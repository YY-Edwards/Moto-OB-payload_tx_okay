
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a1f4  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c200  8000c200  0000c600  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001708  8000c400  8000c400  0000c800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a34  00000008  8000db08  0000e008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a3c  8000e53c  0000ea3c  2**0
                  ALLOC
  8 .bss          000036e0  00000a40  00000a40  00000000  2**2
                  ALLOC
  9 .heap         00012ee0  00004120  00004120  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  0000ea3c  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001140  00000000  00000000  0000ea70  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 000024b1  00000000  00000000  0000fbb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   00028292  00000000  00000000  00012061  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 000067e5  00000000  00000000  0003a2f3  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000c1d2  00000000  00000000  00040ad8  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00002cf0  00000000  00000000  0004ccac  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00006caf  00000000  00000000  0004f99c  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0000c99f  00000000  00000000  0005664b  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 20 .debug_ranges 00001228  00000000  00000000  00062ff0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf 97 28 	sub	pc,pc,-26840

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf b7 2c 	sub	pc,pc,-18644

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d ac       	ld.ub	r12,r6[0x2]

8000202c <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
8000202c:	5e fc       	retal	r12

8000202e <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202e:	5e fc       	retal	r12

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 5c       	eor	r12,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	21 08       	sub	r8,16
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	27 e0       	sub	r0,126
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	28 c8       	sub	r8,-116
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	40 a8       	lddsp	r8,sp[0x28]
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	c4 00       	breq	80002106 <app_cfg+0x72>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	20 94       	sub	r4,9
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	60 4c       	ld.w	r12,r0[0x10]
80002090:	00 00       	add	r0,r0
80002092:	0a 58       	eor	r8,r5

80002094 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002094:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
80002096:	f0 1f 00 17 	mcall	800020f0 <app_cfg+0x5c>
8000209a:	49 78       	lddpc	r8,800020f4 <app_cfg+0x60>
8000209c:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
8000209e:	49 76       	lddpc	r6,800020f8 <app_cfg+0x64>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020a0:	49 74       	lddpc	r4,800020fc <app_cfg+0x68>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020a2:	30 40       	mov	r0,4
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020a4:	30 31       	mov	r1,3
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020a6:	30 22       	mov	r2,2
					//xcmp_enter_device_control_mode();//调换3个命令的顺序，则不会导致掉线。。。奇葩
					//xcmp_unmute_speaker();
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020a8:	30 13       	mov	r3,1
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以2000ms为周期执行。
800020aa:	10 97       	mov	r7,r8
800020ac:	e0 65 0f a0 	mov	r5,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800020b0:	6c 08       	ld.w	r8,r6[0x0]
800020b2:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b6:	58 38       	cp.w	r8,3
800020b8:	c1 71       	brne	800020e6 <app_cfg+0x52>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020ba:	68 08       	ld.w	r8,r4[0x0]
800020bc:	58 08       	cp.w	r8,0
800020be:	c0 51       	brne	800020c8 <app_cfg+0x34>
				{
					//xcmp_data_session();
					xcmp_audio_route_mic();
800020c0:	f0 1f 00 10 	mcall	80002100 <app_cfg+0x6c>
					//xcmp_enter_device_control_mode();//调换3个命令的顺序，则不会导致掉线。。。奇葩
					//xcmp_unmute_speaker();
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020c4:	89 03       	st.w	r4[0x0],r3
800020c6:	c1 08       	rjmp	800020e6 <app_cfg+0x52>
				}
				else if(isAudioRouting == 1)
800020c8:	58 18       	cp.w	r8,1
800020ca:	c0 31       	brne	800020d0 <app_cfg+0x3c>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020cc:	89 02       	st.w	r4[0x0],r2
800020ce:	c0 c8       	rjmp	800020e6 <app_cfg+0x52>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800020d0:	58 28       	cp.w	r8,2
800020d2:	c0 31       	brne	800020d8 <app_cfg+0x44>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020d4:	89 01       	st.w	r4[0x0],r1
800020d6:	c0 88       	rjmp	800020e6 <app_cfg+0x52>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020d8:	58 38       	cp.w	r8,3
800020da:	e9 f0 0a 00 	st.weq	r4[0x0],r0
					
				}
				else
				{
					isAudioRouting++;
800020de:	f7 b8 01 ff 	subne	r8,-1
800020e2:	e9 f8 1a 00 	st.wne	r4[0x0],r8
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以2000ms为周期执行。
800020e6:	0a 9b       	mov	r11,r5
800020e8:	0e 9c       	mov	r12,r7
800020ea:	f0 1f 00 07 	mcall	80002104 <app_cfg+0x70>
	}
800020ee:	ce 1b       	rjmp	800020b0 <app_cfg+0x1c>
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	5d 84       	*unknown*
800020f4:	00 00       	add	r0,r0
800020f6:	0a 50       	eor	r0,r5
800020f8:	00 00       	add	r0,r0
800020fa:	0d ac       	ld.ub	r12,r6[0x2]
800020fc:	00 00       	add	r0,r0
800020fe:	0a 48       	or	r8,r5
80002100:	80 00       	ld.sh	r0,r0[0x0]
80002102:	40 fc       	lddsp	r12,sp[0x3c]
80002104:	80 00       	ld.sh	r0,r0[0x0]
80002106:	5e ec       	retqs	r12

80002108 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002108:	d4 01       	pushm	lr
  log("R");
8000210a:	48 3c       	lddpc	r12,80002114 <app_payload_tx_proc+0xc>
8000210c:	f0 1f 00 03 	mcall	80002118 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002110:	d8 02       	popm	pc
80002112:	00 00       	add	r0,r0
80002114:	80 00       	ld.sh	r0,r0[0x0]
80002116:	c4 08       	rjmp	80002196 <EnOB_reply_func+0x2a>
80002118:	80 00       	ld.sh	r0,r0[0x0]
8000211a:	64 10       	ld.w	r0,r2[0x4]

8000211c <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
8000211c:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000211e:	48 3c       	lddpc	r12,80002128 <FD_brdcst_func+0xc>
80002120:	f0 1f 00 03 	mcall	8000212c <FD_brdcst_func+0x10>
	
}
80002124:	d8 02       	popm	pc
80002126:	00 00       	add	r0,r0
80002128:	80 00       	ld.sh	r0,r0[0x0]
8000212a:	c4 0c       	rcall	800021aa <EnOB_reply_func+0x3e>
8000212c:	80 00       	ld.sh	r0,r0[0x0]
8000212e:	64 10       	ld.w	r0,r2[0x4]

80002130 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002130:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
80002132:	48 3c       	lddpc	r12,8000213c <FD_reply_func+0xc>
80002134:	f0 1f 00 03 	mcall	80002140 <FD_reply_func+0x10>
	
	
}
80002138:	d8 02       	popm	pc
8000213a:	00 00       	add	r0,r0
8000213c:	80 00       	ld.sh	r0,r0[0x0]
8000213e:	c4 2c       	rcall	800021c2 <EnOB_reply_func+0x56>
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	64 10       	ld.w	r0,r2[0x4]

80002144 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002144:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002146:	48 3c       	lddpc	r12,80002150 <FD_request_func+0xc>
80002148:	f0 1f 00 03 	mcall	80002154 <FD_request_func+0x10>
	
	
}
8000214c:	d8 02       	popm	pc
8000214e:	00 00       	add	r0,r0
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	c4 48       	rjmp	800021da <EnOB_reply_func+0x6e>
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	64 10       	ld.w	r0,r2[0x4]

80002158 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002158:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
8000215a:	48 3c       	lddpc	r12,80002164 <EnOB_brdcst_func+0xc>
8000215c:	f0 1f 00 03 	mcall	80002168 <EnOB_brdcst_func+0x10>
}
80002160:	d8 02       	popm	pc
80002162:	00 00       	add	r0,r0
80002164:	80 00       	ld.sh	r0,r0[0x0]
80002166:	c4 64       	brge	800021f2 <SingleDetection_brdcst_func+0x16>
80002168:	80 00       	ld.sh	r0,r0[0x0]
8000216a:	64 10       	ld.w	r0,r2[0x4]

8000216c <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
8000216c:	eb cd 40 80 	pushm	r7,lr
80002170:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
80002172:	19 a9       	ld.ub	r9,r12[0x2]
80002174:	30 08       	mov	r8,0
80002176:	f0 09 18 00 	cp.b	r9,r8
8000217a:	c1 91       	brne	800021ac <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
8000217c:	19 b8       	ld.ub	r8,r12[0x3]
8000217e:	30 19       	mov	r9,1
80002180:	f2 08 18 00 	cp.b	r8,r9
80002184:	c0 61       	brne	80002190 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002186:	49 0c       	lddpc	r12,800021c4 <EnOB_reply_func+0x58>
80002188:	f0 1f 00 10 	mcall	800021c8 <EnOB_reply_func+0x5c>
8000218c:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80002190:	58 08       	cp.w	r8,0
80002192:	c0 61       	brne	8000219e <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002194:	48 ec       	lddpc	r12,800021cc <EnOB_reply_func+0x60>
80002196:	f0 1f 00 0d 	mcall	800021c8 <EnOB_reply_func+0x5c>
8000219a:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000219e:	1a d8       	st.w	--sp,r8
800021a0:	48 cc       	lddpc	r12,800021d0 <EnOB_reply_func+0x64>
800021a2:	f0 1f 00 0a 	mcall	800021c8 <EnOB_reply_func+0x5c>
800021a6:	2f fd       	sub	sp,-4
800021a8:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021ac:	48 ac       	lddpc	r12,800021d4 <EnOB_reply_func+0x68>
800021ae:	f0 1f 00 07 	mcall	800021c8 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021b2:	0f a8       	ld.ub	r8,r7[0x2]
800021b4:	1a d8       	st.w	--sp,r8
800021b6:	48 9c       	lddpc	r12,800021d8 <EnOB_reply_func+0x6c>
800021b8:	f0 1f 00 04 	mcall	800021c8 <EnOB_reply_func+0x5c>
800021bc:	2f fd       	sub	sp,-4
800021be:	e3 cd 80 80 	ldm	sp++,r7,pc
800021c2:	00 00       	add	r0,r0
800021c4:	80 00       	ld.sh	r0,r0[0x0]
800021c6:	c4 7c       	rcall	80002254 <ButtonConfig_brdcst_func+0x38>
800021c8:	80 00       	ld.sh	r0,r0[0x0]
800021ca:	64 10       	ld.w	r0,r2[0x4]
800021cc:	80 00       	ld.sh	r0,r0[0x0]
800021ce:	c4 94       	brge	80002260 <ButtonConfig_brdcst_func+0x44>
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	c4 a8       	rjmp	80002266 <ButtonConfig_brdcst_func+0x4a>
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	c4 c0       	breq	8000226e <ButtonConfig_brdcst_func+0x52>
800021d8:	80 00       	ld.sh	r0,r0[0x0]
800021da:	c4 dc       	rcall	80002274 <ButtonConfig_brdcst_func+0x58>

800021dc <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800021dc:	eb cd 40 80 	pushm	r7,lr
800021e0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
800021e2:	19 a9       	ld.ub	r9,r12[0x2]
800021e4:	31 18       	mov	r8,17
800021e6:	f0 09 18 00 	cp.b	r9,r8
800021ea:	c0 61       	brne	800021f6 <SingleDetection_brdcst_func+0x1a>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021ec:	48 8c       	lddpc	r12,8000220c <SingleDetection_brdcst_func+0x30>
800021ee:	f0 1f 00 09 	mcall	80002210 <SingleDetection_brdcst_func+0x34>
800021f2:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error");
800021f6:	48 8c       	lddpc	r12,80002214 <SingleDetection_brdcst_func+0x38>
800021f8:	f0 1f 00 06 	mcall	80002210 <SingleDetection_brdcst_func+0x34>
		log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
800021fc:	0f a8       	ld.ub	r8,r7[0x2]
800021fe:	1a d8       	st.w	--sp,r8
80002200:	48 6c       	lddpc	r12,80002218 <SingleDetection_brdcst_func+0x3c>
80002202:	f0 1f 00 04 	mcall	80002210 <SingleDetection_brdcst_func+0x34>
80002206:	2f fd       	sub	sp,-4
80002208:	e3 cd 80 80 	ldm	sp++,r7,pc
8000220c:	80 00       	ld.sh	r0,r0[0x0]
8000220e:	c4 f4       	brge	800022ac <ButtonConfig_brdcst_func+0x90>
80002210:	80 00       	ld.sh	r0,r0[0x0]
80002212:	64 10       	ld.w	r0,r2[0x4]
80002214:	80 00       	ld.sh	r0,r0[0x0]
80002216:	c5 08       	rjmp	800022b6 <ButtonConfig_brdcst_func+0x9a>
80002218:	80 00       	ld.sh	r0,r0[0x0]
8000221a:	c5 18       	rjmp	800022bc <ButtonConfig_brdcst_func+0xa0>

8000221c <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
8000221c:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
8000221e:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
80002222:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002224:	4a bc       	lddpc	r12,800022d0 <ButtonConfig_brdcst_func+0xb4>
80002226:	f0 1f 00 2c 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
8000222a:	0f 88       	ld.ub	r8,r7[0x0]
8000222c:	1a d8       	st.w	--sp,r8
8000222e:	4a bc       	lddpc	r12,800022d8 <ButtonConfig_brdcst_func+0xbc>
80002230:	f0 1f 00 29 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002234:	1a d5       	st.w	--sp,r5
80002236:	4a ac       	lddpc	r12,800022dc <ButtonConfig_brdcst_func+0xc0>
80002238:	f0 1f 00 27 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
8000223c:	0f a8       	ld.ub	r8,r7[0x2]
8000223e:	1a d8       	st.w	--sp,r8
80002240:	4a 8c       	lddpc	r12,800022e0 <ButtonConfig_brdcst_func+0xc4>
80002242:	f0 1f 00 25 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
80002246:	2f dd       	sub	sp,-12
80002248:	58 05       	cp.w	r5,0
8000224a:	c4 10       	breq	800022cc <ButtonConfig_brdcst_func+0xb0>
8000224c:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000224e:	4a 64       	lddpc	r4,800022e4 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002250:	4a 63       	lddpc	r3,800022e8 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002252:	4a 72       	lddpc	r2,800022ec <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002254:	4a 71       	lddpc	r1,800022f0 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002256:	4a 80       	lddpc	r0,800022f4 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002258:	0f b9       	ld.ub	r9,r7[0x3]
8000225a:	0f c8       	ld.ub	r8,r7[0x4]
8000225c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002260:	1a d8       	st.w	--sp,r8
80002262:	1a d6       	st.w	--sp,r6
80002264:	08 9c       	mov	r12,r4
80002266:	f0 1f 00 1c 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000226a:	0f d9       	ld.ub	r9,r7[0x5]
8000226c:	0f e8       	ld.ub	r8,r7[0x6]
8000226e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002272:	1a d8       	st.w	--sp,r8
80002274:	1a d6       	st.w	--sp,r6
80002276:	06 9c       	mov	r12,r3
80002278:	f0 1f 00 17 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000227c:	0f f9       	ld.ub	r9,r7[0x7]
8000227e:	ef 38 00 08 	ld.ub	r8,r7[8]
80002282:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002286:	1a d8       	st.w	--sp,r8
80002288:	1a d6       	st.w	--sp,r6
8000228a:	04 9c       	mov	r12,r2
8000228c:	f0 1f 00 12 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002290:	ef 39 00 09 	ld.ub	r9,r7[9]
80002294:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002298:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000229c:	1a d8       	st.w	--sp,r8
8000229e:	1a d6       	st.w	--sp,r6
800022a0:	02 9c       	mov	r12,r1
800022a2:	f0 1f 00 0d 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800022a6:	2f 8d       	sub	sp,-32
800022a8:	ef 39 00 0b 	ld.ub	r9,r7[11]
800022ac:	ef 38 00 0c 	ld.ub	r8,r7[12]
800022b0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022b4:	1a d8       	st.w	--sp,r8
800022b6:	1a d6       	st.w	--sp,r6
800022b8:	00 9c       	mov	r12,r0
800022ba:	f0 1f 00 07 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
800022be:	2f f6       	sub	r6,-1
800022c0:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022c2:	2f ed       	sub	sp,-8
800022c4:	ec 05 18 00 	cp.b	r5,r6
800022c8:	fe 9b ff c8 	brhi	80002258 <ButtonConfig_brdcst_func+0x3c>
800022cc:	d8 32       	popm	r0-r7,pc
800022ce:	00 00       	add	r0,r0
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	c5 30       	breq	80002378 <ButtonConfig_reply_func+0x8>
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	64 10       	ld.w	r0,r2[0x4]
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	c5 50       	breq	80002384 <ButtonConfig_reply_func+0x14>
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	c5 64       	brge	8000238a <ButtonConfig_reply_func+0x1a>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	c5 7c       	rcall	80002390 <ButtonConfig_reply_func+0x20>
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	c5 9c       	rcall	80002398 <ButtonConfig_reply_func+0x28>
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	c5 c4       	brge	800023a2 <ButtonConfig_reply_func+0x32>
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	c5 ec       	rcall	800023aa <ButtonConfig_reply_func+0x3a>
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	c6 10       	breq	800023b4 <DataSession_brdcst_func>
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	c6 38       	rjmp	800023bc <DataSession_brdcst_func+0x8>

800022f8 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022f8:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
800022fc:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
800022fe:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002300:	19 c7       	ld.ub	r7,r12[0x4]
80002302:	19 d8       	ld.ub	r8,r12[0x5]
80002304:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002308:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
8000230a:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
8000230c:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002310:	49 0c       	lddpc	r12,80002350 <Phyuserinput_brdcst_func+0x58>
80002312:	f0 1f 00 11 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
80002316:	1a d6       	st.w	--sp,r6
80002318:	49 0c       	lddpc	r12,80002358 <Phyuserinput_brdcst_func+0x60>
8000231a:	f0 1f 00 0f 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
8000231e:	1a d5       	st.w	--sp,r5
80002320:	48 fc       	lddpc	r12,8000235c <Phyuserinput_brdcst_func+0x64>
80002322:	f0 1f 00 0d 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
80002326:	5c 77       	castu.h	r7
80002328:	1a d7       	st.w	--sp,r7
8000232a:	48 ec       	lddpc	r12,80002360 <Phyuserinput_brdcst_func+0x68>
8000232c:	f0 1f 00 0a 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002330:	1a d4       	st.w	--sp,r4
80002332:	48 dc       	lddpc	r12,80002364 <Phyuserinput_brdcst_func+0x6c>
80002334:	f0 1f 00 08 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
80002338:	1a d3       	st.w	--sp,r3
8000233a:	48 cc       	lddpc	r12,80002368 <Phyuserinput_brdcst_func+0x70>
8000233c:	f0 1f 00 06 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
80002340:	1a d2       	st.w	--sp,r2
80002342:	48 bc       	lddpc	r12,8000236c <Phyuserinput_brdcst_func+0x74>
80002344:	f0 1f 00 04 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
80002348:	2f ad       	sub	sp,-24
	
	
	
	
	
}
8000234a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000234e:	00 00       	add	r0,r0
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	c6 5c       	rcall	8000241c <DataSession_brdcst_func+0x68>
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	64 10       	ld.w	r0,r2[0x4]
80002358:	80 00       	ld.sh	r0,r0[0x0]
8000235a:	c6 80       	breq	8000242a <DataSession_brdcst_func+0x76>
8000235c:	80 00       	ld.sh	r0,r0[0x0]
8000235e:	c6 98       	rjmp	80002430 <DataSession_brdcst_func+0x7c>
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	c6 ac       	rcall	80002436 <DataSession_brdcst_func+0x82>
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	c6 c0       	breq	8000243e <DataSession_reply_func+0x6>
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	c6 d4       	brge	80002444 <DataSession_reply_func+0xc>
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	c6 f4       	brge	8000244c <DataSession_reply_func+0x14>

80002370 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002370:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002374:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002378:	0f 89       	ld.ub	r9,r7[0x0]
8000237a:	30 08       	mov	r8,0
8000237c:	f0 09 18 00 	cp.b	r9,r8
80002380:	c0 c1       	brne	80002398 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
80002382:	48 9c       	lddpc	r12,800023a4 <ButtonConfig_reply_func+0x34>
80002384:	f0 1f 00 09 	mcall	800023a8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002388:	0f 98       	ld.ub	r8,r7[0x1]
8000238a:	1a d8       	st.w	--sp,r8
8000238c:	48 8c       	lddpc	r12,800023ac <ButtonConfig_reply_func+0x3c>
8000238e:	f0 1f 00 07 	mcall	800023a8 <ButtonConfig_reply_func+0x38>
80002392:	2f fd       	sub	sp,-4
80002394:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002398:	48 6c       	lddpc	r12,800023b0 <ButtonConfig_reply_func+0x40>
8000239a:	f0 1f 00 04 	mcall	800023a8 <ButtonConfig_reply_func+0x38>
8000239e:	e3 cd 80 80 	ldm	sp++,r7,pc
800023a2:	00 00       	add	r0,r0
800023a4:	80 00       	ld.sh	r0,r0[0x0]
800023a6:	c7 14       	brge	80002488 <DataSession_reply_func+0x50>
800023a8:	80 00       	ld.sh	r0,r0[0x0]
800023aa:	64 10       	ld.w	r0,r2[0x4]
800023ac:	80 00       	ld.sh	r0,r0[0x0]
800023ae:	c5 50       	breq	80002458 <DataSession_reply_func+0x20>
800023b0:	80 00       	ld.sh	r0,r0[0x0]
800023b2:	c7 2c       	rcall	80002496 <TransmitControl_brdcst_func+0x6>

800023b4 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800023b4:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800023b6:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
800023ba:	0d 88       	ld.ub	r8,r6[0x0]
800023bc:	32 49       	mov	r9,36
800023be:	f2 08 18 00 	cp.b	r8,r9
800023c2:	c2 91       	brne	80002414 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800023c4:	49 7c       	lddpc	r12,80002420 <DataSession_brdcst_func+0x6c>
800023c6:	f0 1f 00 18 	mcall	80002424 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023ca:	0d a5       	ld.ub	r5,r6[0x2]
800023cc:	0d b8       	ld.ub	r8,r6[0x3]
800023ce:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800023d2:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800023d4:	0d 98       	ld.ub	r8,r6[0x1]
800023d6:	1a d8       	st.w	--sp,r8
800023d8:	49 4c       	lddpc	r12,80002428 <DataSession_brdcst_func+0x74>
800023da:	f0 1f 00 13 	mcall	80002424 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023de:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800023e2:	1a d8       	st.w	--sp,r8
800023e4:	49 2c       	lddpc	r12,8000242c <DataSession_brdcst_func+0x78>
800023e6:	f0 1f 00 10 	mcall	80002424 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
800023ea:	2f ed       	sub	sp,-8
800023ec:	58 05       	cp.w	r5,0
800023ee:	c1 80       	breq	8000241e <DataSession_brdcst_func+0x6a>
800023f0:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800023f2:	49 04       	lddpc	r4,80002430 <DataSession_brdcst_func+0x7c>
800023f4:	ec 07 00 08 	add	r8,r6,r7
800023f8:	11 c8       	ld.ub	r8,r8[0x4]
800023fa:	1a d8       	st.w	--sp,r8
800023fc:	1a d7       	st.w	--sp,r7
800023fe:	08 9c       	mov	r12,r4
80002400:	f0 1f 00 09 	mcall	80002424 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002404:	2f f7       	sub	r7,-1
80002406:	5c 57       	castu.b	r7
80002408:	2f ed       	sub	sp,-8
8000240a:	ee 05 19 00 	cp.h	r5,r7
8000240e:	fe 9b ff f3 	brhi	800023f4 <DataSession_brdcst_func+0x40>
80002412:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002414:	1a d8       	st.w	--sp,r8
80002416:	48 8c       	lddpc	r12,80002434 <DataSession_brdcst_func+0x80>
80002418:	f0 1f 00 03 	mcall	80002424 <DataSession_brdcst_func+0x70>
8000241c:	2f fd       	sub	sp,-4
8000241e:	d8 22       	popm	r4-r7,pc
80002420:	80 00       	ld.sh	r0,r0[0x0]
80002422:	c7 48       	rjmp	8000250a <TransmitControl_reply_func+0x32>
80002424:	80 00       	ld.sh	r0,r0[0x0]
80002426:	64 10       	ld.w	r0,r2[0x4]
80002428:	80 00       	ld.sh	r0,r0[0x0]
8000242a:	c7 5c       	rcall	80002514 <TransmitControl_reply_func+0x3c>
8000242c:	80 00       	ld.sh	r0,r0[0x0]
8000242e:	c7 74       	brge	8000251c <TransmitControl_reply_func+0x44>
80002430:	80 00       	ld.sh	r0,r0[0x0]
80002432:	c7 90       	breq	80002524 <TransmitControl_reply_func+0x4c>
80002434:	80 00       	ld.sh	r0,r0[0x0]
80002436:	c7 a8       	rjmp	8000252a <TransmitControl_reply_func+0x52>

80002438 <DataSession_reply_func>:
	
}


void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002438:	eb cd 40 80 	pushm	r7,lr
8000243c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000243e:	19 a8       	ld.ub	r8,r12[0x2]
80002440:	58 08       	cp.w	r8,0
80002442:	c0 61       	brne	8000244e <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
80002444:	48 dc       	lddpc	r12,80002478 <DataSession_reply_func+0x40>
80002446:	f0 1f 00 0e 	mcall	8000247c <DataSession_reply_func+0x44>
8000244a:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
8000244e:	1a d8       	st.w	--sp,r8
80002450:	48 cc       	lddpc	r12,80002480 <DataSession_reply_func+0x48>
80002452:	f0 1f 00 0b 	mcall	8000247c <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
80002456:	48 cc       	lddpc	r12,80002484 <DataSession_reply_func+0x4c>
80002458:	f0 1f 00 09 	mcall	8000247c <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
8000245c:	0f b8       	ld.ub	r8,r7[0x3]
8000245e:	1a d8       	st.w	--sp,r8
80002460:	48 ac       	lddpc	r12,80002488 <DataSession_reply_func+0x50>
80002462:	f0 1f 00 07 	mcall	8000247c <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
80002466:	0f c8       	ld.ub	r8,r7[0x4]
80002468:	1a d8       	st.w	--sp,r8
8000246a:	48 9c       	lddpc	r12,8000248c <DataSession_reply_func+0x54>
8000246c:	f0 1f 00 04 	mcall	8000247c <DataSession_reply_func+0x44>
80002470:	2f dd       	sub	sp,-12
80002472:	e3 cd 80 80 	ldm	sp++,r7,pc
80002476:	00 00       	add	r0,r0
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	c7 bc       	rcall	80002570 <Volume_reply_func+0x1c>
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	64 10       	ld.w	r0,r2[0x4]
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	c7 d0       	breq	8000257c <Volume_reply_func+0x28>
80002484:	80 00       	ld.sh	r0,r0[0x0]
80002486:	c7 e4       	brge	80002582 <Volume_reply_func+0x2e>
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	c7 f8       	rjmp	80002588 <Volume_reply_func+0x34>
8000248c:	80 00       	ld.sh	r0,r0[0x0]
8000248e:	c8 08       	rjmp	8000258e <Volume_reply_func+0x3a>

80002490 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002490:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002494:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002498:	0f 99       	ld.ub	r9,r7[0x1]
8000249a:	30 08       	mov	r8,0
8000249c:	f0 09 18 00 	cp.b	r9,r8
800024a0:	c0 71       	brne	800024ae <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800024a2:	48 ac       	lddpc	r12,800024c8 <TransmitControl_brdcst_func+0x38>
800024a4:	f0 1f 00 0a 	mcall	800024cc <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800024a8:	30 09       	mov	r9,0
800024aa:	48 a8       	lddpc	r8,800024d0 <TransmitControl_brdcst_func+0x40>
800024ac:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800024ae:	0f 99       	ld.ub	r9,r7[0x1]
800024b0:	30 18       	mov	r8,1
800024b2:	f0 09 18 00 	cp.b	r9,r8
800024b6:	c0 71       	brne	800024c4 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800024b8:	48 7c       	lddpc	r12,800024d4 <TransmitControl_brdcst_func+0x44>
800024ba:	f0 1f 00 05 	mcall	800024cc <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800024be:	30 19       	mov	r9,1
800024c0:	48 48       	lddpc	r8,800024d0 <TransmitControl_brdcst_func+0x40>
800024c2:	b0 89       	st.b	r8[0x0],r9
800024c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	c8 18       	rjmp	800025cc <spk_brdcst_func+0x14>
800024cc:	80 00       	ld.sh	r0,r0[0x0]
800024ce:	64 10       	ld.w	r0,r2[0x4]
800024d0:	00 00       	add	r0,r0
800024d2:	0a 44       	or	r4,r5
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	c8 30       	breq	800023dc <DataSession_brdcst_func+0x28>

800024d8 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
800024d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
800024dc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
800024e0:	0f 89       	ld.ub	r9,r7[0x0]
800024e2:	30 08       	mov	r8,0
800024e4:	f0 09 18 00 	cp.b	r9,r8
800024e8:	c2 21       	brne	8000252c <TransmitControl_reply_func+0x54>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
800024ea:	49 4c       	lddpc	r12,80002538 <TransmitControl_reply_func+0x60>
800024ec:	f0 1f 00 14 	mcall	8000253c <TransmitControl_reply_func+0x64>
		log("\n\r Function: %x \n\r", ptr->Function);
800024f0:	0f 98       	ld.ub	r8,r7[0x1]
800024f2:	1a d8       	st.w	--sp,r8
800024f4:	49 3c       	lddpc	r12,80002540 <TransmitControl_reply_func+0x68>
800024f6:	f0 1f 00 12 	mcall	8000253c <TransmitControl_reply_func+0x64>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800024fa:	0f a8       	ld.ub	r8,r7[0x2]
800024fc:	1a d8       	st.w	--sp,r8
800024fe:	49 2c       	lddpc	r12,80002544 <TransmitControl_reply_func+0x6c>
80002500:	f0 1f 00 0f 	mcall	8000253c <TransmitControl_reply_func+0x64>
		log("\n\r State: %x \n\r", ptr->State);
80002504:	0f b8       	ld.ub	r8,r7[0x3]
80002506:	1a d8       	st.w	--sp,r8
80002508:	49 0c       	lddpc	r12,80002548 <TransmitControl_reply_func+0x70>
8000250a:	f0 1f 00 0d 	mcall	8000253c <TransmitControl_reply_func+0x64>
		
		if (ptr->Function == KEY_UP)
8000250e:	0f 98       	ld.ub	r8,r7[0x1]
80002510:	2f dd       	sub	sp,-12
80002512:	30 19       	mov	r9,1
80002514:	f2 08 18 00 	cp.b	r8,r9
80002518:	c0 d0       	breq	80002532 <TransmitControl_reply_func+0x5a>
		{
			//is_unmute = 1;
		}
		else if (ptr->Function ==DE_KEY)
8000251a:	30 29       	mov	r9,2
8000251c:	f2 08 18 00 	cp.b	r8,r9
80002520:	c0 91       	brne	80002532 <TransmitControl_reply_func+0x5a>
		{
			is_unmute = 0;
80002522:	30 09       	mov	r9,0
80002524:	48 a8       	lddpc	r8,8000254c <TransmitControl_reply_func+0x74>
80002526:	b0 89       	st.b	r8[0x0],r9
80002528:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
8000252c:	48 9c       	lddpc	r12,80002550 <TransmitControl_reply_func+0x78>
8000252e:	f0 1f 00 04 	mcall	8000253c <TransmitControl_reply_func+0x64>
80002532:	e3 cd 80 80 	ldm	sp++,r7,pc
80002536:	00 00       	add	r0,r0
80002538:	80 00       	ld.sh	r0,r0[0x0]
8000253a:	c8 44       	brge	80002442 <DataSession_reply_func+0xa>
8000253c:	80 00       	ld.sh	r0,r0[0x0]
8000253e:	64 10       	ld.w	r0,r2[0x4]
80002540:	80 00       	ld.sh	r0,r0[0x0]
80002542:	c8 60       	breq	8000244e <DataSession_reply_func+0x16>
80002544:	80 00       	ld.sh	r0,r0[0x0]
80002546:	c8 74       	brge	80002454 <DataSession_reply_func+0x1c>
80002548:	80 00       	ld.sh	r0,r0[0x0]
8000254a:	c8 90       	breq	8000245c <DataSession_reply_func+0x24>
8000254c:	00 00       	add	r0,r0
8000254e:	0a 4c       	or	r12,r5
80002550:	80 00       	ld.sh	r0,r0[0x0]
80002552:	c8 a0       	breq	80002466 <DataSession_reply_func+0x2e>

80002554 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002554:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002558:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000255c:	0f 89       	ld.ub	r9,r7[0x0]
8000255e:	30 08       	mov	r8,0
80002560:	f0 09 18 00 	cp.b	r9,r8
80002564:	c1 b1       	brne	8000259a <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002566:	0f b8       	ld.ub	r8,r7[0x3]
80002568:	31 09       	mov	r9,16
8000256a:	f2 08 18 00 	cp.b	r8,r9
8000256e:	c0 f1       	brne	8000258c <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002570:	48 dc       	lddpc	r12,800025a4 <Volume_reply_func+0x50>
80002572:	f0 1f 00 0e 	mcall	800025a8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002576:	0f 99       	ld.ub	r9,r7[0x1]
80002578:	0f a8       	ld.ub	r8,r7[0x2]
8000257a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000257e:	1a d8       	st.w	--sp,r8
80002580:	48 bc       	lddpc	r12,800025ac <Volume_reply_func+0x58>
80002582:	f0 1f 00 0a 	mcall	800025a8 <Volume_reply_func+0x54>
80002586:	2f fd       	sub	sp,-4
80002588:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
8000258c:	1a d8       	st.w	--sp,r8
8000258e:	48 9c       	lddpc	r12,800025b0 <Volume_reply_func+0x5c>
80002590:	f0 1f 00 06 	mcall	800025a8 <Volume_reply_func+0x54>
80002594:	2f fd       	sub	sp,-4
80002596:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
8000259a:	48 7c       	lddpc	r12,800025b4 <Volume_reply_func+0x60>
8000259c:	f0 1f 00 03 	mcall	800025a8 <Volume_reply_func+0x54>
800025a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025a4:	80 00       	ld.sh	r0,r0[0x0]
800025a6:	c8 b8       	rjmp	800026bc <mic_reply_func+0x48>
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	64 10       	ld.w	r0,r2[0x4]
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	c8 cc       	rcall	800026c6 <mic_reply_func+0x52>
800025b0:	80 00       	ld.sh	r0,r0[0x0]
800025b2:	c8 e8       	rjmp	800026ce <mic_reply_func+0x5a>
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	c9 00       	breq	800024d6 <TransmitControl_brdcst_func+0x46>

800025b8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025b8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025ba:	19 d9       	ld.ub	r9,r12[0x5]
800025bc:	30 08       	mov	r8,0
800025be:	f0 09 18 00 	cp.b	r9,r8
800025c2:	c0 81       	brne	800025d2 <spk_brdcst_func+0x1a>
	{
		is_unmute =0;
800025c4:	10 99       	mov	r9,r8
800025c6:	48 68       	lddpc	r8,800025dc <spk_brdcst_func+0x24>
800025c8:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
800025ca:	48 6c       	lddpc	r12,800025e0 <spk_brdcst_func+0x28>
800025cc:	f0 1f 00 06 	mcall	800025e4 <spk_brdcst_func+0x2c>
800025d0:	d8 02       	popm	pc
	}
	else
	{
		//Silent_flag = 1;
		//is_unmute = 1;
		log("spk_s_open ");
800025d2:	48 6c       	lddpc	r12,800025e8 <spk_brdcst_func+0x30>
800025d4:	f0 1f 00 04 	mcall	800025e4 <spk_brdcst_func+0x2c>
800025d8:	d8 02       	popm	pc
800025da:	00 00       	add	r0,r0
800025dc:	00 00       	add	r0,r0
800025de:	0a 4c       	or	r12,r5
800025e0:	80 00       	ld.sh	r0,r0[0x0]
800025e2:	c9 18       	rjmp	80002704 <mic_reply_func+0x90>
800025e4:	80 00       	ld.sh	r0,r0[0x0]
800025e6:	64 10       	ld.w	r0,r2[0x4]
800025e8:	80 00       	ld.sh	r0,r0[0x0]
800025ea:	c9 28       	rjmp	8000270e <dcm_brdcst_func+0x6>

800025ec <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800025ec:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025ee:	19 a9       	ld.ub	r9,r12[0x2]
800025f0:	30 08       	mov	r8,0
800025f2:	f0 09 18 00 	cp.b	r9,r8
800025f6:	c0 f1       	brne	80002614 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
800025f8:	19 e9       	ld.ub	r9,r12[0x6]
800025fa:	f0 09 18 00 	cp.b	r9,r8
800025fe:	c0 40       	breq	80002606 <spk_reply_func+0x1a>
		{
			is_unmute = 1;
80002600:	30 19       	mov	r9,1
80002602:	48 78       	lddpc	r8,8000261c <spk_reply_func+0x30>
80002604:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002606:	19 e8       	ld.ub	r8,r12[0x6]
80002608:	1a d8       	st.w	--sp,r8
8000260a:	48 6c       	lddpc	r12,80002620 <spk_reply_func+0x34>
8000260c:	f0 1f 00 06 	mcall	80002624 <spk_reply_func+0x38>
80002610:	2f fd       	sub	sp,-4
80002612:	d8 02       	popm	pc
		
	}
	else
	{
		log("spk error");
80002614:	48 5c       	lddpc	r12,80002628 <spk_reply_func+0x3c>
80002616:	f0 1f 00 04 	mcall	80002624 <spk_reply_func+0x38>
8000261a:	d8 02       	popm	pc
8000261c:	00 00       	add	r0,r0
8000261e:	0a 4c       	or	r12,r5
80002620:	80 00       	ld.sh	r0,r0[0x0]
80002622:	c9 34       	brge	80002548 <TransmitControl_reply_func+0x70>
80002624:	80 00       	ld.sh	r0,r0[0x0]
80002626:	64 10       	ld.w	r0,r2[0x4]
80002628:	80 00       	ld.sh	r0,r0[0x0]
8000262a:	c9 44       	brge	80002552 <TransmitControl_reply_func+0x7a>

8000262c <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
8000262c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002630:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002634:	0f a9       	ld.ub	r9,r7[0x2]
80002636:	30 08       	mov	r8,0
80002638:	f0 09 18 00 	cp.b	r9,r8
8000263c:	c0 71       	brne	8000264a <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000263e:	48 ac       	lddpc	r12,80002664 <mic_brdcst_func+0x38>
80002640:	f0 1f 00 0a 	mcall	80002668 <mic_brdcst_func+0x3c>
		Mic_is_Enabled = 0;
80002644:	30 09       	mov	r9,0
80002646:	48 a8       	lddpc	r8,8000266c <mic_brdcst_func+0x40>
80002648:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
8000264a:	0f a9       	ld.ub	r9,r7[0x2]
8000264c:	31 18       	mov	r8,17
8000264e:	f0 09 18 00 	cp.b	r9,r8
80002652:	c0 71       	brne	80002660 <mic_brdcst_func+0x34>
	{
		log("\n\r Mic_Enabled \n\r");	
80002654:	48 7c       	lddpc	r12,80002670 <mic_brdcst_func+0x44>
80002656:	f0 1f 00 05 	mcall	80002668 <mic_brdcst_func+0x3c>
		Mic_is_Enabled = 1;
8000265a:	30 19       	mov	r9,1
8000265c:	48 48       	lddpc	r8,8000266c <mic_brdcst_func+0x40>
8000265e:	b0 89       	st.b	r8[0x0],r9
80002660:	e3 cd 80 80 	ldm	sp++,r7,pc
80002664:	80 00       	ld.sh	r0,r0[0x0]
80002666:	c9 50       	breq	80002590 <Volume_reply_func+0x3c>
80002668:	80 00       	ld.sh	r0,r0[0x0]
8000266a:	64 10       	ld.w	r0,r2[0x4]
8000266c:	00 00       	add	r0,r0
8000266e:	0a 43       	or	r3,r5
80002670:	80 00       	ld.sh	r0,r0[0x0]
80002672:	c9 64       	brge	8000259e <Volume_reply_func+0x4a>

80002674 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002674:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002678:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
8000267c:	49 ac       	lddpc	r12,800026e4 <mic_reply_func+0x70>
8000267e:	f0 1f 00 1b 	mcall	800026e8 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
80002682:	0f 89       	ld.ub	r9,r7[0x0]
80002684:	30 08       	mov	r8,0
80002686:	f0 09 18 00 	cp.b	r9,r8
8000268a:	c2 71       	brne	800026d8 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
8000268c:	0f 98       	ld.ub	r8,r7[0x1]
8000268e:	30 29       	mov	r9,2
80002690:	f2 08 18 00 	cp.b	r8,r9
80002694:	c1 b1       	brne	800026ca <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002696:	49 6c       	lddpc	r12,800026ec <mic_reply_func+0x78>
80002698:	f0 1f 00 14 	mcall	800026e8 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
8000269c:	0f a8       	ld.ub	r8,r7[0x2]
8000269e:	1a d8       	st.w	--sp,r8
800026a0:	49 4c       	lddpc	r12,800026f0 <mic_reply_func+0x7c>
800026a2:	f0 1f 00 12 	mcall	800026e8 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800026a6:	0f b8       	ld.ub	r8,r7[0x3]
800026a8:	1a d8       	st.w	--sp,r8
800026aa:	49 3c       	lddpc	r12,800026f4 <mic_reply_func+0x80>
800026ac:	f0 1f 00 0f 	mcall	800026e8 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800026b0:	0f c8       	ld.ub	r8,r7[0x4]
800026b2:	1a d8       	st.w	--sp,r8
800026b4:	49 1c       	lddpc	r12,800026f8 <mic_reply_func+0x84>
800026b6:	f0 1f 00 0d 	mcall	800026e8 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800026ba:	0f d8       	ld.ub	r8,r7[0x5]
800026bc:	1a d8       	st.w	--sp,r8
800026be:	49 0c       	lddpc	r12,800026fc <mic_reply_func+0x88>
800026c0:	f0 1f 00 0a 	mcall	800026e8 <mic_reply_func+0x74>
800026c4:	2f cd       	sub	sp,-16
800026c6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026ca:	1a d8       	st.w	--sp,r8
800026cc:	48 dc       	lddpc	r12,80002700 <mic_reply_func+0x8c>
800026ce:	f0 1f 00 07 	mcall	800026e8 <mic_reply_func+0x74>
800026d2:	2f fd       	sub	sp,-4
800026d4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026d8:	48 bc       	lddpc	r12,80002704 <mic_reply_func+0x90>
800026da:	f0 1f 00 04 	mcall	800026e8 <mic_reply_func+0x74>
800026de:	e3 cd 80 80 	ldm	sp++,r7,pc
800026e2:	00 00       	add	r0,r0
800026e4:	80 00       	ld.sh	r0,r0[0x0]
800026e6:	c9 78       	rjmp	80002814 <app_payload_rx_proc+0x34>
800026e8:	80 00       	ld.sh	r0,r0[0x0]
800026ea:	64 10       	ld.w	r0,r2[0x4]
800026ec:	80 00       	ld.sh	r0,r0[0x0]
800026ee:	c9 88       	rjmp	8000281e <app_payload_rx_proc+0x3e>
800026f0:	80 00       	ld.sh	r0,r0[0x0]
800026f2:	c9 9c       	rcall	80002824 <AudioRoutingControl_reply_func>
800026f4:	80 00       	ld.sh	r0,r0[0x0]
800026f6:	c9 b0       	breq	8000262c <mic_brdcst_func>
800026f8:	80 00       	ld.sh	r0,r0[0x0]
800026fa:	c9 cc       	rcall	80002832 <AudioRoutingControl_reply_func+0xe>
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	c9 e4       	brge	8000263a <mic_brdcst_func+0xe>
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	c9 fc       	rcall	80002840 <AudioRoutingControl_reply_func+0x1c>
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	ca 14       	brge	80002648 <mic_brdcst_func+0x1c>

80002708 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002708:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
8000270c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002710:	48 bc       	lddpc	r12,8000273c <dcm_brdcst_func+0x34>
80002712:	f0 1f 00 0c 	mcall	80002740 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002716:	0f 88       	ld.ub	r8,r7[0x0]
80002718:	1a d8       	st.w	--sp,r8
8000271a:	48 bc       	lddpc	r12,80002744 <dcm_brdcst_func+0x3c>
8000271c:	f0 1f 00 09 	mcall	80002740 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002720:	0f a8       	ld.ub	r8,r7[0x2]
80002722:	1a d8       	st.w	--sp,r8
80002724:	48 9c       	lddpc	r12,80002748 <dcm_brdcst_func+0x40>
80002726:	f0 1f 00 07 	mcall	80002740 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000272a:	0f 98       	ld.ub	r8,r7[0x1]
8000272c:	1a d8       	st.w	--sp,r8
8000272e:	48 8c       	lddpc	r12,8000274c <dcm_brdcst_func+0x44>
80002730:	f0 1f 00 04 	mcall	80002740 <dcm_brdcst_func+0x38>
80002734:	2f dd       	sub	sp,-12
	
	
}
80002736:	e3 cd 80 80 	ldm	sp++,r7,pc
8000273a:	00 00       	add	r0,r0
8000273c:	80 00       	ld.sh	r0,r0[0x0]
8000273e:	ca 24       	brge	80002682 <mic_reply_func+0xe>
80002740:	80 00       	ld.sh	r0,r0[0x0]
80002742:	64 10       	ld.w	r0,r2[0x4]
80002744:	80 00       	ld.sh	r0,r0[0x0]
80002746:	ca 38       	rjmp	8000288c <DeviceInitializationStatus_brdcst_func+0x18>
80002748:	80 00       	ld.sh	r0,r0[0x0]
8000274a:	ca 4c       	rcall	80002892 <DeviceInitializationStatus_brdcst_func+0x1e>
8000274c:	80 00       	ld.sh	r0,r0[0x0]
8000274e:	ca 64       	brge	8000269a <mic_reply_func+0x26>

80002750 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002750:	eb cd 40 80 	pushm	r7,lr
80002754:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002756:	19 a9       	ld.ub	r9,r12[0x2]
80002758:	30 08       	mov	r8,0
8000275a:	f0 09 18 00 	cp.b	r9,r8
8000275e:	c1 b1       	brne	80002794 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002760:	19 b8       	ld.ub	r8,r12[0x3]
80002762:	30 19       	mov	r9,1
80002764:	f2 08 18 00 	cp.b	r8,r9
80002768:	c0 51       	brne	80002772 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
8000276a:	48 ec       	lddpc	r12,800027a0 <dcm_reply_func+0x50>
8000276c:	f0 1f 00 0e 	mcall	800027a4 <dcm_reply_func+0x54>
80002770:	c0 a8       	rjmp	80002784 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
80002772:	58 08       	cp.w	r8,0
80002774:	c0 51       	brne	8000277e <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002776:	48 dc       	lddpc	r12,800027a8 <dcm_reply_func+0x58>
80002778:	f0 1f 00 0b 	mcall	800027a4 <dcm_reply_func+0x54>
8000277c:	c0 48       	rjmp	80002784 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000277e:	48 cc       	lddpc	r12,800027ac <dcm_reply_func+0x5c>
80002780:	f0 1f 00 09 	mcall	800027a4 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002784:	0f d8       	ld.ub	r8,r7[0x5]
80002786:	1a d8       	st.w	--sp,r8
80002788:	48 ac       	lddpc	r12,800027b0 <dcm_reply_func+0x60>
8000278a:	f0 1f 00 07 	mcall	800027a4 <dcm_reply_func+0x54>
8000278e:	2f fd       	sub	sp,-4
80002790:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002794:	48 8c       	lddpc	r12,800027b4 <dcm_reply_func+0x64>
80002796:	f0 1f 00 04 	mcall	800027a4 <dcm_reply_func+0x54>
8000279a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000279e:	00 00       	add	r0,r0
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	ca 80       	breq	800026f2 <mic_reply_func+0x7e>
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	64 10       	ld.w	r0,r2[0x4]
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	ca 94       	brge	800026fc <mic_reply_func+0x88>
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	ca a8       	rjmp	80002902 <payload_rx_process+0x2>
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	ca bc       	rcall	80002908 <payload_rx_process+0x8>
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	ca c8       	rjmp	8000290e <payload_rx_process+0xe>

800027b8 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800027b8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800027ba:	19 a9       	ld.ub	r9,r12[0x2]
800027bc:	30 08       	mov	r8,0
800027be:	f0 09 18 00 	cp.b	r9,r8
800027c2:	c0 51       	brne	800027cc <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
800027c4:	48 4c       	lddpc	r12,800027d4 <ToneControl_reply_func+0x1c>
800027c6:	f0 1f 00 05 	mcall	800027d8 <ToneControl_reply_func+0x20>
800027ca:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027cc:	48 4c       	lddpc	r12,800027dc <ToneControl_reply_func+0x24>
800027ce:	f0 1f 00 03 	mcall	800027d8 <ToneControl_reply_func+0x20>
800027d2:	d8 02       	popm	pc
800027d4:	80 00       	ld.sh	r0,r0[0x0]
800027d6:	ca d4       	brge	80002730 <dcm_brdcst_func+0x28>
800027d8:	80 00       	ld.sh	r0,r0[0x0]
800027da:	64 10       	ld.w	r0,r2[0x4]
800027dc:	80 00       	ld.sh	r0,r0[0x0]
800027de:	ca dc       	rcall	80002938 <payload_rx_process+0x38>

800027e0 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
800027e0:	eb cd 40 80 	pushm	r7,lr
800027e4:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
800027e6:	48 b9       	lddpc	r9,80002810 <app_payload_rx_proc+0x30>
800027e8:	13 88       	ld.ub	r8,r9[0x0]
800027ea:	2f f8       	sub	r8,-1
800027ec:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 110)
800027ee:	36 e9       	mov	r9,110
800027f0:	f2 08 18 00 	cp.b	r8,r9
800027f4:	c0 71       	brne	80002802 <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
800027f6:	30 09       	mov	r9,0
800027f8:	48 68       	lddpc	r8,80002810 <app_payload_rx_proc+0x30>
800027fa:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800027fc:	48 6c       	lddpc	r12,80002814 <app_payload_rx_proc+0x34>
800027fe:	f0 1f 00 07 	mcall	80002818 <app_payload_rx_proc+0x38>
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
80002802:	48 78       	lddpc	r8,8000281c <app_payload_rx_proc+0x3c>
80002804:	70 0c       	ld.w	r12,r8[0x0]
80002806:	0e 9b       	mov	r11,r7
80002808:	f0 1f 00 06 	mcall	80002820 <app_payload_rx_proc+0x40>

}
8000280c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002810:	00 00       	add	r0,r0
80002812:	0a 42       	or	r2,r5
80002814:	80 00       	ld.sh	r0,r0[0x0]
80002816:	ca e8       	rjmp	80002972 <phy_rx+0xa>
80002818:	80 00       	ld.sh	r0,r0[0x0]
8000281a:	64 10       	ld.w	r0,r2[0x4]
8000281c:	00 00       	add	r0,r0
8000281e:	0a 70       	tst	r0,r5
80002820:	80 00       	ld.sh	r0,r0[0x0]
80002822:	29 a0       	sub	r0,-102

80002824 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002824:	eb cd 40 80 	pushm	r7,lr
80002828:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000282a:	19 a9       	ld.ub	r9,r12[0x2]
8000282c:	30 08       	mov	r8,0
8000282e:	f0 09 18 00 	cp.b	r9,r8
80002832:	c0 c1       	brne	8000284a <AudioRoutingControl_reply_func+0x26>
	{
		log("AudioRouting OK");
80002834:	48 bc       	lddpc	r12,80002860 <AudioRoutingControl_reply_func+0x3c>
80002836:	f0 1f 00 0c 	mcall	80002864 <AudioRoutingControl_reply_func+0x40>
		xcmp_IdleTestTone();//提示通道配置成功
8000283a:	f0 1f 00 0c 	mcall	80002868 <AudioRoutingControl_reply_func+0x44>
		xcmp_IdleTestTone();
8000283e:	f0 1f 00 0b 	mcall	80002868 <AudioRoutingControl_reply_func+0x44>
		xcmp_IdleTestTone();
80002842:	f0 1f 00 0a 	mcall	80002868 <AudioRoutingControl_reply_func+0x44>
80002846:	e3 cd 80 80 	ldm	sp++,r7,pc
		//is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
8000284a:	48 9c       	lddpc	r12,8000286c <AudioRoutingControl_reply_func+0x48>
8000284c:	f0 1f 00 06 	mcall	80002864 <AudioRoutingControl_reply_func+0x40>
		log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
80002850:	0f a8       	ld.ub	r8,r7[0x2]
80002852:	1a d8       	st.w	--sp,r8
80002854:	48 7c       	lddpc	r12,80002870 <AudioRoutingControl_reply_func+0x4c>
80002856:	f0 1f 00 04 	mcall	80002864 <AudioRoutingControl_reply_func+0x40>
8000285a:	2f fd       	sub	sp,-4
8000285c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	ca f4       	brge	800027c0 <ToneControl_reply_func+0x8>
80002864:	80 00       	ld.sh	r0,r0[0x0]
80002866:	64 10       	ld.w	r0,r2[0x4]
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	41 e4       	lddsp	r4,sp[0x78]
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	cb 04       	brge	800027ce <ToneControl_reply_func+0x16>
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	cb 18       	rjmp	800029d4 <phy_tx+0x14>

80002874 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002874:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002876:	19 e8       	ld.ub	r8,r12[0x6]
80002878:	30 19       	mov	r9,1
8000287a:	f2 08 18 00 	cp.b	r8,r9
8000287e:	c0 61       	brne	8000288a <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002880:	48 98       	lddpc	r8,800028a4 <DeviceInitializationStatus_brdcst_func+0x30>
80002882:	70 09       	ld.w	r9,r8[0x0]
80002884:	a1 a9       	sbr	r9,0x0
80002886:	91 09       	st.w	r8[0x0],r9
80002888:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
8000288a:	30 29       	mov	r9,2
8000288c:	f2 08 18 00 	cp.b	r8,r9
80002890:	c0 80       	breq	800028a0 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002892:	48 58       	lddpc	r8,800028a4 <DeviceInitializationStatus_brdcst_func+0x30>
80002894:	70 09       	ld.w	r9,r8[0x0]
80002896:	e0 19 ff fc 	andl	r9,0xfffc
8000289a:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
8000289c:	f0 1f 00 03 	mcall	800028a8 <DeviceInitializationStatus_brdcst_func+0x34>
800028a0:	d8 02       	popm	pc
800028a2:	00 00       	add	r0,r0
800028a4:	00 00       	add	r0,r0
800028a6:	0d ac       	ld.ub	r12,r6[0x2]
800028a8:	80 00       	ld.sh	r0,r0[0x0]
800028aa:	41 38       	lddsp	r8,sp[0x4c]

800028ac <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800028ac:	20 1c       	sub	r12,1
800028ae:	5c 5c       	castu.b	r12
800028b0:	31 18       	mov	r8,17
800028b2:	f0 0c 18 00 	cp.b	r12,r8
800028b6:	e0 88 00 03 	brls	800028bc <CalculateBurst+0x10>
800028ba:	5e fd       	retal	0
800028bc:	48 28       	lddpc	r8,800028c4 <CalculateBurst+0x18>
800028be:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
800028c2:	5e fc       	retal	r12
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	cb 38       	rjmp	80002a2c <get_idle_store_isr+0x10>

800028c8 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
800028c8:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
800028ca:	48 98       	lddpc	r8,800028ec <payload_init+0x24>
800028cc:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800028ce:	48 98       	lddpc	r8,800028f0 <payload_init+0x28>
800028d0:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800028d2:	30 09       	mov	r9,0
800028d4:	1a d9       	st.w	--sp,r9
800028d6:	1a d9       	st.w	--sp,r9
800028d8:	1a d9       	st.w	--sp,r9
800028da:	30 28       	mov	r8,2
800028dc:	e0 6a 04 00 	mov	r10,1024
800028e0:	48 5b       	lddpc	r11,800028f4 <payload_init+0x2c>
800028e2:	48 6c       	lddpc	r12,800028f8 <payload_init+0x30>
800028e4:	f0 1f 00 06 	mcall	800028fc <payload_init+0x34>
800028e8:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
800028ea:	d8 02       	popm	pc
800028ec:	00 00       	add	r0,r0
800028ee:	0a 60       	and	r0,r5
800028f0:	00 00       	add	r0,r0
800028f2:	0a 64       	and	r4,r5
800028f4:	80 00       	ld.sh	r0,r0[0x0]
800028f6:	d1 30       	acall	0x13
800028f8:	80 00       	ld.sh	r0,r0[0x0]
800028fa:	29 00       	sub	r0,-112
800028fc:	80 00       	ld.sh	r0,r0[0x0]
800028fe:	60 4c       	ld.w	r12,r0[0x10]

80002900 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002900:	eb cd 40 f8 	pushm	r3-r7,lr
80002904:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002906:	48 e8       	lddpc	r8,8000293c <payload_rx_process+0x3c>
80002908:	70 08       	ld.w	r8,r8[0x0]
8000290a:	58 08       	cp.w	r8,0
8000290c:	c0 71       	brne	8000291a <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000290e:	30 4b       	mov	r11,4
80002910:	30 5c       	mov	r12,5
80002912:	f0 1f 00 0c 	mcall	80002940 <payload_rx_process+0x40>
80002916:	48 a8       	lddpc	r8,8000293c <payload_rx_process+0x3c>
80002918:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000291a:	48 96       	lddpc	r6,8000293c <payload_rx_process+0x3c>
8000291c:	30 05       	mov	r5,0
8000291e:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();//此处跳转。。。。
80002920:	48 93       	lddpc	r3,80002944 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002922:	6c 0c       	ld.w	r12,r6[0x0]
80002924:	0a 99       	mov	r9,r5
80002926:	08 9a       	mov	r10,r4
80002928:	1a 9b       	mov	r11,sp
8000292a:	f0 1f 00 08 	mcall	80002948 <payload_rx_process+0x48>
8000292e:	58 1c       	cp.w	r12,1
80002930:	cf 91       	brne	80002922 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();//此处跳转。。。。
80002932:	66 08       	ld.w	r8,r3[0x0]
80002934:	40 0c       	lddsp	r12,sp[0x0]
80002936:	5d 18       	icall	r8
80002938:	cf 5b       	rjmp	80002922 <payload_rx_process+0x22>
8000293a:	00 00       	add	r0,r0
8000293c:	00 00       	add	r0,r0
8000293e:	0a 74       	tst	r4,r5
80002940:	80 00       	ld.sh	r0,r0[0x0]
80002942:	59 78       	cp.w	r8,23
80002944:	00 00       	add	r0,r0
80002946:	0a 60       	and	r0,r5
80002948:	80 00       	ld.sh	r0,r0[0x0]
8000294a:	56 14       	stdsp	sp[0x184],r4

8000294c <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
8000294c:	d4 01       	pushm	lr
8000294e:	20 2d       	sub	sp,8
80002950:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002952:	30 09       	mov	r9,0
80002954:	fa ca ff f8 	sub	r10,sp,-8
80002958:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
8000295a:	1a 9b       	mov	r11,sp
8000295c:	f0 1f 00 02 	mcall	80002964 <set_idle_store_isr+0x18>
}
80002960:	2f ed       	sub	sp,-8
80002962:	d8 02       	popm	pc
80002964:	80 00       	ld.sh	r0,r0[0x0]
80002966:	57 d0       	stdsp	sp[0x1f4],r0

80002968 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002968:	d4 01       	pushm	lr
8000296a:	20 2d       	sub	sp,8
8000296c:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
8000296e:	58 0c       	cp.w	r12,0
80002970:	c1 10       	breq	80002992 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002972:	30 08       	mov	r8,0
80002974:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002976:	98 88       	ld.uh	r8,r12[0x0]
80002978:	e2 18 f0 00 	andl	r8,0xf000,COH
8000297c:	e0 48 40 00 	cp.w	r8,16384
80002980:	c0 91       	brne	80002992 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002982:	48 68       	lddpc	r8,80002998 <phy_rx+0x30>
80002984:	70 0c       	ld.w	r12,r8[0x0]
80002986:	30 09       	mov	r9,0
80002988:	fa ca ff fc 	sub	r10,sp,-4
8000298c:	1a 9b       	mov	r11,sp
8000298e:	f0 1f 00 04 	mcall	8000299c <phy_rx+0x34>
		}	

    }
		
 
}
80002992:	2f ed       	sub	sp,-8
80002994:	d8 02       	popm	pc
80002996:	00 00       	add	r0,r0
80002998:	00 00       	add	r0,r0
8000299a:	0a bc       	st.h	r5++,r12
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	57 d0       	stdsp	sp[0x1f4],r0

800029a0 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800029a0:	eb cd 40 80 	pushm	r7,lr
800029a4:	20 1d       	sub	sp,4
800029a6:	fa c7 ff fc 	sub	r7,sp,-4
800029aa:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800029ac:	30 09       	mov	r9,0
800029ae:	12 9a       	mov	r10,r9
800029b0:	1a 9b       	mov	r11,sp
800029b2:	f0 1f 00 03 	mcall	800029bc <set_idle_store+0x1c>
}
800029b6:	2f fd       	sub	sp,-4
800029b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800029bc:	80 00       	ld.sh	r0,r0[0x0]
800029be:	58 20       	cp.w	r0,2

800029c0 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800029c0:	d4 01       	pushm	lr
800029c2:	20 1d       	sub	sp,4
800029c4:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
800029c6:	98 88       	ld.uh	r8,r12[0x0]
800029c8:	e2 18 f0 00 	andl	r8,0xf000,COH
800029cc:	e0 48 40 00 	cp.w	r8,16384
800029d0:	c0 d1       	brne	800029ea <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
800029d2:	49 08       	lddpc	r8,80002a10 <phy_tx+0x50>
800029d4:	70 08       	ld.w	r8,r8[0x0]
800029d6:	58 08       	cp.w	r8,0
800029d8:	c1 a0       	breq	80002a0c <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
800029da:	48 e8       	lddpc	r8,80002a10 <phy_tx+0x50>
800029dc:	70 0c       	ld.w	r12,r8[0x0]
800029de:	30 09       	mov	r9,0
800029e0:	12 9a       	mov	r10,r9
800029e2:	1a 9b       	mov	r11,sp
800029e4:	f0 1f 00 0c 	mcall	80002a14 <phy_tx+0x54>
800029e8:	c1 28       	rjmp	80002a0c <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
800029ea:	e0 48 10 00 	cp.w	r8,4096
800029ee:	5f 0a       	sreq	r10
800029f0:	e0 48 20 00 	cp.w	r8,8192
800029f4:	5f 09       	sreq	r9
800029f6:	f5 e9 10 09 	or	r9,r10,r9
800029fa:	c0 71       	brne	80002a08 <phy_tx+0x48>
800029fc:	e0 48 50 00 	cp.w	r8,20480
80002a00:	c0 40       	breq	80002a08 <phy_tx+0x48>
80002a02:	e0 48 60 00 	cp.w	r8,24576
80002a06:	c0 31       	brne	80002a0c <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a08:	48 48       	lddpc	r8,80002a18 <phy_tx+0x58>
80002a0a:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a0c:	2f fd       	sub	sp,-4
80002a0e:	d8 02       	popm	pc
80002a10:	00 00       	add	r0,r0
80002a12:	0a d4       	st.w	--r5,r4
80002a14:	80 00       	ld.sh	r0,r0[0x0]
80002a16:	58 20       	cp.w	r0,2
80002a18:	00 00       	add	r0,r0
80002a1a:	0a c0       	st.b	r5++,r0

80002a1c <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a1c:	d4 01       	pushm	lr
80002a1e:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a20:	30 08       	mov	r8,0
80002a22:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a24:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a26:	1a 9a       	mov	r10,sp
80002a28:	fa cb ff fc 	sub	r11,sp,-4
80002a2c:	f0 1f 00 05 	mcall	80002a40 <get_idle_store_isr+0x24>
80002a30:	58 1c       	cp.w	r12,1
80002a32:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a36:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002a3a:	2f ed       	sub	sp,-8
80002a3c:	d8 02       	popm	pc
80002a3e:	00 00       	add	r0,r0
80002a40:	80 00       	ld.sh	r0,r0[0x0]
80002a42:	55 24       	stdsp	sp[0x148],r4

80002a44 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002a44:	eb cd 40 c0 	pushm	r6-r7,lr
80002a48:	20 1d       	sub	sp,4
80002a4a:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002a4c:	fe f8 04 48 	ld.w	r8,pc[1096]
80002a50:	70 08       	ld.w	r8,r8[0x0]
80002a52:	58 08       	cp.w	r8,0
80002a54:	c7 40       	breq	80002b3c <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002a56:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a58:	30 08       	mov	r8,0
80002a5a:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002a5c:	fe f8 04 3c 	ld.w	r8,pc[1084]
80002a60:	70 08       	ld.w	r8,r8[0x0]
80002a62:	58 18       	cp.w	r8,1
80002a64:	c2 90       	breq	80002ab6 <phy_tx_func+0x72>
80002a66:	c0 43       	brcs	80002a6e <phy_tx_func+0x2a>
80002a68:	58 28       	cp.w	r8,2
80002a6a:	c6 91       	brne	80002b3c <phy_tx_func+0xf8>
80002a6c:	c6 18       	rjmp	80002b2e <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002a6e:	fe f8 04 26 	ld.w	r8,pc[1062]
80002a72:	70 0c       	ld.w	r12,r8[0x0]
80002a74:	1a 9a       	mov	r10,sp
80002a76:	fe fb 04 26 	ld.w	r11,pc[1062]
80002a7a:	f0 1f 01 0a 	mcall	80002ea0 <phy_tx_func+0x45c>
80002a7e:	58 1c       	cp.w	r12,1
80002a80:	c1 51       	brne	80002aaa <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002a82:	fe f8 04 1a 	ld.w	r8,pc[1050]
80002a86:	70 08       	ld.w	r8,r8[0x0]
80002a88:	11 9a       	ld.ub	r10,r8[0x1]
80002a8a:	fe f9 04 1a 	ld.w	r9,pc[1050]
80002a8e:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002a90:	90 88       	ld.uh	r8,r8[0x0]
80002a92:	ea 18 ab cd 	orh	r8,0xabcd
80002a96:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002a98:	30 19       	mov	r9,1
80002a9a:	fe f8 04 0e 	ld.w	r8,pc[1038]
80002a9e:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002aa0:	30 19       	mov	r9,1
80002aa2:	fe f8 03 f6 	ld.w	r8,pc[1014]
80002aa6:	91 09       	st.w	r8[0x0],r9
80002aa8:	c4 a8       	rjmp	80002b3c <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002aaa:	e0 68 5a 5a 	mov	r8,23130
80002aae:	ea 18 ab cd 	orh	r8,0xabcd
80002ab2:	8f 18       	st.w	r7[0x4],r8
80002ab4:	c4 48       	rjmp	80002b3c <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002ab6:	fe f9 03 f2 	ld.w	r9,pc[1010]
80002aba:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002abc:	fe fa 03 e0 	ld.w	r10,pc[992]
80002ac0:	74 0a       	ld.w	r10,r10[0x0]
80002ac2:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002ac6:	b1 6a       	lsl	r10,0x10
80002ac8:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002aca:	2f f8       	sub	r8,-1
80002acc:	5c 58       	castu.b	r8
80002ace:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002ad0:	fe fa 03 d4 	ld.w	r10,pc[980]
80002ad4:	94 09       	ld.sh	r9,r10[0x0]
80002ad6:	20 29       	sub	r9,2
80002ad8:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002ada:	30 0a       	mov	r10,0
80002adc:	f4 09 19 00 	cp.h	r9,r10
80002ae0:	e0 89 00 0b 	brgt	80002af6 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002ae4:	78 18       	ld.w	r8,r12[0x4]
80002ae6:	e8 18 00 ba 	orl	r8,0xba
80002aea:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80002aec:	30 09       	mov	r9,0
80002aee:	fe f8 03 aa 	ld.w	r8,pc[938]
80002af2:	91 09       	st.w	r8[0x0],r9
80002af4:	c2 48       	rjmp	80002b3c <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002af6:	fe f9 03 a6 	ld.w	r9,pc[934]
80002afa:	72 09       	ld.w	r9,r9[0x0]
80002afc:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002b00:	78 1a       	ld.w	r10,r12[0x4]
80002b02:	f5 e9 10 09 	or	r9,r10,r9
80002b06:	99 19       	st.w	r12[0x4],r9
80002b08:	2f f8       	sub	r8,-1
80002b0a:	fe f9 03 9e 	ld.w	r9,pc[926]
80002b0e:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b10:	fe f9 03 94 	ld.w	r9,pc[916]
80002b14:	92 08       	ld.sh	r8,r9[0x0]
80002b16:	20 28       	sub	r8,2
80002b18:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b1a:	30 09       	mov	r9,0
80002b1c:	f2 08 19 00 	cp.h	r8,r9
80002b20:	e0 89 00 0e 	brgt	80002b3c <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b24:	30 29       	mov	r9,2
80002b26:	fe f8 03 72 	ld.w	r8,pc[882]
80002b2a:	91 09       	st.w	r8[0x0],r9
80002b2c:	c0 88       	rjmp	80002b3c <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b2e:	fc 18 00 ba 	movh	r8,0xba
80002b32:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002b34:	30 09       	mov	r9,0
80002b36:	fe f8 03 62 	ld.w	r8,pc[866]
80002b3a:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_tx_flag == TRUE) || (AMBE_rx_flag == TRUE))
80002b3c:	fe f8 03 70 	ld.w	r8,pc[880]
80002b40:	11 89       	ld.ub	r9,r8[0x0]
80002b42:	30 18       	mov	r8,1
80002b44:	f0 09 18 00 	cp.b	r9,r8
80002b48:	c0 90       	breq	80002b5a <phy_tx_func+0x116>
80002b4a:	fe f8 03 66 	ld.w	r8,pc[870]
80002b4e:	11 89       	ld.ub	r9,r8[0x0]
80002b50:	30 18       	mov	r8,1
80002b52:	f0 09 18 00 	cp.b	r9,r8
80002b56:	e0 81 01 4a 	brne	80002dea <phy_tx_func+0x3a6>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80002b5a:	fe f8 03 5a 	ld.w	r8,pc[858]
80002b5e:	70 08       	ld.w	r8,r8[0x0]
80002b60:	e0 48 05 b0 	cp.w	r8,1456
80002b64:	f9 b8 02 00 	movhs	r8,0
80002b68:	fe f9 03 4c 	ld.w	r9,pc[844]
80002b6c:	93 08       	st.w	r9[0x0],r8

	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80002b6e:	fe f9 03 4a 	ld.w	r9,pc[842]
80002b72:	72 09       	ld.w	r9,r9[0x0]
80002b74:	58 29       	cp.w	r9,2
80002b76:	e0 80 00 90 	breq	80002c96 <phy_tx_func+0x252>
80002b7a:	e0 8b 00 08 	brhi	80002b8a <phy_tx_func+0x146>
80002b7e:	58 09       	cp.w	r9,0
80002b80:	c0 e0       	breq	80002b9c <phy_tx_func+0x158>
80002b82:	58 19       	cp.w	r9,1
80002b84:	e0 81 01 29 	brne	80002dd6 <phy_tx_func+0x392>
80002b88:	c5 68       	rjmp	80002c34 <phy_tx_func+0x1f0>
80002b8a:	58 49       	cp.w	r9,4
80002b8c:	e0 80 00 bc 	breq	80002d04 <phy_tx_func+0x2c0>
80002b90:	e0 83 00 99 	brlo	80002cc2 <phy_tx_func+0x27e>
80002b94:	58 59       	cp.w	r9,5
80002b96:	e0 81 01 20 	brne	80002dd6 <phy_tx_func+0x392>
80002b9a:	c1 39       	rjmp	80002dc0 <phy_tx_func+0x37c>
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80002b9c:	fe f8 03 20 	ld.w	r8,pc[800]
80002ba0:	70 08       	ld.w	r8,r8[0x0]
80002ba2:	58 08       	cp.w	r8,0
80002ba4:	c0 b0       	breq	80002bba <phy_tx_func+0x176>
80002ba6:	fe f8 03 16 	ld.w	r8,pc[790]
80002baa:	70 08       	ld.w	r8,r8[0x0]
80002bac:	58 a8       	cp.w	r8,10
80002bae:	c0 60       	breq	80002bba <phy_tx_func+0x176>
80002bb0:	fe f8 03 0c 	ld.w	r8,pc[780]
80002bb4:	70 08       	ld.w	r8,r8[0x0]
80002bb6:	58 18       	cp.w	r8,1
80002bb8:	c0 a1       	brne	80002bcc <phy_tx_func+0x188>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002bba:	e0 68 5a 5a 	mov	r8,23130
80002bbe:	ea 18 ab cd 	orh	r8,0xabcd
80002bc2:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002bc4:	30 08       	mov	r8,0
80002bc6:	8f 38       	st.w	r7[0xc],r8
80002bc8:	e0 8f 01 63 	bral	80002e8e <phy_tx_func+0x44a>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80002bcc:	fe f8 02 f0 	ld.w	r8,pc[752]
80002bd0:	70 08       	ld.w	r8,r8[0x0]
80002bd2:	58 38       	cp.w	r8,3
80002bd4:	c0 91       	brne	80002be6 <phy_tx_func+0x1a2>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80002bd6:	fe f8 02 ea 	ld.w	r8,pc[746]
80002bda:	70 09       	ld.w	r9,r8[0x0]
80002bdc:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80002bde:	70 18       	ld.w	r8,r8[0x4]
80002be0:	8f 38       	st.w	r7[0xc],r8
80002be2:	e0 8f 01 56 	bral	80002e8e <phy_tx_func+0x44a>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 3 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
80002be6:	fe f8 02 d6 	ld.w	r8,pc[726]
80002bea:	70 08       	ld.w	r8,r8[0x0]
80002bec:	58 28       	cp.w	r8,2
80002bee:	c1 31       	brne	80002c14 <phy_tx_func+0x1d0>
					{
						//0xABCDCO14
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//49bits
80002bf0:	e0 68 c0 14 	mov	r8,49172
80002bf4:	ea 18 ab cd 	orh	r8,0xabcd
80002bf8:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80002bfa:	fe 78 84 7f 	mov	r8,-31617
80002bfe:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80002c00:	fe f8 02 c4 	ld.w	r8,pc[708]
80002c04:	90 08       	ld.sh	r8,r8[0x0]
80002c06:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80002c08:	30 39       	mov	r9,3
80002c0a:	fe f8 02 ae 	ld.w	r8,pc[686]
80002c0e:	91 09       	st.w	r8[0x0],r9
80002c10:	e0 8f 01 3f 	bral	80002e8e <phy_tx_func+0x44a>
					
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80002c14:	e0 68 c0 0e 	mov	r8,49166
80002c18:	ea 18 ab cd 	orh	r8,0xabcd
80002c1c:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80002c1e:	fe f8 02 aa 	ld.w	r8,pc[682]
80002c22:	90 09       	ld.sh	r9,r8[0x0]
80002c24:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80002c26:	90 18       	ld.sh	r8,r8[0x2]
80002c28:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80002c2a:	30 19       	mov	r9,1
80002c2c:	fe f8 02 8c 	ld.w	r8,pc[652]
80002c30:	91 09       	st.w	r8[0x0],r9
80002c32:	c2 e9       	rjmp	80002e8e <phy_tx_func+0x44a>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80002c34:	fe 78 88 f2 	mov	r8,-30478
80002c38:	ae 48       	st.h	r7[0x8],r8
				
				payload_tx_channel->word[1] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80002c3a:	fe f8 02 7a 	ld.w	r8,pc[634]
80002c3e:	70 0a       	ld.w	r10,r8[0x0]
80002c40:	fe f9 02 8c 	ld.w	r9,pc[652]
80002c44:	f2 0a 00 0b 	add	r11,r9,r10
80002c48:	17 9b       	ld.ub	r11,r11[0x1]
80002c4a:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
80002c4e:	a9 6a       	lsl	r10,0x8
80002c50:	f6 0a 00 0a 	add	r10,r11,r10
80002c54:	ae 5a       	st.h	r7[0xa],r10
				A_index+=2;
80002c56:	70 0a       	ld.w	r10,r8[0x0]
80002c58:	2f ea       	sub	r10,-2
80002c5a:	91 0a       	st.w	r8[0x0],r10
				
				payload_tx_channel->word[2] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80002c5c:	f2 0a 00 0b 	add	r11,r9,r10
80002c60:	17 9b       	ld.ub	r11,r11[0x1]
80002c62:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
80002c66:	a9 6a       	lsl	r10,0x8
80002c68:	f6 0a 00 0a 	add	r10,r11,r10
80002c6c:	ae 6a       	st.h	r7[0xc],r10
				A_index+=2;
80002c6e:	70 0a       	ld.w	r10,r8[0x0]
80002c70:	2f ea       	sub	r10,-2
80002c72:	91 0a       	st.w	r8[0x0],r10
				
				payload_tx_channel->word[3] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80002c74:	f2 0a 00 0b 	add	r11,r9,r10
80002c78:	17 9b       	ld.ub	r11,r11[0x1]
80002c7a:	f2 0a 07 09 	ld.ub	r9,r9[r10]
80002c7e:	a9 69       	lsl	r9,0x8
80002c80:	f6 09 00 09 	add	r9,r11,r9
80002c84:	ae 79       	st.h	r7[0xe],r9
				A_index+=2;
80002c86:	70 09       	ld.w	r9,r8[0x0]
80002c88:	2f e9       	sub	r9,-2
80002c8a:	91 09       	st.w	r8[0x0],r9
				
				AMBEpayload_tx_state = AMBE_EN_LAST;
80002c8c:	30 29       	mov	r9,2
80002c8e:	fe f8 02 2a 	ld.w	r8,pc[554]
80002c92:	91 09       	st.w	r8[0x0],r9
80002c94:	cf d8       	rjmp	80002e8e <phy_tx_func+0x44a>
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3]) ^ (AMBEBurst_rawdata[3])) ;
					
					}
					
					***/
					payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
80002c96:	fe f9 02 36 	ld.w	r9,pc[566]
80002c9a:	f2 08 07 08 	ld.ub	r8,r9[r8]
80002c9e:	a9 68       	lsl	r8,0x8
80002ca0:	ae 48       	st.h	r7[0x8],r8
					A_index+=1;
80002ca2:	fe f8 02 12 	ld.w	r8,pc[530]
80002ca6:	70 09       	ld.w	r9,r8[0x0]
80002ca8:	2f f9       	sub	r9,-1
80002caa:	91 09       	st.w	r8[0x0],r9
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80002cac:	e0 68 00 ba 	mov	r8,186
80002cb0:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002cb2:	30 08       	mov	r8,0
80002cb4:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002cb6:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80002cb8:	30 09       	mov	r9,0
80002cba:	fe f8 01 fe 	ld.w	r8,pc[510]
80002cbe:	91 09       	st.w	r8[0x0],r9
80002cc0:	ce 78       	rjmp	80002e8e <phy_tx_func+0x44a>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80002cc2:	fe f8 02 02 	ld.w	r8,pc[514]
80002cc6:	90 18       	ld.sh	r8,r8[0x2]
80002cc8:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80002cca:	fe f8 01 fe 	ld.w	r8,pc[510]
80002cce:	90 08       	ld.sh	r8,r8[0x0]
80002cd0:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80002cd2:	4f b8       	lddpc	r8,80002ebc <phy_tx_func+0x478>
80002cd4:	70 08       	ld.w	r8,r8[0x0]
80002cd6:	58 48       	cp.w	r8,4
80002cd8:	c0 c1       	brne	80002cf0 <phy_tx_func+0x2ac>
80002cda:	4f e8       	lddpc	r8,80002ed0 <phy_tx_func+0x48c>
80002cdc:	11 89       	ld.ub	r9,r8[0x0]
80002cde:	30 18       	mov	r8,1
80002ce0:	f0 09 18 00 	cp.b	r9,r8
80002ce4:	c0 61       	brne	80002cf0 <phy_tx_func+0x2ac>
					{
						// Vocoder Bits Stream Parameter("E" flag = 1)
						//0xF08x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0080));
80002ce6:	4f 98       	lddpc	r8,80002ec8 <phy_tx_func+0x484>
80002ce8:	90 18       	ld.sh	r8,r8[0x2]
80002cea:	a7 b8       	sbr	r8,0x7
80002cec:	ae 68       	st.h	r7[0xc],r8
80002cee:	c0 48       	rjmp	80002cf6 <phy_tx_func+0x2b2>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80002cf0:	4f 68       	lddpc	r8,80002ec8 <phy_tx_func+0x484>
80002cf2:	90 18       	ld.sh	r8,r8[0x2]
80002cf4:	ae 68       	st.h	r7[0xc],r8
					
					//0x88F3
					payload_tx_channel->word[3] = DECODER_PAYLOAD;
80002cf6:	fe 78 88 f3 	mov	r8,-30477
80002cfa:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80002cfc:	30 49       	mov	r9,4
80002cfe:	4e f8       	lddpc	r8,80002eb8 <phy_tx_func+0x474>
80002d00:	91 09       	st.w	r8[0x0],r9
80002d02:	cc 68       	rjmp	80002e8e <phy_tx_func+0x44a>
					
				break;
			case AMBE_DE_SECOND:
					
				switch (m_RxBurstType)//在发送函数中去做解密处理
80002d04:	4e e8       	lddpc	r8,80002ebc <phy_tx_func+0x478>
80002d06:	70 08       	ld.w	r8,r8[0x0]
80002d08:	58 48       	cp.w	r8,4
80002d0a:	c0 60       	breq	80002d16 <phy_tx_func+0x2d2>
80002d0c:	c5 03       	brcs	80002dac <phy_tx_func+0x368>
80002d0e:	58 98       	cp.w	r8,9
80002d10:	e0 8b 00 4e 	brhi	80002dac <phy_tx_func+0x368>
80002d14:	c3 38       	rjmp	80002d7a <phy_tx_func+0x336>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80002d16:	4e f8       	lddpc	r8,80002ed0 <phy_tx_func+0x48c>
80002d18:	11 89       	ld.ub	r9,r8[0x0]
80002d1a:	30 18       	mov	r8,1
80002d1c:	f0 09 18 00 	cp.b	r9,r8
80002d20:	c1 41       	brne	80002d48 <phy_tx_func+0x304>
							{	
								//Pick up public key
								
								AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80002d22:	4e d8       	lddpc	r8,80002ed4 <phy_tx_func+0x490>
80002d24:	90 0a       	ld.sh	r10,r8[0x0]
80002d26:	4e d9       	lddpc	r9,80002ed8 <phy_tx_func+0x494>
80002d28:	b2 0a       	st.h	r9[0x0],r10
								AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80002d2a:	90 1a       	ld.sh	r10,r8[0x2]
80002d2c:	b2 1a       	st.h	r9[0x2],r10
								AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80002d2e:	90 2a       	ld.sh	r10,r8[0x4]
80002d30:	b2 2a       	st.h	r9[0x4],r10
								AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80002d32:	90 3a       	ld.sh	r10,r8[0x6]
80002d34:	b2 3a       	st.h	r9[0x6],r10
								
								//Post back data
								payload_tx_channel->word[0] = AMBEBurst_rawdata[0] ;
80002d36:	90 09       	ld.sh	r9,r8[0x0]
80002d38:	ae 49       	st.h	r7[0x8],r9
								payload_tx_channel->word[1] = AMBEBurst_rawdata[1] ;
80002d3a:	90 19       	ld.sh	r9,r8[0x2]
80002d3c:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = AMBEBurst_rawdata[2] ;
80002d3e:	90 29       	ld.sh	r9,r8[0x4]
80002d40:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = AMBEBurst_rawdata[3] ;
80002d42:	90 38       	ld.sh	r8,r8[0x6]
80002d44:	ae 78       	st.h	r7[0xe],r8
80002d46:	c1 68       	rjmp	80002d72 <phy_tx_func+0x32e>
								
								
						
								//Decrypt AMBE data(XOR) 
								//Recover data
								payload_tx_channel->word[0] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002d48:	4e 49       	lddpc	r9,80002ed8 <phy_tx_func+0x494>
80002d4a:	92 0a       	ld.sh	r10,r9[0x0]
80002d4c:	4e 28       	lddpc	r8,80002ed4 <phy_tx_func+0x490>
80002d4e:	90 0b       	ld.sh	r11,r8[0x0]
80002d50:	f7 ea 20 0a 	eor	r10,r11,r10
80002d54:	ae 4a       	st.h	r7[0x8],r10
								payload_tx_channel->word[1] = ((AMBE_DecryptionKey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002d56:	92 1a       	ld.sh	r10,r9[0x2]
80002d58:	90 1b       	ld.sh	r11,r8[0x2]
80002d5a:	f7 ea 20 0a 	eor	r10,r11,r10
80002d5e:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((AMBE_DecryptionKey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002d60:	92 2a       	ld.sh	r10,r9[0x4]
80002d62:	90 2b       	ld.sh	r11,r8[0x4]
80002d64:	f7 ea 20 0a 	eor	r10,r11,r10
80002d68:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[3]) ^ (AMBEBurst_rawdata[3])) ;
80002d6a:	92 39       	ld.sh	r9,r9[0x6]
80002d6c:	90 38       	ld.sh	r8,r8[0x6]
80002d6e:	12 58       	eor	r8,r9
80002d70:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_DE_LAST;
80002d72:	30 59       	mov	r9,5
80002d74:	4d 18       	lddpc	r8,80002eb8 <phy_tx_func+0x474>
80002d76:	91 09       	st.w	r8[0x0],r9
80002d78:	c8 b8       	rjmp	80002e8e <phy_tx_func+0x44a>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002d7a:	4d 89       	lddpc	r9,80002ed8 <phy_tx_func+0x494>
80002d7c:	92 0a       	ld.sh	r10,r9[0x0]
80002d7e:	4d 68       	lddpc	r8,80002ed4 <phy_tx_func+0x490>
80002d80:	90 0b       	ld.sh	r11,r8[0x0]
80002d82:	f7 ea 20 0a 	eor	r10,r11,r10
80002d86:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = ((AMBE_DecryptionKey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002d88:	92 1a       	ld.sh	r10,r9[0x2]
80002d8a:	90 1b       	ld.sh	r11,r8[0x2]
80002d8c:	f7 ea 20 0a 	eor	r10,r11,r10
80002d90:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((AMBE_DecryptionKey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002d92:	92 2a       	ld.sh	r10,r9[0x4]
80002d94:	90 2b       	ld.sh	r11,r8[0x4]
80002d96:	f7 ea 20 0a 	eor	r10,r11,r10
80002d9a:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((AMBE_DecryptionKey[3]) ^ (AMBEBurst_rawdata[3])) ;
80002d9c:	92 39       	ld.sh	r9,r9[0x6]
80002d9e:	90 38       	ld.sh	r8,r8[0x6]
80002da0:	12 58       	eor	r8,r9
80002da2:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_DE_LAST;
80002da4:	30 59       	mov	r9,5
80002da6:	4c 58       	lddpc	r8,80002eb8 <phy_tx_func+0x474>
80002da8:	91 09       	st.w	r8[0x0],r9
80002daa:	c7 28       	rjmp	80002e8e <phy_tx_func+0x44a>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002dac:	e0 68 5a 5a 	mov	r8,23130
80002db0:	ea 18 ab cd 	orh	r8,0xabcd
80002db4:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002db6:	30 08       	mov	r8,0
80002db8:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
80002dba:	4c 09       	lddpc	r9,80002eb8 <phy_tx_func+0x474>
80002dbc:	93 08       	st.w	r9[0x0],r8
80002dbe:	c6 88       	rjmp	80002e8e <phy_tx_func+0x44a>
		
				break;
				
			case AMBE_DE_LAST:
				
					payload_tx_channel->word[0]	= 0x00BA ;
80002dc0:	e0 68 00 ba 	mov	r8,186
80002dc4:	ae 48       	st.h	r7[0x8],r8
					payload_tx_channel->word[1]	= 0x0000 ;
80002dc6:	30 08       	mov	r8,0
80002dc8:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002dca:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002dcc:	ae 78       	st.h	r7[0xe],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002dce:	30 09       	mov	r9,0
80002dd0:	4b a8       	lddpc	r8,80002eb8 <phy_tx_func+0x474>
80002dd2:	91 09       	st.w	r8[0x0],r9
80002dd4:	c5 d8       	rjmp	80002e8e <phy_tx_func+0x44a>
				
				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002dd6:	e0 68 5a 5a 	mov	r8,23130
80002dda:	ea 18 ab cd 	orh	r8,0xabcd
80002dde:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002de0:	30 08       	mov	r8,0
80002de2:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002de4:	4b 59       	lddpc	r9,80002eb8 <phy_tx_func+0x474>
80002de6:	93 08       	st.w	r9[0x0],r8
80002de8:	c5 38       	rjmp	80002e8e <phy_tx_func+0x44a>

	else//Send-PCM-data（注意测试回放时：数字信道码流为320bytes/20ms)
	{
		
		
		Payload_frame_DATA_1 = ((PCM_frame_Payload[0]<<16) | (PCM_frame_Payload[1]));
80002dea:	4b d8       	lddpc	r8,80002edc <phy_tx_func+0x498>
80002dec:	90 0a       	ld.sh	r10,r8[0x0]
80002dee:	90 19       	ld.sh	r9,r8[0x2]
80002df0:	5c 79       	castu.h	r9
80002df2:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80002df6:	4b ba       	lddpc	r10,80002ee0 <phy_tx_func+0x49c>
80002df8:	95 09       	st.w	r10[0x0],r9
		Payload_frame_DATA_2 = ((PCM_frame_Payload[2]<<16) | (PCM_frame_Payload[3]));
80002dfa:	90 2a       	ld.sh	r10,r8[0x4]
80002dfc:	90 38       	ld.sh	r8,r8[0x6]
80002dfe:	5c 78       	castu.h	r8
80002e00:	f1 ea 11 08 	or	r8,r8,r10<<0x10
80002e04:	4b 8a       	lddpc	r10,80002ee4 <phy_tx_func+0x4a0>
80002e06:	95 08       	st.w	r10[0x0],r8
		
		
		
		if ((Payload_frame_DATA_1 == PAYLOADIDLE0) && (Payload_frame_DATA_2 == PAYLOADIDLE1))//loop IDLE frame
80002e08:	e0 6a 5a 5a 	mov	r10,23130
80002e0c:	ea 1a ab cd 	orh	r10,0xabcd
80002e10:	14 39       	cp.w	r9,r10
80002e12:	c0 71       	brne	80002e20 <phy_tx_func+0x3dc>
80002e14:	58 08       	cp.w	r8,0
80002e16:	c2 11       	brne	80002e58 <phy_tx_func+0x414>
		{
			payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e18:	8f 2a       	st.w	r7[0x8],r10
			payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e1a:	30 08       	mov	r8,0
80002e1c:	8f 38       	st.w	r7[0xc],r8
80002e1e:	c3 88       	rjmp	80002e8e <phy_tx_func+0x44a>
			
		}
		else////PCM encryption Mic media data
		{
		
			if ((Payload_frame_DATA_1 == 0xABCD21fe) || (Payload_frame_DATA_1 == 0xABCD2346)
80002e20:	e0 68 21 fe 	mov	r8,8702
80002e24:	ea 18 ab cd 	orh	r8,0xabcd
80002e28:	10 39       	cp.w	r9,r8
80002e2a:	5f 0a       	sreq	r10
80002e2c:	e0 68 23 46 	mov	r8,9030
80002e30:	ea 18 ab cd 	orh	r8,0xabcd
80002e34:	10 39       	cp.w	r9,r8
80002e36:	5f 08       	sreq	r8
80002e38:	f5 e8 10 08 	or	r8,r10,r8
80002e3c:	c0 41       	brne	80002e44 <phy_tx_func+0x400>
80002e3e:	ea 59 a0 00 	cp.w	r9,761856
80002e42:	c0 b1       	brne	80002e58 <phy_tx_func+0x414>
			|| (Payload_frame_DATA_1 == 0x00ba000) )
			{
			
		
				payload_tx_channel->word[0] = PCM_frame_Payload[0];
80002e44:	4a 68       	lddpc	r8,80002edc <phy_tx_func+0x498>
80002e46:	90 09       	ld.sh	r9,r8[0x0]
80002e48:	ae 49       	st.h	r7[0x8],r9
				payload_tx_channel->word[1] = PCM_frame_Payload[1];
80002e4a:	90 19       	ld.sh	r9,r8[0x2]
80002e4c:	ae 59       	st.h	r7[0xa],r9
				payload_tx_channel->word[2] = PCM_frame_Payload[2];
80002e4e:	90 29       	ld.sh	r9,r8[0x4]
80002e50:	ae 69       	st.h	r7[0xc],r9
				payload_tx_channel->word[3] = PCM_frame_Payload[3];
80002e52:	90 38       	ld.sh	r8,r8[0x6]
80002e54:	ae 78       	st.h	r7[0xe],r8
80002e56:	c1 c8       	rjmp	80002e8e <phy_tx_func+0x44a>
			}
			else//PCM encryption
			{
				if (Silent_flag)
80002e58:	4a 48       	lddpc	r8,80002ee8 <phy_tx_func+0x4a4>
80002e5a:	11 89       	ld.ub	r9,r8[0x0]
80002e5c:	30 08       	mov	r8,0
80002e5e:	f0 09 18 00 	cp.b	r9,r8
80002e62:	c0 b0       	breq	80002e78 <phy_tx_func+0x434>
				{
					payload_tx_channel->word[0] = PCM_frame_Payload[0];
80002e64:	49 e8       	lddpc	r8,80002edc <phy_tx_func+0x498>
80002e66:	90 09       	ld.sh	r9,r8[0x0]
80002e68:	ae 49       	st.h	r7[0x8],r9
					payload_tx_channel->word[1] = PCM_frame_Payload[1];
80002e6a:	90 19       	ld.sh	r9,r8[0x2]
80002e6c:	ae 59       	st.h	r7[0xa],r9
					payload_tx_channel->word[2] = PCM_frame_Payload[2];
80002e6e:	90 29       	ld.sh	r9,r8[0x4]
80002e70:	ae 69       	st.h	r7[0xc],r9
					payload_tx_channel->word[3] = PCM_frame_Payload[3];
80002e72:	90 38       	ld.sh	r8,r8[0x6]
80002e74:	ae 78       	st.h	r7[0xe],r8
80002e76:	c0 c8       	rjmp	80002e8e <phy_tx_func+0x44a>
				}
				else
				{
				
					payload_tx_channel->word[0] = (PCM_frame_Payload[0]);
80002e78:	49 98       	lddpc	r8,80002edc <phy_tx_func+0x498>
80002e7a:	90 09       	ld.sh	r9,r8[0x0]
80002e7c:	ae 49       	st.h	r7[0x8],r9
					payload_tx_channel->word[1] = (PCM_frame_Payload[1] );
80002e7e:	90 19       	ld.sh	r9,r8[0x2]
80002e80:	ae 59       	st.h	r7[0xa],r9
					payload_tx_channel->word[2] = (PCM_frame_Payload[2]);
80002e82:	90 29       	ld.sh	r9,r8[0x4]
80002e84:	ae 69       	st.h	r7[0xc],r9
					payload_tx_channel->word[3] = (PCM_frame_Payload[3] ^ Public_PCMkey);
80002e86:	90 38       	ld.sh	r8,r8[0x6]
80002e88:	ec 18 19 49 	eorl	r8,0x1949
80002e8c:	ae 78       	st.h	r7[0xe],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80002e8e:	2f fd       	sub	sp,-4
80002e90:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002e94:	00 00       	add	r0,r0
80002e96:	0a d4       	st.w	--r5,r4
80002e98:	00 00       	add	r0,r0
80002e9a:	0a a0       	st.w	r5++,r0
80002e9c:	00 00       	add	r0,r0
80002e9e:	0a 80       	andn	r0,r5
80002ea0:	80 00       	ld.sh	r0,r0[0x0]
80002ea2:	55 24       	stdsp	sp[0x148],r4
80002ea4:	00 00       	add	r0,r0
80002ea6:	0a d0       	st.w	--r5,r0
80002ea8:	00 00       	add	r0,r0
80002eaa:	0a 88       	andn	r8,r5
80002eac:	00 00       	add	r0,r0
80002eae:	0a 54       	eor	r4,r5
80002eb0:	00 00       	add	r0,r0
80002eb2:	0a 40       	or	r0,r5
80002eb4:	00 00       	add	r0,r0
80002eb6:	0a 7c       	tst	r12,r5
80002eb8:	00 00       	add	r0,r0
80002eba:	0a 9c       	mov	r12,r5
80002ebc:	00 00       	add	r0,r0
80002ebe:	0a 6c       	and	r12,r5
80002ec0:	00 00       	add	r0,r0
80002ec2:	0a 90       	mov	r0,r5
80002ec4:	00 00       	add	r0,r0
80002ec6:	0d c0       	ld.ub	r0,r6[0x4]
80002ec8:	00 00       	add	r0,r0
80002eca:	0e bc       	st.h	r7++,r12
80002ecc:	80 00       	ld.sh	r0,r0[0x0]
80002ece:	cb 80       	breq	80002e3e <phy_tx_func+0x3fa>
80002ed0:	00 00       	add	r0,r0
80002ed2:	0a 41       	or	r1,r5
80002ed4:	00 00       	add	r0,r0
80002ed6:	0d b8       	ld.ub	r8,r6[0x3]
80002ed8:	00 00       	add	r0,r0
80002eda:	0d c4       	ld.ub	r4,r6[0x4]
80002edc:	00 00       	add	r0,r0
80002ede:	04 f4       	st.b	--r2,r4
80002ee0:	00 00       	add	r0,r0
80002ee2:	0a e0       	st.h	--r5,r0
80002ee4:	00 00       	add	r0,r0
80002ee6:	0a 84       	andn	r4,r5
80002ee8:	00 00       	add	r0,r0
80002eea:	0a 56       	eor	r6,r5

80002eec <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002eec:	d4 01       	pushm	lr
80002eee:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002ef0:	30 0a       	mov	r10,0
80002ef2:	fa cb ff fc 	sub	r11,sp,-4
80002ef6:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002ef8:	14 99       	mov	r9,r10
80002efa:	1a 9b       	mov	r11,sp
80002efc:	f0 1f 00 05 	mcall	80002f10 <get_idle_store+0x24>
80002f00:	58 1c       	cp.w	r12,1
80002f02:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002f06:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002f0a:	2f fd       	sub	sp,-4
80002f0c:	d8 02       	popm	pc
80002f0e:	00 00       	add	r0,r0
80002f10:	80 00       	ld.sh	r0,r0[0x0]
80002f12:	56 14       	stdsp	sp[0x184],r4

80002f14 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002f14:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80002f18:	f0 1f 00 24 	mcall	80002fa8 <phy_init+0x94>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002f1c:	4a 4b       	lddpc	r11,80002fac <phy_init+0x98>
80002f1e:	4a 5c       	lddpc	r12,80002fb0 <phy_init+0x9c>
80002f20:	f0 1f 00 25 	mcall	80002fb4 <phy_init+0xa0>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80002f24:	30 4b       	mov	r11,4
80002f26:	31 ec       	mov	r12,30
80002f28:	f0 1f 00 24 	mcall	80002fb8 <phy_init+0xa4>
80002f2c:	4a 48       	lddpc	r8,80002fbc <phy_init+0xa8>
80002f2e:	91 0c       	st.w	r8[0x0],r12
80002f30:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80002f32:	10 96       	mov	r6,r8
80002f34:	4a 35       	lddpc	r5,80002fc0 <phy_init+0xac>
80002f36:	6c 0c       	ld.w	r12,r6[0x0]
80002f38:	ea 07 00 0b 	add	r11,r5,r7
80002f3c:	f0 1f 00 22 	mcall	80002fc4 <phy_init+0xb0>
80002f40:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80002f44:	e0 47 1e 00 	cp.w	r7,7680
80002f48:	cf 71       	brne	80002f36 <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f4a:	30 4b       	mov	r11,4
80002f4c:	31 4c       	mov	r12,20
80002f4e:	f0 1f 00 1b 	mcall	80002fb8 <phy_init+0xa4>
80002f52:	49 e8       	lddpc	r8,80002fc8 <phy_init+0xb4>
80002f54:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f56:	30 4b       	mov	r11,4
80002f58:	30 ac       	mov	r12,10
80002f5a:	f0 1f 00 18 	mcall	80002fb8 <phy_init+0xa4>
80002f5e:	49 c8       	lddpc	r8,80002fcc <phy_init+0xb8>
80002f60:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80002f62:	30 4b       	mov	r11,4
80002f64:	30 ac       	mov	r12,10
80002f66:	f0 1f 00 15 	mcall	80002fb8 <phy_init+0xa4>
80002f6a:	49 a8       	lddpc	r8,80002fd0 <phy_init+0xbc>
80002f6c:	91 0c       	st.w	r8[0x0],r12
80002f6e:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80002f70:	10 96       	mov	r6,r8
80002f72:	49 95       	lddpc	r5,80002fd4 <phy_init+0xc0>
80002f74:	6c 0c       	ld.w	r12,r6[0x0]
80002f76:	ea 07 00 0b 	add	r11,r5,r7
80002f7a:	f0 1f 00 13 	mcall	80002fc4 <phy_init+0xb0>
80002f7e:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80002f82:	e0 47 14 00 	cp.w	r7,5120
80002f86:	cf 71       	brne	80002f74 <phy_init+0x60>
		
	/*initialize the queue to send/receive xnl packet */
	
		
	phy_payload_frame_rx =
	xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f88:	30 4b       	mov	r11,4
80002f8a:	30 5c       	mov	r12,5
80002f8c:	f0 1f 00 0b 	mcall	80002fb8 <phy_init+0xa4>
	}
		
	/*initialize the queue to send/receive xnl packet */
	
		
	phy_payload_frame_rx =
80002f90:	49 28       	lddpc	r8,80002fd8 <phy_init+0xc4>
80002f92:	91 0c       	st.w	r8[0x0],r12
	xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));//未知bug不能屏蔽
80002f94:	e0 6b 01 00 	mov	r11,256
80002f98:	30 5c       	mov	r12,5
80002f9a:	f0 1f 00 08 	mcall	80002fb8 <phy_init+0xa4>
	
		
	phy_payload_frame_rx =
	xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	phy_payload_frame_tx =
80002f9e:	49 08       	lddpc	r8,80002fdc <phy_init+0xc8>
80002fa0:	91 0c       	st.w	r8[0x0],r12
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));//未知bug不能屏蔽
	#endif /*end if*/
	
}
80002fa2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002fa6:	00 00       	add	r0,r0
80002fa8:	80 00       	ld.sh	r0,r0[0x0]
80002faa:	40 40       	lddsp	r0,sp[0x10]
80002fac:	80 00       	ld.sh	r0,r0[0x0]
80002fae:	2a 44       	sub	r4,-92
80002fb0:	80 00       	ld.sh	r0,r0[0x0]
80002fb2:	30 40       	mov	r0,4
80002fb4:	80 00       	ld.sh	r0,r0[0x0]
80002fb6:	40 2c       	lddsp	r12,sp[0x8]
80002fb8:	80 00       	ld.sh	r0,r0[0x0]
80002fba:	59 78       	cp.w	r8,23
80002fbc:	00 00       	add	r0,r0
80002fbe:	0a b8       	st.h	r5++,r8
80002fc0:	00 00       	add	r0,r0
80002fc2:	22 c0       	sub	r0,44
80002fc4:	80 00       	ld.sh	r0,r0[0x0]
80002fc6:	29 a0       	sub	r0,-102
80002fc8:	00 00       	add	r0,r0
80002fca:	0a d4       	st.w	--r5,r4
80002fcc:	00 00       	add	r0,r0
80002fce:	0a bc       	st.h	r5++,r12
80002fd0:	00 00       	add	r0,r0
80002fd2:	0a 70       	tst	r0,r5
80002fd4:	00 00       	add	r0,r0
80002fd6:	0e c0       	st.b	r7++,r0
80002fd8:	00 00       	add	r0,r0
80002fda:	0a 74       	tst	r4,r5
80002fdc:	00 00       	add	r0,r0
80002fde:	0a c0       	st.b	r5++,r0

80002fe0 <payload_rx>:




static void payload_rx(void * payload)
{
80002fe0:	d4 01       	pushm	lr
80002fe2:	20 2d       	sub	sp,8
80002fe4:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002fe6:	30 08       	mov	r8,0
80002fe8:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
80002fea:	48 f8       	lddpc	r8,80003024 <payload_rx+0x44>
80002fec:	70 08       	ld.w	r8,r8[0x0]
80002fee:	58 08       	cp.w	r8,0
80002ff0:	c0 71       	brne	80002ffe <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80002ff2:	30 4b       	mov	r11,4
80002ff4:	30 5c       	mov	r12,5
80002ff6:	f0 1f 00 0d 	mcall	80003028 <payload_rx+0x48>
80002ffa:	48 b8       	lddpc	r8,80003024 <payload_rx+0x44>
80002ffc:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80002ffe:	48 a8       	lddpc	r8,80003024 <payload_rx+0x44>
80003000:	70 0c       	ld.w	r12,r8[0x0]
80003002:	30 09       	mov	r9,0
80003004:	fa ca ff fc 	sub	r10,sp,-4
80003008:	1a 9b       	mov	r11,sp
8000300a:	f0 1f 00 09 	mcall	8000302c <payload_rx+0x4c>
8000300e:	c0 91       	brne	80003020 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80003010:	48 88       	lddpc	r8,80003030 <payload_rx+0x50>
80003012:	70 0c       	ld.w	r12,r8[0x0]
80003014:	40 0b       	lddsp	r11,sp[0x0]
80003016:	f0 1f 00 08 	mcall	80003034 <payload_rx+0x54>
		logFromISR("mm");//触发未知BUG时，此处会被触发。
8000301a:	48 8c       	lddpc	r12,80003038 <payload_rx+0x58>
8000301c:	f0 1f 00 08 	mcall	8000303c <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
80003020:	2f ed       	sub	sp,-8
80003022:	d8 02       	popm	pc
80003024:	00 00       	add	r0,r0
80003026:	0a 74       	tst	r4,r5
80003028:	80 00       	ld.sh	r0,r0[0x0]
8000302a:	59 78       	cp.w	r8,23
8000302c:	80 00       	ld.sh	r0,r0[0x0]
8000302e:	57 d0       	stdsp	sp[0x1f4],r0
80003030:	00 00       	add	r0,r0
80003032:	0a 70       	tst	r0,r5
80003034:	80 00       	ld.sh	r0,r0[0x0]
80003036:	29 4c       	sub	r12,-108
80003038:	80 00       	ld.sh	r0,r0[0x0]
8000303a:	d1 3c       	*unknown*
8000303c:	80 00       	ld.sh	r0,r0[0x0]
8000303e:	65 9c       	ld.w	r12,r2[0x64]

80003040 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80003040:	eb cd 40 e0 	pushm	r5-r7,lr
80003044:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80003046:	fe f8 0e 1e 	ld.w	r8,pc[3614]
8000304a:	70 08       	ld.w	r8,r8[0x0]
8000304c:	58 08       	cp.w	r8,0
8000304e:	e0 80 01 05 	breq	80003258 <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80003052:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003054:	fe f8 0e 14 	ld.w	r8,pc[3604]
80003058:	70 09       	ld.w	r9,r8[0x0]
8000305a:	2f f9       	sub	r9,-1
8000305c:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
8000305e:	fe f8 0e 0e 	ld.w	r8,pc[3598]
80003062:	70 08       	ld.w	r8,r8[0x0]
80003064:	58 18       	cp.w	r8,1
80003066:	e0 80 00 84 	breq	8000316e <phy_rx_func+0x12e>
8000306a:	c0 73       	brcs	80003078 <phy_rx_func+0x38>
8000306c:	58 28       	cp.w	r8,2
8000306e:	c5 b0       	breq	80003124 <phy_rx_func+0xe4>
80003070:	58 38       	cp.w	r8,3
80003072:	e0 81 00 f3 	brne	80003258 <phy_rx_func+0x218>
80003076:	cd 38       	rjmp	8000321c <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80003078:	e0 6a 5a 5a 	mov	r10,23130
8000307c:	ea 1a ab cd 	orh	r10,0xabcd
80003080:	14 36       	cp.w	r6,r10
80003082:	e0 80 00 eb 	breq	80003258 <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80003086:	ec 08 16 10 	lsr	r8,r6,0x10
8000308a:	e0 48 ab cd 	cp.w	r8,43981
8000308e:	e0 81 00 e5 	brne	80003258 <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80003092:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80003096:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000309a:	20 28       	sub	r8,2
8000309c:	fe f9 0d d4 	ld.w	r9,pc[3540]
800030a0:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
800030a2:	30 09       	mov	r9,0
800030a4:	f2 08 19 00 	cp.h	r8,r9
800030a8:	e0 8a 00 d8 	brle	80003258 <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
800030ac:	fe f8 0d c8 	ld.w	r8,pc[3528]
800030b0:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
800030b2:	fe f8 0d c6 	ld.w	r8,pc[3526]
800030b6:	70 0c       	ld.w	r12,r8[0x0]
800030b8:	f0 1f 03 71 	mcall	80003e7c <phy_rx_func+0xe3c>
800030bc:	fe f8 0d c4 	ld.w	r8,pc[3524]
800030c0:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
800030c2:	58 0c       	cp.w	r12,0
800030c4:	e0 80 00 ca 	breq	80003258 <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800030c8:	fe f8 0d ac 	ld.w	r8,pc[3500]
800030cc:	90 09       	ld.sh	r9,r8[0x0]
800030ce:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
800030d2:	2f f9       	sub	r9,-1
800030d4:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800030d6:	fe fa 0d aa 	ld.w	r10,pc[3498]
800030da:	74 0a       	ld.w	r10,r10[0x0]
800030dc:	fe fb 0d 8c 	ld.w	r11,pc[3468]
800030e0:	76 0b       	ld.w	r11,r11[0x0]
800030e2:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
800030e6:	2f f9       	sub	r9,-1
800030e8:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
800030ea:	e2 16 0f 00 	andl	r6,0xf00,COH
800030ee:	e0 46 01 00 	cp.w	r6,256
800030f2:	c0 c0       	breq	8000310a <phy_rx_func+0xca>
800030f4:	e0 8b 00 05 	brhi	800030fe <phy_rx_func+0xbe>
800030f8:	58 06       	cp.w	r6,0
800030fa:	c0 80       	breq	8000310a <phy_rx_func+0xca>
800030fc:	c0 c8       	rjmp	80003114 <phy_rx_func+0xd4>
800030fe:	e0 46 02 00 	cp.w	r6,512
80003102:	c0 40       	breq	8000310a <phy_rx_func+0xca>
80003104:	e0 46 03 00 	cp.w	r6,768
80003108:	c0 61       	brne	80003114 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
8000310a:	30 29       	mov	r9,2
8000310c:	fe f8 0d 60 	ld.w	r8,pc[3424]
80003110:	91 09       	st.w	r8[0x0],r9
80003112:	ca 38       	rjmp	80003258 <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
80003114:	fe f6 0d 6c 	ld.w	r6,pc[3436]
80003118:	6c 0c       	ld.w	r12,r6[0x0]
8000311a:	f0 1f 03 5b 	mcall	80003e84 <phy_rx_func+0xe44>
					phy_frame_ptr = NULL;					
8000311e:	30 08       	mov	r8,0
80003120:	8d 08       	st.w	r6[0x0],r8
80003122:	c9 b8       	rjmp	80003258 <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003124:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80003128:	b1 86       	lsr	r6,0x10
8000312a:	14 06       	add	r6,r10
8000312c:	fe f8 0d 5c 	ld.w	r8,pc[3420]
80003130:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003132:	fe f8 0d 42 	ld.w	r8,pc[3394]
80003136:	90 09       	ld.sh	r9,r8[0x0]
80003138:	fe fb 0d 48 	ld.w	r11,pc[3400]
8000313c:	76 0b       	ld.w	r11,r11[0x0]
8000313e:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80003142:	2f f9       	sub	r9,-1
80003144:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80003146:	fe f9 0d 2a 	ld.w	r9,pc[3370]
8000314a:	92 08       	ld.sh	r8,r9[0x0]
8000314c:	20 28       	sub	r8,2
8000314e:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80003150:	30 09       	mov	r9,0
80003152:	f2 08 19 00 	cp.h	r8,r9
80003156:	e0 8a 00 07 	brle	80003164 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
8000315a:	30 19       	mov	r9,1
8000315c:	fe f8 0d 10 	ld.w	r8,pc[3344]
80003160:	91 09       	st.w	r8[0x0],r9
80003162:	c7 b8       	rjmp	80003258 <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80003164:	30 39       	mov	r9,3
80003166:	fe f8 0d 06 	ld.w	r8,pc[3334]
8000316a:	91 09       	st.w	r8[0x0],r9
8000316c:	c7 68       	rjmp	80003258 <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
8000316e:	ec 0a 14 10 	asr	r10,r6,0x10
80003172:	fe f8 0d 16 	ld.w	r8,pc[3350]
80003176:	90 09       	ld.sh	r9,r8[0x0]
80003178:	14 09       	add	r9,r10
8000317a:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000317c:	fe f9 0c f8 	ld.w	r9,pc[3320]
80003180:	92 08       	ld.sh	r8,r9[0x0]
80003182:	fe fb 0c fe 	ld.w	r11,pc[3326]
80003186:	76 0b       	ld.w	r11,r11[0x0]
80003188:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
8000318c:	2f f8       	sub	r8,-1
8000318e:	5c 88       	casts.h	r8
80003190:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003192:	fe fa 0c de 	ld.w	r10,pc[3294]
80003196:	94 09       	ld.sh	r9,r10[0x0]
80003198:	20 29       	sub	r9,2
8000319a:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
8000319c:	30 0a       	mov	r10,0
8000319e:	f4 09 19 00 	cp.h	r9,r10
800031a2:	e0 89 00 1f 	brgt	800031e0 <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
800031a6:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
800031aa:	e0 46 00 ba 	cp.w	r6,186
800031ae:	c0 d1       	brne	800031c8 <phy_rx_func+0x188>
800031b0:	fe f8 0c d8 	ld.w	r8,pc[3288]
800031b4:	90 09       	ld.sh	r9,r8[0x0]
800031b6:	f4 09 19 00 	cp.h	r9,r10
800031ba:	c0 71       	brne	800031c8 <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
800031bc:	fe f8 0c c4 	ld.w	r8,pc[3268]
800031c0:	70 0c       	ld.w	r12,r8[0x0]
800031c2:	f0 1f 03 33 	mcall	80003e8c <phy_rx_func+0xe4c>
800031c6:	c0 88       	rjmp	800031d6 <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
800031c8:	fe f6 0c b8 	ld.w	r6,pc[3256]
800031cc:	6c 0c       	ld.w	r12,r6[0x0]
800031ce:	f0 1f 03 2e 	mcall	80003e84 <phy_rx_func+0xe44>
					phy_frame_ptr = NULL;
800031d2:	30 08       	mov	r8,0
800031d4:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
800031d6:	30 09       	mov	r9,0
800031d8:	fe f8 0c 94 	ld.w	r8,pc[3220]
800031dc:	91 09       	st.w	r8[0x0],r9
800031de:	c3 d8       	rjmp	80003258 <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
800031e0:	5c 86       	casts.h	r6
800031e2:	fe f9 0c a6 	ld.w	r9,pc[3238]
800031e6:	92 0a       	ld.sh	r10,r9[0x0]
800031e8:	0c 0a       	add	r10,r6
800031ea:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800031ec:	fe f9 0c 94 	ld.w	r9,pc[3220]
800031f0:	72 09       	ld.w	r9,r9[0x0]
800031f2:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
800031f6:	2f f8       	sub	r8,-1
800031f8:	fe f9 0c 7c 	ld.w	r9,pc[3196]
800031fc:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
800031fe:	fe f9 0c 72 	ld.w	r9,pc[3186]
80003202:	92 08       	ld.sh	r8,r9[0x0]
80003204:	20 28       	sub	r8,2
80003206:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003208:	30 09       	mov	r9,0
8000320a:	f2 08 19 00 	cp.h	r8,r9
8000320e:	e0 89 00 25 	brgt	80003258 <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003212:	30 39       	mov	r9,3
80003214:	fe f8 0c 58 	ld.w	r8,pc[3160]
80003218:	91 09       	st.w	r8[0x0],r9
8000321a:	c1 f8       	rjmp	80003258 <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
8000321c:	e6 16 00 ff 	andh	r6,0xff,COH
80003220:	fc 19 00 ba 	movh	r9,0xba
80003224:	12 36       	cp.w	r6,r9
80003226:	c0 e1       	brne	80003242 <phy_rx_func+0x202>
80003228:	fe f8 0c 60 	ld.w	r8,pc[3168]
8000322c:	90 09       	ld.sh	r9,r8[0x0]
8000322e:	30 08       	mov	r8,0
80003230:	f0 09 19 00 	cp.h	r9,r8
80003234:	c0 71       	brne	80003242 <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003236:	fe f8 0c 4a 	ld.w	r8,pc[3146]
8000323a:	70 0c       	ld.w	r12,r8[0x0]
8000323c:	f0 1f 03 14 	mcall	80003e8c <phy_rx_func+0xe4c>
80003240:	c0 88       	rjmp	80003250 <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
80003242:	fe f6 0c 3e 	ld.w	r6,pc[3134]
80003246:	6c 0c       	ld.w	r12,r6[0x0]
80003248:	f0 1f 03 0f 	mcall	80003e84 <phy_rx_func+0xe44>
				phy_frame_ptr = NULL;
8000324c:	30 08       	mov	r8,0
8000324e:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80003250:	30 09       	mov	r9,0
80003252:	fe f8 0c 1a 	ld.w	r8,pc[3098]
80003256:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
80003258:	fe f8 0c 38 	ld.w	r8,pc[3128]
8000325c:	11 89       	ld.ub	r9,r8[0x0]
8000325e:	30 08       	mov	r8,0
80003260:	f0 09 18 00 	cp.b	r9,r8
80003264:	c1 31       	brne	8000328a <phy_rx_func+0x24a>
	{
		payload_ptr = get_payload_idle_isr();
80003266:	fe f6 0c 2e 	ld.w	r6,pc[3118]
8000326a:	6c 0c       	ld.w	r12,r6[0x0]
8000326c:	f0 1f 03 04 	mcall	80003e7c <phy_rx_func+0xe3c>
80003270:	fe f8 0c 28 	ld.w	r8,pc[3112]
80003274:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003276:	6c 0c       	ld.w	r12,r6[0x0]
80003278:	f0 1f 03 01 	mcall	80003e7c <phy_rx_func+0xe3c>
8000327c:	fe f8 0c 20 	ld.w	r8,pc[3104]
80003280:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003282:	30 19       	mov	r9,1
80003284:	fe f8 0c 0c 	ld.w	r8,pc[3084]
80003288:	b0 89       	st.b	r8[0x0],r9
	}	
	
	
	PCM_frame_Payload[0] = payload_rx_channel->word[0];
8000328a:	8e 49       	ld.sh	r9,r7[0x8]
8000328c:	fe f8 0c 14 	ld.w	r8,pc[3092]
80003290:	b0 09       	st.h	r8[0x0],r9
	PCM_frame_Payload[1] = payload_rx_channel->word[1];
80003292:	8e 59       	ld.sh	r9,r7[0xa]
80003294:	b0 19       	st.h	r8[0x2],r9
	PCM_frame_Payload[2] = payload_rx_channel->word[2];
80003296:	8e 69       	ld.sh	r9,r7[0xc]
80003298:	b0 29       	st.h	r8[0x4],r9
	PCM_frame_Payload[3] = payload_rx_channel->word[3];
8000329a:	8e 79       	ld.sh	r9,r7[0xe]
8000329c:	b0 39       	st.h	r8[0x6],r9
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
8000329e:	fe f8 0c 06 	ld.w	r8,pc[3078]
800032a2:	70 08       	ld.w	r8,r8[0x0]
800032a4:	58 28       	cp.w	r8,2
800032a6:	e0 80 01 bd 	breq	80003620 <phy_rx_func+0x5e0>
800032aa:	e0 8b 00 06 	brhi	800032b6 <phy_rx_func+0x276>
800032ae:	58 08       	cp.w	r8,0
800032b0:	c0 b0       	breq	800032c6 <phy_rx_func+0x286>
800032b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800032b6:	58 38       	cp.w	r8,3
800032b8:	e0 80 05 90 	breq	80003dd8 <phy_rx_func+0xd98>
800032bc:	58 48       	cp.w	r8,4
800032be:	e0 81 05 d1 	brne	80003e60 <phy_rx_func+0xe20>
800032c2:	e0 8f 02 70 	bral	800037a2 <phy_rx_func+0x762>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800032c6:	6e 28       	ld.w	r8,r7[0x8]
800032c8:	e0 6a 5a 5a 	mov	r10,23130
800032cc:	ea 1a ab cd 	orh	r10,0xabcd
800032d0:	14 38       	cp.w	r8,r10
800032d2:	c0 71       	brne	800032e0 <phy_rx_func+0x2a0>
			{
				
				m_RxBurstType = VOICE_WATING;
800032d4:	30 09       	mov	r9,0
800032d6:	fe f8 0b d2 	ld.w	r8,pc[3026]
800032da:	91 09       	st.w	r8[0x0],r9
800032dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800032e0:	10 99       	mov	r9,r8
800032e2:	e0 19 00 00 	andl	r9,0x0
800032e6:	fc 1a ab cd 	movh	r10,0xabcd
800032ea:	14 39       	cp.w	r9,r10
800032ec:	e0 81 05 ba 	brne	80003e60 <phy_rx_func+0xe20>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800032f0:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800032f4:	fe f9 0b b8 	ld.w	r9,pc[3000]
800032f8:	93 08       	st.w	r9[0x0],r8
		
			if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
800032fa:	fe f8 0b 9e 	ld.w	r8,pc[2974]
800032fe:	70 08       	ld.w	r8,r8[0x0]
80003300:	58 08       	cp.w	r8,0
80003302:	c0 60       	breq	8000330e <phy_rx_func+0x2ce>
80003304:	fe f8 0b 98 	ld.w	r8,pc[2968]
80003308:	70 08       	ld.w	r8,r8[0x0]
8000330a:	58 08       	cp.w	r8,0
8000330c:	c1 a1       	brne	80003340 <phy_rx_func+0x300>
			{
				payload_ptr = get_payload_idle_isr();
8000330e:	fe f6 0b 86 	ld.w	r6,pc[2950]
80003312:	6c 0c       	ld.w	r12,r6[0x0]
80003314:	f0 1f 02 da 	mcall	80003e7c <phy_rx_func+0xe3c>
80003318:	fe f5 0b 80 	ld.w	r5,pc[2944]
8000331c:	8b 0c       	st.w	r5[0x0],r12
				AMBE_payload_ptr = get_payload_idle_isr();
8000331e:	6c 0c       	ld.w	r12,r6[0x0]
80003320:	f0 1f 02 d7 	mcall	80003e7c <phy_rx_func+0xe3c>
80003324:	fe f8 0b 78 	ld.w	r8,pc[2936]
80003328:	91 0c       	st.w	r8[0x0],r12
				
				if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
8000332a:	6a 08       	ld.w	r8,r5[0x0]
8000332c:	58 08       	cp.w	r8,0
8000332e:	c0 30       	breq	80003334 <phy_rx_func+0x2f4>
80003330:	58 0c       	cp.w	r12,0
80003332:	c0 71       	brne	80003340 <phy_rx_func+0x300>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003334:	fe fc 0b 7c 	ld.w	r12,pc[2940]
80003338:	f0 1f 02 df 	mcall	80003eb4 <phy_rx_func+0xe74>
8000333c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			}
			
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80003340:	6e 28       	ld.w	r8,r7[0x8]
80003342:	e2 18 f0 00 	andl	r8,0xf000,COH
80003346:	e0 48 c0 00 	cp.w	r8,49152
8000334a:	e0 81 00 c7 	brne	800034d8 <phy_rx_func+0x498>
			{
											
				Item_ID = payload_rx_channel->byte[5];
8000334e:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003352:	fe f8 0b 66 	ld.w	r8,pc[2918]
80003356:	b0 89       	st.b	r8[0x0],r9
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003358:	ef 3a 00 0c 	ld.ub	r10,r7[12]
8000335c:	f5 da c0 07 	bfextu	r10,r10,0x0,0x7
80003360:	fe f9 0b 5c 	ld.w	r9,pc[2908]
80003364:	93 0a       	st.w	r9[0x0],r10
								
				switch(Item_ID)
80003366:	11 88       	ld.ub	r8,r8[0x0]
80003368:	37 f9       	mov	r9,127
8000336a:	f2 08 18 00 	cp.b	r8,r9
8000336e:	c6 b0       	breq	80003444 <phy_rx_func+0x404>
80003370:	e0 8b 00 0c 	brhi	80003388 <phy_rx_func+0x348>
80003374:	31 29       	mov	r9,18
80003376:	f2 08 18 00 	cp.b	r8,r9
8000337a:	c4 20       	breq	800033fe <phy_rx_func+0x3be>
8000337c:	31 39       	mov	r9,19
8000337e:	f2 08 18 00 	cp.b	r8,r9
80003382:	e0 81 00 8b 	brne	80003498 <phy_rx_func+0x458>
80003386:	c5 98       	rjmp	80003438 <phy_rx_func+0x3f8>
80003388:	2f 08       	sub	r8,-16
8000338a:	30 19       	mov	r9,1
8000338c:	f2 08 18 00 	cp.b	r8,r9
80003390:	e0 8b 00 84 	brhi	80003498 <phy_rx_func+0x458>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003394:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003398:	e2 18 00 f0 	andl	r8,0xf0,COH
8000339c:	59 08       	cp.w	r8,16
8000339e:	c0 71       	brne	800033ac <phy_rx_func+0x36c>
							{
								m_RxBurstType = VOICEHEADER;
800033a0:	30 19       	mov	r9,1
800033a2:	fe f8 0b 06 	ld.w	r8,pc[2822]
800033a6:	91 09       	st.w	r8[0x0],r9
800033a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800033ac:	e0 48 00 20 	cp.w	r8,32
800033b0:	c2 11       	brne	800033f2 <phy_rx_func+0x3b2>
							{
								m_RxBurstType = VOICETERMINATOR;
800033b2:	30 a9       	mov	r9,10
800033b4:	fe f8 0a f4 	ld.w	r8,pc[2804]
800033b8:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800033ba:	fe f6 0b 06 	ld.w	r6,pc[2822]
800033be:	6c 08       	ld.w	r8,r6[0x0]
800033c0:	f0 0a 11 ff 	rsub	r10,r8,-1
800033c4:	fe f7 0a d8 	ld.w	r7,pc[2776]
800033c8:	2f f8       	sub	r8,-1
800033ca:	6e 0c       	ld.w	r12,r7[0x0]
800033cc:	f4 ca fe 00 	sub	r10,r10,-512
800033d0:	30 0b       	mov	r11,0
800033d2:	10 0c       	add	r12,r8
800033d4:	f0 1f 02 bc 	mcall	80003ec4 <phy_rx_func+0xe84>
								
								RxAMBE_IsFillingNext8 = 0;
800033d8:	30 08       	mov	r8,0
800033da:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
800033dc:	6e 0c       	ld.w	r12,r7[0x0]
800033de:	f0 1f 02 bb 	mcall	80003ec8 <phy_rx_func+0xe88>
								AMBE_payload_ptr = get_payload_idle_isr();
800033e2:	fe f8 0a b2 	ld.w	r8,pc[2738]
800033e6:	70 0c       	ld.w	r12,r8[0x0]
800033e8:	f0 1f 02 a5 	mcall	80003e7c <phy_rx_func+0xe3c>
800033ec:	8f 0c       	st.w	r7[0x0],r12
800033ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
800033f2:	30 09       	mov	r9,0
800033f4:	fe f8 0a b4 	ld.w	r8,pc[2740]
800033f8:	91 09       	st.w	r8[0x0],r9
800033fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800033fe:	fe f9 0a ae 	ld.w	r9,pc[2734]
80003402:	72 08       	ld.w	r8,r9[0x0]
80003404:	20 48       	sub	r8,4
80003406:	93 08       	st.w	r9[0x0],r8
80003408:	e0 80 05 2c 	breq	80003e60 <phy_rx_func+0xe20>
					
							//Vocoder Bits Stream Parameter
							VF_SN = payload_rx_channel->byte[7];//This parameter is very important to the loop back Radio, as a reference.
8000340c:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003410:	fe f8 0a bc 	ld.w	r8,pc[2748]
80003414:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003416:	8e 69       	ld.sh	r9,r7[0xc]
80003418:	fe f8 0a b8 	ld.w	r8,pc[2744]
8000341c:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
8000341e:	8e 79       	ld.sh	r9,r7[0xe]
80003420:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003422:	f0 1f 02 ad 	mcall	80003ed4 <phy_rx_func+0xe94>
80003426:	fe f8 0a 82 	ld.w	r8,pc[2690]
8000342a:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000342c:	30 49       	mov	r9,4
8000342e:	fe f8 0a 76 	ld.w	r8,pc[2678]
80003432:	91 09       	st.w	r8[0x0],r9
80003434:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003438:	30 09       	mov	r9,0
8000343a:	fe f8 0a 6e 	ld.w	r8,pc[2670]
8000343e:	91 09       	st.w	r8[0x0],r9
80003440:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
							
								
					case Radio_Internal_Parameter://0x7F
							
							logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
80003444:	fe f8 0a 78 	ld.w	r8,pc[2680]
80003448:	70 08       	ld.w	r8,r8[0x0]
8000344a:	1a d8       	st.w	--sp,r8
8000344c:	fe fc 0a 8c 	ld.w	r12,pc[2700]
80003450:	f0 1f 02 99 	mcall	80003eb4 <phy_rx_func+0xe74>
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003454:	fe f9 0a 58 	ld.w	r9,pc[2648]
80003458:	72 08       	ld.w	r8,r9[0x0]
8000345a:	20 48       	sub	r8,4
8000345c:	93 08       	st.w	r9[0x0],r8
8000345e:	2f fd       	sub	sp,-4
80003460:	58 08       	cp.w	r8,0
80003462:	e0 80 04 ff 	breq	80003e60 <phy_rx_func+0xe20>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003466:	fe f8 0a 76 	ld.w	r8,pc[2678]
8000346a:	70 09       	ld.w	r9,r8[0x0]
8000346c:	8e 7b       	ld.sh	r11,r7[0xe]
8000346e:	fe fa 0a 72 	ld.w	r10,pc[2674]
80003472:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003476:	2f f9       	sub	r9,-1
80003478:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
8000347a:	fe f8 0a 42 	ld.w	r8,pc[2626]
8000347e:	70 09       	ld.w	r9,r8[0x0]
80003480:	20 29       	sub	r9,2
80003482:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003484:	30 29       	mov	r9,2
80003486:	fe f8 0a 22 	ld.w	r8,pc[2594]
8000348a:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
8000348c:	30 39       	mov	r9,3
8000348e:	fe f8 0a 16 	ld.w	r8,pc[2582]
80003492:	91 09       	st.w	r8[0x0],r9
80003494:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003498:	30 39       	mov	r9,3
8000349a:	fe f8 0a 0e 	ld.w	r8,pc[2574]
8000349e:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
800034a0:	6e 29       	ld.w	r9,r7[0x8]
800034a2:	fe f8 0a 42 	ld.w	r8,pc[2626]
800034a6:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
800034a8:	6e 39       	ld.w	r9,r7[0xc]
800034aa:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
800034ac:	fe f8 0a 00 	ld.w	r8,pc[2560]
800034b0:	70 08       	ld.w	r8,r8[0x0]
800034b2:	59 48       	cp.w	r8,20
800034b4:	c0 61       	brne	800034c0 <phy_rx_func+0x480>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
800034b6:	31 89       	mov	r9,24
800034b8:	fe f8 09 f4 	ld.w	r8,pc[2548]
800034bc:	91 09       	st.w	r8[0x0],r9
800034be:	c0 78       	rjmp	800034cc <phy_rx_func+0x48c>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
800034c0:	59 08       	cp.w	r8,16
800034c2:	c0 51       	brne	800034cc <phy_rx_func+0x48c>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
800034c4:	31 09       	mov	r9,16
800034c6:	fe f8 09 e6 	ld.w	r8,pc[2534]
800034ca:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
800034cc:	30 49       	mov	r9,4
800034ce:	fe f8 09 d6 	ld.w	r8,pc[2518]
800034d2:	91 09       	st.w	r8[0x0],r9
800034d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
800034d8:	e0 48 10 00 	cp.w	r8,4096
800034dc:	5f 1a       	srne	r10
800034de:	e0 48 20 00 	cp.w	r8,8192
800034e2:	5f 19       	srne	r9
800034e4:	f5 e9 00 09 	and	r9,r10,r9
800034e8:	e0 81 04 bc 	brne	80003e60 <phy_rx_func+0xe20>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
							
					if ((payload_rx_channel->dword[0] & 0x0000F000 ) == SPEAKER_DATA)
800034ec:	e0 48 10 00 	cp.w	r8,4096
800034f0:	e0 80 04 b8 	breq	80003e60 <phy_rx_func+0xe20>
					{
						break;//65794的机器通道有问题
					}
				AMBE_tx_flag = 0;
800034f4:	30 08       	mov	r8,0
800034f6:	fe f9 09 f2 	ld.w	r9,pc[2546]
800034fa:	b2 88       	st.b	r9[0x0],r8
				AMBE_rx_flag = 0;
800034fc:	fe f9 09 f0 	ld.w	r9,pc[2544]
80003500:	b2 88       	st.b	r9[0x0],r8
				
				Item_ID = 0;//To make sure your save PCM data.
80003502:	fe f9 09 b6 	ld.w	r9,pc[2486]
80003506:	b2 88       	st.b	r9[0x0],r8
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003508:	6e 28       	ld.w	r8,r7[0x8]
8000350a:	e2 18 0f 00 	andl	r8,0xf00,COH
8000350e:	58 18       	cp.w	r8,1
80003510:	e0 8b 00 56 	brhi	800035bc <phy_rx_func+0x57c>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
				if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003514:	fe f9 09 98 	ld.w	r9,pc[2456]
80003518:	72 08       	ld.w	r8,r9[0x0]
8000351a:	20 48       	sub	r8,4
8000351c:	93 08       	st.w	r9[0x0],r8
8000351e:	e0 80 04 a1 	breq	80003e60 <phy_rx_func+0xe20>
				ArrayDiscLength = payload_rx_channel->word[2];
80003522:	8e 68       	ld.sh	r8,r7[0xc]
80003524:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003528:	fe f9 09 c8 	ld.w	r9,pc[2504]
8000352c:	93 0a       	st.w	r9[0x0],r10
				
				switch (ArrayDiscLength){
8000352e:	30 09       	mov	r9,0
80003530:	f2 08 19 00 	cp.h	r8,r9
80003534:	c0 70       	breq	80003542 <phy_rx_func+0x502>
80003536:	30 19       	mov	r9,1
80003538:	f2 08 19 00 	cp.h	r8,r9
8000353c:	e0 81 04 92 	brne	80003e60 <phy_rx_func+0xe20>
80003540:	c2 68       	rjmp	8000358c <phy_rx_func+0x54c>
					case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003542:	fe f8 09 b2 	ld.w	r8,pc[2482]
80003546:	70 0a       	ld.w	r10,r8[0x0]
80003548:	fe f9 09 50 	ld.w	r9,pc[2384]
8000354c:	72 09       	ld.w	r9,r9[0x0]
8000354e:	8e 7b       	ld.sh	r11,r7[0xe]
80003550:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
80003554:	70 09       	ld.w	r9,r8[0x0]
80003556:	2f f9       	sub	r9,-1
80003558:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000355a:	e0 49 00 ff 	cp.w	r9,255
8000355e:	e0 88 00 11 	brls	80003580 <phy_rx_func+0x540>
						{
							RxMedia_IsFillingNext16 = 0;	
80003562:	30 09       	mov	r9,0
80003564:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);	
80003566:	fe f7 09 32 	ld.w	r7,pc[2354]
8000356a:	6e 0c       	ld.w	r12,r7[0x0]
8000356c:	f0 1f 02 57 	mcall	80003ec8 <phy_rx_func+0xe88>
							payload_ptr = get_payload_idle_isr();
80003570:	fe f8 09 24 	ld.w	r8,pc[2340]
80003574:	70 0c       	ld.w	r12,r8[0x0]
80003576:	f0 1f 02 42 	mcall	80003e7c <phy_rx_func+0xe3c>
8000357a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
8000357c:	e0 80 04 72 	breq	80003e60 <phy_rx_func+0xe20>
							{
								break;
							}				
						}
							RxMediaState = READINGMEDIA;
80003580:	30 29       	mov	r9,2
80003582:	fe f8 09 22 	ld.w	r8,pc[2338]
80003586:	91 09       	st.w	r8[0x0],r9
80003588:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				
					case 1: //The next usual case.
							//In general case, add code to process single word Array descriptor.
							if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
8000358c:	8e 78       	ld.sh	r8,r7[0xe]
8000358e:	30 39       	mov	r9,3
80003590:	f2 08 19 00 	cp.h	r8,r9
80003594:	c0 61       	brne	800035a0 <phy_rx_func+0x560>
							{
								Terminator_Flag = 1;
80003596:	30 19       	mov	r9,1
80003598:	fe f8 09 60 	ld.w	r8,pc[2400]
8000359c:	b0 89       	st.b	r8[0x0],r9
8000359e:	c0 98       	rjmp	800035b0 <phy_rx_func+0x570>

							}
							else if(payload_rx_channel->word[3] == 0x0004)//Silent Descriptor
800035a0:	30 49       	mov	r9,4
800035a2:	f2 08 19 00 	cp.h	r8,r9
800035a6:	c0 51       	brne	800035b0 <phy_rx_func+0x570>
							{
							
								Silent_flag = 1;
800035a8:	30 19       	mov	r9,1
800035aa:	fe f8 09 52 	ld.w	r8,pc[2386]
800035ae:	b0 89       	st.b	r8[0x0],r9
							{
								//Terminator_Flag = 0;
							}
					
					
							RxMediaState = READINGMEDIA;
800035b0:	30 29       	mov	r9,2
800035b2:	fe f8 08 f2 	ld.w	r8,pc[2290]
800035b6:	91 09       	st.w	r8[0x0],r9
800035b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
				}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
800035bc:	fe f8 08 f0 	ld.w	r8,pc[2288]
800035c0:	70 08       	ld.w	r8,r8[0x0]
800035c2:	58 18       	cp.w	r8,1
800035c4:	e0 88 04 4e 	brls	80003e60 <phy_rx_func+0xe20>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
800035c8:	fe f8 09 2c 	ld.w	r8,pc[2348]
800035cc:	70 0a       	ld.w	r10,r8[0x0]
800035ce:	fe f9 08 ca 	ld.w	r9,pc[2250]
800035d2:	72 09       	ld.w	r9,r9[0x0]
800035d4:	6e 3b       	ld.w	r11,r7[0xc]
800035d6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800035da:	70 09       	ld.w	r9,r8[0x0]
800035dc:	2f f9       	sub	r9,-1
800035de:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800035e0:	e0 49 00 ff 	cp.w	r9,255
800035e4:	e0 88 00 11 	brls	80003606 <phy_rx_func+0x5c6>
				{
					RxMedia_IsFillingNext16 = 0;
800035e8:	30 09       	mov	r9,0
800035ea:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800035ec:	fe f7 08 ac 	ld.w	r7,pc[2220]
800035f0:	6e 0c       	ld.w	r12,r7[0x0]
800035f2:	f0 1f 02 36 	mcall	80003ec8 <phy_rx_func+0xe88>
								payload_ptr = get_payload_idle_isr();
800035f6:	fe f8 08 9e 	ld.w	r8,pc[2206]
800035fa:	70 0c       	ld.w	r12,r8[0x0]
800035fc:	f0 1f 02 20 	mcall	80003e7c <phy_rx_func+0xe3c>
80003600:	8f 0c       	st.w	r7[0x0],r12
													if(NULL == payload_ptr)
80003602:	e0 80 04 2f 	breq	80003e60 <phy_rx_func+0xe20>
													{
														break;
													}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003606:	fe f9 08 a6 	ld.w	r9,pc[2214]
8000360a:	72 08       	ld.w	r8,r9[0x0]
8000360c:	20 28       	sub	r8,2
8000360e:	93 08       	st.w	r9[0x0],r8
80003610:	e0 80 04 28 	breq	80003e60 <phy_rx_func+0xe20>
				RxMediaState = READINGMEDIA;
80003614:	30 29       	mov	r9,2
80003616:	fe f8 08 8e 	ld.w	r8,pc[2190]
8000361a:	91 09       	st.w	r8[0x0],r9
8000361c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
						
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003620:	fe f8 08 d4 	ld.w	r8,pc[2260]
80003624:	70 0a       	ld.w	r10,r8[0x0]
80003626:	fe f9 08 72 	ld.w	r9,pc[2162]
8000362a:	72 09       	ld.w	r9,r9[0x0]
8000362c:	8e 4b       	ld.sh	r11,r7[0x8]
8000362e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003632:	70 09       	ld.w	r9,r8[0x0]
80003634:	2f f9       	sub	r9,-1
80003636:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003638:	e0 49 00 ff 	cp.w	r9,255
8000363c:	e0 88 00 16 	brls	80003668 <phy_rx_func+0x628>
					{
							RxMedia_IsFillingNext16 = 0;
80003640:	30 09       	mov	r9,0
80003642:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80003644:	fe f6 08 54 	ld.w	r6,pc[2132]
80003648:	6c 0c       	ld.w	r12,r6[0x0]
8000364a:	f0 1f 02 20 	mcall	80003ec8 <phy_rx_func+0xe88>
							payload_ptr = get_payload_idle_isr();
8000364e:	fe f8 08 46 	ld.w	r8,pc[2118]
80003652:	70 0c       	ld.w	r12,r8[0x0]
80003654:	f0 1f 02 0a 	mcall	80003e7c <phy_rx_func+0xe3c>
80003658:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == payload_ptr)
8000365a:	c0 71       	brne	80003668 <phy_rx_func+0x628>
							{
								RxMediaState = WAITINGABAB;
8000365c:	30 09       	mov	r9,0
8000365e:	fe f8 08 46 	ld.w	r8,pc[2118]
80003662:	91 09       	st.w	r8[0x0],r9
80003664:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
					}
				if ((RxBytesWaiting -= 2) <= 0)
80003668:	fe f9 08 44 	ld.w	r9,pc[2116]
8000366c:	72 08       	ld.w	r8,r9[0x0]
8000366e:	20 28       	sub	r8,2
80003670:	93 08       	st.w	r9[0x0],r8
80003672:	c0 71       	brne	80003680 <phy_rx_func+0x640>
				{
					RxMediaState = WAITINGABAB;
80003674:	30 09       	mov	r9,0
80003676:	fe f8 08 2e 	ld.w	r8,pc[2094]
8000367a:	91 09       	st.w	r8[0x0],r9
8000367c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003680:	fe f8 08 74 	ld.w	r8,pc[2164]
80003684:	70 0a       	ld.w	r10,r8[0x0]
80003686:	fe f9 08 12 	ld.w	r9,pc[2066]
8000368a:	72 09       	ld.w	r9,r9[0x0]
8000368c:	8e 5b       	ld.sh	r11,r7[0xa]
8000368e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003692:	70 09       	ld.w	r9,r8[0x0]
80003694:	2f f9       	sub	r9,-1
80003696:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003698:	e0 49 00 ff 	cp.w	r9,255
8000369c:	e0 88 00 16 	brls	800036c8 <phy_rx_func+0x688>
						{
							RxMedia_IsFillingNext16 = 0;
800036a0:	30 09       	mov	r9,0
800036a2:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800036a4:	fe f6 07 f4 	ld.w	r6,pc[2036]
800036a8:	6c 0c       	ld.w	r12,r6[0x0]
800036aa:	f0 1f 02 08 	mcall	80003ec8 <phy_rx_func+0xe88>
								payload_ptr = get_payload_idle_isr();
800036ae:	fe f8 07 e6 	ld.w	r8,pc[2022]
800036b2:	70 0c       	ld.w	r12,r8[0x0]
800036b4:	f0 1f 01 f2 	mcall	80003e7c <phy_rx_func+0xe3c>
800036b8:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
800036ba:	c0 71       	brne	800036c8 <phy_rx_func+0x688>
								{
									RxMediaState = WAITINGABAB;
800036bc:	30 09       	mov	r9,0
800036be:	fe f8 07 e6 	ld.w	r8,pc[2022]
800036c2:	91 09       	st.w	r8[0x0],r9
800036c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
						}
				if ((RxBytesWaiting -= 2) <= 0){
800036c8:	fe f9 07 e4 	ld.w	r9,pc[2020]
800036cc:	72 08       	ld.w	r8,r9[0x0]
800036ce:	20 28       	sub	r8,2
800036d0:	93 08       	st.w	r9[0x0],r8
800036d2:	c0 71       	brne	800036e0 <phy_rx_func+0x6a0>
					RxMediaState = WAITINGABAB;
800036d4:	30 09       	mov	r9,0
800036d6:	fe f8 07 ce 	ld.w	r8,pc[1998]
800036da:	91 09       	st.w	r8[0x0],r9
800036dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
800036e0:	fe f8 08 14 	ld.w	r8,pc[2068]
800036e4:	70 0a       	ld.w	r10,r8[0x0]
800036e6:	fe f9 07 b2 	ld.w	r9,pc[1970]
800036ea:	72 09       	ld.w	r9,r9[0x0]
800036ec:	8e 6b       	ld.sh	r11,r7[0xc]
800036ee:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800036f2:	70 09       	ld.w	r9,r8[0x0]
800036f4:	2f f9       	sub	r9,-1
800036f6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800036f8:	e0 49 00 ff 	cp.w	r9,255
800036fc:	e0 88 00 16 	brls	80003728 <phy_rx_func+0x6e8>
						{
							RxMedia_IsFillingNext16 = 0;
80003700:	30 09       	mov	r9,0
80003702:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80003704:	fe f6 07 94 	ld.w	r6,pc[1940]
80003708:	6c 0c       	ld.w	r12,r6[0x0]
8000370a:	f0 1f 01 f0 	mcall	80003ec8 <phy_rx_func+0xe88>
									payload_ptr = get_payload_idle_isr();
8000370e:	fe f8 07 86 	ld.w	r8,pc[1926]
80003712:	70 0c       	ld.w	r12,r8[0x0]
80003714:	f0 1f 01 da 	mcall	80003e7c <phy_rx_func+0xe3c>
80003718:	8d 0c       	st.w	r6[0x0],r12
									if(NULL == payload_ptr)
8000371a:	c0 71       	brne	80003728 <phy_rx_func+0x6e8>
									{
										RxMediaState = WAITINGABAB;
8000371c:	30 09       	mov	r9,0
8000371e:	fe f8 07 86 	ld.w	r8,pc[1926]
80003722:	91 09       	st.w	r8[0x0],r9
80003724:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80003728:	fe f9 07 84 	ld.w	r9,pc[1924]
8000372c:	72 08       	ld.w	r8,r9[0x0]
8000372e:	20 28       	sub	r8,2
80003730:	93 08       	st.w	r9[0x0],r8
80003732:	c0 71       	brne	80003740 <phy_rx_func+0x700>
					RxMediaState = WAITINGABAB;
80003734:	30 09       	mov	r9,0
80003736:	fe f8 07 6e 	ld.w	r8,pc[1902]
8000373a:	91 09       	st.w	r8[0x0],r9
8000373c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003740:	fe f8 07 b4 	ld.w	r8,pc[1972]
80003744:	70 0a       	ld.w	r10,r8[0x0]
80003746:	fe f9 07 52 	ld.w	r9,pc[1874]
8000374a:	72 09       	ld.w	r9,r9[0x0]
8000374c:	8e 7b       	ld.sh	r11,r7[0xe]
8000374e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003752:	70 09       	ld.w	r9,r8[0x0]
80003754:	2f f9       	sub	r9,-1
80003756:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003758:	e0 49 00 ff 	cp.w	r9,255
8000375c:	e0 88 00 16 	brls	80003788 <phy_rx_func+0x748>
						{
							RxMedia_IsFillingNext16 = 0;
80003760:	30 09       	mov	r9,0
80003762:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80003764:	fe f7 07 34 	ld.w	r7,pc[1844]
80003768:	6e 0c       	ld.w	r12,r7[0x0]
8000376a:	f0 1f 01 d8 	mcall	80003ec8 <phy_rx_func+0xe88>
							payload_ptr = get_payload_idle_isr();
8000376e:	fe f8 07 26 	ld.w	r8,pc[1830]
80003772:	70 0c       	ld.w	r12,r8[0x0]
80003774:	f0 1f 01 c2 	mcall	80003e7c <phy_rx_func+0xe3c>
80003778:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
8000377a:	c0 71       	brne	80003788 <phy_rx_func+0x748>
							{
								RxMediaState = WAITINGABAB;
8000377c:	30 09       	mov	r9,0
8000377e:	fe f8 07 26 	ld.w	r8,pc[1830]
80003782:	91 09       	st.w	r8[0x0],r9
80003784:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80003788:	fe f9 07 24 	ld.w	r9,pc[1828]
8000378c:	72 08       	ld.w	r8,r9[0x0]
8000378e:	20 28       	sub	r8,2
80003790:	93 08       	st.w	r9[0x0],r8
80003792:	e0 81 03 67 	brne	80003e60 <phy_rx_func+0xe20>
					RxMediaState = WAITINGABAB;
80003796:	30 09       	mov	r9,0
80003798:	fe f8 07 0c 	ld.w	r8,pc[1804]
8000379c:	91 09       	st.w	r8[0x0],r9
8000379e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800037a2:	fe f8 07 16 	ld.w	r8,pc[1814]
800037a6:	11 89       	ld.ub	r9,r8[0x0]
800037a8:	31 28       	mov	r8,18
800037aa:	f0 09 18 00 	cp.b	r9,r8
800037ae:	e0 81 01 4c 	brne	80003a46 <phy_rx_func+0xa06>
					{
						Item_ID = payload_rx_channel->byte[1];
800037b2:	ef 39 00 09 	ld.ub	r9,r7[9]
800037b6:	fe f8 07 02 	ld.w	r8,pc[1794]
800037ba:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
800037bc:	11 89       	ld.ub	r9,r8[0x0]
800037be:	3f 28       	mov	r8,-14
800037c0:	f0 09 18 00 	cp.b	r9,r8
800037c4:	e0 81 01 3b 	brne	80003a3a <phy_rx_func+0x9fa>
						{
							AMBE_tx_flag = 1;
800037c8:	30 19       	mov	r9,1
800037ca:	fe f8 07 1e 	ld.w	r8,pc[1822]
800037ce:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
800037d0:	6e 29       	ld.w	r9,r7[0x8]
800037d2:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
800037d6:	fe f8 06 d6 	ld.w	r8,pc[1750]
800037da:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
800037dc:	8e 59       	ld.sh	r9,r7[0xa]
800037de:	fe f8 07 22 	ld.w	r8,pc[1826]
800037e2:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
800037e4:	8e 69       	ld.sh	r9,r7[0xc]
800037e6:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
800037e8:	8e 79       	ld.sh	r9,r7[0xe]
800037ea:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
800037ec:	fe f8 06 d4 	ld.w	r8,pc[1748]
800037f0:	fe f9 06 ac 	ld.w	r9,pc[1708]
800037f4:	72 0a       	ld.w	r10,r9[0x0]
800037f6:	70 09       	ld.w	r9,r8[0x0]
800037f8:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800037fc:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003800:	70 09       	ld.w	r9,r8[0x0]
80003802:	2f f9       	sub	r9,-1
80003804:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003806:	e0 49 01 ff 	cp.w	r9,511
8000380a:	e0 88 00 16 	brls	80003836 <phy_rx_func+0x7f6>
							{
								RxAMBE_IsFillingNext8 = 0;
8000380e:	30 09       	mov	r9,0
80003810:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003812:	fe f6 06 8a 	ld.w	r6,pc[1674]
80003816:	6c 0c       	ld.w	r12,r6[0x0]
80003818:	f0 1f 01 ac 	mcall	80003ec8 <phy_rx_func+0xe88>
								AMBE_payload_ptr = get_payload_idle_isr();
8000381c:	fe f8 06 78 	ld.w	r8,pc[1656]
80003820:	70 0c       	ld.w	r12,r8[0x0]
80003822:	f0 1f 01 97 	mcall	80003e7c <phy_rx_func+0xe3c>
80003826:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003828:	c0 71       	brne	80003836 <phy_rx_func+0x7f6>
								{
									RxMediaState = WAITINGABAB;
8000382a:	30 09       	mov	r9,0
8000382c:	fe f8 06 78 	ld.w	r8,pc[1656]
80003830:	91 09       	st.w	r8[0x0],r9
80003832:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003836:	fe f9 06 76 	ld.w	r9,pc[1654]
8000383a:	72 08       	ld.w	r8,r9[0x0]
8000383c:	20 18       	sub	r8,1
8000383e:	93 08       	st.w	r9[0x0],r8
80003840:	c0 71       	brne	8000384e <phy_rx_func+0x80e>
								RxMediaState = WAITINGABAB;
80003842:	30 09       	mov	r9,0
80003844:	fe f8 06 60 	ld.w	r8,pc[1632]
80003848:	91 09       	st.w	r8[0x0],r9
8000384a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
8000384e:	fe f8 06 72 	ld.w	r8,pc[1650]
80003852:	fe f9 06 4a 	ld.w	r9,pc[1610]
80003856:	72 0a       	ld.w	r10,r9[0x0]
80003858:	70 09       	ld.w	r9,r8[0x0]
8000385a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000385e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003862:	70 09       	ld.w	r9,r8[0x0]
80003864:	2f f9       	sub	r9,-1
80003866:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003868:	e0 49 01 ff 	cp.w	r9,511
8000386c:	e0 88 00 16 	brls	80003898 <phy_rx_func+0x858>
							{
								RxAMBE_IsFillingNext8 = 0;
80003870:	30 09       	mov	r9,0
80003872:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003874:	fe f6 06 28 	ld.w	r6,pc[1576]
80003878:	6c 0c       	ld.w	r12,r6[0x0]
8000387a:	f0 1f 01 94 	mcall	80003ec8 <phy_rx_func+0xe88>
								AMBE_payload_ptr = get_payload_idle_isr();
8000387e:	fe f8 06 16 	ld.w	r8,pc[1558]
80003882:	70 0c       	ld.w	r12,r8[0x0]
80003884:	f0 1f 01 7e 	mcall	80003e7c <phy_rx_func+0xe3c>
80003888:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000388a:	c0 71       	brne	80003898 <phy_rx_func+0x858>
								{
									RxMediaState = WAITINGABAB;
8000388c:	30 09       	mov	r9,0
8000388e:	fe f8 06 16 	ld.w	r8,pc[1558]
80003892:	91 09       	st.w	r8[0x0],r9
80003894:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003898:	fe f9 06 14 	ld.w	r9,pc[1556]
8000389c:	72 08       	ld.w	r8,r9[0x0]
8000389e:	20 18       	sub	r8,1
800038a0:	93 08       	st.w	r9[0x0],r8
800038a2:	c0 71       	brne	800038b0 <phy_rx_func+0x870>
								RxMediaState = WAITINGABAB;
800038a4:	30 09       	mov	r9,0
800038a6:	fe f8 05 fe 	ld.w	r8,pc[1534]
800038aa:	91 09       	st.w	r8[0x0],r9
800038ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800038b0:	fe f8 06 10 	ld.w	r8,pc[1552]
800038b4:	fe f9 05 e8 	ld.w	r9,pc[1512]
800038b8:	72 0a       	ld.w	r10,r9[0x0]
800038ba:	70 09       	ld.w	r9,r8[0x0]
800038bc:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800038c0:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800038c4:	70 09       	ld.w	r9,r8[0x0]
800038c6:	2f f9       	sub	r9,-1
800038c8:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038ca:	e0 49 01 ff 	cp.w	r9,511
800038ce:	e0 88 00 16 	brls	800038fa <phy_rx_func+0x8ba>
							{
								RxAMBE_IsFillingNext8 = 0;
800038d2:	30 09       	mov	r9,0
800038d4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800038d6:	fe f6 05 c6 	ld.w	r6,pc[1478]
800038da:	6c 0c       	ld.w	r12,r6[0x0]
800038dc:	f0 1f 01 7b 	mcall	80003ec8 <phy_rx_func+0xe88>
								AMBE_payload_ptr = get_payload_idle_isr();
800038e0:	fe f8 05 b4 	ld.w	r8,pc[1460]
800038e4:	70 0c       	ld.w	r12,r8[0x0]
800038e6:	f0 1f 01 66 	mcall	80003e7c <phy_rx_func+0xe3c>
800038ea:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800038ec:	c0 71       	brne	800038fa <phy_rx_func+0x8ba>
								{
									RxMediaState = WAITINGABAB;
800038ee:	30 09       	mov	r9,0
800038f0:	fe f8 05 b4 	ld.w	r8,pc[1460]
800038f4:	91 09       	st.w	r8[0x0],r9
800038f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800038fa:	fe f9 05 b2 	ld.w	r9,pc[1458]
800038fe:	72 08       	ld.w	r8,r9[0x0]
80003900:	20 18       	sub	r8,1
80003902:	93 08       	st.w	r9[0x0],r8
80003904:	c0 71       	brne	80003912 <phy_rx_func+0x8d2>
								RxMediaState = WAITINGABAB;
80003906:	30 09       	mov	r9,0
80003908:	fe f8 05 9c 	ld.w	r8,pc[1436]
8000390c:	91 09       	st.w	r8[0x0],r9
8000390e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003912:	fe f8 05 ae 	ld.w	r8,pc[1454]
80003916:	fe f9 05 86 	ld.w	r9,pc[1414]
8000391a:	72 0a       	ld.w	r10,r9[0x0]
8000391c:	70 09       	ld.w	r9,r8[0x0]
8000391e:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003922:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003926:	70 09       	ld.w	r9,r8[0x0]
80003928:	2f f9       	sub	r9,-1
8000392a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000392c:	e0 49 01 ff 	cp.w	r9,511
80003930:	e0 88 00 16 	brls	8000395c <phy_rx_func+0x91c>
							{
								RxAMBE_IsFillingNext8 = 0;
80003934:	30 09       	mov	r9,0
80003936:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003938:	fe f6 05 64 	ld.w	r6,pc[1380]
8000393c:	6c 0c       	ld.w	r12,r6[0x0]
8000393e:	f0 1f 01 63 	mcall	80003ec8 <phy_rx_func+0xe88>
								AMBE_payload_ptr = get_payload_idle_isr();
80003942:	fe f8 05 52 	ld.w	r8,pc[1362]
80003946:	70 0c       	ld.w	r12,r8[0x0]
80003948:	f0 1f 01 4d 	mcall	80003e7c <phy_rx_func+0xe3c>
8000394c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000394e:	c0 71       	brne	8000395c <phy_rx_func+0x91c>
								{
									RxMediaState = WAITINGABAB;
80003950:	30 09       	mov	r9,0
80003952:	fe f8 05 52 	ld.w	r8,pc[1362]
80003956:	91 09       	st.w	r8[0x0],r9
80003958:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000395c:	fe f9 05 50 	ld.w	r9,pc[1360]
80003960:	72 08       	ld.w	r8,r9[0x0]
80003962:	20 18       	sub	r8,1
80003964:	93 08       	st.w	r9[0x0],r8
80003966:	c0 71       	brne	80003974 <phy_rx_func+0x934>
								RxMediaState = WAITINGABAB;
80003968:	30 09       	mov	r9,0
8000396a:	fe f8 05 3a 	ld.w	r8,pc[1338]
8000396e:	91 09       	st.w	r8[0x0],r9
80003970:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003974:	fe f8 05 4c 	ld.w	r8,pc[1356]
80003978:	fe f9 05 24 	ld.w	r9,pc[1316]
8000397c:	72 0a       	ld.w	r10,r9[0x0]
8000397e:	70 09       	ld.w	r9,r8[0x0]
80003980:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003984:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003988:	70 09       	ld.w	r9,r8[0x0]
8000398a:	2f f9       	sub	r9,-1
8000398c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000398e:	e0 49 01 ff 	cp.w	r9,511
80003992:	e0 88 00 16 	brls	800039be <phy_rx_func+0x97e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003996:	30 09       	mov	r9,0
80003998:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000399a:	fe f6 05 02 	ld.w	r6,pc[1282]
8000399e:	6c 0c       	ld.w	r12,r6[0x0]
800039a0:	f0 1f 01 4a 	mcall	80003ec8 <phy_rx_func+0xe88>
								AMBE_payload_ptr = get_payload_idle_isr();
800039a4:	fe f8 04 f0 	ld.w	r8,pc[1264]
800039a8:	70 0c       	ld.w	r12,r8[0x0]
800039aa:	f0 1f 01 35 	mcall	80003e7c <phy_rx_func+0xe3c>
800039ae:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800039b0:	c0 71       	brne	800039be <phy_rx_func+0x97e>
								{
									RxMediaState = WAITINGABAB;
800039b2:	30 09       	mov	r9,0
800039b4:	fe f8 04 f0 	ld.w	r8,pc[1264]
800039b8:	91 09       	st.w	r8[0x0],r9
800039ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800039be:	fe f9 04 ee 	ld.w	r9,pc[1262]
800039c2:	72 08       	ld.w	r8,r9[0x0]
800039c4:	20 18       	sub	r8,1
800039c6:	93 08       	st.w	r9[0x0],r8
800039c8:	c0 71       	brne	800039d6 <phy_rx_func+0x996>
								RxMediaState = WAITINGABAB;
800039ca:	30 09       	mov	r9,0
800039cc:	fe f8 04 d8 	ld.w	r8,pc[1240]
800039d0:	91 09       	st.w	r8[0x0],r9
800039d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
800039d6:	fe f8 04 ea 	ld.w	r8,pc[1258]
800039da:	fe f9 04 c2 	ld.w	r9,pc[1218]
800039de:	72 0a       	ld.w	r10,r9[0x0]
800039e0:	70 09       	ld.w	r9,r8[0x0]
800039e2:	ef 3b 00 0f 	ld.ub	r11,r7[15]
800039e6:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800039ea:	70 09       	ld.w	r9,r8[0x0]
800039ec:	2f f9       	sub	r9,-1
800039ee:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039f0:	e0 49 01 ff 	cp.w	r9,511
800039f4:	e0 88 00 16 	brls	80003a20 <phy_rx_func+0x9e0>
							{
								RxAMBE_IsFillingNext8 = 0;
800039f8:	30 09       	mov	r9,0
800039fa:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800039fc:	fe f7 04 a0 	ld.w	r7,pc[1184]
80003a00:	6e 0c       	ld.w	r12,r7[0x0]
80003a02:	f0 1f 01 32 	mcall	80003ec8 <phy_rx_func+0xe88>
								AMBE_payload_ptr = get_payload_idle_isr();
80003a06:	fe f8 04 8e 	ld.w	r8,pc[1166]
80003a0a:	70 0c       	ld.w	r12,r8[0x0]
80003a0c:	f0 1f 01 1c 	mcall	80003e7c <phy_rx_func+0xe3c>
80003a10:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003a12:	c0 71       	brne	80003a20 <phy_rx_func+0x9e0>
								{
									RxMediaState = WAITINGABAB;
80003a14:	30 09       	mov	r9,0
80003a16:	fe f8 04 8e 	ld.w	r8,pc[1166]
80003a1a:	91 09       	st.w	r8[0x0],r9
80003a1c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003a20:	fe f9 04 8c 	ld.w	r9,pc[1164]
80003a24:	72 08       	ld.w	r8,r9[0x0]
80003a26:	20 18       	sub	r8,1
80003a28:	93 08       	st.w	r9[0x0],r8
80003a2a:	e0 81 02 1b 	brne	80003e60 <phy_rx_func+0xe20>
								RxMediaState = WAITINGABAB;
80003a2e:	30 09       	mov	r9,0
80003a30:	fe f8 04 74 	ld.w	r8,pc[1140]
80003a34:	91 09       	st.w	r8[0x0],r9
80003a36:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003a3a:	30 09       	mov	r9,0
80003a3c:	fe f8 04 68 	ld.w	r8,pc[1128]
80003a40:	91 09       	st.w	r8[0x0],r9
80003a42:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003a46:	fe f8 04 72 	ld.w	r8,pc[1138]
80003a4a:	11 89       	ld.ub	r9,r8[0x0]
80003a4c:	3f 28       	mov	r8,-14
80003a4e:	f0 09 18 00 	cp.b	r9,r8
80003a52:	c4 31       	brne	80003ad8 <phy_rx_func+0xa98>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003a54:	8e 49       	ld.sh	r9,r7[0x8]
80003a56:	fe f8 04 aa 	ld.w	r8,pc[1194]
80003a5a:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003a5c:	fe f8 04 64 	ld.w	r8,pc[1124]
80003a60:	fe f9 04 3c 	ld.w	r9,pc[1084]
80003a64:	72 0a       	ld.w	r10,r9[0x0]
80003a66:	70 09       	ld.w	r9,r8[0x0]
80003a68:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003a6c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a70:	70 09       	ld.w	r9,r8[0x0]
80003a72:	2f f9       	sub	r9,-1
80003a74:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a76:	e0 49 01 ff 	cp.w	r9,511
80003a7a:	e0 88 00 16 	brls	80003aa6 <phy_rx_func+0xa66>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a7e:	30 09       	mov	r9,0
80003a80:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a82:	fe f7 04 1a 	ld.w	r7,pc[1050]
80003a86:	6e 0c       	ld.w	r12,r7[0x0]
80003a88:	f0 1f 01 10 	mcall	80003ec8 <phy_rx_func+0xe88>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a8c:	fe f8 04 08 	ld.w	r8,pc[1032]
80003a90:	70 0c       	ld.w	r12,r8[0x0]
80003a92:	f0 1f 00 fb 	mcall	80003e7c <phy_rx_func+0xe3c>
80003a96:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a98:	c0 71       	brne	80003aa6 <phy_rx_func+0xa66>
							{
								RxMediaState = WAITINGABAB;
80003a9a:	30 09       	mov	r9,0
80003a9c:	fe f8 04 08 	ld.w	r8,pc[1032]
80003aa0:	91 09       	st.w	r8[0x0],r9
80003aa2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003aa6:	fe f9 04 06 	ld.w	r9,pc[1030]
80003aaa:	72 08       	ld.w	r8,r9[0x0]
80003aac:	20 18       	sub	r8,1
80003aae:	93 08       	st.w	r9[0x0],r8
80003ab0:	c0 71       	brne	80003abe <phy_rx_func+0xa7e>
							RxMediaState = WAITINGABAB;
80003ab2:	30 09       	mov	r9,0
80003ab4:	fe f8 03 f0 	ld.w	r8,pc[1008]
80003ab8:	91 09       	st.w	r8[0x0],r9
80003aba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003abe:	20 18       	sub	r8,1
80003ac0:	fe f9 03 ec 	ld.w	r9,pc[1004]
80003ac4:	93 08       	st.w	r9[0x0],r8
80003ac6:	58 08       	cp.w	r8,0
80003ac8:	e0 81 01 cc 	brne	80003e60 <phy_rx_func+0xe20>
							RxMediaState = WAITINGABAB;
80003acc:	30 09       	mov	r9,0
80003ace:	fe f8 03 d6 	ld.w	r8,pc[982]
80003ad2:	91 09       	st.w	r8[0x0],r9
80003ad4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit0~bit63
80003ad8:	fe f8 03 e0 	ld.w	r8,pc[992]
80003adc:	11 89       	ld.ub	r9,r8[0x0]
80003ade:	3f 38       	mov	r8,-13
80003ae0:	f0 09 18 00 	cp.b	r9,r8
80003ae4:	e0 81 01 5a 	brne	80003d98 <phy_rx_func+0xd58>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[0] = payload_rx_channel->word[0];
80003ae8:	8e 49       	ld.sh	r9,r7[0x8]
80003aea:	fe f8 04 16 	ld.w	r8,pc[1046]
80003aee:	b0 09       	st.h	r8[0x0],r9
						AMBEBurst_rawdata[1] = payload_rx_channel->word[1];
80003af0:	8e 59       	ld.sh	r9,r7[0xa]
80003af2:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[2];
80003af4:	8e 69       	ld.sh	r9,r7[0xc]
80003af6:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[3];
80003af8:	8e 79       	ld.sh	r9,r7[0xe]
80003afa:	b0 39       	st.h	r8[0x6],r9
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//1
80003afc:	fe f8 03 c4 	ld.w	r8,pc[964]
80003b00:	fe f9 03 9c 	ld.w	r9,pc[924]
80003b04:	72 0a       	ld.w	r10,r9[0x0]
80003b06:	70 09       	ld.w	r9,r8[0x0]
80003b08:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003b0c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003b10:	70 09       	ld.w	r9,r8[0x0]
80003b12:	2f f9       	sub	r9,-1
80003b14:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b16:	e0 49 01 ff 	cp.w	r9,511
80003b1a:	e0 88 00 16 	brls	80003b46 <phy_rx_func+0xb06>
						{
							RxAMBE_IsFillingNext8 = 0;
80003b1e:	30 09       	mov	r9,0
80003b20:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003b22:	fe f6 03 7a 	ld.w	r6,pc[890]
80003b26:	6c 0c       	ld.w	r12,r6[0x0]
80003b28:	f0 1f 00 e8 	mcall	80003ec8 <phy_rx_func+0xe88>
							AMBE_payload_ptr = get_payload_idle_isr();
80003b2c:	fe f8 03 68 	ld.w	r8,pc[872]
80003b30:	70 0c       	ld.w	r12,r8[0x0]
80003b32:	f0 1f 00 d3 	mcall	80003e7c <phy_rx_func+0xe3c>
80003b36:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003b38:	c0 71       	brne	80003b46 <phy_rx_func+0xb06>
							{
								RxMediaState = WAITINGABAB;
80003b3a:	30 09       	mov	r9,0
80003b3c:	fe f8 03 68 	ld.w	r8,pc[872]
80003b40:	91 09       	st.w	r8[0x0],r9
80003b42:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003b46:	fe f9 03 66 	ld.w	r9,pc[870]
80003b4a:	72 08       	ld.w	r8,r9[0x0]
80003b4c:	20 18       	sub	r8,1
80003b4e:	93 08       	st.w	r9[0x0],r8
80003b50:	c0 71       	brne	80003b5e <phy_rx_func+0xb1e>
							RxMediaState = WAITINGABAB;
80003b52:	30 09       	mov	r9,0
80003b54:	fe f8 03 50 	ld.w	r8,pc[848]
80003b58:	91 09       	st.w	r8[0x0],r9
80003b5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//2
80003b5e:	fe f8 03 62 	ld.w	r8,pc[866]
80003b62:	fe f9 03 3a 	ld.w	r9,pc[826]
80003b66:	72 0a       	ld.w	r10,r9[0x0]
80003b68:	70 09       	ld.w	r9,r8[0x0]
80003b6a:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003b6e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003b72:	70 09       	ld.w	r9,r8[0x0]
80003b74:	2f f9       	sub	r9,-1
80003b76:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b78:	e0 49 01 ff 	cp.w	r9,511
80003b7c:	e0 88 00 16 	brls	80003ba8 <phy_rx_func+0xb68>
						{
							RxAMBE_IsFillingNext8 = 0;
80003b80:	30 09       	mov	r9,0
80003b82:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003b84:	fe f6 03 18 	ld.w	r6,pc[792]
80003b88:	6c 0c       	ld.w	r12,r6[0x0]
80003b8a:	f0 1f 00 d0 	mcall	80003ec8 <phy_rx_func+0xe88>
							AMBE_payload_ptr = get_payload_idle_isr();
80003b8e:	fe f8 03 06 	ld.w	r8,pc[774]
80003b92:	70 0c       	ld.w	r12,r8[0x0]
80003b94:	f0 1f 00 ba 	mcall	80003e7c <phy_rx_func+0xe3c>
80003b98:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003b9a:	c0 71       	brne	80003ba8 <phy_rx_func+0xb68>
							{
								RxMediaState = WAITINGABAB;
80003b9c:	30 09       	mov	r9,0
80003b9e:	fe f8 03 06 	ld.w	r8,pc[774]
80003ba2:	91 09       	st.w	r8[0x0],r9
80003ba4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003ba8:	fe f9 03 04 	ld.w	r9,pc[772]
80003bac:	72 08       	ld.w	r8,r9[0x0]
80003bae:	20 18       	sub	r8,1
80003bb0:	93 08       	st.w	r9[0x0],r8
80003bb2:	c0 71       	brne	80003bc0 <phy_rx_func+0xb80>
							RxMediaState = WAITINGABAB;
80003bb4:	30 09       	mov	r9,0
80003bb6:	fe f8 02 ee 	ld.w	r8,pc[750]
80003bba:	91 09       	st.w	r8[0x0],r9
80003bbc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//3
80003bc0:	fe f8 03 00 	ld.w	r8,pc[768]
80003bc4:	fe f9 02 d8 	ld.w	r9,pc[728]
80003bc8:	72 0a       	ld.w	r10,r9[0x0]
80003bca:	70 09       	ld.w	r9,r8[0x0]
80003bcc:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003bd0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003bd4:	70 09       	ld.w	r9,r8[0x0]
80003bd6:	2f f9       	sub	r9,-1
80003bd8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003bda:	e0 49 01 ff 	cp.w	r9,511
80003bde:	e0 88 00 16 	brls	80003c0a <phy_rx_func+0xbca>
						{
							RxAMBE_IsFillingNext8 = 0;
80003be2:	30 09       	mov	r9,0
80003be4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003be6:	fe f6 02 b6 	ld.w	r6,pc[694]
80003bea:	6c 0c       	ld.w	r12,r6[0x0]
80003bec:	f0 1f 00 b7 	mcall	80003ec8 <phy_rx_func+0xe88>
							AMBE_payload_ptr = get_payload_idle_isr();
80003bf0:	fe f8 02 a4 	ld.w	r8,pc[676]
80003bf4:	70 0c       	ld.w	r12,r8[0x0]
80003bf6:	f0 1f 00 a2 	mcall	80003e7c <phy_rx_func+0xe3c>
80003bfa:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003bfc:	c0 71       	brne	80003c0a <phy_rx_func+0xbca>
							{
								RxMediaState = WAITINGABAB;
80003bfe:	30 09       	mov	r9,0
80003c00:	fe f8 02 a4 	ld.w	r8,pc[676]
80003c04:	91 09       	st.w	r8[0x0],r9
80003c06:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003c0a:	fe f9 02 a2 	ld.w	r9,pc[674]
80003c0e:	72 08       	ld.w	r8,r9[0x0]
80003c10:	20 18       	sub	r8,1
80003c12:	93 08       	st.w	r9[0x0],r8
80003c14:	c0 71       	brne	80003c22 <phy_rx_func+0xbe2>
							RxMediaState = WAITINGABAB;
80003c16:	30 09       	mov	r9,0
80003c18:	fe f8 02 8c 	ld.w	r8,pc[652]
80003c1c:	91 09       	st.w	r8[0x0],r9
80003c1e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//4
80003c22:	fe f8 02 9e 	ld.w	r8,pc[670]
80003c26:	fe f9 02 76 	ld.w	r9,pc[630]
80003c2a:	72 0a       	ld.w	r10,r9[0x0]
80003c2c:	70 09       	ld.w	r9,r8[0x0]
80003c2e:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003c32:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003c36:	70 09       	ld.w	r9,r8[0x0]
80003c38:	2f f9       	sub	r9,-1
80003c3a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c3c:	e0 49 01 ff 	cp.w	r9,511
80003c40:	e0 88 00 16 	brls	80003c6c <phy_rx_func+0xc2c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003c44:	30 09       	mov	r9,0
80003c46:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003c48:	fe f6 02 54 	ld.w	r6,pc[596]
80003c4c:	6c 0c       	ld.w	r12,r6[0x0]
80003c4e:	f0 1f 00 9f 	mcall	80003ec8 <phy_rx_func+0xe88>
							AMBE_payload_ptr = get_payload_idle_isr();
80003c52:	fe f8 02 42 	ld.w	r8,pc[578]
80003c56:	70 0c       	ld.w	r12,r8[0x0]
80003c58:	f0 1f 00 89 	mcall	80003e7c <phy_rx_func+0xe3c>
80003c5c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003c5e:	c0 71       	brne	80003c6c <phy_rx_func+0xc2c>
							{
								RxMediaState = WAITINGABAB;
80003c60:	30 09       	mov	r9,0
80003c62:	fe f8 02 42 	ld.w	r8,pc[578]
80003c66:	91 09       	st.w	r8[0x0],r9
80003c68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003c6c:	fe f9 02 40 	ld.w	r9,pc[576]
80003c70:	72 08       	ld.w	r8,r9[0x0]
80003c72:	20 18       	sub	r8,1
80003c74:	93 08       	st.w	r9[0x0],r8
80003c76:	c0 71       	brne	80003c84 <phy_rx_func+0xc44>
							RxMediaState = WAITINGABAB;
80003c78:	30 09       	mov	r9,0
80003c7a:	fe f8 02 2a 	ld.w	r8,pc[554]
80003c7e:	91 09       	st.w	r8[0x0],r9
80003c80:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//5
80003c84:	fe f8 02 3c 	ld.w	r8,pc[572]
80003c88:	fe f9 02 14 	ld.w	r9,pc[532]
80003c8c:	72 0a       	ld.w	r10,r9[0x0]
80003c8e:	70 09       	ld.w	r9,r8[0x0]
80003c90:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003c94:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003c98:	70 09       	ld.w	r9,r8[0x0]
80003c9a:	2f f9       	sub	r9,-1
80003c9c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c9e:	e0 49 01 ff 	cp.w	r9,511
80003ca2:	e0 88 00 13 	brls	80003cc8 <phy_rx_func+0xc88>
						{
							RxAMBE_IsFillingNext8 = 0;
80003ca6:	30 09       	mov	r9,0
80003ca8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003caa:	4f d6       	lddpc	r6,80003e9c <phy_rx_func+0xe5c>
80003cac:	6c 0c       	ld.w	r12,r6[0x0]
80003cae:	f0 1f 00 87 	mcall	80003ec8 <phy_rx_func+0xe88>
							AMBE_payload_ptr = get_payload_idle_isr();
80003cb2:	4f 98       	lddpc	r8,80003e94 <phy_rx_func+0xe54>
80003cb4:	70 0c       	ld.w	r12,r8[0x0]
80003cb6:	f0 1f 00 72 	mcall	80003e7c <phy_rx_func+0xe3c>
80003cba:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003cbc:	c0 61       	brne	80003cc8 <phy_rx_func+0xc88>
							{
								RxMediaState = WAITINGABAB;
80003cbe:	30 09       	mov	r9,0
80003cc0:	4f 98       	lddpc	r8,80003ea4 <phy_rx_func+0xe64>
80003cc2:	91 09       	st.w	r8[0x0],r9
80003cc4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003cc8:	4f 99       	lddpc	r9,80003eac <phy_rx_func+0xe6c>
80003cca:	72 08       	ld.w	r8,r9[0x0]
80003ccc:	20 18       	sub	r8,1
80003cce:	93 08       	st.w	r9[0x0],r8
80003cd0:	c0 61       	brne	80003cdc <phy_rx_func+0xc9c>
							RxMediaState = WAITINGABAB;
80003cd2:	30 09       	mov	r9,0
80003cd4:	4f 48       	lddpc	r8,80003ea4 <phy_rx_func+0xe64>
80003cd6:	91 09       	st.w	r8[0x0],r9
80003cd8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//6
80003cdc:	4f 98       	lddpc	r8,80003ec0 <phy_rx_func+0xe80>
80003cde:	4f 09       	lddpc	r9,80003e9c <phy_rx_func+0xe5c>
80003ce0:	72 0a       	ld.w	r10,r9[0x0]
80003ce2:	70 09       	ld.w	r9,r8[0x0]
80003ce4:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003ce8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003cec:	70 09       	ld.w	r9,r8[0x0]
80003cee:	2f f9       	sub	r9,-1
80003cf0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003cf2:	e0 49 01 ff 	cp.w	r9,511
80003cf6:	e0 88 00 13 	brls	80003d1c <phy_rx_func+0xcdc>
						{
							RxAMBE_IsFillingNext8 = 0;
80003cfa:	30 09       	mov	r9,0
80003cfc:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003cfe:	4e 86       	lddpc	r6,80003e9c <phy_rx_func+0xe5c>
80003d00:	6c 0c       	ld.w	r12,r6[0x0]
80003d02:	f0 1f 00 72 	mcall	80003ec8 <phy_rx_func+0xe88>
							AMBE_payload_ptr = get_payload_idle_isr();
80003d06:	4e 48       	lddpc	r8,80003e94 <phy_rx_func+0xe54>
80003d08:	70 0c       	ld.w	r12,r8[0x0]
80003d0a:	f0 1f 00 5d 	mcall	80003e7c <phy_rx_func+0xe3c>
80003d0e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003d10:	c0 61       	brne	80003d1c <phy_rx_func+0xcdc>
							{
								RxMediaState = WAITINGABAB;
80003d12:	30 09       	mov	r9,0
80003d14:	4e 48       	lddpc	r8,80003ea4 <phy_rx_func+0xe64>
80003d16:	91 09       	st.w	r8[0x0],r9
80003d18:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003d1c:	4e 49       	lddpc	r9,80003eac <phy_rx_func+0xe6c>
80003d1e:	72 08       	ld.w	r8,r9[0x0]
80003d20:	20 18       	sub	r8,1
80003d22:	93 08       	st.w	r9[0x0],r8
80003d24:	c0 61       	brne	80003d30 <phy_rx_func+0xcf0>
							RxMediaState = WAITINGABAB;
80003d26:	30 09       	mov	r9,0
80003d28:	4d f8       	lddpc	r8,80003ea4 <phy_rx_func+0xe64>
80003d2a:	91 09       	st.w	r8[0x0],r9
80003d2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//7
80003d30:	4e 48       	lddpc	r8,80003ec0 <phy_rx_func+0xe80>
80003d32:	4d b9       	lddpc	r9,80003e9c <phy_rx_func+0xe5c>
80003d34:	72 0a       	ld.w	r10,r9[0x0]
80003d36:	70 09       	ld.w	r9,r8[0x0]
80003d38:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003d3c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003d40:	70 09       	ld.w	r9,r8[0x0]
80003d42:	2f f9       	sub	r9,-1
80003d44:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d46:	e0 49 01 ff 	cp.w	r9,511
80003d4a:	e0 88 00 13 	brls	80003d70 <phy_rx_func+0xd30>
						{
							RxAMBE_IsFillingNext8 = 0;
80003d4e:	30 09       	mov	r9,0
80003d50:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003d52:	4d 37       	lddpc	r7,80003e9c <phy_rx_func+0xe5c>
80003d54:	6e 0c       	ld.w	r12,r7[0x0]
80003d56:	f0 1f 00 5d 	mcall	80003ec8 <phy_rx_func+0xe88>
							AMBE_payload_ptr = get_payload_idle_isr();
80003d5a:	4c f8       	lddpc	r8,80003e94 <phy_rx_func+0xe54>
80003d5c:	70 0c       	ld.w	r12,r8[0x0]
80003d5e:	f0 1f 00 48 	mcall	80003e7c <phy_rx_func+0xe3c>
80003d62:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003d64:	c0 61       	brne	80003d70 <phy_rx_func+0xd30>
							{
								RxMediaState = WAITINGABAB;
80003d66:	30 09       	mov	r9,0
80003d68:	4c f8       	lddpc	r8,80003ea4 <phy_rx_func+0xe64>
80003d6a:	91 09       	st.w	r8[0x0],r9
80003d6c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003d70:	4c f9       	lddpc	r9,80003eac <phy_rx_func+0xe6c>
80003d72:	72 08       	ld.w	r8,r9[0x0]
80003d74:	20 18       	sub	r8,1
80003d76:	93 08       	st.w	r9[0x0],r8
80003d78:	c0 61       	brne	80003d84 <phy_rx_func+0xd44>
							RxMediaState = WAITINGABAB;
80003d7a:	30 09       	mov	r9,0
80003d7c:	4c a8       	lddpc	r8,80003ea4 <phy_rx_func+0xe64>
80003d7e:	91 09       	st.w	r8[0x0],r9
80003d80:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003d84:	20 18       	sub	r8,1
80003d86:	4c a9       	lddpc	r9,80003eac <phy_rx_func+0xe6c>
80003d88:	93 08       	st.w	r9[0x0],r8
80003d8a:	58 08       	cp.w	r8,0
80003d8c:	c6 a1       	brne	80003e60 <phy_rx_func+0xe20>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003d8e:	30 09       	mov	r9,0
80003d90:	4c 58       	lddpc	r8,80003ea4 <phy_rx_func+0xe64>
80003d92:	91 09       	st.w	r8[0x0],r9
80003d94:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003d98:	4c 88       	lddpc	r8,80003eb8 <phy_rx_func+0xe78>
80003d9a:	11 89       	ld.ub	r9,r8[0x0]
80003d9c:	30 48       	mov	r8,4
80003d9e:	f0 09 18 00 	cp.b	r9,r8
80003da2:	c0 70       	breq	80003db0 <phy_rx_func+0xd70>
80003da4:	4c 58       	lddpc	r8,80003eb8 <phy_rx_func+0xe78>
80003da6:	11 89       	ld.ub	r9,r8[0x0]
80003da8:	30 38       	mov	r8,3
80003daa:	f0 09 18 00 	cp.b	r9,r8
80003dae:	c1 01       	brne	80003dce <phy_rx_func+0xd8e>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003db0:	6e 29       	ld.w	r9,r7[0x8]
80003db2:	4c d8       	lddpc	r8,80003ee4 <phy_rx_func+0xea4>
80003db4:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003db6:	6e 39       	ld.w	r9,r7[0xc]
80003db8:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003dba:	4b d9       	lddpc	r9,80003eac <phy_rx_func+0xe6c>
80003dbc:	72 08       	ld.w	r8,r9[0x0]
80003dbe:	20 88       	sub	r8,8
80003dc0:	93 08       	st.w	r9[0x0],r8
80003dc2:	c4 f1       	brne	80003e60 <phy_rx_func+0xe20>
						{
					
							RxBytesWaiting = 0;
80003dc4:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003dc6:	4b 89       	lddpc	r9,80003ea4 <phy_rx_func+0xe64>
80003dc8:	93 08       	st.w	r9[0x0],r8
80003dca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003dce:	30 09       	mov	r9,0
80003dd0:	4b 58       	lddpc	r8,80003ea4 <phy_rx_func+0xe64>
80003dd2:	91 09       	st.w	r8[0x0],r9
80003dd4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003dd8:	4c 18       	lddpc	r8,80003edc <phy_rx_func+0xe9c>
80003dda:	70 09       	ld.w	r9,r8[0x0]
80003ddc:	8e 4b       	ld.sh	r11,r7[0x8]
80003dde:	4c 1a       	lddpc	r10,80003ee0 <phy_rx_func+0xea0>
80003de0:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003de4:	2f f9       	sub	r9,-1
80003de6:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003de8:	4b 58       	lddpc	r8,80003ebc <phy_rx_func+0xe7c>
80003dea:	70 09       	ld.w	r9,r8[0x0]
80003dec:	20 29       	sub	r9,2
80003dee:	91 09       	st.w	r8[0x0],r9
80003df0:	70 08       	ld.w	r8,r8[0x0]
80003df2:	58 08       	cp.w	r8,0
80003df4:	c3 01       	brne	80003e54 <phy_rx_func+0xe14>
				{
					RxData_IsFillingNext16 = 0;
80003df6:	30 09       	mov	r9,0
80003df8:	4b 98       	lddpc	r8,80003edc <phy_rx_func+0xe9c>
80003dfa:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003dfc:	8e 59       	ld.sh	r9,r7[0xa]
80003dfe:	fe 78 82 12 	mov	r8,-32238
80003e02:	f0 09 19 00 	cp.h	r9,r8
80003e06:	c2 21       	brne	80003e4a <phy_rx_func+0xe0a>
				
					if (payload_rx_channel->word[1] == 0x8212 )
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						VF_SN = payload_rx_channel->byte[5];//This parameter is very important to the loop back Radio, as a reference.
80003e08:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003e0c:	4b 08       	lddpc	r8,80003ecc <phy_rx_func+0xe8c>
80003e0e:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003e10:	8e 59       	ld.sh	r9,r7[0xa]
80003e12:	4b 08       	lddpc	r8,80003ed0 <phy_rx_func+0xe90>
80003e14:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003e16:	8e 69       	ld.sh	r9,r7[0xc]
80003e18:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003e1a:	f0 1f 00 2f 	mcall	80003ed4 <phy_rx_func+0xe94>
80003e1e:	4a 38       	lddpc	r8,80003ea8 <phy_rx_func+0xe68>
80003e20:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003e22:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003e26:	3f 38       	mov	r8,-13
80003e28:	f0 09 18 00 	cp.b	r9,r8
80003e2c:	c0 a1       	brne	80003e40 <phy_rx_func+0xe00>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Pre_Voice_Decoder_Data)//0xF3
						{
							Item_ID = Pre_Voice_Decoder_Data;
80003e2e:	10 99       	mov	r9,r8
80003e30:	4a 28       	lddpc	r8,80003eb8 <phy_rx_func+0xe78>
80003e32:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 8
80003e34:	30 09       	mov	r9,0
80003e36:	49 e8       	lddpc	r8,80003eac <phy_rx_func+0xe6c>
80003e38:	91 09       	st.w	r8[0x0],r9
							AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003e3a:	30 19       	mov	r9,1
80003e3c:	4a c8       	lddpc	r8,80003eec <phy_rx_func+0xeac>
80003e3e:	b0 89       	st.b	r8[0x0],r9
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003e40:	30 49       	mov	r9,4
80003e42:	49 98       	lddpc	r8,80003ea4 <phy_rx_func+0xe64>
80003e44:	91 09       	st.w	r8[0x0],r9
80003e46:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003e4a:	30 09       	mov	r9,0
80003e4c:	49 68       	lddpc	r8,80003ea4 <phy_rx_func+0xe64>
80003e4e:	91 09       	st.w	r8[0x0],r9
80003e50:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003e54:	4a cc       	lddpc	r12,80003f04 <phy_rx_func+0xec4>
80003e56:	f0 1f 00 18 	mcall	80003eb4 <phy_rx_func+0xe74>
					RxMediaState = WAITINGABAB;//Jump
80003e5a:	30 09       	mov	r9,0
80003e5c:	49 28       	lddpc	r8,80003ea4 <phy_rx_func+0xe64>
80003e5e:	91 09       	st.w	r8[0x0],r9
80003e60:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003e64:	00 00       	add	r0,r0
80003e66:	0a bc       	st.h	r5++,r12
80003e68:	00 00       	add	r0,r0
80003e6a:	0a b4       	st.h	r5++,r4
80003e6c:	00 00       	add	r0,r0
80003e6e:	0a 8c       	andn	r12,r5
80003e70:	00 00       	add	r0,r0
80003e72:	0a e4       	st.h	--r5,r4
80003e74:	00 00       	add	r0,r0
80003e76:	0a dc       	st.w	--r5,r12
80003e78:	00 00       	add	r0,r0
80003e7a:	0a b8       	st.h	r5++,r8
80003e7c:	80 00       	ld.sh	r0,r0[0x0]
80003e7e:	2a 1c       	sub	r12,-95
80003e80:	00 00       	add	r0,r0
80003e82:	0a 78       	tst	r8,r5
80003e84:	80 00       	ld.sh	r0,r0[0x0]
80003e86:	54 a4       	stdsp	sp[0x128],r4
80003e88:	00 00       	add	r0,r0
80003e8a:	0a 98       	mov	r8,r5
80003e8c:	80 00       	ld.sh	r0,r0[0x0]
80003e8e:	29 68       	sub	r8,-106
80003e90:	00 00       	add	r0,r0
80003e92:	0a 9b       	mov	r11,r5
80003e94:	00 00       	add	r0,r0
80003e96:	0a 70       	tst	r0,r5
80003e98:	00 00       	add	r0,r0
80003e9a:	0a c4       	st.b	r5++,r4
80003e9c:	00 00       	add	r0,r0
80003e9e:	0a a4       	st.w	r5++,r4
80003ea0:	00 00       	add	r0,r0
80003ea2:	04 f4       	st.b	--r2,r4
80003ea4:	00 00       	add	r0,r0
80003ea6:	0a b0       	st.h	r5++,r0
80003ea8:	00 00       	add	r0,r0
80003eaa:	0a 6c       	and	r12,r5
80003eac:	00 00       	add	r0,r0
80003eae:	0a ac       	st.w	r5++,r12
80003eb0:	80 00       	ld.sh	r0,r0[0x0]
80003eb2:	d1 40       	acall	0x14
80003eb4:	80 00       	ld.sh	r0,r0[0x0]
80003eb6:	65 9c       	ld.w	r12,r2[0x64]
80003eb8:	00 00       	add	r0,r0
80003eba:	0a 9a       	mov	r10,r5
80003ebc:	00 00       	add	r0,r0
80003ebe:	0a cc       	st.b	r5++,r12
80003ec0:	00 00       	add	r0,r0
80003ec2:	0a d8       	st.w	--r5,r8
80003ec4:	80 00       	ld.sh	r0,r0[0x0]
80003ec6:	6e b8       	ld.w	r8,r7[0x2c]
80003ec8:	80 00       	ld.sh	r0,r0[0x0]
80003eca:	2f e0       	sub	r0,-2
80003ecc:	00 00       	add	r0,r0
80003ece:	0a 41       	or	r1,r5
80003ed0:	00 00       	add	r0,r0
80003ed2:	0e bc       	st.h	r7++,r12
80003ed4:	80 00       	ld.sh	r0,r0[0x0]
80003ed6:	28 ac       	sub	r12,-118
80003ed8:	80 00       	ld.sh	r0,r0[0x0]
80003eda:	d1 58       	*unknown*
80003edc:	00 00       	add	r0,r0
80003ede:	0a c8       	st.b	r5++,r8
80003ee0:	00 00       	add	r0,r0
80003ee2:	0d c0       	ld.ub	r0,r6[0x4]
80003ee4:	00 00       	add	r0,r0
80003ee6:	0a 90       	mov	r0,r5
80003ee8:	00 00       	add	r0,r0
80003eea:	0a 54       	eor	r4,r5
80003eec:	00 00       	add	r0,r0
80003eee:	0a 40       	or	r0,r5
80003ef0:	00 00       	add	r0,r0
80003ef2:	0a a8       	st.w	r5++,r8
80003ef4:	00 00       	add	r0,r0
80003ef6:	0a 68       	and	r8,r5
80003ef8:	00 00       	add	r0,r0
80003efa:	0a 55       	eor	r5,r5
80003efc:	00 00       	add	r0,r0
80003efe:	0a 56       	eor	r6,r5
80003f00:	00 00       	add	r0,r0
80003f02:	0d b8       	ld.ub	r8,r6[0x3]
80003f04:	80 00       	ld.sh	r0,r0[0x0]
80003f06:	d1 6c       	*unknown*

80003f08 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003f08:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003f0a:	49 88       	lddpc	r8,80003f68 <pdca_int_handler+0x60>
80003f0c:	11 89       	ld.ub	r9,r8[0x0]
80003f0e:	ec 19 00 01 	eorl	r9,0x1
80003f12:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003f14:	11 89       	ld.ub	r9,r8[0x0]
80003f16:	a5 69       	lsl	r9,0x4
80003f18:	2f c9       	sub	r9,-4
80003f1a:	49 5a       	lddpc	r10,80003f6c <pdca_int_handler+0x64>
80003f1c:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003f1e:	fe 7a 00 40 	mov	r10,-65472
80003f22:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003f24:	30 39       	mov	r9,3
80003f26:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003f28:	11 8a       	ld.ub	r10,r8[0x0]
80003f2a:	a5 6a       	lsl	r10,0x4
80003f2c:	2f ca       	sub	r10,-4
80003f2e:	49 18       	lddpc	r8,80003f70 <pdca_int_handler+0x68>
80003f30:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003f32:	fe 78 00 00 	mov	r8,-65536
80003f36:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003f38:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003f3a:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003f3c:	48 e8       	lddpc	r8,80003f74 <pdca_int_handler+0x6c>
80003f3e:	70 08       	ld.w	r8,r8[0x0]
80003f40:	58 08       	cp.w	r8,0
80003f42:	c0 70       	breq	80003f50 <pdca_int_handler+0x48>
80003f44:	48 99       	lddpc	r9,80003f68 <pdca_int_handler+0x60>
80003f46:	13 89       	ld.ub	r9,r9[0x0]
80003f48:	a5 69       	lsl	r9,0x4
80003f4a:	48 ac       	lddpc	r12,80003f70 <pdca_int_handler+0x68>
80003f4c:	12 0c       	add	r12,r9
80003f4e:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003f50:	48 a8       	lddpc	r8,80003f78 <pdca_int_handler+0x70>
80003f52:	70 08       	ld.w	r8,r8[0x0]
80003f54:	58 08       	cp.w	r8,0
80003f56:	c0 70       	breq	80003f64 <pdca_int_handler+0x5c>
80003f58:	48 49       	lddpc	r9,80003f68 <pdca_int_handler+0x60>
80003f5a:	13 89       	ld.ub	r9,r9[0x0]
80003f5c:	a5 69       	lsl	r9,0x4
80003f5e:	48 4c       	lddpc	r12,80003f6c <pdca_int_handler+0x64>
80003f60:	12 0c       	add	r12,r9
80003f62:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003f64:	d4 02       	popm	lr
80003f66:	d6 03       	rete
80003f68:	00 00       	add	r0,r0
80003f6a:	40 c4       	lddsp	r4,sp[0x30]
80003f6c:	00 00       	add	r0,r0
80003f6e:	40 ec       	lddsp	r12,sp[0x38]
80003f70:	00 00       	add	r0,r0
80003f72:	40 cc       	lddsp	r12,sp[0x30]
80003f74:	00 00       	add	r0,r0
80003f76:	0a e8       	st.h	--r5,r8
80003f78:	00 00       	add	r0,r0
80003f7a:	0a ec       	st.h	--r5,r12

80003f7c <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003f7c:	fe 78 10 00 	mov	r8,-61440
80003f80:	e0 69 0d c0 	mov	r9,3520
80003f84:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003f88:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003f8c:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003f90:	fe 78 34 00 	mov	r8,-52224
80003f94:	e0 69 80 00 	mov	r9,32768
80003f98:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003f9a:	30 09       	mov	r9,0
80003f9c:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003f9e:	e0 69 04 21 	mov	r9,1057
80003fa2:	ea 19 3f 20 	orh	r9,0x3f20
80003fa6:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80003fa8:	e0 69 02 9f 	mov	r9,671
80003fac:	ea 19 01 00 	orh	r9,0x100
80003fb0:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80003fb2:	e0 6a 04 02 	mov	r10,1026
80003fb6:	ea 1a 3f 20 	orh	r10,0x3f20
80003fba:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80003fbc:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003fbe:	5e fc       	retal	r12

80003fc0 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003fc0:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003fc2:	30 19       	mov	r9,1
80003fc4:	49 78       	lddpc	r8,80004020 <local_start_PDC+0x60>
80003fc6:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003fc8:	fe 78 00 00 	mov	r8,-65536
80003fcc:	30 7b       	mov	r11,7
80003fce:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003fd0:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003fd2:	49 59       	lddpc	r9,80004024 <local_start_PDC+0x64>
80003fd4:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003fd8:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003fda:	30 3a       	mov	r10,3
80003fdc:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003fde:	30 1c       	mov	r12,1
80003fe0:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003fe2:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003fe4:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003fe6:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003fe8:	30 2c       	mov	r12,2
80003fea:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003fec:	48 f9       	lddpc	r9,80004028 <local_start_PDC+0x68>
80003fee:	e0 68 5a 5a 	mov	r8,23130
80003ff2:	ea 18 ab cd 	orh	r8,0xabcd
80003ff6:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003ff8:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003ffa:	30 0e       	mov	lr,0
80003ffc:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003ffe:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004000:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80004002:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80004004:	fe 78 00 40 	mov	r8,-65472
80004008:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
8000400a:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
8000400c:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80004010:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80004012:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80004014:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80004016:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004018:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
8000401a:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
8000401c:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
8000401e:	d8 02       	popm	pc
80004020:	00 00       	add	r0,r0
80004022:	40 c4       	lddsp	r4,sp[0x30]
80004024:	00 00       	add	r0,r0
80004026:	40 cc       	lddsp	r12,sp[0x30]
80004028:	00 00       	add	r0,r0
8000402a:	40 ec       	lddsp	r12,sp[0x38]

8000402c <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
8000402c:	48 38       	lddpc	r8,80004038 <register_rx_tx_func+0xc>
8000402e:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80004030:	48 38       	lddpc	r8,8000403c <register_rx_tx_func+0x10>
80004032:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80004034:	5e fc       	retal	r12
80004036:	00 00       	add	r0,r0
80004038:	00 00       	add	r0,r0
8000403a:	0a e8       	st.h	--r5,r8
8000403c:	00 00       	add	r0,r0
8000403e:	0a ec       	st.h	--r5,r12

80004040 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80004040:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80004042:	fe 78 10 00 	mov	r8,-61440
80004046:	30 29       	mov	r9,2
80004048:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
8000404c:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80004050:	10 99       	mov	r9,r8
80004052:	f2 f8 01 60 	ld.w	r8,r9[352]
80004056:	e2 18 00 02 	andl	r8,0x2,COH
8000405a:	cf c0       	breq	80004052 <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000405c:	fe 79 10 00 	mov	r9,-61440
80004060:	f2 f8 01 60 	ld.w	r8,r9[352]
80004064:	e2 18 00 02 	andl	r8,0x2,COH
80004068:	cf c1       	brne	80004060 <ssc_init+0x20>
				
    INTC_register_interrupt (
8000406a:	30 3a       	mov	r10,3
8000406c:	36 0b       	mov	r11,96
8000406e:	48 bc       	lddpc	r12,80004098 <ssc_init+0x58>
80004070:	f0 1f 00 0b 	mcall	8000409c <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80004074:	f0 1f 00 0b 	mcall	800040a0 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80004078:	f0 1f 00 0b 	mcall	800040a4 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
8000407c:	fe 79 00 00 	mov	r9,-65536
80004080:	30 18       	mov	r8,1
80004082:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004084:	fe 7a 00 40 	mov	r10,-65472
80004088:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
8000408a:	e0 6b 01 01 	mov	r11,257
8000408e:	fe 7a 34 00 	mov	r10,-52224
80004092:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80004094:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80004096:	d8 02       	popm	pc
80004098:	80 00       	ld.sh	r0,r0[0x0]
8000409a:	3f 08       	mov	r8,-16
8000409c:	80 00       	ld.sh	r0,r0[0x0]
8000409e:	4a dc       	lddpc	r12,80004150 <xcmp_DeviceInitializationStatus_request+0x18>
800040a0:	80 00       	ld.sh	r0,r0[0x0]
800040a2:	3f 7c       	mov	r12,-9
800040a4:	80 00       	ld.sh	r0,r0[0x0]
800040a6:	3f c0       	mov	r0,-4

800040a8 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
800040a8:	48 28       	lddpc	r8,800040b0 <xcmp_register_app_list+0x8>
800040aa:	91 0c       	st.w	r8[0x0],r12
}
800040ac:	5e fc       	retal	r12
800040ae:	00 00       	add	r0,r0
800040b0:	00 00       	add	r0,r0
800040b2:	41 0c       	lddsp	r12,sp[0x40]

800040b4 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
800040b4:	eb cd 40 80 	pushm	r7,lr
800040b8:	fa cd 01 00 	sub	sp,sp,256
800040bc:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
800040be:	16 98       	mov	r8,r11
800040c0:	2f 08       	sub	r8,-16
800040c2:	af a8       	sbr	r8,0xe
800040c4:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
800040c6:	3f f8       	mov	r8,-1
800040c8:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
800040ca:	30 b9       	mov	r9,11
800040cc:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
800040ce:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
800040d0:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
800040d2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800040d4:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
800040d6:	f6 ca ff fe 	sub	r10,r11,-2
800040da:	18 9b       	mov	r11,r12
800040dc:	fa cc ff f0 	sub	r12,sp,-16
800040e0:	f0 1f 00 05 	mcall	800040f4 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
800040e4:	2f e7       	sub	r7,-2
800040e6:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
800040e8:	1a 9c       	mov	r12,sp
800040ea:	f0 1f 00 04 	mcall	800040f8 <xcmp_tx+0x44>
}
800040ee:	2c 0d       	sub	sp,-256
800040f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800040f4:	80 00       	ld.sh	r0,r0[0x0]
800040f6:	6d 70       	ld.w	r0,r6[0x5c]
800040f8:	80 00       	ld.sh	r0,r0[0x0]
800040fa:	45 40       	lddsp	r0,sp[0x150]

800040fc <xcmp_audio_route_mic>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_audio_route_mic(void)
{
800040fc:	d4 01       	pushm	lr
800040fe:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
80004102:	e0 68 04 14 	mov	r8,1044
80004106:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
80004108:	fa c8 ff fc 	sub	r8,sp,-4
			
	ptr->Function = Routing_Func_Update_Source;
8000410c:	30 19       	mov	r9,1
8000410e:	b0 89       	st.b	r8[0x0],r9
	
	
	unsigned short NumberofRoutings = 2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
80004110:	30 0a       	mov	r10,0
80004112:	b0 9a       	st.b	r8[0x1],r10
	ptr->NumberofRoutings[1] = NumberofRoutings & 0xFF;
80004114:	30 2a       	mov	r10,2
80004116:	b0 aa       	st.b	r8[0x2],r10
	
	ptr->RoutingData[0].audioInput = IN_Microphone;
80004118:	b0 b9       	st.b	r8[0x3],r9
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;
8000411a:	30 c9       	mov	r9,12
8000411c:	b0 c9       	st.b	r8[0x4],r9
	
	ptr->RoutingData[1].audioInput = IN_Option_Board;
8000411e:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;
80004120:	30 d9       	mov	r9,13
80004122:	b0 e9       	st.b	r8[0x6],r9
		//
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
80004124:	30 7b       	mov	r11,7
80004126:	fa cc ff fe 	sub	r12,sp,-2
8000412a:	f0 1f 00 03 	mcall	80004134 <xcmp_audio_route_mic+0x38>
}
8000412e:	2c dd       	sub	sp,-204
80004130:	d8 02       	popm	pc
80004132:	00 00       	add	r0,r0
80004134:	80 00       	ld.sh	r0,r0[0x0]
80004136:	40 b4       	lddsp	r4,sp[0x2c]

80004138 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80004138:	d4 01       	pushm	lr
8000413a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
8000413e:	fe 78 b4 00 	mov	r8,-19456
80004142:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004144:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80004148:	30 89       	mov	r9,8
8000414a:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
8000414c:	30 19       	mov	r9,1
8000414e:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80004150:	30 09       	mov	r9,0
80004152:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80004154:	30 5a       	mov	r10,5
80004156:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80004158:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
8000415a:	30 7a       	mov	r10,7
8000415c:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
8000415e:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004160:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80004162:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80004166:	30 9b       	mov	r11,9
80004168:	fa cc ff fe 	sub	r12,sp,-2
8000416c:	f0 1f 00 02 	mcall	80004174 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004170:	2c dd       	sub	sp,-204
80004172:	d8 02       	popm	pc
80004174:	80 00       	ld.sh	r0,r0[0x0]
80004176:	40 b4       	lddsp	r4,sp[0x2c]

80004178 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80004178:	d4 01       	pushm	lr
8000417a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
8000417e:	fe 78 80 00 	mov	r8,-32768
80004182:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80004184:	30 38       	mov	r8,3
80004186:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80004188:	30 1b       	mov	r11,1
8000418a:	fa cc ff fe 	sub	r12,sp,-2
8000418e:	f0 1f 00 03 	mcall	80004198 <xcmp_opcode_not_supported+0x20>
}
80004192:	2c dd       	sub	sp,-204
80004194:	d8 02       	popm	pc
80004196:	00 00       	add	r0,r0
80004198:	80 00       	ld.sh	r0,r0[0x0]
8000419a:	40 b4       	lddsp	r4,sp[0x2c]

8000419c <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
8000419c:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
8000419e:	96 88       	ld.uh	r8,r11[0x0]
800041a0:	e2 18 f0 00 	andl	r8,0xf000,COH
800041a4:	e0 48 80 00 	cp.w	r8,32768
800041a8:	c0 f0       	breq	800041c6 <xcmp_exec_func+0x2a>
800041aa:	e0 48 b0 00 	cp.w	r8,45056
800041ae:	c1 20       	breq	800041d2 <xcmp_exec_func+0x36>
800041b0:	58 08       	cp.w	r8,0
800041b2:	c1 51       	brne	800041dc <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
800041b4:	78 08       	ld.w	r8,r12[0x0]
800041b6:	58 08       	cp.w	r8,0
800041b8:	c0 40       	breq	800041c0 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
800041ba:	16 9c       	mov	r12,r11
800041bc:	5d 18       	icall	r8
800041be:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
800041c0:	f0 1f 00 08 	mcall	800041e0 <xcmp_exec_func+0x44>
800041c4:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
800041c6:	78 18       	ld.w	r8,r12[0x4]
800041c8:	58 08       	cp.w	r8,0
800041ca:	c0 90       	breq	800041dc <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
800041cc:	16 9c       	mov	r12,r11
800041ce:	5d 18       	icall	r8
800041d0:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
800041d2:	78 28       	ld.w	r8,r12[0x8]
800041d4:	58 08       	cp.w	r8,0
800041d6:	c0 30       	breq	800041dc <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
800041d8:	16 9c       	mov	r12,r11
800041da:	5d 18       	icall	r8
800041dc:	d8 02       	popm	pc
800041de:	00 00       	add	r0,r0
800041e0:	80 00       	ld.sh	r0,r0[0x0]
800041e2:	41 78       	lddsp	r8,sp[0x5c]

800041e4 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
800041e4:	d4 01       	pushm	lr
800041e6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
800041ea:	e0 68 04 09 	mov	r8,1033
800041ee:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
800041f0:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
800041f4:	30 19       	mov	r9,1
800041f6:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
800041f8:	30 09       	mov	r9,0
800041fa:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
800041fc:	30 ca       	mov	r10,12
800041fe:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004200:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80004202:	fb 69 00 08 	st.b	sp[8],r9
80004206:	fa c8 ff f7 	sub	r8,sp,-9
8000420a:	b0 89       	st.b	r8[0x0],r9
8000420c:	fa c8 ff f6 	sub	r8,sp,-10
80004210:	b0 89       	st.b	r8[0x0],r9
80004212:	fa c8 ff f5 	sub	r8,sp,-11
80004216:	b0 89       	st.b	r8[0x0],r9
80004218:	fa c8 ff f4 	sub	r8,sp,-12
8000421c:	b0 89       	st.b	r8[0x0],r9
8000421e:	fa c8 ff f3 	sub	r8,sp,-13
80004222:	b0 89       	st.b	r8[0x0],r9
80004224:	fa c8 ff f2 	sub	r8,sp,-14
80004228:	b0 89       	st.b	r8[0x0],r9
8000422a:	fa c8 ff f1 	sub	r8,sp,-15
8000422e:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004230:	30 cb       	mov	r11,12
80004232:	fa cc ff fe 	sub	r12,sp,-2
80004236:	f0 1f 00 03 	mcall	80004240 <xcmp_IdleTestTone+0x5c>
}
8000423a:	2c dd       	sub	sp,-204
8000423c:	d8 02       	popm	pc
8000423e:	00 00       	add	r0,r0
80004240:	80 00       	ld.sh	r0,r0[0x0]
80004242:	40 b4       	lddsp	r4,sp[0x2c]

80004244 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004244:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
80004246:	f0 1f 00 0d 	mcall	80004278 <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
8000424a:	48 dc       	lddpc	r12,8000427c <xcmp_init+0x38>
8000424c:	f0 1f 00 0d 	mcall	80004280 <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004250:	30 4b       	mov	r11,4
80004252:	31 4c       	mov	r12,20
80004254:	f0 1f 00 0c 	mcall	80004284 <xcmp_init+0x40>
80004258:	48 c8       	lddpc	r8,80004288 <xcmp_init+0x44>
8000425a:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
8000425c:	30 09       	mov	r9,0
8000425e:	1a d9       	st.w	--sp,r9
80004260:	1a d9       	st.w	--sp,r9
80004262:	1a d9       	st.w	--sp,r9
80004264:	30 38       	mov	r8,3
80004266:	e0 6a 01 80 	mov	r10,384
8000426a:	48 9b       	lddpc	r11,8000428c <xcmp_init+0x48>
8000426c:	48 9c       	lddpc	r12,80004290 <xcmp_init+0x4c>
8000426e:	f0 1f 00 0a 	mcall	80004294 <xcmp_init+0x50>
80004272:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
80004274:	d8 02       	popm	pc
80004276:	00 00       	add	r0,r0
80004278:	80 00       	ld.sh	r0,r0[0x0]
8000427a:	46 24       	lddsp	r4,sp[0x188]
8000427c:	80 00       	ld.sh	r0,r0[0x0]
8000427e:	43 94       	lddsp	r4,sp[0xe4]
80004280:	80 00       	ld.sh	r0,r0[0x0]
80004282:	43 e0       	lddsp	r0,sp[0xf8]
80004284:	80 00       	ld.sh	r0,r0[0x0]
80004286:	59 78       	cp.w	r8,23
80004288:	00 00       	add	r0,r0
8000428a:	0a fc       	st.b	--r5,r12
8000428c:	80 00       	ld.sh	r0,r0[0x0]
8000428e:	d1 98       	*unknown*
80004290:	80 00       	ld.sh	r0,r0[0x0]
80004292:	42 98       	lddsp	r8,sp[0xa4]
80004294:	80 00       	ld.sh	r0,r0[0x0]
80004296:	60 4c       	ld.w	r12,r0[0x10]

80004298 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004298:	d4 31       	pushm	r0-r7,lr
8000429a:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000429c:	4b 16       	lddpc	r6,80004360 <xcmp_rx_process+0xc8>
8000429e:	30 05       	mov	r5,0
800042a0:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800042a2:	4b 13       	lddpc	r3,80004364 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800042a4:	4b 12       	lddpc	r2,80004368 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800042a6:	4b 21       	lddpc	r1,8000436c <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800042a8:	4b 20       	lddpc	r0,80004370 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800042aa:	6c 0c       	ld.w	r12,r6[0x0]
800042ac:	0a 99       	mov	r9,r5
800042ae:	08 9a       	mov	r10,r4
800042b0:	1a 9b       	mov	r11,sp
800042b2:	f0 1f 00 31 	mcall	80004374 <xcmp_rx_process+0xdc>
800042b6:	58 1c       	cp.w	r12,1
800042b8:	cf 91       	brne	800042aa <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
800042ba:	40 0b       	lddsp	r11,sp[0x0]
800042bc:	58 0b       	cp.w	r11,0
800042be:	cf 60       	breq	800042aa <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
800042c0:	96 0a       	ld.sh	r10,r11[0x0]
800042c2:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800042c6:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
800042ca:	59 c8       	cp.w	r8,28
800042cc:	c1 e0       	breq	80004308 <xcmp_rx_process+0x70>
800042ce:	e0 89 00 07 	brgt	800042dc <xcmp_rx_process+0x44>
800042d2:	58 e8       	cp.w	r8,14
800042d4:	c0 e0       	breq	800042f0 <xcmp_rx_process+0x58>
800042d6:	58 f8       	cp.w	r8,15
800042d8:	c2 41       	brne	80004320 <xcmp_rx_process+0x88>
800042da:	c0 f8       	rjmp	800042f8 <xcmp_rx_process+0x60>
800042dc:	e0 48 01 09 	cp.w	r8,265
800042e0:	c1 80       	breq	80004310 <xcmp_rx_process+0x78>
800042e2:	e0 48 01 0a 	cp.w	r8,266
800042e6:	c1 90       	breq	80004318 <xcmp_rx_process+0x80>
800042e8:	e0 48 00 2c 	cp.w	r8,44
800042ec:	c1 a1       	brne	80004320 <xcmp_rx_process+0x88>
800042ee:	c0 98       	rjmp	80004300 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
800042f0:	4a 2c       	lddpc	r12,80004378 <xcmp_rx_process+0xe0>
800042f2:	f0 1f 00 23 	mcall	8000437c <xcmp_rx_process+0xe4>
					break;
800042f6:	c2 f8       	rjmp	80004354 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
800042f8:	4a 2c       	lddpc	r12,80004380 <xcmp_rx_process+0xe8>
800042fa:	f0 1f 00 21 	mcall	8000437c <xcmp_rx_process+0xe4>
					break;
800042fe:	c2 b8       	rjmp	80004354 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004300:	4a 1c       	lddpc	r12,80004384 <xcmp_rx_process+0xec>
80004302:	f0 1f 00 1f 	mcall	8000437c <xcmp_rx_process+0xe4>
					break;
80004306:	c2 78       	rjmp	80004354 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004308:	04 9c       	mov	r12,r2
8000430a:	f0 1f 00 1d 	mcall	8000437c <xcmp_rx_process+0xe4>
						, ptr);
					break;
8000430e:	c2 38       	rjmp	80004354 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004310:	02 9c       	mov	r12,r1
80004312:	f0 1f 00 1b 	mcall	8000437c <xcmp_rx_process+0xe4>
					break;
80004316:	c1 f8       	rjmp	80004354 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004318:	00 9c       	mov	r12,r0
8000431a:	f0 1f 00 19 	mcall	8000437c <xcmp_rx_process+0xe4>
					break;
8000431e:	c1 b8       	rjmp	80004354 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004320:	12 98       	mov	r8,r9
80004322:	e2 18 04 00 	andl	r8,0x400,COH
80004326:	c0 70       	breq	80004334 <xcmp_rx_process+0x9c>
80004328:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000432c:	e0 48 00 68 	cp.w	r8,104
80004330:	e0 8a 00 08 	brle	80004340 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004334:	e2 19 f0 00 	andl	r9,0xf000,COH
80004338:	c0 e1       	brne	80004354 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
8000433a:	f0 1f 00 14 	mcall	80004388 <xcmp_rx_process+0xf0>
8000433e:	c0 b8       	rjmp	80004354 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004340:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004344:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004348:	49 19       	lddpc	r9,8000438c <xcmp_rx_process+0xf4>
8000434a:	72 08       	ld.w	r8,r9[0x0]
8000434c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004350:	f0 1f 00 0b 	mcall	8000437c <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004354:	66 0c       	ld.w	r12,r3[0x0]
80004356:	40 0b       	lddsp	r11,sp[0x0]
80004358:	f0 1f 00 0e 	mcall	80004390 <xcmp_rx_process+0xf8>
8000435c:	ca 7b       	rjmp	800042aa <xcmp_rx_process+0x12>
8000435e:	00 00       	add	r0,r0
80004360:	00 00       	add	r0,r0
80004362:	0a fc       	st.b	--r5,r12
80004364:	00 00       	add	r0,r0
80004366:	0a b8       	st.h	r5++,r8
80004368:	00 00       	add	r0,r0
8000436a:	0b 0c       	ld.w	r12,r5++
8000436c:	00 00       	add	r0,r0
8000436e:	0b 00       	ld.w	r0,r5++
80004370:	00 00       	add	r0,r0
80004372:	0b 18       	ld.sh	r8,r5++
80004374:	80 00       	ld.sh	r0,r0[0x0]
80004376:	56 14       	stdsp	sp[0x184],r4
80004378:	00 00       	add	r0,r0
8000437a:	0b 30       	ld.ub	r0,r5++
8000437c:	80 00       	ld.sh	r0,r0[0x0]
8000437e:	41 9c       	lddsp	r12,sp[0x64]
80004380:	00 00       	add	r0,r0
80004382:	0a f0       	st.b	--r5,r0
80004384:	00 00       	add	r0,r0
80004386:	0b 24       	ld.uh	r4,r5++
80004388:	80 00       	ld.sh	r0,r0[0x0]
8000438a:	41 78       	lddsp	r8,sp[0x5c]
8000438c:	00 00       	add	r0,r0
8000438e:	41 0c       	lddsp	r12,sp[0x40]
80004390:	80 00       	ld.sh	r0,r0[0x0]
80004392:	29 a0       	sub	r0,-102

80004394 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004394:	eb cd 40 90 	pushm	r4,r7,lr
80004398:	20 1d       	sub	sp,4
8000439a:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000439e:	48 c8       	lddpc	r8,800043cc <xcmp_rx+0x38>
800043a0:	70 0c       	ld.w	r12,r8[0x0]
800043a2:	f0 1f 00 0c 	mcall	800043d0 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
800043a6:	c1 00       	breq	800043c6 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800043a8:	fa c7 ff fc 	sub	r7,sp,-4
800043ac:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
800043ae:	e0 6a 00 ca 	mov	r10,202
800043b2:	08 9b       	mov	r11,r4
800043b4:	f0 1f 00 08 	mcall	800043d4 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
800043b8:	48 88       	lddpc	r8,800043d8 <xcmp_rx+0x44>
800043ba:	70 0c       	ld.w	r12,r8[0x0]
800043bc:	30 09       	mov	r9,0
800043be:	12 9a       	mov	r10,r9
800043c0:	1a 9b       	mov	r11,sp
800043c2:	f0 1f 00 07 	mcall	800043dc <xcmp_rx+0x48>
	}	
}
800043c6:	2f fd       	sub	sp,-4
800043c8:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
800043cc:	00 00       	add	r0,r0
800043ce:	0a b8       	st.h	r5++,r8
800043d0:	80 00       	ld.sh	r0,r0[0x0]
800043d2:	2e ec       	sub	r12,-18
800043d4:	80 00       	ld.sh	r0,r0[0x0]
800043d6:	6d 70       	ld.w	r0,r6[0x5c]
800043d8:	00 00       	add	r0,r0
800043da:	0a fc       	st.b	--r5,r12
800043dc:	80 00       	ld.sh	r0,r0[0x0]
800043de:	58 20       	cp.w	r0,2

800043e0 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
800043e0:	48 28       	lddpc	r8,800043e8 <xnl_register_xcmp_func+0x8>
800043e2:	91 0c       	st.w	r8[0x0],r12
}
800043e4:	5e fc       	retal	r12
800043e6:	00 00       	add	r0,r0
800043e8:	00 00       	add	r0,r0
800043ea:	0b 60       	ld.uh	r0,--r5

800043ec <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
800043ec:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
800043ee:	48 88       	lddpc	r8,8000440c <xnl_get_msg_ack_func+0x20>
800043f0:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
800043f2:	98 49       	ld.sh	r9,r12[0x8]
800043f4:	f0 09 19 00 	cp.h	r9,r8
800043f8:	c0 81       	brne	80004408 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
800043fa:	48 68       	lddpc	r8,80004410 <xnl_get_msg_ack_func+0x24>
800043fc:	70 0c       	ld.w	r12,r8[0x0]
800043fe:	30 09       	mov	r9,0
80004400:	12 9a       	mov	r10,r9
80004402:	12 9b       	mov	r11,r9
80004404:	f0 1f 00 04 	mcall	80004414 <xnl_get_msg_ack_func+0x28>
80004408:	d8 02       	popm	pc
8000440a:	00 00       	add	r0,r0
8000440c:	00 00       	add	r0,r0
8000440e:	0b 40       	ld.w	r0,--r5
80004410:	00 00       	add	r0,r0
80004412:	0b 3c       	ld.ub	r12,r5++
80004414:	80 00       	ld.sh	r0,r0[0x0]
80004416:	58 20       	cp.w	r0,2

80004418 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004418:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000441a:	4a 86       	lddpc	r6,800044b8 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000441c:	4a 82       	lddpc	r2,800044bc <xnl_tx_process+0xa4>
8000441e:	4a 94       	lddpc	r4,800044c0 <xnl_tx_process+0xa8>
80004420:	30 07       	mov	r7,0
80004422:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004424:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80004426:	4a 85       	lddpc	r5,800044c4 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004428:	4a 83       	lddpc	r3,800044c8 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000442a:	6c 08       	ld.w	r8,r6[0x0]
8000442c:	58 08       	cp.w	r8,0
8000442e:	c0 40       	breq	80004436 <xnl_tx_process+0x1e>
80004430:	58 18       	cp.w	r8,1
80004432:	cf d1       	brne	8000442c <xnl_tx_process+0x14>
80004434:	c2 08       	rjmp	80004474 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004436:	64 0c       	ld.w	r12,r2[0x0]
80004438:	0e 99       	mov	r9,r7
8000443a:	02 9a       	mov	r10,r1
8000443c:	08 9b       	mov	r11,r4
8000443e:	f0 1f 00 24 	mcall	800044cc <xnl_tx_process+0xb4>
80004442:	58 1c       	cp.w	r12,1
80004444:	cf 31       	brne	8000442a <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004446:	68 0c       	ld.w	r12,r4[0x0]
80004448:	58 0c       	cp.w	r12,0
8000444a:	cf 00       	breq	8000442a <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
8000444c:	98 28       	ld.sh	r8,r12[0x4]
8000444e:	e0 08 19 00 	cp.h	r8,r0
80004452:	c0 41       	brne	8000445a <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
80004454:	f0 1f 00 1f 	mcall	800044d0 <xnl_tx_process+0xb8>
						break;
80004458:	ce 9b       	rjmp	8000442a <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
8000445a:	f0 1f 00 1f 	mcall	800044d4 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
8000445e:	30 18       	mov	r8,1
80004460:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004462:	66 0c       	ld.w	r12,r3[0x0]
80004464:	0e 99       	mov	r9,r7
80004466:	0e 9a       	mov	r10,r7
80004468:	0e 9b       	mov	r11,r7
8000446a:	f0 1f 00 19 	mcall	800044cc <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
8000446e:	30 18       	mov	r8,1
80004470:	8d 08       	st.w	r6[0x0],r8
80004472:	cd cb       	rjmp	8000442a <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004474:	66 0c       	ld.w	r12,r3[0x0]
80004476:	0e 99       	mov	r9,r7
80004478:	36 4a       	mov	r10,100
8000447a:	0e 9b       	mov	r11,r7
8000447c:	f0 1f 00 14 	mcall	800044cc <xnl_tx_process+0xb4>
80004480:	58 1c       	cp.w	r12,1
80004482:	c0 81       	brne	80004492 <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
80004484:	49 58       	lddpc	r8,800044d8 <xnl_tx_process+0xc0>
80004486:	70 0c       	ld.w	r12,r8[0x0]
80004488:	68 0b       	ld.w	r11,r4[0x0]
8000448a:	f0 1f 00 15 	mcall	800044dc <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000448e:	8d 07       	st.w	r6[0x0],r7
80004490:	cc db       	rjmp	8000442a <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004492:	6a 08       	ld.w	r8,r5[0x0]
80004494:	58 38       	cp.w	r8,3
80004496:	e0 89 00 09 	brgt	800044a8 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000449a:	68 0c       	ld.w	r12,r4[0x0]
8000449c:	f0 1f 00 0e 	mcall	800044d4 <xnl_tx_process+0xbc>
						xnl_send_times++;
800044a0:	6a 08       	ld.w	r8,r5[0x0]
800044a2:	2f f8       	sub	r8,-1
800044a4:	8b 08       	st.w	r5[0x0],r8
800044a6:	cc 2b       	rjmp	8000442a <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800044a8:	48 c8       	lddpc	r8,800044d8 <xnl_tx_process+0xc0>
800044aa:	70 0c       	ld.w	r12,r8[0x0]
800044ac:	68 0b       	ld.w	r11,r4[0x0]
800044ae:	f0 1f 00 0c 	mcall	800044dc <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800044b2:	8d 07       	st.w	r6[0x0],r7
800044b4:	cb bb       	rjmp	8000442a <xnl_tx_process+0x12>
800044b6:	00 00       	add	r0,r0
800044b8:	00 00       	add	r0,r0
800044ba:	0b 5c       	ld.sh	r12,--r5
800044bc:	00 00       	add	r0,r0
800044be:	0b 50       	ld.sh	r0,--r5
800044c0:	00 00       	add	r0,r0
800044c2:	0b 54       	ld.sh	r4,--r5
800044c4:	00 00       	add	r0,r0
800044c6:	0b 4c       	ld.w	r12,--r5
800044c8:	00 00       	add	r0,r0
800044ca:	0b 3c       	ld.ub	r12,r5++
800044cc:	80 00       	ld.sh	r0,r0[0x0]
800044ce:	56 14       	stdsp	sp[0x184],r4
800044d0:	80 00       	ld.sh	r0,r0[0x0]
800044d2:	54 a4       	stdsp	sp[0x128],r4
800044d4:	80 00       	ld.sh	r0,r0[0x0]
800044d6:	29 c0       	sub	r0,-100
800044d8:	00 00       	add	r0,r0
800044da:	0a b8       	st.h	r5++,r8
800044dc:	80 00       	ld.sh	r0,r0[0x0]
800044de:	29 a0       	sub	r0,-102

800044e0 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
800044e0:	eb cd 40 fe 	pushm	r1-r7,lr
800044e4:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800044e6:	49 26       	lddpc	r6,8000452c <xnl_rx_process+0x4c>
800044e8:	30 05       	mov	r5,0
800044ea:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800044ec:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800044ee:	49 11       	lddpc	r1,80004530 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800044f0:	49 12       	lddpc	r2,80004534 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800044f2:	6c 0c       	ld.w	r12,r6[0x0]
800044f4:	0a 99       	mov	r9,r5
800044f6:	08 9a       	mov	r10,r4
800044f8:	1a 9b       	mov	r11,sp
800044fa:	f0 1f 00 10 	mcall	80004538 <xnl_rx_process+0x58>
800044fe:	58 1c       	cp.w	r12,1
80004500:	cf 91       	brne	800044f2 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004502:	40 0c       	lddsp	r12,sp[0x0]
80004504:	58 0c       	cp.w	r12,0
80004506:	cf 60       	breq	800044f2 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004508:	98 28       	ld.sh	r8,r12[0x4]
8000450a:	e6 08 19 00 	cp.h	r8,r3
8000450e:	e0 8b 00 0a 	brhi	80004522 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004512:	5c 78       	castu.h	r8
80004514:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004518:	58 09       	cp.w	r9,0
8000451a:	c0 40       	breq	80004522 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
8000451c:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004520:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004522:	62 0c       	ld.w	r12,r1[0x0]
80004524:	40 0b       	lddsp	r11,sp[0x0]
80004526:	f0 1f 00 06 	mcall	8000453c <xnl_rx_process+0x5c>
8000452a:	ce 4b       	rjmp	800044f2 <xnl_rx_process+0x12>
8000452c:	00 00       	add	r0,r0
8000452e:	0a bc       	st.h	r5++,r12
80004530:	00 00       	add	r0,r0
80004532:	0a b8       	st.h	r5++,r8
80004534:	00 00       	add	r0,r0
80004536:	04 fc       	st.b	--r2,r12
80004538:	80 00       	ld.sh	r0,r0[0x0]
8000453a:	56 14       	stdsp	sp[0x184],r4
8000453c:	80 00       	ld.sh	r0,r0[0x0]
8000453e:	29 a0       	sub	r0,-102

80004540 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004540:	eb cd 40 c0 	pushm	r6-r7,lr
80004544:	20 1d       	sub	sp,4
80004546:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004548:	98 39       	ld.sh	r9,r12[0x6]
8000454a:	3f f8       	mov	r8,-1
8000454c:	f0 09 19 00 	cp.h	r9,r8
80004550:	c0 a1       	brne	80004564 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004552:	4a e9       	lddpc	r9,80004608 <xnl_tx+0xc8>
80004554:	13 88       	ld.ub	r8,r9[0x0]
80004556:	2f f8       	sub	r8,-1
80004558:	5c 58       	castu.b	r8
8000455a:	b2 88       	st.b	r9[0x0],r8
8000455c:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004560:	a9 a8       	sbr	r8,0x8
80004562:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004564:	8c 49       	ld.sh	r9,r6[0x8]
80004566:	3f f8       	mov	r8,-1
80004568:	f0 09 19 00 	cp.h	r9,r8
8000456c:	c0 41       	brne	80004574 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
8000456e:	4a 88       	lddpc	r8,8000460c <xnl_tx+0xcc>
80004570:	90 18       	ld.sh	r8,r8[0x2]
80004572:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004574:	8c 59       	ld.sh	r9,r6[0xa]
80004576:	3f f8       	mov	r8,-1
80004578:	f0 09 19 00 	cp.h	r9,r8
8000457c:	c0 41       	brne	80004584 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000457e:	4a 48       	lddpc	r8,8000460c <xnl_tx+0xcc>
80004580:	90 28       	ld.sh	r8,r8[0x4]
80004582:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004584:	8c 69       	ld.sh	r9,r6[0xc]
80004586:	3f f8       	mov	r8,-1
80004588:	f0 09 19 00 	cp.h	r9,r8
8000458c:	c0 e1       	brne	800045a8 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000458e:	4a 08       	lddpc	r8,8000460c <xnl_tx+0xcc>
80004590:	90 49       	ld.sh	r9,r8[0x8]
80004592:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004594:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004596:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004598:	90 49       	ld.sh	r9,r8[0x8]
8000459a:	e0 19 ff 00 	andl	r9,0xff00
8000459e:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
800045a2:	f3 e8 10 08 	or	r8,r9,r8
800045a6:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
800045a8:	0d 98       	ld.ub	r8,r6[0x1]
800045aa:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
800045ac:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800045b0:	10 0c       	add	r12,r8
800045b2:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800045b4:	58 0c       	cp.w	r12,0
800045b6:	e0 89 00 04 	brgt	800045be <xnl_tx+0x7e>
800045ba:	30 09       	mov	r9,0
800045bc:	c0 d8       	rjmp	800045d6 <xnl_tx+0x96>
800045be:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
800045c2:	2f ec       	sub	r12,-2
800045c4:	30 09       	mov	r9,0
800045c6:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
800045c8:	15 1b       	ld.sh	r11,r10++
800045ca:	f6 09 00 09 	add	r9,r11,r9
800045ce:	5c 89       	casts.h	r9
		indextohWord     += 1;
800045d0:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800045d2:	18 38       	cp.w	r8,r12
800045d4:	cf a1       	brne	800045c8 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800045d6:	5c 39       	neg	r9
800045d8:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800045da:	48 e8       	lddpc	r8,80004610 <xnl_tx+0xd0>
800045dc:	70 0c       	ld.w	r12,r8[0x0]
800045de:	f0 1f 00 0e 	mcall	80004614 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800045e2:	c1 00       	breq	80004602 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800045e4:	fa c7 ff fc 	sub	r7,sp,-4
800045e8:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800045ea:	e0 6a 01 00 	mov	r10,256
800045ee:	0c 9b       	mov	r11,r6
800045f0:	f0 1f 00 0a 	mcall	80004618 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800045f4:	48 a8       	lddpc	r8,8000461c <xnl_tx+0xdc>
800045f6:	70 0c       	ld.w	r12,r8[0x0]
800045f8:	30 09       	mov	r9,0
800045fa:	12 9a       	mov	r10,r9
800045fc:	1a 9b       	mov	r11,sp
800045fe:	f0 1f 00 09 	mcall	80004620 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004602:	2f fd       	sub	sp,-4
80004604:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004608:	00 00       	add	r0,r0
8000460a:	0b 58       	ld.sh	r8,--r5
8000460c:	00 00       	add	r0,r0
8000460e:	0b 40       	ld.w	r0,--r5
80004610:	00 00       	add	r0,r0
80004612:	0a b8       	st.h	r5++,r8
80004614:	80 00       	ld.sh	r0,r0[0x0]
80004616:	2e ec       	sub	r12,-18
80004618:	80 00       	ld.sh	r0,r0[0x0]
8000461a:	6d 70       	ld.w	r0,r6[0x5c]
8000461c:	00 00       	add	r0,r0
8000461e:	0b 50       	ld.sh	r0,--r5
80004620:	80 00       	ld.sh	r0,r0[0x0]
80004622:	58 20       	cp.w	r0,2

80004624 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004624:	eb cd 40 80 	pushm	r7,lr
80004628:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
8000462c:	f0 1f 00 27 	mcall	800046c8 <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
80004630:	30 09       	mov	r9,0
80004632:	4a 78       	lddpc	r8,800046cc <xnl_init+0xa8>
80004634:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004636:	30 0b       	mov	r11,0
80004638:	30 1c       	mov	r12,1
8000463a:	f0 1f 00 26 	mcall	800046d0 <xnl_init+0xac>
8000463e:	4a 68       	lddpc	r8,800046d4 <xnl_init+0xb0>
80004640:	91 0c       	st.w	r8[0x0],r12
80004642:	70 08       	ld.w	r8,r8[0x0]
80004644:	58 08       	cp.w	r8,0
80004646:	c0 80       	breq	80004656 <xnl_init+0x32>
80004648:	4a 38       	lddpc	r8,800046d4 <xnl_init+0xb0>
8000464a:	70 0c       	ld.w	r12,r8[0x0]
8000464c:	30 09       	mov	r9,0
8000464e:	12 9a       	mov	r10,r9
80004650:	12 9b       	mov	r11,r9
80004652:	f0 1f 00 22 	mcall	800046d8 <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004656:	30 4b       	mov	r11,4
80004658:	31 4c       	mov	r12,20
8000465a:	f0 1f 00 1e 	mcall	800046d0 <xnl_init+0xac>
8000465e:	4a 08       	lddpc	r8,800046dc <xnl_init+0xb8>
80004660:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004662:	30 07       	mov	r7,0
80004664:	1a d7       	st.w	--sp,r7
80004666:	1a d7       	st.w	--sp,r7
80004668:	1a d7       	st.w	--sp,r7
8000466a:	30 38       	mov	r8,3
8000466c:	0e 99       	mov	r9,r7
8000466e:	e0 6a 02 00 	mov	r10,512
80004672:	49 cb       	lddpc	r11,800046e0 <xnl_init+0xbc>
80004674:	49 cc       	lddpc	r12,800046e4 <xnl_init+0xc0>
80004676:	f0 1f 00 1d 	mcall	800046e8 <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000467a:	1a d7       	st.w	--sp,r7
8000467c:	1a d7       	st.w	--sp,r7
8000467e:	1a d7       	st.w	--sp,r7
80004680:	30 38       	mov	r8,3
80004682:	0e 99       	mov	r9,r7
80004684:	e0 6a 03 20 	mov	r10,800
80004688:	49 9b       	lddpc	r11,800046ec <xnl_init+0xc8>
8000468a:	49 ac       	lddpc	r12,800046f0 <xnl_init+0xcc>
8000468c:	f0 1f 00 17 	mcall	800046e8 <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004690:	e0 68 40 0e 	mov	r8,16398
80004694:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004698:	3f f8       	mov	r8,-1
8000469a:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
8000469e:	30 38       	mov	r8,3
800046a0:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
800046a4:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
800046a8:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
800046ac:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
800046b0:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
800046b4:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800046b8:	fa cc ff e8 	sub	r12,sp,-24
800046bc:	f0 1f 00 0e 	mcall	800046f4 <xnl_init+0xd0>
800046c0:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
800046c2:	2c 0d       	sub	sp,-256
800046c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800046c8:	80 00       	ld.sh	r0,r0[0x0]
800046ca:	2f 14       	sub	r4,-15
800046cc:	00 00       	add	r0,r0
800046ce:	0b 40       	ld.w	r0,--r5
800046d0:	80 00       	ld.sh	r0,r0[0x0]
800046d2:	59 78       	cp.w	r8,23
800046d4:	00 00       	add	r0,r0
800046d6:	0b 3c       	ld.ub	r12,r5++
800046d8:	80 00       	ld.sh	r0,r0[0x0]
800046da:	58 20       	cp.w	r0,2
800046dc:	00 00       	add	r0,r0
800046de:	0b 50       	ld.sh	r0,--r5
800046e0:	80 00       	ld.sh	r0,r0[0x0]
800046e2:	d1 a0       	acall	0x1a
800046e4:	80 00       	ld.sh	r0,r0[0x0]
800046e6:	44 e0       	lddsp	r0,sp[0x138]
800046e8:	80 00       	ld.sh	r0,r0[0x0]
800046ea:	60 4c       	ld.w	r12,r0[0x10]
800046ec:	80 00       	ld.sh	r0,r0[0x0]
800046ee:	c4 00       	breq	8000476e <xnl_device_auth_reply_func+0x16>
800046f0:	80 00       	ld.sh	r0,r0[0x0]
800046f2:	44 18       	lddsp	r8,sp[0x104]
800046f4:	80 00       	ld.sh	r0,r0[0x0]
800046f6:	45 40       	lddsp	r0,sp[0x150]

800046f8 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800046f8:	eb cd 40 80 	pushm	r7,lr
800046fc:	fa cd 01 00 	sub	sp,sp,256
80004700:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004702:	e0 68 40 0e 	mov	r8,16398
80004706:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004708:	3f f8       	mov	r8,-1
8000470a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
8000470c:	30 c8       	mov	r8,12
8000470e:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004710:	98 38       	ld.sh	r8,r12[0x6]
80004712:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004714:	98 58       	ld.sh	r8,r12[0xa]
80004716:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004718:	98 48       	ld.sh	r8,r12[0x8]
8000471a:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
8000471c:	98 68       	ld.sh	r8,r12[0xc]
8000471e:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004720:	30 08       	mov	r8,0
80004722:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004724:	1a 9c       	mov	r12,sp
80004726:	f0 1f 00 0a 	mcall	8000474c <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000472a:	fa cd 00 cc 	sub	sp,sp,204
8000472e:	e0 6a 00 ca 	mov	r10,202
80004732:	ee cb ff f0 	sub	r11,r7,-16
80004736:	1a 9c       	mov	r12,sp
80004738:	f0 1f 00 06 	mcall	80004750 <xnl_data_msg_func+0x58>
8000473c:	48 68       	lddpc	r8,80004754 <xnl_data_msg_func+0x5c>
8000473e:	70 08       	ld.w	r8,r8[0x0]
80004740:	5d 18       	icall	r8
80004742:	fa cd ff 34 	sub	sp,sp,-204
}
80004746:	2c 0d       	sub	sp,-256
80004748:	e3 cd 80 80 	ldm	sp++,r7,pc
8000474c:	80 00       	ld.sh	r0,r0[0x0]
8000474e:	45 40       	lddsp	r0,sp[0x150]
80004750:	80 00       	ld.sh	r0,r0[0x0]
80004752:	6d 70       	ld.w	r0,r6[0x5c]
80004754:	00 00       	add	r0,r0
80004756:	0b 60       	ld.uh	r0,--r5

80004758 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004758:	d4 21       	pushm	r4-r7,lr
8000475a:	fa cd 01 00 	sub	sp,sp,256
8000475e:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004760:	4c 28       	lddpc	r8,80004868 <xnl_device_auth_reply_func+0x110>
80004762:	11 88       	ld.ub	r8,r8[0x0]
80004764:	58 08       	cp.w	r8,0
80004766:	e0 81 00 7f 	brne	80004864 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
8000476a:	4c 18       	lddpc	r8,8000486c <xnl_device_auth_reply_func+0x114>
8000476c:	70 0c       	ld.w	r12,r8[0x0]
8000476e:	30 09       	mov	r9,0
80004770:	12 9a       	mov	r10,r9
80004772:	12 9b       	mov	r11,r9
80004774:	f0 1f 00 3f 	mcall	80004870 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004778:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
8000477c:	4b b8       	lddpc	r8,80004868 <xnl_device_auth_reply_func+0x110>
8000477e:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004780:	ef 39 00 12 	ld.ub	r9,r7[18]
80004784:	ef 38 00 13 	ld.ub	r8,r7[19]
80004788:	b1 68       	lsl	r8,0x10
8000478a:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000478e:	ef 38 00 15 	ld.ub	r8,r7[21]
80004792:	f3 e8 10 08 	or	r8,r9,r8
80004796:	ef 39 00 14 	ld.ub	r9,r7[20]
8000479a:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
8000479e:	ef 3a 00 16 	ld.ub	r10,r7[22]
800047a2:	ef 38 00 17 	ld.ub	r8,r7[23]
800047a6:	b1 68       	lsl	r8,0x10
800047a8:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800047ac:	ef 38 00 19 	ld.ub	r8,r7[25]
800047b0:	f5 e8 10 08 	or	r8,r10,r8
800047b4:	ef 3a 00 18 	ld.ub	r10,r7[24]
800047b8:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800047bc:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800047be:	e0 64 79 b9 	mov	r4,31161
800047c2:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800047c6:	e0 65 45 07 	mov	r5,17671
800047ca:	ea 15 8a bd 	orh	r5,0x8abd
800047ce:	e0 66 f9 3d 	mov	r6,63805
800047d2:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800047d6:	e0 6e b8 cf 	mov	lr,47311
800047da:	ea 1e 36 83 	orh	lr,0x3683
800047de:	e0 67 aa 1c 	mov	r7,43548
800047e2:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800047e6:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800047e8:	f4 08 00 0c 	add	r12,r10,r8
800047ec:	f0 0b 15 04 	lsl	r11,r8,0x4
800047f0:	0a 0b       	add	r11,r5
800047f2:	f9 eb 20 0b 	eor	r11,r12,r11
800047f6:	f0 0c 16 05 	lsr	r12,r8,0x5
800047fa:	0c 0c       	add	r12,r6
800047fc:	18 5b       	eor	r11,r12
800047fe:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004800:	f2 0c 15 04 	lsl	r12,r9,0x4
80004804:	1c 0c       	add	r12,lr
80004806:	f2 0b 16 05 	lsr	r11,r9,0x5
8000480a:	0e 0b       	add	r11,r7
8000480c:	f9 eb 20 0b 	eor	r11,r12,r11
80004810:	f2 0a 00 0c 	add	r12,r9,r10
80004814:	18 5b       	eor	r11,r12
80004816:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004818:	e0 6b 37 20 	mov	r11,14112
8000481c:	ea 1b c6 ef 	orh	r11,0xc6ef
80004820:	16 3a       	cp.w	r10,r11
80004822:	ce 21       	brne	800047e6 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004824:	e0 6a 40 1a 	mov	r10,16410
80004828:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000482a:	3f fa       	mov	r10,-1
8000482c:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
8000482e:	30 6b       	mov	r11,6
80004830:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004832:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004834:	48 db       	lddpc	r11,80004868 <xnl_device_auth_reply_func+0x110>
80004836:	96 1c       	ld.sh	r12,r11[0x2]
80004838:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
8000483a:	96 2b       	ld.sh	r11,r11[0x4]
8000483c:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000483e:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004840:	30 ca       	mov	r10,12
80004842:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004844:	30 0a       	mov	r10,0
80004846:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
8000484a:	30 7a       	mov	r10,7
8000484c:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004850:	30 2a       	mov	r10,2
80004852:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004856:	fa ca ff ec 	sub	r10,sp,-20
8000485a:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000485c:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000485e:	1a 9c       	mov	r12,sp
80004860:	f0 1f 00 05 	mcall	80004874 <xnl_device_auth_reply_func+0x11c>
}
80004864:	2c 0d       	sub	sp,-256
80004866:	d8 22       	popm	r4-r7,pc
80004868:	00 00       	add	r0,r0
8000486a:	0b 40       	ld.w	r0,--r5
8000486c:	00 00       	add	r0,r0
8000486e:	0b 3c       	ld.ub	r12,r5++
80004870:	80 00       	ld.sh	r0,r0[0x0]
80004872:	58 20       	cp.w	r0,2
80004874:	80 00       	ld.sh	r0,r0[0x0]
80004876:	45 40       	lddsp	r0,sp[0x150]

80004878 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004878:	eb cd 40 80 	pushm	r7,lr
8000487c:	fa cd 01 00 	sub	sp,sp,256
80004880:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004882:	49 28       	lddpc	r8,800048c8 <xnl_master_status_brdcst_func+0x50>
80004884:	11 88       	ld.ub	r8,r8[0x0]
80004886:	58 08       	cp.w	r8,0
80004888:	c1 c1       	brne	800048c0 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000488a:	49 18       	lddpc	r8,800048cc <xnl_master_status_brdcst_func+0x54>
8000488c:	70 0c       	ld.w	r12,r8[0x0]
8000488e:	30 09       	mov	r9,0
80004890:	12 9a       	mov	r10,r9
80004892:	12 9b       	mov	r11,r9
80004894:	f0 1f 00 0f 	mcall	800048d0 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004898:	8e 58       	ld.sh	r8,r7[0xa]
8000489a:	48 c9       	lddpc	r9,800048c8 <xnl_master_status_brdcst_func+0x50>
8000489c:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000489e:	e0 68 40 0e 	mov	r8,16398
800048a2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800048a4:	3f f8       	mov	r8,-1
800048a6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800048a8:	30 4a       	mov	r10,4
800048aa:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800048ac:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800048ae:	92 19       	ld.sh	r9,r9[0x2]
800048b0:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800048b2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800048b4:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800048b6:	30 08       	mov	r8,0
800048b8:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800048ba:	1a 9c       	mov	r12,sp
800048bc:	f0 1f 00 06 	mcall	800048d4 <xnl_master_status_brdcst_func+0x5c>
}
800048c0:	2c 0d       	sub	sp,-256
800048c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800048c6:	00 00       	add	r0,r0
800048c8:	00 00       	add	r0,r0
800048ca:	0b 40       	ld.w	r0,--r5
800048cc:	00 00       	add	r0,r0
800048ce:	0b 3c       	ld.ub	r12,r5++
800048d0:	80 00       	ld.sh	r0,r0[0x0]
800048d2:	58 20       	cp.w	r0,2
800048d4:	80 00       	ld.sh	r0,r0[0x0]
800048d6:	45 40       	lddsp	r0,sp[0x150]

800048d8 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800048d8:	eb cd 40 80 	pushm	r7,lr
800048dc:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800048de:	49 38       	lddpc	r8,80004928 <xnl_device_conn_reply_func+0x50>
800048e0:	70 0c       	ld.w	r12,r8[0x0]
800048e2:	30 09       	mov	r9,0
800048e4:	12 9a       	mov	r10,r9
800048e6:	12 9b       	mov	r11,r9
800048e8:	f0 1f 00 11 	mcall	8000492c <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800048ec:	ef 18 00 10 	ld.uh	r8,r7[16]
800048f0:	10 99       	mov	r9,r8
800048f2:	e2 19 ff 00 	andl	r9,0xff00,COH
800048f6:	e0 49 01 00 	cp.w	r9,256
800048fa:	c0 60       	breq	80004906 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800048fc:	0e 9c       	mov	r12,r7
800048fe:	f0 1f 00 0d 	mcall	80004930 <xnl_device_conn_reply_func+0x58>
80004902:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004906:	a9 68       	lsl	r8,0x8
80004908:	48 b9       	lddpc	r9,80004934 <xnl_device_conn_reply_func+0x5c>
8000490a:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
8000490c:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004910:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004912:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004916:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004918:	30 18       	mov	r8,1
8000491a:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
8000491c:	48 7c       	lddpc	r12,80004938 <xnl_device_conn_reply_func+0x60>
8000491e:	f0 1f 00 08 	mcall	8000493c <xnl_device_conn_reply_func+0x64>
80004922:	e3 cd 80 80 	ldm	sp++,r7,pc
80004926:	00 00       	add	r0,r0
80004928:	00 00       	add	r0,r0
8000492a:	0b 3c       	ld.ub	r12,r5++
8000492c:	80 00       	ld.sh	r0,r0[0x0]
8000492e:	58 20       	cp.w	r0,2
80004930:	80 00       	ld.sh	r0,r0[0x0]
80004932:	48 78       	lddpc	r8,8000494c <local_start_pll0+0xc>
80004934:	00 00       	add	r0,r0
80004936:	0b 40       	ld.w	r0,--r5
80004938:	80 00       	ld.sh	r0,r0[0x0]
8000493a:	d1 a8       	*unknown*
8000493c:	80 00       	ld.sh	r0,r0[0x0]
8000493e:	64 10       	ld.w	r0,r2[0x4]

80004940 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004940:	fe 78 0c 00 	mov	r8,-62464
80004944:	e0 69 03 07 	mov	r9,775
80004948:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
8000494a:	30 49       	mov	r9,4
8000494c:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
8000494e:	71 59       	ld.w	r9,r8[0x54]
80004950:	e2 19 00 80 	andl	r9,0x80,COH
80004954:	cf d0       	breq	8000494e <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80004956:	fe 78 0c 00 	mov	r8,-62464
8000495a:	30 59       	mov	r9,5
8000495c:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
8000495e:	e0 69 01 0d 	mov	r9,269
80004962:	ea 19 10 07 	orh	r9,0x1007
80004966:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004968:	71 59       	ld.w	r9,r8[0x54]
8000496a:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000496e:	cf d0       	breq	80004968 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004970:	fe 78 0c 00 	mov	r8,-62464
80004974:	fc 19 00 80 	movh	r9,0x80
80004978:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
8000497a:	34 0a       	mov	r10,64
8000497c:	fe 69 14 00 	mov	r9,-125952
80004980:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80004982:	30 69       	mov	r9,6
80004984:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80004986:	30 19       	mov	r9,1
80004988:	fe 68 10 00 	mov	r8,-126976
8000498c:	91 19       	st.w	r8[0x4],r9
}
8000498e:	5e fc       	retal	r12

80004990 <rtc_init>:
    PCF8563_init
Called By: ..
Return:rtc_err_t
*/
rtc_err_t rtc_init(void)
{
80004990:	eb cd 40 c0 	pushm	r6-r7,lr
80004994:	20 3d       	sub	sp,12
	/* Create the mutex semaphore to guard a shared RTC(TWI).*/	
	rtc_mutex = xSemaphoreCreateMutex();
80004996:	f0 1f 00 1a 	mcall	800049fc <rtc_init+0x6c>
8000499a:	49 a8       	lddpc	r8,80004a00 <rtc_init+0x70>
8000499c:	91 0c       	st.w	r8[0x0],r12
	
	if(NULL != rtc_mutex)
8000499e:	70 08       	ld.w	r8,r8[0x0]
800049a0:	58 08       	cp.w	r8,0
800049a2:	c0 31       	brne	800049a8 <rtc_init+0x18>
800049a4:	30 3c       	mov	r12,3
800049a6:	c2 78       	rjmp	800049f4 <rtc_init+0x64>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
800049a8:	49 66       	lddpc	r6,80004a00 <rtc_init+0x70>
800049aa:	6c 0c       	ld.w	r12,r6[0x0]
800049ac:	30 09       	mov	r9,0
800049ae:	3f fa       	mov	r10,-1
800049b0:	12 9b       	mov	r11,r9
800049b2:	f0 1f 00 15 	mcall	80004a04 <rtc_init+0x74>
	
	/*twi_package_t packet, packet_received*/
	static int status;

	/*TWI gpio pins configuration*/	
	gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
800049b6:	30 2b       	mov	r11,2
800049b8:	49 4c       	lddpc	r12,80004a08 <rtc_init+0x78>
800049ba:	f0 1f 00 15 	mcall	80004a0c <rtc_init+0x7c>
	
	/* options settings*/
	opt.pba_hz = RTC_PBACLK_FREQ_HZ;//FOSC0;24Mhz
800049be:	e0 68 36 00 	mov	r8,13824
800049c2:	ea 18 01 6e 	orh	r8,0x16e
800049c6:	50 08       	stdsp	sp[0x0],r8
	opt.speed  = TWI_SPEED;//200Khz
800049c8:	e2 78 0d 40 	mov	r8,200000
800049cc:	50 18       	stdsp	sp[0x4],r8
	opt.chip   = PCF8563_ADDRESS;
800049ce:	35 18       	mov	r8,81
800049d0:	fb 68 00 08 	st.b	sp[8],r8

	/*initialize TWI driver with options*/
	status = twi_master_init(&AVR32_TWI, &opt);
800049d4:	1a 9b       	mov	r11,sp
800049d6:	fe 7c 2c 00 	mov	r12,-54272
800049da:	f0 1f 00 0e 	mcall	80004a10 <rtc_init+0x80>
800049de:	48 e7       	lddpc	r7,80004a14 <rtc_init+0x84>
800049e0:	8f 0c       	st.w	r7[0x0],r12
	
	/*finished accessing the shared resource.Release the semaphore.*/
	xSemaphoreGive(rtc_mutex);		
800049e2:	6c 0c       	ld.w	r12,r6[0x0]
800049e4:	30 09       	mov	r9,0
800049e6:	12 9a       	mov	r10,r9
800049e8:	12 9b       	mov	r11,r9
800049ea:	f0 1f 00 0c 	mcall	80004a18 <rtc_init+0x88>
800049ee:	6e 08       	ld.w	r8,r7[0x0]
800049f0:	58 08       	cp.w	r8,0
800049f2:	5f 1c       	srne	r12
	{
		return rtc_success;
	}
		
	return rtc_init_err;
}
800049f4:	2f dd       	sub	sp,-12
800049f6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049fa:	00 00       	add	r0,r0
800049fc:	80 00       	ld.sh	r0,r0[0x0]
800049fe:	59 20       	cp.w	r0,18
80004a00:	00 00       	add	r0,r0
80004a02:	0b 68       	ld.uh	r8,--r5
80004a04:	80 00       	ld.sh	r0,r0[0x0]
80004a06:	56 14       	stdsp	sp[0x184],r4
80004a08:	80 00       	ld.sh	r0,r0[0x0]
80004a0a:	d1 bc       	*unknown*
80004a0c:	80 00       	ld.sh	r0,r0[0x0]
80004a0e:	68 a8       	ld.w	r8,r4[0x28]
80004a10:	80 00       	ld.sh	r0,r0[0x0]
80004a12:	4e a0       	lddpc	r0,80004bb8 <_get_interrupt_handler+0x8>
80004a14:	00 00       	add	r0,r0
80004a16:	0b 64       	ld.uh	r4,--r5
80004a18:	80 00       	ld.sh	r0,r0[0x0]
80004a1a:	58 20       	cp.w	r0,2

80004a1c <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80004a1c:	fe 78 10 00 	mov	r8,-61440
80004a20:	fc 19 00 10 	movh	r9,0x10
80004a24:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80004a26:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80004a28:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80004a2a:	30 39       	mov	r9,3
80004a2c:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80004a30:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80004a34:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80004a38:	fe 78 38 00 	mov	r8,-51200
80004a3c:	30 49       	mov	r9,4
80004a3e:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80004a42:	e0 69 91 0d 	mov	r9,37133
80004a46:	ea 19 00 52 	orh	r9,0x52
80004a4a:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80004a4c:	32 09       	mov	r9,32
80004a4e:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004a50:	30 59       	mov	r9,5
80004a52:	91 09       	st.w	r8[0x0],r9
}
80004a54:	5e fc       	retal	r12
80004a56:	d7 03       	nop

80004a58 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80004a58:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
80004a5a:	30 2a       	mov	r10,2
80004a5c:	e0 6b 01 c1 	mov	r11,449
80004a60:	48 ec       	lddpc	r12,80004a98 <tc_init+0x40>
80004a62:	f0 1f 00 0f 	mcall	80004a9c <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
80004a66:	48 fb       	lddpc	r11,80004aa0 <tc_init+0x48>
80004a68:	fe 7c 38 00 	mov	r12,-51200
80004a6c:	f0 1f 00 0e 	mcall	80004aa4 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80004a70:	e0 6a 75 30 	mov	r10,30000
80004a74:	30 1b       	mov	r11,1
80004a76:	fe 7c 38 00 	mov	r12,-51200
80004a7a:	f0 1f 00 0c 	mcall	80004aa8 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80004a7e:	48 ca       	lddpc	r10,80004aac <tc_init+0x54>
80004a80:	30 1b       	mov	r11,1
80004a82:	fe 7c 38 00 	mov	r12,-51200
80004a86:	f0 1f 00 0b 	mcall	80004ab0 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
80004a8a:	30 1b       	mov	r11,1
80004a8c:	fe 7c 38 00 	mov	r12,-51200
80004a90:	f0 1f 00 09 	mcall	80004ab4 <tc_init+0x5c>
80004a94:	d8 02       	popm	pc
80004a96:	00 00       	add	r0,r0
80004a98:	80 00       	ld.sh	r0,r0[0x0]
80004a9a:	4a b8       	lddpc	r8,80004b44 <INTC_register_interrupt+0x68>
80004a9c:	80 00       	ld.sh	r0,r0[0x0]
80004a9e:	4a dc       	lddpc	r12,80004b50 <INTC_register_interrupt+0x74>
80004aa0:	80 00       	ld.sh	r0,r0[0x0]
80004aa2:	d1 d0       	acall	0x1d
80004aa4:	80 00       	ld.sh	r0,r0[0x0]
80004aa6:	4b e8       	lddpc	r8,80004b9c <INTC_init_interrupts+0x40>
80004aa8:	80 00       	ld.sh	r0,r0[0x0]
80004aaa:	4c a8       	lddpc	r8,80004bd0 <_get_interrupt_handler+0x20>
80004aac:	80 00       	ld.sh	r0,r0[0x0]
80004aae:	d1 cc       	*unknown*
80004ab0:	80 00       	ld.sh	r0,r0[0x0]
80004ab2:	4c dc       	lddpc	r12,80004be4 <_get_interrupt_handler+0x34>
80004ab4:	80 00       	ld.sh	r0,r0[0x0]
80004ab6:	4c 84       	lddpc	r4,80004bd4 <_get_interrupt_handler+0x24>

80004ab8 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80004ab8:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
80004aba:	48 68       	lddpc	r8,80004ad0 <_tc_interrupt+0x18>
80004abc:	70 09       	ld.w	r9,r8[0x0]
80004abe:	2f f9       	sub	r9,-1
80004ac0:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80004ac2:	30 1b       	mov	r11,1
80004ac4:	fe 7c 38 00 	mov	r12,-51200
80004ac8:	f0 1f 00 03 	mcall	80004ad4 <_tc_interrupt+0x1c>
	
}
80004acc:	d4 02       	popm	lr
80004ace:	d6 03       	rete
80004ad0:	00 00       	add	r0,r0
80004ad2:	0b 6c       	ld.uh	r12,--r5
80004ad4:	80 00       	ld.sh	r0,r0[0x0]
80004ad6:	4c 96       	lddpc	r6,80004bf8 <tc_init_waveform+0x10>

80004ad8 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004ad8:	c0 08       	rjmp	80004ad8 <_unhandled_interrupt>
80004ada:	d7 03       	nop

80004adc <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004adc:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004ae0:	49 99       	lddpc	r9,80004b44 <INTC_register_interrupt+0x68>
80004ae2:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004ae6:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80004aea:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004aec:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004af0:	58 0a       	cp.w	r10,0
80004af2:	c0 91       	brne	80004b04 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004af4:	49 59       	lddpc	r9,80004b48 <INTC_register_interrupt+0x6c>
80004af6:	49 6a       	lddpc	r10,80004b4c <INTC_register_interrupt+0x70>
80004af8:	12 1a       	sub	r10,r9
80004afa:	fe 79 08 00 	mov	r9,-63488
80004afe:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004b02:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004b04:	58 1a       	cp.w	r10,1
80004b06:	c0 a1       	brne	80004b1a <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004b08:	49 09       	lddpc	r9,80004b48 <INTC_register_interrupt+0x6c>
80004b0a:	49 2a       	lddpc	r10,80004b50 <INTC_register_interrupt+0x74>
80004b0c:	12 1a       	sub	r10,r9
80004b0e:	bf aa       	sbr	r10,0x1e
80004b10:	fe 79 08 00 	mov	r9,-63488
80004b14:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004b18:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80004b1a:	58 2a       	cp.w	r10,2
80004b1c:	c0 a1       	brne	80004b30 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004b1e:	48 b9       	lddpc	r9,80004b48 <INTC_register_interrupt+0x6c>
80004b20:	48 da       	lddpc	r10,80004b54 <INTC_register_interrupt+0x78>
80004b22:	12 1a       	sub	r10,r9
80004b24:	bf ba       	sbr	r10,0x1f
80004b26:	fe 79 08 00 	mov	r9,-63488
80004b2a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004b2e:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004b30:	48 69       	lddpc	r9,80004b48 <INTC_register_interrupt+0x6c>
80004b32:	48 aa       	lddpc	r10,80004b58 <INTC_register_interrupt+0x7c>
80004b34:	12 1a       	sub	r10,r9
80004b36:	ea 1a c0 00 	orh	r10,0xc000
80004b3a:	fe 79 08 00 	mov	r9,-63488
80004b3e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004b42:	5e fc       	retal	r12
80004b44:	80 00       	ld.sh	r0,r0[0x0]
80004b46:	d1 d8       	*unknown*
80004b48:	80 00       	ld.sh	r0,r0[0x0]
80004b4a:	c2 00       	breq	80004b8a <INTC_init_interrupts+0x2e>
80004b4c:	80 00       	ld.sh	r0,r0[0x0]
80004b4e:	c3 04       	brge	80004bae <INTC_init_interrupts+0x52>
80004b50:	80 00       	ld.sh	r0,r0[0x0]
80004b52:	c3 12       	brcc	80004bb4 <_get_interrupt_handler+0x4>
80004b54:	80 00       	ld.sh	r0,r0[0x0]
80004b56:	c3 20       	breq	80004bba <_get_interrupt_handler+0xa>
80004b58:	80 00       	ld.sh	r0,r0[0x0]
80004b5a:	c3 2e       	rcall	800047be <xnl_device_auth_reply_func+0x66>

80004b5c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004b5c:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004b5e:	49 18       	lddpc	r8,80004ba0 <INTC_init_interrupts+0x44>
80004b60:	e3 b8 00 01 	mtsr	0x4,r8
80004b64:	49 0e       	lddpc	lr,80004ba4 <INTC_init_interrupts+0x48>
80004b66:	30 07       	mov	r7,0
80004b68:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004b6a:	49 0c       	lddpc	r12,80004ba8 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004b6c:	49 05       	lddpc	r5,80004bac <INTC_init_interrupts+0x50>
80004b6e:	10 15       	sub	r5,r8
80004b70:	fe 76 08 00 	mov	r6,-63488
80004b74:	c1 08       	rjmp	80004b94 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004b76:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80004b78:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004b7a:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004b7c:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004b80:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004b82:	10 3a       	cp.w	r10,r8
80004b84:	fe 9b ff fc 	brhi	80004b7c <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004b88:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004b8c:	2f f7       	sub	r7,-1
80004b8e:	2f 8e       	sub	lr,-8
80004b90:	59 37       	cp.w	r7,19
80004b92:	c0 50       	breq	80004b9c <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004b94:	7c 08       	ld.w	r8,lr[0x0]
80004b96:	58 08       	cp.w	r8,0
80004b98:	ce f1       	brne	80004b76 <INTC_init_interrupts+0x1a>
80004b9a:	cf 7b       	rjmp	80004b88 <INTC_init_interrupts+0x2c>
80004b9c:	d8 22       	popm	r4-r7,pc
80004b9e:	00 00       	add	r0,r0
80004ba0:	80 00       	ld.sh	r0,r0[0x0]
80004ba2:	c2 00       	breq	80004be2 <_get_interrupt_handler+0x32>
80004ba4:	80 00       	ld.sh	r0,r0[0x0]
80004ba6:	d1 d8       	*unknown*
80004ba8:	80 00       	ld.sh	r0,r0[0x0]
80004baa:	4a d8       	lddpc	r8,80004c5c <tc_init_waveform+0x74>
80004bac:	80 00       	ld.sh	r0,r0[0x0]
80004bae:	c3 04       	brge	80004c0e <tc_init_waveform+0x26>

80004bb0 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004bb0:	fe 78 08 00 	mov	r8,-63488
80004bb4:	e0 69 00 83 	mov	r9,131
80004bb8:	f2 0c 01 0c 	sub	r12,r9,r12
80004bbc:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004bc0:	f2 ca ff c0 	sub	r10,r9,-64
80004bc4:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004bc8:	58 08       	cp.w	r8,0
80004bca:	c0 21       	brne	80004bce <_get_interrupt_handler+0x1e>
80004bcc:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004bce:	f0 08 12 00 	clz	r8,r8
80004bd2:	48 5a       	lddpc	r10,80004be4 <_get_interrupt_handler+0x34>
80004bd4:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004bd8:	f0 08 11 1f 	rsub	r8,r8,31
80004bdc:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004bde:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004be2:	5e fc       	retal	r12
80004be4:	80 00       	ld.sh	r0,r0[0x0]
80004be6:	d1 d8       	*unknown*

80004be8 <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80004be8:	76 09       	ld.w	r9,r11[0x0]
80004bea:	58 29       	cp.w	r9,2
80004bec:	e0 88 00 03 	brls	80004bf2 <tc_init_waveform+0xa>
80004bf0:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80004bf2:	76 18       	ld.w	r8,r11[0x4]
80004bf4:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80004bf8:	af ba       	sbr	r10,0xf
80004bfa:	10 9b       	mov	r11,r8
80004bfc:	e6 1b c0 00 	andh	r11,0xc000,COH
80004c00:	16 4a       	or	r10,r11
80004c02:	10 9b       	mov	r11,r8
80004c04:	e6 1b 30 00 	andh	r11,0x3000,COH
80004c08:	16 4a       	or	r10,r11
80004c0a:	10 9b       	mov	r11,r8
80004c0c:	e6 1b 0c 00 	andh	r11,0xc00,COH
80004c10:	16 4a       	or	r10,r11
80004c12:	10 9b       	mov	r11,r8
80004c14:	e6 1b 03 00 	andh	r11,0x300,COH
80004c18:	16 4a       	or	r10,r11
80004c1a:	10 9b       	mov	r11,r8
80004c1c:	e6 1b 00 c0 	andh	r11,0xc0,COH
80004c20:	16 4a       	or	r10,r11
80004c22:	10 9b       	mov	r11,r8
80004c24:	e6 1b 00 30 	andh	r11,0x30,COH
80004c28:	16 4a       	or	r10,r11
80004c2a:	10 9b       	mov	r11,r8
80004c2c:	e6 1b 00 0c 	andh	r11,0xc,COH
80004c30:	16 4a       	or	r10,r11
80004c32:	10 9b       	mov	r11,r8
80004c34:	e6 1b 00 03 	andh	r11,0x3,COH
80004c38:	16 4a       	or	r10,r11
80004c3a:	10 9b       	mov	r11,r8
80004c3c:	e2 1b 60 00 	andl	r11,0x6000,COH
80004c40:	16 4a       	or	r10,r11
80004c42:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80004c46:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80004c4a:	10 9b       	mov	r11,r8
80004c4c:	e2 1b 0c 00 	andl	r11,0xc00,COH
80004c50:	16 4a       	or	r10,r11
80004c52:	10 9b       	mov	r11,r8
80004c54:	e2 1b 03 00 	andl	r11,0x300,COH
80004c58:	16 4a       	or	r10,r11
80004c5a:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80004c5e:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
80004c62:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80004c66:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80004c6a:	10 9b       	mov	r11,r8
80004c6c:	e2 1b 00 30 	andl	r11,0x30,COH
80004c70:	16 4a       	or	r10,r11
80004c72:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80004c76:	f5 e8 10 38 	or	r8,r10,r8<<0x3
80004c7a:	a5 69       	lsl	r9,0x4
80004c7c:	2f f9       	sub	r9,-1
80004c7e:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80004c82:	5e fd       	retal	0

80004c84 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004c84:	58 2b       	cp.w	r11,2
80004c86:	e0 88 00 03 	brls	80004c8c <tc_start+0x8>
80004c8a:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004c8c:	a7 6b       	lsl	r11,0x6
80004c8e:	16 0c       	add	r12,r11
80004c90:	30 58       	mov	r8,5
80004c92:	99 08       	st.w	r12[0x0],r8
80004c94:	5e fd       	retal	0

80004c96 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004c96:	58 2b       	cp.w	r11,2
80004c98:	e0 88 00 03 	brls	80004c9e <tc_read_sr+0x8>
80004c9c:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80004c9e:	a7 6b       	lsl	r11,0x6
80004ca0:	2e 0b       	sub	r11,-32
80004ca2:	16 0c       	add	r12,r11
80004ca4:	78 0c       	ld.w	r12,r12[0x0]
}
80004ca6:	5e fc       	retal	r12

80004ca8 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004ca8:	58 2b       	cp.w	r11,2
80004caa:	e0 88 00 03 	brls	80004cb0 <tc_write_rc+0x8>
80004cae:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80004cb0:	f6 08 15 04 	lsl	r8,r11,0x4
80004cb4:	2f f8       	sub	r8,-1
80004cb6:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80004cba:	e2 18 80 00 	andl	r8,0x8000,COH
80004cbe:	c0 c0       	breq	80004cd6 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80004cc0:	a7 6b       	lsl	r11,0x6
80004cc2:	16 0c       	add	r12,r11
80004cc4:	2e 4c       	sub	r12,-28
80004cc6:	78 08       	ld.w	r8,r12[0x0]
80004cc8:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004ccc:	e0 18 00 00 	andl	r8,0x0
80004cd0:	f3 e8 10 08 	or	r8,r9,r8
80004cd4:	99 08       	st.w	r12[0x0],r8

  return value;
80004cd6:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80004cda:	5e fc       	retal	r12

80004cdc <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80004cdc:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80004ce0:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004ce4:	58 2b       	cp.w	r11,2
80004ce6:	e0 88 00 04 	brls	80004cee <tc_configure_interrupts+0x12>
80004cea:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80004cee:	ee 19 00 01 	eorh	r9,0x1
80004cf2:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80004cf6:	74 08       	ld.w	r8,r10[0x0]
80004cf8:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80004cfc:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80004d00:	a7 6e       	lsl	lr,0x6
80004d02:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80004d06:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80004d0a:	0e 4e       	or	lr,r7
80004d0c:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80004d10:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80004d14:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80004d18:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80004d1c:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80004d20:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80004d24:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80004d28:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80004d2c:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004d30:	fd e8 10 18 	or	r8,lr,r8<<0x1
80004d34:	f6 0e 15 06 	lsl	lr,r11,0x6
80004d38:	f8 0e 00 0e 	add	lr,r12,lr
80004d3c:	2d ce       	sub	lr,-36
80004d3e:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80004d40:	58 09       	cp.w	r9,0
80004d42:	c0 20       	breq	80004d46 <tc_configure_interrupts+0x6a>
80004d44:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004d46:	74 08       	ld.w	r8,r10[0x0]
80004d48:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80004d4c:	e0 65 00 80 	mov	r5,128
80004d50:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80004d54:	74 08       	ld.w	r8,r10[0x0]
80004d56:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80004d5a:	f9 b4 00 40 	moveq	r4,64
80004d5e:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80004d62:	74 08       	ld.w	r8,r10[0x0]
80004d64:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80004d68:	f9 b3 00 20 	moveq	r3,32
80004d6c:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80004d70:	74 08       	ld.w	r8,r10[0x0]
80004d72:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80004d76:	f9 b2 00 10 	moveq	r2,16
80004d7a:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80004d7e:	74 08       	ld.w	r8,r10[0x0]
80004d80:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80004d84:	f9 b6 00 08 	moveq	r6,8
80004d88:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80004d8c:	74 08       	ld.w	r8,r10[0x0]
80004d8e:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80004d92:	f9 b7 00 04 	moveq	r7,4
80004d96:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80004d9a:	74 08       	ld.w	r8,r10[0x0]
80004d9c:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004da0:	f9 be 00 02 	moveq	lr,2
80004da4:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004da8:	74 08       	ld.w	r8,r10[0x0]
80004daa:	ec 18 00 01 	eorl	r8,0x1
80004dae:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004db2:	eb e8 10 08 	or	r8,r5,r8
80004db6:	08 48       	or	r8,r4
80004db8:	06 48       	or	r8,r3
80004dba:	04 48       	or	r8,r2
80004dbc:	0c 48       	or	r8,r6
80004dbe:	0e 48       	or	r8,r7
80004dc0:	1c 48       	or	r8,lr
80004dc2:	f6 0a 15 06 	lsl	r10,r11,0x6
80004dc6:	f8 0a 00 0a 	add	r10,r12,r10
80004dca:	2d 8a       	sub	r10,-40
80004dcc:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80004dce:	a7 6b       	lsl	r11,0x6
80004dd0:	2e 0b       	sub	r11,-32
80004dd2:	16 0c       	add	r12,r11
80004dd4:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80004dd6:	58 09       	cp.w	r9,0
80004dd8:	c0 31       	brne	80004dde <tc_configure_interrupts+0x102>
80004dda:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80004dde:	d5 03       	csrf	0x10
80004de0:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

80004de4 <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
80004de4:	4a 78       	lddpc	r8,80004e80 <twi_master_interrupt_handler+0x9c>
80004de6:	70 08       	ld.w	r8,r8[0x0]
80004de8:	70 89       	ld.w	r9,r8[0x20]
80004dea:	4a 7a       	lddpc	r10,80004e84 <twi_master_interrupt_handler+0xa0>
80004dec:	74 0a       	ld.w	r10,r10[0x0]
80004dee:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
80004df2:	12 9a       	mov	r10,r9
80004df4:	e2 1a 01 00 	andl	r10,0x100,COH
80004df8:	c3 91       	brne	80004e6a <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
80004dfa:	12 9a       	mov	r10,r9
80004dfc:	e2 1a 00 02 	andl	r10,0x2,COH
80004e00:	c1 70       	breq	80004e2e <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
80004e02:	4a 29       	lddpc	r9,80004e88 <twi_master_interrupt_handler+0xa4>
80004e04:	72 0a       	ld.w	r10,r9[0x0]
80004e06:	70 cb       	ld.w	r11,r8[0x30]
80004e08:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
80004e0a:	72 0a       	ld.w	r10,r9[0x0]
80004e0c:	2f fa       	sub	r10,-1
80004e0e:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
80004e10:	49 f9       	lddpc	r9,80004e8c <twi_master_interrupt_handler+0xa8>
80004e12:	72 0a       	ld.w	r10,r9[0x0]
80004e14:	20 1a       	sub	r10,1
80004e16:	93 0a       	st.w	r9[0x0],r10
80004e18:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
80004e1a:	58 19       	cp.w	r9,1
80004e1c:	f9 b9 00 02 	moveq	r9,2
80004e20:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
80004e24:	49 a9       	lddpc	r9,80004e8c <twi_master_interrupt_handler+0xa8>
80004e26:	72 09       	ld.w	r9,r9[0x0]
80004e28:	58 09       	cp.w	r9,0
80004e2a:	c2 30       	breq	80004e70 <twi_master_interrupt_handler+0x8c>
80004e2c:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
80004e2e:	12 9a       	mov	r10,r9
80004e30:	e2 1a 00 04 	andl	r10,0x4,COH
80004e34:	c1 70       	breq	80004e62 <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
80004e36:	49 79       	lddpc	r9,80004e90 <twi_master_interrupt_handler+0xac>
80004e38:	72 0a       	ld.w	r10,r9[0x0]
80004e3a:	20 1a       	sub	r10,1
80004e3c:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
80004e3e:	72 09       	ld.w	r9,r9[0x0]
80004e40:	58 09       	cp.w	r9,0
80004e42:	e0 89 00 0a 	brgt	80004e56 <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
80004e46:	49 09       	lddpc	r9,80004e84 <twi_master_interrupt_handler+0xa0>
80004e48:	30 1a       	mov	r10,1
80004e4a:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
80004e4c:	3f fa       	mov	r10,-1
80004e4e:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
80004e50:	72 09       	ld.w	r9,r9[0x0]
80004e52:	91 99       	st.w	r8[0x24],r9
80004e54:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
80004e56:	49 0a       	lddpc	r10,80004e94 <twi_master_interrupt_handler+0xb0>
80004e58:	74 09       	ld.w	r9,r10[0x0]
80004e5a:	13 3b       	ld.ub	r11,r9++
80004e5c:	91 db       	st.w	r8[0x34],r11
80004e5e:	95 09       	st.w	r10[0x0],r9
80004e60:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
80004e62:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004e66:	c0 51       	brne	80004e70 <twi_master_interrupt_handler+0x8c>
80004e68:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
80004e6a:	30 1a       	mov	r10,1
80004e6c:	48 b9       	lddpc	r9,80004e98 <twi_master_interrupt_handler+0xb4>
80004e6e:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
80004e70:	3f f9       	mov	r9,-1
80004e72:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
80004e74:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
80004e76:	30 09       	mov	r9,0
80004e78:	48 98       	lddpc	r8,80004e9c <twi_master_interrupt_handler+0xb8>
80004e7a:	b0 89       	st.b	r8[0x0],r9
80004e7c:	d6 03       	rete
80004e7e:	00 00       	add	r0,r0
80004e80:	00 00       	add	r0,r0
80004e82:	0c 24       	rsub	r4,r6
80004e84:	00 00       	add	r0,r0
80004e86:	0c 20       	rsub	r0,r6
80004e88:	00 00       	add	r0,r0
80004e8a:	0c 30       	cp.w	r0,r6
80004e8c:	00 00       	add	r0,r0
80004e8e:	0c 2c       	rsub	r12,r6
80004e90:	00 00       	add	r0,r0
80004e92:	0c 1c       	sub	r12,r6
80004e94:	00 00       	add	r0,r0
80004e96:	0c 28       	rsub	r8,r6
80004e98:	00 00       	add	r0,r0
80004e9a:	0c 19       	sub	r9,r6
80004e9c:	00 00       	add	r0,r0
80004e9e:	0c 18       	sub	r8,r6

80004ea0 <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
80004ea0:	eb cd 40 e0 	pushm	r5-r7,lr
80004ea4:	18 97       	mov	r7,r12
80004ea6:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
80004ea8:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
80004eac:	49 f9       	lddpc	r9,80004f28 <twi_master_init+0x88>
80004eae:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
80004eb0:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
80004eb2:	3f f9       	mov	r9,-1
80004eb4:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
80004eb6:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
80004eb8:	e0 69 00 80 	mov	r9,128
80004ebc:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004ebe:	e6 18 00 01 	andh	r8,0x1,COH
80004ec2:	c0 21       	brne	80004ec6 <twi_master_init+0x26>
      cpu_irq_enable();
80004ec4:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
80004ec6:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004ec8:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80004ecc:	d3 03       	ssrf	0x10
	
	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();

	irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL);
80004ece:	30 3a       	mov	r10,3
80004ed0:	e0 6b 01 60 	mov	r11,352
80004ed4:	49 6c       	lddpc	r12,80004f2c <twi_master_init+0x8c>
80004ed6:	f0 1f 00 17 	mcall	80004f30 <twi_master_init+0x90>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004eda:	e6 16 00 01 	andh	r6,0x1,COH
80004ede:	c0 21       	brne	80004ee2 <twi_master_init+0x42>
      cpu_irq_enable();
80004ee0:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
80004ee2:	6a 19       	ld.w	r9,r5[0x4]
80004ee4:	a1 79       	lsl	r9,0x1
80004ee6:	6a 08       	ld.w	r8,r5[0x0]
80004ee8:	f0 09 0d 08 	divu	r8,r8,r9
80004eec:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80004eee:	e0 48 00 ff 	cp.w	r8,255
80004ef2:	e0 8b 00 04 	brhi	80004efa <twi_master_init+0x5a>
80004ef6:	30 09       	mov	r9,0
80004ef8:	c0 f8       	rjmp	80004f16 <twi_master_init+0x76>
80004efa:	30 09       	mov	r9,0
80004efc:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
80004efe:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
80004f00:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80004f02:	e0 48 00 ff 	cp.w	r8,255
80004f06:	5f bb       	srhi	r11
80004f08:	58 69       	cp.w	r9,6
80004f0a:	5f 8a       	srls	r10
80004f0c:	f7 ea 00 0a 	and	r10,r11,r10
80004f10:	f8 0a 18 00 	cp.b	r10,r12
80004f14:	cf 51       	brne	80004efe <twi_master_init+0x5e>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
80004f16:	b1 69       	lsl	r9,0x10
80004f18:	f3 e8 10 89 	or	r9,r9,r8<<0x8
80004f1c:	f3 e8 10 08 	or	r8,r9,r8
80004f20:	8f 48       	st.w	r7[0x10],r8

	//Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
80004f22:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80004f26:	00 00       	add	r0,r0
80004f28:	00 00       	add	r0,r0
80004f2a:	0c 24       	rsub	r4,r6
80004f2c:	80 00       	ld.sh	r0,r0[0x0]
80004f2e:	4d e4       	lddpc	r4,800050a4 <usart_init_rs232+0x34>
80004f30:	80 00       	ld.sh	r0,r0[0x0]
80004f32:	4a dc       	lddpc	r12,80004fe4 <usart_read_char+0x14>

80004f34 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80004f34:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80004f36:	f6 08 15 04 	lsl	r8,r11,0x4
80004f3a:	14 38       	cp.w	r8,r10
80004f3c:	f9 b8 08 10 	movls	r8,16
80004f40:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80004f44:	f0 0b 02 4b 	mul	r11,r8,r11
80004f48:	f6 09 16 01 	lsr	r9,r11,0x1
80004f4c:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80004f50:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80004f54:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004f58:	f2 cb 00 01 	sub	r11,r9,1
80004f5c:	e0 4b ff fe 	cp.w	r11,65534
80004f60:	e0 88 00 03 	brls	80004f66 <usart_set_async_baudrate+0x32>
80004f64:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004f66:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004f68:	e8 6e 00 00 	mov	lr,524288
80004f6c:	59 08       	cp.w	r8,16
80004f6e:	fc 08 17 10 	movne	r8,lr
80004f72:	f9 b8 00 00 	moveq	r8,0
80004f76:	e4 1b ff f7 	andh	r11,0xfff7
80004f7a:	e0 1b fe cf 	andl	r11,0xfecf
80004f7e:	16 48       	or	r8,r11
80004f80:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80004f82:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80004f86:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80004f8a:	99 89       	st.w	r12[0x20],r9
80004f8c:	d8 0a       	popm	pc,r12=0

80004f8e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004f8e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80004f90:	e2 18 00 02 	andl	r8,0x2,COH
80004f94:	c0 31       	brne	80004f9a <usart_write_char+0xc>
80004f96:	30 2c       	mov	r12,2
80004f98:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004f9a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80004f9e:	99 7b       	st.w	r12[0x1c],r11
80004fa0:	5e fd       	retal	0
80004fa2:	d7 03       	nop

80004fa4 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004fa4:	eb cd 40 e0 	pushm	r5-r7,lr
80004fa8:	18 96       	mov	r6,r12
80004faa:	16 95       	mov	r5,r11
80004fac:	e0 67 27 0f 	mov	r7,9999
80004fb0:	c0 68       	rjmp	80004fbc <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80004fb2:	58 07       	cp.w	r7,0
80004fb4:	c0 31       	brne	80004fba <usart_putchar+0x16>
80004fb6:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80004fba:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004fbc:	0a 9b       	mov	r11,r5
80004fbe:	0c 9c       	mov	r12,r6
80004fc0:	f0 1f 00 03 	mcall	80004fcc <usart_putchar+0x28>
80004fc4:	cf 71       	brne	80004fb2 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80004fc6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004fca:	00 00       	add	r0,r0
80004fcc:	80 00       	ld.sh	r0,r0[0x0]
80004fce:	4f 8e       	lddpc	lr,800051ac <vListRemove+0x6>

80004fd0 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004fd0:	78 58       	ld.w	r8,r12[0x14]
80004fd2:	e2 18 00 e0 	andl	r8,0xe0,COH
80004fd6:	c0 30       	breq	80004fdc <usart_read_char+0xc>
80004fd8:	30 4c       	mov	r12,4
80004fda:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004fdc:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004fde:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004fe2:	c0 31       	brne	80004fe8 <usart_read_char+0x18>
80004fe4:	30 3c       	mov	r12,3
80004fe6:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004fe8:	78 68       	ld.w	r8,r12[0x18]
80004fea:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80004fee:	97 08       	st.w	r11[0x0],r8
80004ff0:	5e fd       	retal	0
80004ff2:	d7 03       	nop

80004ff4 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80004ff4:	eb cd 40 c0 	pushm	r6-r7,lr
80004ff8:	20 1d       	sub	sp,4
80004ffa:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004ffc:	1a 97       	mov	r7,sp
80004ffe:	1a 9b       	mov	r11,sp
80005000:	0c 9c       	mov	r12,r6
80005002:	f0 1f 00 07 	mcall	8000501c <usart_getchar+0x28>
80005006:	58 3c       	cp.w	r12,3
80005008:	cf b0       	breq	80004ffe <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
8000500a:	58 4c       	cp.w	r12,4
8000500c:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005010:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005014:	2f fd       	sub	sp,-4
80005016:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000501a:	00 00       	add	r0,r0
8000501c:	80 00       	ld.sh	r0,r0[0x0]
8000501e:	4f d0       	lddpc	r0,80005210 <pxPortInitialiseStack+0x44>

80005020 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005020:	eb cd 40 c0 	pushm	r6-r7,lr
80005024:	18 96       	mov	r6,r12
80005026:	16 97       	mov	r7,r11
  while (*string != '\0')
80005028:	17 8b       	ld.ub	r11,r11[0x0]
8000502a:	58 0b       	cp.w	r11,0
8000502c:	c0 80       	breq	8000503c <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
8000502e:	2f f7       	sub	r7,-1
80005030:	0c 9c       	mov	r12,r6
80005032:	f0 1f 00 04 	mcall	80005040 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005036:	0f 8b       	ld.ub	r11,r7[0x0]
80005038:	58 0b       	cp.w	r11,0
8000503a:	cf a1       	brne	8000502e <usart_write_line+0xe>
8000503c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005040:	80 00       	ld.sh	r0,r0[0x0]
80005042:	4f a4       	lddpc	r4,80005228 <pxPortInitialiseStack+0x5c>

80005044 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005044:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005048:	e6 18 00 01 	andh	r8,0x1,COH
8000504c:	c0 71       	brne	8000505a <usart_reset+0x16>
8000504e:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005050:	3f f8       	mov	r8,-1
80005052:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005054:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005056:	d5 03       	csrf	0x10
80005058:	c0 48       	rjmp	80005060 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
8000505a:	3f f8       	mov	r8,-1
8000505c:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000505e:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005060:	30 08       	mov	r8,0
80005062:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005064:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005066:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005068:	ea 68 61 0c 	mov	r8,680204
8000506c:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
8000506e:	5e fc       	retal	r12

80005070 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005070:	eb cd 40 e0 	pushm	r5-r7,lr
80005074:	18 96       	mov	r6,r12
80005076:	16 97       	mov	r7,r11
80005078:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000507a:	f0 1f 00 2f 	mcall	80005134 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
8000507e:	58 07       	cp.w	r7,0
80005080:	c5 80       	breq	80005130 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005082:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005084:	30 49       	mov	r9,4
80005086:	f2 08 18 00 	cp.b	r8,r9
8000508a:	e0 88 00 53 	brls	80005130 <usart_init_rs232+0xc0>
8000508e:	30 99       	mov	r9,9
80005090:	f2 08 18 00 	cp.b	r8,r9
80005094:	e0 8b 00 4e 	brhi	80005130 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005098:	0f d9       	ld.ub	r9,r7[0x5]
8000509a:	30 78       	mov	r8,7
8000509c:	f0 09 18 00 	cp.b	r9,r8
800050a0:	e0 8b 00 48 	brhi	80005130 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
800050a4:	8e 39       	ld.sh	r9,r7[0x6]
800050a6:	e0 68 01 01 	mov	r8,257
800050aa:	f0 09 19 00 	cp.h	r9,r8
800050ae:	e0 8b 00 41 	brhi	80005130 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
800050b2:	ef 39 00 08 	ld.ub	r9,r7[8]
800050b6:	30 38       	mov	r8,3
800050b8:	f0 09 18 00 	cp.b	r9,r8
800050bc:	e0 8b 00 3a 	brhi	80005130 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
800050c0:	0a 9a       	mov	r10,r5
800050c2:	6e 0b       	ld.w	r11,r7[0x0]
800050c4:	0c 9c       	mov	r12,r6
800050c6:	f0 1f 00 1d 	mcall	80005138 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800050ca:	58 1c       	cp.w	r12,1
800050cc:	c3 20       	breq	80005130 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
800050ce:	0f c8       	ld.ub	r8,r7[0x4]
800050d0:	30 99       	mov	r9,9
800050d2:	f2 08 18 00 	cp.b	r8,r9
800050d6:	c0 51       	brne	800050e0 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800050d8:	6c 18       	ld.w	r8,r6[0x4]
800050da:	b1 b8       	sbr	r8,0x11
800050dc:	8d 18       	st.w	r6[0x4],r8
800050de:	c0 68       	rjmp	800050ea <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800050e0:	6c 19       	ld.w	r9,r6[0x4]
800050e2:	20 58       	sub	r8,5
800050e4:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800050e8:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800050ea:	6c 19       	ld.w	r9,r6[0x4]
800050ec:	ef 3a 00 08 	ld.ub	r10,r7[8]
800050f0:	0f d8       	ld.ub	r8,r7[0x5]
800050f2:	a9 78       	lsl	r8,0x9
800050f4:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800050f8:	12 48       	or	r8,r9
800050fa:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800050fc:	8e 38       	ld.sh	r8,r7[0x6]
800050fe:	30 29       	mov	r9,2
80005100:	f2 08 19 00 	cp.h	r8,r9
80005104:	e0 88 00 09 	brls	80005116 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005108:	6c 18       	ld.w	r8,r6[0x4]
8000510a:	ad b8       	sbr	r8,0xd
8000510c:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
8000510e:	8e b8       	ld.uh	r8,r7[0x6]
80005110:	20 28       	sub	r8,2
80005112:	8d a8       	st.w	r6[0x28],r8
80005114:	c0 68       	rjmp	80005120 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005116:	6c 19       	ld.w	r9,r6[0x4]
80005118:	5c 78       	castu.h	r8
8000511a:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
8000511e:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005120:	6c 18       	ld.w	r8,r6[0x4]
80005122:	e0 18 ff f0 	andl	r8,0xfff0
80005126:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005128:	35 08       	mov	r8,80
8000512a:	8d 08       	st.w	r6[0x0],r8
8000512c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005130:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005134:	80 00       	ld.sh	r0,r0[0x0]
80005136:	50 44       	stdsp	sp[0x10],r4
80005138:	80 00       	ld.sh	r0,r0[0x0]
8000513a:	4f 34       	lddpc	r4,80005304 <SCALLYield+0x3c>

8000513c <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
8000513c:	f8 c8 ff f8 	sub	r8,r12,-8
80005140:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005142:	3f f9       	mov	r9,-1
80005144:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005146:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005148:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
8000514a:	30 08       	mov	r8,0
8000514c:	99 08       	st.w	r12[0x0],r8
}
8000514e:	5e fc       	retal	r12

80005150 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005150:	30 08       	mov	r8,0
80005152:	99 48       	st.w	r12[0x10],r8
}
80005154:	5e fc       	retal	r12

80005156 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005156:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005158:	70 19       	ld.w	r9,r8[0x4]
8000515a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
8000515c:	78 19       	ld.w	r9,r12[0x4]
8000515e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005160:	70 19       	ld.w	r9,r8[0x4]
80005162:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005164:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005166:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005168:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000516a:	78 08       	ld.w	r8,r12[0x0]
8000516c:	2f f8       	sub	r8,-1
8000516e:	99 08       	st.w	r12[0x0],r8
}
80005170:	5e fc       	retal	r12

80005172 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005172:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005174:	5b fa       	cp.w	r10,-1
80005176:	c0 31       	brne	8000517c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005178:	78 48       	ld.w	r8,r12[0x10]
8000517a:	c0 c8       	rjmp	80005192 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
8000517c:	f8 c8 ff f8 	sub	r8,r12,-8
80005180:	70 19       	ld.w	r9,r8[0x4]
80005182:	72 09       	ld.w	r9,r9[0x0]
80005184:	12 3a       	cp.w	r10,r9
80005186:	c0 63       	brcs	80005192 <vListInsert+0x20>
80005188:	70 18       	ld.w	r8,r8[0x4]
8000518a:	70 19       	ld.w	r9,r8[0x4]
8000518c:	72 09       	ld.w	r9,r9[0x0]
8000518e:	12 3a       	cp.w	r10,r9
80005190:	cf c2       	brcc	80005188 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005192:	70 19       	ld.w	r9,r8[0x4]
80005194:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005196:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005198:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
8000519a:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
8000519c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000519e:	78 08       	ld.w	r8,r12[0x0]
800051a0:	2f f8       	sub	r8,-1
800051a2:	99 08       	st.w	r12[0x0],r8
}
800051a4:	5e fc       	retal	r12

800051a6 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
800051a6:	78 18       	ld.w	r8,r12[0x4]
800051a8:	78 29       	ld.w	r9,r12[0x8]
800051aa:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
800051ac:	78 28       	ld.w	r8,r12[0x8]
800051ae:	78 19       	ld.w	r9,r12[0x4]
800051b0:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
800051b2:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
800051b4:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
800051b6:	18 39       	cp.w	r9,r12
800051b8:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
800051bc:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
800051c0:	30 09       	mov	r9,0
800051c2:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
800051c4:	70 09       	ld.w	r9,r8[0x0]
800051c6:	20 19       	sub	r9,1
800051c8:	91 09       	st.w	r8[0x0],r9
}
800051ca:	5e fc       	retal	r12

800051cc <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
800051cc:	e0 68 08 08 	mov	r8,2056
800051d0:	ea 18 08 08 	orh	r8,0x808
800051d4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
800051d6:	e0 68 09 09 	mov	r8,2313
800051da:	ea 18 09 09 	orh	r8,0x909
800051de:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800051e0:	e0 68 0a 0a 	mov	r8,2570
800051e4:	ea 18 0a 0a 	orh	r8,0xa0a
800051e8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800051ea:	e0 68 0b 0b 	mov	r8,2827
800051ee:	ea 18 0b 0b 	orh	r8,0xb0b
800051f2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800051f4:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
800051f6:	e0 68 be ef 	mov	r8,48879
800051fa:	ea 18 de ad 	orh	r8,0xdead
800051fe:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005200:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005202:	fc 18 00 40 	movh	r8,0x40
80005206:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005208:	e0 68 00 ff 	mov	r8,255
8000520c:	ea 18 ff 00 	orh	r8,0xff00
80005210:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005212:	e0 68 01 01 	mov	r8,257
80005216:	ea 18 01 01 	orh	r8,0x101
8000521a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
8000521c:	e0 68 02 02 	mov	r8,514
80005220:	ea 18 02 02 	orh	r8,0x202
80005224:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005226:	e0 68 03 03 	mov	r8,771
8000522a:	ea 18 03 03 	orh	r8,0x303
8000522e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005230:	e0 68 04 04 	mov	r8,1028
80005234:	ea 18 04 04 	orh	r8,0x404
80005238:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
8000523a:	e0 68 05 05 	mov	r8,1285
8000523e:	ea 18 05 05 	orh	r8,0x505
80005242:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005244:	e0 68 06 06 	mov	r8,1542
80005248:	ea 18 06 06 	orh	r8,0x606
8000524c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
8000524e:	e0 68 07 07 	mov	r8,1799
80005252:	ea 18 07 07 	orh	r8,0x707
80005256:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005258:	30 08       	mov	r8,0
8000525a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
8000525c:	5e fc       	retal	r12
8000525e:	d7 03       	nop

80005260 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005260:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005262:	48 38       	lddpc	r8,8000526c <vPortEnterCritical+0xc>
80005264:	70 09       	ld.w	r9,r8[0x0]
80005266:	2f f9       	sub	r9,-1
80005268:	91 09       	st.w	r8[0x0],r9
}
8000526a:	5e fc       	retal	r12
8000526c:	00 00       	add	r0,r0
8000526e:	05 30       	ld.ub	r0,r2++

80005270 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005270:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005272:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005274:	30 0a       	mov	r10,0
80005276:	14 9b       	mov	r11,r10
80005278:	49 2c       	lddpc	r12,800052c0 <xPortStartScheduler+0x50>
8000527a:	f0 1f 00 13 	mcall	800052c4 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
8000527e:	e0 68 5d c0 	mov	r8,24000
80005282:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005286:	30 08       	mov	r8,0
80005288:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000528c:	e0 68 0d 04 	mov	r8,3332
80005290:	ea 18 00 00 	orh	r8,0x0
80005294:	70 00       	ld.w	r0,r8[0x0]
80005296:	60 0d       	ld.w	sp,r0[0x0]
80005298:	1b 00       	ld.w	r0,sp++
8000529a:	e0 68 05 30 	mov	r8,1328
8000529e:	ea 18 00 00 	orh	r8,0x0
800052a2:	91 00       	st.w	r8[0x0],r0
800052a4:	e3 cd 00 ff 	ldm	sp++,r0-r7
800052a8:	2f ed       	sub	sp,-8
800052aa:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
800052ae:	fa f0 ff e0 	ld.w	r0,sp[-32]
800052b2:	e3 b0 00 00 	mtsr	0x0,r0
800052b6:	fa f0 ff dc 	ld.w	r0,sp[-36]
800052ba:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
800052be:	d8 0a       	popm	pc,r12=0
800052c0:	80 00       	ld.sh	r0,r0[0x0]
800052c2:	53 8c       	stdsp	sp[0xe0],r12
800052c4:	80 00       	ld.sh	r0,r0[0x0]
800052c6:	4a dc       	lddpc	r12,80005378 <vPortExitCritical+0xc>

800052c8 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
800052c8:	20 6d       	sub	sp,24
800052ca:	eb cd 00 ff 	pushm	r0-r7
800052ce:	fa c7 ff c0 	sub	r7,sp,-64
800052d2:	ee f0 ff f8 	ld.w	r0,r7[-8]
800052d6:	ef 40 ff e0 	st.w	r7[-32],r0
800052da:	ee f0 ff fc 	ld.w	r0,r7[-4]
800052de:	ef 40 ff e4 	st.w	r7[-28],r0
800052e2:	eb c7 5f 00 	stm	--r7,r8-r12,lr
800052e6:	e0 68 05 30 	mov	r8,1328
800052ea:	ea 18 00 00 	orh	r8,0x0
800052ee:	70 00       	ld.w	r0,r8[0x0]
800052f0:	1a d0       	st.w	--sp,r0
800052f2:	f0 1f 00 1a 	mcall	80005358 <LABEL_RET_SCALL_263+0x14>
800052f6:	e0 68 0d 04 	mov	r8,3332
800052fa:	ea 18 00 00 	orh	r8,0x0
800052fe:	70 00       	ld.w	r0,r8[0x0]
80005300:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005302:	f0 1f 00 17 	mcall	8000535c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005306:	e0 68 0d 04 	mov	r8,3332
8000530a:	ea 18 00 00 	orh	r8,0x0
8000530e:	70 00       	ld.w	r0,r8[0x0]
80005310:	60 0d       	ld.w	sp,r0[0x0]
80005312:	1b 00       	ld.w	r0,sp++
80005314:	e0 68 05 30 	mov	r8,1328
80005318:	ea 18 00 00 	orh	r8,0x0
8000531c:	91 00       	st.w	r8[0x0],r0
8000531e:	fa c7 ff d8 	sub	r7,sp,-40
80005322:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005326:	ee f0 ff e0 	ld.w	r0,r7[-32]
8000532a:	e0 61 05 30 	mov	r1,1328
8000532e:	ea 11 00 00 	orh	r1,0x0
80005332:	62 02       	ld.w	r2,r1[0x0]
80005334:	58 02       	cp.w	r2,0
80005336:	c0 70       	breq	80005344 <LABEL_RET_SCALL_263>
80005338:	e4 c2 00 01 	sub	r2,r2,1
8000533c:	83 02       	st.w	r1[0x0],r2
8000533e:	58 02       	cp.w	r2,0
80005340:	c0 21       	brne	80005344 <LABEL_RET_SCALL_263>
80005342:	b1 c0       	cbr	r0,0x10

80005344 <LABEL_RET_SCALL_263>:
80005344:	ef 40 ff f8 	st.w	r7[-8],r0
80005348:	ee f0 ff e4 	ld.w	r0,r7[-28]
8000534c:	ef 40 ff fc 	st.w	r7[-4],r0
80005350:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005354:	2f ad       	sub	sp,-24
80005356:	d6 13       	rets
80005358:	80 00       	ld.sh	r0,r0[0x0]
8000535a:	52 60       	stdsp	sp[0x98],r0
8000535c:	80 00       	ld.sh	r0,r0[0x0]
8000535e:	59 fc       	cp.w	r12,31

80005360 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005360:	e1 b8 00 43 	mfsr	r8,0x10c
80005364:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005368:	5e fc       	retal	r12
8000536a:	d7 03       	nop

8000536c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
8000536c:	48 78       	lddpc	r8,80005388 <vPortExitCritical+0x1c>
8000536e:	70 08       	ld.w	r8,r8[0x0]
80005370:	58 08       	cp.w	r8,0
80005372:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005374:	48 58       	lddpc	r8,80005388 <vPortExitCritical+0x1c>
80005376:	70 09       	ld.w	r9,r8[0x0]
80005378:	20 19       	sub	r9,1
8000537a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
8000537c:	70 08       	ld.w	r8,r8[0x0]
8000537e:	58 08       	cp.w	r8,0
80005380:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005382:	d5 03       	csrf	0x10
80005384:	5e fc       	retal	r12
80005386:	00 00       	add	r0,r0
80005388:	00 00       	add	r0,r0
8000538a:	05 30       	ld.ub	r0,r2++

8000538c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
8000538c:	eb cd 00 ff 	pushm	r0-r7
80005390:	e0 68 05 30 	mov	r8,1328
80005394:	ea 18 00 00 	orh	r8,0x0
80005398:	70 00       	ld.w	r0,r8[0x0]
8000539a:	1a d0       	st.w	--sp,r0
8000539c:	7a 90       	ld.w	r0,sp[0x24]
8000539e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800053a2:	58 10       	cp.w	r0,1
800053a4:	e0 8b 00 08 	brhi	800053b4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
800053a8:	e0 68 0d 04 	mov	r8,3332
800053ac:	ea 18 00 00 	orh	r8,0x0
800053b0:	70 00       	ld.w	r0,r8[0x0]
800053b2:	81 0d       	st.w	r0[0x0],sp

800053b4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
800053b4:	f0 1f 00 12 	mcall	800053fc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
800053b8:	f0 1f 00 12 	mcall	80005400 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
800053bc:	f0 1f 00 12 	mcall	80005404 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
800053c0:	f0 1f 00 12 	mcall	80005408 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
800053c4:	7a 90       	ld.w	r0,sp[0x24]
800053c6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800053ca:	58 10       	cp.w	r0,1
800053cc:	e0 8b 00 0e 	brhi	800053e8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
800053d0:	f0 1f 00 0c 	mcall	80005400 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
800053d4:	f0 1f 00 0e 	mcall	8000540c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
800053d8:	f0 1f 00 0c 	mcall	80005408 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
800053dc:	e0 68 0d 04 	mov	r8,3332
800053e0:	ea 18 00 00 	orh	r8,0x0
800053e4:	70 00       	ld.w	r0,r8[0x0]
800053e6:	60 0d       	ld.w	sp,r0[0x0]

800053e8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
800053e8:	1b 00       	ld.w	r0,sp++
800053ea:	e0 68 05 30 	mov	r8,1328
800053ee:	ea 18 00 00 	orh	r8,0x0
800053f2:	91 00       	st.w	r8[0x0],r0
800053f4:	e3 cd 00 ff 	ldm	sp++,r0-r7
800053f8:	d6 03       	rete
800053fa:	00 00       	add	r0,r0
800053fc:	80 00       	ld.sh	r0,r0[0x0]
800053fe:	53 60       	stdsp	sp[0xd8],r0
80005400:	80 00       	ld.sh	r0,r0[0x0]
80005402:	52 60       	stdsp	sp[0x98],r0
80005404:	80 00       	ld.sh	r0,r0[0x0]
80005406:	5c 00       	acr	r0
80005408:	80 00       	ld.sh	r0,r0[0x0]
8000540a:	53 6c       	stdsp	sp[0xd8],r12
8000540c:	80 00       	ld.sh	r0,r0[0x0]
8000540e:	59 fc       	cp.w	r12,31

80005410 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005410:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005412:	f0 1f 00 02 	mcall	80005418 <__malloc_lock+0x8>
}
80005416:	d8 02       	popm	pc
80005418:	80 00       	ld.sh	r0,r0[0x0]
8000541a:	59 ec       	cp.w	r12,30

8000541c <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
8000541c:	d4 01       	pushm	lr
	xTaskResumeAll();
8000541e:	f0 1f 00 02 	mcall	80005424 <__malloc_unlock+0x8>
}
80005422:	d8 02       	popm	pc
80005424:	80 00       	ld.sh	r0,r0[0x0]
80005426:	5d a8       	*unknown*

80005428 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005428:	d4 21       	pushm	r4-r7,lr
8000542a:	16 95       	mov	r5,r11
8000542c:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
8000542e:	58 0c       	cp.w	r12,0
80005430:	c0 30       	breq	80005436 <_read+0xe>
80005432:	3f f7       	mov	r7,-1
80005434:	c1 48       	rjmp	8000545c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005436:	58 0a       	cp.w	r10,0
80005438:	e0 89 00 04 	brgt	80005440 <_read+0x18>
8000543c:	30 07       	mov	r7,0
8000543e:	c0 f8       	rjmp	8000545c <_read+0x34>
80005440:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005442:	48 84       	lddpc	r4,80005460 <_read+0x38>
80005444:	68 0c       	ld.w	r12,r4[0x0]
80005446:	f0 1f 00 08 	mcall	80005464 <_read+0x3c>
    if (c < 0)
8000544a:	c0 95       	brlt	8000545c <_read+0x34>
      break;

    *ptr++ = c;
8000544c:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005450:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005452:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005456:	58 08       	cp.w	r8,0
80005458:	fe 99 ff f6 	brgt	80005444 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
8000545c:	0e 9c       	mov	r12,r7
8000545e:	d8 22       	popm	r4-r7,pc
80005460:	00 00       	add	r0,r0
80005462:	41 10       	lddsp	r0,sp[0x44]
80005464:	80 00       	ld.sh	r0,r0[0x0]
80005466:	4f f4       	lddpc	r4,80005660 <xQueueGenericReceive+0x4c>

80005468 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005468:	d4 21       	pushm	r4-r7,lr
8000546a:	16 95       	mov	r5,r11
8000546c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
8000546e:	20 1c       	sub	r12,1
80005470:	58 2c       	cp.w	r12,2
80005472:	e0 8b 00 12 	brhi	80005496 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005476:	58 0a       	cp.w	r10,0
80005478:	c0 31       	brne	8000547e <_write+0x16>
8000547a:	30 07       	mov	r7,0
8000547c:	c0 e8       	rjmp	80005498 <_write+0x30>
8000547e:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005480:	48 74       	lddpc	r4,8000549c <_write+0x34>
80005482:	68 0c       	ld.w	r12,r4[0x0]
80005484:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005488:	f0 1f 00 06 	mcall	800054a0 <_write+0x38>
8000548c:	c0 55       	brlt	80005496 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
8000548e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005490:	0e 36       	cp.w	r6,r7
80005492:	cf 81       	brne	80005482 <_write+0x1a>
80005494:	c0 28       	rjmp	80005498 <_write+0x30>
80005496:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005498:	0e 9c       	mov	r12,r7
8000549a:	d8 22       	popm	r4-r7,pc
8000549c:	00 00       	add	r0,r0
8000549e:	41 10       	lddsp	r0,sp[0x44]
800054a0:	80 00       	ld.sh	r0,r0[0x0]
800054a2:	4f a4       	lddpc	r4,80005688 <xQueueGenericReceive+0x74>

800054a4 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
800054a4:	eb cd 40 80 	pushm	r7,lr
800054a8:	18 97       	mov	r7,r12
	if( pv )
800054aa:	58 0c       	cp.w	r12,0
800054ac:	c0 80       	breq	800054bc <vPortFree+0x18>
	{
		vTaskSuspendAll();
800054ae:	f0 1f 00 05 	mcall	800054c0 <vPortFree+0x1c>
		{
			free( pv );
800054b2:	0e 9c       	mov	r12,r7
800054b4:	f0 1f 00 04 	mcall	800054c4 <vPortFree+0x20>
		}
		xTaskResumeAll();
800054b8:	f0 1f 00 04 	mcall	800054c8 <vPortFree+0x24>
800054bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800054c0:	80 00       	ld.sh	r0,r0[0x0]
800054c2:	59 ec       	cp.w	r12,30
800054c4:	80 00       	ld.sh	r0,r0[0x0]
800054c6:	69 18       	ld.w	r8,r4[0x44]
800054c8:	80 00       	ld.sh	r0,r0[0x0]
800054ca:	5d a8       	*unknown*

800054cc <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
800054cc:	eb cd 40 80 	pushm	r7,lr
800054d0:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
800054d2:	f0 1f 00 06 	mcall	800054e8 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
800054d6:	0e 9c       	mov	r12,r7
800054d8:	f0 1f 00 05 	mcall	800054ec <pvPortMalloc+0x20>
800054dc:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
800054de:	f0 1f 00 05 	mcall	800054f0 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
800054e2:	0e 9c       	mov	r12,r7
800054e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800054e8:	80 00       	ld.sh	r0,r0[0x0]
800054ea:	59 ec       	cp.w	r12,30
800054ec:	80 00       	ld.sh	r0,r0[0x0]
800054ee:	69 28       	ld.w	r8,r4[0x48]
800054f0:	80 00       	ld.sh	r0,r0[0x0]
800054f2:	5d a8       	*unknown*

800054f4 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800054f4:	d4 01       	pushm	lr
800054f6:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
800054f8:	78 09       	ld.w	r9,r12[0x0]
800054fa:	58 09       	cp.w	r9,0
800054fc:	c1 10       	breq	8000551e <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
800054fe:	78 3a       	ld.w	r10,r12[0xc]
80005500:	79 09       	ld.w	r9,r12[0x40]
80005502:	f4 09 00 09 	add	r9,r10,r9
80005506:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005508:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000550a:	14 39       	cp.w	r9,r10
8000550c:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005510:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005514:	79 0a       	ld.w	r10,r12[0x40]
80005516:	78 3b       	ld.w	r11,r12[0xc]
80005518:	10 9c       	mov	r12,r8
8000551a:	f0 1f 00 02 	mcall	80005520 <prvCopyDataFromQueue+0x2c>
8000551e:	d8 02       	popm	pc
80005520:	80 00       	ld.sh	r0,r0[0x0]
80005522:	6d 70       	ld.w	r0,r6[0x5c]

80005524 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005524:	eb cd 40 c0 	pushm	r6-r7,lr
80005528:	18 97       	mov	r7,r12
8000552a:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000552c:	78 e8       	ld.w	r8,r12[0x38]
8000552e:	58 08       	cp.w	r8,0
80005530:	c0 31       	brne	80005536 <xQueueReceiveFromISR+0x12>
80005532:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005536:	f0 1f 00 0e 	mcall	8000556c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
8000553a:	6e e8       	ld.w	r8,r7[0x38]
8000553c:	20 18       	sub	r8,1
8000553e:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005540:	6f 18       	ld.w	r8,r7[0x44]
80005542:	5b f8       	cp.w	r8,-1
80005544:	c0 d1       	brne	8000555e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005546:	6e 48       	ld.w	r8,r7[0x10]
80005548:	58 08       	cp.w	r8,0
8000554a:	c0 f0       	breq	80005568 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000554c:	ee cc ff f0 	sub	r12,r7,-16
80005550:	f0 1f 00 08 	mcall	80005570 <xQueueReceiveFromISR+0x4c>
80005554:	c0 a0       	breq	80005568 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005556:	30 1c       	mov	r12,1
80005558:	8d 0c       	st.w	r6[0x0],r12
8000555a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
8000555e:	2f f8       	sub	r8,-1
80005560:	ef 48 00 44 	st.w	r7[68],r8
80005564:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005568:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000556c:	80 00       	ld.sh	r0,r0[0x0]
8000556e:	54 f4       	stdsp	sp[0x13c],r4
80005570:	80 00       	ld.sh	r0,r0[0x0]
80005572:	5b 84       	cp.w	r4,-8

80005574 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005574:	eb cd 40 c0 	pushm	r6-r7,lr
80005578:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000557a:	f0 1f 00 23 	mcall	80005604 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000557e:	6f 28       	ld.w	r8,r7[0x48]
80005580:	58 08       	cp.w	r8,0
80005582:	e0 8a 00 18 	brle	800055b2 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005586:	6e 98       	ld.w	r8,r7[0x24]
80005588:	58 08       	cp.w	r8,0
8000558a:	c1 40       	breq	800055b2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000558c:	ee c6 ff dc 	sub	r6,r7,-36
80005590:	c0 48       	rjmp	80005598 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005592:	6e 98       	ld.w	r8,r7[0x24]
80005594:	58 08       	cp.w	r8,0
80005596:	c0 e0       	breq	800055b2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005598:	0c 9c       	mov	r12,r6
8000559a:	f0 1f 00 1c 	mcall	80005608 <prvUnlockQueue+0x94>
8000559e:	c0 30       	breq	800055a4 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800055a0:	f0 1f 00 1b 	mcall	8000560c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800055a4:	6f 28       	ld.w	r8,r7[0x48]
800055a6:	20 18       	sub	r8,1
800055a8:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800055ac:	58 08       	cp.w	r8,0
800055ae:	fe 99 ff f2 	brgt	80005592 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800055b2:	3f f8       	mov	r8,-1
800055b4:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800055b8:	f0 1f 00 16 	mcall	80005610 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800055bc:	f0 1f 00 12 	mcall	80005604 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800055c0:	6f 18       	ld.w	r8,r7[0x44]
800055c2:	58 08       	cp.w	r8,0
800055c4:	e0 8a 00 18 	brle	800055f4 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800055c8:	6e 48       	ld.w	r8,r7[0x10]
800055ca:	58 08       	cp.w	r8,0
800055cc:	c1 40       	breq	800055f4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800055ce:	ee c6 ff f0 	sub	r6,r7,-16
800055d2:	c0 48       	rjmp	800055da <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800055d4:	6e 48       	ld.w	r8,r7[0x10]
800055d6:	58 08       	cp.w	r8,0
800055d8:	c0 e0       	breq	800055f4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800055da:	0c 9c       	mov	r12,r6
800055dc:	f0 1f 00 0b 	mcall	80005608 <prvUnlockQueue+0x94>
800055e0:	c0 30       	breq	800055e6 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800055e2:	f0 1f 00 0b 	mcall	8000560c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
800055e6:	6f 18       	ld.w	r8,r7[0x44]
800055e8:	20 18       	sub	r8,1
800055ea:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800055ee:	58 08       	cp.w	r8,0
800055f0:	fe 99 ff f2 	brgt	800055d4 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800055f4:	3f f8       	mov	r8,-1
800055f6:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
800055fa:	f0 1f 00 06 	mcall	80005610 <prvUnlockQueue+0x9c>
}
800055fe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005602:	00 00       	add	r0,r0
80005604:	80 00       	ld.sh	r0,r0[0x0]
80005606:	52 60       	stdsp	sp[0x98],r0
80005608:	80 00       	ld.sh	r0,r0[0x0]
8000560a:	5b 84       	cp.w	r4,-8
8000560c:	80 00       	ld.sh	r0,r0[0x0]
8000560e:	5a 90       	cp.w	r0,-23
80005610:	80 00       	ld.sh	r0,r0[0x0]
80005612:	53 6c       	stdsp	sp[0xd8],r12

80005614 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005614:	d4 31       	pushm	r0-r7,lr
80005616:	20 5d       	sub	sp,20
80005618:	18 97       	mov	r7,r12
8000561a:	50 0b       	stdsp	sp[0x0],r11
8000561c:	50 2a       	stdsp	sp[0x8],r10
8000561e:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005620:	f8 c2 ff dc 	sub	r2,r12,-36
80005624:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005626:	fa c4 ff f4 	sub	r4,sp,-12
8000562a:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000562c:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000562e:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005632:	f0 1f 00 3e 	mcall	80005728 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005636:	6e e8       	ld.w	r8,r7[0x38]
80005638:	58 08       	cp.w	r8,0
8000563a:	c2 a0       	breq	8000568e <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
8000563c:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000563e:	40 0b       	lddsp	r11,sp[0x0]
80005640:	0e 9c       	mov	r12,r7
80005642:	f0 1f 00 3b 	mcall	8000572c <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005646:	40 18       	lddsp	r8,sp[0x4]
80005648:	58 08       	cp.w	r8,0
8000564a:	c1 51       	brne	80005674 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
8000564c:	6e e8       	ld.w	r8,r7[0x38]
8000564e:	20 18       	sub	r8,1
80005650:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005652:	6e 08       	ld.w	r8,r7[0x0]
80005654:	58 08       	cp.w	r8,0
80005656:	c0 41       	brne	8000565e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005658:	f0 1f 00 36 	mcall	80005730 <xQueueGenericReceive+0x11c>
8000565c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000565e:	6e 48       	ld.w	r8,r7[0x10]
80005660:	58 08       	cp.w	r8,0
80005662:	c1 20       	breq	80005686 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005664:	ee cc ff f0 	sub	r12,r7,-16
80005668:	f0 1f 00 33 	mcall	80005734 <xQueueGenericReceive+0x120>
8000566c:	58 1c       	cp.w	r12,1
8000566e:	c0 c1       	brne	80005686 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005670:	d7 33       	scall
80005672:	c0 a8       	rjmp	80005686 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005674:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005676:	6e 98       	ld.w	r8,r7[0x24]
80005678:	58 08       	cp.w	r8,0
8000567a:	c0 60       	breq	80005686 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000567c:	04 9c       	mov	r12,r2
8000567e:	f0 1f 00 2e 	mcall	80005734 <xQueueGenericReceive+0x120>
80005682:	c0 20       	breq	80005686 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005684:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005686:	f0 1f 00 2d 	mcall	80005738 <xQueueGenericReceive+0x124>
8000568a:	30 1c       	mov	r12,1
				return pdPASS;
8000568c:	c4 c8       	rjmp	80005724 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000568e:	40 28       	lddsp	r8,sp[0x8]
80005690:	58 08       	cp.w	r8,0
80005692:	c0 51       	brne	8000569c <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005694:	f0 1f 00 29 	mcall	80005738 <xQueueGenericReceive+0x124>
80005698:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000569a:	c4 58       	rjmp	80005724 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
8000569c:	58 05       	cp.w	r5,0
8000569e:	c0 51       	brne	800056a8 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800056a0:	08 9c       	mov	r12,r4
800056a2:	f0 1f 00 27 	mcall	8000573c <xQueueGenericReceive+0x128>
800056a6:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800056a8:	f0 1f 00 24 	mcall	80005738 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800056ac:	f0 1f 00 25 	mcall	80005740 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800056b0:	f0 1f 00 1e 	mcall	80005728 <xQueueGenericReceive+0x114>
800056b4:	6f 18       	ld.w	r8,r7[0x44]
800056b6:	5b f8       	cp.w	r8,-1
800056b8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800056bc:	6f 28       	ld.w	r8,r7[0x48]
800056be:	5b f8       	cp.w	r8,-1
800056c0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800056c4:	f0 1f 00 1d 	mcall	80005738 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800056c8:	06 9b       	mov	r11,r3
800056ca:	08 9c       	mov	r12,r4
800056cc:	f0 1f 00 1e 	mcall	80005744 <xQueueGenericReceive+0x130>
800056d0:	c2 41       	brne	80005718 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800056d2:	f0 1f 00 16 	mcall	80005728 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
800056d6:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
800056d8:	f0 1f 00 18 	mcall	80005738 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
800056dc:	58 06       	cp.w	r6,0
800056de:	c1 71       	brne	8000570c <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800056e0:	6e 08       	ld.w	r8,r7[0x0]
800056e2:	58 08       	cp.w	r8,0
800056e4:	c0 81       	brne	800056f4 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800056e6:	f0 1f 00 11 	mcall	80005728 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800056ea:	6e 1c       	ld.w	r12,r7[0x4]
800056ec:	f0 1f 00 17 	mcall	80005748 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800056f0:	f0 1f 00 12 	mcall	80005738 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800056f4:	40 2b       	lddsp	r11,sp[0x8]
800056f6:	04 9c       	mov	r12,r2
800056f8:	f0 1f 00 15 	mcall	8000574c <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
800056fc:	0e 9c       	mov	r12,r7
800056fe:	f0 1f 00 15 	mcall	80005750 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005702:	f0 1f 00 15 	mcall	80005754 <xQueueGenericReceive+0x140>
80005706:	c9 61       	brne	80005632 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005708:	d7 33       	scall
8000570a:	c9 4b       	rjmp	80005632 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000570c:	0e 9c       	mov	r12,r7
8000570e:	f0 1f 00 11 	mcall	80005750 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005712:	f0 1f 00 11 	mcall	80005754 <xQueueGenericReceive+0x140>
80005716:	c8 eb       	rjmp	80005632 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005718:	0e 9c       	mov	r12,r7
8000571a:	f0 1f 00 0e 	mcall	80005750 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000571e:	f0 1f 00 0e 	mcall	80005754 <xQueueGenericReceive+0x140>
80005722:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005724:	2f bd       	sub	sp,-20
80005726:	d8 32       	popm	r0-r7,pc
80005728:	80 00       	ld.sh	r0,r0[0x0]
8000572a:	52 60       	stdsp	sp[0x98],r0
8000572c:	80 00       	ld.sh	r0,r0[0x0]
8000572e:	54 f4       	stdsp	sp[0x13c],r4
80005730:	80 00       	ld.sh	r0,r0[0x0]
80005732:	5a 9c       	cp.w	r12,-23
80005734:	80 00       	ld.sh	r0,r0[0x0]
80005736:	5b 84       	cp.w	r4,-8
80005738:	80 00       	ld.sh	r0,r0[0x0]
8000573a:	53 6c       	stdsp	sp[0xd8],r12
8000573c:	80 00       	ld.sh	r0,r0[0x0]
8000573e:	5a 78       	cp.w	r8,-25
80005740:	80 00       	ld.sh	r0,r0[0x0]
80005742:	59 ec       	cp.w	r12,30
80005744:	80 00       	ld.sh	r0,r0[0x0]
80005746:	5d 14       	icall	r4
80005748:	80 00       	ld.sh	r0,r0[0x0]
8000574a:	5b 00       	cp.w	r0,-16
8000574c:	80 00       	ld.sh	r0,r0[0x0]
8000574e:	5f 6c       	srmi	r12
80005750:	80 00       	ld.sh	r0,r0[0x0]
80005752:	55 74       	stdsp	sp[0x15c],r4
80005754:	80 00       	ld.sh	r0,r0[0x0]
80005756:	5d a8       	*unknown*

80005758 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005758:	eb cd 40 80 	pushm	r7,lr
8000575c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000575e:	79 08       	ld.w	r8,r12[0x40]
80005760:	58 08       	cp.w	r8,0
80005762:	c0 a1       	brne	80005776 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005764:	78 08       	ld.w	r8,r12[0x0]
80005766:	58 08       	cp.w	r8,0
80005768:	c2 b1       	brne	800057be <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000576a:	78 1c       	ld.w	r12,r12[0x4]
8000576c:	f0 1f 00 17 	mcall	800057c8 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005770:	30 08       	mov	r8,0
80005772:	8f 18       	st.w	r7[0x4],r8
80005774:	c2 58       	rjmp	800057be <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005776:	58 0a       	cp.w	r10,0
80005778:	c1 01       	brne	80005798 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000577a:	10 9a       	mov	r10,r8
8000577c:	78 2c       	ld.w	r12,r12[0x8]
8000577e:	f0 1f 00 14 	mcall	800057cc <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005782:	6e 29       	ld.w	r9,r7[0x8]
80005784:	6f 08       	ld.w	r8,r7[0x40]
80005786:	f2 08 00 08 	add	r8,r9,r8
8000578a:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000578c:	6e 19       	ld.w	r9,r7[0x4]
8000578e:	12 38       	cp.w	r8,r9
80005790:	c1 73       	brcs	800057be <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005792:	6e 08       	ld.w	r8,r7[0x0]
80005794:	8f 28       	st.w	r7[0x8],r8
80005796:	c1 48       	rjmp	800057be <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005798:	10 9a       	mov	r10,r8
8000579a:	78 3c       	ld.w	r12,r12[0xc]
8000579c:	f0 1f 00 0c 	mcall	800057cc <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800057a0:	6f 08       	ld.w	r8,r7[0x40]
800057a2:	6e 39       	ld.w	r9,r7[0xc]
800057a4:	f2 08 01 08 	sub	r8,r9,r8
800057a8:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800057aa:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800057ac:	12 38       	cp.w	r8,r9
800057ae:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800057b2:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800057b6:	f3 d8 e3 19 	subcs	r9,r9,r8
800057ba:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800057be:	6e e8       	ld.w	r8,r7[0x38]
800057c0:	2f f8       	sub	r8,-1
800057c2:	8f e8       	st.w	r7[0x38],r8
}
800057c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800057c8:	80 00       	ld.sh	r0,r0[0x0]
800057ca:	5a a8       	cp.w	r8,-22
800057cc:	80 00       	ld.sh	r0,r0[0x0]
800057ce:	6d 70       	ld.w	r0,r6[0x5c]

800057d0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800057d0:	eb cd 40 c0 	pushm	r6-r7,lr
800057d4:	18 97       	mov	r7,r12
800057d6:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800057d8:	78 ec       	ld.w	r12,r12[0x38]
800057da:	6e f8       	ld.w	r8,r7[0x3c]
800057dc:	10 3c       	cp.w	r12,r8
800057de:	c0 33       	brcs	800057e4 <xQueueGenericSendFromISR+0x14>
800057e0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800057e4:	12 9a       	mov	r10,r9
800057e6:	0e 9c       	mov	r12,r7
800057e8:	f0 1f 00 0c 	mcall	80005818 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800057ec:	6f 28       	ld.w	r8,r7[0x48]
800057ee:	5b f8       	cp.w	r8,-1
800057f0:	c0 d1       	brne	8000580a <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800057f2:	6e 98       	ld.w	r8,r7[0x24]
800057f4:	58 08       	cp.w	r8,0
800057f6:	c0 f0       	breq	80005814 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800057f8:	ee cc ff dc 	sub	r12,r7,-36
800057fc:	f0 1f 00 08 	mcall	8000581c <xQueueGenericSendFromISR+0x4c>
80005800:	c0 a0       	breq	80005814 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80005802:	30 1c       	mov	r12,1
80005804:	8d 0c       	st.w	r6[0x0],r12
80005806:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000580a:	2f f8       	sub	r8,-1
8000580c:	ef 48 00 48 	st.w	r7[72],r8
80005810:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005814:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005818:	80 00       	ld.sh	r0,r0[0x0]
8000581a:	57 58       	stdsp	sp[0x1d4],r8
8000581c:	80 00       	ld.sh	r0,r0[0x0]
8000581e:	5b 84       	cp.w	r4,-8

80005820 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005820:	d4 31       	pushm	r0-r7,lr
80005822:	20 5d       	sub	sp,20
80005824:	18 97       	mov	r7,r12
80005826:	50 0b       	stdsp	sp[0x0],r11
80005828:	50 2a       	stdsp	sp[0x8],r10
8000582a:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000582c:	f8 c0 ff f0 	sub	r0,r12,-16
80005830:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005832:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005836:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005838:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000583c:	f0 1f 00 2f 	mcall	800058f8 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005840:	6e e9       	ld.w	r9,r7[0x38]
80005842:	6e f8       	ld.w	r8,r7[0x3c]
80005844:	10 39       	cp.w	r9,r8
80005846:	c1 42       	brcc	8000586e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005848:	40 1a       	lddsp	r10,sp[0x4]
8000584a:	40 0b       	lddsp	r11,sp[0x0]
8000584c:	0e 9c       	mov	r12,r7
8000584e:	f0 1f 00 2c 	mcall	800058fc <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005852:	6e 98       	ld.w	r8,r7[0x24]
80005854:	58 08       	cp.w	r8,0
80005856:	c0 80       	breq	80005866 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005858:	ee cc ff dc 	sub	r12,r7,-36
8000585c:	f0 1f 00 29 	mcall	80005900 <xQueueGenericSend+0xe0>
80005860:	58 1c       	cp.w	r12,1
80005862:	c0 21       	brne	80005866 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005864:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005866:	f0 1f 00 28 	mcall	80005904 <xQueueGenericSend+0xe4>
8000586a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
8000586c:	c4 38       	rjmp	800058f2 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000586e:	40 28       	lddsp	r8,sp[0x8]
80005870:	58 08       	cp.w	r8,0
80005872:	c0 51       	brne	8000587c <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005874:	f0 1f 00 24 	mcall	80005904 <xQueueGenericSend+0xe4>
80005878:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000587a:	c3 c8       	rjmp	800058f2 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
8000587c:	58 04       	cp.w	r4,0
8000587e:	c0 51       	brne	80005888 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005880:	06 9c       	mov	r12,r3
80005882:	f0 1f 00 22 	mcall	80005908 <xQueueGenericSend+0xe8>
80005886:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005888:	f0 1f 00 1f 	mcall	80005904 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000588c:	f0 1f 00 20 	mcall	8000590c <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005890:	f0 1f 00 1a 	mcall	800058f8 <xQueueGenericSend+0xd8>
80005894:	6f 18       	ld.w	r8,r7[0x44]
80005896:	5b f8       	cp.w	r8,-1
80005898:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000589c:	6f 28       	ld.w	r8,r7[0x48]
8000589e:	5b f8       	cp.w	r8,-1
800058a0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800058a4:	f0 1f 00 18 	mcall	80005904 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800058a8:	04 9b       	mov	r11,r2
800058aa:	06 9c       	mov	r12,r3
800058ac:	f0 1f 00 19 	mcall	80005910 <xQueueGenericSend+0xf0>
800058b0:	c1 b1       	brne	800058e6 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800058b2:	f0 1f 00 12 	mcall	800058f8 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800058b6:	6e e5       	ld.w	r5,r7[0x38]
800058b8:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800058ba:	f0 1f 00 13 	mcall	80005904 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800058be:	0c 35       	cp.w	r5,r6
800058c0:	c0 d1       	brne	800058da <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800058c2:	40 2b       	lddsp	r11,sp[0x8]
800058c4:	00 9c       	mov	r12,r0
800058c6:	f0 1f 00 14 	mcall	80005914 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800058ca:	0e 9c       	mov	r12,r7
800058cc:	f0 1f 00 13 	mcall	80005918 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800058d0:	f0 1f 00 13 	mcall	8000591c <xQueueGenericSend+0xfc>
800058d4:	cb 41       	brne	8000583c <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800058d6:	d7 33       	scall
800058d8:	cb 2b       	rjmp	8000583c <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800058da:	0e 9c       	mov	r12,r7
800058dc:	f0 1f 00 0f 	mcall	80005918 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800058e0:	f0 1f 00 0f 	mcall	8000591c <xQueueGenericSend+0xfc>
800058e4:	ca cb       	rjmp	8000583c <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800058e6:	0e 9c       	mov	r12,r7
800058e8:	f0 1f 00 0c 	mcall	80005918 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800058ec:	f0 1f 00 0c 	mcall	8000591c <xQueueGenericSend+0xfc>
800058f0:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800058f2:	2f bd       	sub	sp,-20
800058f4:	d8 32       	popm	r0-r7,pc
800058f6:	00 00       	add	r0,r0
800058f8:	80 00       	ld.sh	r0,r0[0x0]
800058fa:	52 60       	stdsp	sp[0x98],r0
800058fc:	80 00       	ld.sh	r0,r0[0x0]
800058fe:	57 58       	stdsp	sp[0x1d4],r8
80005900:	80 00       	ld.sh	r0,r0[0x0]
80005902:	5b 84       	cp.w	r4,-8
80005904:	80 00       	ld.sh	r0,r0[0x0]
80005906:	53 6c       	stdsp	sp[0xd8],r12
80005908:	80 00       	ld.sh	r0,r0[0x0]
8000590a:	5a 78       	cp.w	r8,-25
8000590c:	80 00       	ld.sh	r0,r0[0x0]
8000590e:	59 ec       	cp.w	r12,30
80005910:	80 00       	ld.sh	r0,r0[0x0]
80005912:	5d 14       	icall	r4
80005914:	80 00       	ld.sh	r0,r0[0x0]
80005916:	5f 6c       	srmi	r12
80005918:	80 00       	ld.sh	r0,r0[0x0]
8000591a:	55 74       	stdsp	sp[0x15c],r4
8000591c:	80 00       	ld.sh	r0,r0[0x0]
8000591e:	5d a8       	*unknown*

80005920 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80005920:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005924:	34 cc       	mov	r12,76
80005926:	f0 1f 00 12 	mcall	8000596c <xQueueCreateMutex+0x4c>
8000592a:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
8000592c:	c1 d0       	breq	80005966 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
8000592e:	30 06       	mov	r6,0
80005930:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80005932:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80005934:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80005936:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005938:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
8000593a:	30 18       	mov	r8,1
8000593c:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
8000593e:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80005942:	3f f8       	mov	r8,-1
80005944:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80005948:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000594c:	2f 0c       	sub	r12,-16
8000594e:	f0 1f 00 09 	mcall	80005970 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005952:	ee cc ff dc 	sub	r12,r7,-36
80005956:	f0 1f 00 07 	mcall	80005970 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
8000595a:	0c 99       	mov	r9,r6
8000595c:	0c 9a       	mov	r10,r6
8000595e:	0c 9b       	mov	r11,r6
80005960:	0e 9c       	mov	r12,r7
80005962:	f0 1f 00 05 	mcall	80005974 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80005966:	0e 9c       	mov	r12,r7
80005968:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000596c:	80 00       	ld.sh	r0,r0[0x0]
8000596e:	54 cc       	stdsp	sp[0x130],r12
80005970:	80 00       	ld.sh	r0,r0[0x0]
80005972:	51 3c       	stdsp	sp[0x4c],r12
80005974:	80 00       	ld.sh	r0,r0[0x0]
80005976:	58 20       	cp.w	r0,2

80005978 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005978:	d4 21       	pushm	r4-r7,lr
8000597a:	18 97       	mov	r7,r12
8000597c:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000597e:	58 0c       	cp.w	r12,0
80005980:	c2 f0       	breq	800059de <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005982:	34 cc       	mov	r12,76
80005984:	f0 1f 00 17 	mcall	800059e0 <xQueueCreate+0x68>
80005988:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000598a:	c2 a0       	breq	800059de <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000598c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005990:	e8 cc ff ff 	sub	r12,r4,-1
80005994:	f0 1f 00 13 	mcall	800059e0 <xQueueCreate+0x68>
80005998:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000599a:	c1 e0       	breq	800059d6 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000599c:	f8 04 00 04 	add	r4,r12,r4
800059a0:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800059a2:	30 08       	mov	r8,0
800059a4:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800059a6:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800059a8:	ee c8 00 01 	sub	r8,r7,1
800059ac:	ad 38       	mul	r8,r6
800059ae:	10 0c       	add	r12,r8
800059b0:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800059b2:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800059b4:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800059b8:	3f f8       	mov	r8,-1
800059ba:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800059be:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800059c2:	ea cc ff f0 	sub	r12,r5,-16
800059c6:	f0 1f 00 08 	mcall	800059e4 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800059ca:	ea cc ff dc 	sub	r12,r5,-36
800059ce:	f0 1f 00 06 	mcall	800059e4 <xQueueCreate+0x6c>
800059d2:	0a 9c       	mov	r12,r5
800059d4:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800059d6:	0a 9c       	mov	r12,r5
800059d8:	f0 1f 00 04 	mcall	800059e8 <xQueueCreate+0x70>
800059dc:	d8 2a       	popm	r4-r7,pc,r12=0
800059de:	d8 2a       	popm	r4-r7,pc,r12=0
800059e0:	80 00       	ld.sh	r0,r0[0x0]
800059e2:	54 cc       	stdsp	sp[0x130],r12
800059e4:	80 00       	ld.sh	r0,r0[0x0]
800059e6:	51 3c       	stdsp	sp[0x4c],r12
800059e8:	80 00       	ld.sh	r0,r0[0x0]
800059ea:	54 a4       	stdsp	sp[0x128],r4

800059ec <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800059ec:	48 38       	lddpc	r8,800059f8 <vTaskSuspendAll+0xc>
800059ee:	70 09       	ld.w	r9,r8[0x0]
800059f0:	2f f9       	sub	r9,-1
800059f2:	91 09       	st.w	r8[0x0],r9
}
800059f4:	5e fc       	retal	r12
800059f6:	00 00       	add	r0,r0
800059f8:	00 00       	add	r0,r0
800059fa:	0d 34       	ld.ub	r4,r6++

800059fc <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800059fc:	49 a8       	lddpc	r8,80005a64 <vTaskSwitchContext+0x68>
800059fe:	70 08       	ld.w	r8,r8[0x0]
80005a00:	58 08       	cp.w	r8,0
80005a02:	c0 b1       	brne	80005a18 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005a04:	49 98       	lddpc	r8,80005a68 <vTaskSwitchContext+0x6c>
80005a06:	70 08       	ld.w	r8,r8[0x0]
80005a08:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005a0c:	49 89       	lddpc	r9,80005a6c <vTaskSwitchContext+0x70>
80005a0e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005a12:	58 08       	cp.w	r8,0
80005a14:	c0 60       	breq	80005a20 <vTaskSwitchContext+0x24>
80005a16:	c1 18       	rjmp	80005a38 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005a18:	30 19       	mov	r9,1
80005a1a:	49 68       	lddpc	r8,80005a70 <vTaskSwitchContext+0x74>
80005a1c:	91 09       	st.w	r8[0x0],r9
80005a1e:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005a20:	49 28       	lddpc	r8,80005a68 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005a22:	49 3a       	lddpc	r10,80005a6c <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005a24:	70 09       	ld.w	r9,r8[0x0]
80005a26:	20 19       	sub	r9,1
80005a28:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005a2a:	70 09       	ld.w	r9,r8[0x0]
80005a2c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005a30:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005a34:	58 09       	cp.w	r9,0
80005a36:	cf 70       	breq	80005a24 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005a38:	48 c8       	lddpc	r8,80005a68 <vTaskSwitchContext+0x6c>
80005a3a:	70 08       	ld.w	r8,r8[0x0]
80005a3c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005a40:	48 b9       	lddpc	r9,80005a6c <vTaskSwitchContext+0x70>
80005a42:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005a46:	70 19       	ld.w	r9,r8[0x4]
80005a48:	72 19       	ld.w	r9,r9[0x4]
80005a4a:	91 19       	st.w	r8[0x4],r9
80005a4c:	f0 ca ff f8 	sub	r10,r8,-8
80005a50:	14 39       	cp.w	r9,r10
80005a52:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80005a56:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80005a5a:	70 18       	ld.w	r8,r8[0x4]
80005a5c:	70 39       	ld.w	r9,r8[0xc]
80005a5e:	48 68       	lddpc	r8,80005a74 <vTaskSwitchContext+0x78>
80005a60:	91 09       	st.w	r8[0x0],r9
80005a62:	5e fc       	retal	r12
80005a64:	00 00       	add	r0,r0
80005a66:	0d 34       	ld.ub	r4,r6++
80005a68:	00 00       	add	r0,r0
80005a6a:	0d 6c       	ld.uh	r12,--r6
80005a6c:	00 00       	add	r0,r0
80005a6e:	0c 50       	eor	r0,r6
80005a70:	00 00       	add	r0,r0
80005a72:	0d 54       	ld.sh	r4,--r6
80005a74:	00 00       	add	r0,r0
80005a76:	0d 04       	ld.w	r4,r6++

80005a78 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80005a78:	48 48       	lddpc	r8,80005a88 <vTaskSetTimeOutState+0x10>
80005a7a:	70 08       	ld.w	r8,r8[0x0]
80005a7c:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80005a7e:	48 48       	lddpc	r8,80005a8c <vTaskSetTimeOutState+0x14>
80005a80:	70 08       	ld.w	r8,r8[0x0]
80005a82:	99 18       	st.w	r12[0x4],r8
}
80005a84:	5e fc       	retal	r12
80005a86:	00 00       	add	r0,r0
80005a88:	00 00       	add	r0,r0
80005a8a:	0c 48       	or	r8,r6
80005a8c:	00 00       	add	r0,r0
80005a8e:	0d 30       	ld.ub	r0,r6++

80005a90 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80005a90:	30 19       	mov	r9,1
80005a92:	48 28       	lddpc	r8,80005a98 <vTaskMissedYield+0x8>
80005a94:	91 09       	st.w	r8[0x0],r9
}
80005a96:	5e fc       	retal	r12
80005a98:	00 00       	add	r0,r0
80005a9a:	0d 54       	ld.sh	r4,--r6

80005a9c <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80005a9c:	48 28       	lddpc	r8,80005aa4 <xTaskGetCurrentTaskHandle+0x8>
80005a9e:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80005aa0:	5e fc       	retal	r12
80005aa2:	00 00       	add	r0,r0
80005aa4:	00 00       	add	r0,r0
80005aa6:	0d 04       	ld.w	r4,r6++

80005aa8 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80005aa8:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80005aac:	58 0c       	cp.w	r12,0
80005aae:	c1 f0       	breq	80005aec <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005ab0:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80005ab2:	78 b9       	ld.w	r9,r12[0x2c]
80005ab4:	79 18       	ld.w	r8,r12[0x44]
80005ab6:	10 39       	cp.w	r9,r8
80005ab8:	c1 a0       	breq	80005aec <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80005aba:	f8 c6 ff fc 	sub	r6,r12,-4
80005abe:	0c 9c       	mov	r12,r6
80005ac0:	f0 1f 00 0c 	mcall	80005af0 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80005ac4:	6f 1c       	ld.w	r12,r7[0x44]
80005ac6:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005ac8:	f8 08 11 08 	rsub	r8,r12,8
80005acc:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80005ace:	48 a8       	lddpc	r8,80005af4 <vTaskPriorityDisinherit+0x4c>
80005ad0:	70 08       	ld.w	r8,r8[0x0]
80005ad2:	10 3c       	cp.w	r12,r8
80005ad4:	e0 88 00 04 	brls	80005adc <vTaskPriorityDisinherit+0x34>
80005ad8:	48 78       	lddpc	r8,80005af4 <vTaskPriorityDisinherit+0x4c>
80005ada:	91 0c       	st.w	r8[0x0],r12
80005adc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005ae0:	0c 9b       	mov	r11,r6
80005ae2:	48 68       	lddpc	r8,80005af8 <vTaskPriorityDisinherit+0x50>
80005ae4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005ae8:	f0 1f 00 05 	mcall	80005afc <vTaskPriorityDisinherit+0x54>
80005aec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005af0:	80 00       	ld.sh	r0,r0[0x0]
80005af2:	51 a6       	stdsp	sp[0x68],r6
80005af4:	00 00       	add	r0,r0
80005af6:	0d 6c       	ld.uh	r12,--r6
80005af8:	00 00       	add	r0,r0
80005afa:	0c 50       	eor	r0,r6
80005afc:	80 00       	ld.sh	r0,r0[0x0]
80005afe:	51 56       	stdsp	sp[0x54],r6

80005b00 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005b00:	eb cd 40 c0 	pushm	r6-r7,lr
80005b04:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80005b06:	49 b8       	lddpc	r8,80005b70 <vTaskPriorityInherit+0x70>
80005b08:	70 08       	ld.w	r8,r8[0x0]
80005b0a:	78 b9       	ld.w	r9,r12[0x2c]
80005b0c:	70 b8       	ld.w	r8,r8[0x2c]
80005b0e:	10 39       	cp.w	r9,r8
80005b10:	c2 d2       	brcc	80005b6a <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80005b12:	49 88       	lddpc	r8,80005b70 <vTaskPriorityInherit+0x70>
80005b14:	70 08       	ld.w	r8,r8[0x0]
80005b16:	70 b8       	ld.w	r8,r8[0x2c]
80005b18:	f0 08 11 08 	rsub	r8,r8,8
80005b1c:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80005b1e:	f2 09 00 28 	add	r8,r9,r9<<0x2
80005b22:	49 59       	lddpc	r9,80005b74 <vTaskPriorityInherit+0x74>
80005b24:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005b28:	78 59       	ld.w	r9,r12[0x14]
80005b2a:	10 39       	cp.w	r9,r8
80005b2c:	c1 b1       	brne	80005b62 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80005b2e:	f8 c6 ff fc 	sub	r6,r12,-4
80005b32:	0c 9c       	mov	r12,r6
80005b34:	f0 1f 00 11 	mcall	80005b78 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005b38:	48 e8       	lddpc	r8,80005b70 <vTaskPriorityInherit+0x70>
80005b3a:	70 08       	ld.w	r8,r8[0x0]
80005b3c:	70 bc       	ld.w	r12,r8[0x2c]
80005b3e:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80005b40:	48 f8       	lddpc	r8,80005b7c <vTaskPriorityInherit+0x7c>
80005b42:	70 08       	ld.w	r8,r8[0x0]
80005b44:	10 3c       	cp.w	r12,r8
80005b46:	e0 88 00 04 	brls	80005b4e <vTaskPriorityInherit+0x4e>
80005b4a:	48 d8       	lddpc	r8,80005b7c <vTaskPriorityInherit+0x7c>
80005b4c:	91 0c       	st.w	r8[0x0],r12
80005b4e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005b52:	0c 9b       	mov	r11,r6
80005b54:	48 88       	lddpc	r8,80005b74 <vTaskPriorityInherit+0x74>
80005b56:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005b5a:	f0 1f 00 0a 	mcall	80005b80 <vTaskPriorityInherit+0x80>
80005b5e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005b62:	48 48       	lddpc	r8,80005b70 <vTaskPriorityInherit+0x70>
80005b64:	70 08       	ld.w	r8,r8[0x0]
80005b66:	70 b8       	ld.w	r8,r8[0x2c]
80005b68:	99 b8       	st.w	r12[0x2c],r8
80005b6a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b6e:	00 00       	add	r0,r0
80005b70:	00 00       	add	r0,r0
80005b72:	0d 04       	ld.w	r4,r6++
80005b74:	00 00       	add	r0,r0
80005b76:	0c 50       	eor	r0,r6
80005b78:	80 00       	ld.sh	r0,r0[0x0]
80005b7a:	51 a6       	stdsp	sp[0x68],r6
80005b7c:	00 00       	add	r0,r0
80005b7e:	0d 6c       	ld.uh	r12,--r6
80005b80:	80 00       	ld.sh	r0,r0[0x0]
80005b82:	51 56       	stdsp	sp[0x54],r6

80005b84 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80005b84:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80005b88:	78 38       	ld.w	r8,r12[0xc]
80005b8a:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80005b8c:	ee c6 ff e8 	sub	r6,r7,-24
80005b90:	0c 9c       	mov	r12,r6
80005b92:	f0 1f 00 15 	mcall	80005be4 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005b96:	49 58       	lddpc	r8,80005be8 <xTaskRemoveFromEventList+0x64>
80005b98:	70 08       	ld.w	r8,r8[0x0]
80005b9a:	58 08       	cp.w	r8,0
80005b9c:	c1 71       	brne	80005bca <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80005b9e:	ee c6 ff fc 	sub	r6,r7,-4
80005ba2:	0c 9c       	mov	r12,r6
80005ba4:	f0 1f 00 10 	mcall	80005be4 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005ba8:	6e bc       	ld.w	r12,r7[0x2c]
80005baa:	49 18       	lddpc	r8,80005bec <xTaskRemoveFromEventList+0x68>
80005bac:	70 08       	ld.w	r8,r8[0x0]
80005bae:	10 3c       	cp.w	r12,r8
80005bb0:	e0 88 00 04 	brls	80005bb8 <xTaskRemoveFromEventList+0x34>
80005bb4:	48 e8       	lddpc	r8,80005bec <xTaskRemoveFromEventList+0x68>
80005bb6:	91 0c       	st.w	r8[0x0],r12
80005bb8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005bbc:	0c 9b       	mov	r11,r6
80005bbe:	48 d8       	lddpc	r8,80005bf0 <xTaskRemoveFromEventList+0x6c>
80005bc0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005bc4:	f0 1f 00 0c 	mcall	80005bf4 <xTaskRemoveFromEventList+0x70>
80005bc8:	c0 58       	rjmp	80005bd2 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005bca:	0c 9b       	mov	r11,r6
80005bcc:	48 bc       	lddpc	r12,80005bf8 <xTaskRemoveFromEventList+0x74>
80005bce:	f0 1f 00 0a 	mcall	80005bf4 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005bd2:	48 b8       	lddpc	r8,80005bfc <xTaskRemoveFromEventList+0x78>
80005bd4:	70 08       	ld.w	r8,r8[0x0]
80005bd6:	6e b9       	ld.w	r9,r7[0x2c]
80005bd8:	70 b8       	ld.w	r8,r8[0x2c]
80005bda:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005bdc:	5f 2c       	srhs	r12
80005bde:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005be2:	00 00       	add	r0,r0
80005be4:	80 00       	ld.sh	r0,r0[0x0]
80005be6:	51 a6       	stdsp	sp[0x68],r6
80005be8:	00 00       	add	r0,r0
80005bea:	0d 34       	ld.ub	r4,r6++
80005bec:	00 00       	add	r0,r0
80005bee:	0d 6c       	ld.uh	r12,--r6
80005bf0:	00 00       	add	r0,r0
80005bf2:	0c 50       	eor	r0,r6
80005bf4:	80 00       	ld.sh	r0,r0[0x0]
80005bf6:	51 56       	stdsp	sp[0x54],r6
80005bf8:	00 00       	add	r0,r0
80005bfa:	0d 08       	ld.w	r8,r6++
80005bfc:	00 00       	add	r0,r0
80005bfe:	0d 04       	ld.w	r4,r6++

80005c00 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005c00:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005c04:	4b 98       	lddpc	r8,80005ce8 <vTaskIncrementTick+0xe8>
80005c06:	70 08       	ld.w	r8,r8[0x0]
80005c08:	58 08       	cp.w	r8,0
80005c0a:	c6 91       	brne	80005cdc <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005c0c:	4b 88       	lddpc	r8,80005cec <vTaskIncrementTick+0xec>
80005c0e:	70 09       	ld.w	r9,r8[0x0]
80005c10:	2f f9       	sub	r9,-1
80005c12:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005c14:	70 08       	ld.w	r8,r8[0x0]
80005c16:	58 08       	cp.w	r8,0
80005c18:	c1 a1       	brne	80005c4c <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005c1a:	4b 68       	lddpc	r8,80005cf0 <vTaskIncrementTick+0xf0>
80005c1c:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005c1e:	4b 69       	lddpc	r9,80005cf4 <vTaskIncrementTick+0xf4>
80005c20:	72 0b       	ld.w	r11,r9[0x0]
80005c22:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005c24:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80005c26:	4b 59       	lddpc	r9,80005cf8 <vTaskIncrementTick+0xf8>
80005c28:	72 0a       	ld.w	r10,r9[0x0]
80005c2a:	2f fa       	sub	r10,-1
80005c2c:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005c2e:	70 08       	ld.w	r8,r8[0x0]
80005c30:	70 08       	ld.w	r8,r8[0x0]
80005c32:	58 08       	cp.w	r8,0
80005c34:	c0 51       	brne	80005c3e <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005c36:	3f f9       	mov	r9,-1
80005c38:	4b 18       	lddpc	r8,80005cfc <vTaskIncrementTick+0xfc>
80005c3a:	91 09       	st.w	r8[0x0],r9
80005c3c:	c0 88       	rjmp	80005c4c <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005c3e:	4a d8       	lddpc	r8,80005cf0 <vTaskIncrementTick+0xf0>
80005c40:	70 08       	ld.w	r8,r8[0x0]
80005c42:	70 38       	ld.w	r8,r8[0xc]
80005c44:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80005c46:	70 19       	ld.w	r9,r8[0x4]
80005c48:	4a d8       	lddpc	r8,80005cfc <vTaskIncrementTick+0xfc>
80005c4a:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005c4c:	4a 88       	lddpc	r8,80005cec <vTaskIncrementTick+0xec>
80005c4e:	70 09       	ld.w	r9,r8[0x0]
80005c50:	4a b8       	lddpc	r8,80005cfc <vTaskIncrementTick+0xfc>
80005c52:	70 08       	ld.w	r8,r8[0x0]
80005c54:	10 39       	cp.w	r9,r8
80005c56:	c4 73       	brcs	80005ce4 <vTaskIncrementTick+0xe4>
80005c58:	4a 68       	lddpc	r8,80005cf0 <vTaskIncrementTick+0xf0>
80005c5a:	70 08       	ld.w	r8,r8[0x0]
80005c5c:	70 08       	ld.w	r8,r8[0x0]
80005c5e:	58 08       	cp.w	r8,0
80005c60:	c0 c0       	breq	80005c78 <vTaskIncrementTick+0x78>
80005c62:	4a 48       	lddpc	r8,80005cf0 <vTaskIncrementTick+0xf0>
80005c64:	70 08       	ld.w	r8,r8[0x0]
80005c66:	70 38       	ld.w	r8,r8[0xc]
80005c68:	70 37       	ld.w	r7,r8[0xc]
80005c6a:	6e 18       	ld.w	r8,r7[0x4]
80005c6c:	4a 09       	lddpc	r9,80005cec <vTaskIncrementTick+0xec>
80005c6e:	72 09       	ld.w	r9,r9[0x0]
80005c70:	12 38       	cp.w	r8,r9
80005c72:	e0 88 00 14 	brls	80005c9a <vTaskIncrementTick+0x9a>
80005c76:	c0 e8       	rjmp	80005c92 <vTaskIncrementTick+0x92>
80005c78:	3f f9       	mov	r9,-1
80005c7a:	4a 18       	lddpc	r8,80005cfc <vTaskIncrementTick+0xfc>
80005c7c:	91 09       	st.w	r8[0x0],r9
80005c7e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005c82:	6a 08       	ld.w	r8,r5[0x0]
80005c84:	70 38       	ld.w	r8,r8[0xc]
80005c86:	70 37       	ld.w	r7,r8[0xc]
80005c88:	6e 18       	ld.w	r8,r7[0x4]
80005c8a:	64 09       	ld.w	r9,r2[0x0]
80005c8c:	12 38       	cp.w	r8,r9
80005c8e:	e0 88 00 0a 	brls	80005ca2 <vTaskIncrementTick+0xa2>
80005c92:	49 b9       	lddpc	r9,80005cfc <vTaskIncrementTick+0xfc>
80005c94:	93 08       	st.w	r9[0x0],r8
80005c96:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005c9a:	49 a4       	lddpc	r4,80005d00 <vTaskIncrementTick+0x100>
80005c9c:	49 a3       	lddpc	r3,80005d04 <vTaskIncrementTick+0x104>
80005c9e:	49 55       	lddpc	r5,80005cf0 <vTaskIncrementTick+0xf0>
80005ca0:	49 32       	lddpc	r2,80005cec <vTaskIncrementTick+0xec>
80005ca2:	ee c6 ff fc 	sub	r6,r7,-4
80005ca6:	0c 9c       	mov	r12,r6
80005ca8:	f0 1f 00 18 	mcall	80005d08 <vTaskIncrementTick+0x108>
80005cac:	6e a8       	ld.w	r8,r7[0x28]
80005cae:	58 08       	cp.w	r8,0
80005cb0:	c0 50       	breq	80005cba <vTaskIncrementTick+0xba>
80005cb2:	ee cc ff e8 	sub	r12,r7,-24
80005cb6:	f0 1f 00 15 	mcall	80005d08 <vTaskIncrementTick+0x108>
80005cba:	6e bc       	ld.w	r12,r7[0x2c]
80005cbc:	68 08       	ld.w	r8,r4[0x0]
80005cbe:	10 3c       	cp.w	r12,r8
80005cc0:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005cc4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005cc8:	0c 9b       	mov	r11,r6
80005cca:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005cce:	f0 1f 00 10 	mcall	80005d0c <vTaskIncrementTick+0x10c>
80005cd2:	6a 08       	ld.w	r8,r5[0x0]
80005cd4:	70 08       	ld.w	r8,r8[0x0]
80005cd6:	58 08       	cp.w	r8,0
80005cd8:	cd 51       	brne	80005c82 <vTaskIncrementTick+0x82>
80005cda:	cc fb       	rjmp	80005c78 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005cdc:	48 d8       	lddpc	r8,80005d10 <vTaskIncrementTick+0x110>
80005cde:	70 09       	ld.w	r9,r8[0x0]
80005ce0:	2f f9       	sub	r9,-1
80005ce2:	91 09       	st.w	r8[0x0],r9
80005ce4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005ce8:	00 00       	add	r0,r0
80005cea:	0d 34       	ld.ub	r4,r6++
80005cec:	00 00       	add	r0,r0
80005cee:	0d 30       	ld.ub	r0,r6++
80005cf0:	00 00       	add	r0,r0
80005cf2:	0c 3c       	cp.w	r12,r6
80005cf4:	00 00       	add	r0,r0
80005cf6:	0c 4c       	or	r12,r6
80005cf8:	00 00       	add	r0,r0
80005cfa:	0c 48       	or	r8,r6
80005cfc:	00 00       	add	r0,r0
80005cfe:	05 34       	ld.ub	r4,r2++
80005d00:	00 00       	add	r0,r0
80005d02:	0d 6c       	ld.uh	r12,--r6
80005d04:	00 00       	add	r0,r0
80005d06:	0c 50       	eor	r0,r6
80005d08:	80 00       	ld.sh	r0,r0[0x0]
80005d0a:	51 a6       	stdsp	sp[0x68],r6
80005d0c:	80 00       	ld.sh	r0,r0[0x0]
80005d0e:	51 56       	stdsp	sp[0x54],r6
80005d10:	00 00       	add	r0,r0
80005d12:	0c 34       	cp.w	r4,r6

80005d14 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80005d14:	eb cd 40 c0 	pushm	r6-r7,lr
80005d18:	18 97       	mov	r7,r12
80005d1a:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80005d1c:	f0 1f 00 15 	mcall	80005d70 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005d20:	6c 08       	ld.w	r8,r6[0x0]
80005d22:	5b f8       	cp.w	r8,-1
80005d24:	c0 31       	brne	80005d2a <xTaskCheckForTimeOut+0x16>
80005d26:	30 07       	mov	r7,0
80005d28:	c1 f8       	rjmp	80005d66 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80005d2a:	49 39       	lddpc	r9,80005d74 <xTaskCheckForTimeOut+0x60>
80005d2c:	72 09       	ld.w	r9,r9[0x0]
80005d2e:	6e 0a       	ld.w	r10,r7[0x0]
80005d30:	12 3a       	cp.w	r10,r9
80005d32:	c0 70       	breq	80005d40 <xTaskCheckForTimeOut+0x2c>
80005d34:	49 19       	lddpc	r9,80005d78 <xTaskCheckForTimeOut+0x64>
80005d36:	72 09       	ld.w	r9,r9[0x0]
80005d38:	6e 1a       	ld.w	r10,r7[0x4]
80005d3a:	12 3a       	cp.w	r10,r9
80005d3c:	e0 88 00 14 	brls	80005d64 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80005d40:	48 e9       	lddpc	r9,80005d78 <xTaskCheckForTimeOut+0x64>
80005d42:	72 0a       	ld.w	r10,r9[0x0]
80005d44:	6e 19       	ld.w	r9,r7[0x4]
80005d46:	12 1a       	sub	r10,r9
80005d48:	14 38       	cp.w	r8,r10
80005d4a:	e0 88 00 0d 	brls	80005d64 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80005d4e:	48 ba       	lddpc	r10,80005d78 <xTaskCheckForTimeOut+0x64>
80005d50:	74 0a       	ld.w	r10,r10[0x0]
80005d52:	14 19       	sub	r9,r10
80005d54:	f2 08 00 08 	add	r8,r9,r8
80005d58:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80005d5a:	0e 9c       	mov	r12,r7
80005d5c:	f0 1f 00 08 	mcall	80005d7c <xTaskCheckForTimeOut+0x68>
80005d60:	30 07       	mov	r7,0
80005d62:	c0 28       	rjmp	80005d66 <xTaskCheckForTimeOut+0x52>
80005d64:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80005d66:	f0 1f 00 07 	mcall	80005d80 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80005d6a:	0e 9c       	mov	r12,r7
80005d6c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005d70:	80 00       	ld.sh	r0,r0[0x0]
80005d72:	52 60       	stdsp	sp[0x98],r0
80005d74:	00 00       	add	r0,r0
80005d76:	0c 48       	or	r8,r6
80005d78:	00 00       	add	r0,r0
80005d7a:	0d 30       	ld.ub	r0,r6++
80005d7c:	80 00       	ld.sh	r0,r0[0x0]
80005d7e:	5a 78       	cp.w	r8,-25
80005d80:	80 00       	ld.sh	r0,r0[0x0]
80005d82:	53 6c       	stdsp	sp[0xd8],r12

80005d84 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005d84:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005d88:	f0 1f 00 05 	mcall	80005d9c <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80005d8c:	48 58       	lddpc	r8,80005da0 <xTaskGetTickCount+0x1c>
80005d8e:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80005d90:	f0 1f 00 05 	mcall	80005da4 <xTaskGetTickCount+0x20>

	return xTicks;
}
80005d94:	0e 9c       	mov	r12,r7
80005d96:	e3 cd 80 80 	ldm	sp++,r7,pc
80005d9a:	00 00       	add	r0,r0
80005d9c:	80 00       	ld.sh	r0,r0[0x0]
80005d9e:	52 60       	stdsp	sp[0x98],r0
80005da0:	00 00       	add	r0,r0
80005da2:	0d 30       	ld.ub	r0,r6++
80005da4:	80 00       	ld.sh	r0,r0[0x0]
80005da6:	53 6c       	stdsp	sp[0xd8],r12

80005da8 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005da8:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005dac:	f0 1f 00 2c 	mcall	80005e5c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80005db0:	4a c8       	lddpc	r8,80005e60 <xTaskResumeAll+0xb8>
80005db2:	70 09       	ld.w	r9,r8[0x0]
80005db4:	20 19       	sub	r9,1
80005db6:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005db8:	70 08       	ld.w	r8,r8[0x0]
80005dba:	58 08       	cp.w	r8,0
80005dbc:	c4 91       	brne	80005e4e <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005dbe:	4a a8       	lddpc	r8,80005e64 <xTaskResumeAll+0xbc>
80005dc0:	70 08       	ld.w	r8,r8[0x0]
80005dc2:	58 08       	cp.w	r8,0
80005dc4:	c4 50       	breq	80005e4e <xTaskResumeAll+0xa6>
80005dc6:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005dc8:	4a 85       	lddpc	r5,80005e68 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80005dca:	4a 93       	lddpc	r3,80005e6c <xTaskResumeAll+0xc4>
80005dcc:	4a 92       	lddpc	r2,80005e70 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005dce:	4a a1       	lddpc	r1,80005e74 <xTaskResumeAll+0xcc>
80005dd0:	c1 e8       	rjmp	80005e0c <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005dd2:	6a 38       	ld.w	r8,r5[0xc]
80005dd4:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80005dd6:	ee cc ff e8 	sub	r12,r7,-24
80005dda:	f0 1f 00 28 	mcall	80005e78 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005dde:	ee c6 ff fc 	sub	r6,r7,-4
80005de2:	0c 9c       	mov	r12,r6
80005de4:	f0 1f 00 25 	mcall	80005e78 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80005de8:	6e bc       	ld.w	r12,r7[0x2c]
80005dea:	66 08       	ld.w	r8,r3[0x0]
80005dec:	10 3c       	cp.w	r12,r8
80005dee:	e7 fc ba 00 	st.whi	r3[0x0],r12
80005df2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005df6:	0c 9b       	mov	r11,r6
80005df8:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80005dfc:	f0 1f 00 20 	mcall	80005e7c <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005e00:	62 08       	ld.w	r8,r1[0x0]
80005e02:	6e b9       	ld.w	r9,r7[0x2c]
80005e04:	70 b8       	ld.w	r8,r8[0x2c]
80005e06:	10 39       	cp.w	r9,r8
80005e08:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005e0c:	6a 08       	ld.w	r8,r5[0x0]
80005e0e:	58 08       	cp.w	r8,0
80005e10:	ce 11       	brne	80005dd2 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005e12:	49 c8       	lddpc	r8,80005e80 <xTaskResumeAll+0xd8>
80005e14:	70 08       	ld.w	r8,r8[0x0]
80005e16:	58 08       	cp.w	r8,0
80005e18:	c0 f0       	breq	80005e36 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005e1a:	49 a8       	lddpc	r8,80005e80 <xTaskResumeAll+0xd8>
80005e1c:	70 08       	ld.w	r8,r8[0x0]
80005e1e:	58 08       	cp.w	r8,0
80005e20:	c1 10       	breq	80005e42 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80005e22:	49 87       	lddpc	r7,80005e80 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80005e24:	f0 1f 00 18 	mcall	80005e84 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80005e28:	6e 08       	ld.w	r8,r7[0x0]
80005e2a:	20 18       	sub	r8,1
80005e2c:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005e2e:	6e 08       	ld.w	r8,r7[0x0]
80005e30:	58 08       	cp.w	r8,0
80005e32:	cf 91       	brne	80005e24 <xTaskResumeAll+0x7c>
80005e34:	c0 78       	rjmp	80005e42 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80005e36:	58 14       	cp.w	r4,1
80005e38:	c0 50       	breq	80005e42 <xTaskResumeAll+0x9a>
80005e3a:	49 48       	lddpc	r8,80005e88 <xTaskResumeAll+0xe0>
80005e3c:	70 08       	ld.w	r8,r8[0x0]
80005e3e:	58 18       	cp.w	r8,1
80005e40:	c0 71       	brne	80005e4e <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80005e42:	30 09       	mov	r9,0
80005e44:	49 18       	lddpc	r8,80005e88 <xTaskResumeAll+0xe0>
80005e46:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005e48:	d7 33       	scall
80005e4a:	30 17       	mov	r7,1
80005e4c:	c0 28       	rjmp	80005e50 <xTaskResumeAll+0xa8>
80005e4e:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005e50:	f0 1f 00 0f 	mcall	80005e8c <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005e54:	0e 9c       	mov	r12,r7
80005e56:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80005e5a:	00 00       	add	r0,r0
80005e5c:	80 00       	ld.sh	r0,r0[0x0]
80005e5e:	52 60       	stdsp	sp[0x98],r0
80005e60:	00 00       	add	r0,r0
80005e62:	0d 34       	ld.ub	r4,r6++
80005e64:	00 00       	add	r0,r0
80005e66:	0d 50       	ld.sh	r0,--r6
80005e68:	00 00       	add	r0,r0
80005e6a:	0d 08       	ld.w	r8,r6++
80005e6c:	00 00       	add	r0,r0
80005e6e:	0d 6c       	ld.uh	r12,--r6
80005e70:	00 00       	add	r0,r0
80005e72:	0c 50       	eor	r0,r6
80005e74:	00 00       	add	r0,r0
80005e76:	0d 04       	ld.w	r4,r6++
80005e78:	80 00       	ld.sh	r0,r0[0x0]
80005e7a:	51 a6       	stdsp	sp[0x68],r6
80005e7c:	80 00       	ld.sh	r0,r0[0x0]
80005e7e:	51 56       	stdsp	sp[0x54],r6
80005e80:	00 00       	add	r0,r0
80005e82:	0c 34       	cp.w	r4,r6
80005e84:	80 00       	ld.sh	r0,r0[0x0]
80005e86:	5c 00       	acr	r0
80005e88:	00 00       	add	r0,r0
80005e8a:	0d 54       	ld.sh	r4,--r6
80005e8c:	80 00       	ld.sh	r0,r0[0x0]
80005e8e:	53 6c       	stdsp	sp[0xd8],r12

80005e90 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80005e90:	eb cd 40 80 	pushm	r7,lr
80005e94:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005e96:	49 08       	lddpc	r8,80005ed4 <prvAddCurrentTaskToDelayedList+0x44>
80005e98:	70 08       	ld.w	r8,r8[0x0]
80005e9a:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80005e9c:	48 f8       	lddpc	r8,80005ed8 <prvAddCurrentTaskToDelayedList+0x48>
80005e9e:	70 08       	ld.w	r8,r8[0x0]
80005ea0:	10 3c       	cp.w	r12,r8
80005ea2:	c0 a2       	brcc	80005eb6 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005ea4:	48 c8       	lddpc	r8,80005ed4 <prvAddCurrentTaskToDelayedList+0x44>
80005ea6:	70 0b       	ld.w	r11,r8[0x0]
80005ea8:	48 d8       	lddpc	r8,80005edc <prvAddCurrentTaskToDelayedList+0x4c>
80005eaa:	70 0c       	ld.w	r12,r8[0x0]
80005eac:	2f cb       	sub	r11,-4
80005eae:	f0 1f 00 0d 	mcall	80005ee0 <prvAddCurrentTaskToDelayedList+0x50>
80005eb2:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005eb6:	48 88       	lddpc	r8,80005ed4 <prvAddCurrentTaskToDelayedList+0x44>
80005eb8:	70 0b       	ld.w	r11,r8[0x0]
80005eba:	48 b8       	lddpc	r8,80005ee4 <prvAddCurrentTaskToDelayedList+0x54>
80005ebc:	70 0c       	ld.w	r12,r8[0x0]
80005ebe:	2f cb       	sub	r11,-4
80005ec0:	f0 1f 00 08 	mcall	80005ee0 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005ec4:	48 98       	lddpc	r8,80005ee8 <prvAddCurrentTaskToDelayedList+0x58>
80005ec6:	70 08       	ld.w	r8,r8[0x0]
80005ec8:	10 37       	cp.w	r7,r8
80005eca:	c0 32       	brcc	80005ed0 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005ecc:	48 78       	lddpc	r8,80005ee8 <prvAddCurrentTaskToDelayedList+0x58>
80005ece:	91 07       	st.w	r8[0x0],r7
80005ed0:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ed4:	00 00       	add	r0,r0
80005ed6:	0d 04       	ld.w	r4,r6++
80005ed8:	00 00       	add	r0,r0
80005eda:	0d 30       	ld.ub	r0,r6++
80005edc:	00 00       	add	r0,r0
80005ede:	0c 4c       	or	r12,r6
80005ee0:	80 00       	ld.sh	r0,r0[0x0]
80005ee2:	51 72       	stdsp	sp[0x5c],r2
80005ee4:	00 00       	add	r0,r0
80005ee6:	0c 3c       	cp.w	r12,r6
80005ee8:	00 00       	add	r0,r0
80005eea:	05 34       	ld.ub	r4,r2++

80005eec <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005eec:	eb cd 40 c0 	pushm	r6-r7,lr
80005ef0:	18 96       	mov	r6,r12
80005ef2:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80005ef4:	f0 1f 00 18 	mcall	80005f54 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005ef8:	6c 08       	ld.w	r8,r6[0x0]
80005efa:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005efc:	49 79       	lddpc	r9,80005f58 <vTaskDelayUntil+0x6c>
80005efe:	72 09       	ld.w	r9,r9[0x0]
80005f00:	12 38       	cp.w	r8,r9
80005f02:	e0 88 00 0c 	brls	80005f1a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005f06:	0e 38       	cp.w	r8,r7
80005f08:	e0 88 00 22 	brls	80005f4c <vTaskDelayUntil+0x60>
80005f0c:	49 38       	lddpc	r8,80005f58 <vTaskDelayUntil+0x6c>
80005f0e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005f10:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80005f12:	10 37       	cp.w	r7,r8
80005f14:	e0 88 00 14 	brls	80005f3c <vTaskDelayUntil+0x50>
80005f18:	c0 a8       	rjmp	80005f2c <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005f1a:	0e 38       	cp.w	r8,r7
80005f1c:	e0 8b 00 16 	brhi	80005f48 <vTaskDelayUntil+0x5c>
80005f20:	48 e8       	lddpc	r8,80005f58 <vTaskDelayUntil+0x6c>
80005f22:	70 08       	ld.w	r8,r8[0x0]
80005f24:	10 37       	cp.w	r7,r8
80005f26:	e0 8b 00 11 	brhi	80005f48 <vTaskDelayUntil+0x5c>
80005f2a:	c1 18       	rjmp	80005f4c <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005f2c:	48 c8       	lddpc	r8,80005f5c <vTaskDelayUntil+0x70>
80005f2e:	70 0c       	ld.w	r12,r8[0x0]
80005f30:	2f cc       	sub	r12,-4
80005f32:	f0 1f 00 0c 	mcall	80005f60 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005f36:	0e 9c       	mov	r12,r7
80005f38:	f0 1f 00 0b 	mcall	80005f64 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005f3c:	f0 1f 00 0b 	mcall	80005f68 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005f40:	c0 81       	brne	80005f50 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80005f42:	d7 33       	scall
80005f44:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005f48:	8d 07       	st.w	r6[0x0],r7
80005f4a:	cf 1b       	rjmp	80005f2c <vTaskDelayUntil+0x40>
80005f4c:	8d 07       	st.w	r6[0x0],r7
80005f4e:	cf 7b       	rjmp	80005f3c <vTaskDelayUntil+0x50>
80005f50:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005f54:	80 00       	ld.sh	r0,r0[0x0]
80005f56:	59 ec       	cp.w	r12,30
80005f58:	00 00       	add	r0,r0
80005f5a:	0d 30       	ld.ub	r0,r6++
80005f5c:	00 00       	add	r0,r0
80005f5e:	0d 04       	ld.w	r4,r6++
80005f60:	80 00       	ld.sh	r0,r0[0x0]
80005f62:	51 a6       	stdsp	sp[0x68],r6
80005f64:	80 00       	ld.sh	r0,r0[0x0]
80005f66:	5e 90       	retgt	r0
80005f68:	80 00       	ld.sh	r0,r0[0x0]
80005f6a:	5d a8       	*unknown*

80005f6c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80005f6c:	eb cd 40 c0 	pushm	r6-r7,lr
80005f70:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80005f72:	48 e7       	lddpc	r7,80005fa8 <vTaskPlaceOnEventList+0x3c>
80005f74:	6e 0b       	ld.w	r11,r7[0x0]
80005f76:	2e 8b       	sub	r11,-24
80005f78:	f0 1f 00 0d 	mcall	80005fac <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005f7c:	6e 0c       	ld.w	r12,r7[0x0]
80005f7e:	2f cc       	sub	r12,-4
80005f80:	f0 1f 00 0c 	mcall	80005fb0 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80005f84:	5b f6       	cp.w	r6,-1
80005f86:	c0 81       	brne	80005f96 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005f88:	6e 0b       	ld.w	r11,r7[0x0]
80005f8a:	2f cb       	sub	r11,-4
80005f8c:	48 ac       	lddpc	r12,80005fb4 <vTaskPlaceOnEventList+0x48>
80005f8e:	f0 1f 00 0b 	mcall	80005fb8 <vTaskPlaceOnEventList+0x4c>
80005f92:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80005f96:	48 a8       	lddpc	r8,80005fbc <vTaskPlaceOnEventList+0x50>
80005f98:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80005f9a:	ec 0c 00 0c 	add	r12,r6,r12
80005f9e:	f0 1f 00 09 	mcall	80005fc0 <vTaskPlaceOnEventList+0x54>
80005fa2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005fa6:	00 00       	add	r0,r0
80005fa8:	00 00       	add	r0,r0
80005faa:	0d 04       	ld.w	r4,r6++
80005fac:	80 00       	ld.sh	r0,r0[0x0]
80005fae:	51 72       	stdsp	sp[0x5c],r2
80005fb0:	80 00       	ld.sh	r0,r0[0x0]
80005fb2:	51 a6       	stdsp	sp[0x68],r6
80005fb4:	00 00       	add	r0,r0
80005fb6:	0d 58       	ld.sh	r8,--r6
80005fb8:	80 00       	ld.sh	r0,r0[0x0]
80005fba:	51 56       	stdsp	sp[0x54],r6
80005fbc:	00 00       	add	r0,r0
80005fbe:	0d 30       	ld.ub	r0,r6++
80005fc0:	80 00       	ld.sh	r0,r0[0x0]
80005fc2:	5e 90       	retgt	r0

80005fc4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80005fc4:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005fc8:	49 67       	lddpc	r7,80006020 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005fca:	49 74       	lddpc	r4,80006024 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005fcc:	49 73       	lddpc	r3,80006028 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005fce:	49 85       	lddpc	r5,8000602c <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005fd0:	6e 08       	ld.w	r8,r7[0x0]
80005fd2:	58 08       	cp.w	r8,0
80005fd4:	c1 e0       	breq	80006010 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80005fd6:	f0 1f 00 17 	mcall	80006030 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005fda:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005fdc:	f0 1f 00 16 	mcall	80006034 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80005fe0:	58 06       	cp.w	r6,0
80005fe2:	c1 70       	breq	80006010 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80005fe4:	f0 1f 00 15 	mcall	80006038 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80005fe8:	68 38       	ld.w	r8,r4[0xc]
80005fea:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80005fec:	ec cc ff fc 	sub	r12,r6,-4
80005ff0:	f0 1f 00 13 	mcall	8000603c <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80005ff4:	66 08       	ld.w	r8,r3[0x0]
80005ff6:	20 18       	sub	r8,1
80005ff8:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80005ffa:	6e 08       	ld.w	r8,r7[0x0]
80005ffc:	20 18       	sub	r8,1
80005ffe:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006000:	f0 1f 00 10 	mcall	80006040 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006004:	6c cc       	ld.w	r12,r6[0x30]
80006006:	f0 1f 00 10 	mcall	80006044 <prvIdleTask+0x80>
		vPortFree( pxTCB );
8000600a:	0c 9c       	mov	r12,r6
8000600c:	f0 1f 00 0e 	mcall	80006044 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006010:	6a 08       	ld.w	r8,r5[0x0]
80006012:	58 18       	cp.w	r8,1
80006014:	e0 88 00 03 	brls	8000601a <prvIdleTask+0x56>
			{
				taskYIELD();
80006018:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
8000601a:	f0 1f 00 0c 	mcall	80006048 <prvIdleTask+0x84>
		}
		#endif
	}
8000601e:	cd 9b       	rjmp	80005fd0 <prvIdleTask+0xc>
80006020:	00 00       	add	r0,r0
80006022:	0c 44       	or	r4,r6
80006024:	00 00       	add	r0,r0
80006026:	0c f0       	st.b	--r6,r0
80006028:	00 00       	add	r0,r0
8000602a:	0d 50       	ld.sh	r0,--r6
8000602c:	00 00       	add	r0,r0
8000602e:	0c 50       	eor	r0,r6
80006030:	80 00       	ld.sh	r0,r0[0x0]
80006032:	59 ec       	cp.w	r12,30
80006034:	80 00       	ld.sh	r0,r0[0x0]
80006036:	5d a8       	*unknown*
80006038:	80 00       	ld.sh	r0,r0[0x0]
8000603a:	52 60       	stdsp	sp[0x98],r0
8000603c:	80 00       	ld.sh	r0,r0[0x0]
8000603e:	51 a6       	stdsp	sp[0x68],r6
80006040:	80 00       	ld.sh	r0,r0[0x0]
80006042:	53 6c       	stdsp	sp[0xd8],r12
80006044:	80 00       	ld.sh	r0,r0[0x0]
80006046:	54 a4       	stdsp	sp[0x128],r4
80006048:	80 00       	ld.sh	r0,r0[0x0]
8000604a:	20 30       	sub	r0,3

8000604c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
8000604c:	d4 31       	pushm	r0-r7,lr
8000604e:	20 1d       	sub	sp,4
80006050:	fa c4 ff d8 	sub	r4,sp,-40
80006054:	50 0c       	stdsp	sp[0x0],r12
80006056:	16 91       	mov	r1,r11
80006058:	14 97       	mov	r7,r10
8000605a:	12 90       	mov	r0,r9
8000605c:	10 93       	mov	r3,r8
8000605e:	68 02       	ld.w	r2,r4[0x0]
80006060:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006062:	34 8c       	mov	r12,72
80006064:	f0 1f 00 5c 	mcall	800061d4 <xTaskGenericCreate+0x188>
80006068:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
8000606a:	c0 31       	brne	80006070 <xTaskGenericCreate+0x24>
8000606c:	3f fc       	mov	r12,-1
8000606e:	ca f8       	rjmp	800061cc <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006070:	58 06       	cp.w	r6,0
80006072:	e0 81 00 af 	brne	800061d0 <xTaskGenericCreate+0x184>
80006076:	0e 9c       	mov	r12,r7
80006078:	5c 7c       	castu.h	r12
8000607a:	a3 6c       	lsl	r12,0x2
8000607c:	f0 1f 00 56 	mcall	800061d4 <xTaskGenericCreate+0x188>
80006080:	18 96       	mov	r6,r12
80006082:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006084:	c0 61       	brne	80006090 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006086:	0a 9c       	mov	r12,r5
80006088:	f0 1f 00 54 	mcall	800061d8 <xTaskGenericCreate+0x18c>
8000608c:	3f fc       	mov	r12,-1
8000608e:	c9 f8       	rjmp	800061cc <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006090:	5c 77       	castu.h	r7
80006092:	ee 0a 15 02 	lsl	r10,r7,0x2
80006096:	e0 6b 00 a5 	mov	r11,165
8000609a:	0c 9c       	mov	r12,r6
8000609c:	f0 1f 00 50 	mcall	800061dc <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
800060a0:	ee c6 00 01 	sub	r6,r7,1
800060a4:	6a c8       	ld.w	r8,r5[0x30]
800060a6:	f0 06 00 26 	add	r6,r8,r6<<0x2
800060aa:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800060ae:	31 0a       	mov	r10,16
800060b0:	02 9b       	mov	r11,r1
800060b2:	ea cc ff cc 	sub	r12,r5,-52
800060b6:	f0 1f 00 4b 	mcall	800061e0 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800060ba:	30 08       	mov	r8,0
800060bc:	eb 68 00 43 	st.b	r5[67],r8
800060c0:	58 73       	cp.w	r3,7
800060c2:	e6 07 17 80 	movls	r7,r3
800060c6:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
800060ca:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
800060cc:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
800060d0:	ea c4 ff fc 	sub	r4,r5,-4
800060d4:	08 9c       	mov	r12,r4
800060d6:	f0 1f 00 44 	mcall	800061e4 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
800060da:	ea cc ff e8 	sub	r12,r5,-24
800060de:	f0 1f 00 42 	mcall	800061e4 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
800060e2:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
800060e4:	ee 07 11 08 	rsub	r7,r7,8
800060e8:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
800060ea:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
800060ec:	00 9a       	mov	r10,r0
800060ee:	40 0b       	lddsp	r11,sp[0x0]
800060f0:	0c 9c       	mov	r12,r6
800060f2:	f0 1f 00 3e 	mcall	800061e8 <xTaskGenericCreate+0x19c>
800060f6:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
800060f8:	58 02       	cp.w	r2,0
800060fa:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
800060fe:	f0 1f 00 3c 	mcall	800061ec <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006102:	4b c8       	lddpc	r8,800061f0 <xTaskGenericCreate+0x1a4>
80006104:	70 09       	ld.w	r9,r8[0x0]
80006106:	2f f9       	sub	r9,-1
80006108:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
8000610a:	4b b8       	lddpc	r8,800061f4 <xTaskGenericCreate+0x1a8>
8000610c:	70 08       	ld.w	r8,r8[0x0]
8000610e:	58 08       	cp.w	r8,0
80006110:	c2 61       	brne	8000615c <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006112:	4b 98       	lddpc	r8,800061f4 <xTaskGenericCreate+0x1a8>
80006114:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006116:	4b 78       	lddpc	r8,800061f0 <xTaskGenericCreate+0x1a4>
80006118:	70 08       	ld.w	r8,r8[0x0]
8000611a:	58 18       	cp.w	r8,1
8000611c:	c2 b1       	brne	80006172 <xTaskGenericCreate+0x126>
8000611e:	4b 77       	lddpc	r7,800061f8 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006120:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006124:	0e 9c       	mov	r12,r7
80006126:	f0 1f 00 36 	mcall	800061fc <xTaskGenericCreate+0x1b0>
8000612a:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
8000612c:	0c 37       	cp.w	r7,r6
8000612e:	cf b1       	brne	80006124 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006130:	4b 47       	lddpc	r7,80006200 <xTaskGenericCreate+0x1b4>
80006132:	0e 9c       	mov	r12,r7
80006134:	f0 1f 00 32 	mcall	800061fc <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006138:	4b 36       	lddpc	r6,80006204 <xTaskGenericCreate+0x1b8>
8000613a:	0c 9c       	mov	r12,r6
8000613c:	f0 1f 00 30 	mcall	800061fc <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006140:	4b 2c       	lddpc	r12,80006208 <xTaskGenericCreate+0x1bc>
80006142:	f0 1f 00 2f 	mcall	800061fc <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006146:	4b 2c       	lddpc	r12,8000620c <xTaskGenericCreate+0x1c0>
80006148:	f0 1f 00 2d 	mcall	800061fc <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
8000614c:	4b 1c       	lddpc	r12,80006210 <xTaskGenericCreate+0x1c4>
8000614e:	f0 1f 00 2c 	mcall	800061fc <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006152:	4b 18       	lddpc	r8,80006214 <xTaskGenericCreate+0x1c8>
80006154:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006156:	4b 18       	lddpc	r8,80006218 <xTaskGenericCreate+0x1cc>
80006158:	91 06       	st.w	r8[0x0],r6
8000615a:	c0 c8       	rjmp	80006172 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
8000615c:	4b 08       	lddpc	r8,8000621c <xTaskGenericCreate+0x1d0>
8000615e:	70 08       	ld.w	r8,r8[0x0]
80006160:	58 08       	cp.w	r8,0
80006162:	c0 81       	brne	80006172 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006164:	4a 48       	lddpc	r8,800061f4 <xTaskGenericCreate+0x1a8>
80006166:	70 08       	ld.w	r8,r8[0x0]
80006168:	70 b8       	ld.w	r8,r8[0x2c]
8000616a:	10 33       	cp.w	r3,r8
8000616c:	c0 33       	brcs	80006172 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
8000616e:	4a 28       	lddpc	r8,800061f4 <xTaskGenericCreate+0x1a8>
80006170:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006172:	6a b8       	ld.w	r8,r5[0x2c]
80006174:	4a b9       	lddpc	r9,80006220 <xTaskGenericCreate+0x1d4>
80006176:	72 09       	ld.w	r9,r9[0x0]
80006178:	12 38       	cp.w	r8,r9
8000617a:	e0 88 00 04 	brls	80006182 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
8000617e:	4a 99       	lddpc	r9,80006220 <xTaskGenericCreate+0x1d4>
80006180:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006182:	4a 98       	lddpc	r8,80006224 <xTaskGenericCreate+0x1d8>
80006184:	70 09       	ld.w	r9,r8[0x0]
80006186:	2f f9       	sub	r9,-1
80006188:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
8000618a:	6a b8       	ld.w	r8,r5[0x2c]
8000618c:	4a 79       	lddpc	r9,80006228 <xTaskGenericCreate+0x1dc>
8000618e:	72 09       	ld.w	r9,r9[0x0]
80006190:	12 38       	cp.w	r8,r9
80006192:	e0 88 00 04 	brls	8000619a <xTaskGenericCreate+0x14e>
80006196:	4a 59       	lddpc	r9,80006228 <xTaskGenericCreate+0x1dc>
80006198:	93 08       	st.w	r9[0x0],r8
8000619a:	6a bc       	ld.w	r12,r5[0x2c]
8000619c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800061a0:	08 9b       	mov	r11,r4
800061a2:	49 68       	lddpc	r8,800061f8 <xTaskGenericCreate+0x1ac>
800061a4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800061a8:	f0 1f 00 21 	mcall	8000622c <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
800061ac:	f0 1f 00 21 	mcall	80006230 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
800061b0:	49 b8       	lddpc	r8,8000621c <xTaskGenericCreate+0x1d0>
800061b2:	70 08       	ld.w	r8,r8[0x0]
800061b4:	58 08       	cp.w	r8,0
800061b6:	c0 a0       	breq	800061ca <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
800061b8:	48 f8       	lddpc	r8,800061f4 <xTaskGenericCreate+0x1a8>
800061ba:	70 08       	ld.w	r8,r8[0x0]
800061bc:	70 b8       	ld.w	r8,r8[0x2c]
800061be:	10 33       	cp.w	r3,r8
800061c0:	e0 88 00 05 	brls	800061ca <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
800061c4:	d7 33       	scall
800061c6:	30 1c       	mov	r12,1
800061c8:	c0 28       	rjmp	800061cc <xTaskGenericCreate+0x180>
800061ca:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
800061cc:	2f fd       	sub	sp,-4
800061ce:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800061d0:	99 c6       	st.w	r12[0x30],r6
800061d2:	c5 fb       	rjmp	80006090 <xTaskGenericCreate+0x44>
800061d4:	80 00       	ld.sh	r0,r0[0x0]
800061d6:	54 cc       	stdsp	sp[0x130],r12
800061d8:	80 00       	ld.sh	r0,r0[0x0]
800061da:	54 a4       	stdsp	sp[0x128],r4
800061dc:	80 00       	ld.sh	r0,r0[0x0]
800061de:	6e b8       	ld.w	r8,r7[0x2c]
800061e0:	80 00       	ld.sh	r0,r0[0x0]
800061e2:	71 fc       	ld.w	r12,r8[0x7c]
800061e4:	80 00       	ld.sh	r0,r0[0x0]
800061e6:	51 50       	stdsp	sp[0x54],r0
800061e8:	80 00       	ld.sh	r0,r0[0x0]
800061ea:	51 cc       	stdsp	sp[0x70],r12
800061ec:	80 00       	ld.sh	r0,r0[0x0]
800061ee:	52 60       	stdsp	sp[0x98],r0
800061f0:	00 00       	add	r0,r0
800061f2:	0d 50       	ld.sh	r0,--r6
800061f4:	00 00       	add	r0,r0
800061f6:	0d 04       	ld.w	r4,r6++
800061f8:	00 00       	add	r0,r0
800061fa:	0c 50       	eor	r0,r6
800061fc:	80 00       	ld.sh	r0,r0[0x0]
800061fe:	51 3c       	stdsp	sp[0x4c],r12
80006200:	00 00       	add	r0,r0
80006202:	0d 1c       	ld.sh	r12,r6++
80006204:	00 00       	add	r0,r0
80006206:	0d 38       	ld.ub	r8,r6++
80006208:	00 00       	add	r0,r0
8000620a:	0d 08       	ld.w	r8,r6++
8000620c:	00 00       	add	r0,r0
8000620e:	0c f0       	st.b	--r6,r0
80006210:	00 00       	add	r0,r0
80006212:	0d 58       	ld.sh	r8,--r6
80006214:	00 00       	add	r0,r0
80006216:	0c 3c       	cp.w	r12,r6
80006218:	00 00       	add	r0,r0
8000621a:	0c 4c       	or	r12,r6
8000621c:	00 00       	add	r0,r0
8000621e:	0c 40       	or	r0,r6
80006220:	00 00       	add	r0,r0
80006222:	0c 38       	cp.w	r8,r6
80006224:	00 00       	add	r0,r0
80006226:	0d 4c       	ld.w	r12,--r6
80006228:	00 00       	add	r0,r0
8000622a:	0d 6c       	ld.uh	r12,--r6
8000622c:	80 00       	ld.sh	r0,r0[0x0]
8000622e:	51 56       	stdsp	sp[0x54],r6
80006230:	80 00       	ld.sh	r0,r0[0x0]
80006232:	53 6c       	stdsp	sp[0xd8],r12

80006234 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006234:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006236:	30 09       	mov	r9,0
80006238:	1a d9       	st.w	--sp,r9
8000623a:	1a d9       	st.w	--sp,r9
8000623c:	1a d9       	st.w	--sp,r9
8000623e:	12 98       	mov	r8,r9
80006240:	e0 6a 01 00 	mov	r10,256
80006244:	48 9b       	lddpc	r11,80006268 <vTaskStartScheduler+0x34>
80006246:	48 ac       	lddpc	r12,8000626c <vTaskStartScheduler+0x38>
80006248:	f0 1f 00 0a 	mcall	80006270 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
8000624c:	2f dd       	sub	sp,-12
8000624e:	58 1c       	cp.w	r12,1
80006250:	c0 a1       	brne	80006264 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006252:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006254:	30 19       	mov	r9,1
80006256:	48 88       	lddpc	r8,80006274 <vTaskStartScheduler+0x40>
80006258:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
8000625a:	30 09       	mov	r9,0
8000625c:	48 78       	lddpc	r8,80006278 <vTaskStartScheduler+0x44>
8000625e:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006260:	f0 1f 00 07 	mcall	8000627c <vTaskStartScheduler+0x48>
80006264:	d8 02       	popm	pc
80006266:	00 00       	add	r0,r0
80006268:	80 00       	ld.sh	r0,r0[0x0]
8000626a:	d2 70       	acall	0x27
8000626c:	80 00       	ld.sh	r0,r0[0x0]
8000626e:	5f c4       	srvs	r4
80006270:	80 00       	ld.sh	r0,r0[0x0]
80006272:	60 4c       	ld.w	r12,r0[0x10]
80006274:	00 00       	add	r0,r0
80006276:	0c 40       	or	r0,r6
80006278:	00 00       	add	r0,r0
8000627a:	0d 30       	ld.ub	r0,r6++
8000627c:	80 00       	ld.sh	r0,r0[0x0]
8000627e:	52 70       	stdsp	sp[0x9c],r0

80006280 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006280:	16 cc       	st.b	r11++,r12
	return str;
}
80006282:	5e fb       	retal	r11

80006284 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006284:	eb cd 40 c0 	pushm	r6-r7,lr
80006288:	20 3d       	sub	sp,12
8000628a:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
8000628c:	30 06       	mov	r6,0
8000628e:	30 07       	mov	r7,0
80006290:	fa e7 00 00 	st.d	sp[0],r6
80006294:	30 0c       	mov	r12,0
80006296:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006298:	58 08       	cp.w	r8,0
8000629a:	c1 30       	breq	800062c0 <PrintHex+0x3c>
8000629c:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
8000629e:	1a 9c       	mov	r12,sp
800062a0:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800062a4:	58 9e       	cp.w	lr,9
800062a6:	e0 8a 00 04 	brle	800062ae <PrintHex+0x2a>
800062aa:	2c 9e       	sub	lr,-55
800062ac:	c0 48       	rjmp	800062b4 <PrintHex+0x30>
800062ae:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800062b2:	2d 0e       	sub	lr,-48
800062b4:	f8 09 0b 0e 	st.b	r12[r9],lr
800062b8:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
800062ba:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
800062bc:	cf 21       	brne	800062a0 <PrintHex+0x1c>
800062be:	c0 48       	rjmp	800062c6 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
800062c0:	33 08       	mov	r8,48
800062c2:	ba 88       	st.b	sp[0x0],r8
800062c4:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
800062c6:	f6 09 01 08 	sub	r8,r11,r9
800062ca:	58 08       	cp.w	r8,0
800062cc:	e0 8a 00 13 	brle	800062f2 <PrintHex+0x6e>
	{
		char num = len - cnt;
800062d0:	12 1b       	sub	r11,r9
800062d2:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
800062d6:	18 9e       	mov	lr,r12
800062d8:	58 0c       	cp.w	r12,0
800062da:	e0 8a 00 0c 	brle	800062f2 <PrintHex+0x6e>
800062de:	1a 9b       	mov	r11,sp
800062e0:	12 0b       	add	r11,r9
800062e2:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
800062e4:	33 07       	mov	r7,48
800062e6:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
800062e8:	2f f8       	sub	r8,-1
800062ea:	1c 38       	cp.w	r8,lr
800062ec:	cf d5       	brlt	800062e6 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
800062ee:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
800062f2:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
800062f6:	f0 cb ff ff 	sub	r11,r8,-1
800062fa:	58 0b       	cp.w	r11,0
800062fc:	e0 8a 00 19 	brle	8000632e <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006300:	fa cb ff f4 	sub	r11,sp,-12
80006304:	f6 09 00 09 	add	r9,r11,r9
80006308:	37 8b       	mov	r11,120
8000630a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
8000630e:	fa c9 ff f4 	sub	r9,sp,-12
80006312:	10 09       	add	r9,r8
80006314:	33 0b       	mov	r11,48
80006316:	f3 6b ff f4 	st.b	r9[-12],r11
8000631a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000631e:	fa ce 00 01 	sub	lr,sp,1
80006322:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006324:	11 8b       	ld.ub	r11,r8[0x0]
80006326:	12 cb       	st.b	r9++,r11
80006328:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
8000632a:	1c 38       	cp.w	r8,lr
8000632c:	cf c1       	brne	80006324 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
8000632e:	14 9c       	mov	r12,r10
80006330:	2f dd       	sub	sp,-12
80006332:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006336 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006336:	d4 21       	pushm	r4-r7,lr
80006338:	20 3d       	sub	sp,12
8000633a:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
8000633c:	30 06       	mov	r6,0
8000633e:	30 07       	mov	r7,0
80006340:	fa e7 00 00 	st.d	sp[0],r6
80006344:	30 0c       	mov	r12,0
80006346:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006348:	58 08       	cp.w	r8,0
8000634a:	c0 35       	brlt	80006350 <PrintDec+0x1a>
8000634c:	14 97       	mov	r7,r10
8000634e:	c0 58       	rjmp	80006358 <PrintDec+0x22>
	{
		*p++ = '-';
80006350:	14 97       	mov	r7,r10
80006352:	32 d9       	mov	r9,45
80006354:	0e c9       	st.b	r7++,r9
		i = -i;
80006356:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006358:	58 08       	cp.w	r8,0
8000635a:	c0 51       	brne	80006364 <PrintDec+0x2e>
8000635c:	33 08       	mov	r8,48
8000635e:	ba 88       	st.b	sp[0x0],r8
80006360:	30 1e       	mov	lr,1
80006362:	c2 f8       	rjmp	800063c0 <PrintDec+0x8a>
	
	int ten = i%10;
80006364:	e0 65 66 67 	mov	r5,26215
80006368:	ea 15 66 66 	orh	r5,0x6666
8000636c:	f0 05 04 44 	muls.d	r4,r8,r5
80006370:	ea 0c 14 02 	asr	r12,r5,0x2
80006374:	f0 09 14 1f 	asr	r9,r8,0x1f
80006378:	f8 09 01 09 	sub	r9,r12,r9
8000637c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006380:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006384:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006386:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006388:	e0 66 66 67 	mov	r6,26215
8000638c:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006390:	2d 09       	sub	r9,-48
80006392:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006396:	2f fe       	sub	lr,-1
		i /= 10;
80006398:	f0 06 04 44 	muls.d	r4,r8,r6
8000639c:	ea 09 14 02 	asr	r9,r5,0x2
800063a0:	bf 58       	asr	r8,0x1f
800063a2:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
800063a6:	f0 06 04 44 	muls.d	r4,r8,r6
800063aa:	ea 09 14 02 	asr	r9,r5,0x2
800063ae:	f0 05 14 1f 	asr	r5,r8,0x1f
800063b2:	0a 19       	sub	r9,r5
800063b4:	f2 09 00 29 	add	r9,r9,r9<<0x2
800063b8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
800063bc:	58 08       	cp.w	r8,0
800063be:	ce 91       	brne	80006390 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
800063c0:	f6 0e 01 08 	sub	r8,r11,lr
800063c4:	58 08       	cp.w	r8,0
800063c6:	e0 89 00 06 	brgt	800063d2 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
800063ca:	58 0e       	cp.w	lr,0
800063cc:	e0 89 00 14 	brgt	800063f4 <PrintDec+0xbe>
800063d0:	c1 d8       	rjmp	8000640a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
800063d2:	1c 1b       	sub	r11,lr
800063d4:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
800063d6:	16 9c       	mov	r12,r11
800063d8:	58 0b       	cp.w	r11,0
800063da:	fe 9a ff f8 	brle	800063ca <PrintDec+0x94>
800063de:	1a 99       	mov	r9,sp
800063e0:	1c 09       	add	r9,lr
800063e2:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
800063e4:	33 06       	mov	r6,48
800063e6:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
800063e8:	2f f8       	sub	r8,-1
800063ea:	18 38       	cp.w	r8,r12
800063ec:	cf d5       	brlt	800063e6 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
800063ee:	f6 0e 00 0e 	add	lr,r11,lr
800063f2:	ce cb       	rjmp	800063ca <PrintDec+0x94>
800063f4:	fa c8 ff f4 	sub	r8,sp,-12
800063f8:	1c 08       	add	r8,lr
800063fa:	20 d8       	sub	r8,13
800063fc:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006400:	11 89       	ld.ub	r9,r8[0x0]
80006402:	0e c9       	st.b	r7++,r9
80006404:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006406:	16 38       	cp.w	r8,r11
80006408:	cf c1       	brne	80006400 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
8000640a:	14 9c       	mov	r12,r10
8000640c:	2f dd       	sub	sp,-12
8000640e:	d8 22       	popm	r4-r7,pc

80006410 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006410:	d4 31       	pushm	r0-r7,lr
80006412:	fa cd 02 08 	sub	sp,sp,520
80006416:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006418:	e0 6a 01 00 	mov	r10,256
8000641c:	30 0b       	mov	r11,0
8000641e:	fa cc fe f8 	sub	r12,sp,-264
80006422:	f0 1f 00 4e 	mcall	80006558 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006426:	fa c4 fd d4 	sub	r4,sp,-556
8000642a:	30 0a       	mov	r10,0
8000642c:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000642e:	fa c3 ff fc 	sub	r3,sp,-4
80006432:	e0 61 01 00 	mov	r1,256
80006436:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006438:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000643a:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000643e:	02 9a       	mov	r10,r1
80006440:	00 9b       	mov	r11,r0
80006442:	06 9c       	mov	r12,r3
80006444:	f0 1f 00 45 	mcall	80006558 <log+0x148>
			
					if(*str == '%')
80006448:	0f 88       	ld.ub	r8,r7[0x0]
8000644a:	e4 08 18 00 	cp.b	r8,r2
8000644e:	c5 71       	brne	800064fc <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006450:	ee c8 ff ff 	sub	r8,r7,-1
80006454:	11 89       	ld.ub	r9,r8[0x0]
80006456:	4c 2a       	lddpc	r10,8000655c <log+0x14c>
80006458:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
8000645a:	23 09       	sub	r9,48
8000645c:	30 9a       	mov	r10,9
8000645e:	f4 09 18 00 	cp.b	r9,r10
80006462:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006466:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000646a:	f7 b9 08 30 	subls	r9,48
8000646e:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006472:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006476:	0f 88       	ld.ub	r8,r7[0x0]
80006478:	22 58       	sub	r8,37
8000647a:	e0 48 00 53 	cp.w	r8,83
8000647e:	e0 8b 00 31 	brhi	800064e0 <log+0xd0>
80006482:	4b 89       	lddpc	r9,80006560 <log+0x150>
80006484:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006488:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
8000648c:	06 9a       	mov	r10,r3
8000648e:	40 0b       	lddsp	r11,sp[0x0]
80006490:	5c 5b       	castu.b	r11
80006492:	68 0c       	ld.w	r12,r4[0x0]
80006494:	f0 1f 00 34 	mcall	80006564 <log+0x154>
							break;
80006498:	c2 98       	rjmp	800064ea <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
8000649a:	4b 4c       	lddpc	r12,80006568 <log+0x158>
8000649c:	f0 1f 00 34 	mcall	8000656c <log+0x15c>
800064a0:	08 95       	mov	r5,r4
800064a2:	06 9c       	mov	r12,r3
							break;
800064a4:	c2 38       	rjmp	800064ea <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
800064a6:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
800064aa:	06 9a       	mov	r10,r3
800064ac:	40 0b       	lddsp	r11,sp[0x0]
800064ae:	5c 5b       	castu.b	r11
800064b0:	68 0c       	ld.w	r12,r4[0x0]
800064b2:	f0 1f 00 30 	mcall	80006570 <log+0x160>
800064b6:	06 9c       	mov	r12,r3
							break;
800064b8:	c1 98       	rjmp	800064ea <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
800064ba:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
800064be:	06 9b       	mov	r11,r3
800064c0:	09 bc       	ld.ub	r12,r4[0x3]
800064c2:	f0 1f 00 2d 	mcall	80006574 <log+0x164>
800064c6:	06 9c       	mov	r12,r3
							break;
800064c8:	c1 18       	rjmp	800064ea <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
800064ca:	e8 c5 ff fc 	sub	r5,r4,-4
800064ce:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
800064d0:	c0 d8       	rjmp	800064ea <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
800064d2:	06 9b       	mov	r11,r3
800064d4:	32 5c       	mov	r12,37
800064d6:	f0 1f 00 28 	mcall	80006574 <log+0x164>
800064da:	08 95       	mov	r5,r4
800064dc:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
800064de:	c0 68       	rjmp	800064ea <log+0xda>
							
							default:
							log("I need relax.");
800064e0:	4a 6c       	lddpc	r12,80006578 <log+0x168>
800064e2:	f0 1f 00 23 	mcall	8000656c <log+0x15c>
800064e6:	08 95       	mov	r5,r4
800064e8:	06 9c       	mov	r12,r3
						}
						str++;
800064ea:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800064ec:	1a dc       	st.w	--sp,r12
800064ee:	1a d6       	st.w	--sp,r6
800064f0:	4a 3b       	lddpc	r11,8000657c <log+0x16c>
800064f2:	0c 9c       	mov	r12,r6
800064f4:	f0 1f 00 23 	mcall	80006580 <log+0x170>
800064f8:	2f ed       	sub	sp,-8
800064fa:	c0 a8       	rjmp	8000650e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800064fc:	2f f7       	sub	r7,-1
800064fe:	1a d8       	st.w	--sp,r8
80006500:	1a d6       	st.w	--sp,r6
80006502:	4a 1b       	lddpc	r11,80006584 <log+0x174>
80006504:	0c 9c       	mov	r12,r6
80006506:	f0 1f 00 1f 	mcall	80006580 <log+0x170>
8000650a:	08 95       	mov	r5,r4
8000650c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
8000650e:	0f 89       	ld.ub	r9,r7[0x0]
80006510:	30 08       	mov	r8,0
80006512:	f0 09 18 00 	cp.b	r9,r8
80006516:	c0 30       	breq	8000651c <log+0x10c>
80006518:	0a 94       	mov	r4,r5
8000651a:	c9 2b       	rjmp	8000643e <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
8000651c:	fa c7 fe f8 	sub	r7,sp,-264
80006520:	1a d7       	st.w	--sp,r7
80006522:	49 ab       	lddpc	r11,80006588 <log+0x178>
80006524:	0e 9c       	mov	r12,r7
80006526:	f0 1f 00 17 	mcall	80006580 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
8000652a:	5c 5c       	castu.b	r12
8000652c:	f8 c6 ff ff 	sub	r6,r12,-1
80006530:	0c 9c       	mov	r12,r6
80006532:	f0 1f 00 17 	mcall	8000658c <log+0x17c>
80006536:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006538:	0c 9a       	mov	r10,r6
8000653a:	0e 9b       	mov	r11,r7
8000653c:	f0 1f 00 15 	mcall	80006590 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
80006540:	30 09       	mov	r9,0
80006542:	30 5a       	mov	r10,5
80006544:	fa cb fe f8 	sub	r11,sp,-264
80006548:	49 38       	lddpc	r8,80006594 <log+0x184>
8000654a:	70 0c       	ld.w	r12,r8[0x0]
8000654c:	f0 1f 00 13 	mcall	80006598 <log+0x188>
80006550:	2f fd       	sub	sp,-4
}
80006552:	fe 3d fd f8 	sub	sp,-520
80006556:	d8 32       	popm	r0-r7,pc
80006558:	80 00       	ld.sh	r0,r0[0x0]
8000655a:	6e b8       	ld.w	r8,r7[0x2c]
8000655c:	00 00       	add	r0,r0
8000655e:	0d 70       	ld.ub	r0,--r6
80006560:	80 00       	ld.sh	r0,r0[0x0]
80006562:	d2 78       	*unknown*
80006564:	80 00       	ld.sh	r0,r0[0x0]
80006566:	63 36       	ld.w	r6,r1[0x4c]
80006568:	80 00       	ld.sh	r0,r0[0x0]
8000656a:	d5 24       	*unknown*
8000656c:	80 00       	ld.sh	r0,r0[0x0]
8000656e:	64 10       	ld.w	r0,r2[0x4]
80006570:	80 00       	ld.sh	r0,r0[0x0]
80006572:	62 84       	ld.w	r4,r1[0x20]
80006574:	80 00       	ld.sh	r0,r0[0x0]
80006576:	62 80       	ld.w	r0,r1[0x20]
80006578:	80 00       	ld.sh	r0,r0[0x0]
8000657a:	d5 34       	*unknown*
8000657c:	80 00       	ld.sh	r0,r0[0x0]
8000657e:	d5 44       	*unknown*
80006580:	80 00       	ld.sh	r0,r0[0x0]
80006582:	71 a8       	ld.w	r8,r8[0x68]
80006584:	80 00       	ld.sh	r0,r0[0x0]
80006586:	d5 4c       	*unknown*
80006588:	80 00       	ld.sh	r0,r0[0x0]
8000658a:	d5 54       	*unknown*
8000658c:	80 00       	ld.sh	r0,r0[0x0]
8000658e:	54 cc       	stdsp	sp[0x130],r12
80006590:	80 00       	ld.sh	r0,r0[0x0]
80006592:	6d 70       	ld.w	r0,r6[0x5c]
80006594:	00 00       	add	r0,r0
80006596:	41 14       	lddsp	r4,sp[0x44]
80006598:	80 00       	ld.sh	r0,r0[0x0]
8000659a:	58 20       	cp.w	r0,2

8000659c <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
8000659c:	d4 31       	pushm	r0-r7,lr
8000659e:	fa cd 02 0c 	sub	sp,sp,524
800065a2:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
800065a4:	e0 6a 01 00 	mov	r10,256
800065a8:	30 0b       	mov	r11,0
800065aa:	fa cc fe f4 	sub	r12,sp,-268
800065ae:	f0 1f 00 4c 	mcall	800066dc <logFromISR+0x140>
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
}
	
	
int logFromISR(char * content, ...)
800065b2:	fa c4 fd d0 	sub	r4,sp,-560
800065b6:	30 0a       	mov	r10,0
800065b8:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800065ba:	fa c3 ff fc 	sub	r3,sp,-4
800065be:	e0 61 01 00 	mov	r1,256
800065c2:	14 90       	mov	r0,r10
			
			if(*str == '%')
800065c4:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800065c6:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800065ca:	02 9a       	mov	r10,r1
800065cc:	00 9b       	mov	r11,r0
800065ce:	06 9c       	mov	r12,r3
800065d0:	f0 1f 00 43 	mcall	800066dc <logFromISR+0x140>
			
			if(*str == '%')
800065d4:	0f 88       	ld.ub	r8,r7[0x0]
800065d6:	e4 08 18 00 	cp.b	r8,r2
800065da:	c5 11       	brne	8000667c <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
800065dc:	ee c8 ff ff 	sub	r8,r7,-1
800065e0:	11 89       	ld.ub	r9,r8[0x0]
800065e2:	4c 0a       	lddpc	r10,800066e0 <logFromISR+0x144>
800065e4:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
800065e6:	23 09       	sub	r9,48
800065e8:	30 9a       	mov	r10,9
800065ea:	f4 09 18 00 	cp.b	r9,r10
800065ee:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
800065f2:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800065f6:	f7 b9 08 30 	subls	r9,48
800065fa:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
800065fe:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006602:	0f 88       	ld.ub	r8,r7[0x0]
80006604:	22 58       	sub	r8,37
80006606:	e0 48 00 53 	cp.w	r8,83
8000660a:	e0 8b 00 2b 	brhi	80006660 <logFromISR+0xc4>
8000660e:	4b 69       	lddpc	r9,800066e4 <logFromISR+0x148>
80006610:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006614:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006618:	06 9a       	mov	r10,r3
8000661a:	40 0b       	lddsp	r11,sp[0x0]
8000661c:	5c 5b       	castu.b	r11
8000661e:	68 0c       	ld.w	r12,r4[0x0]
80006620:	f0 1f 00 32 	mcall	800066e8 <logFromISR+0x14c>
					break;
80006624:	c2 38       	rjmp	8000666a <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80006626:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
8000662a:	06 9a       	mov	r10,r3
8000662c:	40 0b       	lddsp	r11,sp[0x0]
8000662e:	5c 5b       	castu.b	r11
80006630:	68 0c       	ld.w	r12,r4[0x0]
80006632:	f0 1f 00 2f 	mcall	800066ec <logFromISR+0x150>
80006636:	06 9c       	mov	r12,r3
					break;
80006638:	c1 98       	rjmp	8000666a <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000663a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
8000663e:	06 9b       	mov	r11,r3
80006640:	09 bc       	ld.ub	r12,r4[0x3]
80006642:	f0 1f 00 2c 	mcall	800066f0 <logFromISR+0x154>
80006646:	06 9c       	mov	r12,r3
					break;
80006648:	c1 18       	rjmp	8000666a <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000664a:	e8 c5 ff fc 	sub	r5,r4,-4
8000664e:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80006650:	c0 d8       	rjmp	8000666a <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80006652:	06 9b       	mov	r11,r3
80006654:	32 5c       	mov	r12,37
80006656:	f0 1f 00 27 	mcall	800066f0 <logFromISR+0x154>
8000665a:	08 95       	mov	r5,r4
8000665c:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
8000665e:	c0 68       	rjmp	8000666a <logFromISR+0xce>
					default:
					log("I need relax.");
80006660:	4a 5c       	lddpc	r12,800066f4 <logFromISR+0x158>
80006662:	f0 1f 00 26 	mcall	800066f8 <logFromISR+0x15c>
80006666:	08 95       	mov	r5,r4
80006668:	06 9c       	mov	r12,r3
				}
				str++;
8000666a:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000666c:	1a dc       	st.w	--sp,r12
8000666e:	1a d6       	st.w	--sp,r6
80006670:	4a 3b       	lddpc	r11,800066fc <logFromISR+0x160>
80006672:	0c 9c       	mov	r12,r6
80006674:	f0 1f 00 23 	mcall	80006700 <logFromISR+0x164>
80006678:	2f ed       	sub	sp,-8
8000667a:	c0 a8       	rjmp	8000668e <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000667c:	2f f7       	sub	r7,-1
8000667e:	1a d8       	st.w	--sp,r8
80006680:	1a d6       	st.w	--sp,r6
80006682:	4a 1b       	lddpc	r11,80006704 <logFromISR+0x168>
80006684:	0c 9c       	mov	r12,r6
80006686:	f0 1f 00 1f 	mcall	80006700 <logFromISR+0x164>
8000668a:	08 95       	mov	r5,r4
8000668c:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
8000668e:	0f 89       	ld.ub	r9,r7[0x0]
80006690:	30 08       	mov	r8,0
80006692:	f0 09 18 00 	cp.b	r9,r8
80006696:	c0 30       	breq	8000669c <logFromISR+0x100>
80006698:	0a 94       	mov	r4,r5
8000669a:	c9 8b       	rjmp	800065ca <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
8000669c:	fa c7 fe f4 	sub	r7,sp,-268
800066a0:	1a d7       	st.w	--sp,r7
800066a2:	49 ab       	lddpc	r11,80006708 <logFromISR+0x16c>
800066a4:	0e 9c       	mov	r12,r7
800066a6:	f0 1f 00 17 	mcall	80006700 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
800066aa:	5c 5c       	castu.b	r12
800066ac:	f8 c6 ff ff 	sub	r6,r12,-1
800066b0:	0c 9c       	mov	r12,r6
800066b2:	f0 1f 00 17 	mcall	8000670c <logFromISR+0x170>
800066b6:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
800066b8:	0c 9a       	mov	r10,r6
800066ba:	0e 9b       	mov	r11,r7
800066bc:	f0 1f 00 15 	mcall	80006710 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800066c0:	30 09       	mov	r9,0
800066c2:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
800066c4:	fa ca fe f8 	sub	r10,sp,-264
800066c8:	fa cb fe f4 	sub	r11,sp,-268
800066cc:	49 28       	lddpc	r8,80006714 <logFromISR+0x178>
800066ce:	70 0c       	ld.w	r12,r8[0x0]
800066d0:	f0 1f 00 12 	mcall	80006718 <logFromISR+0x17c>
800066d4:	2f fd       	sub	sp,-4
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
800066d6:	fe 3d fd f4 	sub	sp,-524
800066da:	d8 32       	popm	r0-r7,pc
800066dc:	80 00       	ld.sh	r0,r0[0x0]
800066de:	6e b8       	ld.w	r8,r7[0x2c]
800066e0:	00 00       	add	r0,r0
800066e2:	0d 71       	ld.ub	r1,--r6
800066e4:	80 00       	ld.sh	r0,r0[0x0]
800066e6:	d3 c8       	*unknown*
800066e8:	80 00       	ld.sh	r0,r0[0x0]
800066ea:	63 36       	ld.w	r6,r1[0x4c]
800066ec:	80 00       	ld.sh	r0,r0[0x0]
800066ee:	62 84       	ld.w	r4,r1[0x20]
800066f0:	80 00       	ld.sh	r0,r0[0x0]
800066f2:	62 80       	ld.w	r0,r1[0x20]
800066f4:	80 00       	ld.sh	r0,r0[0x0]
800066f6:	d5 34       	*unknown*
800066f8:	80 00       	ld.sh	r0,r0[0x0]
800066fa:	64 10       	ld.w	r0,r2[0x4]
800066fc:	80 00       	ld.sh	r0,r0[0x0]
800066fe:	d5 44       	*unknown*
80006700:	80 00       	ld.sh	r0,r0[0x0]
80006702:	71 a8       	ld.w	r8,r8[0x68]
80006704:	80 00       	ld.sh	r0,r0[0x0]
80006706:	d5 4c       	*unknown*
80006708:	80 00       	ld.sh	r0,r0[0x0]
8000670a:	d5 54       	*unknown*
8000670c:	80 00       	ld.sh	r0,r0[0x0]
8000670e:	54 cc       	stdsp	sp[0x130],r12
80006710:	80 00       	ld.sh	r0,r0[0x0]
80006712:	6d 70       	ld.w	r0,r6[0x5c]
80006714:	00 00       	add	r0,r0
80006716:	41 14       	lddsp	r4,sp[0x44]
80006718:	80 00       	ld.sh	r0,r0[0x0]
8000671a:	57 d0       	stdsp	sp[0x1f4],r0

8000671c <log_init>:
		
	return str;
}

void log_init(void)
{
8000671c:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000671e:	30 2b       	mov	r11,2
80006720:	49 0c       	lddpc	r12,80006760 <log_init+0x44>
80006722:	f0 1f 00 11 	mcall	80006764 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80006726:	e0 6a 36 00 	mov	r10,13824
8000672a:	ea 1a 01 6e 	orh	r10,0x16e
8000672e:	48 fb       	lddpc	r11,80006768 <log_init+0x4c>
80006730:	fe 7c 18 00 	mov	r12,-59392
80006734:	f0 1f 00 0e 	mcall	8000676c <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80006738:	30 4b       	mov	r11,4
8000673a:	33 2c       	mov	r12,50
8000673c:	f0 1f 00 0d 	mcall	80006770 <log_init+0x54>
80006740:	48 d8       	lddpc	r8,80006774 <log_init+0x58>
80006742:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80006744:	30 09       	mov	r9,0
80006746:	1a d9       	st.w	--sp,r9
80006748:	1a d9       	st.w	--sp,r9
8000674a:	1a d9       	st.w	--sp,r9
8000674c:	30 28       	mov	r8,2
8000674e:	e0 6a 01 80 	mov	r10,384
80006752:	48 ab       	lddpc	r11,80006778 <log_init+0x5c>
80006754:	48 ac       	lddpc	r12,8000677c <log_init+0x60>
80006756:	f0 1f 00 0b 	mcall	80006780 <log_init+0x64>
8000675a:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
8000675c:	d8 02       	popm	pc
8000675e:	00 00       	add	r0,r0
80006760:	80 00       	ld.sh	r0,r0[0x0]
80006762:	d5 60       	acall	0x56
80006764:	80 00       	ld.sh	r0,r0[0x0]
80006766:	68 a8       	ld.w	r8,r4[0x28]
80006768:	80 00       	ld.sh	r0,r0[0x0]
8000676a:	d5 18       	*unknown*
8000676c:	80 00       	ld.sh	r0,r0[0x0]
8000676e:	50 70       	stdsp	sp[0x1c],r0
80006770:	80 00       	ld.sh	r0,r0[0x0]
80006772:	59 78       	cp.w	r8,23
80006774:	00 00       	add	r0,r0
80006776:	41 14       	lddsp	r4,sp[0x44]
80006778:	80 00       	ld.sh	r0,r0[0x0]
8000677a:	d5 5c       	*unknown*
8000677c:	80 00       	ld.sh	r0,r0[0x0]
8000677e:	67 84       	ld.w	r4,r3[0x60]
80006780:	80 00       	ld.sh	r0,r0[0x0]
80006782:	60 4c       	ld.w	r12,r0[0x10]

80006784 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80006784:	eb cd 40 f8 	pushm	r3-r7,lr
80006788:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000678a:	48 c7       	lddpc	r7,800067b8 <task_log+0x34>
8000678c:	30 05       	mov	r5,0
8000678e:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006790:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006794:	0a 99       	mov	r9,r5
80006796:	08 9a       	mov	r10,r4
80006798:	1a 9b       	mov	r11,sp
8000679a:	6e 0c       	ld.w	r12,r7[0x0]
8000679c:	f0 1f 00 08 	mcall	800067bc <task_log+0x38>
800067a0:	58 1c       	cp.w	r12,1
800067a2:	cf 91       	brne	80006794 <task_log+0x10>
		{
			if( NULL != str)
800067a4:	40 0b       	lddsp	r11,sp[0x0]
800067a6:	58 0b       	cp.w	r11,0
800067a8:	cf 60       	breq	80006794 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
800067aa:	06 9c       	mov	r12,r3
800067ac:	f0 1f 00 05 	mcall	800067c0 <task_log+0x3c>
				vPortFree(str);
800067b0:	40 0c       	lddsp	r12,sp[0x0]
800067b2:	f0 1f 00 05 	mcall	800067c4 <task_log+0x40>
800067b6:	ce fb       	rjmp	80006794 <task_log+0x10>
800067b8:	00 00       	add	r0,r0
800067ba:	41 14       	lddsp	r4,sp[0x44]
800067bc:	80 00       	ld.sh	r0,r0[0x0]
800067be:	56 14       	stdsp	sp[0x184],r4
800067c0:	80 00       	ld.sh	r0,r0[0x0]
800067c2:	50 20       	stdsp	sp[0x8],r0
800067c4:	80 00       	ld.sh	r0,r0[0x0]
800067c6:	54 a4       	stdsp	sp[0x128],r4

800067c8 <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
800067c8:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800067ca:	fe 78 10 00 	mov	r8,-61440
800067ce:	30 19       	mov	r9,1
800067d0:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
800067d4:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
800067d8:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
800067dc:	d3 03       	ssrf	0x10
	local_start_pll0();
800067de:	f0 1f 00 13 	mcall	80006828 <main+0x60>
		
	INTC_init_interrupts();
800067e2:	f0 1f 00 13 	mcall	8000682c <main+0x64>
	
	log_init();		
800067e6:	f0 1f 00 13 	mcall	80006830 <main+0x68>
	log("----start debug----");	
800067ea:	49 3c       	lddpc	r12,80006834 <main+0x6c>
800067ec:	f0 1f 00 13 	mcall	80006838 <main+0x70>
		
	rtc_init();
800067f0:	f0 1f 00 13 	mcall	8000683c <main+0x74>
	
	//fs_init();//65795机器无法通过文件系统初始化

	tc_init();	
800067f4:	f0 1f 00 13 	mcall	80006840 <main+0x78>
			
	xcmp_init();
800067f8:	f0 1f 00 13 	mcall	80006844 <main+0x7c>
	
	app_init();
800067fc:	f0 1f 00 13 	mcall	80006848 <main+0x80>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80006800:	fe 79 10 00 	mov	r9,-61440
80006804:	f2 f8 01 60 	ld.w	r8,r9[352]
80006808:	e2 18 00 02 	andl	r8,0x2,COH
8000680c:	cf c0       	breq	80006804 <main+0x3c>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000680e:	fe 79 10 00 	mov	r9,-61440
80006812:	f2 f8 01 60 	ld.w	r8,r9[352]
80006816:	e2 18 00 02 	andl	r8,0x2,COH
8000681a:	cf c1       	brne	80006812 <main+0x4a>
	local_start_timer();
8000681c:	f0 1f 00 0c 	mcall	8000684c <main+0x84>
	
	Enable_global_interrupt();
80006820:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
80006822:	f0 1f 00 0c 	mcall	80006850 <main+0x88>
	return 0;
}
80006826:	d8 0a       	popm	pc,r12=0
80006828:	80 00       	ld.sh	r0,r0[0x0]
8000682a:	49 40       	lddpc	r0,80006878 <gpio_enable_module_pin+0x24>
8000682c:	80 00       	ld.sh	r0,r0[0x0]
8000682e:	4b 5c       	lddpc	r12,80006900 <idata_load_loop_end+0x4>
80006830:	80 00       	ld.sh	r0,r0[0x0]
80006832:	67 1c       	ld.w	r12,r3[0x44]
80006834:	80 00       	ld.sh	r0,r0[0x0]
80006836:	d5 70       	acall	0x57
80006838:	80 00       	ld.sh	r0,r0[0x0]
8000683a:	64 10       	ld.w	r0,r2[0x4]
8000683c:	80 00       	ld.sh	r0,r0[0x0]
8000683e:	49 90       	lddpc	r0,800068a0 <gpio_enable_module_pin+0x4c>
80006840:	80 00       	ld.sh	r0,r0[0x0]
80006842:	4a 58       	lddpc	r8,800068d4 <gpio_enable_module+0x2c>
80006844:	80 00       	ld.sh	r0,r0[0x0]
80006846:	42 44       	lddsp	r4,sp[0x90]
80006848:	80 00       	ld.sh	r0,r0[0x0]
8000684a:	20 40       	sub	r0,4
8000684c:	80 00       	ld.sh	r0,r0[0x0]
8000684e:	4a 1c       	lddpc	r12,800068d0 <gpio_enable_module+0x28>
80006850:	80 00       	ld.sh	r0,r0[0x0]
80006852:	62 34       	ld.w	r4,r1[0xc]

80006854 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006854:	f8 08 16 05 	lsr	r8,r12,0x5
80006858:	a9 68       	lsl	r8,0x8
8000685a:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
8000685e:	58 1b       	cp.w	r11,1
80006860:	c0 d0       	breq	8000687a <gpio_enable_module_pin+0x26>
80006862:	c0 63       	brcs	8000686e <gpio_enable_module_pin+0x1a>
80006864:	58 2b       	cp.w	r11,2
80006866:	c1 00       	breq	80006886 <gpio_enable_module_pin+0x32>
80006868:	58 3b       	cp.w	r11,3
8000686a:	c1 40       	breq	80006892 <gpio_enable_module_pin+0x3e>
8000686c:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000686e:	30 19       	mov	r9,1
80006870:	f2 0c 09 49 	lsl	r9,r9,r12
80006874:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006876:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006878:	c1 28       	rjmp	8000689c <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000687a:	30 19       	mov	r9,1
8000687c:	f2 0c 09 49 	lsl	r9,r9,r12
80006880:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006882:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006884:	c0 c8       	rjmp	8000689c <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006886:	30 19       	mov	r9,1
80006888:	f2 0c 09 49 	lsl	r9,r9,r12
8000688c:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000688e:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006890:	c0 68       	rjmp	8000689c <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006892:	30 19       	mov	r9,1
80006894:	f2 0c 09 49 	lsl	r9,r9,r12
80006898:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000689a:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000689c:	30 19       	mov	r9,1
8000689e:	f2 0c 09 4c 	lsl	r12,r9,r12
800068a2:	91 2c       	st.w	r8[0x8],r12
800068a4:	5e fd       	retal	0
800068a6:	d7 03       	nop

800068a8 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800068a8:	d4 21       	pushm	r4-r7,lr
800068aa:	18 97       	mov	r7,r12
800068ac:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800068ae:	58 0b       	cp.w	r11,0
800068b0:	c0 31       	brne	800068b6 <gpio_enable_module+0xe>
800068b2:	30 05       	mov	r5,0
800068b4:	c0 d8       	rjmp	800068ce <gpio_enable_module+0x26>
800068b6:	30 06       	mov	r6,0
800068b8:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800068ba:	6e 1b       	ld.w	r11,r7[0x4]
800068bc:	6e 0c       	ld.w	r12,r7[0x0]
800068be:	f0 1f 00 06 	mcall	800068d4 <gpio_enable_module+0x2c>
800068c2:	18 45       	or	r5,r12
		gpiomap++;
800068c4:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800068c6:	2f f6       	sub	r6,-1
800068c8:	0c 34       	cp.w	r4,r6
800068ca:	fe 9b ff f8 	brhi	800068ba <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800068ce:	0a 9c       	mov	r12,r5
800068d0:	d8 22       	popm	r4-r7,pc
800068d2:	00 00       	add	r0,r0
800068d4:	80 00       	ld.sh	r0,r0[0x0]
800068d6:	68 54       	ld.w	r4,r4[0x14]

800068d8 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
800068d8:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
800068dc:	fe c0 a6 dc 	sub	r0,pc,-22820

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
800068e0:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
800068e4:	d5 53       	csrf	0x15
  cp      r0, r1
800068e6:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
800068e8:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
800068ec:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
800068ee:	c0 72       	brcc	800068fc <idata_load_loop_end>
  cp      r0, r1
800068f0:	fe c2 8d e8 	sub	r2,pc,-29208

800068f4 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
800068f4:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
800068f6:	a1 24       	st.d	r0++,r4
  cp      r0, r1
800068f8:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
800068fa:	cf d3       	brcs	800068f4 <idata_load_loop>

800068fc <idata_load_loop_end>:
  mov     r2, 0
800068fc:	e0 60 0a 40 	mov	r0,2624
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
80006900:	e0 61 41 20 	mov	r1,16672
  cp      r0, r1
  brlo    udata_clear_loop
80006904:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80006906:	c0 62       	brcc	80006912 <udata_clear_loop_end>
80006908:	30 02       	mov	r2,0
8000690a:	30 03       	mov	r3,0

8000690c <udata_clear_loop>:
8000690c:	a1 22       	st.d	r0++,r2
8000690e:	02 30       	cp.w	r0,r1
80006910:	cf e3       	brcs	8000690c <udata_clear_loop>

80006912 <udata_clear_loop_end>:
80006912:	fe cf 01 4a 	sub	pc,pc,330
80006916:	d7 03       	nop

80006918 <free>:
80006918:	d4 01       	pushm	lr
8000691a:	e0 68 0a 38 	mov	r8,2616
8000691e:	18 9b       	mov	r11,r12
80006920:	70 0c       	ld.w	r12,r8[0x0]
80006922:	e0 a0 1e 6d 	rcall	8000a5fc <_free_r>
80006926:	d8 02       	popm	pc

80006928 <malloc>:
80006928:	d4 01       	pushm	lr
8000692a:	e0 68 0a 38 	mov	r8,2616
8000692e:	18 9b       	mov	r11,r12
80006930:	70 0c       	ld.w	r12,r8[0x0]
80006932:	c0 3c       	rcall	80006938 <_malloc_r>
80006934:	d8 02       	popm	pc
80006936:	d7 03       	nop

80006938 <_malloc_r>:
80006938:	d4 31       	pushm	r0-r7,lr
8000693a:	f6 c8 ff f5 	sub	r8,r11,-11
8000693e:	18 95       	mov	r5,r12
80006940:	10 97       	mov	r7,r8
80006942:	e0 17 ff f8 	andl	r7,0xfff8
80006946:	59 68       	cp.w	r8,22
80006948:	f9 b7 08 10 	movls	r7,16
8000694c:	16 37       	cp.w	r7,r11
8000694e:	5f 38       	srlo	r8
80006950:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006954:	c0 50       	breq	8000695e <_malloc_r+0x26>
80006956:	30 c8       	mov	r8,12
80006958:	99 38       	st.w	r12[0xc],r8
8000695a:	e0 8f 01 fa 	bral	80006d4e <_malloc_r+0x416>
8000695e:	fe b0 f5 59 	rcall	80005410 <__malloc_lock>
80006962:	e0 47 01 f7 	cp.w	r7,503
80006966:	e0 8b 00 1d 	brhi	800069a0 <_malloc_r+0x68>
8000696a:	ee 03 16 03 	lsr	r3,r7,0x3
8000696e:	e0 68 05 38 	mov	r8,1336
80006972:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006976:	70 36       	ld.w	r6,r8[0xc]
80006978:	10 36       	cp.w	r6,r8
8000697a:	c0 61       	brne	80006986 <_malloc_r+0x4e>
8000697c:	ec c8 ff f8 	sub	r8,r6,-8
80006980:	70 36       	ld.w	r6,r8[0xc]
80006982:	10 36       	cp.w	r6,r8
80006984:	c0 c0       	breq	8000699c <_malloc_r+0x64>
80006986:	6c 18       	ld.w	r8,r6[0x4]
80006988:	e0 18 ff fc 	andl	r8,0xfffc
8000698c:	6c 3a       	ld.w	r10,r6[0xc]
8000698e:	ec 08 00 09 	add	r9,r6,r8
80006992:	0a 9c       	mov	r12,r5
80006994:	6c 28       	ld.w	r8,r6[0x8]
80006996:	95 28       	st.w	r10[0x8],r8
80006998:	91 3a       	st.w	r8[0xc],r10
8000699a:	c4 78       	rjmp	80006a28 <_malloc_r+0xf0>
8000699c:	2f e3       	sub	r3,-2
8000699e:	c4 d8       	rjmp	80006a38 <_malloc_r+0x100>
800069a0:	ee 03 16 09 	lsr	r3,r7,0x9
800069a4:	c0 41       	brne	800069ac <_malloc_r+0x74>
800069a6:	ee 03 16 03 	lsr	r3,r7,0x3
800069aa:	c2 68       	rjmp	800069f6 <_malloc_r+0xbe>
800069ac:	58 43       	cp.w	r3,4
800069ae:	e0 8b 00 06 	brhi	800069ba <_malloc_r+0x82>
800069b2:	ee 03 16 06 	lsr	r3,r7,0x6
800069b6:	2c 83       	sub	r3,-56
800069b8:	c1 f8       	rjmp	800069f6 <_malloc_r+0xbe>
800069ba:	59 43       	cp.w	r3,20
800069bc:	e0 8b 00 04 	brhi	800069c4 <_malloc_r+0x8c>
800069c0:	2a 53       	sub	r3,-91
800069c2:	c1 a8       	rjmp	800069f6 <_malloc_r+0xbe>
800069c4:	e0 43 00 54 	cp.w	r3,84
800069c8:	e0 8b 00 06 	brhi	800069d4 <_malloc_r+0x9c>
800069cc:	ee 03 16 0c 	lsr	r3,r7,0xc
800069d0:	29 23       	sub	r3,-110
800069d2:	c1 28       	rjmp	800069f6 <_malloc_r+0xbe>
800069d4:	e0 43 01 54 	cp.w	r3,340
800069d8:	e0 8b 00 06 	brhi	800069e4 <_malloc_r+0xac>
800069dc:	ee 03 16 0f 	lsr	r3,r7,0xf
800069e0:	28 93       	sub	r3,-119
800069e2:	c0 a8       	rjmp	800069f6 <_malloc_r+0xbe>
800069e4:	e0 43 05 54 	cp.w	r3,1364
800069e8:	e0 88 00 04 	brls	800069f0 <_malloc_r+0xb8>
800069ec:	37 e3       	mov	r3,126
800069ee:	c0 48       	rjmp	800069f6 <_malloc_r+0xbe>
800069f0:	ee 03 16 12 	lsr	r3,r7,0x12
800069f4:	28 43       	sub	r3,-124
800069f6:	e0 6a 05 38 	mov	r10,1336
800069fa:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800069fe:	74 36       	ld.w	r6,r10[0xc]
80006a00:	c1 98       	rjmp	80006a32 <_malloc_r+0xfa>
80006a02:	6c 19       	ld.w	r9,r6[0x4]
80006a04:	e0 19 ff fc 	andl	r9,0xfffc
80006a08:	f2 07 01 0b 	sub	r11,r9,r7
80006a0c:	58 fb       	cp.w	r11,15
80006a0e:	e0 8a 00 04 	brle	80006a16 <_malloc_r+0xde>
80006a12:	20 13       	sub	r3,1
80006a14:	c1 18       	rjmp	80006a36 <_malloc_r+0xfe>
80006a16:	6c 38       	ld.w	r8,r6[0xc]
80006a18:	58 0b       	cp.w	r11,0
80006a1a:	c0 b5       	brlt	80006a30 <_malloc_r+0xf8>
80006a1c:	6c 2a       	ld.w	r10,r6[0x8]
80006a1e:	ec 09 00 09 	add	r9,r6,r9
80006a22:	0a 9c       	mov	r12,r5
80006a24:	91 2a       	st.w	r8[0x8],r10
80006a26:	95 38       	st.w	r10[0xc],r8
80006a28:	72 18       	ld.w	r8,r9[0x4]
80006a2a:	a1 a8       	sbr	r8,0x0
80006a2c:	93 18       	st.w	r9[0x4],r8
80006a2e:	cb c8       	rjmp	80006ba6 <_malloc_r+0x26e>
80006a30:	10 96       	mov	r6,r8
80006a32:	14 36       	cp.w	r6,r10
80006a34:	ce 71       	brne	80006a02 <_malloc_r+0xca>
80006a36:	2f f3       	sub	r3,-1
80006a38:	e0 6a 05 38 	mov	r10,1336
80006a3c:	f4 cc ff f8 	sub	r12,r10,-8
80006a40:	78 26       	ld.w	r6,r12[0x8]
80006a42:	18 36       	cp.w	r6,r12
80006a44:	c6 c0       	breq	80006b1c <_malloc_r+0x1e4>
80006a46:	6c 19       	ld.w	r9,r6[0x4]
80006a48:	e0 19 ff fc 	andl	r9,0xfffc
80006a4c:	f2 07 01 08 	sub	r8,r9,r7
80006a50:	58 f8       	cp.w	r8,15
80006a52:	e0 89 00 8f 	brgt	80006b70 <_malloc_r+0x238>
80006a56:	99 3c       	st.w	r12[0xc],r12
80006a58:	99 2c       	st.w	r12[0x8],r12
80006a5a:	58 08       	cp.w	r8,0
80006a5c:	c0 55       	brlt	80006a66 <_malloc_r+0x12e>
80006a5e:	ec 09 00 09 	add	r9,r6,r9
80006a62:	0a 9c       	mov	r12,r5
80006a64:	ce 2b       	rjmp	80006a28 <_malloc_r+0xf0>
80006a66:	e0 49 01 ff 	cp.w	r9,511
80006a6a:	e0 8b 00 13 	brhi	80006a90 <_malloc_r+0x158>
80006a6e:	a3 99       	lsr	r9,0x3
80006a70:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006a74:	70 2b       	ld.w	r11,r8[0x8]
80006a76:	8d 38       	st.w	r6[0xc],r8
80006a78:	8d 2b       	st.w	r6[0x8],r11
80006a7a:	97 36       	st.w	r11[0xc],r6
80006a7c:	91 26       	st.w	r8[0x8],r6
80006a7e:	a3 49       	asr	r9,0x2
80006a80:	74 18       	ld.w	r8,r10[0x4]
80006a82:	30 1b       	mov	r11,1
80006a84:	f6 09 09 49 	lsl	r9,r11,r9
80006a88:	f1 e9 10 09 	or	r9,r8,r9
80006a8c:	95 19       	st.w	r10[0x4],r9
80006a8e:	c4 78       	rjmp	80006b1c <_malloc_r+0x1e4>
80006a90:	f2 0a 16 09 	lsr	r10,r9,0x9
80006a94:	58 4a       	cp.w	r10,4
80006a96:	e0 8b 00 07 	brhi	80006aa4 <_malloc_r+0x16c>
80006a9a:	f2 0a 16 06 	lsr	r10,r9,0x6
80006a9e:	2c 8a       	sub	r10,-56
80006aa0:	c2 08       	rjmp	80006ae0 <_malloc_r+0x1a8>
80006aa2:	d7 03       	nop
80006aa4:	59 4a       	cp.w	r10,20
80006aa6:	e0 8b 00 04 	brhi	80006aae <_malloc_r+0x176>
80006aaa:	2a 5a       	sub	r10,-91
80006aac:	c1 a8       	rjmp	80006ae0 <_malloc_r+0x1a8>
80006aae:	e0 4a 00 54 	cp.w	r10,84
80006ab2:	e0 8b 00 06 	brhi	80006abe <_malloc_r+0x186>
80006ab6:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006aba:	29 2a       	sub	r10,-110
80006abc:	c1 28       	rjmp	80006ae0 <_malloc_r+0x1a8>
80006abe:	e0 4a 01 54 	cp.w	r10,340
80006ac2:	e0 8b 00 06 	brhi	80006ace <_malloc_r+0x196>
80006ac6:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006aca:	28 9a       	sub	r10,-119
80006acc:	c0 a8       	rjmp	80006ae0 <_malloc_r+0x1a8>
80006ace:	e0 4a 05 54 	cp.w	r10,1364
80006ad2:	e0 88 00 04 	brls	80006ada <_malloc_r+0x1a2>
80006ad6:	37 ea       	mov	r10,126
80006ad8:	c0 48       	rjmp	80006ae0 <_malloc_r+0x1a8>
80006ada:	f2 0a 16 12 	lsr	r10,r9,0x12
80006ade:	28 4a       	sub	r10,-124
80006ae0:	e0 6b 05 38 	mov	r11,1336
80006ae4:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006ae8:	68 28       	ld.w	r8,r4[0x8]
80006aea:	08 38       	cp.w	r8,r4
80006aec:	c0 e1       	brne	80006b08 <_malloc_r+0x1d0>
80006aee:	76 19       	ld.w	r9,r11[0x4]
80006af0:	a3 4a       	asr	r10,0x2
80006af2:	30 1e       	mov	lr,1
80006af4:	fc 0a 09 4a 	lsl	r10,lr,r10
80006af8:	f3 ea 10 0a 	or	r10,r9,r10
80006afc:	10 99       	mov	r9,r8
80006afe:	97 1a       	st.w	r11[0x4],r10
80006b00:	c0 a8       	rjmp	80006b14 <_malloc_r+0x1dc>
80006b02:	70 28       	ld.w	r8,r8[0x8]
80006b04:	08 38       	cp.w	r8,r4
80006b06:	c0 60       	breq	80006b12 <_malloc_r+0x1da>
80006b08:	70 1a       	ld.w	r10,r8[0x4]
80006b0a:	e0 1a ff fc 	andl	r10,0xfffc
80006b0e:	14 39       	cp.w	r9,r10
80006b10:	cf 93       	brcs	80006b02 <_malloc_r+0x1ca>
80006b12:	70 39       	ld.w	r9,r8[0xc]
80006b14:	8d 39       	st.w	r6[0xc],r9
80006b16:	8d 28       	st.w	r6[0x8],r8
80006b18:	91 36       	st.w	r8[0xc],r6
80006b1a:	93 26       	st.w	r9[0x8],r6
80006b1c:	e6 08 14 02 	asr	r8,r3,0x2
80006b20:	30 1b       	mov	r11,1
80006b22:	e0 64 05 38 	mov	r4,1336
80006b26:	f6 08 09 4b 	lsl	r11,r11,r8
80006b2a:	68 18       	ld.w	r8,r4[0x4]
80006b2c:	10 3b       	cp.w	r11,r8
80006b2e:	e0 8b 00 6b 	brhi	80006c04 <_malloc_r+0x2cc>
80006b32:	f7 e8 00 09 	and	r9,r11,r8
80006b36:	c0 b1       	brne	80006b4c <_malloc_r+0x214>
80006b38:	e0 13 ff fc 	andl	r3,0xfffc
80006b3c:	a1 7b       	lsl	r11,0x1
80006b3e:	2f c3       	sub	r3,-4
80006b40:	c0 38       	rjmp	80006b46 <_malloc_r+0x20e>
80006b42:	2f c3       	sub	r3,-4
80006b44:	a1 7b       	lsl	r11,0x1
80006b46:	f7 e8 00 09 	and	r9,r11,r8
80006b4a:	cf c0       	breq	80006b42 <_malloc_r+0x20a>
80006b4c:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80006b50:	06 92       	mov	r2,r3
80006b52:	1c 91       	mov	r1,lr
80006b54:	62 36       	ld.w	r6,r1[0xc]
80006b56:	c2 e8       	rjmp	80006bb2 <_malloc_r+0x27a>
80006b58:	6c 1a       	ld.w	r10,r6[0x4]
80006b5a:	e0 1a ff fc 	andl	r10,0xfffc
80006b5e:	f4 07 01 08 	sub	r8,r10,r7
80006b62:	58 f8       	cp.w	r8,15
80006b64:	e0 8a 00 15 	brle	80006b8e <_malloc_r+0x256>
80006b68:	6c 3a       	ld.w	r10,r6[0xc]
80006b6a:	6c 29       	ld.w	r9,r6[0x8]
80006b6c:	95 29       	st.w	r10[0x8],r9
80006b6e:	93 3a       	st.w	r9[0xc],r10
80006b70:	0e 99       	mov	r9,r7
80006b72:	ec 07 00 07 	add	r7,r6,r7
80006b76:	a1 a9       	sbr	r9,0x0
80006b78:	99 37       	st.w	r12[0xc],r7
80006b7a:	99 27       	st.w	r12[0x8],r7
80006b7c:	8d 19       	st.w	r6[0x4],r9
80006b7e:	ee 08 09 08 	st.w	r7[r8],r8
80006b82:	8f 2c       	st.w	r7[0x8],r12
80006b84:	8f 3c       	st.w	r7[0xc],r12
80006b86:	a1 a8       	sbr	r8,0x0
80006b88:	0a 9c       	mov	r12,r5
80006b8a:	8f 18       	st.w	r7[0x4],r8
80006b8c:	c0 d8       	rjmp	80006ba6 <_malloc_r+0x26e>
80006b8e:	6c 39       	ld.w	r9,r6[0xc]
80006b90:	58 08       	cp.w	r8,0
80006b92:	c0 f5       	brlt	80006bb0 <_malloc_r+0x278>
80006b94:	ec 0a 00 0a 	add	r10,r6,r10
80006b98:	74 18       	ld.w	r8,r10[0x4]
80006b9a:	a1 a8       	sbr	r8,0x0
80006b9c:	0a 9c       	mov	r12,r5
80006b9e:	95 18       	st.w	r10[0x4],r8
80006ba0:	6c 28       	ld.w	r8,r6[0x8]
80006ba2:	93 28       	st.w	r9[0x8],r8
80006ba4:	91 39       	st.w	r8[0xc],r9
80006ba6:	fe b0 f4 3b 	rcall	8000541c <__malloc_unlock>
80006baa:	ec cc ff f8 	sub	r12,r6,-8
80006bae:	d8 32       	popm	r0-r7,pc
80006bb0:	12 96       	mov	r6,r9
80006bb2:	02 36       	cp.w	r6,r1
80006bb4:	cd 21       	brne	80006b58 <_malloc_r+0x220>
80006bb6:	2f f2       	sub	r2,-1
80006bb8:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006bbc:	c0 30       	breq	80006bc2 <_malloc_r+0x28a>
80006bbe:	2f 81       	sub	r1,-8
80006bc0:	cc ab       	rjmp	80006b54 <_malloc_r+0x21c>
80006bc2:	1c 98       	mov	r8,lr
80006bc4:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006bc8:	c0 81       	brne	80006bd8 <_malloc_r+0x2a0>
80006bca:	68 19       	ld.w	r9,r4[0x4]
80006bcc:	f6 08 11 ff 	rsub	r8,r11,-1
80006bd0:	f3 e8 00 08 	and	r8,r9,r8
80006bd4:	89 18       	st.w	r4[0x4],r8
80006bd6:	c0 78       	rjmp	80006be4 <_malloc_r+0x2ac>
80006bd8:	f0 c9 00 08 	sub	r9,r8,8
80006bdc:	20 13       	sub	r3,1
80006bde:	70 08       	ld.w	r8,r8[0x0]
80006be0:	12 38       	cp.w	r8,r9
80006be2:	cf 10       	breq	80006bc4 <_malloc_r+0x28c>
80006be4:	a1 7b       	lsl	r11,0x1
80006be6:	68 18       	ld.w	r8,r4[0x4]
80006be8:	10 3b       	cp.w	r11,r8
80006bea:	e0 8b 00 0d 	brhi	80006c04 <_malloc_r+0x2cc>
80006bee:	58 0b       	cp.w	r11,0
80006bf0:	c0 a0       	breq	80006c04 <_malloc_r+0x2cc>
80006bf2:	04 93       	mov	r3,r2
80006bf4:	c0 38       	rjmp	80006bfa <_malloc_r+0x2c2>
80006bf6:	2f c3       	sub	r3,-4
80006bf8:	a1 7b       	lsl	r11,0x1
80006bfa:	f7 e8 00 09 	and	r9,r11,r8
80006bfe:	ca 71       	brne	80006b4c <_malloc_r+0x214>
80006c00:	cf bb       	rjmp	80006bf6 <_malloc_r+0x2be>
80006c02:	d7 03       	nop
80006c04:	68 23       	ld.w	r3,r4[0x8]
80006c06:	66 12       	ld.w	r2,r3[0x4]
80006c08:	e0 12 ff fc 	andl	r2,0xfffc
80006c0c:	0e 32       	cp.w	r2,r7
80006c0e:	5f 39       	srlo	r9
80006c10:	e4 07 01 08 	sub	r8,r2,r7
80006c14:	58 f8       	cp.w	r8,15
80006c16:	5f aa       	srle	r10
80006c18:	f5 e9 10 09 	or	r9,r10,r9
80006c1c:	e0 80 00 9a 	breq	80006d50 <_malloc_r+0x418>
80006c20:	e0 68 0d 7c 	mov	r8,3452
80006c24:	70 01       	ld.w	r1,r8[0x0]
80006c26:	e0 68 09 44 	mov	r8,2372
80006c2a:	2f 01       	sub	r1,-16
80006c2c:	70 08       	ld.w	r8,r8[0x0]
80006c2e:	0e 01       	add	r1,r7
80006c30:	5b f8       	cp.w	r8,-1
80006c32:	c0 40       	breq	80006c3a <_malloc_r+0x302>
80006c34:	28 11       	sub	r1,-127
80006c36:	e0 11 ff 80 	andl	r1,0xff80
80006c3a:	02 9b       	mov	r11,r1
80006c3c:	0a 9c       	mov	r12,r5
80006c3e:	e0 a0 02 a5 	rcall	80007188 <_sbrk_r>
80006c42:	18 96       	mov	r6,r12
80006c44:	5b fc       	cp.w	r12,-1
80006c46:	c7 50       	breq	80006d30 <_malloc_r+0x3f8>
80006c48:	e6 02 00 08 	add	r8,r3,r2
80006c4c:	10 3c       	cp.w	r12,r8
80006c4e:	c0 32       	brcc	80006c54 <_malloc_r+0x31c>
80006c50:	08 33       	cp.w	r3,r4
80006c52:	c6 f1       	brne	80006d30 <_malloc_r+0x3f8>
80006c54:	e0 6a 0d 80 	mov	r10,3456
80006c58:	74 09       	ld.w	r9,r10[0x0]
80006c5a:	e2 09 00 09 	add	r9,r1,r9
80006c5e:	95 09       	st.w	r10[0x0],r9
80006c60:	10 36       	cp.w	r6,r8
80006c62:	c0 a1       	brne	80006c76 <_malloc_r+0x33e>
80006c64:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80006c68:	c0 71       	brne	80006c76 <_malloc_r+0x33e>
80006c6a:	e2 02 00 02 	add	r2,r1,r2
80006c6e:	68 28       	ld.w	r8,r4[0x8]
80006c70:	a1 a2       	sbr	r2,0x0
80006c72:	91 12       	st.w	r8[0x4],r2
80006c74:	c4 f8       	rjmp	80006d12 <_malloc_r+0x3da>
80006c76:	e0 6a 09 44 	mov	r10,2372
80006c7a:	74 0b       	ld.w	r11,r10[0x0]
80006c7c:	5b fb       	cp.w	r11,-1
80006c7e:	c0 31       	brne	80006c84 <_malloc_r+0x34c>
80006c80:	95 06       	st.w	r10[0x0],r6
80006c82:	c0 78       	rjmp	80006c90 <_malloc_r+0x358>
80006c84:	ec 09 00 09 	add	r9,r6,r9
80006c88:	e0 6a 0d 80 	mov	r10,3456
80006c8c:	10 19       	sub	r9,r8
80006c8e:	95 09       	st.w	r10[0x0],r9
80006c90:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006c94:	f0 09 11 08 	rsub	r9,r8,8
80006c98:	58 08       	cp.w	r8,0
80006c9a:	f2 08 17 10 	movne	r8,r9
80006c9e:	ed d8 e1 06 	addne	r6,r6,r8
80006ca2:	28 08       	sub	r8,-128
80006ca4:	ec 01 00 01 	add	r1,r6,r1
80006ca8:	0a 9c       	mov	r12,r5
80006caa:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006cae:	f0 01 01 01 	sub	r1,r8,r1
80006cb2:	02 9b       	mov	r11,r1
80006cb4:	e0 a0 02 6a 	rcall	80007188 <_sbrk_r>
80006cb8:	e0 68 0d 80 	mov	r8,3456
80006cbc:	5b fc       	cp.w	r12,-1
80006cbe:	ec 0c 17 00 	moveq	r12,r6
80006cc2:	f9 b1 00 00 	moveq	r1,0
80006cc6:	70 09       	ld.w	r9,r8[0x0]
80006cc8:	0c 1c       	sub	r12,r6
80006cca:	89 26       	st.w	r4[0x8],r6
80006ccc:	02 0c       	add	r12,r1
80006cce:	12 01       	add	r1,r9
80006cd0:	a1 ac       	sbr	r12,0x0
80006cd2:	91 01       	st.w	r8[0x0],r1
80006cd4:	8d 1c       	st.w	r6[0x4],r12
80006cd6:	08 33       	cp.w	r3,r4
80006cd8:	c1 d0       	breq	80006d12 <_malloc_r+0x3da>
80006cda:	58 f2       	cp.w	r2,15
80006cdc:	e0 8b 00 05 	brhi	80006ce6 <_malloc_r+0x3ae>
80006ce0:	30 18       	mov	r8,1
80006ce2:	8d 18       	st.w	r6[0x4],r8
80006ce4:	c2 68       	rjmp	80006d30 <_malloc_r+0x3f8>
80006ce6:	30 59       	mov	r9,5
80006ce8:	20 c2       	sub	r2,12
80006cea:	e0 12 ff f8 	andl	r2,0xfff8
80006cee:	e6 02 00 08 	add	r8,r3,r2
80006cf2:	91 29       	st.w	r8[0x8],r9
80006cf4:	91 19       	st.w	r8[0x4],r9
80006cf6:	66 18       	ld.w	r8,r3[0x4]
80006cf8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006cfc:	e5 e8 10 08 	or	r8,r2,r8
80006d00:	87 18       	st.w	r3[0x4],r8
80006d02:	58 f2       	cp.w	r2,15
80006d04:	e0 88 00 07 	brls	80006d12 <_malloc_r+0x3da>
80006d08:	e6 cb ff f8 	sub	r11,r3,-8
80006d0c:	0a 9c       	mov	r12,r5
80006d0e:	e0 a0 1c 77 	rcall	8000a5fc <_free_r>
80006d12:	e0 69 0d 78 	mov	r9,3448
80006d16:	72 0a       	ld.w	r10,r9[0x0]
80006d18:	e0 68 0d 80 	mov	r8,3456
80006d1c:	70 08       	ld.w	r8,r8[0x0]
80006d1e:	14 38       	cp.w	r8,r10
80006d20:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006d24:	e0 69 0d 74 	mov	r9,3444
80006d28:	72 0a       	ld.w	r10,r9[0x0]
80006d2a:	14 38       	cp.w	r8,r10
80006d2c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006d30:	68 28       	ld.w	r8,r4[0x8]
80006d32:	70 18       	ld.w	r8,r8[0x4]
80006d34:	e0 18 ff fc 	andl	r8,0xfffc
80006d38:	0e 38       	cp.w	r8,r7
80006d3a:	5f 39       	srlo	r9
80006d3c:	0e 18       	sub	r8,r7
80006d3e:	58 f8       	cp.w	r8,15
80006d40:	5f aa       	srle	r10
80006d42:	f5 e9 10 09 	or	r9,r10,r9
80006d46:	c0 50       	breq	80006d50 <_malloc_r+0x418>
80006d48:	0a 9c       	mov	r12,r5
80006d4a:	fe b0 f3 69 	rcall	8000541c <__malloc_unlock>
80006d4e:	d8 3a       	popm	r0-r7,pc,r12=0
80006d50:	68 26       	ld.w	r6,r4[0x8]
80006d52:	a1 a8       	sbr	r8,0x0
80006d54:	0e 99       	mov	r9,r7
80006d56:	a1 a9       	sbr	r9,0x0
80006d58:	8d 19       	st.w	r6[0x4],r9
80006d5a:	ec 07 00 07 	add	r7,r6,r7
80006d5e:	0a 9c       	mov	r12,r5
80006d60:	89 27       	st.w	r4[0x8],r7
80006d62:	8f 18       	st.w	r7[0x4],r8
80006d64:	fe b0 f3 5c 	rcall	8000541c <__malloc_unlock>
80006d68:	ec cc ff f8 	sub	r12,r6,-8
80006d6c:	d8 32       	popm	r0-r7,pc
80006d6e:	d7 03       	nop

80006d70 <memcpy>:
80006d70:	58 8a       	cp.w	r10,8
80006d72:	c2 f5       	brlt	80006dd0 <memcpy+0x60>
80006d74:	f9 eb 10 09 	or	r9,r12,r11
80006d78:	e2 19 00 03 	andl	r9,0x3,COH
80006d7c:	e0 81 00 97 	brne	80006eaa <memcpy+0x13a>
80006d80:	e0 4a 00 20 	cp.w	r10,32
80006d84:	c3 b4       	brge	80006dfa <memcpy+0x8a>
80006d86:	f4 08 14 02 	asr	r8,r10,0x2
80006d8a:	f0 09 11 08 	rsub	r9,r8,8
80006d8e:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80006d92:	76 69       	ld.w	r9,r11[0x18]
80006d94:	99 69       	st.w	r12[0x18],r9
80006d96:	76 59       	ld.w	r9,r11[0x14]
80006d98:	99 59       	st.w	r12[0x14],r9
80006d9a:	76 49       	ld.w	r9,r11[0x10]
80006d9c:	99 49       	st.w	r12[0x10],r9
80006d9e:	76 39       	ld.w	r9,r11[0xc]
80006da0:	99 39       	st.w	r12[0xc],r9
80006da2:	76 29       	ld.w	r9,r11[0x8]
80006da4:	99 29       	st.w	r12[0x8],r9
80006da6:	76 19       	ld.w	r9,r11[0x4]
80006da8:	99 19       	st.w	r12[0x4],r9
80006daa:	76 09       	ld.w	r9,r11[0x0]
80006dac:	99 09       	st.w	r12[0x0],r9
80006dae:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80006db2:	f8 08 00 28 	add	r8,r12,r8<<0x2
80006db6:	e0 1a 00 03 	andl	r10,0x3
80006dba:	f4 0a 11 04 	rsub	r10,r10,4
80006dbe:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006dc2:	17 a9       	ld.ub	r9,r11[0x2]
80006dc4:	b0 a9       	st.b	r8[0x2],r9
80006dc6:	17 99       	ld.ub	r9,r11[0x1]
80006dc8:	b0 99       	st.b	r8[0x1],r9
80006dca:	17 89       	ld.ub	r9,r11[0x0]
80006dcc:	b0 89       	st.b	r8[0x0],r9
80006dce:	5e fc       	retal	r12
80006dd0:	f4 0a 11 09 	rsub	r10,r10,9
80006dd4:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006dd8:	17 f9       	ld.ub	r9,r11[0x7]
80006dda:	b8 f9       	st.b	r12[0x7],r9
80006ddc:	17 e9       	ld.ub	r9,r11[0x6]
80006dde:	b8 e9       	st.b	r12[0x6],r9
80006de0:	17 d9       	ld.ub	r9,r11[0x5]
80006de2:	b8 d9       	st.b	r12[0x5],r9
80006de4:	17 c9       	ld.ub	r9,r11[0x4]
80006de6:	b8 c9       	st.b	r12[0x4],r9
80006de8:	17 b9       	ld.ub	r9,r11[0x3]
80006dea:	b8 b9       	st.b	r12[0x3],r9
80006dec:	17 a9       	ld.ub	r9,r11[0x2]
80006dee:	b8 a9       	st.b	r12[0x2],r9
80006df0:	17 99       	ld.ub	r9,r11[0x1]
80006df2:	b8 99       	st.b	r12[0x1],r9
80006df4:	17 89       	ld.ub	r9,r11[0x0]
80006df6:	b8 89       	st.b	r12[0x0],r9
80006df8:	5e fc       	retal	r12
80006dfa:	eb cd 40 c0 	pushm	r6-r7,lr
80006dfe:	18 99       	mov	r9,r12
80006e00:	22 0a       	sub	r10,32
80006e02:	b7 07       	ld.d	r6,r11++
80006e04:	b3 26       	st.d	r9++,r6
80006e06:	b7 07       	ld.d	r6,r11++
80006e08:	b3 26       	st.d	r9++,r6
80006e0a:	b7 07       	ld.d	r6,r11++
80006e0c:	b3 26       	st.d	r9++,r6
80006e0e:	b7 07       	ld.d	r6,r11++
80006e10:	b3 26       	st.d	r9++,r6
80006e12:	22 0a       	sub	r10,32
80006e14:	cf 74       	brge	80006e02 <memcpy+0x92>
80006e16:	2f 0a       	sub	r10,-16
80006e18:	c0 65       	brlt	80006e24 <memcpy+0xb4>
80006e1a:	b7 07       	ld.d	r6,r11++
80006e1c:	b3 26       	st.d	r9++,r6
80006e1e:	b7 07       	ld.d	r6,r11++
80006e20:	b3 26       	st.d	r9++,r6
80006e22:	21 0a       	sub	r10,16
80006e24:	5c 3a       	neg	r10
80006e26:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80006e2a:	d7 03       	nop
80006e2c:	d7 03       	nop
80006e2e:	f7 36 00 0e 	ld.ub	r6,r11[14]
80006e32:	f3 66 00 0e 	st.b	r9[14],r6
80006e36:	f7 36 00 0d 	ld.ub	r6,r11[13]
80006e3a:	f3 66 00 0d 	st.b	r9[13],r6
80006e3e:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006e42:	f3 66 00 0c 	st.b	r9[12],r6
80006e46:	f7 36 00 0b 	ld.ub	r6,r11[11]
80006e4a:	f3 66 00 0b 	st.b	r9[11],r6
80006e4e:	f7 36 00 0a 	ld.ub	r6,r11[10]
80006e52:	f3 66 00 0a 	st.b	r9[10],r6
80006e56:	f7 36 00 09 	ld.ub	r6,r11[9]
80006e5a:	f3 66 00 09 	st.b	r9[9],r6
80006e5e:	f7 36 00 08 	ld.ub	r6,r11[8]
80006e62:	f3 66 00 08 	st.b	r9[8],r6
80006e66:	f7 36 00 07 	ld.ub	r6,r11[7]
80006e6a:	f3 66 00 07 	st.b	r9[7],r6
80006e6e:	f7 36 00 06 	ld.ub	r6,r11[6]
80006e72:	f3 66 00 06 	st.b	r9[6],r6
80006e76:	f7 36 00 05 	ld.ub	r6,r11[5]
80006e7a:	f3 66 00 05 	st.b	r9[5],r6
80006e7e:	f7 36 00 04 	ld.ub	r6,r11[4]
80006e82:	f3 66 00 04 	st.b	r9[4],r6
80006e86:	f7 36 00 03 	ld.ub	r6,r11[3]
80006e8a:	f3 66 00 03 	st.b	r9[3],r6
80006e8e:	f7 36 00 02 	ld.ub	r6,r11[2]
80006e92:	f3 66 00 02 	st.b	r9[2],r6
80006e96:	f7 36 00 01 	ld.ub	r6,r11[1]
80006e9a:	f3 66 00 01 	st.b	r9[1],r6
80006e9e:	f7 36 00 00 	ld.ub	r6,r11[0]
80006ea2:	f3 66 00 00 	st.b	r9[0],r6
80006ea6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006eaa:	20 1a       	sub	r10,1
80006eac:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006eb0:	f8 0a 0b 09 	st.b	r12[r10],r9
80006eb4:	cf b1       	brne	80006eaa <memcpy+0x13a>
80006eb6:	5e fc       	retal	r12

80006eb8 <memset>:
80006eb8:	18 98       	mov	r8,r12
80006eba:	c0 38       	rjmp	80006ec0 <memset+0x8>
80006ebc:	10 cb       	st.b	r8++,r11
80006ebe:	20 1a       	sub	r10,1
80006ec0:	58 0a       	cp.w	r10,0
80006ec2:	cf d1       	brne	80006ebc <memset+0x4>
80006ec4:	5e fc       	retal	r12
80006ec6:	d7 03       	nop

80006ec8 <_realloc_r>:
80006ec8:	d4 31       	pushm	r0-r7,lr
80006eca:	20 1d       	sub	sp,4
80006ecc:	16 94       	mov	r4,r11
80006ece:	18 92       	mov	r2,r12
80006ed0:	14 9b       	mov	r11,r10
80006ed2:	58 04       	cp.w	r4,0
80006ed4:	c0 51       	brne	80006ede <_realloc_r+0x16>
80006ed6:	fe b0 fd 31 	rcall	80006938 <_malloc_r>
80006eda:	18 95       	mov	r5,r12
80006edc:	c5 39       	rjmp	80007182 <_realloc_r+0x2ba>
80006ede:	50 0a       	stdsp	sp[0x0],r10
80006ee0:	fe b0 f2 98 	rcall	80005410 <__malloc_lock>
80006ee4:	40 0b       	lddsp	r11,sp[0x0]
80006ee6:	f6 c8 ff f5 	sub	r8,r11,-11
80006eea:	e8 c1 00 08 	sub	r1,r4,8
80006eee:	10 96       	mov	r6,r8
80006ef0:	62 1c       	ld.w	r12,r1[0x4]
80006ef2:	e0 16 ff f8 	andl	r6,0xfff8
80006ef6:	59 68       	cp.w	r8,22
80006ef8:	f9 b6 08 10 	movls	r6,16
80006efc:	16 36       	cp.w	r6,r11
80006efe:	5f 38       	srlo	r8
80006f00:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80006f04:	c0 50       	breq	80006f0e <_realloc_r+0x46>
80006f06:	30 c8       	mov	r8,12
80006f08:	30 05       	mov	r5,0
80006f0a:	85 38       	st.w	r2[0xc],r8
80006f0c:	c3 b9       	rjmp	80007182 <_realloc_r+0x2ba>
80006f0e:	18 90       	mov	r0,r12
80006f10:	e0 10 ff fc 	andl	r0,0xfffc
80006f14:	0c 30       	cp.w	r0,r6
80006f16:	e0 84 01 0b 	brge	8000712c <_realloc_r+0x264>
80006f1a:	e0 68 05 38 	mov	r8,1336
80006f1e:	e2 00 00 09 	add	r9,r1,r0
80006f22:	70 25       	ld.w	r5,r8[0x8]
80006f24:	0a 39       	cp.w	r9,r5
80006f26:	c0 90       	breq	80006f38 <_realloc_r+0x70>
80006f28:	72 1a       	ld.w	r10,r9[0x4]
80006f2a:	a1 ca       	cbr	r10,0x0
80006f2c:	f2 0a 00 0a 	add	r10,r9,r10
80006f30:	74 1a       	ld.w	r10,r10[0x4]
80006f32:	ed ba 00 00 	bld	r10,0x0
80006f36:	c2 20       	breq	80006f7a <_realloc_r+0xb2>
80006f38:	72 1a       	ld.w	r10,r9[0x4]
80006f3a:	e0 1a ff fc 	andl	r10,0xfffc
80006f3e:	f4 00 00 03 	add	r3,r10,r0
80006f42:	0a 39       	cp.w	r9,r5
80006f44:	c1 31       	brne	80006f6a <_realloc_r+0xa2>
80006f46:	ec c7 ff f0 	sub	r7,r6,-16
80006f4a:	0e 33       	cp.w	r3,r7
80006f4c:	c1 95       	brlt	80006f7e <_realloc_r+0xb6>
80006f4e:	e2 06 00 09 	add	r9,r1,r6
80006f52:	0c 13       	sub	r3,r6
80006f54:	a1 a3       	sbr	r3,0x0
80006f56:	93 13       	st.w	r9[0x4],r3
80006f58:	91 29       	st.w	r8[0x8],r9
80006f5a:	04 9c       	mov	r12,r2
80006f5c:	62 18       	ld.w	r8,r1[0x4]
80006f5e:	08 95       	mov	r5,r4
80006f60:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006f64:	10 46       	or	r6,r8
80006f66:	83 16       	st.w	r1[0x4],r6
80006f68:	c0 b9       	rjmp	8000717e <_realloc_r+0x2b6>
80006f6a:	0c 33       	cp.w	r3,r6
80006f6c:	c0 95       	brlt	80006f7e <_realloc_r+0xb6>
80006f6e:	72 28       	ld.w	r8,r9[0x8]
80006f70:	02 97       	mov	r7,r1
80006f72:	72 39       	ld.w	r9,r9[0xc]
80006f74:	93 28       	st.w	r9[0x8],r8
80006f76:	91 39       	st.w	r8[0xc],r9
80006f78:	cd c8       	rjmp	80007130 <_realloc_r+0x268>
80006f7a:	30 0a       	mov	r10,0
80006f7c:	14 99       	mov	r9,r10
80006f7e:	ed bc 00 00 	bld	r12,0x0
80006f82:	e0 80 00 95 	breq	800070ac <_realloc_r+0x1e4>
80006f86:	62 07       	ld.w	r7,r1[0x0]
80006f88:	e2 07 01 07 	sub	r7,r1,r7
80006f8c:	6e 1c       	ld.w	r12,r7[0x4]
80006f8e:	e0 1c ff fc 	andl	r12,0xfffc
80006f92:	58 09       	cp.w	r9,0
80006f94:	c5 60       	breq	80007040 <_realloc_r+0x178>
80006f96:	f8 00 00 03 	add	r3,r12,r0
80006f9a:	0a 39       	cp.w	r9,r5
80006f9c:	c4 81       	brne	8000702c <_realloc_r+0x164>
80006f9e:	14 03       	add	r3,r10
80006fa0:	ec c9 ff f0 	sub	r9,r6,-16
80006fa4:	12 33       	cp.w	r3,r9
80006fa6:	c4 d5       	brlt	80007040 <_realloc_r+0x178>
80006fa8:	6e 3a       	ld.w	r10,r7[0xc]
80006faa:	6e 29       	ld.w	r9,r7[0x8]
80006fac:	95 29       	st.w	r10[0x8],r9
80006fae:	93 3a       	st.w	r9[0xc],r10
80006fb0:	ee c5 ff f8 	sub	r5,r7,-8
80006fb4:	e0 ca 00 04 	sub	r10,r0,4
80006fb8:	e0 4a 00 24 	cp.w	r10,36
80006fbc:	e0 8b 00 25 	brhi	80007006 <_realloc_r+0x13e>
80006fc0:	0a 99       	mov	r9,r5
80006fc2:	59 3a       	cp.w	r10,19
80006fc4:	e0 88 00 1a 	brls	80006ff8 <_realloc_r+0x130>
80006fc8:	09 09       	ld.w	r9,r4++
80006fca:	8b 09       	st.w	r5[0x0],r9
80006fcc:	09 09       	ld.w	r9,r4++
80006fce:	8f 39       	st.w	r7[0xc],r9
80006fd0:	ee c9 ff f0 	sub	r9,r7,-16
80006fd4:	59 ba       	cp.w	r10,27
80006fd6:	e0 88 00 11 	brls	80006ff8 <_realloc_r+0x130>
80006fda:	09 0b       	ld.w	r11,r4++
80006fdc:	93 0b       	st.w	r9[0x0],r11
80006fde:	09 09       	ld.w	r9,r4++
80006fe0:	8f 59       	st.w	r7[0x14],r9
80006fe2:	ee c9 ff e8 	sub	r9,r7,-24
80006fe6:	e0 4a 00 24 	cp.w	r10,36
80006fea:	c0 71       	brne	80006ff8 <_realloc_r+0x130>
80006fec:	09 0a       	ld.w	r10,r4++
80006fee:	93 0a       	st.w	r9[0x0],r10
80006ff0:	ee c9 ff e0 	sub	r9,r7,-32
80006ff4:	09 0a       	ld.w	r10,r4++
80006ff6:	8f 7a       	st.w	r7[0x1c],r10
80006ff8:	09 0a       	ld.w	r10,r4++
80006ffa:	12 aa       	st.w	r9++,r10
80006ffc:	68 0a       	ld.w	r10,r4[0x0]
80006ffe:	93 0a       	st.w	r9[0x0],r10
80007000:	68 1a       	ld.w	r10,r4[0x4]
80007002:	93 1a       	st.w	r9[0x4],r10
80007004:	c0 78       	rjmp	80007012 <_realloc_r+0x14a>
80007006:	50 08       	stdsp	sp[0x0],r8
80007008:	08 9b       	mov	r11,r4
8000700a:	0a 9c       	mov	r12,r5
8000700c:	e0 a0 1d 9b 	rcall	8000ab42 <memmove>
80007010:	40 08       	lddsp	r8,sp[0x0]
80007012:	ee 06 00 09 	add	r9,r7,r6
80007016:	0c 13       	sub	r3,r6
80007018:	a1 a3       	sbr	r3,0x0
8000701a:	93 13       	st.w	r9[0x4],r3
8000701c:	91 29       	st.w	r8[0x8],r9
8000701e:	04 9c       	mov	r12,r2
80007020:	6e 18       	ld.w	r8,r7[0x4]
80007022:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007026:	10 46       	or	r6,r8
80007028:	8f 16       	st.w	r7[0x4],r6
8000702a:	ca a8       	rjmp	8000717e <_realloc_r+0x2b6>
8000702c:	14 03       	add	r3,r10
8000702e:	0c 33       	cp.w	r3,r6
80007030:	c0 85       	brlt	80007040 <_realloc_r+0x178>
80007032:	72 28       	ld.w	r8,r9[0x8]
80007034:	72 39       	ld.w	r9,r9[0xc]
80007036:	93 28       	st.w	r9[0x8],r8
80007038:	91 39       	st.w	r8[0xc],r9
8000703a:	6e 28       	ld.w	r8,r7[0x8]
8000703c:	6e 39       	ld.w	r9,r7[0xc]
8000703e:	c0 78       	rjmp	8000704c <_realloc_r+0x184>
80007040:	f8 00 00 03 	add	r3,r12,r0
80007044:	0c 33       	cp.w	r3,r6
80007046:	c3 35       	brlt	800070ac <_realloc_r+0x1e4>
80007048:	6e 39       	ld.w	r9,r7[0xc]
8000704a:	6e 28       	ld.w	r8,r7[0x8]
8000704c:	93 28       	st.w	r9[0x8],r8
8000704e:	91 39       	st.w	r8[0xc],r9
80007050:	e0 ca 00 04 	sub	r10,r0,4
80007054:	ee cc ff f8 	sub	r12,r7,-8
80007058:	e0 4a 00 24 	cp.w	r10,36
8000705c:	e0 8b 00 24 	brhi	800070a4 <_realloc_r+0x1dc>
80007060:	59 3a       	cp.w	r10,19
80007062:	e0 88 00 1a 	brls	80007096 <_realloc_r+0x1ce>
80007066:	09 08       	ld.w	r8,r4++
80007068:	99 08       	st.w	r12[0x0],r8
8000706a:	09 08       	ld.w	r8,r4++
8000706c:	8f 38       	st.w	r7[0xc],r8
8000706e:	ee cc ff f0 	sub	r12,r7,-16
80007072:	59 ba       	cp.w	r10,27
80007074:	e0 88 00 11 	brls	80007096 <_realloc_r+0x1ce>
80007078:	09 08       	ld.w	r8,r4++
8000707a:	99 08       	st.w	r12[0x0],r8
8000707c:	09 08       	ld.w	r8,r4++
8000707e:	8f 58       	st.w	r7[0x14],r8
80007080:	ee cc ff e8 	sub	r12,r7,-24
80007084:	e0 4a 00 24 	cp.w	r10,36
80007088:	c0 71       	brne	80007096 <_realloc_r+0x1ce>
8000708a:	09 08       	ld.w	r8,r4++
8000708c:	99 08       	st.w	r12[0x0],r8
8000708e:	ee cc ff e0 	sub	r12,r7,-32
80007092:	09 08       	ld.w	r8,r4++
80007094:	8f 78       	st.w	r7[0x1c],r8
80007096:	09 08       	ld.w	r8,r4++
80007098:	18 a8       	st.w	r12++,r8
8000709a:	68 08       	ld.w	r8,r4[0x0]
8000709c:	99 08       	st.w	r12[0x0],r8
8000709e:	68 18       	ld.w	r8,r4[0x4]
800070a0:	99 18       	st.w	r12[0x4],r8
800070a2:	c4 78       	rjmp	80007130 <_realloc_r+0x268>
800070a4:	08 9b       	mov	r11,r4
800070a6:	e0 a0 1d 4e 	rcall	8000ab42 <memmove>
800070aa:	c4 38       	rjmp	80007130 <_realloc_r+0x268>
800070ac:	04 9c       	mov	r12,r2
800070ae:	fe b0 fc 45 	rcall	80006938 <_malloc_r>
800070b2:	18 95       	mov	r5,r12
800070b4:	c3 a0       	breq	80007128 <_realloc_r+0x260>
800070b6:	62 18       	ld.w	r8,r1[0x4]
800070b8:	f8 c9 00 08 	sub	r9,r12,8
800070bc:	a1 c8       	cbr	r8,0x0
800070be:	e2 08 00 08 	add	r8,r1,r8
800070c2:	10 39       	cp.w	r9,r8
800070c4:	c0 71       	brne	800070d2 <_realloc_r+0x20a>
800070c6:	72 13       	ld.w	r3,r9[0x4]
800070c8:	02 97       	mov	r7,r1
800070ca:	e0 13 ff fc 	andl	r3,0xfffc
800070ce:	00 03       	add	r3,r0
800070d0:	c3 08       	rjmp	80007130 <_realloc_r+0x268>
800070d2:	e0 ca 00 04 	sub	r10,r0,4
800070d6:	e0 4a 00 24 	cp.w	r10,36
800070da:	e0 8b 00 20 	brhi	8000711a <_realloc_r+0x252>
800070de:	08 99       	mov	r9,r4
800070e0:	18 98       	mov	r8,r12
800070e2:	59 3a       	cp.w	r10,19
800070e4:	e0 88 00 14 	brls	8000710c <_realloc_r+0x244>
800070e8:	13 0b       	ld.w	r11,r9++
800070ea:	10 ab       	st.w	r8++,r11
800070ec:	13 0b       	ld.w	r11,r9++
800070ee:	10 ab       	st.w	r8++,r11
800070f0:	59 ba       	cp.w	r10,27
800070f2:	e0 88 00 0d 	brls	8000710c <_realloc_r+0x244>
800070f6:	13 0b       	ld.w	r11,r9++
800070f8:	10 ab       	st.w	r8++,r11
800070fa:	13 0b       	ld.w	r11,r9++
800070fc:	10 ab       	st.w	r8++,r11
800070fe:	e0 4a 00 24 	cp.w	r10,36
80007102:	c0 51       	brne	8000710c <_realloc_r+0x244>
80007104:	13 0a       	ld.w	r10,r9++
80007106:	10 aa       	st.w	r8++,r10
80007108:	13 0a       	ld.w	r10,r9++
8000710a:	10 aa       	st.w	r8++,r10
8000710c:	13 0a       	ld.w	r10,r9++
8000710e:	10 aa       	st.w	r8++,r10
80007110:	72 0a       	ld.w	r10,r9[0x0]
80007112:	91 0a       	st.w	r8[0x0],r10
80007114:	72 19       	ld.w	r9,r9[0x4]
80007116:	91 19       	st.w	r8[0x4],r9
80007118:	c0 48       	rjmp	80007120 <_realloc_r+0x258>
8000711a:	08 9b       	mov	r11,r4
8000711c:	e0 a0 1d 13 	rcall	8000ab42 <memmove>
80007120:	08 9b       	mov	r11,r4
80007122:	04 9c       	mov	r12,r2
80007124:	e0 a0 1a 6c 	rcall	8000a5fc <_free_r>
80007128:	04 9c       	mov	r12,r2
8000712a:	c2 a8       	rjmp	8000717e <_realloc_r+0x2b6>
8000712c:	00 93       	mov	r3,r0
8000712e:	02 97       	mov	r7,r1
80007130:	e6 06 01 09 	sub	r9,r3,r6
80007134:	6e 18       	ld.w	r8,r7[0x4]
80007136:	58 f9       	cp.w	r9,15
80007138:	e0 88 00 16 	brls	80007164 <_realloc_r+0x29c>
8000713c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007140:	ed e8 10 08 	or	r8,r6,r8
80007144:	8f 18       	st.w	r7[0x4],r8
80007146:	12 98       	mov	r8,r9
80007148:	a1 a8       	sbr	r8,0x0
8000714a:	ee 06 00 0b 	add	r11,r7,r6
8000714e:	f6 09 00 09 	add	r9,r11,r9
80007152:	97 18       	st.w	r11[0x4],r8
80007154:	72 18       	ld.w	r8,r9[0x4]
80007156:	a1 a8       	sbr	r8,0x0
80007158:	2f 8b       	sub	r11,-8
8000715a:	93 18       	st.w	r9[0x4],r8
8000715c:	04 9c       	mov	r12,r2
8000715e:	e0 a0 1a 4f 	rcall	8000a5fc <_free_r>
80007162:	c0 b8       	rjmp	80007178 <_realloc_r+0x2b0>
80007164:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007168:	e7 e8 10 08 	or	r8,r3,r8
8000716c:	8f 18       	st.w	r7[0x4],r8
8000716e:	ee 03 00 03 	add	r3,r7,r3
80007172:	66 18       	ld.w	r8,r3[0x4]
80007174:	a1 a8       	sbr	r8,0x0
80007176:	87 18       	st.w	r3[0x4],r8
80007178:	04 9c       	mov	r12,r2
8000717a:	ee c5 ff f8 	sub	r5,r7,-8
8000717e:	fe b0 f1 4f 	rcall	8000541c <__malloc_unlock>
80007182:	0a 9c       	mov	r12,r5
80007184:	2f fd       	sub	sp,-4
80007186:	d8 32       	popm	r0-r7,pc

80007188 <_sbrk_r>:
80007188:	d4 21       	pushm	r4-r7,lr
8000718a:	30 08       	mov	r8,0
8000718c:	18 97       	mov	r7,r12
8000718e:	e0 66 41 18 	mov	r6,16664
80007192:	16 9c       	mov	r12,r11
80007194:	8d 08       	st.w	r6[0x0],r8
80007196:	c9 1c       	rcall	800072b8 <_sbrk>
80007198:	5b fc       	cp.w	r12,-1
8000719a:	c0 51       	brne	800071a4 <_sbrk_r+0x1c>
8000719c:	6c 08       	ld.w	r8,r6[0x0]
8000719e:	58 08       	cp.w	r8,0
800071a0:	ef f8 1a 03 	st.wne	r7[0xc],r8
800071a4:	d8 22       	popm	r4-r7,pc
800071a6:	d7 03       	nop

800071a8 <sprintf>:
800071a8:	d4 01       	pushm	lr
800071aa:	21 7d       	sub	sp,92
800071ac:	e0 68 ff ff 	mov	r8,65535
800071b0:	ea 18 7f ff 	orh	r8,0x7fff
800071b4:	50 58       	stdsp	sp[0x14],r8
800071b6:	50 28       	stdsp	sp[0x8],r8
800071b8:	e0 68 02 08 	mov	r8,520
800071bc:	ba 68       	st.h	sp[0xc],r8
800071be:	3f f8       	mov	r8,-1
800071c0:	ba 78       	st.h	sp[0xe],r8
800071c2:	e0 68 0a 38 	mov	r8,2616
800071c6:	50 4c       	stdsp	sp[0x10],r12
800071c8:	16 9a       	mov	r10,r11
800071ca:	50 0c       	stdsp	sp[0x0],r12
800071cc:	fa c9 ff a0 	sub	r9,sp,-96
800071d0:	70 0c       	ld.w	r12,r8[0x0]
800071d2:	1a 9b       	mov	r11,sp
800071d4:	e0 a0 02 26 	rcall	80007620 <_vfprintf_r>
800071d8:	30 09       	mov	r9,0
800071da:	40 08       	lddsp	r8,sp[0x0]
800071dc:	b0 89       	st.b	r8[0x0],r9
800071de:	2e 9d       	sub	sp,-92
800071e0:	d8 02       	popm	pc
800071e2:	d7 03       	nop

800071e4 <strlen>:
800071e4:	30 09       	mov	r9,0
800071e6:	18 98       	mov	r8,r12
800071e8:	c0 28       	rjmp	800071ec <strlen+0x8>
800071ea:	2f f8       	sub	r8,-1
800071ec:	11 8a       	ld.ub	r10,r8[0x0]
800071ee:	f2 0a 18 00 	cp.b	r10,r9
800071f2:	cf c1       	brne	800071ea <strlen+0x6>
800071f4:	f0 0c 01 0c 	sub	r12,r8,r12
800071f8:	5e fc       	retal	r12
800071fa:	d7 03       	nop

800071fc <strncpy>:
800071fc:	30 08       	mov	r8,0
800071fe:	10 3a       	cp.w	r10,r8
80007200:	5e 0c       	reteq	r12
80007202:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007206:	f8 08 0b 09 	st.b	r12[r8],r9
8000720a:	2f f8       	sub	r8,-1
8000720c:	58 09       	cp.w	r9,0
8000720e:	cf 81       	brne	800071fe <strncpy+0x2>
80007210:	10 3a       	cp.w	r10,r8
80007212:	5e 0c       	reteq	r12
80007214:	f8 08 0b 09 	st.b	r12[r8],r9
80007218:	2f f8       	sub	r8,-1
8000721a:	cf bb       	rjmp	80007210 <strncpy+0x14>

8000721c <_close>:
8000721c:	30 28       	mov	r8,2
8000721e:	d6 73       	breakpoint
80007220:	3f fc       	mov	r12,-1
80007222:	35 8b       	mov	r11,88
80007224:	58 0c       	cp.w	r12,0
80007226:	5e 4c       	retge	r12
80007228:	e0 6a 41 18 	mov	r10,16664
8000722c:	95 0b       	st.w	r10[0x0],r11
8000722e:	5e fc       	retal	r12

80007230 <_lseek>:
80007230:	30 58       	mov	r8,5
80007232:	d6 73       	breakpoint
80007234:	3f fc       	mov	r12,-1
80007236:	35 8b       	mov	r11,88
80007238:	58 0c       	cp.w	r12,0
8000723a:	5e 4c       	retge	r12
8000723c:	e0 6a 41 18 	mov	r10,16664
80007240:	95 0b       	st.w	r10[0x0],r11
80007242:	5e fc       	retal	r12

80007244 <isatty>:
80007244:	30 b8       	mov	r8,11
80007246:	d6 73       	breakpoint
80007248:	3f fc       	mov	r12,-1
8000724a:	35 8b       	mov	r11,88
8000724c:	58 0c       	cp.w	r12,0
8000724e:	5e 4c       	retge	r12
80007250:	e0 6a 41 18 	mov	r10,16664
80007254:	95 0b       	st.w	r10[0x0],r11
80007256:	5e fc       	retal	r12

80007258 <_fstat_host>:
80007258:	30 98       	mov	r8,9
8000725a:	d6 73       	breakpoint
8000725c:	3f fc       	mov	r12,-1
8000725e:	35 8b       	mov	r11,88
80007260:	58 0c       	cp.w	r12,0
80007262:	5e 4c       	retge	r12
80007264:	e0 6a 41 18 	mov	r10,16664
80007268:	95 0b       	st.w	r10[0x0],r11
8000726a:	5e fc       	retal	r12

8000726c <_fstat>:
8000726c:	d4 21       	pushm	r4-r7,lr
8000726e:	21 0d       	sub	sp,64
80007270:	16 97       	mov	r7,r11
80007272:	1a 9b       	mov	r11,sp
80007274:	cf 2f       	rcall	80007258 <_fstat_host>
80007276:	c0 34       	brge	8000727c <_fstat+0x10>
80007278:	3f fc       	mov	r12,-1
8000727a:	c1 c8       	rjmp	800072b2 <_fstat+0x46>
8000727c:	40 08       	lddsp	r8,sp[0x0]
8000727e:	ae 08       	st.h	r7[0x0],r8
80007280:	40 18       	lddsp	r8,sp[0x4]
80007282:	ae 18       	st.h	r7[0x2],r8
80007284:	40 28       	lddsp	r8,sp[0x8]
80007286:	8f 18       	st.w	r7[0x4],r8
80007288:	40 38       	lddsp	r8,sp[0xc]
8000728a:	ae 48       	st.h	r7[0x8],r8
8000728c:	40 48       	lddsp	r8,sp[0x10]
8000728e:	ae 58       	st.h	r7[0xa],r8
80007290:	40 58       	lddsp	r8,sp[0x14]
80007292:	ae 68       	st.h	r7[0xc],r8
80007294:	40 68       	lddsp	r8,sp[0x18]
80007296:	ae 78       	st.h	r7[0xe],r8
80007298:	40 88       	lddsp	r8,sp[0x20]
8000729a:	8f 48       	st.w	r7[0x10],r8
8000729c:	40 a8       	lddsp	r8,sp[0x28]
8000729e:	8f b8       	st.w	r7[0x2c],r8
800072a0:	40 c8       	lddsp	r8,sp[0x30]
800072a2:	8f c8       	st.w	r7[0x30],r8
800072a4:	40 d8       	lddsp	r8,sp[0x34]
800072a6:	8f 58       	st.w	r7[0x14],r8
800072a8:	40 e8       	lddsp	r8,sp[0x38]
800072aa:	30 0c       	mov	r12,0
800072ac:	8f 78       	st.w	r7[0x1c],r8
800072ae:	40 f8       	lddsp	r8,sp[0x3c]
800072b0:	8f 98       	st.w	r7[0x24],r8
800072b2:	2f 0d       	sub	sp,-64
800072b4:	d8 22       	popm	r4-r7,pc
800072b6:	d7 03       	nop

800072b8 <_sbrk>:
800072b8:	d4 01       	pushm	lr
800072ba:	e0 68 0d a8 	mov	r8,3496
800072be:	70 09       	ld.w	r9,r8[0x0]
800072c0:	58 09       	cp.w	r9,0
800072c2:	c0 41       	brne	800072ca <_sbrk+0x12>
800072c4:	e0 69 41 20 	mov	r9,16672
800072c8:	91 09       	st.w	r8[0x0],r9
800072ca:	e0 69 0d a8 	mov	r9,3496
800072ce:	e0 7a 70 00 	mov	r10,94208
800072d2:	72 08       	ld.w	r8,r9[0x0]
800072d4:	f0 0c 00 0c 	add	r12,r8,r12
800072d8:	14 3c       	cp.w	r12,r10
800072da:	e0 8b 00 04 	brhi	800072e2 <_sbrk+0x2a>
800072de:	93 0c       	st.w	r9[0x0],r12
800072e0:	c0 68       	rjmp	800072ec <_sbrk+0x34>
800072e2:	e0 a0 18 15 	rcall	8000a30c <__errno>
800072e6:	30 c8       	mov	r8,12
800072e8:	99 08       	st.w	r12[0x0],r8
800072ea:	3f f8       	mov	r8,-1
800072ec:	10 9c       	mov	r12,r8
800072ee:	d8 02       	popm	pc

800072f0 <get_arg>:
800072f0:	d4 31       	pushm	r0-r7,lr
800072f2:	20 8d       	sub	sp,32
800072f4:	fa c4 ff bc 	sub	r4,sp,-68
800072f8:	50 4b       	stdsp	sp[0x10],r11
800072fa:	68 2e       	ld.w	lr,r4[0x8]
800072fc:	50 58       	stdsp	sp[0x14],r8
800072fe:	12 96       	mov	r6,r9
80007300:	7c 0b       	ld.w	r11,lr[0x0]
80007302:	70 05       	ld.w	r5,r8[0x0]
80007304:	50 6e       	stdsp	sp[0x18],lr
80007306:	58 0b       	cp.w	r11,0
80007308:	f4 0b 17 00 	moveq	r11,r10
8000730c:	68 03       	ld.w	r3,r4[0x0]
8000730e:	68 11       	ld.w	r1,r4[0x4]
80007310:	40 49       	lddsp	r9,sp[0x10]
80007312:	30 08       	mov	r8,0
80007314:	c2 89       	rjmp	80007564 <get_arg+0x274>
80007316:	2f fb       	sub	r11,-1
80007318:	32 5c       	mov	r12,37
8000731a:	17 8a       	ld.ub	r10,r11[0x0]
8000731c:	f8 0a 18 00 	cp.b	r10,r12
80007320:	5f 1e       	srne	lr
80007322:	f0 0a 18 00 	cp.b	r10,r8
80007326:	5f 1c       	srne	r12
80007328:	fd ec 00 0c 	and	r12,lr,r12
8000732c:	f0 0c 18 00 	cp.b	r12,r8
80007330:	cf 31       	brne	80007316 <get_arg+0x26>
80007332:	58 0a       	cp.w	r10,0
80007334:	e0 80 01 25 	breq	8000757e <get_arg+0x28e>
80007338:	30 0c       	mov	r12,0
8000733a:	3f fa       	mov	r10,-1
8000733c:	18 90       	mov	r0,r12
8000733e:	50 3a       	stdsp	sp[0xc],r10
80007340:	18 94       	mov	r4,r12
80007342:	18 92       	mov	r2,r12
80007344:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007348:	16 97       	mov	r7,r11
8000734a:	50 7c       	stdsp	sp[0x1c],r12
8000734c:	fe cc 9a f4 	sub	r12,pc,-25868
80007350:	0f 3a       	ld.ub	r10,r7++
80007352:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007356:	40 7c       	lddsp	r12,sp[0x1c]
80007358:	1c 0c       	add	r12,lr
8000735a:	fe ce 9b ca 	sub	lr,pc,-25654
8000735e:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007362:	20 1e       	sub	lr,1
80007364:	50 0e       	stdsp	sp[0x0],lr
80007366:	fe ce 9c 42 	sub	lr,pc,-25534
8000736a:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000736e:	50 7c       	stdsp	sp[0x1c],r12
80007370:	40 0c       	lddsp	r12,sp[0x0]
80007372:	58 7c       	cp.w	r12,7
80007374:	e0 8b 00 f1 	brhi	80007556 <get_arg+0x266>
80007378:	fe ce 9d f4 	sub	lr,pc,-25100
8000737c:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007380:	36 8b       	mov	r11,104
80007382:	f6 0a 18 00 	cp.b	r10,r11
80007386:	e0 80 00 e8 	breq	80007556 <get_arg+0x266>
8000738a:	37 1b       	mov	r11,113
8000738c:	f6 0a 18 00 	cp.b	r10,r11
80007390:	c0 70       	breq	8000739e <get_arg+0xae>
80007392:	34 cb       	mov	r11,76
80007394:	f6 0a 18 00 	cp.b	r10,r11
80007398:	c0 51       	brne	800073a2 <get_arg+0xb2>
8000739a:	a3 b4       	sbr	r4,0x3
8000739c:	cd d8       	rjmp	80007556 <get_arg+0x266>
8000739e:	a5 b4       	sbr	r4,0x5
800073a0:	cd b8       	rjmp	80007556 <get_arg+0x266>
800073a2:	08 9a       	mov	r10,r4
800073a4:	0e 9b       	mov	r11,r7
800073a6:	a5 aa       	sbr	r10,0x4
800073a8:	17 3c       	ld.ub	r12,r11++
800073aa:	a5 b4       	sbr	r4,0x5
800073ac:	36 ce       	mov	lr,108
800073ae:	fc 0c 18 00 	cp.b	r12,lr
800073b2:	e0 80 00 d3 	breq	80007558 <get_arg+0x268>
800073b6:	14 94       	mov	r4,r10
800073b8:	cc f8       	rjmp	80007556 <get_arg+0x266>
800073ba:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
800073be:	36 7c       	mov	r12,103
800073c0:	f8 0a 18 00 	cp.b	r10,r12
800073c4:	e0 8b 00 27 	brhi	80007412 <get_arg+0x122>
800073c8:	36 5b       	mov	r11,101
800073ca:	f6 0a 18 00 	cp.b	r10,r11
800073ce:	c4 82       	brcc	8000745e <get_arg+0x16e>
800073d0:	34 fb       	mov	r11,79
800073d2:	f6 0a 18 00 	cp.b	r10,r11
800073d6:	c4 80       	breq	80007466 <get_arg+0x176>
800073d8:	e0 8b 00 0c 	brhi	800073f0 <get_arg+0x100>
800073dc:	34 5b       	mov	r11,69
800073de:	f6 0a 18 00 	cp.b	r10,r11
800073e2:	c3 e0       	breq	8000745e <get_arg+0x16e>
800073e4:	34 7b       	mov	r11,71
800073e6:	f6 0a 18 00 	cp.b	r10,r11
800073ea:	c3 a0       	breq	8000745e <get_arg+0x16e>
800073ec:	34 4b       	mov	r11,68
800073ee:	c0 88       	rjmp	800073fe <get_arg+0x10e>
800073f0:	35 8b       	mov	r11,88
800073f2:	f6 0a 18 00 	cp.b	r10,r11
800073f6:	c2 c0       	breq	8000744e <get_arg+0x15e>
800073f8:	e0 8b 00 07 	brhi	80007406 <get_arg+0x116>
800073fc:	35 5b       	mov	r11,85
800073fe:	f6 0a 18 00 	cp.b	r10,r11
80007402:	c3 51       	brne	8000746c <get_arg+0x17c>
80007404:	c3 18       	rjmp	80007466 <get_arg+0x176>
80007406:	36 3b       	mov	r11,99
80007408:	f6 0a 18 00 	cp.b	r10,r11
8000740c:	c2 f0       	breq	8000746a <get_arg+0x17a>
8000740e:	36 4b       	mov	r11,100
80007410:	c0 e8       	rjmp	8000742c <get_arg+0x13c>
80007412:	37 0b       	mov	r11,112
80007414:	f6 0a 18 00 	cp.b	r10,r11
80007418:	c2 50       	breq	80007462 <get_arg+0x172>
8000741a:	e0 8b 00 0d 	brhi	80007434 <get_arg+0x144>
8000741e:	36 eb       	mov	r11,110
80007420:	f6 0a 18 00 	cp.b	r10,r11
80007424:	c1 f0       	breq	80007462 <get_arg+0x172>
80007426:	e0 8b 00 14 	brhi	8000744e <get_arg+0x15e>
8000742a:	36 9b       	mov	r11,105
8000742c:	f6 0a 18 00 	cp.b	r10,r11
80007430:	c1 e1       	brne	8000746c <get_arg+0x17c>
80007432:	c0 e8       	rjmp	8000744e <get_arg+0x15e>
80007434:	37 5b       	mov	r11,117
80007436:	f6 0a 18 00 	cp.b	r10,r11
8000743a:	c0 a0       	breq	8000744e <get_arg+0x15e>
8000743c:	37 8b       	mov	r11,120
8000743e:	f6 0a 18 00 	cp.b	r10,r11
80007442:	c0 60       	breq	8000744e <get_arg+0x15e>
80007444:	37 3b       	mov	r11,115
80007446:	f6 0a 18 00 	cp.b	r10,r11
8000744a:	c1 11       	brne	8000746c <get_arg+0x17c>
8000744c:	c0 b8       	rjmp	80007462 <get_arg+0x172>
8000744e:	ed b4 00 04 	bld	r4,0x4
80007452:	c0 a0       	breq	80007466 <get_arg+0x176>
80007454:	ed b4 00 05 	bld	r4,0x5
80007458:	c0 91       	brne	8000746a <get_arg+0x17a>
8000745a:	30 20       	mov	r0,2
8000745c:	c0 88       	rjmp	8000746c <get_arg+0x17c>
8000745e:	30 40       	mov	r0,4
80007460:	c0 68       	rjmp	8000746c <get_arg+0x17c>
80007462:	30 30       	mov	r0,3
80007464:	c0 48       	rjmp	8000746c <get_arg+0x17c>
80007466:	30 10       	mov	r0,1
80007468:	c0 28       	rjmp	8000746c <get_arg+0x17c>
8000746a:	30 00       	mov	r0,0
8000746c:	40 3b       	lddsp	r11,sp[0xc]
8000746e:	5b fb       	cp.w	r11,-1
80007470:	c0 40       	breq	80007478 <get_arg+0x188>
80007472:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007476:	c7 08       	rjmp	80007556 <get_arg+0x266>
80007478:	58 60       	cp.w	r0,6
8000747a:	e0 8b 00 6e 	brhi	80007556 <get_arg+0x266>
8000747e:	6c 0a       	ld.w	r10,r6[0x0]
80007480:	ea cc ff ff 	sub	r12,r5,-1
80007484:	fe ce 9e e0 	sub	lr,pc,-24864
80007488:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000748c:	f4 cb ff f8 	sub	r11,r10,-8
80007490:	8d 0b       	st.w	r6[0x0],r11
80007492:	f4 ea 00 00 	ld.d	r10,r10[0]
80007496:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000749a:	c0 f8       	rjmp	800074b8 <get_arg+0x1c8>
8000749c:	f4 cb ff fc 	sub	r11,r10,-4
800074a0:	8d 0b       	st.w	r6[0x0],r11
800074a2:	74 0a       	ld.w	r10,r10[0x0]
800074a4:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800074a8:	c0 88       	rjmp	800074b8 <get_arg+0x1c8>
800074aa:	f4 cb ff f8 	sub	r11,r10,-8
800074ae:	8d 0b       	st.w	r6[0x0],r11
800074b0:	f4 ea 00 00 	ld.d	r10,r10[0]
800074b4:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800074b8:	0e 9b       	mov	r11,r7
800074ba:	18 95       	mov	r5,r12
800074bc:	c4 e8       	rjmp	80007558 <get_arg+0x268>
800074be:	62 0a       	ld.w	r10,r1[0x0]
800074c0:	5b fa       	cp.w	r10,-1
800074c2:	c0 b1       	brne	800074d8 <get_arg+0x1e8>
800074c4:	50 19       	stdsp	sp[0x4],r9
800074c6:	50 28       	stdsp	sp[0x8],r8
800074c8:	e0 6a 00 80 	mov	r10,128
800074cc:	30 0b       	mov	r11,0
800074ce:	02 9c       	mov	r12,r1
800074d0:	fe b0 fc f4 	rcall	80006eb8 <memset>
800074d4:	40 28       	lddsp	r8,sp[0x8]
800074d6:	40 19       	lddsp	r9,sp[0x4]
800074d8:	e4 cc 00 01 	sub	r12,r2,1
800074dc:	0e 9b       	mov	r11,r7
800074de:	50 3c       	stdsp	sp[0xc],r12
800074e0:	f2 0c 0c 49 	max	r9,r9,r12
800074e4:	c3 a8       	rjmp	80007558 <get_arg+0x268>
800074e6:	62 0a       	ld.w	r10,r1[0x0]
800074e8:	5b fa       	cp.w	r10,-1
800074ea:	c0 b1       	brne	80007500 <get_arg+0x210>
800074ec:	50 19       	stdsp	sp[0x4],r9
800074ee:	50 28       	stdsp	sp[0x8],r8
800074f0:	e0 6a 00 80 	mov	r10,128
800074f4:	30 0b       	mov	r11,0
800074f6:	02 9c       	mov	r12,r1
800074f8:	fe b0 fc e0 	rcall	80006eb8 <memset>
800074fc:	40 28       	lddsp	r8,sp[0x8]
800074fe:	40 19       	lddsp	r9,sp[0x4]
80007500:	20 12       	sub	r2,1
80007502:	30 0a       	mov	r10,0
80007504:	0e 9b       	mov	r11,r7
80007506:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000750a:	f2 02 0c 49 	max	r9,r9,r2
8000750e:	c2 58       	rjmp	80007558 <get_arg+0x268>
80007510:	16 97       	mov	r7,r11
80007512:	6c 0a       	ld.w	r10,r6[0x0]
80007514:	f4 cb ff fc 	sub	r11,r10,-4
80007518:	8d 0b       	st.w	r6[0x0],r11
8000751a:	74 0a       	ld.w	r10,r10[0x0]
8000751c:	0e 9b       	mov	r11,r7
8000751e:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007522:	2f f5       	sub	r5,-1
80007524:	c1 a8       	rjmp	80007558 <get_arg+0x268>
80007526:	f4 c2 00 30 	sub	r2,r10,48
8000752a:	c0 68       	rjmp	80007536 <get_arg+0x246>
8000752c:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007530:	2f f7       	sub	r7,-1
80007532:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007536:	0f 8a       	ld.ub	r10,r7[0x0]
80007538:	58 0a       	cp.w	r10,0
8000753a:	c0 e0       	breq	80007556 <get_arg+0x266>
8000753c:	23 0a       	sub	r10,48
8000753e:	58 9a       	cp.w	r10,9
80007540:	fe 98 ff f6 	brls	8000752c <get_arg+0x23c>
80007544:	c0 98       	rjmp	80007556 <get_arg+0x266>
80007546:	2f f7       	sub	r7,-1
80007548:	0f 8a       	ld.ub	r10,r7[0x0]
8000754a:	58 0a       	cp.w	r10,0
8000754c:	c0 50       	breq	80007556 <get_arg+0x266>
8000754e:	23 0a       	sub	r10,48
80007550:	58 9a       	cp.w	r10,9
80007552:	fe 98 ff fa 	brls	80007546 <get_arg+0x256>
80007556:	0e 9b       	mov	r11,r7
80007558:	40 7c       	lddsp	r12,sp[0x1c]
8000755a:	30 ba       	mov	r10,11
8000755c:	f4 0c 18 00 	cp.b	r12,r10
80007560:	fe 91 fe f2 	brne	80007344 <get_arg+0x54>
80007564:	40 42       	lddsp	r2,sp[0x10]
80007566:	17 8c       	ld.ub	r12,r11[0x0]
80007568:	0a 32       	cp.w	r2,r5
8000756a:	5f 4a       	srge	r10
8000756c:	f0 0c 18 00 	cp.b	r12,r8
80007570:	5f 1c       	srne	r12
80007572:	f9 ea 00 0a 	and	r10,r12,r10
80007576:	f0 0a 18 00 	cp.b	r10,r8
8000757a:	fe 91 fe cf 	brne	80007318 <get_arg+0x28>
8000757e:	30 08       	mov	r8,0
80007580:	40 4e       	lddsp	lr,sp[0x10]
80007582:	17 8a       	ld.ub	r10,r11[0x0]
80007584:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007588:	f0 0a 18 00 	cp.b	r10,r8
8000758c:	fc 09 17 10 	movne	r9,lr
80007590:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007594:	06 9e       	mov	lr,r3
80007596:	c2 a8       	rjmp	800075ea <get_arg+0x2fa>
80007598:	62 0a       	ld.w	r10,r1[0x0]
8000759a:	58 3a       	cp.w	r10,3
8000759c:	c1 e0       	breq	800075d8 <get_arg+0x2e8>
8000759e:	e0 89 00 07 	brgt	800075ac <get_arg+0x2bc>
800075a2:	58 1a       	cp.w	r10,1
800075a4:	c1 a0       	breq	800075d8 <get_arg+0x2e8>
800075a6:	58 2a       	cp.w	r10,2
800075a8:	c1 81       	brne	800075d8 <get_arg+0x2e8>
800075aa:	c0 58       	rjmp	800075b4 <get_arg+0x2c4>
800075ac:	58 5a       	cp.w	r10,5
800075ae:	c0 c0       	breq	800075c6 <get_arg+0x2d6>
800075b0:	c0 b5       	brlt	800075c6 <get_arg+0x2d6>
800075b2:	c1 38       	rjmp	800075d8 <get_arg+0x2e8>
800075b4:	6c 0a       	ld.w	r10,r6[0x0]
800075b6:	f4 cc ff f8 	sub	r12,r10,-8
800075ba:	8d 0c       	st.w	r6[0x0],r12
800075bc:	f4 e2 00 00 	ld.d	r2,r10[0]
800075c0:	f0 e3 00 00 	st.d	r8[0],r2
800075c4:	c1 08       	rjmp	800075e4 <get_arg+0x2f4>
800075c6:	6c 0a       	ld.w	r10,r6[0x0]
800075c8:	f4 cc ff f8 	sub	r12,r10,-8
800075cc:	8d 0c       	st.w	r6[0x0],r12
800075ce:	f4 e2 00 00 	ld.d	r2,r10[0]
800075d2:	f0 e3 00 00 	st.d	r8[0],r2
800075d6:	c0 78       	rjmp	800075e4 <get_arg+0x2f4>
800075d8:	6c 0a       	ld.w	r10,r6[0x0]
800075da:	f4 cc ff fc 	sub	r12,r10,-4
800075de:	8d 0c       	st.w	r6[0x0],r12
800075e0:	74 0a       	ld.w	r10,r10[0x0]
800075e2:	91 0a       	st.w	r8[0x0],r10
800075e4:	2f f5       	sub	r5,-1
800075e6:	2f 88       	sub	r8,-8
800075e8:	2f c1       	sub	r1,-4
800075ea:	12 35       	cp.w	r5,r9
800075ec:	fe 9a ff d6 	brle	80007598 <get_arg+0x2a8>
800075f0:	1c 93       	mov	r3,lr
800075f2:	40 52       	lddsp	r2,sp[0x14]
800075f4:	40 6e       	lddsp	lr,sp[0x18]
800075f6:	85 05       	st.w	r2[0x0],r5
800075f8:	9d 0b       	st.w	lr[0x0],r11
800075fa:	40 4b       	lddsp	r11,sp[0x10]
800075fc:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007600:	2f 8d       	sub	sp,-32
80007602:	d8 32       	popm	r0-r7,pc

80007604 <__sprint_r>:
80007604:	d4 21       	pushm	r4-r7,lr
80007606:	14 97       	mov	r7,r10
80007608:	74 28       	ld.w	r8,r10[0x8]
8000760a:	58 08       	cp.w	r8,0
8000760c:	c0 41       	brne	80007614 <__sprint_r+0x10>
8000760e:	95 18       	st.w	r10[0x4],r8
80007610:	10 9c       	mov	r12,r8
80007612:	d8 22       	popm	r4-r7,pc
80007614:	e0 a0 18 ba 	rcall	8000a788 <__sfvwrite_r>
80007618:	30 08       	mov	r8,0
8000761a:	8f 18       	st.w	r7[0x4],r8
8000761c:	8f 28       	st.w	r7[0x8],r8
8000761e:	d8 22       	popm	r4-r7,pc

80007620 <_vfprintf_r>:
80007620:	d4 31       	pushm	r0-r7,lr
80007622:	fa cd 06 bc 	sub	sp,sp,1724
80007626:	51 09       	stdsp	sp[0x40],r9
80007628:	16 91       	mov	r1,r11
8000762a:	14 97       	mov	r7,r10
8000762c:	18 95       	mov	r5,r12
8000762e:	e0 a0 1a 1d 	rcall	8000aa68 <_localeconv_r>
80007632:	78 0c       	ld.w	r12,r12[0x0]
80007634:	50 cc       	stdsp	sp[0x30],r12
80007636:	58 05       	cp.w	r5,0
80007638:	c0 70       	breq	80007646 <_vfprintf_r+0x26>
8000763a:	6a 68       	ld.w	r8,r5[0x18]
8000763c:	58 08       	cp.w	r8,0
8000763e:	c0 41       	brne	80007646 <_vfprintf_r+0x26>
80007640:	0a 9c       	mov	r12,r5
80007642:	e0 a0 17 43 	rcall	8000a4c8 <__sinit>
80007646:	fe c8 9c de 	sub	r8,pc,-25378
8000764a:	10 31       	cp.w	r1,r8
8000764c:	c0 31       	brne	80007652 <_vfprintf_r+0x32>
8000764e:	6a 01       	ld.w	r1,r5[0x0]
80007650:	c0 c8       	rjmp	80007668 <_vfprintf_r+0x48>
80007652:	fe c8 9c ca 	sub	r8,pc,-25398
80007656:	10 31       	cp.w	r1,r8
80007658:	c0 31       	brne	8000765e <_vfprintf_r+0x3e>
8000765a:	6a 11       	ld.w	r1,r5[0x4]
8000765c:	c0 68       	rjmp	80007668 <_vfprintf_r+0x48>
8000765e:	fe c8 9c b6 	sub	r8,pc,-25418
80007662:	10 31       	cp.w	r1,r8
80007664:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007668:	82 68       	ld.sh	r8,r1[0xc]
8000766a:	ed b8 00 03 	bld	r8,0x3
8000766e:	c0 41       	brne	80007676 <_vfprintf_r+0x56>
80007670:	62 48       	ld.w	r8,r1[0x10]
80007672:	58 08       	cp.w	r8,0
80007674:	c0 71       	brne	80007682 <_vfprintf_r+0x62>
80007676:	02 9b       	mov	r11,r1
80007678:	0a 9c       	mov	r12,r5
8000767a:	e0 a0 0f 5d 	rcall	80009534 <__swsetup_r>
8000767e:	e0 81 0f 54 	brne	80009526 <_vfprintf_r+0x1f06>
80007682:	82 68       	ld.sh	r8,r1[0xc]
80007684:	10 99       	mov	r9,r8
80007686:	e2 19 00 1a 	andl	r9,0x1a,COH
8000768a:	58 a9       	cp.w	r9,10
8000768c:	c3 c1       	brne	80007704 <_vfprintf_r+0xe4>
8000768e:	82 79       	ld.sh	r9,r1[0xe]
80007690:	30 0a       	mov	r10,0
80007692:	f4 09 19 00 	cp.h	r9,r10
80007696:	c3 75       	brlt	80007704 <_vfprintf_r+0xe4>
80007698:	a1 d8       	cbr	r8,0x1
8000769a:	fb 58 05 d0 	st.h	sp[1488],r8
8000769e:	62 88       	ld.w	r8,r1[0x20]
800076a0:	fb 48 05 e4 	st.w	sp[1508],r8
800076a4:	62 a8       	ld.w	r8,r1[0x28]
800076a6:	fb 48 05 ec 	st.w	sp[1516],r8
800076aa:	fa c8 ff bc 	sub	r8,sp,-68
800076ae:	fb 48 05 d4 	st.w	sp[1492],r8
800076b2:	fb 48 05 c4 	st.w	sp[1476],r8
800076b6:	e0 68 04 00 	mov	r8,1024
800076ba:	fb 48 05 d8 	st.w	sp[1496],r8
800076be:	fb 48 05 cc 	st.w	sp[1484],r8
800076c2:	30 08       	mov	r8,0
800076c4:	fb 59 05 d2 	st.h	sp[1490],r9
800076c8:	0e 9a       	mov	r10,r7
800076ca:	41 09       	lddsp	r9,sp[0x40]
800076cc:	fa c7 fa 3c 	sub	r7,sp,-1476
800076d0:	fb 48 05 dc 	st.w	sp[1500],r8
800076d4:	0a 9c       	mov	r12,r5
800076d6:	0e 9b       	mov	r11,r7
800076d8:	ca 4f       	rcall	80007620 <_vfprintf_r>
800076da:	50 bc       	stdsp	sp[0x2c],r12
800076dc:	c0 95       	brlt	800076ee <_vfprintf_r+0xce>
800076de:	0e 9b       	mov	r11,r7
800076e0:	0a 9c       	mov	r12,r5
800076e2:	e0 a0 16 1b 	rcall	8000a318 <_fflush_r>
800076e6:	40 be       	lddsp	lr,sp[0x2c]
800076e8:	f9 be 01 ff 	movne	lr,-1
800076ec:	50 be       	stdsp	sp[0x2c],lr
800076ee:	fb 08 05 d0 	ld.sh	r8,sp[1488]
800076f2:	ed b8 00 06 	bld	r8,0x6
800076f6:	e0 81 0f 1a 	brne	8000952a <_vfprintf_r+0x1f0a>
800076fa:	82 68       	ld.sh	r8,r1[0xc]
800076fc:	a7 a8       	sbr	r8,0x6
800076fe:	a2 68       	st.h	r1[0xc],r8
80007700:	e0 8f 0f 15 	bral	8000952a <_vfprintf_r+0x1f0a>
80007704:	30 08       	mov	r8,0
80007706:	fb 48 06 b4 	st.w	sp[1716],r8
8000770a:	fb 48 06 90 	st.w	sp[1680],r8
8000770e:	fb 48 06 8c 	st.w	sp[1676],r8
80007712:	fb 48 06 b0 	st.w	sp[1712],r8
80007716:	30 08       	mov	r8,0
80007718:	30 09       	mov	r9,0
8000771a:	50 a7       	stdsp	sp[0x28],r7
8000771c:	50 78       	stdsp	sp[0x1c],r8
8000771e:	fa c3 f9 e0 	sub	r3,sp,-1568
80007722:	3f f8       	mov	r8,-1
80007724:	50 59       	stdsp	sp[0x14],r9
80007726:	fb 43 06 88 	st.w	sp[1672],r3
8000772a:	fb 48 05 44 	st.w	sp[1348],r8
8000772e:	12 9c       	mov	r12,r9
80007730:	50 69       	stdsp	sp[0x18],r9
80007732:	50 d9       	stdsp	sp[0x34],r9
80007734:	50 e9       	stdsp	sp[0x38],r9
80007736:	50 b9       	stdsp	sp[0x2c],r9
80007738:	12 97       	mov	r7,r9
8000773a:	0a 94       	mov	r4,r5
8000773c:	40 a2       	lddsp	r2,sp[0x28]
8000773e:	32 5a       	mov	r10,37
80007740:	30 08       	mov	r8,0
80007742:	c0 28       	rjmp	80007746 <_vfprintf_r+0x126>
80007744:	2f f2       	sub	r2,-1
80007746:	05 89       	ld.ub	r9,r2[0x0]
80007748:	f0 09 18 00 	cp.b	r9,r8
8000774c:	5f 1b       	srne	r11
8000774e:	f4 09 18 00 	cp.b	r9,r10
80007752:	5f 19       	srne	r9
80007754:	f3 eb 00 0b 	and	r11,r9,r11
80007758:	f0 0b 18 00 	cp.b	r11,r8
8000775c:	cf 41       	brne	80007744 <_vfprintf_r+0x124>
8000775e:	40 ab       	lddsp	r11,sp[0x28]
80007760:	e4 0b 01 06 	sub	r6,r2,r11
80007764:	c1 e0       	breq	800077a0 <_vfprintf_r+0x180>
80007766:	fa f8 06 90 	ld.w	r8,sp[1680]
8000776a:	0c 08       	add	r8,r6
8000776c:	87 0b       	st.w	r3[0x0],r11
8000776e:	fb 48 06 90 	st.w	sp[1680],r8
80007772:	87 16       	st.w	r3[0x4],r6
80007774:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007778:	2f f8       	sub	r8,-1
8000777a:	fb 48 06 8c 	st.w	sp[1676],r8
8000777e:	58 78       	cp.w	r8,7
80007780:	e0 89 00 04 	brgt	80007788 <_vfprintf_r+0x168>
80007784:	2f 83       	sub	r3,-8
80007786:	c0 a8       	rjmp	8000779a <_vfprintf_r+0x17a>
80007788:	fa ca f9 78 	sub	r10,sp,-1672
8000778c:	02 9b       	mov	r11,r1
8000778e:	08 9c       	mov	r12,r4
80007790:	c3 af       	rcall	80007604 <__sprint_r>
80007792:	e0 81 0e c6 	brne	8000951e <_vfprintf_r+0x1efe>
80007796:	fa c3 f9 e0 	sub	r3,sp,-1568
8000779a:	40 ba       	lddsp	r10,sp[0x2c]
8000779c:	0c 0a       	add	r10,r6
8000779e:	50 ba       	stdsp	sp[0x2c],r10
800077a0:	05 89       	ld.ub	r9,r2[0x0]
800077a2:	30 08       	mov	r8,0
800077a4:	f0 09 18 00 	cp.b	r9,r8
800077a8:	e0 80 0e aa 	breq	800094fc <_vfprintf_r+0x1edc>
800077ac:	30 09       	mov	r9,0
800077ae:	fb 68 06 bb 	st.b	sp[1723],r8
800077b2:	0e 96       	mov	r6,r7
800077b4:	e4 c8 ff ff 	sub	r8,r2,-1
800077b8:	3f fe       	mov	lr,-1
800077ba:	50 93       	stdsp	sp[0x24],r3
800077bc:	50 41       	stdsp	sp[0x10],r1
800077be:	0e 93       	mov	r3,r7
800077c0:	04 91       	mov	r1,r2
800077c2:	50 89       	stdsp	sp[0x20],r9
800077c4:	50 a8       	stdsp	sp[0x28],r8
800077c6:	50 2e       	stdsp	sp[0x8],lr
800077c8:	50 39       	stdsp	sp[0xc],r9
800077ca:	12 95       	mov	r5,r9
800077cc:	12 90       	mov	r0,r9
800077ce:	10 97       	mov	r7,r8
800077d0:	08 92       	mov	r2,r4
800077d2:	c0 78       	rjmp	800077e0 <_vfprintf_r+0x1c0>
800077d4:	3f fc       	mov	r12,-1
800077d6:	08 97       	mov	r7,r4
800077d8:	50 2c       	stdsp	sp[0x8],r12
800077da:	c0 38       	rjmp	800077e0 <_vfprintf_r+0x1c0>
800077dc:	30 0b       	mov	r11,0
800077de:	50 3b       	stdsp	sp[0xc],r11
800077e0:	0f 38       	ld.ub	r8,r7++
800077e2:	c0 28       	rjmp	800077e6 <_vfprintf_r+0x1c6>
800077e4:	12 90       	mov	r0,r9
800077e6:	f0 c9 00 20 	sub	r9,r8,32
800077ea:	e0 49 00 58 	cp.w	r9,88
800077ee:	e0 8b 0a 30 	brhi	80008c4e <_vfprintf_r+0x162e>
800077f2:	fe ca a2 32 	sub	r10,pc,-24014
800077f6:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
800077fa:	50 a7       	stdsp	sp[0x28],r7
800077fc:	50 80       	stdsp	sp[0x20],r0
800077fe:	0c 97       	mov	r7,r6
80007800:	04 94       	mov	r4,r2
80007802:	06 96       	mov	r6,r3
80007804:	02 92       	mov	r2,r1
80007806:	fe c9 a0 0a 	sub	r9,pc,-24566
8000780a:	40 93       	lddsp	r3,sp[0x24]
8000780c:	10 90       	mov	r0,r8
8000780e:	40 41       	lddsp	r1,sp[0x10]
80007810:	50 d9       	stdsp	sp[0x34],r9
80007812:	e0 8f 08 8e 	bral	8000892e <_vfprintf_r+0x130e>
80007816:	30 08       	mov	r8,0
80007818:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000781c:	f0 09 18 00 	cp.b	r9,r8
80007820:	ce 01       	brne	800077e0 <_vfprintf_r+0x1c0>
80007822:	32 08       	mov	r8,32
80007824:	c6 e8       	rjmp	80007900 <_vfprintf_r+0x2e0>
80007826:	a1 a5       	sbr	r5,0x0
80007828:	cd cb       	rjmp	800077e0 <_vfprintf_r+0x1c0>
8000782a:	0f 89       	ld.ub	r9,r7[0x0]
8000782c:	f2 c8 00 30 	sub	r8,r9,48
80007830:	58 98       	cp.w	r8,9
80007832:	e0 8b 00 1d 	brhi	8000786c <_vfprintf_r+0x24c>
80007836:	ee c8 ff ff 	sub	r8,r7,-1
8000783a:	30 0b       	mov	r11,0
8000783c:	23 09       	sub	r9,48
8000783e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007842:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007846:	11 39       	ld.ub	r9,r8++
80007848:	f2 ca 00 30 	sub	r10,r9,48
8000784c:	58 9a       	cp.w	r10,9
8000784e:	fe 98 ff f7 	brls	8000783c <_vfprintf_r+0x21c>
80007852:	e0 49 00 24 	cp.w	r9,36
80007856:	cc 31       	brne	800077dc <_vfprintf_r+0x1bc>
80007858:	e0 4b 00 20 	cp.w	r11,32
8000785c:	e0 89 0e 60 	brgt	8000951c <_vfprintf_r+0x1efc>
80007860:	20 1b       	sub	r11,1
80007862:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007866:	12 3b       	cp.w	r11,r9
80007868:	c0 95       	brlt	8000787a <_vfprintf_r+0x25a>
8000786a:	c1 08       	rjmp	8000788a <_vfprintf_r+0x26a>
8000786c:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007870:	ec ca ff ff 	sub	r10,r6,-1
80007874:	12 36       	cp.w	r6,r9
80007876:	c1 f5       	brlt	800078b4 <_vfprintf_r+0x294>
80007878:	c2 68       	rjmp	800078c4 <_vfprintf_r+0x2a4>
8000787a:	fa ce f9 44 	sub	lr,sp,-1724
8000787e:	10 97       	mov	r7,r8
80007880:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007884:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007888:	c3 58       	rjmp	800078f2 <_vfprintf_r+0x2d2>
8000788a:	10 97       	mov	r7,r8
8000788c:	fa c8 f9 50 	sub	r8,sp,-1712
80007890:	1a d8       	st.w	--sp,r8
80007892:	fa c8 fa b8 	sub	r8,sp,-1352
80007896:	1a d8       	st.w	--sp,r8
80007898:	fa c8 fb b4 	sub	r8,sp,-1100
8000789c:	02 9a       	mov	r10,r1
8000789e:	1a d8       	st.w	--sp,r8
800078a0:	04 9c       	mov	r12,r2
800078a2:	fa c8 f9 40 	sub	r8,sp,-1728
800078a6:	fa c9 ff b4 	sub	r9,sp,-76
800078aa:	fe b0 fd 23 	rcall	800072f0 <get_arg>
800078ae:	2f dd       	sub	sp,-12
800078b0:	78 00       	ld.w	r0,r12[0x0]
800078b2:	c2 08       	rjmp	800078f2 <_vfprintf_r+0x2d2>
800078b4:	fa cc f9 44 	sub	r12,sp,-1724
800078b8:	14 96       	mov	r6,r10
800078ba:	f8 03 00 38 	add	r8,r12,r3<<0x3
800078be:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800078c2:	c1 88       	rjmp	800078f2 <_vfprintf_r+0x2d2>
800078c4:	41 08       	lddsp	r8,sp[0x40]
800078c6:	59 f9       	cp.w	r9,31
800078c8:	e0 89 00 11 	brgt	800078ea <_vfprintf_r+0x2ca>
800078cc:	f0 cb ff fc 	sub	r11,r8,-4
800078d0:	51 0b       	stdsp	sp[0x40],r11
800078d2:	70 00       	ld.w	r0,r8[0x0]
800078d4:	fa cb f9 44 	sub	r11,sp,-1724
800078d8:	f6 09 00 38 	add	r8,r11,r9<<0x3
800078dc:	f1 40 fd 88 	st.w	r8[-632],r0
800078e0:	2f f9       	sub	r9,-1
800078e2:	14 96       	mov	r6,r10
800078e4:	fb 49 06 b4 	st.w	sp[1716],r9
800078e8:	c0 58       	rjmp	800078f2 <_vfprintf_r+0x2d2>
800078ea:	70 00       	ld.w	r0,r8[0x0]
800078ec:	14 96       	mov	r6,r10
800078ee:	2f c8       	sub	r8,-4
800078f0:	51 08       	stdsp	sp[0x40],r8
800078f2:	58 00       	cp.w	r0,0
800078f4:	fe 94 ff 76 	brge	800077e0 <_vfprintf_r+0x1c0>
800078f8:	5c 30       	neg	r0
800078fa:	a3 a5       	sbr	r5,0x2
800078fc:	c7 2b       	rjmp	800077e0 <_vfprintf_r+0x1c0>
800078fe:	32 b8       	mov	r8,43
80007900:	fb 68 06 bb 	st.b	sp[1723],r8
80007904:	c6 eb       	rjmp	800077e0 <_vfprintf_r+0x1c0>
80007906:	0f 38       	ld.ub	r8,r7++
80007908:	e0 48 00 2a 	cp.w	r8,42
8000790c:	c0 30       	breq	80007912 <_vfprintf_r+0x2f2>
8000790e:	30 09       	mov	r9,0
80007910:	c7 98       	rjmp	80007a02 <_vfprintf_r+0x3e2>
80007912:	0f 88       	ld.ub	r8,r7[0x0]
80007914:	f0 c9 00 30 	sub	r9,r8,48
80007918:	58 99       	cp.w	r9,9
8000791a:	e0 8b 00 1f 	brhi	80007958 <_vfprintf_r+0x338>
8000791e:	ee c4 ff ff 	sub	r4,r7,-1
80007922:	30 0b       	mov	r11,0
80007924:	23 08       	sub	r8,48
80007926:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000792a:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000792e:	09 38       	ld.ub	r8,r4++
80007930:	f0 c9 00 30 	sub	r9,r8,48
80007934:	58 99       	cp.w	r9,9
80007936:	fe 98 ff f7 	brls	80007924 <_vfprintf_r+0x304>
8000793a:	e0 48 00 24 	cp.w	r8,36
8000793e:	fe 91 ff 4f 	brne	800077dc <_vfprintf_r+0x1bc>
80007942:	e0 4b 00 20 	cp.w	r11,32
80007946:	e0 89 0d eb 	brgt	8000951c <_vfprintf_r+0x1efc>
8000794a:	20 1b       	sub	r11,1
8000794c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007950:	10 3b       	cp.w	r11,r8
80007952:	c0 a5       	brlt	80007966 <_vfprintf_r+0x346>
80007954:	c1 18       	rjmp	80007976 <_vfprintf_r+0x356>
80007956:	d7 03       	nop
80007958:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000795c:	ec c9 ff ff 	sub	r9,r6,-1
80007960:	14 36       	cp.w	r6,r10
80007962:	c1 f5       	brlt	800079a0 <_vfprintf_r+0x380>
80007964:	c2 88       	rjmp	800079b4 <_vfprintf_r+0x394>
80007966:	fa ca f9 44 	sub	r10,sp,-1724
8000796a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000796e:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007972:	50 2b       	stdsp	sp[0x8],r11
80007974:	c3 c8       	rjmp	800079ec <_vfprintf_r+0x3cc>
80007976:	fa c8 f9 50 	sub	r8,sp,-1712
8000797a:	1a d8       	st.w	--sp,r8
8000797c:	fa c8 fa b8 	sub	r8,sp,-1352
80007980:	1a d8       	st.w	--sp,r8
80007982:	fa c8 fb b4 	sub	r8,sp,-1100
80007986:	02 9a       	mov	r10,r1
80007988:	1a d8       	st.w	--sp,r8
8000798a:	04 9c       	mov	r12,r2
8000798c:	fa c8 f9 40 	sub	r8,sp,-1728
80007990:	fa c9 ff b4 	sub	r9,sp,-76
80007994:	fe b0 fc ae 	rcall	800072f0 <get_arg>
80007998:	2f dd       	sub	sp,-12
8000799a:	78 0c       	ld.w	r12,r12[0x0]
8000799c:	50 2c       	stdsp	sp[0x8],r12
8000799e:	c2 78       	rjmp	800079ec <_vfprintf_r+0x3cc>
800079a0:	12 96       	mov	r6,r9
800079a2:	0e 94       	mov	r4,r7
800079a4:	fa c9 f9 44 	sub	r9,sp,-1724
800079a8:	f2 03 00 38 	add	r8,r9,r3<<0x3
800079ac:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800079b0:	50 28       	stdsp	sp[0x8],r8
800079b2:	c1 d8       	rjmp	800079ec <_vfprintf_r+0x3cc>
800079b4:	41 08       	lddsp	r8,sp[0x40]
800079b6:	59 fa       	cp.w	r10,31
800079b8:	e0 89 00 14 	brgt	800079e0 <_vfprintf_r+0x3c0>
800079bc:	f0 cb ff fc 	sub	r11,r8,-4
800079c0:	70 08       	ld.w	r8,r8[0x0]
800079c2:	51 0b       	stdsp	sp[0x40],r11
800079c4:	50 28       	stdsp	sp[0x8],r8
800079c6:	fa c6 f9 44 	sub	r6,sp,-1724
800079ca:	40 2e       	lddsp	lr,sp[0x8]
800079cc:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800079d0:	f1 4e fd 88 	st.w	r8[-632],lr
800079d4:	2f fa       	sub	r10,-1
800079d6:	0e 94       	mov	r4,r7
800079d8:	fb 4a 06 b4 	st.w	sp[1716],r10
800079dc:	12 96       	mov	r6,r9
800079de:	c0 78       	rjmp	800079ec <_vfprintf_r+0x3cc>
800079e0:	70 0c       	ld.w	r12,r8[0x0]
800079e2:	0e 94       	mov	r4,r7
800079e4:	2f c8       	sub	r8,-4
800079e6:	50 2c       	stdsp	sp[0x8],r12
800079e8:	12 96       	mov	r6,r9
800079ea:	51 08       	stdsp	sp[0x40],r8
800079ec:	40 2b       	lddsp	r11,sp[0x8]
800079ee:	58 0b       	cp.w	r11,0
800079f0:	fe 95 fe f2 	brlt	800077d4 <_vfprintf_r+0x1b4>
800079f4:	08 97       	mov	r7,r4
800079f6:	cf 5a       	rjmp	800077e0 <_vfprintf_r+0x1c0>
800079f8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800079fc:	0f 38       	ld.ub	r8,r7++
800079fe:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007a02:	f0 ca 00 30 	sub	r10,r8,48
80007a06:	58 9a       	cp.w	r10,9
80007a08:	fe 98 ff f8 	brls	800079f8 <_vfprintf_r+0x3d8>
80007a0c:	3f fa       	mov	r10,-1
80007a0e:	f2 0a 0c 49 	max	r9,r9,r10
80007a12:	50 29       	stdsp	sp[0x8],r9
80007a14:	ce 9a       	rjmp	800077e6 <_vfprintf_r+0x1c6>
80007a16:	a7 b5       	sbr	r5,0x7
80007a18:	ce 4a       	rjmp	800077e0 <_vfprintf_r+0x1c0>
80007a1a:	30 09       	mov	r9,0
80007a1c:	23 08       	sub	r8,48
80007a1e:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007a22:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007a26:	0f 38       	ld.ub	r8,r7++
80007a28:	f0 ca 00 30 	sub	r10,r8,48
80007a2c:	58 9a       	cp.w	r10,9
80007a2e:	fe 98 ff f7 	brls	80007a1c <_vfprintf_r+0x3fc>
80007a32:	e0 48 00 24 	cp.w	r8,36
80007a36:	fe 91 fe d7 	brne	800077e4 <_vfprintf_r+0x1c4>
80007a3a:	e0 49 00 20 	cp.w	r9,32
80007a3e:	e0 89 0d 6f 	brgt	8000951c <_vfprintf_r+0x1efc>
80007a42:	f2 c3 00 01 	sub	r3,r9,1
80007a46:	30 19       	mov	r9,1
80007a48:	50 39       	stdsp	sp[0xc],r9
80007a4a:	cc ba       	rjmp	800077e0 <_vfprintf_r+0x1c0>
80007a4c:	a3 b5       	sbr	r5,0x3
80007a4e:	cc 9a       	rjmp	800077e0 <_vfprintf_r+0x1c0>
80007a50:	a7 a5       	sbr	r5,0x6
80007a52:	cc 7a       	rjmp	800077e0 <_vfprintf_r+0x1c0>
80007a54:	0a 98       	mov	r8,r5
80007a56:	a5 b5       	sbr	r5,0x5
80007a58:	a5 a8       	sbr	r8,0x4
80007a5a:	0f 89       	ld.ub	r9,r7[0x0]
80007a5c:	36 ce       	mov	lr,108
80007a5e:	fc 09 18 00 	cp.b	r9,lr
80007a62:	f7 b7 00 ff 	subeq	r7,-1
80007a66:	f0 05 17 10 	movne	r5,r8
80007a6a:	cb ba       	rjmp	800077e0 <_vfprintf_r+0x1c0>
80007a6c:	a5 b5       	sbr	r5,0x5
80007a6e:	cb 9a       	rjmp	800077e0 <_vfprintf_r+0x1c0>
80007a70:	50 a7       	stdsp	sp[0x28],r7
80007a72:	50 80       	stdsp	sp[0x20],r0
80007a74:	0c 97       	mov	r7,r6
80007a76:	10 90       	mov	r0,r8
80007a78:	06 96       	mov	r6,r3
80007a7a:	04 94       	mov	r4,r2
80007a7c:	40 93       	lddsp	r3,sp[0x24]
80007a7e:	02 92       	mov	r2,r1
80007a80:	0e 99       	mov	r9,r7
80007a82:	40 41       	lddsp	r1,sp[0x10]
80007a84:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007a88:	40 3c       	lddsp	r12,sp[0xc]
80007a8a:	58 0c       	cp.w	r12,0
80007a8c:	c1 d0       	breq	80007ac6 <_vfprintf_r+0x4a6>
80007a8e:	10 36       	cp.w	r6,r8
80007a90:	c0 64       	brge	80007a9c <_vfprintf_r+0x47c>
80007a92:	fa cb f9 44 	sub	r11,sp,-1724
80007a96:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007a9a:	c1 d8       	rjmp	80007ad4 <_vfprintf_r+0x4b4>
80007a9c:	fa c8 f9 50 	sub	r8,sp,-1712
80007aa0:	1a d8       	st.w	--sp,r8
80007aa2:	fa c8 fa b8 	sub	r8,sp,-1352
80007aa6:	1a d8       	st.w	--sp,r8
80007aa8:	fa c8 fb b4 	sub	r8,sp,-1100
80007aac:	1a d8       	st.w	--sp,r8
80007aae:	fa c8 f9 40 	sub	r8,sp,-1728
80007ab2:	fa c9 ff b4 	sub	r9,sp,-76
80007ab6:	04 9a       	mov	r10,r2
80007ab8:	0c 9b       	mov	r11,r6
80007aba:	08 9c       	mov	r12,r4
80007abc:	fe b0 fc 1a 	rcall	800072f0 <get_arg>
80007ac0:	2f dd       	sub	sp,-12
80007ac2:	19 b8       	ld.ub	r8,r12[0x3]
80007ac4:	c2 28       	rjmp	80007b08 <_vfprintf_r+0x4e8>
80007ac6:	2f f7       	sub	r7,-1
80007ac8:	10 39       	cp.w	r9,r8
80007aca:	c0 84       	brge	80007ada <_vfprintf_r+0x4ba>
80007acc:	fa ca f9 44 	sub	r10,sp,-1724
80007ad0:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007ad4:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007ad8:	c1 88       	rjmp	80007b08 <_vfprintf_r+0x4e8>
80007ada:	41 09       	lddsp	r9,sp[0x40]
80007adc:	59 f8       	cp.w	r8,31
80007ade:	e0 89 00 12 	brgt	80007b02 <_vfprintf_r+0x4e2>
80007ae2:	f2 ca ff fc 	sub	r10,r9,-4
80007ae6:	51 0a       	stdsp	sp[0x40],r10
80007ae8:	72 09       	ld.w	r9,r9[0x0]
80007aea:	fa c6 f9 44 	sub	r6,sp,-1724
80007aee:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007af2:	2f f8       	sub	r8,-1
80007af4:	f5 49 fd 88 	st.w	r10[-632],r9
80007af8:	fb 48 06 b4 	st.w	sp[1716],r8
80007afc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007b00:	c0 48       	rjmp	80007b08 <_vfprintf_r+0x4e8>
80007b02:	13 b8       	ld.ub	r8,r9[0x3]
80007b04:	2f c9       	sub	r9,-4
80007b06:	51 09       	stdsp	sp[0x40],r9
80007b08:	fb 68 06 60 	st.b	sp[1632],r8
80007b0c:	30 0e       	mov	lr,0
80007b0e:	30 08       	mov	r8,0
80007b10:	30 12       	mov	r2,1
80007b12:	fb 68 06 bb 	st.b	sp[1723],r8
80007b16:	50 2e       	stdsp	sp[0x8],lr
80007b18:	e0 8f 08 ad 	bral	80008c72 <_vfprintf_r+0x1652>
80007b1c:	50 a7       	stdsp	sp[0x28],r7
80007b1e:	50 80       	stdsp	sp[0x20],r0
80007b20:	0c 97       	mov	r7,r6
80007b22:	04 94       	mov	r4,r2
80007b24:	06 96       	mov	r6,r3
80007b26:	02 92       	mov	r2,r1
80007b28:	40 93       	lddsp	r3,sp[0x24]
80007b2a:	10 90       	mov	r0,r8
80007b2c:	40 41       	lddsp	r1,sp[0x10]
80007b2e:	a5 a5       	sbr	r5,0x4
80007b30:	c0 a8       	rjmp	80007b44 <_vfprintf_r+0x524>
80007b32:	50 a7       	stdsp	sp[0x28],r7
80007b34:	50 80       	stdsp	sp[0x20],r0
80007b36:	0c 97       	mov	r7,r6
80007b38:	04 94       	mov	r4,r2
80007b3a:	06 96       	mov	r6,r3
80007b3c:	02 92       	mov	r2,r1
80007b3e:	40 93       	lddsp	r3,sp[0x24]
80007b40:	10 90       	mov	r0,r8
80007b42:	40 41       	lddsp	r1,sp[0x10]
80007b44:	ed b5 00 05 	bld	r5,0x5
80007b48:	c5 11       	brne	80007bea <_vfprintf_r+0x5ca>
80007b4a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007b4e:	40 3c       	lddsp	r12,sp[0xc]
80007b50:	58 0c       	cp.w	r12,0
80007b52:	c1 e0       	breq	80007b8e <_vfprintf_r+0x56e>
80007b54:	10 36       	cp.w	r6,r8
80007b56:	c0 64       	brge	80007b62 <_vfprintf_r+0x542>
80007b58:	fa cb f9 44 	sub	r11,sp,-1724
80007b5c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007b60:	c2 08       	rjmp	80007ba0 <_vfprintf_r+0x580>
80007b62:	fa c8 f9 50 	sub	r8,sp,-1712
80007b66:	1a d8       	st.w	--sp,r8
80007b68:	fa c8 fa b8 	sub	r8,sp,-1352
80007b6c:	0c 9b       	mov	r11,r6
80007b6e:	1a d8       	st.w	--sp,r8
80007b70:	fa c8 fb b4 	sub	r8,sp,-1100
80007b74:	1a d8       	st.w	--sp,r8
80007b76:	fa c9 ff b4 	sub	r9,sp,-76
80007b7a:	fa c8 f9 40 	sub	r8,sp,-1728
80007b7e:	04 9a       	mov	r10,r2
80007b80:	08 9c       	mov	r12,r4
80007b82:	fe b0 fb b7 	rcall	800072f0 <get_arg>
80007b86:	2f dd       	sub	sp,-12
80007b88:	78 1b       	ld.w	r11,r12[0x4]
80007b8a:	78 09       	ld.w	r9,r12[0x0]
80007b8c:	c2 b8       	rjmp	80007be2 <_vfprintf_r+0x5c2>
80007b8e:	ee ca ff ff 	sub	r10,r7,-1
80007b92:	10 37       	cp.w	r7,r8
80007b94:	c0 b4       	brge	80007baa <_vfprintf_r+0x58a>
80007b96:	fa c9 f9 44 	sub	r9,sp,-1724
80007b9a:	14 97       	mov	r7,r10
80007b9c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007ba0:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007ba4:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007ba8:	c1 d8       	rjmp	80007be2 <_vfprintf_r+0x5c2>
80007baa:	41 09       	lddsp	r9,sp[0x40]
80007bac:	59 f8       	cp.w	r8,31
80007bae:	e0 89 00 14 	brgt	80007bd6 <_vfprintf_r+0x5b6>
80007bb2:	f2 cb ff f8 	sub	r11,r9,-8
80007bb6:	51 0b       	stdsp	sp[0x40],r11
80007bb8:	fa c6 f9 44 	sub	r6,sp,-1724
80007bbc:	72 1b       	ld.w	r11,r9[0x4]
80007bbe:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007bc2:	72 09       	ld.w	r9,r9[0x0]
80007bc4:	f9 4b fd 8c 	st.w	r12[-628],r11
80007bc8:	f9 49 fd 88 	st.w	r12[-632],r9
80007bcc:	2f f8       	sub	r8,-1
80007bce:	14 97       	mov	r7,r10
80007bd0:	fb 48 06 b4 	st.w	sp[1716],r8
80007bd4:	c0 78       	rjmp	80007be2 <_vfprintf_r+0x5c2>
80007bd6:	f2 c8 ff f8 	sub	r8,r9,-8
80007bda:	72 1b       	ld.w	r11,r9[0x4]
80007bdc:	14 97       	mov	r7,r10
80007bde:	51 08       	stdsp	sp[0x40],r8
80007be0:	72 09       	ld.w	r9,r9[0x0]
80007be2:	16 98       	mov	r8,r11
80007be4:	fa e9 00 00 	st.d	sp[0],r8
80007be8:	ca e8       	rjmp	80007d44 <_vfprintf_r+0x724>
80007bea:	ed b5 00 04 	bld	r5,0x4
80007bee:	c1 71       	brne	80007c1c <_vfprintf_r+0x5fc>
80007bf0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007bf4:	40 3e       	lddsp	lr,sp[0xc]
80007bf6:	58 0e       	cp.w	lr,0
80007bf8:	c0 80       	breq	80007c08 <_vfprintf_r+0x5e8>
80007bfa:	10 36       	cp.w	r6,r8
80007bfc:	c6 94       	brge	80007cce <_vfprintf_r+0x6ae>
80007bfe:	fa cc f9 44 	sub	r12,sp,-1724
80007c02:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007c06:	c8 28       	rjmp	80007d0a <_vfprintf_r+0x6ea>
80007c08:	ee ca ff ff 	sub	r10,r7,-1
80007c0c:	10 37       	cp.w	r7,r8
80007c0e:	e0 84 00 81 	brge	80007d10 <_vfprintf_r+0x6f0>
80007c12:	fa cb f9 44 	sub	r11,sp,-1724
80007c16:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007c1a:	c7 78       	rjmp	80007d08 <_vfprintf_r+0x6e8>
80007c1c:	ed b5 00 06 	bld	r5,0x6
80007c20:	c4 b1       	brne	80007cb6 <_vfprintf_r+0x696>
80007c22:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007c26:	40 3c       	lddsp	r12,sp[0xc]
80007c28:	58 0c       	cp.w	r12,0
80007c2a:	c1 d0       	breq	80007c64 <_vfprintf_r+0x644>
80007c2c:	10 36       	cp.w	r6,r8
80007c2e:	c0 64       	brge	80007c3a <_vfprintf_r+0x61a>
80007c30:	fa cb f9 44 	sub	r11,sp,-1724
80007c34:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007c38:	c1 f8       	rjmp	80007c76 <_vfprintf_r+0x656>
80007c3a:	fa c8 f9 50 	sub	r8,sp,-1712
80007c3e:	1a d8       	st.w	--sp,r8
80007c40:	fa c8 fa b8 	sub	r8,sp,-1352
80007c44:	1a d8       	st.w	--sp,r8
80007c46:	fa c8 fb b4 	sub	r8,sp,-1100
80007c4a:	1a d8       	st.w	--sp,r8
80007c4c:	fa c8 f9 40 	sub	r8,sp,-1728
80007c50:	fa c9 ff b4 	sub	r9,sp,-76
80007c54:	04 9a       	mov	r10,r2
80007c56:	0c 9b       	mov	r11,r6
80007c58:	08 9c       	mov	r12,r4
80007c5a:	fe b0 fb 4b 	rcall	800072f0 <get_arg>
80007c5e:	2f dd       	sub	sp,-12
80007c60:	98 18       	ld.sh	r8,r12[0x2]
80007c62:	c2 68       	rjmp	80007cae <_vfprintf_r+0x68e>
80007c64:	ee ca ff ff 	sub	r10,r7,-1
80007c68:	10 37       	cp.w	r7,r8
80007c6a:	c0 94       	brge	80007c7c <_vfprintf_r+0x65c>
80007c6c:	fa c9 f9 44 	sub	r9,sp,-1724
80007c70:	14 97       	mov	r7,r10
80007c72:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007c76:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007c7a:	c1 a8       	rjmp	80007cae <_vfprintf_r+0x68e>
80007c7c:	41 09       	lddsp	r9,sp[0x40]
80007c7e:	59 f8       	cp.w	r8,31
80007c80:	e0 89 00 13 	brgt	80007ca6 <_vfprintf_r+0x686>
80007c84:	f2 cb ff fc 	sub	r11,r9,-4
80007c88:	51 0b       	stdsp	sp[0x40],r11
80007c8a:	72 09       	ld.w	r9,r9[0x0]
80007c8c:	fa c6 f9 44 	sub	r6,sp,-1724
80007c90:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007c94:	2f f8       	sub	r8,-1
80007c96:	f7 49 fd 88 	st.w	r11[-632],r9
80007c9a:	fb 48 06 b4 	st.w	sp[1716],r8
80007c9e:	14 97       	mov	r7,r10
80007ca0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007ca4:	c0 58       	rjmp	80007cae <_vfprintf_r+0x68e>
80007ca6:	92 18       	ld.sh	r8,r9[0x2]
80007ca8:	14 97       	mov	r7,r10
80007caa:	2f c9       	sub	r9,-4
80007cac:	51 09       	stdsp	sp[0x40],r9
80007cae:	50 18       	stdsp	sp[0x4],r8
80007cb0:	bf 58       	asr	r8,0x1f
80007cb2:	50 08       	stdsp	sp[0x0],r8
80007cb4:	c4 88       	rjmp	80007d44 <_vfprintf_r+0x724>
80007cb6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007cba:	40 3c       	lddsp	r12,sp[0xc]
80007cbc:	58 0c       	cp.w	r12,0
80007cbe:	c1 d0       	breq	80007cf8 <_vfprintf_r+0x6d8>
80007cc0:	10 36       	cp.w	r6,r8
80007cc2:	c0 64       	brge	80007cce <_vfprintf_r+0x6ae>
80007cc4:	fa cb f9 44 	sub	r11,sp,-1724
80007cc8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007ccc:	c1 f8       	rjmp	80007d0a <_vfprintf_r+0x6ea>
80007cce:	fa c8 f9 50 	sub	r8,sp,-1712
80007cd2:	1a d8       	st.w	--sp,r8
80007cd4:	fa c8 fa b8 	sub	r8,sp,-1352
80007cd8:	0c 9b       	mov	r11,r6
80007cda:	1a d8       	st.w	--sp,r8
80007cdc:	fa c8 fb b4 	sub	r8,sp,-1100
80007ce0:	04 9a       	mov	r10,r2
80007ce2:	1a d8       	st.w	--sp,r8
80007ce4:	08 9c       	mov	r12,r4
80007ce6:	fa c8 f9 40 	sub	r8,sp,-1728
80007cea:	fa c9 ff b4 	sub	r9,sp,-76
80007cee:	fe b0 fb 01 	rcall	800072f0 <get_arg>
80007cf2:	2f dd       	sub	sp,-12
80007cf4:	78 0b       	ld.w	r11,r12[0x0]
80007cf6:	c2 48       	rjmp	80007d3e <_vfprintf_r+0x71e>
80007cf8:	ee ca ff ff 	sub	r10,r7,-1
80007cfc:	10 37       	cp.w	r7,r8
80007cfe:	c0 94       	brge	80007d10 <_vfprintf_r+0x6f0>
80007d00:	fa c9 f9 44 	sub	r9,sp,-1724
80007d04:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007d08:	14 97       	mov	r7,r10
80007d0a:	ec fb fd 88 	ld.w	r11,r6[-632]
80007d0e:	c1 88       	rjmp	80007d3e <_vfprintf_r+0x71e>
80007d10:	41 09       	lddsp	r9,sp[0x40]
80007d12:	59 f8       	cp.w	r8,31
80007d14:	e0 89 00 11 	brgt	80007d36 <_vfprintf_r+0x716>
80007d18:	f2 cb ff fc 	sub	r11,r9,-4
80007d1c:	51 0b       	stdsp	sp[0x40],r11
80007d1e:	fa c6 f9 44 	sub	r6,sp,-1724
80007d22:	72 0b       	ld.w	r11,r9[0x0]
80007d24:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007d28:	f3 4b fd 88 	st.w	r9[-632],r11
80007d2c:	2f f8       	sub	r8,-1
80007d2e:	14 97       	mov	r7,r10
80007d30:	fb 48 06 b4 	st.w	sp[1716],r8
80007d34:	c0 58       	rjmp	80007d3e <_vfprintf_r+0x71e>
80007d36:	72 0b       	ld.w	r11,r9[0x0]
80007d38:	14 97       	mov	r7,r10
80007d3a:	2f c9       	sub	r9,-4
80007d3c:	51 09       	stdsp	sp[0x40],r9
80007d3e:	50 1b       	stdsp	sp[0x4],r11
80007d40:	bf 5b       	asr	r11,0x1f
80007d42:	50 0b       	stdsp	sp[0x0],r11
80007d44:	fa ea 00 00 	ld.d	r10,sp[0]
80007d48:	58 0a       	cp.w	r10,0
80007d4a:	5c 2b       	cpc	r11
80007d4c:	c0 e4       	brge	80007d68 <_vfprintf_r+0x748>
80007d4e:	30 08       	mov	r8,0
80007d50:	fa ea 00 00 	ld.d	r10,sp[0]
80007d54:	30 09       	mov	r9,0
80007d56:	f0 0a 01 0a 	sub	r10,r8,r10
80007d5a:	f2 0b 01 4b 	sbc	r11,r9,r11
80007d5e:	32 d8       	mov	r8,45
80007d60:	fa eb 00 00 	st.d	sp[0],r10
80007d64:	fb 68 06 bb 	st.b	sp[1723],r8
80007d68:	30 18       	mov	r8,1
80007d6a:	e0 8f 06 fa 	bral	80008b5e <_vfprintf_r+0x153e>
80007d6e:	50 a7       	stdsp	sp[0x28],r7
80007d70:	50 80       	stdsp	sp[0x20],r0
80007d72:	0c 97       	mov	r7,r6
80007d74:	04 94       	mov	r4,r2
80007d76:	06 96       	mov	r6,r3
80007d78:	02 92       	mov	r2,r1
80007d7a:	40 93       	lddsp	r3,sp[0x24]
80007d7c:	10 90       	mov	r0,r8
80007d7e:	40 41       	lddsp	r1,sp[0x10]
80007d80:	0e 99       	mov	r9,r7
80007d82:	ed b5 00 03 	bld	r5,0x3
80007d86:	c4 11       	brne	80007e08 <_vfprintf_r+0x7e8>
80007d88:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d8c:	40 3a       	lddsp	r10,sp[0xc]
80007d8e:	58 0a       	cp.w	r10,0
80007d90:	c1 90       	breq	80007dc2 <_vfprintf_r+0x7a2>
80007d92:	10 36       	cp.w	r6,r8
80007d94:	c6 45       	brlt	80007e5c <_vfprintf_r+0x83c>
80007d96:	fa c8 f9 50 	sub	r8,sp,-1712
80007d9a:	1a d8       	st.w	--sp,r8
80007d9c:	fa c8 fa b8 	sub	r8,sp,-1352
80007da0:	1a d8       	st.w	--sp,r8
80007da2:	fa c8 fb b4 	sub	r8,sp,-1100
80007da6:	0c 9b       	mov	r11,r6
80007da8:	1a d8       	st.w	--sp,r8
80007daa:	04 9a       	mov	r10,r2
80007dac:	fa c8 f9 40 	sub	r8,sp,-1728
80007db0:	fa c9 ff b4 	sub	r9,sp,-76
80007db4:	08 9c       	mov	r12,r4
80007db6:	fe b0 fa 9d 	rcall	800072f0 <get_arg>
80007dba:	2f dd       	sub	sp,-12
80007dbc:	78 16       	ld.w	r6,r12[0x4]
80007dbe:	50 76       	stdsp	sp[0x1c],r6
80007dc0:	c4 88       	rjmp	80007e50 <_vfprintf_r+0x830>
80007dc2:	2f f7       	sub	r7,-1
80007dc4:	10 39       	cp.w	r9,r8
80007dc6:	c0 c4       	brge	80007dde <_vfprintf_r+0x7be>
80007dc8:	fa ce f9 44 	sub	lr,sp,-1724
80007dcc:	fc 06 00 36 	add	r6,lr,r6<<0x3
80007dd0:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007dd4:	50 7c       	stdsp	sp[0x1c],r12
80007dd6:	ec f6 fd 88 	ld.w	r6,r6[-632]
80007dda:	50 56       	stdsp	sp[0x14],r6
80007ddc:	c6 68       	rjmp	80007ea8 <_vfprintf_r+0x888>
80007dde:	41 09       	lddsp	r9,sp[0x40]
80007de0:	59 f8       	cp.w	r8,31
80007de2:	e0 89 00 10 	brgt	80007e02 <_vfprintf_r+0x7e2>
80007de6:	f2 ca ff f8 	sub	r10,r9,-8
80007dea:	72 1b       	ld.w	r11,r9[0x4]
80007dec:	51 0a       	stdsp	sp[0x40],r10
80007dee:	72 09       	ld.w	r9,r9[0x0]
80007df0:	fa ca f9 44 	sub	r10,sp,-1724
80007df4:	50 7b       	stdsp	sp[0x1c],r11
80007df6:	50 59       	stdsp	sp[0x14],r9
80007df8:	f4 08 00 39 	add	r9,r10,r8<<0x3
80007dfc:	40 5b       	lddsp	r11,sp[0x14]
80007dfe:	40 7a       	lddsp	r10,sp[0x1c]
80007e00:	c4 78       	rjmp	80007e8e <_vfprintf_r+0x86e>
80007e02:	72 18       	ld.w	r8,r9[0x4]
80007e04:	50 78       	stdsp	sp[0x1c],r8
80007e06:	c4 c8       	rjmp	80007e9e <_vfprintf_r+0x87e>
80007e08:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e0c:	40 3e       	lddsp	lr,sp[0xc]
80007e0e:	58 0e       	cp.w	lr,0
80007e10:	c2 30       	breq	80007e56 <_vfprintf_r+0x836>
80007e12:	10 36       	cp.w	r6,r8
80007e14:	c0 94       	brge	80007e26 <_vfprintf_r+0x806>
80007e16:	fa cc f9 44 	sub	r12,sp,-1724
80007e1a:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007e1e:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007e22:	50 7b       	stdsp	sp[0x1c],r11
80007e24:	cd 9b       	rjmp	80007dd6 <_vfprintf_r+0x7b6>
80007e26:	fa c8 f9 50 	sub	r8,sp,-1712
80007e2a:	1a d8       	st.w	--sp,r8
80007e2c:	fa c8 fa b8 	sub	r8,sp,-1352
80007e30:	04 9a       	mov	r10,r2
80007e32:	1a d8       	st.w	--sp,r8
80007e34:	fa c8 fb b4 	sub	r8,sp,-1100
80007e38:	0c 9b       	mov	r11,r6
80007e3a:	1a d8       	st.w	--sp,r8
80007e3c:	08 9c       	mov	r12,r4
80007e3e:	fa c8 f9 40 	sub	r8,sp,-1728
80007e42:	fa c9 ff b4 	sub	r9,sp,-76
80007e46:	fe b0 fa 55 	rcall	800072f0 <get_arg>
80007e4a:	2f dd       	sub	sp,-12
80007e4c:	78 1a       	ld.w	r10,r12[0x4]
80007e4e:	50 7a       	stdsp	sp[0x1c],r10
80007e50:	78 0c       	ld.w	r12,r12[0x0]
80007e52:	50 5c       	stdsp	sp[0x14],r12
80007e54:	c2 a8       	rjmp	80007ea8 <_vfprintf_r+0x888>
80007e56:	2f f7       	sub	r7,-1
80007e58:	10 39       	cp.w	r9,r8
80007e5a:	c0 94       	brge	80007e6c <_vfprintf_r+0x84c>
80007e5c:	fa c9 f9 44 	sub	r9,sp,-1724
80007e60:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007e64:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80007e68:	50 78       	stdsp	sp[0x1c],r8
80007e6a:	cb 6b       	rjmp	80007dd6 <_vfprintf_r+0x7b6>
80007e6c:	41 09       	lddsp	r9,sp[0x40]
80007e6e:	59 f8       	cp.w	r8,31
80007e70:	e0 89 00 15 	brgt	80007e9a <_vfprintf_r+0x87a>
80007e74:	f2 ca ff f8 	sub	r10,r9,-8
80007e78:	72 16       	ld.w	r6,r9[0x4]
80007e7a:	72 09       	ld.w	r9,r9[0x0]
80007e7c:	51 0a       	stdsp	sp[0x40],r10
80007e7e:	50 59       	stdsp	sp[0x14],r9
80007e80:	fa ce f9 44 	sub	lr,sp,-1724
80007e84:	50 76       	stdsp	sp[0x1c],r6
80007e86:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007e8a:	40 5b       	lddsp	r11,sp[0x14]
80007e8c:	0c 9a       	mov	r10,r6
80007e8e:	f2 eb fd 88 	st.d	r9[-632],r10
80007e92:	2f f8       	sub	r8,-1
80007e94:	fb 48 06 b4 	st.w	sp[1716],r8
80007e98:	c0 88       	rjmp	80007ea8 <_vfprintf_r+0x888>
80007e9a:	72 1c       	ld.w	r12,r9[0x4]
80007e9c:	50 7c       	stdsp	sp[0x1c],r12
80007e9e:	f2 c8 ff f8 	sub	r8,r9,-8
80007ea2:	51 08       	stdsp	sp[0x40],r8
80007ea4:	72 09       	ld.w	r9,r9[0x0]
80007ea6:	50 59       	stdsp	sp[0x14],r9
80007ea8:	40 5b       	lddsp	r11,sp[0x14]
80007eaa:	40 7a       	lddsp	r10,sp[0x1c]
80007eac:	e0 a0 19 54 	rcall	8000b154 <__isinfd>
80007eb0:	18 96       	mov	r6,r12
80007eb2:	c1 70       	breq	80007ee0 <_vfprintf_r+0x8c0>
80007eb4:	30 08       	mov	r8,0
80007eb6:	30 09       	mov	r9,0
80007eb8:	40 5b       	lddsp	r11,sp[0x14]
80007eba:	40 7a       	lddsp	r10,sp[0x1c]
80007ebc:	e0 a0 1d a8 	rcall	8000ba0c <__avr32_f64_cmp_lt>
80007ec0:	c0 40       	breq	80007ec8 <_vfprintf_r+0x8a8>
80007ec2:	32 d8       	mov	r8,45
80007ec4:	fb 68 06 bb 	st.b	sp[1723],r8
80007ec8:	fe c8 a6 b8 	sub	r8,pc,-22856
80007ecc:	fe c6 a6 b8 	sub	r6,pc,-22856
80007ed0:	a7 d5       	cbr	r5,0x7
80007ed2:	e0 40 00 47 	cp.w	r0,71
80007ed6:	f0 06 17 a0 	movle	r6,r8
80007eda:	30 32       	mov	r2,3
80007edc:	e0 8f 06 ce 	bral	80008c78 <_vfprintf_r+0x1658>
80007ee0:	40 5b       	lddsp	r11,sp[0x14]
80007ee2:	40 7a       	lddsp	r10,sp[0x1c]
80007ee4:	e0 a0 19 4d 	rcall	8000b17e <__isnand>
80007ee8:	c0 e0       	breq	80007f04 <_vfprintf_r+0x8e4>
80007eea:	50 26       	stdsp	sp[0x8],r6
80007eec:	fe c8 a6 d4 	sub	r8,pc,-22828
80007ef0:	fe c6 a6 d4 	sub	r6,pc,-22828
80007ef4:	a7 d5       	cbr	r5,0x7
80007ef6:	e0 40 00 47 	cp.w	r0,71
80007efa:	f0 06 17 a0 	movle	r6,r8
80007efe:	30 32       	mov	r2,3
80007f00:	e0 8f 06 c2 	bral	80008c84 <_vfprintf_r+0x1664>
80007f04:	40 2a       	lddsp	r10,sp[0x8]
80007f06:	5b fa       	cp.w	r10,-1
80007f08:	c0 41       	brne	80007f10 <_vfprintf_r+0x8f0>
80007f0a:	30 69       	mov	r9,6
80007f0c:	50 29       	stdsp	sp[0x8],r9
80007f0e:	c1 18       	rjmp	80007f30 <_vfprintf_r+0x910>
80007f10:	e0 40 00 47 	cp.w	r0,71
80007f14:	5f 09       	sreq	r9
80007f16:	e0 40 00 67 	cp.w	r0,103
80007f1a:	5f 08       	sreq	r8
80007f1c:	f3 e8 10 08 	or	r8,r9,r8
80007f20:	f8 08 18 00 	cp.b	r8,r12
80007f24:	c0 60       	breq	80007f30 <_vfprintf_r+0x910>
80007f26:	40 28       	lddsp	r8,sp[0x8]
80007f28:	58 08       	cp.w	r8,0
80007f2a:	f9 b8 00 01 	moveq	r8,1
80007f2e:	50 28       	stdsp	sp[0x8],r8
80007f30:	40 78       	lddsp	r8,sp[0x1c]
80007f32:	40 59       	lddsp	r9,sp[0x14]
80007f34:	fa e9 06 94 	st.d	sp[1684],r8
80007f38:	a9 a5       	sbr	r5,0x8
80007f3a:	fa f8 06 94 	ld.w	r8,sp[1684]
80007f3e:	58 08       	cp.w	r8,0
80007f40:	c0 65       	brlt	80007f4c <_vfprintf_r+0x92c>
80007f42:	40 5e       	lddsp	lr,sp[0x14]
80007f44:	30 0c       	mov	r12,0
80007f46:	50 6e       	stdsp	sp[0x18],lr
80007f48:	50 9c       	stdsp	sp[0x24],r12
80007f4a:	c0 78       	rjmp	80007f58 <_vfprintf_r+0x938>
80007f4c:	40 5b       	lddsp	r11,sp[0x14]
80007f4e:	32 da       	mov	r10,45
80007f50:	ee 1b 80 00 	eorh	r11,0x8000
80007f54:	50 9a       	stdsp	sp[0x24],r10
80007f56:	50 6b       	stdsp	sp[0x18],r11
80007f58:	e0 40 00 46 	cp.w	r0,70
80007f5c:	5f 09       	sreq	r9
80007f5e:	e0 40 00 66 	cp.w	r0,102
80007f62:	5f 08       	sreq	r8
80007f64:	f3 e8 10 08 	or	r8,r9,r8
80007f68:	50 48       	stdsp	sp[0x10],r8
80007f6a:	c0 40       	breq	80007f72 <_vfprintf_r+0x952>
80007f6c:	40 22       	lddsp	r2,sp[0x8]
80007f6e:	30 39       	mov	r9,3
80007f70:	c1 08       	rjmp	80007f90 <_vfprintf_r+0x970>
80007f72:	e0 40 00 45 	cp.w	r0,69
80007f76:	5f 09       	sreq	r9
80007f78:	e0 40 00 65 	cp.w	r0,101
80007f7c:	5f 08       	sreq	r8
80007f7e:	40 22       	lddsp	r2,sp[0x8]
80007f80:	10 49       	or	r9,r8
80007f82:	2f f2       	sub	r2,-1
80007f84:	40 46       	lddsp	r6,sp[0x10]
80007f86:	ec 09 18 00 	cp.b	r9,r6
80007f8a:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80007f8e:	30 29       	mov	r9,2
80007f90:	fa c8 f9 5c 	sub	r8,sp,-1700
80007f94:	1a d8       	st.w	--sp,r8
80007f96:	fa c8 f9 54 	sub	r8,sp,-1708
80007f9a:	1a d8       	st.w	--sp,r8
80007f9c:	fa c8 f9 4c 	sub	r8,sp,-1716
80007fa0:	08 9c       	mov	r12,r4
80007fa2:	1a d8       	st.w	--sp,r8
80007fa4:	04 98       	mov	r8,r2
80007fa6:	40 9b       	lddsp	r11,sp[0x24]
80007fa8:	40 aa       	lddsp	r10,sp[0x28]
80007faa:	e0 a0 0b c3 	rcall	80009730 <_dtoa_r>
80007fae:	e0 40 00 47 	cp.w	r0,71
80007fb2:	5f 19       	srne	r9
80007fb4:	e0 40 00 67 	cp.w	r0,103
80007fb8:	5f 18       	srne	r8
80007fba:	18 96       	mov	r6,r12
80007fbc:	2f dd       	sub	sp,-12
80007fbe:	f3 e8 00 08 	and	r8,r9,r8
80007fc2:	c0 41       	brne	80007fca <_vfprintf_r+0x9aa>
80007fc4:	ed b5 00 00 	bld	r5,0x0
80007fc8:	c3 01       	brne	80008028 <_vfprintf_r+0xa08>
80007fca:	ec 02 00 0e 	add	lr,r6,r2
80007fce:	50 3e       	stdsp	sp[0xc],lr
80007fd0:	40 4c       	lddsp	r12,sp[0x10]
80007fd2:	58 0c       	cp.w	r12,0
80007fd4:	c1 50       	breq	80007ffe <_vfprintf_r+0x9de>
80007fd6:	0d 89       	ld.ub	r9,r6[0x0]
80007fd8:	33 08       	mov	r8,48
80007fda:	f0 09 18 00 	cp.b	r9,r8
80007fde:	c0 b1       	brne	80007ff4 <_vfprintf_r+0x9d4>
80007fe0:	30 08       	mov	r8,0
80007fe2:	30 09       	mov	r9,0
80007fe4:	40 6b       	lddsp	r11,sp[0x18]
80007fe6:	40 7a       	lddsp	r10,sp[0x1c]
80007fe8:	e0 a0 1c cb 	rcall	8000b97e <__avr32_f64_cmp_eq>
80007fec:	fb b2 00 01 	rsubeq	r2,1
80007ff0:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80007ff4:	40 3b       	lddsp	r11,sp[0xc]
80007ff6:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007ffa:	10 0b       	add	r11,r8
80007ffc:	50 3b       	stdsp	sp[0xc],r11
80007ffe:	40 6b       	lddsp	r11,sp[0x18]
80008000:	30 08       	mov	r8,0
80008002:	30 09       	mov	r9,0
80008004:	40 7a       	lddsp	r10,sp[0x1c]
80008006:	e0 a0 1c bc 	rcall	8000b97e <__avr32_f64_cmp_eq>
8000800a:	c0 90       	breq	8000801c <_vfprintf_r+0x9fc>
8000800c:	40 3a       	lddsp	r10,sp[0xc]
8000800e:	fb 4a 06 a4 	st.w	sp[1700],r10
80008012:	c0 58       	rjmp	8000801c <_vfprintf_r+0x9fc>
80008014:	10 c9       	st.b	r8++,r9
80008016:	fb 48 06 a4 	st.w	sp[1700],r8
8000801a:	c0 28       	rjmp	8000801e <_vfprintf_r+0x9fe>
8000801c:	33 09       	mov	r9,48
8000801e:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008022:	40 3e       	lddsp	lr,sp[0xc]
80008024:	1c 38       	cp.w	r8,lr
80008026:	cf 73       	brcs	80008014 <_vfprintf_r+0x9f4>
80008028:	e0 40 00 47 	cp.w	r0,71
8000802c:	5f 09       	sreq	r9
8000802e:	e0 40 00 67 	cp.w	r0,103
80008032:	5f 08       	sreq	r8
80008034:	f3 e8 10 08 	or	r8,r9,r8
80008038:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000803c:	0c 19       	sub	r9,r6
8000803e:	50 69       	stdsp	sp[0x18],r9
80008040:	58 08       	cp.w	r8,0
80008042:	c0 b0       	breq	80008058 <_vfprintf_r+0xa38>
80008044:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008048:	5b d8       	cp.w	r8,-3
8000804a:	c0 55       	brlt	80008054 <_vfprintf_r+0xa34>
8000804c:	40 2c       	lddsp	r12,sp[0x8]
8000804e:	18 38       	cp.w	r8,r12
80008050:	e0 8a 00 6a 	brle	80008124 <_vfprintf_r+0xb04>
80008054:	20 20       	sub	r0,2
80008056:	c0 58       	rjmp	80008060 <_vfprintf_r+0xa40>
80008058:	e0 40 00 65 	cp.w	r0,101
8000805c:	e0 89 00 46 	brgt	800080e8 <_vfprintf_r+0xac8>
80008060:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008064:	fb 60 06 9c 	st.b	sp[1692],r0
80008068:	20 1b       	sub	r11,1
8000806a:	fb 4b 06 ac 	st.w	sp[1708],r11
8000806e:	c0 47       	brpl	80008076 <_vfprintf_r+0xa56>
80008070:	5c 3b       	neg	r11
80008072:	32 d8       	mov	r8,45
80008074:	c0 28       	rjmp	80008078 <_vfprintf_r+0xa58>
80008076:	32 b8       	mov	r8,43
80008078:	fb 68 06 9d 	st.b	sp[1693],r8
8000807c:	58 9b       	cp.w	r11,9
8000807e:	e0 8a 00 1d 	brle	800080b8 <_vfprintf_r+0xa98>
80008082:	fa c9 fa 35 	sub	r9,sp,-1483
80008086:	30 aa       	mov	r10,10
80008088:	12 98       	mov	r8,r9
8000808a:	0e 9c       	mov	r12,r7
8000808c:	0c 92       	mov	r2,r6
8000808e:	f6 0a 0c 06 	divs	r6,r11,r10
80008092:	0e 9b       	mov	r11,r7
80008094:	2d 0b       	sub	r11,-48
80008096:	10 fb       	st.b	--r8,r11
80008098:	0c 9b       	mov	r11,r6
8000809a:	58 96       	cp.w	r6,9
8000809c:	fe 99 ff f9 	brgt	8000808e <_vfprintf_r+0xa6e>
800080a0:	2d 0b       	sub	r11,-48
800080a2:	18 97       	mov	r7,r12
800080a4:	04 96       	mov	r6,r2
800080a6:	10 fb       	st.b	--r8,r11
800080a8:	fa ca f9 62 	sub	r10,sp,-1694
800080ac:	c0 38       	rjmp	800080b2 <_vfprintf_r+0xa92>
800080ae:	11 3b       	ld.ub	r11,r8++
800080b0:	14 cb       	st.b	r10++,r11
800080b2:	12 38       	cp.w	r8,r9
800080b4:	cf d3       	brcs	800080ae <_vfprintf_r+0xa8e>
800080b6:	c0 98       	rjmp	800080c8 <_vfprintf_r+0xaa8>
800080b8:	2d 0b       	sub	r11,-48
800080ba:	33 08       	mov	r8,48
800080bc:	fb 6b 06 9f 	st.b	sp[1695],r11
800080c0:	fb 68 06 9e 	st.b	sp[1694],r8
800080c4:	fa ca f9 60 	sub	r10,sp,-1696
800080c8:	fa c8 f9 64 	sub	r8,sp,-1692
800080cc:	f4 08 01 08 	sub	r8,r10,r8
800080d0:	50 e8       	stdsp	sp[0x38],r8
800080d2:	10 92       	mov	r2,r8
800080d4:	40 6b       	lddsp	r11,sp[0x18]
800080d6:	16 02       	add	r2,r11
800080d8:	58 1b       	cp.w	r11,1
800080da:	e0 89 00 05 	brgt	800080e4 <_vfprintf_r+0xac4>
800080de:	ed b5 00 00 	bld	r5,0x0
800080e2:	c3 51       	brne	8000814c <_vfprintf_r+0xb2c>
800080e4:	2f f2       	sub	r2,-1
800080e6:	c3 38       	rjmp	8000814c <_vfprintf_r+0xb2c>
800080e8:	e0 40 00 66 	cp.w	r0,102
800080ec:	c1 c1       	brne	80008124 <_vfprintf_r+0xb04>
800080ee:	fa f2 06 ac 	ld.w	r2,sp[1708]
800080f2:	58 02       	cp.w	r2,0
800080f4:	e0 8a 00 0c 	brle	8000810c <_vfprintf_r+0xaec>
800080f8:	40 2a       	lddsp	r10,sp[0x8]
800080fa:	58 0a       	cp.w	r10,0
800080fc:	c0 41       	brne	80008104 <_vfprintf_r+0xae4>
800080fe:	ed b5 00 00 	bld	r5,0x0
80008102:	c2 51       	brne	8000814c <_vfprintf_r+0xb2c>
80008104:	2f f2       	sub	r2,-1
80008106:	40 29       	lddsp	r9,sp[0x8]
80008108:	12 02       	add	r2,r9
8000810a:	c0 b8       	rjmp	80008120 <_vfprintf_r+0xb00>
8000810c:	40 28       	lddsp	r8,sp[0x8]
8000810e:	58 08       	cp.w	r8,0
80008110:	c0 61       	brne	8000811c <_vfprintf_r+0xafc>
80008112:	ed b5 00 00 	bld	r5,0x0
80008116:	c0 30       	breq	8000811c <_vfprintf_r+0xafc>
80008118:	30 12       	mov	r2,1
8000811a:	c1 98       	rjmp	8000814c <_vfprintf_r+0xb2c>
8000811c:	40 22       	lddsp	r2,sp[0x8]
8000811e:	2f e2       	sub	r2,-2
80008120:	36 60       	mov	r0,102
80008122:	c1 58       	rjmp	8000814c <_vfprintf_r+0xb2c>
80008124:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008128:	40 6e       	lddsp	lr,sp[0x18]
8000812a:	1c 32       	cp.w	r2,lr
8000812c:	c0 65       	brlt	80008138 <_vfprintf_r+0xb18>
8000812e:	ed b5 00 00 	bld	r5,0x0
80008132:	f7 b2 00 ff 	subeq	r2,-1
80008136:	c0 a8       	rjmp	8000814a <_vfprintf_r+0xb2a>
80008138:	e4 08 11 02 	rsub	r8,r2,2
8000813c:	40 6c       	lddsp	r12,sp[0x18]
8000813e:	58 02       	cp.w	r2,0
80008140:	f0 02 17 a0 	movle	r2,r8
80008144:	f9 b2 09 01 	movgt	r2,1
80008148:	18 02       	add	r2,r12
8000814a:	36 70       	mov	r0,103
8000814c:	40 9b       	lddsp	r11,sp[0x24]
8000814e:	58 0b       	cp.w	r11,0
80008150:	e0 80 05 94 	breq	80008c78 <_vfprintf_r+0x1658>
80008154:	32 d8       	mov	r8,45
80008156:	fb 68 06 bb 	st.b	sp[1723],r8
8000815a:	e0 8f 05 93 	bral	80008c80 <_vfprintf_r+0x1660>
8000815e:	50 a7       	stdsp	sp[0x28],r7
80008160:	04 94       	mov	r4,r2
80008162:	0c 97       	mov	r7,r6
80008164:	02 92       	mov	r2,r1
80008166:	06 96       	mov	r6,r3
80008168:	40 41       	lddsp	r1,sp[0x10]
8000816a:	40 93       	lddsp	r3,sp[0x24]
8000816c:	0e 99       	mov	r9,r7
8000816e:	ed b5 00 05 	bld	r5,0x5
80008172:	c4 81       	brne	80008202 <_vfprintf_r+0xbe2>
80008174:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008178:	40 3e       	lddsp	lr,sp[0xc]
8000817a:	58 0e       	cp.w	lr,0
8000817c:	c1 d0       	breq	800081b6 <_vfprintf_r+0xb96>
8000817e:	10 36       	cp.w	r6,r8
80008180:	c0 64       	brge	8000818c <_vfprintf_r+0xb6c>
80008182:	fa cc f9 44 	sub	r12,sp,-1724
80008186:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000818a:	c1 d8       	rjmp	800081c4 <_vfprintf_r+0xba4>
8000818c:	fa c8 f9 50 	sub	r8,sp,-1712
80008190:	1a d8       	st.w	--sp,r8
80008192:	fa c8 fa b8 	sub	r8,sp,-1352
80008196:	04 9a       	mov	r10,r2
80008198:	1a d8       	st.w	--sp,r8
8000819a:	fa c8 fb b4 	sub	r8,sp,-1100
8000819e:	0c 9b       	mov	r11,r6
800081a0:	1a d8       	st.w	--sp,r8
800081a2:	08 9c       	mov	r12,r4
800081a4:	fa c8 f9 40 	sub	r8,sp,-1728
800081a8:	fa c9 ff b4 	sub	r9,sp,-76
800081ac:	fe b0 f8 a2 	rcall	800072f0 <get_arg>
800081b0:	2f dd       	sub	sp,-12
800081b2:	78 0a       	ld.w	r10,r12[0x0]
800081b4:	c2 08       	rjmp	800081f4 <_vfprintf_r+0xbd4>
800081b6:	2f f7       	sub	r7,-1
800081b8:	10 39       	cp.w	r9,r8
800081ba:	c0 84       	brge	800081ca <_vfprintf_r+0xbaa>
800081bc:	fa cb f9 44 	sub	r11,sp,-1724
800081c0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081c4:	ec fa fd 88 	ld.w	r10,r6[-632]
800081c8:	c1 68       	rjmp	800081f4 <_vfprintf_r+0xbd4>
800081ca:	41 09       	lddsp	r9,sp[0x40]
800081cc:	59 f8       	cp.w	r8,31
800081ce:	e0 89 00 10 	brgt	800081ee <_vfprintf_r+0xbce>
800081d2:	f2 ca ff fc 	sub	r10,r9,-4
800081d6:	51 0a       	stdsp	sp[0x40],r10
800081d8:	fa c6 f9 44 	sub	r6,sp,-1724
800081dc:	72 0a       	ld.w	r10,r9[0x0]
800081de:	ec 08 00 39 	add	r9,r6,r8<<0x3
800081e2:	f3 4a fd 88 	st.w	r9[-632],r10
800081e6:	2f f8       	sub	r8,-1
800081e8:	fb 48 06 b4 	st.w	sp[1716],r8
800081ec:	c0 48       	rjmp	800081f4 <_vfprintf_r+0xbd4>
800081ee:	72 0a       	ld.w	r10,r9[0x0]
800081f0:	2f c9       	sub	r9,-4
800081f2:	51 09       	stdsp	sp[0x40],r9
800081f4:	40 be       	lddsp	lr,sp[0x2c]
800081f6:	1c 98       	mov	r8,lr
800081f8:	95 1e       	st.w	r10[0x4],lr
800081fa:	bf 58       	asr	r8,0x1f
800081fc:	95 08       	st.w	r10[0x0],r8
800081fe:	fe 9f fa 9f 	bral	8000773c <_vfprintf_r+0x11c>
80008202:	ed b5 00 04 	bld	r5,0x4
80008206:	c4 80       	breq	80008296 <_vfprintf_r+0xc76>
80008208:	e2 15 00 40 	andl	r5,0x40,COH
8000820c:	c4 50       	breq	80008296 <_vfprintf_r+0xc76>
8000820e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008212:	40 3c       	lddsp	r12,sp[0xc]
80008214:	58 0c       	cp.w	r12,0
80008216:	c1 d0       	breq	80008250 <_vfprintf_r+0xc30>
80008218:	10 36       	cp.w	r6,r8
8000821a:	c0 64       	brge	80008226 <_vfprintf_r+0xc06>
8000821c:	fa cb f9 44 	sub	r11,sp,-1724
80008220:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008224:	c1 d8       	rjmp	8000825e <_vfprintf_r+0xc3e>
80008226:	fa c8 f9 50 	sub	r8,sp,-1712
8000822a:	1a d8       	st.w	--sp,r8
8000822c:	fa c8 fa b8 	sub	r8,sp,-1352
80008230:	04 9a       	mov	r10,r2
80008232:	1a d8       	st.w	--sp,r8
80008234:	fa c8 fb b4 	sub	r8,sp,-1100
80008238:	0c 9b       	mov	r11,r6
8000823a:	1a d8       	st.w	--sp,r8
8000823c:	08 9c       	mov	r12,r4
8000823e:	fa c8 f9 40 	sub	r8,sp,-1728
80008242:	fa c9 ff b4 	sub	r9,sp,-76
80008246:	fe b0 f8 55 	rcall	800072f0 <get_arg>
8000824a:	2f dd       	sub	sp,-12
8000824c:	78 0a       	ld.w	r10,r12[0x0]
8000824e:	c2 08       	rjmp	8000828e <_vfprintf_r+0xc6e>
80008250:	2f f7       	sub	r7,-1
80008252:	10 39       	cp.w	r9,r8
80008254:	c0 84       	brge	80008264 <_vfprintf_r+0xc44>
80008256:	fa ca f9 44 	sub	r10,sp,-1724
8000825a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000825e:	ec fa fd 88 	ld.w	r10,r6[-632]
80008262:	c1 68       	rjmp	8000828e <_vfprintf_r+0xc6e>
80008264:	41 09       	lddsp	r9,sp[0x40]
80008266:	59 f8       	cp.w	r8,31
80008268:	e0 89 00 10 	brgt	80008288 <_vfprintf_r+0xc68>
8000826c:	f2 ca ff fc 	sub	r10,r9,-4
80008270:	51 0a       	stdsp	sp[0x40],r10
80008272:	fa c6 f9 44 	sub	r6,sp,-1724
80008276:	72 0a       	ld.w	r10,r9[0x0]
80008278:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000827c:	f3 4a fd 88 	st.w	r9[-632],r10
80008280:	2f f8       	sub	r8,-1
80008282:	fb 48 06 b4 	st.w	sp[1716],r8
80008286:	c0 48       	rjmp	8000828e <_vfprintf_r+0xc6e>
80008288:	72 0a       	ld.w	r10,r9[0x0]
8000828a:	2f c9       	sub	r9,-4
8000828c:	51 09       	stdsp	sp[0x40],r9
8000828e:	40 be       	lddsp	lr,sp[0x2c]
80008290:	b4 0e       	st.h	r10[0x0],lr
80008292:	fe 9f fa 55 	bral	8000773c <_vfprintf_r+0x11c>
80008296:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000829a:	40 3c       	lddsp	r12,sp[0xc]
8000829c:	58 0c       	cp.w	r12,0
8000829e:	c1 d0       	breq	800082d8 <_vfprintf_r+0xcb8>
800082a0:	10 36       	cp.w	r6,r8
800082a2:	c0 64       	brge	800082ae <_vfprintf_r+0xc8e>
800082a4:	fa cb f9 44 	sub	r11,sp,-1724
800082a8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800082ac:	c1 d8       	rjmp	800082e6 <_vfprintf_r+0xcc6>
800082ae:	fa c8 f9 50 	sub	r8,sp,-1712
800082b2:	1a d8       	st.w	--sp,r8
800082b4:	fa c8 fa b8 	sub	r8,sp,-1352
800082b8:	04 9a       	mov	r10,r2
800082ba:	1a d8       	st.w	--sp,r8
800082bc:	fa c8 fb b4 	sub	r8,sp,-1100
800082c0:	0c 9b       	mov	r11,r6
800082c2:	1a d8       	st.w	--sp,r8
800082c4:	08 9c       	mov	r12,r4
800082c6:	fa c8 f9 40 	sub	r8,sp,-1728
800082ca:	fa c9 ff b4 	sub	r9,sp,-76
800082ce:	fe b0 f8 11 	rcall	800072f0 <get_arg>
800082d2:	2f dd       	sub	sp,-12
800082d4:	78 0a       	ld.w	r10,r12[0x0]
800082d6:	c2 08       	rjmp	80008316 <_vfprintf_r+0xcf6>
800082d8:	2f f7       	sub	r7,-1
800082da:	10 39       	cp.w	r9,r8
800082dc:	c0 84       	brge	800082ec <_vfprintf_r+0xccc>
800082de:	fa ca f9 44 	sub	r10,sp,-1724
800082e2:	f4 06 00 36 	add	r6,r10,r6<<0x3
800082e6:	ec fa fd 88 	ld.w	r10,r6[-632]
800082ea:	c1 68       	rjmp	80008316 <_vfprintf_r+0xcf6>
800082ec:	41 09       	lddsp	r9,sp[0x40]
800082ee:	59 f8       	cp.w	r8,31
800082f0:	e0 89 00 10 	brgt	80008310 <_vfprintf_r+0xcf0>
800082f4:	f2 ca ff fc 	sub	r10,r9,-4
800082f8:	51 0a       	stdsp	sp[0x40],r10
800082fa:	fa c6 f9 44 	sub	r6,sp,-1724
800082fe:	72 0a       	ld.w	r10,r9[0x0]
80008300:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008304:	f3 4a fd 88 	st.w	r9[-632],r10
80008308:	2f f8       	sub	r8,-1
8000830a:	fb 48 06 b4 	st.w	sp[1716],r8
8000830e:	c0 48       	rjmp	80008316 <_vfprintf_r+0xcf6>
80008310:	72 0a       	ld.w	r10,r9[0x0]
80008312:	2f c9       	sub	r9,-4
80008314:	51 09       	stdsp	sp[0x40],r9
80008316:	40 be       	lddsp	lr,sp[0x2c]
80008318:	95 0e       	st.w	r10[0x0],lr
8000831a:	fe 9f fa 11 	bral	8000773c <_vfprintf_r+0x11c>
8000831e:	50 a7       	stdsp	sp[0x28],r7
80008320:	50 80       	stdsp	sp[0x20],r0
80008322:	0c 97       	mov	r7,r6
80008324:	04 94       	mov	r4,r2
80008326:	06 96       	mov	r6,r3
80008328:	02 92       	mov	r2,r1
8000832a:	40 93       	lddsp	r3,sp[0x24]
8000832c:	10 90       	mov	r0,r8
8000832e:	40 41       	lddsp	r1,sp[0x10]
80008330:	a5 a5       	sbr	r5,0x4
80008332:	c0 a8       	rjmp	80008346 <_vfprintf_r+0xd26>
80008334:	50 a7       	stdsp	sp[0x28],r7
80008336:	50 80       	stdsp	sp[0x20],r0
80008338:	0c 97       	mov	r7,r6
8000833a:	04 94       	mov	r4,r2
8000833c:	06 96       	mov	r6,r3
8000833e:	02 92       	mov	r2,r1
80008340:	40 93       	lddsp	r3,sp[0x24]
80008342:	10 90       	mov	r0,r8
80008344:	40 41       	lddsp	r1,sp[0x10]
80008346:	ed b5 00 05 	bld	r5,0x5
8000834a:	c5 d1       	brne	80008404 <_vfprintf_r+0xde4>
8000834c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008350:	40 3c       	lddsp	r12,sp[0xc]
80008352:	58 0c       	cp.w	r12,0
80008354:	c2 60       	breq	800083a0 <_vfprintf_r+0xd80>
80008356:	10 36       	cp.w	r6,r8
80008358:	c0 a4       	brge	8000836c <_vfprintf_r+0xd4c>
8000835a:	fa cb f9 44 	sub	r11,sp,-1724
8000835e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008362:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008366:	fa e9 00 00 	st.d	sp[0],r8
8000836a:	c1 88       	rjmp	8000839a <_vfprintf_r+0xd7a>
8000836c:	fa c8 f9 50 	sub	r8,sp,-1712
80008370:	1a d8       	st.w	--sp,r8
80008372:	fa c8 fa b8 	sub	r8,sp,-1352
80008376:	04 9a       	mov	r10,r2
80008378:	1a d8       	st.w	--sp,r8
8000837a:	0c 9b       	mov	r11,r6
8000837c:	fa c8 fb b4 	sub	r8,sp,-1100
80008380:	08 9c       	mov	r12,r4
80008382:	1a d8       	st.w	--sp,r8
80008384:	fa c8 f9 40 	sub	r8,sp,-1728
80008388:	fa c9 ff b4 	sub	r9,sp,-76
8000838c:	fe b0 f7 b2 	rcall	800072f0 <get_arg>
80008390:	2f dd       	sub	sp,-12
80008392:	f8 ea 00 00 	ld.d	r10,r12[0]
80008396:	fa eb 00 00 	st.d	sp[0],r10
8000839a:	30 08       	mov	r8,0
8000839c:	e0 8f 03 de 	bral	80008b58 <_vfprintf_r+0x1538>
800083a0:	ee ca ff ff 	sub	r10,r7,-1
800083a4:	10 37       	cp.w	r7,r8
800083a6:	c0 b4       	brge	800083bc <_vfprintf_r+0xd9c>
800083a8:	fa c9 f9 44 	sub	r9,sp,-1724
800083ac:	14 97       	mov	r7,r10
800083ae:	f2 06 00 36 	add	r6,r9,r6<<0x3
800083b2:	ec ea fd 88 	ld.d	r10,r6[-632]
800083b6:	fa eb 00 00 	st.d	sp[0],r10
800083ba:	c1 88       	rjmp	800083ea <_vfprintf_r+0xdca>
800083bc:	41 09       	lddsp	r9,sp[0x40]
800083be:	59 f8       	cp.w	r8,31
800083c0:	e0 89 00 18 	brgt	800083f0 <_vfprintf_r+0xdd0>
800083c4:	f2 e6 00 00 	ld.d	r6,r9[0]
800083c8:	f2 cb ff f8 	sub	r11,r9,-8
800083cc:	fa e7 00 00 	st.d	sp[0],r6
800083d0:	51 0b       	stdsp	sp[0x40],r11
800083d2:	fa c6 f9 44 	sub	r6,sp,-1724
800083d6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800083da:	fa e6 00 00 	ld.d	r6,sp[0]
800083de:	f2 e7 fd 88 	st.d	r9[-632],r6
800083e2:	2f f8       	sub	r8,-1
800083e4:	14 97       	mov	r7,r10
800083e6:	fb 48 06 b4 	st.w	sp[1716],r8
800083ea:	40 38       	lddsp	r8,sp[0xc]
800083ec:	e0 8f 03 b6 	bral	80008b58 <_vfprintf_r+0x1538>
800083f0:	f2 e6 00 00 	ld.d	r6,r9[0]
800083f4:	40 38       	lddsp	r8,sp[0xc]
800083f6:	fa e7 00 00 	st.d	sp[0],r6
800083fa:	2f 89       	sub	r9,-8
800083fc:	14 97       	mov	r7,r10
800083fe:	51 09       	stdsp	sp[0x40],r9
80008400:	e0 8f 03 ac 	bral	80008b58 <_vfprintf_r+0x1538>
80008404:	ed b5 00 04 	bld	r5,0x4
80008408:	c1 61       	brne	80008434 <_vfprintf_r+0xe14>
8000840a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000840e:	40 3e       	lddsp	lr,sp[0xc]
80008410:	58 0e       	cp.w	lr,0
80008412:	c0 80       	breq	80008422 <_vfprintf_r+0xe02>
80008414:	10 36       	cp.w	r6,r8
80008416:	c6 74       	brge	800084e4 <_vfprintf_r+0xec4>
80008418:	fa cc f9 44 	sub	r12,sp,-1724
8000841c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008420:	c8 08       	rjmp	80008520 <_vfprintf_r+0xf00>
80008422:	ee ca ff ff 	sub	r10,r7,-1
80008426:	10 37       	cp.w	r7,r8
80008428:	c7 f4       	brge	80008526 <_vfprintf_r+0xf06>
8000842a:	fa cb f9 44 	sub	r11,sp,-1724
8000842e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008432:	c7 68       	rjmp	8000851e <_vfprintf_r+0xefe>
80008434:	ed b5 00 06 	bld	r5,0x6
80008438:	c4 a1       	brne	800084cc <_vfprintf_r+0xeac>
8000843a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000843e:	40 3c       	lddsp	r12,sp[0xc]
80008440:	58 0c       	cp.w	r12,0
80008442:	c1 d0       	breq	8000847c <_vfprintf_r+0xe5c>
80008444:	10 36       	cp.w	r6,r8
80008446:	c0 64       	brge	80008452 <_vfprintf_r+0xe32>
80008448:	fa cb f9 44 	sub	r11,sp,-1724
8000844c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008450:	c1 f8       	rjmp	8000848e <_vfprintf_r+0xe6e>
80008452:	fa c8 f9 50 	sub	r8,sp,-1712
80008456:	1a d8       	st.w	--sp,r8
80008458:	fa c8 fa b8 	sub	r8,sp,-1352
8000845c:	1a d8       	st.w	--sp,r8
8000845e:	fa c8 fb b4 	sub	r8,sp,-1100
80008462:	1a d8       	st.w	--sp,r8
80008464:	fa c8 f9 40 	sub	r8,sp,-1728
80008468:	fa c9 ff b4 	sub	r9,sp,-76
8000846c:	04 9a       	mov	r10,r2
8000846e:	0c 9b       	mov	r11,r6
80008470:	08 9c       	mov	r12,r4
80008472:	fe b0 f7 3f 	rcall	800072f0 <get_arg>
80008476:	2f dd       	sub	sp,-12
80008478:	98 18       	ld.sh	r8,r12[0x2]
8000847a:	c2 68       	rjmp	800084c6 <_vfprintf_r+0xea6>
8000847c:	ee ca ff ff 	sub	r10,r7,-1
80008480:	10 37       	cp.w	r7,r8
80008482:	c0 94       	brge	80008494 <_vfprintf_r+0xe74>
80008484:	fa c9 f9 44 	sub	r9,sp,-1724
80008488:	14 97       	mov	r7,r10
8000848a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000848e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008492:	c1 a8       	rjmp	800084c6 <_vfprintf_r+0xea6>
80008494:	41 09       	lddsp	r9,sp[0x40]
80008496:	59 f8       	cp.w	r8,31
80008498:	e0 89 00 13 	brgt	800084be <_vfprintf_r+0xe9e>
8000849c:	f2 cb ff fc 	sub	r11,r9,-4
800084a0:	51 0b       	stdsp	sp[0x40],r11
800084a2:	72 09       	ld.w	r9,r9[0x0]
800084a4:	fa c6 f9 44 	sub	r6,sp,-1724
800084a8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800084ac:	2f f8       	sub	r8,-1
800084ae:	f7 49 fd 88 	st.w	r11[-632],r9
800084b2:	fb 48 06 b4 	st.w	sp[1716],r8
800084b6:	14 97       	mov	r7,r10
800084b8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800084bc:	c0 58       	rjmp	800084c6 <_vfprintf_r+0xea6>
800084be:	92 18       	ld.sh	r8,r9[0x2]
800084c0:	14 97       	mov	r7,r10
800084c2:	2f c9       	sub	r9,-4
800084c4:	51 09       	stdsp	sp[0x40],r9
800084c6:	5c 78       	castu.h	r8
800084c8:	50 18       	stdsp	sp[0x4],r8
800084ca:	c4 68       	rjmp	80008556 <_vfprintf_r+0xf36>
800084cc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084d0:	40 3c       	lddsp	r12,sp[0xc]
800084d2:	58 0c       	cp.w	r12,0
800084d4:	c1 d0       	breq	8000850e <_vfprintf_r+0xeee>
800084d6:	10 36       	cp.w	r6,r8
800084d8:	c0 64       	brge	800084e4 <_vfprintf_r+0xec4>
800084da:	fa cb f9 44 	sub	r11,sp,-1724
800084de:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084e2:	c1 f8       	rjmp	80008520 <_vfprintf_r+0xf00>
800084e4:	fa c8 f9 50 	sub	r8,sp,-1712
800084e8:	1a d8       	st.w	--sp,r8
800084ea:	fa c8 fa b8 	sub	r8,sp,-1352
800084ee:	0c 9b       	mov	r11,r6
800084f0:	1a d8       	st.w	--sp,r8
800084f2:	fa c8 fb b4 	sub	r8,sp,-1100
800084f6:	04 9a       	mov	r10,r2
800084f8:	1a d8       	st.w	--sp,r8
800084fa:	08 9c       	mov	r12,r4
800084fc:	fa c8 f9 40 	sub	r8,sp,-1728
80008500:	fa c9 ff b4 	sub	r9,sp,-76
80008504:	fe b0 f6 f6 	rcall	800072f0 <get_arg>
80008508:	2f dd       	sub	sp,-12
8000850a:	78 0b       	ld.w	r11,r12[0x0]
8000850c:	c2 48       	rjmp	80008554 <_vfprintf_r+0xf34>
8000850e:	ee ca ff ff 	sub	r10,r7,-1
80008512:	10 37       	cp.w	r7,r8
80008514:	c0 94       	brge	80008526 <_vfprintf_r+0xf06>
80008516:	fa c9 f9 44 	sub	r9,sp,-1724
8000851a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000851e:	14 97       	mov	r7,r10
80008520:	ec fb fd 88 	ld.w	r11,r6[-632]
80008524:	c1 88       	rjmp	80008554 <_vfprintf_r+0xf34>
80008526:	41 09       	lddsp	r9,sp[0x40]
80008528:	59 f8       	cp.w	r8,31
8000852a:	e0 89 00 11 	brgt	8000854c <_vfprintf_r+0xf2c>
8000852e:	f2 cb ff fc 	sub	r11,r9,-4
80008532:	51 0b       	stdsp	sp[0x40],r11
80008534:	fa c6 f9 44 	sub	r6,sp,-1724
80008538:	72 0b       	ld.w	r11,r9[0x0]
8000853a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000853e:	f3 4b fd 88 	st.w	r9[-632],r11
80008542:	2f f8       	sub	r8,-1
80008544:	14 97       	mov	r7,r10
80008546:	fb 48 06 b4 	st.w	sp[1716],r8
8000854a:	c0 58       	rjmp	80008554 <_vfprintf_r+0xf34>
8000854c:	72 0b       	ld.w	r11,r9[0x0]
8000854e:	14 97       	mov	r7,r10
80008550:	2f c9       	sub	r9,-4
80008552:	51 09       	stdsp	sp[0x40],r9
80008554:	50 1b       	stdsp	sp[0x4],r11
80008556:	30 0e       	mov	lr,0
80008558:	50 0e       	stdsp	sp[0x0],lr
8000855a:	1c 98       	mov	r8,lr
8000855c:	e0 8f 02 fe 	bral	80008b58 <_vfprintf_r+0x1538>
80008560:	50 a7       	stdsp	sp[0x28],r7
80008562:	50 80       	stdsp	sp[0x20],r0
80008564:	0c 97       	mov	r7,r6
80008566:	04 94       	mov	r4,r2
80008568:	06 96       	mov	r6,r3
8000856a:	02 92       	mov	r2,r1
8000856c:	40 93       	lddsp	r3,sp[0x24]
8000856e:	40 41       	lddsp	r1,sp[0x10]
80008570:	0e 99       	mov	r9,r7
80008572:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008576:	40 3c       	lddsp	r12,sp[0xc]
80008578:	58 0c       	cp.w	r12,0
8000857a:	c1 d0       	breq	800085b4 <_vfprintf_r+0xf94>
8000857c:	10 36       	cp.w	r6,r8
8000857e:	c0 64       	brge	8000858a <_vfprintf_r+0xf6a>
80008580:	fa cb f9 44 	sub	r11,sp,-1724
80008584:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008588:	c1 d8       	rjmp	800085c2 <_vfprintf_r+0xfa2>
8000858a:	fa c8 f9 50 	sub	r8,sp,-1712
8000858e:	1a d8       	st.w	--sp,r8
80008590:	fa c8 fa b8 	sub	r8,sp,-1352
80008594:	1a d8       	st.w	--sp,r8
80008596:	fa c8 fb b4 	sub	r8,sp,-1100
8000859a:	1a d8       	st.w	--sp,r8
8000859c:	fa c9 ff b4 	sub	r9,sp,-76
800085a0:	fa c8 f9 40 	sub	r8,sp,-1728
800085a4:	04 9a       	mov	r10,r2
800085a6:	0c 9b       	mov	r11,r6
800085a8:	08 9c       	mov	r12,r4
800085aa:	fe b0 f6 a3 	rcall	800072f0 <get_arg>
800085ae:	2f dd       	sub	sp,-12
800085b0:	78 09       	ld.w	r9,r12[0x0]
800085b2:	c2 18       	rjmp	800085f4 <_vfprintf_r+0xfd4>
800085b4:	2f f7       	sub	r7,-1
800085b6:	10 39       	cp.w	r9,r8
800085b8:	c0 84       	brge	800085c8 <_vfprintf_r+0xfa8>
800085ba:	fa ca f9 44 	sub	r10,sp,-1724
800085be:	f4 06 00 36 	add	r6,r10,r6<<0x3
800085c2:	ec f9 fd 88 	ld.w	r9,r6[-632]
800085c6:	c1 78       	rjmp	800085f4 <_vfprintf_r+0xfd4>
800085c8:	41 09       	lddsp	r9,sp[0x40]
800085ca:	59 f8       	cp.w	r8,31
800085cc:	e0 89 00 10 	brgt	800085ec <_vfprintf_r+0xfcc>
800085d0:	f2 ca ff fc 	sub	r10,r9,-4
800085d4:	51 0a       	stdsp	sp[0x40],r10
800085d6:	fa c6 f9 44 	sub	r6,sp,-1724
800085da:	72 09       	ld.w	r9,r9[0x0]
800085dc:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800085e0:	f5 49 fd 88 	st.w	r10[-632],r9
800085e4:	2f f8       	sub	r8,-1
800085e6:	fb 48 06 b4 	st.w	sp[1716],r8
800085ea:	c0 58       	rjmp	800085f4 <_vfprintf_r+0xfd4>
800085ec:	f2 c8 ff fc 	sub	r8,r9,-4
800085f0:	51 08       	stdsp	sp[0x40],r8
800085f2:	72 09       	ld.w	r9,r9[0x0]
800085f4:	33 08       	mov	r8,48
800085f6:	fb 68 06 b8 	st.b	sp[1720],r8
800085fa:	37 88       	mov	r8,120
800085fc:	30 0e       	mov	lr,0
800085fe:	fb 68 06 b9 	st.b	sp[1721],r8
80008602:	fe cc ad e2 	sub	r12,pc,-21022
80008606:	50 19       	stdsp	sp[0x4],r9
80008608:	a1 b5       	sbr	r5,0x1
8000860a:	50 0e       	stdsp	sp[0x0],lr
8000860c:	50 dc       	stdsp	sp[0x34],r12
8000860e:	30 28       	mov	r8,2
80008610:	37 80       	mov	r0,120
80008612:	e0 8f 02 a3 	bral	80008b58 <_vfprintf_r+0x1538>
80008616:	50 a7       	stdsp	sp[0x28],r7
80008618:	50 80       	stdsp	sp[0x20],r0
8000861a:	10 90       	mov	r0,r8
8000861c:	30 08       	mov	r8,0
8000861e:	fb 68 06 bb 	st.b	sp[1723],r8
80008622:	0c 97       	mov	r7,r6
80008624:	04 94       	mov	r4,r2
80008626:	06 96       	mov	r6,r3
80008628:	02 92       	mov	r2,r1
8000862a:	40 93       	lddsp	r3,sp[0x24]
8000862c:	40 41       	lddsp	r1,sp[0x10]
8000862e:	0e 99       	mov	r9,r7
80008630:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008634:	40 3b       	lddsp	r11,sp[0xc]
80008636:	58 0b       	cp.w	r11,0
80008638:	c1 d0       	breq	80008672 <_vfprintf_r+0x1052>
8000863a:	10 36       	cp.w	r6,r8
8000863c:	c0 64       	brge	80008648 <_vfprintf_r+0x1028>
8000863e:	fa ca f9 44 	sub	r10,sp,-1724
80008642:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008646:	c1 d8       	rjmp	80008680 <_vfprintf_r+0x1060>
80008648:	fa c8 f9 50 	sub	r8,sp,-1712
8000864c:	1a d8       	st.w	--sp,r8
8000864e:	fa c8 fa b8 	sub	r8,sp,-1352
80008652:	1a d8       	st.w	--sp,r8
80008654:	fa c8 fb b4 	sub	r8,sp,-1100
80008658:	0c 9b       	mov	r11,r6
8000865a:	1a d8       	st.w	--sp,r8
8000865c:	04 9a       	mov	r10,r2
8000865e:	fa c8 f9 40 	sub	r8,sp,-1728
80008662:	fa c9 ff b4 	sub	r9,sp,-76
80008666:	08 9c       	mov	r12,r4
80008668:	fe b0 f6 44 	rcall	800072f0 <get_arg>
8000866c:	2f dd       	sub	sp,-12
8000866e:	78 06       	ld.w	r6,r12[0x0]
80008670:	c2 08       	rjmp	800086b0 <_vfprintf_r+0x1090>
80008672:	2f f7       	sub	r7,-1
80008674:	10 39       	cp.w	r9,r8
80008676:	c0 84       	brge	80008686 <_vfprintf_r+0x1066>
80008678:	fa c9 f9 44 	sub	r9,sp,-1724
8000867c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008680:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008684:	c1 68       	rjmp	800086b0 <_vfprintf_r+0x1090>
80008686:	41 09       	lddsp	r9,sp[0x40]
80008688:	59 f8       	cp.w	r8,31
8000868a:	e0 89 00 10 	brgt	800086aa <_vfprintf_r+0x108a>
8000868e:	f2 ca ff fc 	sub	r10,r9,-4
80008692:	51 0a       	stdsp	sp[0x40],r10
80008694:	72 06       	ld.w	r6,r9[0x0]
80008696:	fa ce f9 44 	sub	lr,sp,-1724
8000869a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000869e:	f3 46 fd 88 	st.w	r9[-632],r6
800086a2:	2f f8       	sub	r8,-1
800086a4:	fb 48 06 b4 	st.w	sp[1716],r8
800086a8:	c0 48       	rjmp	800086b0 <_vfprintf_r+0x1090>
800086aa:	72 06       	ld.w	r6,r9[0x0]
800086ac:	2f c9       	sub	r9,-4
800086ae:	51 09       	stdsp	sp[0x40],r9
800086b0:	40 2c       	lddsp	r12,sp[0x8]
800086b2:	58 0c       	cp.w	r12,0
800086b4:	c1 05       	brlt	800086d4 <_vfprintf_r+0x10b4>
800086b6:	18 9a       	mov	r10,r12
800086b8:	30 0b       	mov	r11,0
800086ba:	0c 9c       	mov	r12,r6
800086bc:	e0 a0 12 38 	rcall	8000ab2c <memchr>
800086c0:	e0 80 02 df 	breq	80008c7e <_vfprintf_r+0x165e>
800086c4:	f8 06 01 02 	sub	r2,r12,r6
800086c8:	40 2b       	lddsp	r11,sp[0x8]
800086ca:	16 32       	cp.w	r2,r11
800086cc:	e0 89 02 d9 	brgt	80008c7e <_vfprintf_r+0x165e>
800086d0:	e0 8f 02 d4 	bral	80008c78 <_vfprintf_r+0x1658>
800086d4:	30 0a       	mov	r10,0
800086d6:	0c 9c       	mov	r12,r6
800086d8:	50 2a       	stdsp	sp[0x8],r10
800086da:	fe b0 f5 85 	rcall	800071e4 <strlen>
800086de:	18 92       	mov	r2,r12
800086e0:	e0 8f 02 d2 	bral	80008c84 <_vfprintf_r+0x1664>
800086e4:	50 a7       	stdsp	sp[0x28],r7
800086e6:	50 80       	stdsp	sp[0x20],r0
800086e8:	0c 97       	mov	r7,r6
800086ea:	04 94       	mov	r4,r2
800086ec:	06 96       	mov	r6,r3
800086ee:	02 92       	mov	r2,r1
800086f0:	40 93       	lddsp	r3,sp[0x24]
800086f2:	10 90       	mov	r0,r8
800086f4:	40 41       	lddsp	r1,sp[0x10]
800086f6:	a5 a5       	sbr	r5,0x4
800086f8:	c0 a8       	rjmp	8000870c <_vfprintf_r+0x10ec>
800086fa:	50 a7       	stdsp	sp[0x28],r7
800086fc:	50 80       	stdsp	sp[0x20],r0
800086fe:	0c 97       	mov	r7,r6
80008700:	04 94       	mov	r4,r2
80008702:	06 96       	mov	r6,r3
80008704:	02 92       	mov	r2,r1
80008706:	40 93       	lddsp	r3,sp[0x24]
80008708:	10 90       	mov	r0,r8
8000870a:	40 41       	lddsp	r1,sp[0x10]
8000870c:	ed b5 00 05 	bld	r5,0x5
80008710:	c5 61       	brne	800087bc <_vfprintf_r+0x119c>
80008712:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008716:	40 39       	lddsp	r9,sp[0xc]
80008718:	58 09       	cp.w	r9,0
8000871a:	c2 10       	breq	8000875c <_vfprintf_r+0x113c>
8000871c:	10 36       	cp.w	r6,r8
8000871e:	c0 74       	brge	8000872c <_vfprintf_r+0x110c>
80008720:	fa c8 f9 44 	sub	r8,sp,-1724
80008724:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008728:	c2 38       	rjmp	8000876e <_vfprintf_r+0x114e>
8000872a:	d7 03       	nop
8000872c:	fa c8 f9 50 	sub	r8,sp,-1712
80008730:	1a d8       	st.w	--sp,r8
80008732:	fa c8 fa b8 	sub	r8,sp,-1352
80008736:	1a d8       	st.w	--sp,r8
80008738:	fa c8 fb b4 	sub	r8,sp,-1100
8000873c:	1a d8       	st.w	--sp,r8
8000873e:	fa c8 f9 40 	sub	r8,sp,-1728
80008742:	fa c9 ff b4 	sub	r9,sp,-76
80008746:	04 9a       	mov	r10,r2
80008748:	0c 9b       	mov	r11,r6
8000874a:	08 9c       	mov	r12,r4
8000874c:	fe b0 f5 d2 	rcall	800072f0 <get_arg>
80008750:	2f dd       	sub	sp,-12
80008752:	f8 e8 00 00 	ld.d	r8,r12[0]
80008756:	fa e9 00 00 	st.d	sp[0],r8
8000875a:	c2 e8       	rjmp	800087b6 <_vfprintf_r+0x1196>
8000875c:	ee ca ff ff 	sub	r10,r7,-1
80008760:	10 37       	cp.w	r7,r8
80008762:	c0 b4       	brge	80008778 <_vfprintf_r+0x1158>
80008764:	fa c8 f9 44 	sub	r8,sp,-1724
80008768:	14 97       	mov	r7,r10
8000876a:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000876e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008772:	fa eb 00 00 	st.d	sp[0],r10
80008776:	c2 08       	rjmp	800087b6 <_vfprintf_r+0x1196>
80008778:	41 09       	lddsp	r9,sp[0x40]
8000877a:	59 f8       	cp.w	r8,31
8000877c:	e0 89 00 16 	brgt	800087a8 <_vfprintf_r+0x1188>
80008780:	f2 e6 00 00 	ld.d	r6,r9[0]
80008784:	f2 cb ff f8 	sub	r11,r9,-8
80008788:	fa e7 00 00 	st.d	sp[0],r6
8000878c:	51 0b       	stdsp	sp[0x40],r11
8000878e:	fa c6 f9 44 	sub	r6,sp,-1724
80008792:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008796:	fa e6 00 00 	ld.d	r6,sp[0]
8000879a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000879e:	2f f8       	sub	r8,-1
800087a0:	14 97       	mov	r7,r10
800087a2:	fb 48 06 b4 	st.w	sp[1716],r8
800087a6:	c0 88       	rjmp	800087b6 <_vfprintf_r+0x1196>
800087a8:	f2 e6 00 00 	ld.d	r6,r9[0]
800087ac:	2f 89       	sub	r9,-8
800087ae:	fa e7 00 00 	st.d	sp[0],r6
800087b2:	51 09       	stdsp	sp[0x40],r9
800087b4:	14 97       	mov	r7,r10
800087b6:	30 18       	mov	r8,1
800087b8:	e0 8f 01 d0 	bral	80008b58 <_vfprintf_r+0x1538>
800087bc:	ed b5 00 04 	bld	r5,0x4
800087c0:	c1 61       	brne	800087ec <_vfprintf_r+0x11cc>
800087c2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800087c6:	40 3e       	lddsp	lr,sp[0xc]
800087c8:	58 0e       	cp.w	lr,0
800087ca:	c0 80       	breq	800087da <_vfprintf_r+0x11ba>
800087cc:	10 36       	cp.w	r6,r8
800087ce:	c6 74       	brge	8000889c <_vfprintf_r+0x127c>
800087d0:	fa cc f9 44 	sub	r12,sp,-1724
800087d4:	f8 06 00 36 	add	r6,r12,r6<<0x3
800087d8:	c8 08       	rjmp	800088d8 <_vfprintf_r+0x12b8>
800087da:	ee ca ff ff 	sub	r10,r7,-1
800087de:	10 37       	cp.w	r7,r8
800087e0:	c7 f4       	brge	800088de <_vfprintf_r+0x12be>
800087e2:	fa cb f9 44 	sub	r11,sp,-1724
800087e6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800087ea:	c7 68       	rjmp	800088d6 <_vfprintf_r+0x12b6>
800087ec:	ed b5 00 06 	bld	r5,0x6
800087f0:	c4 a1       	brne	80008884 <_vfprintf_r+0x1264>
800087f2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800087f6:	40 3c       	lddsp	r12,sp[0xc]
800087f8:	58 0c       	cp.w	r12,0
800087fa:	c1 d0       	breq	80008834 <_vfprintf_r+0x1214>
800087fc:	10 36       	cp.w	r6,r8
800087fe:	c0 64       	brge	8000880a <_vfprintf_r+0x11ea>
80008800:	fa cb f9 44 	sub	r11,sp,-1724
80008804:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008808:	c1 f8       	rjmp	80008846 <_vfprintf_r+0x1226>
8000880a:	fa c8 f9 50 	sub	r8,sp,-1712
8000880e:	1a d8       	st.w	--sp,r8
80008810:	fa c8 fa b8 	sub	r8,sp,-1352
80008814:	1a d8       	st.w	--sp,r8
80008816:	fa c8 fb b4 	sub	r8,sp,-1100
8000881a:	1a d8       	st.w	--sp,r8
8000881c:	fa c8 f9 40 	sub	r8,sp,-1728
80008820:	fa c9 ff b4 	sub	r9,sp,-76
80008824:	04 9a       	mov	r10,r2
80008826:	0c 9b       	mov	r11,r6
80008828:	08 9c       	mov	r12,r4
8000882a:	fe b0 f5 63 	rcall	800072f0 <get_arg>
8000882e:	2f dd       	sub	sp,-12
80008830:	98 18       	ld.sh	r8,r12[0x2]
80008832:	c2 68       	rjmp	8000887e <_vfprintf_r+0x125e>
80008834:	ee ca ff ff 	sub	r10,r7,-1
80008838:	10 37       	cp.w	r7,r8
8000883a:	c0 94       	brge	8000884c <_vfprintf_r+0x122c>
8000883c:	fa c9 f9 44 	sub	r9,sp,-1724
80008840:	14 97       	mov	r7,r10
80008842:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008846:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000884a:	c1 a8       	rjmp	8000887e <_vfprintf_r+0x125e>
8000884c:	41 09       	lddsp	r9,sp[0x40]
8000884e:	59 f8       	cp.w	r8,31
80008850:	e0 89 00 13 	brgt	80008876 <_vfprintf_r+0x1256>
80008854:	f2 cb ff fc 	sub	r11,r9,-4
80008858:	51 0b       	stdsp	sp[0x40],r11
8000885a:	72 09       	ld.w	r9,r9[0x0]
8000885c:	fa c6 f9 44 	sub	r6,sp,-1724
80008860:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008864:	2f f8       	sub	r8,-1
80008866:	f7 49 fd 88 	st.w	r11[-632],r9
8000886a:	fb 48 06 b4 	st.w	sp[1716],r8
8000886e:	14 97       	mov	r7,r10
80008870:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008874:	c0 58       	rjmp	8000887e <_vfprintf_r+0x125e>
80008876:	92 18       	ld.sh	r8,r9[0x2]
80008878:	14 97       	mov	r7,r10
8000887a:	2f c9       	sub	r9,-4
8000887c:	51 09       	stdsp	sp[0x40],r9
8000887e:	5c 78       	castu.h	r8
80008880:	50 18       	stdsp	sp[0x4],r8
80008882:	c4 68       	rjmp	8000890e <_vfprintf_r+0x12ee>
80008884:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008888:	40 3c       	lddsp	r12,sp[0xc]
8000888a:	58 0c       	cp.w	r12,0
8000888c:	c1 d0       	breq	800088c6 <_vfprintf_r+0x12a6>
8000888e:	10 36       	cp.w	r6,r8
80008890:	c0 64       	brge	8000889c <_vfprintf_r+0x127c>
80008892:	fa cb f9 44 	sub	r11,sp,-1724
80008896:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000889a:	c1 f8       	rjmp	800088d8 <_vfprintf_r+0x12b8>
8000889c:	fa c8 f9 50 	sub	r8,sp,-1712
800088a0:	1a d8       	st.w	--sp,r8
800088a2:	fa c8 fa b8 	sub	r8,sp,-1352
800088a6:	0c 9b       	mov	r11,r6
800088a8:	1a d8       	st.w	--sp,r8
800088aa:	fa c8 fb b4 	sub	r8,sp,-1100
800088ae:	04 9a       	mov	r10,r2
800088b0:	1a d8       	st.w	--sp,r8
800088b2:	08 9c       	mov	r12,r4
800088b4:	fa c8 f9 40 	sub	r8,sp,-1728
800088b8:	fa c9 ff b4 	sub	r9,sp,-76
800088bc:	fe b0 f5 1a 	rcall	800072f0 <get_arg>
800088c0:	2f dd       	sub	sp,-12
800088c2:	78 0b       	ld.w	r11,r12[0x0]
800088c4:	c2 48       	rjmp	8000890c <_vfprintf_r+0x12ec>
800088c6:	ee ca ff ff 	sub	r10,r7,-1
800088ca:	10 37       	cp.w	r7,r8
800088cc:	c0 94       	brge	800088de <_vfprintf_r+0x12be>
800088ce:	fa c9 f9 44 	sub	r9,sp,-1724
800088d2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800088d6:	14 97       	mov	r7,r10
800088d8:	ec fb fd 88 	ld.w	r11,r6[-632]
800088dc:	c1 88       	rjmp	8000890c <_vfprintf_r+0x12ec>
800088de:	41 09       	lddsp	r9,sp[0x40]
800088e0:	59 f8       	cp.w	r8,31
800088e2:	e0 89 00 11 	brgt	80008904 <_vfprintf_r+0x12e4>
800088e6:	f2 cb ff fc 	sub	r11,r9,-4
800088ea:	51 0b       	stdsp	sp[0x40],r11
800088ec:	fa c6 f9 44 	sub	r6,sp,-1724
800088f0:	72 0b       	ld.w	r11,r9[0x0]
800088f2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800088f6:	f3 4b fd 88 	st.w	r9[-632],r11
800088fa:	2f f8       	sub	r8,-1
800088fc:	14 97       	mov	r7,r10
800088fe:	fb 48 06 b4 	st.w	sp[1716],r8
80008902:	c0 58       	rjmp	8000890c <_vfprintf_r+0x12ec>
80008904:	72 0b       	ld.w	r11,r9[0x0]
80008906:	14 97       	mov	r7,r10
80008908:	2f c9       	sub	r9,-4
8000890a:	51 09       	stdsp	sp[0x40],r9
8000890c:	50 1b       	stdsp	sp[0x4],r11
8000890e:	30 0e       	mov	lr,0
80008910:	30 18       	mov	r8,1
80008912:	50 0e       	stdsp	sp[0x0],lr
80008914:	c2 29       	rjmp	80008b58 <_vfprintf_r+0x1538>
80008916:	50 a7       	stdsp	sp[0x28],r7
80008918:	50 80       	stdsp	sp[0x20],r0
8000891a:	0c 97       	mov	r7,r6
8000891c:	04 94       	mov	r4,r2
8000891e:	06 96       	mov	r6,r3
80008920:	02 92       	mov	r2,r1
80008922:	fe cc b1 02 	sub	r12,pc,-20222
80008926:	40 93       	lddsp	r3,sp[0x24]
80008928:	10 90       	mov	r0,r8
8000892a:	40 41       	lddsp	r1,sp[0x10]
8000892c:	50 dc       	stdsp	sp[0x34],r12
8000892e:	ed b5 00 05 	bld	r5,0x5
80008932:	c5 51       	brne	800089dc <_vfprintf_r+0x13bc>
80008934:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008938:	40 3b       	lddsp	r11,sp[0xc]
8000893a:	58 0b       	cp.w	r11,0
8000893c:	c2 20       	breq	80008980 <_vfprintf_r+0x1360>
8000893e:	10 36       	cp.w	r6,r8
80008940:	c0 a4       	brge	80008954 <_vfprintf_r+0x1334>
80008942:	fa ca f9 44 	sub	r10,sp,-1724
80008946:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000894a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000894e:	fa e9 00 00 	st.d	sp[0],r8
80008952:	cf 28       	rjmp	80008b36 <_vfprintf_r+0x1516>
80008954:	fa c8 f9 50 	sub	r8,sp,-1712
80008958:	1a d8       	st.w	--sp,r8
8000895a:	fa c8 fa b8 	sub	r8,sp,-1352
8000895e:	04 9a       	mov	r10,r2
80008960:	1a d8       	st.w	--sp,r8
80008962:	0c 9b       	mov	r11,r6
80008964:	fa c8 fb b4 	sub	r8,sp,-1100
80008968:	08 9c       	mov	r12,r4
8000896a:	1a d8       	st.w	--sp,r8
8000896c:	fa c8 f9 40 	sub	r8,sp,-1728
80008970:	fa c9 ff b4 	sub	r9,sp,-76
80008974:	fe b0 f4 be 	rcall	800072f0 <get_arg>
80008978:	2f dd       	sub	sp,-12
8000897a:	f8 ea 00 00 	ld.d	r10,r12[0]
8000897e:	c0 c8       	rjmp	80008996 <_vfprintf_r+0x1376>
80008980:	ee ca ff ff 	sub	r10,r7,-1
80008984:	10 37       	cp.w	r7,r8
80008986:	c0 b4       	brge	8000899c <_vfprintf_r+0x137c>
80008988:	fa c9 f9 44 	sub	r9,sp,-1724
8000898c:	14 97       	mov	r7,r10
8000898e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008992:	ec ea fd 88 	ld.d	r10,r6[-632]
80008996:	fa eb 00 00 	st.d	sp[0],r10
8000899a:	cc e8       	rjmp	80008b36 <_vfprintf_r+0x1516>
8000899c:	41 09       	lddsp	r9,sp[0x40]
8000899e:	59 f8       	cp.w	r8,31
800089a0:	e0 89 00 16 	brgt	800089cc <_vfprintf_r+0x13ac>
800089a4:	f2 e6 00 00 	ld.d	r6,r9[0]
800089a8:	f2 cb ff f8 	sub	r11,r9,-8
800089ac:	fa e7 00 00 	st.d	sp[0],r6
800089b0:	51 0b       	stdsp	sp[0x40],r11
800089b2:	fa c6 f9 44 	sub	r6,sp,-1724
800089b6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800089ba:	fa e6 00 00 	ld.d	r6,sp[0]
800089be:	f2 e7 fd 88 	st.d	r9[-632],r6
800089c2:	2f f8       	sub	r8,-1
800089c4:	14 97       	mov	r7,r10
800089c6:	fb 48 06 b4 	st.w	sp[1716],r8
800089ca:	cb 68       	rjmp	80008b36 <_vfprintf_r+0x1516>
800089cc:	f2 e6 00 00 	ld.d	r6,r9[0]
800089d0:	2f 89       	sub	r9,-8
800089d2:	fa e7 00 00 	st.d	sp[0],r6
800089d6:	51 09       	stdsp	sp[0x40],r9
800089d8:	14 97       	mov	r7,r10
800089da:	ca e8       	rjmp	80008b36 <_vfprintf_r+0x1516>
800089dc:	ed b5 00 04 	bld	r5,0x4
800089e0:	c1 71       	brne	80008a0e <_vfprintf_r+0x13ee>
800089e2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089e6:	40 3e       	lddsp	lr,sp[0xc]
800089e8:	58 0e       	cp.w	lr,0
800089ea:	c0 80       	breq	800089fa <_vfprintf_r+0x13da>
800089ec:	10 36       	cp.w	r6,r8
800089ee:	c6 94       	brge	80008ac0 <_vfprintf_r+0x14a0>
800089f0:	fa cc f9 44 	sub	r12,sp,-1724
800089f4:	f8 06 00 36 	add	r6,r12,r6<<0x3
800089f8:	c8 28       	rjmp	80008afc <_vfprintf_r+0x14dc>
800089fa:	ee ca ff ff 	sub	r10,r7,-1
800089fe:	10 37       	cp.w	r7,r8
80008a00:	e0 84 00 81 	brge	80008b02 <_vfprintf_r+0x14e2>
80008a04:	fa cb f9 44 	sub	r11,sp,-1724
80008a08:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a0c:	c7 78       	rjmp	80008afa <_vfprintf_r+0x14da>
80008a0e:	ed b5 00 06 	bld	r5,0x6
80008a12:	c4 b1       	brne	80008aa8 <_vfprintf_r+0x1488>
80008a14:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a18:	40 3c       	lddsp	r12,sp[0xc]
80008a1a:	58 0c       	cp.w	r12,0
80008a1c:	c1 d0       	breq	80008a56 <_vfprintf_r+0x1436>
80008a1e:	10 36       	cp.w	r6,r8
80008a20:	c0 64       	brge	80008a2c <_vfprintf_r+0x140c>
80008a22:	fa cb f9 44 	sub	r11,sp,-1724
80008a26:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a2a:	c1 f8       	rjmp	80008a68 <_vfprintf_r+0x1448>
80008a2c:	fa c8 f9 50 	sub	r8,sp,-1712
80008a30:	1a d8       	st.w	--sp,r8
80008a32:	fa c8 fa b8 	sub	r8,sp,-1352
80008a36:	1a d8       	st.w	--sp,r8
80008a38:	fa c8 fb b4 	sub	r8,sp,-1100
80008a3c:	1a d8       	st.w	--sp,r8
80008a3e:	fa c8 f9 40 	sub	r8,sp,-1728
80008a42:	fa c9 ff b4 	sub	r9,sp,-76
80008a46:	04 9a       	mov	r10,r2
80008a48:	0c 9b       	mov	r11,r6
80008a4a:	08 9c       	mov	r12,r4
80008a4c:	fe b0 f4 52 	rcall	800072f0 <get_arg>
80008a50:	2f dd       	sub	sp,-12
80008a52:	98 18       	ld.sh	r8,r12[0x2]
80008a54:	c2 78       	rjmp	80008aa2 <_vfprintf_r+0x1482>
80008a56:	ee ca ff ff 	sub	r10,r7,-1
80008a5a:	10 37       	cp.w	r7,r8
80008a5c:	c0 a4       	brge	80008a70 <_vfprintf_r+0x1450>
80008a5e:	fa c9 f9 44 	sub	r9,sp,-1724
80008a62:	14 97       	mov	r7,r10
80008a64:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008a68:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008a6c:	c1 b8       	rjmp	80008aa2 <_vfprintf_r+0x1482>
80008a6e:	d7 03       	nop
80008a70:	41 09       	lddsp	r9,sp[0x40]
80008a72:	59 f8       	cp.w	r8,31
80008a74:	e0 89 00 13 	brgt	80008a9a <_vfprintf_r+0x147a>
80008a78:	f2 cb ff fc 	sub	r11,r9,-4
80008a7c:	51 0b       	stdsp	sp[0x40],r11
80008a7e:	72 09       	ld.w	r9,r9[0x0]
80008a80:	fa c6 f9 44 	sub	r6,sp,-1724
80008a84:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008a88:	2f f8       	sub	r8,-1
80008a8a:	f7 49 fd 88 	st.w	r11[-632],r9
80008a8e:	fb 48 06 b4 	st.w	sp[1716],r8
80008a92:	14 97       	mov	r7,r10
80008a94:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008a98:	c0 58       	rjmp	80008aa2 <_vfprintf_r+0x1482>
80008a9a:	92 18       	ld.sh	r8,r9[0x2]
80008a9c:	14 97       	mov	r7,r10
80008a9e:	2f c9       	sub	r9,-4
80008aa0:	51 09       	stdsp	sp[0x40],r9
80008aa2:	5c 78       	castu.h	r8
80008aa4:	50 18       	stdsp	sp[0x4],r8
80008aa6:	c4 68       	rjmp	80008b32 <_vfprintf_r+0x1512>
80008aa8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008aac:	40 3c       	lddsp	r12,sp[0xc]
80008aae:	58 0c       	cp.w	r12,0
80008ab0:	c1 d0       	breq	80008aea <_vfprintf_r+0x14ca>
80008ab2:	10 36       	cp.w	r6,r8
80008ab4:	c0 64       	brge	80008ac0 <_vfprintf_r+0x14a0>
80008ab6:	fa cb f9 44 	sub	r11,sp,-1724
80008aba:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008abe:	c1 f8       	rjmp	80008afc <_vfprintf_r+0x14dc>
80008ac0:	fa c8 f9 50 	sub	r8,sp,-1712
80008ac4:	1a d8       	st.w	--sp,r8
80008ac6:	fa c8 fa b8 	sub	r8,sp,-1352
80008aca:	0c 9b       	mov	r11,r6
80008acc:	1a d8       	st.w	--sp,r8
80008ace:	fa c8 fb b4 	sub	r8,sp,-1100
80008ad2:	04 9a       	mov	r10,r2
80008ad4:	1a d8       	st.w	--sp,r8
80008ad6:	08 9c       	mov	r12,r4
80008ad8:	fa c8 f9 40 	sub	r8,sp,-1728
80008adc:	fa c9 ff b4 	sub	r9,sp,-76
80008ae0:	fe b0 f4 08 	rcall	800072f0 <get_arg>
80008ae4:	2f dd       	sub	sp,-12
80008ae6:	78 0b       	ld.w	r11,r12[0x0]
80008ae8:	c2 48       	rjmp	80008b30 <_vfprintf_r+0x1510>
80008aea:	ee ca ff ff 	sub	r10,r7,-1
80008aee:	10 37       	cp.w	r7,r8
80008af0:	c0 94       	brge	80008b02 <_vfprintf_r+0x14e2>
80008af2:	fa c9 f9 44 	sub	r9,sp,-1724
80008af6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008afa:	14 97       	mov	r7,r10
80008afc:	ec fb fd 88 	ld.w	r11,r6[-632]
80008b00:	c1 88       	rjmp	80008b30 <_vfprintf_r+0x1510>
80008b02:	41 09       	lddsp	r9,sp[0x40]
80008b04:	59 f8       	cp.w	r8,31
80008b06:	e0 89 00 11 	brgt	80008b28 <_vfprintf_r+0x1508>
80008b0a:	f2 cb ff fc 	sub	r11,r9,-4
80008b0e:	51 0b       	stdsp	sp[0x40],r11
80008b10:	fa c6 f9 44 	sub	r6,sp,-1724
80008b14:	72 0b       	ld.w	r11,r9[0x0]
80008b16:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008b1a:	f3 4b fd 88 	st.w	r9[-632],r11
80008b1e:	2f f8       	sub	r8,-1
80008b20:	14 97       	mov	r7,r10
80008b22:	fb 48 06 b4 	st.w	sp[1716],r8
80008b26:	c0 58       	rjmp	80008b30 <_vfprintf_r+0x1510>
80008b28:	72 0b       	ld.w	r11,r9[0x0]
80008b2a:	14 97       	mov	r7,r10
80008b2c:	2f c9       	sub	r9,-4
80008b2e:	51 09       	stdsp	sp[0x40],r9
80008b30:	50 1b       	stdsp	sp[0x4],r11
80008b32:	30 0e       	mov	lr,0
80008b34:	50 0e       	stdsp	sp[0x0],lr
80008b36:	40 08       	lddsp	r8,sp[0x0]
80008b38:	40 1c       	lddsp	r12,sp[0x4]
80008b3a:	18 48       	or	r8,r12
80008b3c:	5f 19       	srne	r9
80008b3e:	0a 98       	mov	r8,r5
80008b40:	eb e9 00 09 	and	r9,r5,r9
80008b44:	a1 b8       	sbr	r8,0x1
80008b46:	58 09       	cp.w	r9,0
80008b48:	c0 70       	breq	80008b56 <_vfprintf_r+0x1536>
80008b4a:	10 95       	mov	r5,r8
80008b4c:	fb 60 06 b9 	st.b	sp[1721],r0
80008b50:	33 08       	mov	r8,48
80008b52:	fb 68 06 b8 	st.b	sp[1720],r8
80008b56:	30 28       	mov	r8,2
80008b58:	30 09       	mov	r9,0
80008b5a:	fb 69 06 bb 	st.b	sp[1723],r9
80008b5e:	0a 99       	mov	r9,r5
80008b60:	a7 d9       	cbr	r9,0x7
80008b62:	40 2b       	lddsp	r11,sp[0x8]
80008b64:	40 16       	lddsp	r6,sp[0x4]
80008b66:	58 0b       	cp.w	r11,0
80008b68:	5f 1a       	srne	r10
80008b6a:	f2 05 17 40 	movge	r5,r9
80008b6e:	fa c2 f9 78 	sub	r2,sp,-1672
80008b72:	40 09       	lddsp	r9,sp[0x0]
80008b74:	0c 49       	or	r9,r6
80008b76:	5f 19       	srne	r9
80008b78:	f5 e9 10 09 	or	r9,r10,r9
80008b7c:	c5 c0       	breq	80008c34 <_vfprintf_r+0x1614>
80008b7e:	30 19       	mov	r9,1
80008b80:	f2 08 18 00 	cp.b	r8,r9
80008b84:	c0 60       	breq	80008b90 <_vfprintf_r+0x1570>
80008b86:	30 29       	mov	r9,2
80008b88:	f2 08 18 00 	cp.b	r8,r9
80008b8c:	c0 41       	brne	80008b94 <_vfprintf_r+0x1574>
80008b8e:	c3 c8       	rjmp	80008c06 <_vfprintf_r+0x15e6>
80008b90:	04 96       	mov	r6,r2
80008b92:	c3 08       	rjmp	80008bf2 <_vfprintf_r+0x15d2>
80008b94:	04 96       	mov	r6,r2
80008b96:	fa e8 00 00 	ld.d	r8,sp[0]
80008b9a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80008b9e:	2d 0a       	sub	r10,-48
80008ba0:	0c fa       	st.b	--r6,r10
80008ba2:	f0 0b 16 03 	lsr	r11,r8,0x3
80008ba6:	f2 0c 16 03 	lsr	r12,r9,0x3
80008baa:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80008bae:	18 99       	mov	r9,r12
80008bb0:	16 98       	mov	r8,r11
80008bb2:	58 08       	cp.w	r8,0
80008bb4:	5c 29       	cpc	r9
80008bb6:	cf 21       	brne	80008b9a <_vfprintf_r+0x157a>
80008bb8:	fa e9 00 00 	st.d	sp[0],r8
80008bbc:	ed b5 00 00 	bld	r5,0x0
80008bc0:	c4 51       	brne	80008c4a <_vfprintf_r+0x162a>
80008bc2:	33 09       	mov	r9,48
80008bc4:	f2 0a 18 00 	cp.b	r10,r9
80008bc8:	c4 10       	breq	80008c4a <_vfprintf_r+0x162a>
80008bca:	0c f9       	st.b	--r6,r9
80008bcc:	c3 f8       	rjmp	80008c4a <_vfprintf_r+0x162a>
80008bce:	fa ea 00 00 	ld.d	r10,sp[0]
80008bd2:	30 a8       	mov	r8,10
80008bd4:	30 09       	mov	r9,0
80008bd6:	e0 a0 1a 0d 	rcall	8000bff0 <__avr32_umod64>
80008bda:	30 a8       	mov	r8,10
80008bdc:	2d 0a       	sub	r10,-48
80008bde:	30 09       	mov	r9,0
80008be0:	ac 8a       	st.b	r6[0x0],r10
80008be2:	fa ea 00 00 	ld.d	r10,sp[0]
80008be6:	e0 a0 18 d3 	rcall	8000bd8c <__avr32_udiv64>
80008bea:	16 99       	mov	r9,r11
80008bec:	14 98       	mov	r8,r10
80008bee:	fa e9 00 00 	st.d	sp[0],r8
80008bf2:	20 16       	sub	r6,1
80008bf4:	fa ea 00 00 	ld.d	r10,sp[0]
80008bf8:	58 9a       	cp.w	r10,9
80008bfa:	5c 2b       	cpc	r11
80008bfc:	fe 9b ff e9 	brhi	80008bce <_vfprintf_r+0x15ae>
80008c00:	1b f8       	ld.ub	r8,sp[0x7]
80008c02:	2d 08       	sub	r8,-48
80008c04:	c2 08       	rjmp	80008c44 <_vfprintf_r+0x1624>
80008c06:	04 96       	mov	r6,r2
80008c08:	fa e8 00 00 	ld.d	r8,sp[0]
80008c0c:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80008c10:	40 de       	lddsp	lr,sp[0x34]
80008c12:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80008c16:	0c fa       	st.b	--r6,r10
80008c18:	f2 0b 16 04 	lsr	r11,r9,0x4
80008c1c:	f0 0a 16 04 	lsr	r10,r8,0x4
80008c20:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80008c24:	16 99       	mov	r9,r11
80008c26:	14 98       	mov	r8,r10
80008c28:	58 08       	cp.w	r8,0
80008c2a:	5c 29       	cpc	r9
80008c2c:	cf 01       	brne	80008c0c <_vfprintf_r+0x15ec>
80008c2e:	fa e9 00 00 	st.d	sp[0],r8
80008c32:	c0 c8       	rjmp	80008c4a <_vfprintf_r+0x162a>
80008c34:	58 08       	cp.w	r8,0
80008c36:	c0 91       	brne	80008c48 <_vfprintf_r+0x1628>
80008c38:	ed b5 00 00 	bld	r5,0x0
80008c3c:	c0 61       	brne	80008c48 <_vfprintf_r+0x1628>
80008c3e:	fa c6 f9 79 	sub	r6,sp,-1671
80008c42:	33 08       	mov	r8,48
80008c44:	ac 88       	st.b	r6[0x0],r8
80008c46:	c0 28       	rjmp	80008c4a <_vfprintf_r+0x162a>
80008c48:	04 96       	mov	r6,r2
80008c4a:	0c 12       	sub	r2,r6
80008c4c:	c1 c8       	rjmp	80008c84 <_vfprintf_r+0x1664>
80008c4e:	50 a7       	stdsp	sp[0x28],r7
80008c50:	50 80       	stdsp	sp[0x20],r0
80008c52:	40 93       	lddsp	r3,sp[0x24]
80008c54:	0c 97       	mov	r7,r6
80008c56:	10 90       	mov	r0,r8
80008c58:	04 94       	mov	r4,r2
80008c5a:	40 41       	lddsp	r1,sp[0x10]
80008c5c:	58 08       	cp.w	r8,0
80008c5e:	e0 80 04 4f 	breq	800094fc <_vfprintf_r+0x1edc>
80008c62:	fb 68 06 60 	st.b	sp[1632],r8
80008c66:	30 0c       	mov	r12,0
80008c68:	30 08       	mov	r8,0
80008c6a:	30 12       	mov	r2,1
80008c6c:	fb 68 06 bb 	st.b	sp[1723],r8
80008c70:	50 2c       	stdsp	sp[0x8],r12
80008c72:	fa c6 f9 a0 	sub	r6,sp,-1632
80008c76:	c0 78       	rjmp	80008c84 <_vfprintf_r+0x1664>
80008c78:	30 0b       	mov	r11,0
80008c7a:	50 2b       	stdsp	sp[0x8],r11
80008c7c:	c0 48       	rjmp	80008c84 <_vfprintf_r+0x1664>
80008c7e:	40 22       	lddsp	r2,sp[0x8]
80008c80:	30 0a       	mov	r10,0
80008c82:	50 2a       	stdsp	sp[0x8],r10
80008c84:	40 29       	lddsp	r9,sp[0x8]
80008c86:	e4 09 0c 49 	max	r9,r2,r9
80008c8a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008c8e:	50 39       	stdsp	sp[0xc],r9
80008c90:	0a 9e       	mov	lr,r5
80008c92:	30 09       	mov	r9,0
80008c94:	e2 1e 00 02 	andl	lr,0x2,COH
80008c98:	f2 08 18 00 	cp.b	r8,r9
80008c9c:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80008ca0:	f7 b8 01 ff 	subne	r8,-1
80008ca4:	fb f8 1a 03 	st.wne	sp[0xc],r8
80008ca8:	0a 9b       	mov	r11,r5
80008caa:	58 0e       	cp.w	lr,0
80008cac:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80008cb0:	f7 bc 01 fe 	subne	r12,-2
80008cb4:	fb fc 1a 03 	st.wne	sp[0xc],r12
80008cb8:	e2 1b 00 84 	andl	r11,0x84,COH
80008cbc:	50 fe       	stdsp	sp[0x3c],lr
80008cbe:	50 9b       	stdsp	sp[0x24],r11
80008cc0:	c4 71       	brne	80008d4e <_vfprintf_r+0x172e>
80008cc2:	40 8a       	lddsp	r10,sp[0x20]
80008cc4:	40 39       	lddsp	r9,sp[0xc]
80008cc6:	12 1a       	sub	r10,r9
80008cc8:	50 4a       	stdsp	sp[0x10],r10
80008cca:	58 0a       	cp.w	r10,0
80008ccc:	e0 89 00 20 	brgt	80008d0c <_vfprintf_r+0x16ec>
80008cd0:	c3 f8       	rjmp	80008d4e <_vfprintf_r+0x172e>
80008cd2:	2f 09       	sub	r9,-16
80008cd4:	2f f8       	sub	r8,-1
80008cd6:	fe ce b4 9e 	sub	lr,pc,-19298
80008cda:	31 0c       	mov	r12,16
80008cdc:	fb 49 06 90 	st.w	sp[1680],r9
80008ce0:	87 0e       	st.w	r3[0x0],lr
80008ce2:	87 1c       	st.w	r3[0x4],r12
80008ce4:	fb 48 06 8c 	st.w	sp[1676],r8
80008ce8:	58 78       	cp.w	r8,7
80008cea:	e0 89 00 04 	brgt	80008cf2 <_vfprintf_r+0x16d2>
80008cee:	2f 83       	sub	r3,-8
80008cf0:	c0 b8       	rjmp	80008d06 <_vfprintf_r+0x16e6>
80008cf2:	fa ca f9 78 	sub	r10,sp,-1672
80008cf6:	02 9b       	mov	r11,r1
80008cf8:	08 9c       	mov	r12,r4
80008cfa:	fe b0 f4 85 	rcall	80007604 <__sprint_r>
80008cfe:	e0 81 04 10 	brne	8000951e <_vfprintf_r+0x1efe>
80008d02:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d06:	40 4b       	lddsp	r11,sp[0x10]
80008d08:	21 0b       	sub	r11,16
80008d0a:	50 4b       	stdsp	sp[0x10],r11
80008d0c:	fa f9 06 90 	ld.w	r9,sp[1680]
80008d10:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d14:	fe ca b4 dc 	sub	r10,pc,-19236
80008d18:	40 4e       	lddsp	lr,sp[0x10]
80008d1a:	59 0e       	cp.w	lr,16
80008d1c:	fe 99 ff db 	brgt	80008cd2 <_vfprintf_r+0x16b2>
80008d20:	1c 09       	add	r9,lr
80008d22:	2f f8       	sub	r8,-1
80008d24:	87 0a       	st.w	r3[0x0],r10
80008d26:	fb 49 06 90 	st.w	sp[1680],r9
80008d2a:	87 1e       	st.w	r3[0x4],lr
80008d2c:	fb 48 06 8c 	st.w	sp[1676],r8
80008d30:	58 78       	cp.w	r8,7
80008d32:	e0 89 00 04 	brgt	80008d3a <_vfprintf_r+0x171a>
80008d36:	2f 83       	sub	r3,-8
80008d38:	c0 b8       	rjmp	80008d4e <_vfprintf_r+0x172e>
80008d3a:	fa ca f9 78 	sub	r10,sp,-1672
80008d3e:	02 9b       	mov	r11,r1
80008d40:	08 9c       	mov	r12,r4
80008d42:	fe b0 f4 61 	rcall	80007604 <__sprint_r>
80008d46:	e0 81 03 ec 	brne	8000951e <_vfprintf_r+0x1efe>
80008d4a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d4e:	30 09       	mov	r9,0
80008d50:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008d54:	f2 08 18 00 	cp.b	r8,r9
80008d58:	c1 f0       	breq	80008d96 <_vfprintf_r+0x1776>
80008d5a:	fa f8 06 90 	ld.w	r8,sp[1680]
80008d5e:	fa c9 f9 45 	sub	r9,sp,-1723
80008d62:	2f f8       	sub	r8,-1
80008d64:	87 09       	st.w	r3[0x0],r9
80008d66:	fb 48 06 90 	st.w	sp[1680],r8
80008d6a:	30 19       	mov	r9,1
80008d6c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d70:	87 19       	st.w	r3[0x4],r9
80008d72:	2f f8       	sub	r8,-1
80008d74:	fb 48 06 8c 	st.w	sp[1676],r8
80008d78:	58 78       	cp.w	r8,7
80008d7a:	e0 89 00 04 	brgt	80008d82 <_vfprintf_r+0x1762>
80008d7e:	2f 83       	sub	r3,-8
80008d80:	c0 b8       	rjmp	80008d96 <_vfprintf_r+0x1776>
80008d82:	fa ca f9 78 	sub	r10,sp,-1672
80008d86:	02 9b       	mov	r11,r1
80008d88:	08 9c       	mov	r12,r4
80008d8a:	fe b0 f4 3d 	rcall	80007604 <__sprint_r>
80008d8e:	e0 81 03 c8 	brne	8000951e <_vfprintf_r+0x1efe>
80008d92:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d96:	40 fc       	lddsp	r12,sp[0x3c]
80008d98:	58 0c       	cp.w	r12,0
80008d9a:	c1 f0       	breq	80008dd8 <_vfprintf_r+0x17b8>
80008d9c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008da0:	fa c9 f9 48 	sub	r9,sp,-1720
80008da4:	2f e8       	sub	r8,-2
80008da6:	87 09       	st.w	r3[0x0],r9
80008da8:	fb 48 06 90 	st.w	sp[1680],r8
80008dac:	30 29       	mov	r9,2
80008dae:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008db2:	87 19       	st.w	r3[0x4],r9
80008db4:	2f f8       	sub	r8,-1
80008db6:	fb 48 06 8c 	st.w	sp[1676],r8
80008dba:	58 78       	cp.w	r8,7
80008dbc:	e0 89 00 04 	brgt	80008dc4 <_vfprintf_r+0x17a4>
80008dc0:	2f 83       	sub	r3,-8
80008dc2:	c0 b8       	rjmp	80008dd8 <_vfprintf_r+0x17b8>
80008dc4:	fa ca f9 78 	sub	r10,sp,-1672
80008dc8:	02 9b       	mov	r11,r1
80008dca:	08 9c       	mov	r12,r4
80008dcc:	fe b0 f4 1c 	rcall	80007604 <__sprint_r>
80008dd0:	e0 81 03 a7 	brne	8000951e <_vfprintf_r+0x1efe>
80008dd4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008dd8:	40 9b       	lddsp	r11,sp[0x24]
80008dda:	e0 4b 00 80 	cp.w	r11,128
80008dde:	c4 71       	brne	80008e6c <_vfprintf_r+0x184c>
80008de0:	40 8a       	lddsp	r10,sp[0x20]
80008de2:	40 39       	lddsp	r9,sp[0xc]
80008de4:	12 1a       	sub	r10,r9
80008de6:	50 4a       	stdsp	sp[0x10],r10
80008de8:	58 0a       	cp.w	r10,0
80008dea:	e0 89 00 20 	brgt	80008e2a <_vfprintf_r+0x180a>
80008dee:	c3 f8       	rjmp	80008e6c <_vfprintf_r+0x184c>
80008df0:	2f 09       	sub	r9,-16
80008df2:	2f f8       	sub	r8,-1
80008df4:	fe ce b5 ac 	sub	lr,pc,-19028
80008df8:	31 0c       	mov	r12,16
80008dfa:	fb 49 06 90 	st.w	sp[1680],r9
80008dfe:	87 0e       	st.w	r3[0x0],lr
80008e00:	87 1c       	st.w	r3[0x4],r12
80008e02:	fb 48 06 8c 	st.w	sp[1676],r8
80008e06:	58 78       	cp.w	r8,7
80008e08:	e0 89 00 04 	brgt	80008e10 <_vfprintf_r+0x17f0>
80008e0c:	2f 83       	sub	r3,-8
80008e0e:	c0 b8       	rjmp	80008e24 <_vfprintf_r+0x1804>
80008e10:	fa ca f9 78 	sub	r10,sp,-1672
80008e14:	02 9b       	mov	r11,r1
80008e16:	08 9c       	mov	r12,r4
80008e18:	fe b0 f3 f6 	rcall	80007604 <__sprint_r>
80008e1c:	e0 81 03 81 	brne	8000951e <_vfprintf_r+0x1efe>
80008e20:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e24:	40 4b       	lddsp	r11,sp[0x10]
80008e26:	21 0b       	sub	r11,16
80008e28:	50 4b       	stdsp	sp[0x10],r11
80008e2a:	fa f9 06 90 	ld.w	r9,sp[1680]
80008e2e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e32:	fe ca b5 ea 	sub	r10,pc,-18966
80008e36:	40 4e       	lddsp	lr,sp[0x10]
80008e38:	59 0e       	cp.w	lr,16
80008e3a:	fe 99 ff db 	brgt	80008df0 <_vfprintf_r+0x17d0>
80008e3e:	1c 09       	add	r9,lr
80008e40:	2f f8       	sub	r8,-1
80008e42:	87 0a       	st.w	r3[0x0],r10
80008e44:	fb 49 06 90 	st.w	sp[1680],r9
80008e48:	87 1e       	st.w	r3[0x4],lr
80008e4a:	fb 48 06 8c 	st.w	sp[1676],r8
80008e4e:	58 78       	cp.w	r8,7
80008e50:	e0 89 00 04 	brgt	80008e58 <_vfprintf_r+0x1838>
80008e54:	2f 83       	sub	r3,-8
80008e56:	c0 b8       	rjmp	80008e6c <_vfprintf_r+0x184c>
80008e58:	fa ca f9 78 	sub	r10,sp,-1672
80008e5c:	02 9b       	mov	r11,r1
80008e5e:	08 9c       	mov	r12,r4
80008e60:	fe b0 f3 d2 	rcall	80007604 <__sprint_r>
80008e64:	e0 81 03 5d 	brne	8000951e <_vfprintf_r+0x1efe>
80008e68:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e6c:	40 2c       	lddsp	r12,sp[0x8]
80008e6e:	04 1c       	sub	r12,r2
80008e70:	50 2c       	stdsp	sp[0x8],r12
80008e72:	58 0c       	cp.w	r12,0
80008e74:	e0 89 00 20 	brgt	80008eb4 <_vfprintf_r+0x1894>
80008e78:	c3 f8       	rjmp	80008ef6 <_vfprintf_r+0x18d6>
80008e7a:	2f 09       	sub	r9,-16
80008e7c:	2f f8       	sub	r8,-1
80008e7e:	fe cb b6 36 	sub	r11,pc,-18890
80008e82:	31 0a       	mov	r10,16
80008e84:	fb 49 06 90 	st.w	sp[1680],r9
80008e88:	87 0b       	st.w	r3[0x0],r11
80008e8a:	87 1a       	st.w	r3[0x4],r10
80008e8c:	fb 48 06 8c 	st.w	sp[1676],r8
80008e90:	58 78       	cp.w	r8,7
80008e92:	e0 89 00 04 	brgt	80008e9a <_vfprintf_r+0x187a>
80008e96:	2f 83       	sub	r3,-8
80008e98:	c0 b8       	rjmp	80008eae <_vfprintf_r+0x188e>
80008e9a:	fa ca f9 78 	sub	r10,sp,-1672
80008e9e:	02 9b       	mov	r11,r1
80008ea0:	08 9c       	mov	r12,r4
80008ea2:	fe b0 f3 b1 	rcall	80007604 <__sprint_r>
80008ea6:	e0 81 03 3c 	brne	8000951e <_vfprintf_r+0x1efe>
80008eaa:	fa c3 f9 e0 	sub	r3,sp,-1568
80008eae:	40 29       	lddsp	r9,sp[0x8]
80008eb0:	21 09       	sub	r9,16
80008eb2:	50 29       	stdsp	sp[0x8],r9
80008eb4:	fa f9 06 90 	ld.w	r9,sp[1680]
80008eb8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ebc:	fe ca b6 74 	sub	r10,pc,-18828
80008ec0:	40 2e       	lddsp	lr,sp[0x8]
80008ec2:	59 0e       	cp.w	lr,16
80008ec4:	fe 99 ff db 	brgt	80008e7a <_vfprintf_r+0x185a>
80008ec8:	1c 09       	add	r9,lr
80008eca:	2f f8       	sub	r8,-1
80008ecc:	87 0a       	st.w	r3[0x0],r10
80008ece:	fb 49 06 90 	st.w	sp[1680],r9
80008ed2:	87 1e       	st.w	r3[0x4],lr
80008ed4:	fb 48 06 8c 	st.w	sp[1676],r8
80008ed8:	58 78       	cp.w	r8,7
80008eda:	e0 89 00 04 	brgt	80008ee2 <_vfprintf_r+0x18c2>
80008ede:	2f 83       	sub	r3,-8
80008ee0:	c0 b8       	rjmp	80008ef6 <_vfprintf_r+0x18d6>
80008ee2:	fa ca f9 78 	sub	r10,sp,-1672
80008ee6:	02 9b       	mov	r11,r1
80008ee8:	08 9c       	mov	r12,r4
80008eea:	fe b0 f3 8d 	rcall	80007604 <__sprint_r>
80008eee:	e0 81 03 18 	brne	8000951e <_vfprintf_r+0x1efe>
80008ef2:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ef6:	ed b5 00 08 	bld	r5,0x8
80008efa:	c0 b0       	breq	80008f10 <_vfprintf_r+0x18f0>
80008efc:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f00:	87 12       	st.w	r3[0x4],r2
80008f02:	87 06       	st.w	r3[0x0],r6
80008f04:	f0 02 00 02 	add	r2,r8,r2
80008f08:	fb 42 06 90 	st.w	sp[1680],r2
80008f0c:	e0 8f 01 d4 	bral	800092b4 <_vfprintf_r+0x1c94>
80008f10:	e0 40 00 65 	cp.w	r0,101
80008f14:	e0 8a 01 d6 	brle	800092c0 <_vfprintf_r+0x1ca0>
80008f18:	30 08       	mov	r8,0
80008f1a:	30 09       	mov	r9,0
80008f1c:	40 5b       	lddsp	r11,sp[0x14]
80008f1e:	40 7a       	lddsp	r10,sp[0x1c]
80008f20:	e0 a0 15 2f 	rcall	8000b97e <__avr32_f64_cmp_eq>
80008f24:	c7 90       	breq	80009016 <_vfprintf_r+0x19f6>
80008f26:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f2a:	fe c9 b6 f6 	sub	r9,pc,-18698
80008f2e:	2f f8       	sub	r8,-1
80008f30:	87 09       	st.w	r3[0x0],r9
80008f32:	fb 48 06 90 	st.w	sp[1680],r8
80008f36:	30 19       	mov	r9,1
80008f38:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f3c:	87 19       	st.w	r3[0x4],r9
80008f3e:	2f f8       	sub	r8,-1
80008f40:	fb 48 06 8c 	st.w	sp[1676],r8
80008f44:	58 78       	cp.w	r8,7
80008f46:	e0 89 00 05 	brgt	80008f50 <_vfprintf_r+0x1930>
80008f4a:	2f 83       	sub	r3,-8
80008f4c:	c0 c8       	rjmp	80008f64 <_vfprintf_r+0x1944>
80008f4e:	d7 03       	nop
80008f50:	fa ca f9 78 	sub	r10,sp,-1672
80008f54:	02 9b       	mov	r11,r1
80008f56:	08 9c       	mov	r12,r4
80008f58:	fe b0 f3 56 	rcall	80007604 <__sprint_r>
80008f5c:	e0 81 02 e1 	brne	8000951e <_vfprintf_r+0x1efe>
80008f60:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f64:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008f68:	40 6c       	lddsp	r12,sp[0x18]
80008f6a:	18 38       	cp.w	r8,r12
80008f6c:	c0 55       	brlt	80008f76 <_vfprintf_r+0x1956>
80008f6e:	ed b5 00 00 	bld	r5,0x0
80008f72:	e0 81 02 6b 	brne	80009448 <_vfprintf_r+0x1e28>
80008f76:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f7a:	2f f8       	sub	r8,-1
80008f7c:	40 cb       	lddsp	r11,sp[0x30]
80008f7e:	fb 48 06 90 	st.w	sp[1680],r8
80008f82:	30 19       	mov	r9,1
80008f84:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f88:	87 0b       	st.w	r3[0x0],r11
80008f8a:	2f f8       	sub	r8,-1
80008f8c:	87 19       	st.w	r3[0x4],r9
80008f8e:	fb 48 06 8c 	st.w	sp[1676],r8
80008f92:	58 78       	cp.w	r8,7
80008f94:	e0 89 00 04 	brgt	80008f9c <_vfprintf_r+0x197c>
80008f98:	2f 83       	sub	r3,-8
80008f9a:	c0 b8       	rjmp	80008fb0 <_vfprintf_r+0x1990>
80008f9c:	fa ca f9 78 	sub	r10,sp,-1672
80008fa0:	02 9b       	mov	r11,r1
80008fa2:	08 9c       	mov	r12,r4
80008fa4:	fe b0 f3 30 	rcall	80007604 <__sprint_r>
80008fa8:	e0 81 02 bb 	brne	8000951e <_vfprintf_r+0x1efe>
80008fac:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fb0:	40 66       	lddsp	r6,sp[0x18]
80008fb2:	20 16       	sub	r6,1
80008fb4:	58 06       	cp.w	r6,0
80008fb6:	e0 89 00 1d 	brgt	80008ff0 <_vfprintf_r+0x19d0>
80008fba:	e0 8f 02 47 	bral	80009448 <_vfprintf_r+0x1e28>
80008fbe:	2f 09       	sub	r9,-16
80008fc0:	2f f8       	sub	r8,-1
80008fc2:	fb 49 06 90 	st.w	sp[1680],r9
80008fc6:	87 02       	st.w	r3[0x0],r2
80008fc8:	87 10       	st.w	r3[0x4],r0
80008fca:	fb 48 06 8c 	st.w	sp[1676],r8
80008fce:	58 78       	cp.w	r8,7
80008fd0:	e0 89 00 04 	brgt	80008fd8 <_vfprintf_r+0x19b8>
80008fd4:	2f 83       	sub	r3,-8
80008fd6:	c0 b8       	rjmp	80008fec <_vfprintf_r+0x19cc>
80008fd8:	fa ca f9 78 	sub	r10,sp,-1672
80008fdc:	02 9b       	mov	r11,r1
80008fde:	08 9c       	mov	r12,r4
80008fe0:	fe b0 f3 12 	rcall	80007604 <__sprint_r>
80008fe4:	e0 81 02 9d 	brne	8000951e <_vfprintf_r+0x1efe>
80008fe8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fec:	21 06       	sub	r6,16
80008fee:	c0 48       	rjmp	80008ff6 <_vfprintf_r+0x19d6>
80008ff0:	fe c2 b7 a8 	sub	r2,pc,-18520
80008ff4:	31 00       	mov	r0,16
80008ff6:	fa f9 06 90 	ld.w	r9,sp[1680]
80008ffa:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ffe:	fe ca b7 b6 	sub	r10,pc,-18506
80009002:	59 06       	cp.w	r6,16
80009004:	fe 99 ff dd 	brgt	80008fbe <_vfprintf_r+0x199e>
80009008:	0c 09       	add	r9,r6
8000900a:	87 0a       	st.w	r3[0x0],r10
8000900c:	fb 49 06 90 	st.w	sp[1680],r9
80009010:	2f f8       	sub	r8,-1
80009012:	87 16       	st.w	r3[0x4],r6
80009014:	c5 39       	rjmp	800092ba <_vfprintf_r+0x1c9a>
80009016:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000901a:	58 0a       	cp.w	r10,0
8000901c:	e0 89 00 92 	brgt	80009140 <_vfprintf_r+0x1b20>
80009020:	fa f8 06 90 	ld.w	r8,sp[1680]
80009024:	fe c9 b7 f0 	sub	r9,pc,-18448
80009028:	2f f8       	sub	r8,-1
8000902a:	87 09       	st.w	r3[0x0],r9
8000902c:	fb 48 06 90 	st.w	sp[1680],r8
80009030:	30 19       	mov	r9,1
80009032:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009036:	87 19       	st.w	r3[0x4],r9
80009038:	2f f8       	sub	r8,-1
8000903a:	fb 48 06 8c 	st.w	sp[1676],r8
8000903e:	58 78       	cp.w	r8,7
80009040:	e0 89 00 04 	brgt	80009048 <_vfprintf_r+0x1a28>
80009044:	2f 83       	sub	r3,-8
80009046:	c0 b8       	rjmp	8000905c <_vfprintf_r+0x1a3c>
80009048:	fa ca f9 78 	sub	r10,sp,-1672
8000904c:	02 9b       	mov	r11,r1
8000904e:	08 9c       	mov	r12,r4
80009050:	fe b0 f2 da 	rcall	80007604 <__sprint_r>
80009054:	e0 81 02 65 	brne	8000951e <_vfprintf_r+0x1efe>
80009058:	fa c3 f9 e0 	sub	r3,sp,-1568
8000905c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009060:	58 08       	cp.w	r8,0
80009062:	c0 81       	brne	80009072 <_vfprintf_r+0x1a52>
80009064:	40 6a       	lddsp	r10,sp[0x18]
80009066:	58 0a       	cp.w	r10,0
80009068:	c0 51       	brne	80009072 <_vfprintf_r+0x1a52>
8000906a:	ed b5 00 00 	bld	r5,0x0
8000906e:	e0 81 01 ed 	brne	80009448 <_vfprintf_r+0x1e28>
80009072:	40 c9       	lddsp	r9,sp[0x30]
80009074:	fa f8 06 90 	ld.w	r8,sp[1680]
80009078:	2f f8       	sub	r8,-1
8000907a:	87 09       	st.w	r3[0x0],r9
8000907c:	fb 48 06 90 	st.w	sp[1680],r8
80009080:	30 19       	mov	r9,1
80009082:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009086:	87 19       	st.w	r3[0x4],r9
80009088:	2f f8       	sub	r8,-1
8000908a:	fb 48 06 8c 	st.w	sp[1676],r8
8000908e:	58 78       	cp.w	r8,7
80009090:	e0 89 00 04 	brgt	80009098 <_vfprintf_r+0x1a78>
80009094:	2f 83       	sub	r3,-8
80009096:	c0 b8       	rjmp	800090ac <_vfprintf_r+0x1a8c>
80009098:	fa ca f9 78 	sub	r10,sp,-1672
8000909c:	02 9b       	mov	r11,r1
8000909e:	08 9c       	mov	r12,r4
800090a0:	fe b0 f2 b2 	rcall	80007604 <__sprint_r>
800090a4:	e0 81 02 3d 	brne	8000951e <_vfprintf_r+0x1efe>
800090a8:	fa c3 f9 e0 	sub	r3,sp,-1568
800090ac:	fa f2 06 ac 	ld.w	r2,sp[1708]
800090b0:	5c 32       	neg	r2
800090b2:	58 02       	cp.w	r2,0
800090b4:	e0 89 00 1d 	brgt	800090ee <_vfprintf_r+0x1ace>
800090b8:	c3 d8       	rjmp	80009132 <_vfprintf_r+0x1b12>
800090ba:	2f 09       	sub	r9,-16
800090bc:	2f f8       	sub	r8,-1
800090be:	31 0e       	mov	lr,16
800090c0:	fb 49 06 90 	st.w	sp[1680],r9
800090c4:	87 00       	st.w	r3[0x0],r0
800090c6:	87 1e       	st.w	r3[0x4],lr
800090c8:	fb 48 06 8c 	st.w	sp[1676],r8
800090cc:	58 78       	cp.w	r8,7
800090ce:	e0 89 00 04 	brgt	800090d6 <_vfprintf_r+0x1ab6>
800090d2:	2f 83       	sub	r3,-8
800090d4:	c0 b8       	rjmp	800090ea <_vfprintf_r+0x1aca>
800090d6:	fa ca f9 78 	sub	r10,sp,-1672
800090da:	02 9b       	mov	r11,r1
800090dc:	08 9c       	mov	r12,r4
800090de:	fe b0 f2 93 	rcall	80007604 <__sprint_r>
800090e2:	e0 81 02 1e 	brne	8000951e <_vfprintf_r+0x1efe>
800090e6:	fa c3 f9 e0 	sub	r3,sp,-1568
800090ea:	21 02       	sub	r2,16
800090ec:	c0 38       	rjmp	800090f2 <_vfprintf_r+0x1ad2>
800090ee:	fe c0 b8 a6 	sub	r0,pc,-18266
800090f2:	fa f9 06 90 	ld.w	r9,sp[1680]
800090f6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800090fa:	fe ca b8 b2 	sub	r10,pc,-18254
800090fe:	59 02       	cp.w	r2,16
80009100:	fe 99 ff dd 	brgt	800090ba <_vfprintf_r+0x1a9a>
80009104:	04 09       	add	r9,r2
80009106:	2f f8       	sub	r8,-1
80009108:	87 0a       	st.w	r3[0x0],r10
8000910a:	fb 49 06 90 	st.w	sp[1680],r9
8000910e:	87 12       	st.w	r3[0x4],r2
80009110:	fb 48 06 8c 	st.w	sp[1676],r8
80009114:	58 78       	cp.w	r8,7
80009116:	e0 89 00 04 	brgt	8000911e <_vfprintf_r+0x1afe>
8000911a:	2f 83       	sub	r3,-8
8000911c:	c0 b8       	rjmp	80009132 <_vfprintf_r+0x1b12>
8000911e:	fa ca f9 78 	sub	r10,sp,-1672
80009122:	02 9b       	mov	r11,r1
80009124:	08 9c       	mov	r12,r4
80009126:	fe b0 f2 6f 	rcall	80007604 <__sprint_r>
8000912a:	e0 81 01 fa 	brne	8000951e <_vfprintf_r+0x1efe>
8000912e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009132:	40 6c       	lddsp	r12,sp[0x18]
80009134:	fa f8 06 90 	ld.w	r8,sp[1680]
80009138:	87 06       	st.w	r3[0x0],r6
8000913a:	87 1c       	st.w	r3[0x4],r12
8000913c:	18 08       	add	r8,r12
8000913e:	cb 98       	rjmp	800092b0 <_vfprintf_r+0x1c90>
80009140:	fa f9 06 90 	ld.w	r9,sp[1680]
80009144:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009148:	40 6b       	lddsp	r11,sp[0x18]
8000914a:	16 3a       	cp.w	r10,r11
8000914c:	c6 f5       	brlt	8000922a <_vfprintf_r+0x1c0a>
8000914e:	16 09       	add	r9,r11
80009150:	2f f8       	sub	r8,-1
80009152:	87 06       	st.w	r3[0x0],r6
80009154:	fb 49 06 90 	st.w	sp[1680],r9
80009158:	87 1b       	st.w	r3[0x4],r11
8000915a:	fb 48 06 8c 	st.w	sp[1676],r8
8000915e:	58 78       	cp.w	r8,7
80009160:	e0 89 00 04 	brgt	80009168 <_vfprintf_r+0x1b48>
80009164:	2f 83       	sub	r3,-8
80009166:	c0 b8       	rjmp	8000917c <_vfprintf_r+0x1b5c>
80009168:	fa ca f9 78 	sub	r10,sp,-1672
8000916c:	02 9b       	mov	r11,r1
8000916e:	08 9c       	mov	r12,r4
80009170:	fe b0 f2 4a 	rcall	80007604 <__sprint_r>
80009174:	e0 81 01 d5 	brne	8000951e <_vfprintf_r+0x1efe>
80009178:	fa c3 f9 e0 	sub	r3,sp,-1568
8000917c:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009180:	40 6a       	lddsp	r10,sp[0x18]
80009182:	14 16       	sub	r6,r10
80009184:	58 06       	cp.w	r6,0
80009186:	e0 89 00 1c 	brgt	800091be <_vfprintf_r+0x1b9e>
8000918a:	c3 d8       	rjmp	80009204 <_vfprintf_r+0x1be4>
8000918c:	2f 09       	sub	r9,-16
8000918e:	2f f8       	sub	r8,-1
80009190:	fb 49 06 90 	st.w	sp[1680],r9
80009194:	87 02       	st.w	r3[0x0],r2
80009196:	87 10       	st.w	r3[0x4],r0
80009198:	fb 48 06 8c 	st.w	sp[1676],r8
8000919c:	58 78       	cp.w	r8,7
8000919e:	e0 89 00 04 	brgt	800091a6 <_vfprintf_r+0x1b86>
800091a2:	2f 83       	sub	r3,-8
800091a4:	c0 b8       	rjmp	800091ba <_vfprintf_r+0x1b9a>
800091a6:	fa ca f9 78 	sub	r10,sp,-1672
800091aa:	02 9b       	mov	r11,r1
800091ac:	08 9c       	mov	r12,r4
800091ae:	fe b0 f2 2b 	rcall	80007604 <__sprint_r>
800091b2:	e0 81 01 b6 	brne	8000951e <_vfprintf_r+0x1efe>
800091b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800091ba:	21 06       	sub	r6,16
800091bc:	c0 48       	rjmp	800091c4 <_vfprintf_r+0x1ba4>
800091be:	fe c2 b9 76 	sub	r2,pc,-18058
800091c2:	31 00       	mov	r0,16
800091c4:	fa f9 06 90 	ld.w	r9,sp[1680]
800091c8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800091cc:	fe ca b9 84 	sub	r10,pc,-18044
800091d0:	59 06       	cp.w	r6,16
800091d2:	fe 99 ff dd 	brgt	8000918c <_vfprintf_r+0x1b6c>
800091d6:	0c 09       	add	r9,r6
800091d8:	2f f8       	sub	r8,-1
800091da:	87 0a       	st.w	r3[0x0],r10
800091dc:	fb 49 06 90 	st.w	sp[1680],r9
800091e0:	87 16       	st.w	r3[0x4],r6
800091e2:	fb 48 06 8c 	st.w	sp[1676],r8
800091e6:	58 78       	cp.w	r8,7
800091e8:	e0 89 00 04 	brgt	800091f0 <_vfprintf_r+0x1bd0>
800091ec:	2f 83       	sub	r3,-8
800091ee:	c0 b8       	rjmp	80009204 <_vfprintf_r+0x1be4>
800091f0:	fa ca f9 78 	sub	r10,sp,-1672
800091f4:	02 9b       	mov	r11,r1
800091f6:	08 9c       	mov	r12,r4
800091f8:	fe b0 f2 06 	rcall	80007604 <__sprint_r>
800091fc:	e0 81 01 91 	brne	8000951e <_vfprintf_r+0x1efe>
80009200:	fa c3 f9 e0 	sub	r3,sp,-1568
80009204:	ed b5 00 00 	bld	r5,0x0
80009208:	e0 81 01 20 	brne	80009448 <_vfprintf_r+0x1e28>
8000920c:	40 c9       	lddsp	r9,sp[0x30]
8000920e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009212:	2f f8       	sub	r8,-1
80009214:	87 09       	st.w	r3[0x0],r9
80009216:	fb 48 06 90 	st.w	sp[1680],r8
8000921a:	30 19       	mov	r9,1
8000921c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009220:	87 19       	st.w	r3[0x4],r9
80009222:	2f f8       	sub	r8,-1
80009224:	fb 48 06 8c 	st.w	sp[1676],r8
80009228:	c0 29       	rjmp	8000942c <_vfprintf_r+0x1e0c>
8000922a:	14 09       	add	r9,r10
8000922c:	2f f8       	sub	r8,-1
8000922e:	fb 49 06 90 	st.w	sp[1680],r9
80009232:	87 06       	st.w	r3[0x0],r6
80009234:	87 1a       	st.w	r3[0x4],r10
80009236:	fb 48 06 8c 	st.w	sp[1676],r8
8000923a:	58 78       	cp.w	r8,7
8000923c:	e0 89 00 04 	brgt	80009244 <_vfprintf_r+0x1c24>
80009240:	2f 83       	sub	r3,-8
80009242:	c0 b8       	rjmp	80009258 <_vfprintf_r+0x1c38>
80009244:	fa ca f9 78 	sub	r10,sp,-1672
80009248:	02 9b       	mov	r11,r1
8000924a:	08 9c       	mov	r12,r4
8000924c:	fe b0 f1 dc 	rcall	80007604 <__sprint_r>
80009250:	e0 81 01 67 	brne	8000951e <_vfprintf_r+0x1efe>
80009254:	fa c3 f9 e0 	sub	r3,sp,-1568
80009258:	40 c8       	lddsp	r8,sp[0x30]
8000925a:	87 08       	st.w	r3[0x0],r8
8000925c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009260:	2f f8       	sub	r8,-1
80009262:	30 19       	mov	r9,1
80009264:	fb 48 06 90 	st.w	sp[1680],r8
80009268:	87 19       	st.w	r3[0x4],r9
8000926a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000926e:	2f f8       	sub	r8,-1
80009270:	fb 48 06 8c 	st.w	sp[1676],r8
80009274:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009278:	58 78       	cp.w	r8,7
8000927a:	e0 89 00 04 	brgt	80009282 <_vfprintf_r+0x1c62>
8000927e:	2f 83       	sub	r3,-8
80009280:	c0 b8       	rjmp	80009296 <_vfprintf_r+0x1c76>
80009282:	fa ca f9 78 	sub	r10,sp,-1672
80009286:	02 9b       	mov	r11,r1
80009288:	08 9c       	mov	r12,r4
8000928a:	fe b0 f1 bd 	rcall	80007604 <__sprint_r>
8000928e:	e0 81 01 48 	brne	8000951e <_vfprintf_r+0x1efe>
80009292:	fa c3 f9 e0 	sub	r3,sp,-1568
80009296:	04 06       	add	r6,r2
80009298:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000929c:	87 06       	st.w	r3[0x0],r6
8000929e:	fa f9 06 90 	ld.w	r9,sp[1680]
800092a2:	40 66       	lddsp	r6,sp[0x18]
800092a4:	40 6e       	lddsp	lr,sp[0x18]
800092a6:	10 16       	sub	r6,r8
800092a8:	f2 08 01 08 	sub	r8,r9,r8
800092ac:	87 16       	st.w	r3[0x4],r6
800092ae:	1c 08       	add	r8,lr
800092b0:	fb 48 06 90 	st.w	sp[1680],r8
800092b4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092b8:	2f f8       	sub	r8,-1
800092ba:	fb 48 06 8c 	st.w	sp[1676],r8
800092be:	cb 78       	rjmp	8000942c <_vfprintf_r+0x1e0c>
800092c0:	40 6c       	lddsp	r12,sp[0x18]
800092c2:	58 1c       	cp.w	r12,1
800092c4:	e0 89 00 06 	brgt	800092d0 <_vfprintf_r+0x1cb0>
800092c8:	ed b5 00 00 	bld	r5,0x0
800092cc:	e0 81 00 85 	brne	800093d6 <_vfprintf_r+0x1db6>
800092d0:	fa f8 06 90 	ld.w	r8,sp[1680]
800092d4:	2f f8       	sub	r8,-1
800092d6:	30 19       	mov	r9,1
800092d8:	fb 48 06 90 	st.w	sp[1680],r8
800092dc:	87 06       	st.w	r3[0x0],r6
800092de:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092e2:	87 19       	st.w	r3[0x4],r9
800092e4:	2f f8       	sub	r8,-1
800092e6:	fb 48 06 8c 	st.w	sp[1676],r8
800092ea:	58 78       	cp.w	r8,7
800092ec:	e0 89 00 04 	brgt	800092f4 <_vfprintf_r+0x1cd4>
800092f0:	2f 83       	sub	r3,-8
800092f2:	c0 b8       	rjmp	80009308 <_vfprintf_r+0x1ce8>
800092f4:	fa ca f9 78 	sub	r10,sp,-1672
800092f8:	02 9b       	mov	r11,r1
800092fa:	08 9c       	mov	r12,r4
800092fc:	fe b0 f1 84 	rcall	80007604 <__sprint_r>
80009300:	e0 81 01 0f 	brne	8000951e <_vfprintf_r+0x1efe>
80009304:	fa c3 f9 e0 	sub	r3,sp,-1568
80009308:	fa f8 06 90 	ld.w	r8,sp[1680]
8000930c:	2f f8       	sub	r8,-1
8000930e:	40 cb       	lddsp	r11,sp[0x30]
80009310:	fb 48 06 90 	st.w	sp[1680],r8
80009314:	30 19       	mov	r9,1
80009316:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000931a:	87 0b       	st.w	r3[0x0],r11
8000931c:	2f f8       	sub	r8,-1
8000931e:	87 19       	st.w	r3[0x4],r9
80009320:	fb 48 06 8c 	st.w	sp[1676],r8
80009324:	58 78       	cp.w	r8,7
80009326:	e0 89 00 05 	brgt	80009330 <_vfprintf_r+0x1d10>
8000932a:	2f 83       	sub	r3,-8
8000932c:	c0 c8       	rjmp	80009344 <_vfprintf_r+0x1d24>
8000932e:	d7 03       	nop
80009330:	fa ca f9 78 	sub	r10,sp,-1672
80009334:	02 9b       	mov	r11,r1
80009336:	08 9c       	mov	r12,r4
80009338:	fe b0 f1 66 	rcall	80007604 <__sprint_r>
8000933c:	e0 81 00 f1 	brne	8000951e <_vfprintf_r+0x1efe>
80009340:	fa c3 f9 e0 	sub	r3,sp,-1568
80009344:	30 08       	mov	r8,0
80009346:	30 09       	mov	r9,0
80009348:	40 5b       	lddsp	r11,sp[0x14]
8000934a:	40 7a       	lddsp	r10,sp[0x1c]
8000934c:	e0 a0 13 19 	rcall	8000b97e <__avr32_f64_cmp_eq>
80009350:	40 68       	lddsp	r8,sp[0x18]
80009352:	20 18       	sub	r8,1
80009354:	58 0c       	cp.w	r12,0
80009356:	c0 d1       	brne	80009370 <_vfprintf_r+0x1d50>
80009358:	2f f6       	sub	r6,-1
8000935a:	87 18       	st.w	r3[0x4],r8
8000935c:	87 06       	st.w	r3[0x0],r6
8000935e:	fa f6 06 90 	ld.w	r6,sp[1680]
80009362:	10 06       	add	r6,r8
80009364:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009368:	fb 46 06 90 	st.w	sp[1680],r6
8000936c:	2f f8       	sub	r8,-1
8000936e:	c3 18       	rjmp	800093d0 <_vfprintf_r+0x1db0>
80009370:	10 96       	mov	r6,r8
80009372:	58 08       	cp.w	r8,0
80009374:	e0 89 00 1c 	brgt	800093ac <_vfprintf_r+0x1d8c>
80009378:	c4 b8       	rjmp	8000940e <_vfprintf_r+0x1dee>
8000937a:	2f 09       	sub	r9,-16
8000937c:	2f f8       	sub	r8,-1
8000937e:	fb 49 06 90 	st.w	sp[1680],r9
80009382:	87 02       	st.w	r3[0x0],r2
80009384:	87 10       	st.w	r3[0x4],r0
80009386:	fb 48 06 8c 	st.w	sp[1676],r8
8000938a:	58 78       	cp.w	r8,7
8000938c:	e0 89 00 04 	brgt	80009394 <_vfprintf_r+0x1d74>
80009390:	2f 83       	sub	r3,-8
80009392:	c0 b8       	rjmp	800093a8 <_vfprintf_r+0x1d88>
80009394:	fa ca f9 78 	sub	r10,sp,-1672
80009398:	02 9b       	mov	r11,r1
8000939a:	08 9c       	mov	r12,r4
8000939c:	fe b0 f1 34 	rcall	80007604 <__sprint_r>
800093a0:	e0 81 00 bf 	brne	8000951e <_vfprintf_r+0x1efe>
800093a4:	fa c3 f9 e0 	sub	r3,sp,-1568
800093a8:	21 06       	sub	r6,16
800093aa:	c0 48       	rjmp	800093b2 <_vfprintf_r+0x1d92>
800093ac:	fe c2 bb 64 	sub	r2,pc,-17564
800093b0:	31 00       	mov	r0,16
800093b2:	fa f9 06 90 	ld.w	r9,sp[1680]
800093b6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093ba:	fe ca bb 72 	sub	r10,pc,-17550
800093be:	59 06       	cp.w	r6,16
800093c0:	fe 99 ff dd 	brgt	8000937a <_vfprintf_r+0x1d5a>
800093c4:	0c 09       	add	r9,r6
800093c6:	87 0a       	st.w	r3[0x0],r10
800093c8:	fb 49 06 90 	st.w	sp[1680],r9
800093cc:	2f f8       	sub	r8,-1
800093ce:	87 16       	st.w	r3[0x4],r6
800093d0:	fb 48 06 8c 	st.w	sp[1676],r8
800093d4:	c0 e8       	rjmp	800093f0 <_vfprintf_r+0x1dd0>
800093d6:	fa f8 06 90 	ld.w	r8,sp[1680]
800093da:	2f f8       	sub	r8,-1
800093dc:	30 19       	mov	r9,1
800093de:	fb 48 06 90 	st.w	sp[1680],r8
800093e2:	87 06       	st.w	r3[0x0],r6
800093e4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093e8:	87 19       	st.w	r3[0x4],r9
800093ea:	2f f8       	sub	r8,-1
800093ec:	fb 48 06 8c 	st.w	sp[1676],r8
800093f0:	58 78       	cp.w	r8,7
800093f2:	e0 89 00 04 	brgt	800093fa <_vfprintf_r+0x1dda>
800093f6:	2f 83       	sub	r3,-8
800093f8:	c0 b8       	rjmp	8000940e <_vfprintf_r+0x1dee>
800093fa:	fa ca f9 78 	sub	r10,sp,-1672
800093fe:	02 9b       	mov	r11,r1
80009400:	08 9c       	mov	r12,r4
80009402:	fe b0 f1 01 	rcall	80007604 <__sprint_r>
80009406:	e0 81 00 8c 	brne	8000951e <_vfprintf_r+0x1efe>
8000940a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000940e:	40 ea       	lddsp	r10,sp[0x38]
80009410:	fa f8 06 90 	ld.w	r8,sp[1680]
80009414:	14 08       	add	r8,r10
80009416:	fa c9 f9 64 	sub	r9,sp,-1692
8000941a:	fb 48 06 90 	st.w	sp[1680],r8
8000941e:	87 1a       	st.w	r3[0x4],r10
80009420:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009424:	87 09       	st.w	r3[0x0],r9
80009426:	2f f8       	sub	r8,-1
80009428:	fb 48 06 8c 	st.w	sp[1676],r8
8000942c:	58 78       	cp.w	r8,7
8000942e:	e0 89 00 04 	brgt	80009436 <_vfprintf_r+0x1e16>
80009432:	2f 83       	sub	r3,-8
80009434:	c0 a8       	rjmp	80009448 <_vfprintf_r+0x1e28>
80009436:	fa ca f9 78 	sub	r10,sp,-1672
8000943a:	02 9b       	mov	r11,r1
8000943c:	08 9c       	mov	r12,r4
8000943e:	fe b0 f0 e3 	rcall	80007604 <__sprint_r>
80009442:	c6 e1       	brne	8000951e <_vfprintf_r+0x1efe>
80009444:	fa c3 f9 e0 	sub	r3,sp,-1568
80009448:	e2 15 00 04 	andl	r5,0x4,COH
8000944c:	c3 f0       	breq	800094ca <_vfprintf_r+0x1eaa>
8000944e:	40 86       	lddsp	r6,sp[0x20]
80009450:	40 39       	lddsp	r9,sp[0xc]
80009452:	12 16       	sub	r6,r9
80009454:	58 06       	cp.w	r6,0
80009456:	e0 89 00 1a 	brgt	8000948a <_vfprintf_r+0x1e6a>
8000945a:	c3 88       	rjmp	800094ca <_vfprintf_r+0x1eaa>
8000945c:	2f 09       	sub	r9,-16
8000945e:	2f f8       	sub	r8,-1
80009460:	fb 49 06 90 	st.w	sp[1680],r9
80009464:	87 05       	st.w	r3[0x0],r5
80009466:	87 12       	st.w	r3[0x4],r2
80009468:	fb 48 06 8c 	st.w	sp[1676],r8
8000946c:	58 78       	cp.w	r8,7
8000946e:	e0 89 00 04 	brgt	80009476 <_vfprintf_r+0x1e56>
80009472:	2f 83       	sub	r3,-8
80009474:	c0 98       	rjmp	80009486 <_vfprintf_r+0x1e66>
80009476:	00 9a       	mov	r10,r0
80009478:	02 9b       	mov	r11,r1
8000947a:	08 9c       	mov	r12,r4
8000947c:	fe b0 f0 c4 	rcall	80007604 <__sprint_r>
80009480:	c4 f1       	brne	8000951e <_vfprintf_r+0x1efe>
80009482:	fa c3 f9 e0 	sub	r3,sp,-1568
80009486:	21 06       	sub	r6,16
80009488:	c0 68       	rjmp	80009494 <_vfprintf_r+0x1e74>
8000948a:	fe c5 bc 52 	sub	r5,pc,-17326
8000948e:	31 02       	mov	r2,16
80009490:	fa c0 f9 78 	sub	r0,sp,-1672
80009494:	fa f9 06 90 	ld.w	r9,sp[1680]
80009498:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000949c:	fe ca bc 64 	sub	r10,pc,-17308
800094a0:	59 06       	cp.w	r6,16
800094a2:	fe 99 ff dd 	brgt	8000945c <_vfprintf_r+0x1e3c>
800094a6:	0c 09       	add	r9,r6
800094a8:	2f f8       	sub	r8,-1
800094aa:	87 0a       	st.w	r3[0x0],r10
800094ac:	87 16       	st.w	r3[0x4],r6
800094ae:	fb 49 06 90 	st.w	sp[1680],r9
800094b2:	fb 48 06 8c 	st.w	sp[1676],r8
800094b6:	58 78       	cp.w	r8,7
800094b8:	e0 8a 00 09 	brle	800094ca <_vfprintf_r+0x1eaa>
800094bc:	fa ca f9 78 	sub	r10,sp,-1672
800094c0:	02 9b       	mov	r11,r1
800094c2:	08 9c       	mov	r12,r4
800094c4:	fe b0 f0 a0 	rcall	80007604 <__sprint_r>
800094c8:	c2 b1       	brne	8000951e <_vfprintf_r+0x1efe>
800094ca:	40 bc       	lddsp	r12,sp[0x2c]
800094cc:	40 36       	lddsp	r6,sp[0xc]
800094ce:	40 8e       	lddsp	lr,sp[0x20]
800094d0:	ec 0e 0c 48 	max	r8,r6,lr
800094d4:	10 0c       	add	r12,r8
800094d6:	50 bc       	stdsp	sp[0x2c],r12
800094d8:	fa f8 06 90 	ld.w	r8,sp[1680]
800094dc:	58 08       	cp.w	r8,0
800094de:	c0 80       	breq	800094ee <_vfprintf_r+0x1ece>
800094e0:	fa ca f9 78 	sub	r10,sp,-1672
800094e4:	02 9b       	mov	r11,r1
800094e6:	08 9c       	mov	r12,r4
800094e8:	fe b0 f0 8e 	rcall	80007604 <__sprint_r>
800094ec:	c1 91       	brne	8000951e <_vfprintf_r+0x1efe>
800094ee:	30 0b       	mov	r11,0
800094f0:	fa c3 f9 e0 	sub	r3,sp,-1568
800094f4:	fb 4b 06 8c 	st.w	sp[1676],r11
800094f8:	fe 9f f1 22 	bral	8000773c <_vfprintf_r+0x11c>
800094fc:	08 95       	mov	r5,r4
800094fe:	fa f8 06 90 	ld.w	r8,sp[1680]
80009502:	58 08       	cp.w	r8,0
80009504:	c0 80       	breq	80009514 <_vfprintf_r+0x1ef4>
80009506:	08 9c       	mov	r12,r4
80009508:	fa ca f9 78 	sub	r10,sp,-1672
8000950c:	02 9b       	mov	r11,r1
8000950e:	fe b0 f0 7b 	rcall	80007604 <__sprint_r>
80009512:	c0 61       	brne	8000951e <_vfprintf_r+0x1efe>
80009514:	30 08       	mov	r8,0
80009516:	fb 48 06 8c 	st.w	sp[1676],r8
8000951a:	c0 28       	rjmp	8000951e <_vfprintf_r+0x1efe>
8000951c:	40 41       	lddsp	r1,sp[0x10]
8000951e:	82 68       	ld.sh	r8,r1[0xc]
80009520:	ed b8 00 06 	bld	r8,0x6
80009524:	c0 31       	brne	8000952a <_vfprintf_r+0x1f0a>
80009526:	3f fa       	mov	r10,-1
80009528:	50 ba       	stdsp	sp[0x2c],r10
8000952a:	40 bc       	lddsp	r12,sp[0x2c]
8000952c:	fe 3d f9 44 	sub	sp,-1724
80009530:	d8 32       	popm	r0-r7,pc
80009532:	d7 03       	nop

80009534 <__swsetup_r>:
80009534:	d4 21       	pushm	r4-r7,lr
80009536:	e0 68 0a 38 	mov	r8,2616
8000953a:	18 96       	mov	r6,r12
8000953c:	16 97       	mov	r7,r11
8000953e:	70 0c       	ld.w	r12,r8[0x0]
80009540:	58 0c       	cp.w	r12,0
80009542:	c0 60       	breq	8000954e <__swsetup_r+0x1a>
80009544:	78 68       	ld.w	r8,r12[0x18]
80009546:	58 08       	cp.w	r8,0
80009548:	c0 31       	brne	8000954e <__swsetup_r+0x1a>
8000954a:	e0 a0 07 bf 	rcall	8000a4c8 <__sinit>
8000954e:	fe c8 bb e6 	sub	r8,pc,-17434
80009552:	10 37       	cp.w	r7,r8
80009554:	c0 61       	brne	80009560 <__swsetup_r+0x2c>
80009556:	e0 68 0a 38 	mov	r8,2616
8000955a:	70 08       	ld.w	r8,r8[0x0]
8000955c:	70 07       	ld.w	r7,r8[0x0]
8000955e:	c1 28       	rjmp	80009582 <__swsetup_r+0x4e>
80009560:	fe c8 bb d8 	sub	r8,pc,-17448
80009564:	10 37       	cp.w	r7,r8
80009566:	c0 61       	brne	80009572 <__swsetup_r+0x3e>
80009568:	e0 68 0a 38 	mov	r8,2616
8000956c:	70 08       	ld.w	r8,r8[0x0]
8000956e:	70 17       	ld.w	r7,r8[0x4]
80009570:	c0 98       	rjmp	80009582 <__swsetup_r+0x4e>
80009572:	fe c8 bb ca 	sub	r8,pc,-17462
80009576:	10 37       	cp.w	r7,r8
80009578:	c0 51       	brne	80009582 <__swsetup_r+0x4e>
8000957a:	e0 68 0a 38 	mov	r8,2616
8000957e:	70 08       	ld.w	r8,r8[0x0]
80009580:	70 27       	ld.w	r7,r8[0x8]
80009582:	8e 68       	ld.sh	r8,r7[0xc]
80009584:	ed b8 00 03 	bld	r8,0x3
80009588:	c1 e0       	breq	800095c4 <__swsetup_r+0x90>
8000958a:	ed b8 00 04 	bld	r8,0x4
8000958e:	c3 e1       	brne	8000960a <__swsetup_r+0xd6>
80009590:	ed b8 00 02 	bld	r8,0x2
80009594:	c1 51       	brne	800095be <__swsetup_r+0x8a>
80009596:	6e db       	ld.w	r11,r7[0x34]
80009598:	58 0b       	cp.w	r11,0
8000959a:	c0 a0       	breq	800095ae <__swsetup_r+0x7a>
8000959c:	ee c8 ff bc 	sub	r8,r7,-68
800095a0:	10 3b       	cp.w	r11,r8
800095a2:	c0 40       	breq	800095aa <__swsetup_r+0x76>
800095a4:	0c 9c       	mov	r12,r6
800095a6:	e0 a0 08 2b 	rcall	8000a5fc <_free_r>
800095aa:	30 08       	mov	r8,0
800095ac:	8f d8       	st.w	r7[0x34],r8
800095ae:	8e 68       	ld.sh	r8,r7[0xc]
800095b0:	e0 18 ff db 	andl	r8,0xffdb
800095b4:	ae 68       	st.h	r7[0xc],r8
800095b6:	30 08       	mov	r8,0
800095b8:	8f 18       	st.w	r7[0x4],r8
800095ba:	6e 48       	ld.w	r8,r7[0x10]
800095bc:	8f 08       	st.w	r7[0x0],r8
800095be:	8e 68       	ld.sh	r8,r7[0xc]
800095c0:	a3 b8       	sbr	r8,0x3
800095c2:	ae 68       	st.h	r7[0xc],r8
800095c4:	6e 48       	ld.w	r8,r7[0x10]
800095c6:	58 08       	cp.w	r8,0
800095c8:	c0 b1       	brne	800095de <__swsetup_r+0xaa>
800095ca:	8e 68       	ld.sh	r8,r7[0xc]
800095cc:	e2 18 02 80 	andl	r8,0x280,COH
800095d0:	e0 48 02 00 	cp.w	r8,512
800095d4:	c0 50       	breq	800095de <__swsetup_r+0xaa>
800095d6:	0c 9c       	mov	r12,r6
800095d8:	0e 9b       	mov	r11,r7
800095da:	e0 a0 0a 4b 	rcall	8000aa70 <__smakebuf_r>
800095de:	8e 69       	ld.sh	r9,r7[0xc]
800095e0:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
800095e4:	c0 70       	breq	800095f2 <__swsetup_r+0xbe>
800095e6:	30 08       	mov	r8,0
800095e8:	8f 28       	st.w	r7[0x8],r8
800095ea:	6e 58       	ld.w	r8,r7[0x14]
800095ec:	5c 38       	neg	r8
800095ee:	8f 68       	st.w	r7[0x18],r8
800095f0:	c0 68       	rjmp	800095fc <__swsetup_r+0xc8>
800095f2:	ed b9 00 01 	bld	r9,0x1
800095f6:	ef f8 10 05 	ld.wne	r8,r7[0x14]
800095fa:	8f 28       	st.w	r7[0x8],r8
800095fc:	6e 48       	ld.w	r8,r7[0x10]
800095fe:	58 08       	cp.w	r8,0
80009600:	c0 61       	brne	8000960c <__swsetup_r+0xd8>
80009602:	8e 68       	ld.sh	r8,r7[0xc]
80009604:	ed b8 00 07 	bld	r8,0x7
80009608:	c0 21       	brne	8000960c <__swsetup_r+0xd8>
8000960a:	dc 2a       	popm	r4-r7,pc,r12=-1
8000960c:	d8 2a       	popm	r4-r7,pc,r12=0
8000960e:	d7 03       	nop

80009610 <quorem>:
80009610:	d4 31       	pushm	r0-r7,lr
80009612:	20 2d       	sub	sp,8
80009614:	18 97       	mov	r7,r12
80009616:	78 48       	ld.w	r8,r12[0x10]
80009618:	76 46       	ld.w	r6,r11[0x10]
8000961a:	0c 38       	cp.w	r8,r6
8000961c:	c0 34       	brge	80009622 <quorem+0x12>
8000961e:	30 0c       	mov	r12,0
80009620:	c8 58       	rjmp	8000972a <quorem+0x11a>
80009622:	ec c2 ff fc 	sub	r2,r6,-4
80009626:	f6 c3 ff ec 	sub	r3,r11,-20
8000962a:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000962e:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009632:	2f f9       	sub	r9,-1
80009634:	20 16       	sub	r6,1
80009636:	f8 09 0d 08 	divu	r8,r12,r9
8000963a:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000963e:	ee c4 ff ec 	sub	r4,r7,-20
80009642:	10 95       	mov	r5,r8
80009644:	58 08       	cp.w	r8,0
80009646:	c4 10       	breq	800096c8 <quorem+0xb8>
80009648:	30 09       	mov	r9,0
8000964a:	06 9a       	mov	r10,r3
8000964c:	08 98       	mov	r8,r4
8000964e:	12 91       	mov	r1,r9
80009650:	50 0b       	stdsp	sp[0x0],r11
80009652:	70 0e       	ld.w	lr,r8[0x0]
80009654:	b1 8e       	lsr	lr,0x10
80009656:	50 1e       	stdsp	sp[0x4],lr
80009658:	15 0e       	ld.w	lr,r10++
8000965a:	fc 00 16 10 	lsr	r0,lr,0x10
8000965e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009662:	ea 0e 03 41 	mac	r1,r5,lr
80009666:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000966a:	b1 81       	lsr	r1,0x10
8000966c:	40 1b       	lddsp	r11,sp[0x4]
8000966e:	ea 00 02 40 	mul	r0,r5,r0
80009672:	e2 00 00 00 	add	r0,r1,r0
80009676:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000967a:	02 1b       	sub	r11,r1
8000967c:	50 1b       	stdsp	sp[0x4],r11
8000967e:	70 0b       	ld.w	r11,r8[0x0]
80009680:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009684:	02 09       	add	r9,r1
80009686:	f2 0e 01 0e 	sub	lr,r9,lr
8000968a:	b0 1e       	st.h	r8[0x2],lr
8000968c:	fc 09 14 10 	asr	r9,lr,0x10
80009690:	40 1e       	lddsp	lr,sp[0x4]
80009692:	fc 09 00 09 	add	r9,lr,r9
80009696:	b0 09       	st.h	r8[0x0],r9
80009698:	e0 01 16 10 	lsr	r1,r0,0x10
8000969c:	2f c8       	sub	r8,-4
8000969e:	b1 49       	asr	r9,0x10
800096a0:	04 3a       	cp.w	r10,r2
800096a2:	fe 98 ff d8 	brls	80009652 <quorem+0x42>
800096a6:	40 0b       	lddsp	r11,sp[0x0]
800096a8:	58 0c       	cp.w	r12,0
800096aa:	c0 f1       	brne	800096c8 <quorem+0xb8>
800096ac:	ec c8 ff fb 	sub	r8,r6,-5
800096b0:	ee 08 00 28 	add	r8,r7,r8<<0x2
800096b4:	c0 28       	rjmp	800096b8 <quorem+0xa8>
800096b6:	20 16       	sub	r6,1
800096b8:	20 48       	sub	r8,4
800096ba:	08 38       	cp.w	r8,r4
800096bc:	e0 88 00 05 	brls	800096c6 <quorem+0xb6>
800096c0:	70 09       	ld.w	r9,r8[0x0]
800096c2:	58 09       	cp.w	r9,0
800096c4:	cf 90       	breq	800096b6 <quorem+0xa6>
800096c6:	8f 46       	st.w	r7[0x10],r6
800096c8:	0e 9c       	mov	r12,r7
800096ca:	e0 a0 0a d2 	rcall	8000ac6e <__mcmp>
800096ce:	c2 d5       	brlt	80009728 <quorem+0x118>
800096d0:	2f f5       	sub	r5,-1
800096d2:	08 98       	mov	r8,r4
800096d4:	30 09       	mov	r9,0
800096d6:	07 0b       	ld.w	r11,r3++
800096d8:	f6 0a 16 10 	lsr	r10,r11,0x10
800096dc:	70 0c       	ld.w	r12,r8[0x0]
800096de:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
800096e2:	f8 0e 16 10 	lsr	lr,r12,0x10
800096e6:	14 1e       	sub	lr,r10
800096e8:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
800096ec:	16 1a       	sub	r10,r11
800096ee:	12 0a       	add	r10,r9
800096f0:	b0 1a       	st.h	r8[0x2],r10
800096f2:	b1 4a       	asr	r10,0x10
800096f4:	fc 0a 00 09 	add	r9,lr,r10
800096f8:	b0 09       	st.h	r8[0x0],r9
800096fa:	2f c8       	sub	r8,-4
800096fc:	b1 49       	asr	r9,0x10
800096fe:	04 33       	cp.w	r3,r2
80009700:	fe 98 ff eb 	brls	800096d6 <quorem+0xc6>
80009704:	ec c8 ff fb 	sub	r8,r6,-5
80009708:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000970c:	58 09       	cp.w	r9,0
8000970e:	c0 d1       	brne	80009728 <quorem+0x118>
80009710:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009714:	c0 28       	rjmp	80009718 <quorem+0x108>
80009716:	20 16       	sub	r6,1
80009718:	20 48       	sub	r8,4
8000971a:	08 38       	cp.w	r8,r4
8000971c:	e0 88 00 05 	brls	80009726 <quorem+0x116>
80009720:	70 09       	ld.w	r9,r8[0x0]
80009722:	58 09       	cp.w	r9,0
80009724:	cf 90       	breq	80009716 <quorem+0x106>
80009726:	8f 46       	st.w	r7[0x10],r6
80009728:	0a 9c       	mov	r12,r5
8000972a:	2f ed       	sub	sp,-8
8000972c:	d8 32       	popm	r0-r7,pc
8000972e:	d7 03       	nop

80009730 <_dtoa_r>:
80009730:	d4 31       	pushm	r0-r7,lr
80009732:	21 ad       	sub	sp,104
80009734:	fa c4 ff 74 	sub	r4,sp,-140
80009738:	18 97       	mov	r7,r12
8000973a:	16 95       	mov	r5,r11
8000973c:	68 2c       	ld.w	r12,r4[0x8]
8000973e:	50 c9       	stdsp	sp[0x30],r9
80009740:	68 16       	ld.w	r6,r4[0x4]
80009742:	68 09       	ld.w	r9,r4[0x0]
80009744:	50 e8       	stdsp	sp[0x38],r8
80009746:	14 94       	mov	r4,r10
80009748:	51 2c       	stdsp	sp[0x48],r12
8000974a:	fa e5 00 08 	st.d	sp[8],r4
8000974e:	51 59       	stdsp	sp[0x54],r9
80009750:	6e 95       	ld.w	r5,r7[0x24]
80009752:	58 05       	cp.w	r5,0
80009754:	c0 91       	brne	80009766 <_dtoa_r+0x36>
80009756:	31 0c       	mov	r12,16
80009758:	fe b0 e8 e8 	rcall	80006928 <malloc>
8000975c:	99 35       	st.w	r12[0xc],r5
8000975e:	8f 9c       	st.w	r7[0x24],r12
80009760:	99 15       	st.w	r12[0x4],r5
80009762:	99 25       	st.w	r12[0x8],r5
80009764:	99 05       	st.w	r12[0x0],r5
80009766:	6e 99       	ld.w	r9,r7[0x24]
80009768:	72 08       	ld.w	r8,r9[0x0]
8000976a:	58 08       	cp.w	r8,0
8000976c:	c0 f0       	breq	8000978a <_dtoa_r+0x5a>
8000976e:	72 1a       	ld.w	r10,r9[0x4]
80009770:	91 1a       	st.w	r8[0x4],r10
80009772:	30 1a       	mov	r10,1
80009774:	72 19       	ld.w	r9,r9[0x4]
80009776:	f4 09 09 49 	lsl	r9,r10,r9
8000977a:	10 9b       	mov	r11,r8
8000977c:	91 29       	st.w	r8[0x8],r9
8000977e:	0e 9c       	mov	r12,r7
80009780:	e0 a0 0a 90 	rcall	8000aca0 <_Bfree>
80009784:	6e 98       	ld.w	r8,r7[0x24]
80009786:	30 09       	mov	r9,0
80009788:	91 09       	st.w	r8[0x0],r9
8000978a:	40 28       	lddsp	r8,sp[0x8]
8000978c:	10 94       	mov	r4,r8
8000978e:	58 08       	cp.w	r8,0
80009790:	c0 64       	brge	8000979c <_dtoa_r+0x6c>
80009792:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009796:	50 28       	stdsp	sp[0x8],r8
80009798:	30 18       	mov	r8,1
8000979a:	c0 28       	rjmp	8000979e <_dtoa_r+0x6e>
8000979c:	30 08       	mov	r8,0
8000979e:	8d 08       	st.w	r6[0x0],r8
800097a0:	fc 1c 7f f0 	movh	r12,0x7ff0
800097a4:	40 26       	lddsp	r6,sp[0x8]
800097a6:	0c 98       	mov	r8,r6
800097a8:	e6 18 7f f0 	andh	r8,0x7ff0,COH
800097ac:	18 38       	cp.w	r8,r12
800097ae:	c2 01       	brne	800097ee <_dtoa_r+0xbe>
800097b0:	e0 68 27 0f 	mov	r8,9999
800097b4:	41 5b       	lddsp	r11,sp[0x54]
800097b6:	97 08       	st.w	r11[0x0],r8
800097b8:	40 3a       	lddsp	r10,sp[0xc]
800097ba:	58 0a       	cp.w	r10,0
800097bc:	c0 71       	brne	800097ca <_dtoa_r+0x9a>
800097be:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
800097c2:	c0 41       	brne	800097ca <_dtoa_r+0x9a>
800097c4:	fe cc be 6c 	sub	r12,pc,-16788
800097c8:	c0 38       	rjmp	800097ce <_dtoa_r+0x9e>
800097ca:	fe cc be 66 	sub	r12,pc,-16794
800097ce:	41 29       	lddsp	r9,sp[0x48]
800097d0:	58 09       	cp.w	r9,0
800097d2:	e0 80 05 9a 	breq	8000a306 <_dtoa_r+0xbd6>
800097d6:	f8 c8 ff fd 	sub	r8,r12,-3
800097da:	f8 c9 ff f8 	sub	r9,r12,-8
800097de:	11 8b       	ld.ub	r11,r8[0x0]
800097e0:	30 0a       	mov	r10,0
800097e2:	41 25       	lddsp	r5,sp[0x48]
800097e4:	f4 0b 18 00 	cp.b	r11,r10
800097e8:	f2 08 17 10 	movne	r8,r9
800097ec:	c1 68       	rjmp	80009818 <_dtoa_r+0xe8>
800097ee:	fa ea 00 08 	ld.d	r10,sp[8]
800097f2:	30 08       	mov	r8,0
800097f4:	fa eb 00 3c 	st.d	sp[60],r10
800097f8:	30 09       	mov	r9,0
800097fa:	e0 a0 10 c2 	rcall	8000b97e <__avr32_f64_cmp_eq>
800097fe:	c1 00       	breq	8000981e <_dtoa_r+0xee>
80009800:	30 18       	mov	r8,1
80009802:	41 5a       	lddsp	r10,sp[0x54]
80009804:	95 08       	st.w	r10[0x0],r8
80009806:	fe cc bf d2 	sub	r12,pc,-16430
8000980a:	41 29       	lddsp	r9,sp[0x48]
8000980c:	f8 08 00 08 	add	r8,r12,r8
80009810:	58 09       	cp.w	r9,0
80009812:	e0 80 05 7a 	breq	8000a306 <_dtoa_r+0xbd6>
80009816:	12 95       	mov	r5,r9
80009818:	8b 08       	st.w	r5[0x0],r8
8000981a:	e0 8f 05 76 	bral	8000a306 <_dtoa_r+0xbd6>
8000981e:	fa c8 ff 9c 	sub	r8,sp,-100
80009822:	fa c9 ff a0 	sub	r9,sp,-96
80009826:	fa ea 00 3c 	ld.d	r10,sp[60]
8000982a:	0e 9c       	mov	r12,r7
8000982c:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009830:	e0 a0 0a 8a 	rcall	8000ad44 <__d2b>
80009834:	18 93       	mov	r3,r12
80009836:	58 05       	cp.w	r5,0
80009838:	c0 d0       	breq	80009852 <_dtoa_r+0x122>
8000983a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000983e:	30 04       	mov	r4,0
80009840:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009844:	ea c5 03 ff 	sub	r5,r5,1023
80009848:	10 9b       	mov	r11,r8
8000984a:	51 74       	stdsp	sp[0x5c],r4
8000984c:	ea 1b 3f f0 	orh	r11,0x3ff0
80009850:	c2 58       	rjmp	8000989a <_dtoa_r+0x16a>
80009852:	41 88       	lddsp	r8,sp[0x60]
80009854:	41 9c       	lddsp	r12,sp[0x64]
80009856:	10 0c       	add	r12,r8
80009858:	f8 c5 fb ce 	sub	r5,r12,-1074
8000985c:	e0 45 00 20 	cp.w	r5,32
80009860:	e0 8a 00 0e 	brle	8000987c <_dtoa_r+0x14c>
80009864:	f8 cc fb ee 	sub	r12,r12,-1042
80009868:	40 3b       	lddsp	r11,sp[0xc]
8000986a:	ea 08 11 40 	rsub	r8,r5,64
8000986e:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009872:	ec 08 09 46 	lsl	r6,r6,r8
80009876:	0c 4c       	or	r12,r6
80009878:	c0 78       	rjmp	80009886 <_dtoa_r+0x156>
8000987a:	d7 03       	nop
8000987c:	ea 0c 11 20 	rsub	r12,r5,32
80009880:	40 3a       	lddsp	r10,sp[0xc]
80009882:	f4 0c 09 4c 	lsl	r12,r10,r12
80009886:	e0 a0 10 08 	rcall	8000b896 <__avr32_u32_to_f64>
8000988a:	fc 18 fe 10 	movh	r8,0xfe10
8000988e:	30 19       	mov	r9,1
80009890:	ea c5 04 33 	sub	r5,r5,1075
80009894:	f0 0b 00 0b 	add	r11,r8,r11
80009898:	51 79       	stdsp	sp[0x5c],r9
8000989a:	30 08       	mov	r8,0
8000989c:	fc 19 3f f8 	movh	r9,0x3ff8
800098a0:	e0 a0 0e 90 	rcall	8000b5c0 <__avr32_f64_sub>
800098a4:	e0 68 43 61 	mov	r8,17249
800098a8:	ea 18 63 6f 	orh	r8,0x636f
800098ac:	e0 69 87 a7 	mov	r9,34727
800098b0:	ea 19 3f d2 	orh	r9,0x3fd2
800098b4:	e0 a0 0d 9a 	rcall	8000b3e8 <__avr32_f64_mul>
800098b8:	e0 68 c8 b3 	mov	r8,51379
800098bc:	ea 18 8b 60 	orh	r8,0x8b60
800098c0:	e0 69 8a 28 	mov	r9,35368
800098c4:	ea 19 3f c6 	orh	r9,0x3fc6
800098c8:	e0 a0 0f 4a 	rcall	8000b75c <__avr32_f64_add>
800098cc:	0a 9c       	mov	r12,r5
800098ce:	14 90       	mov	r0,r10
800098d0:	16 91       	mov	r1,r11
800098d2:	e0 a0 0f e6 	rcall	8000b89e <__avr32_s32_to_f64>
800098d6:	e0 68 79 fb 	mov	r8,31227
800098da:	ea 18 50 9f 	orh	r8,0x509f
800098de:	e0 69 44 13 	mov	r9,17427
800098e2:	ea 19 3f d3 	orh	r9,0x3fd3
800098e6:	e0 a0 0d 81 	rcall	8000b3e8 <__avr32_f64_mul>
800098ea:	14 98       	mov	r8,r10
800098ec:	16 99       	mov	r9,r11
800098ee:	00 9a       	mov	r10,r0
800098f0:	02 9b       	mov	r11,r1
800098f2:	e0 a0 0f 35 	rcall	8000b75c <__avr32_f64_add>
800098f6:	14 90       	mov	r0,r10
800098f8:	16 91       	mov	r1,r11
800098fa:	e0 a0 0f bb 	rcall	8000b870 <__avr32_f64_to_s32>
800098fe:	30 08       	mov	r8,0
80009900:	18 96       	mov	r6,r12
80009902:	30 09       	mov	r9,0
80009904:	00 9a       	mov	r10,r0
80009906:	02 9b       	mov	r11,r1
80009908:	e0 a0 10 82 	rcall	8000ba0c <__avr32_f64_cmp_lt>
8000990c:	c0 c0       	breq	80009924 <_dtoa_r+0x1f4>
8000990e:	0c 9c       	mov	r12,r6
80009910:	e0 a0 0f c7 	rcall	8000b89e <__avr32_s32_to_f64>
80009914:	14 98       	mov	r8,r10
80009916:	16 99       	mov	r9,r11
80009918:	00 9a       	mov	r10,r0
8000991a:	02 9b       	mov	r11,r1
8000991c:	e0 a0 10 31 	rcall	8000b97e <__avr32_f64_cmp_eq>
80009920:	f7 b6 00 01 	subeq	r6,1
80009924:	59 66       	cp.w	r6,22
80009926:	e0 88 00 05 	brls	80009930 <_dtoa_r+0x200>
8000992a:	30 18       	mov	r8,1
8000992c:	51 48       	stdsp	sp[0x50],r8
8000992e:	c1 38       	rjmp	80009954 <_dtoa_r+0x224>
80009930:	fe c8 bf 18 	sub	r8,pc,-16616
80009934:	fa ea 00 3c 	ld.d	r10,sp[60]
80009938:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000993c:	e0 a0 10 68 	rcall	8000ba0c <__avr32_f64_cmp_lt>
80009940:	f9 b4 00 00 	moveq	r4,0
80009944:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009948:	f7 b6 01 01 	subne	r6,1
8000994c:	f9 bc 01 00 	movne	r12,0
80009950:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009954:	41 90       	lddsp	r0,sp[0x64]
80009956:	20 10       	sub	r0,1
80009958:	0a 10       	sub	r0,r5
8000995a:	c0 46       	brmi	80009962 <_dtoa_r+0x232>
8000995c:	50 40       	stdsp	sp[0x10],r0
8000995e:	30 00       	mov	r0,0
80009960:	c0 48       	rjmp	80009968 <_dtoa_r+0x238>
80009962:	30 0b       	mov	r11,0
80009964:	5c 30       	neg	r0
80009966:	50 4b       	stdsp	sp[0x10],r11
80009968:	ec 02 11 00 	rsub	r2,r6,0
8000996c:	58 06       	cp.w	r6,0
8000996e:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009972:	f5 d6 e4 0a 	addge	r10,r10,r6
80009976:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000997a:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000997e:	f9 b2 04 00 	movge	r2,0
80009982:	e1 d6 e5 10 	sublt	r0,r0,r6
80009986:	f9 b9 05 00 	movlt	r9,0
8000998a:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000998e:	40 c8       	lddsp	r8,sp[0x30]
80009990:	58 98       	cp.w	r8,9
80009992:	e0 8b 00 20 	brhi	800099d2 <_dtoa_r+0x2a2>
80009996:	58 58       	cp.w	r8,5
80009998:	f9 b4 0a 01 	movle	r4,1
8000999c:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
800099a0:	f7 b5 09 04 	subgt	r5,4
800099a4:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
800099a8:	f9 b4 09 00 	movgt	r4,0
800099ac:	40 cc       	lddsp	r12,sp[0x30]
800099ae:	58 3c       	cp.w	r12,3
800099b0:	c2 d0       	breq	80009a0a <_dtoa_r+0x2da>
800099b2:	e0 89 00 05 	brgt	800099bc <_dtoa_r+0x28c>
800099b6:	58 2c       	cp.w	r12,2
800099b8:	c1 01       	brne	800099d8 <_dtoa_r+0x2a8>
800099ba:	c1 88       	rjmp	800099ea <_dtoa_r+0x2ba>
800099bc:	40 cb       	lddsp	r11,sp[0x30]
800099be:	58 4b       	cp.w	r11,4
800099c0:	c0 60       	breq	800099cc <_dtoa_r+0x29c>
800099c2:	58 5b       	cp.w	r11,5
800099c4:	c0 a1       	brne	800099d8 <_dtoa_r+0x2a8>
800099c6:	30 1a       	mov	r10,1
800099c8:	50 da       	stdsp	sp[0x34],r10
800099ca:	c2 28       	rjmp	80009a0e <_dtoa_r+0x2de>
800099cc:	30 19       	mov	r9,1
800099ce:	50 d9       	stdsp	sp[0x34],r9
800099d0:	c0 f8       	rjmp	800099ee <_dtoa_r+0x2be>
800099d2:	30 08       	mov	r8,0
800099d4:	30 14       	mov	r4,1
800099d6:	50 c8       	stdsp	sp[0x30],r8
800099d8:	3f f5       	mov	r5,-1
800099da:	30 1c       	mov	r12,1
800099dc:	30 0b       	mov	r11,0
800099de:	50 95       	stdsp	sp[0x24],r5
800099e0:	50 dc       	stdsp	sp[0x34],r12
800099e2:	0a 91       	mov	r1,r5
800099e4:	31 28       	mov	r8,18
800099e6:	50 eb       	stdsp	sp[0x38],r11
800099e8:	c2 08       	rjmp	80009a28 <_dtoa_r+0x2f8>
800099ea:	30 0a       	mov	r10,0
800099ec:	50 da       	stdsp	sp[0x34],r10
800099ee:	40 e9       	lddsp	r9,sp[0x38]
800099f0:	58 09       	cp.w	r9,0
800099f2:	e0 89 00 07 	brgt	80009a00 <_dtoa_r+0x2d0>
800099f6:	30 18       	mov	r8,1
800099f8:	50 98       	stdsp	sp[0x24],r8
800099fa:	10 91       	mov	r1,r8
800099fc:	50 e8       	stdsp	sp[0x38],r8
800099fe:	c1 58       	rjmp	80009a28 <_dtoa_r+0x2f8>
80009a00:	40 e5       	lddsp	r5,sp[0x38]
80009a02:	50 95       	stdsp	sp[0x24],r5
80009a04:	0a 91       	mov	r1,r5
80009a06:	0a 98       	mov	r8,r5
80009a08:	c1 08       	rjmp	80009a28 <_dtoa_r+0x2f8>
80009a0a:	30 0c       	mov	r12,0
80009a0c:	50 dc       	stdsp	sp[0x34],r12
80009a0e:	40 eb       	lddsp	r11,sp[0x38]
80009a10:	ec 0b 00 0b 	add	r11,r6,r11
80009a14:	50 9b       	stdsp	sp[0x24],r11
80009a16:	16 98       	mov	r8,r11
80009a18:	2f f8       	sub	r8,-1
80009a1a:	58 08       	cp.w	r8,0
80009a1c:	e0 89 00 05 	brgt	80009a26 <_dtoa_r+0x2f6>
80009a20:	10 91       	mov	r1,r8
80009a22:	30 18       	mov	r8,1
80009a24:	c0 28       	rjmp	80009a28 <_dtoa_r+0x2f8>
80009a26:	10 91       	mov	r1,r8
80009a28:	30 09       	mov	r9,0
80009a2a:	6e 9a       	ld.w	r10,r7[0x24]
80009a2c:	95 19       	st.w	r10[0x4],r9
80009a2e:	30 49       	mov	r9,4
80009a30:	c0 68       	rjmp	80009a3c <_dtoa_r+0x30c>
80009a32:	d7 03       	nop
80009a34:	6a 1a       	ld.w	r10,r5[0x4]
80009a36:	a1 79       	lsl	r9,0x1
80009a38:	2f fa       	sub	r10,-1
80009a3a:	8b 1a       	st.w	r5[0x4],r10
80009a3c:	6e 95       	ld.w	r5,r7[0x24]
80009a3e:	f2 ca ff ec 	sub	r10,r9,-20
80009a42:	10 3a       	cp.w	r10,r8
80009a44:	fe 98 ff f8 	brls	80009a34 <_dtoa_r+0x304>
80009a48:	6a 1b       	ld.w	r11,r5[0x4]
80009a4a:	0e 9c       	mov	r12,r7
80009a4c:	e0 a0 09 44 	rcall	8000acd4 <_Balloc>
80009a50:	58 e1       	cp.w	r1,14
80009a52:	5f 88       	srls	r8
80009a54:	8b 0c       	st.w	r5[0x0],r12
80009a56:	f1 e4 00 04 	and	r4,r8,r4
80009a5a:	6e 98       	ld.w	r8,r7[0x24]
80009a5c:	70 08       	ld.w	r8,r8[0x0]
80009a5e:	50 88       	stdsp	sp[0x20],r8
80009a60:	e0 80 01 82 	breq	80009d64 <_dtoa_r+0x634>
80009a64:	58 06       	cp.w	r6,0
80009a66:	e0 8a 00 43 	brle	80009aec <_dtoa_r+0x3bc>
80009a6a:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009a6e:	fe c8 c0 56 	sub	r8,pc,-16298
80009a72:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80009a76:	fa e5 00 18 	st.d	sp[24],r4
80009a7a:	ec 04 14 04 	asr	r4,r6,0x4
80009a7e:	ed b4 00 04 	bld	r4,0x4
80009a82:	c0 30       	breq	80009a88 <_dtoa_r+0x358>
80009a84:	30 25       	mov	r5,2
80009a86:	c1 08       	rjmp	80009aa6 <_dtoa_r+0x376>
80009a88:	fe c8 bf a8 	sub	r8,pc,-16472
80009a8c:	f0 e8 00 20 	ld.d	r8,r8[32]
80009a90:	fa ea 00 3c 	ld.d	r10,sp[60]
80009a94:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009a98:	e0 a0 0f ee 	rcall	8000ba74 <__avr32_f64_div>
80009a9c:	30 35       	mov	r5,3
80009a9e:	14 98       	mov	r8,r10
80009aa0:	16 99       	mov	r9,r11
80009aa2:	fa e9 00 08 	st.d	sp[8],r8
80009aa6:	fe cc bf c6 	sub	r12,pc,-16442
80009aaa:	50 a3       	stdsp	sp[0x28],r3
80009aac:	0c 93       	mov	r3,r6
80009aae:	18 96       	mov	r6,r12
80009ab0:	c0 f8       	rjmp	80009ace <_dtoa_r+0x39e>
80009ab2:	fa ea 00 18 	ld.d	r10,sp[24]
80009ab6:	ed b4 00 00 	bld	r4,0x0
80009aba:	c0 81       	brne	80009aca <_dtoa_r+0x39a>
80009abc:	ec e8 00 00 	ld.d	r8,r6[0]
80009ac0:	2f f5       	sub	r5,-1
80009ac2:	e0 a0 0c 93 	rcall	8000b3e8 <__avr32_f64_mul>
80009ac6:	fa eb 00 18 	st.d	sp[24],r10
80009aca:	a1 54       	asr	r4,0x1
80009acc:	2f 86       	sub	r6,-8
80009ace:	58 04       	cp.w	r4,0
80009ad0:	cf 11       	brne	80009ab2 <_dtoa_r+0x382>
80009ad2:	fa e8 00 18 	ld.d	r8,sp[24]
80009ad6:	fa ea 00 08 	ld.d	r10,sp[8]
80009ada:	06 96       	mov	r6,r3
80009adc:	e0 a0 0f cc 	rcall	8000ba74 <__avr32_f64_div>
80009ae0:	40 a3       	lddsp	r3,sp[0x28]
80009ae2:	14 98       	mov	r8,r10
80009ae4:	16 99       	mov	r9,r11
80009ae6:	fa e9 00 08 	st.d	sp[8],r8
80009aea:	c2 f8       	rjmp	80009b48 <_dtoa_r+0x418>
80009aec:	ec 08 11 00 	rsub	r8,r6,0
80009af0:	c0 31       	brne	80009af6 <_dtoa_r+0x3c6>
80009af2:	30 25       	mov	r5,2
80009af4:	c2 a8       	rjmp	80009b48 <_dtoa_r+0x418>
80009af6:	fe cc c0 16 	sub	r12,pc,-16362
80009afa:	f0 04 14 04 	asr	r4,r8,0x4
80009afe:	50 1c       	stdsp	sp[0x4],r12
80009b00:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009b04:	fe c9 c0 ec 	sub	r9,pc,-16148
80009b08:	fa ea 00 3c 	ld.d	r10,sp[60]
80009b0c:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009b10:	e0 a0 0c 6c 	rcall	8000b3e8 <__avr32_f64_mul>
80009b14:	40 1c       	lddsp	r12,sp[0x4]
80009b16:	50 63       	stdsp	sp[0x18],r3
80009b18:	30 25       	mov	r5,2
80009b1a:	0c 93       	mov	r3,r6
80009b1c:	fa eb 00 08 	st.d	sp[8],r10
80009b20:	18 96       	mov	r6,r12
80009b22:	c0 f8       	rjmp	80009b40 <_dtoa_r+0x410>
80009b24:	fa ea 00 08 	ld.d	r10,sp[8]
80009b28:	ed b4 00 00 	bld	r4,0x0
80009b2c:	c0 81       	brne	80009b3c <_dtoa_r+0x40c>
80009b2e:	ec e8 00 00 	ld.d	r8,r6[0]
80009b32:	2f f5       	sub	r5,-1
80009b34:	e0 a0 0c 5a 	rcall	8000b3e8 <__avr32_f64_mul>
80009b38:	fa eb 00 08 	st.d	sp[8],r10
80009b3c:	a1 54       	asr	r4,0x1
80009b3e:	2f 86       	sub	r6,-8
80009b40:	58 04       	cp.w	r4,0
80009b42:	cf 11       	brne	80009b24 <_dtoa_r+0x3f4>
80009b44:	06 96       	mov	r6,r3
80009b46:	40 63       	lddsp	r3,sp[0x18]
80009b48:	41 4a       	lddsp	r10,sp[0x50]
80009b4a:	58 0a       	cp.w	r10,0
80009b4c:	c2 a0       	breq	80009ba0 <_dtoa_r+0x470>
80009b4e:	fa e8 00 08 	ld.d	r8,sp[8]
80009b52:	58 01       	cp.w	r1,0
80009b54:	5f 94       	srgt	r4
80009b56:	fa e9 00 18 	st.d	sp[24],r8
80009b5a:	30 08       	mov	r8,0
80009b5c:	fc 19 3f f0 	movh	r9,0x3ff0
80009b60:	fa ea 00 18 	ld.d	r10,sp[24]
80009b64:	e0 a0 0f 54 	rcall	8000ba0c <__avr32_f64_cmp_lt>
80009b68:	f9 bc 00 00 	moveq	r12,0
80009b6c:	f9 bc 01 01 	movne	r12,1
80009b70:	e9 ec 00 0c 	and	r12,r4,r12
80009b74:	c1 60       	breq	80009ba0 <_dtoa_r+0x470>
80009b76:	40 98       	lddsp	r8,sp[0x24]
80009b78:	58 08       	cp.w	r8,0
80009b7a:	e0 8a 00 f1 	brle	80009d5c <_dtoa_r+0x62c>
80009b7e:	30 08       	mov	r8,0
80009b80:	fc 19 40 24 	movh	r9,0x4024
80009b84:	ec c4 00 01 	sub	r4,r6,1
80009b88:	fa ea 00 18 	ld.d	r10,sp[24]
80009b8c:	2f f5       	sub	r5,-1
80009b8e:	50 64       	stdsp	sp[0x18],r4
80009b90:	e0 a0 0c 2c 	rcall	8000b3e8 <__avr32_f64_mul>
80009b94:	40 94       	lddsp	r4,sp[0x24]
80009b96:	14 98       	mov	r8,r10
80009b98:	16 99       	mov	r9,r11
80009b9a:	fa e9 00 08 	st.d	sp[8],r8
80009b9e:	c0 38       	rjmp	80009ba4 <_dtoa_r+0x474>
80009ba0:	50 66       	stdsp	sp[0x18],r6
80009ba2:	02 94       	mov	r4,r1
80009ba4:	0a 9c       	mov	r12,r5
80009ba6:	e0 a0 0e 7c 	rcall	8000b89e <__avr32_s32_to_f64>
80009baa:	fa e8 00 08 	ld.d	r8,sp[8]
80009bae:	e0 a0 0c 1d 	rcall	8000b3e8 <__avr32_f64_mul>
80009bb2:	30 08       	mov	r8,0
80009bb4:	fc 19 40 1c 	movh	r9,0x401c
80009bb8:	e0 a0 0d d2 	rcall	8000b75c <__avr32_f64_add>
80009bbc:	14 98       	mov	r8,r10
80009bbe:	16 99       	mov	r9,r11
80009bc0:	fa e9 00 28 	st.d	sp[40],r8
80009bc4:	fc 18 fc c0 	movh	r8,0xfcc0
80009bc8:	40 a5       	lddsp	r5,sp[0x28]
80009bca:	10 05       	add	r5,r8
80009bcc:	50 a5       	stdsp	sp[0x28],r5
80009bce:	58 04       	cp.w	r4,0
80009bd0:	c2 11       	brne	80009c12 <_dtoa_r+0x4e2>
80009bd2:	fa ea 00 08 	ld.d	r10,sp[8]
80009bd6:	30 08       	mov	r8,0
80009bd8:	fc 19 40 14 	movh	r9,0x4014
80009bdc:	e0 a0 0c f2 	rcall	8000b5c0 <__avr32_f64_sub>
80009be0:	40 bc       	lddsp	r12,sp[0x2c]
80009be2:	fa eb 00 08 	st.d	sp[8],r10
80009be6:	14 98       	mov	r8,r10
80009be8:	16 99       	mov	r9,r11
80009bea:	18 9a       	mov	r10,r12
80009bec:	0a 9b       	mov	r11,r5
80009bee:	e0 a0 0f 0f 	rcall	8000ba0c <__avr32_f64_cmp_lt>
80009bf2:	e0 81 02 54 	brne	8000a09a <_dtoa_r+0x96a>
80009bf6:	0a 98       	mov	r8,r5
80009bf8:	40 b9       	lddsp	r9,sp[0x2c]
80009bfa:	ee 18 80 00 	eorh	r8,0x8000
80009bfe:	fa ea 00 08 	ld.d	r10,sp[8]
80009c02:	10 95       	mov	r5,r8
80009c04:	12 98       	mov	r8,r9
80009c06:	0a 99       	mov	r9,r5
80009c08:	e0 a0 0f 02 	rcall	8000ba0c <__avr32_f64_cmp_lt>
80009c0c:	e0 81 02 3e 	brne	8000a088 <_dtoa_r+0x958>
80009c10:	ca 68       	rjmp	80009d5c <_dtoa_r+0x62c>
80009c12:	fe c9 c1 fa 	sub	r9,pc,-15878
80009c16:	e8 c8 00 01 	sub	r8,r4,1
80009c1a:	40 d5       	lddsp	r5,sp[0x34]
80009c1c:	58 05       	cp.w	r5,0
80009c1e:	c4 f0       	breq	80009cbc <_dtoa_r+0x58c>
80009c20:	30 0c       	mov	r12,0
80009c22:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009c26:	51 3c       	stdsp	sp[0x4c],r12
80009c28:	30 0a       	mov	r10,0
80009c2a:	fc 1b 3f e0 	movh	r11,0x3fe0
80009c2e:	e0 a0 0f 23 	rcall	8000ba74 <__avr32_f64_div>
80009c32:	fa e8 00 28 	ld.d	r8,sp[40]
80009c36:	40 85       	lddsp	r5,sp[0x20]
80009c38:	e0 a0 0c c4 	rcall	8000b5c0 <__avr32_f64_sub>
80009c3c:	fa eb 00 28 	st.d	sp[40],r10
80009c40:	fa ea 00 08 	ld.d	r10,sp[8]
80009c44:	e0 a0 0e 16 	rcall	8000b870 <__avr32_f64_to_s32>
80009c48:	51 6c       	stdsp	sp[0x58],r12
80009c4a:	e0 a0 0e 2a 	rcall	8000b89e <__avr32_s32_to_f64>
80009c4e:	14 98       	mov	r8,r10
80009c50:	16 99       	mov	r9,r11
80009c52:	fa ea 00 08 	ld.d	r10,sp[8]
80009c56:	e0 a0 0c b5 	rcall	8000b5c0 <__avr32_f64_sub>
80009c5a:	fa eb 00 08 	st.d	sp[8],r10
80009c5e:	41 68       	lddsp	r8,sp[0x58]
80009c60:	2d 08       	sub	r8,-48
80009c62:	0a c8       	st.b	r5++,r8
80009c64:	41 39       	lddsp	r9,sp[0x4c]
80009c66:	2f f9       	sub	r9,-1
80009c68:	51 39       	stdsp	sp[0x4c],r9
80009c6a:	fa e8 00 28 	ld.d	r8,sp[40]
80009c6e:	e0 a0 0e cf 	rcall	8000ba0c <__avr32_f64_cmp_lt>
80009c72:	e0 81 03 39 	brne	8000a2e4 <_dtoa_r+0xbb4>
80009c76:	fa e8 00 08 	ld.d	r8,sp[8]
80009c7a:	30 0a       	mov	r10,0
80009c7c:	fc 1b 3f f0 	movh	r11,0x3ff0
80009c80:	e0 a0 0c a0 	rcall	8000b5c0 <__avr32_f64_sub>
80009c84:	fa e8 00 28 	ld.d	r8,sp[40]
80009c88:	e0 a0 0e c2 	rcall	8000ba0c <__avr32_f64_cmp_lt>
80009c8c:	fa ea 00 28 	ld.d	r10,sp[40]
80009c90:	30 08       	mov	r8,0
80009c92:	fc 19 40 24 	movh	r9,0x4024
80009c96:	e0 81 00 da 	brne	80009e4a <_dtoa_r+0x71a>
80009c9a:	41 3c       	lddsp	r12,sp[0x4c]
80009c9c:	08 3c       	cp.w	r12,r4
80009c9e:	c5 f4       	brge	80009d5c <_dtoa_r+0x62c>
80009ca0:	e0 a0 0b a4 	rcall	8000b3e8 <__avr32_f64_mul>
80009ca4:	30 08       	mov	r8,0
80009ca6:	fa eb 00 28 	st.d	sp[40],r10
80009caa:	fc 19 40 24 	movh	r9,0x4024
80009cae:	fa ea 00 08 	ld.d	r10,sp[8]
80009cb2:	e0 a0 0b 9b 	rcall	8000b3e8 <__avr32_f64_mul>
80009cb6:	fa eb 00 08 	st.d	sp[8],r10
80009cba:	cc 3b       	rjmp	80009c40 <_dtoa_r+0x510>
80009cbc:	40 85       	lddsp	r5,sp[0x20]
80009cbe:	08 05       	add	r5,r4
80009cc0:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009cc4:	51 35       	stdsp	sp[0x4c],r5
80009cc6:	fa e8 00 28 	ld.d	r8,sp[40]
80009cca:	40 85       	lddsp	r5,sp[0x20]
80009ccc:	e0 a0 0b 8e 	rcall	8000b3e8 <__avr32_f64_mul>
80009cd0:	fa eb 00 28 	st.d	sp[40],r10
80009cd4:	fa ea 00 08 	ld.d	r10,sp[8]
80009cd8:	e0 a0 0d cc 	rcall	8000b870 <__avr32_f64_to_s32>
80009cdc:	51 6c       	stdsp	sp[0x58],r12
80009cde:	e0 a0 0d e0 	rcall	8000b89e <__avr32_s32_to_f64>
80009ce2:	14 98       	mov	r8,r10
80009ce4:	16 99       	mov	r9,r11
80009ce6:	fa ea 00 08 	ld.d	r10,sp[8]
80009cea:	e0 a0 0c 6b 	rcall	8000b5c0 <__avr32_f64_sub>
80009cee:	fa eb 00 08 	st.d	sp[8],r10
80009cf2:	41 68       	lddsp	r8,sp[0x58]
80009cf4:	2d 08       	sub	r8,-48
80009cf6:	0a c8       	st.b	r5++,r8
80009cf8:	41 3c       	lddsp	r12,sp[0x4c]
80009cfa:	18 35       	cp.w	r5,r12
80009cfc:	c2 81       	brne	80009d4c <_dtoa_r+0x61c>
80009cfe:	30 08       	mov	r8,0
80009d00:	fc 19 3f e0 	movh	r9,0x3fe0
80009d04:	fa ea 00 28 	ld.d	r10,sp[40]
80009d08:	e0 a0 0d 2a 	rcall	8000b75c <__avr32_f64_add>
80009d0c:	40 85       	lddsp	r5,sp[0x20]
80009d0e:	fa e8 00 08 	ld.d	r8,sp[8]
80009d12:	08 05       	add	r5,r4
80009d14:	e0 a0 0e 7c 	rcall	8000ba0c <__avr32_f64_cmp_lt>
80009d18:	e0 81 00 99 	brne	80009e4a <_dtoa_r+0x71a>
80009d1c:	fa e8 00 28 	ld.d	r8,sp[40]
80009d20:	30 0a       	mov	r10,0
80009d22:	fc 1b 3f e0 	movh	r11,0x3fe0
80009d26:	e0 a0 0c 4d 	rcall	8000b5c0 <__avr32_f64_sub>
80009d2a:	14 98       	mov	r8,r10
80009d2c:	16 99       	mov	r9,r11
80009d2e:	fa ea 00 08 	ld.d	r10,sp[8]
80009d32:	e0 a0 0e 6d 	rcall	8000ba0c <__avr32_f64_cmp_lt>
80009d36:	c1 30       	breq	80009d5c <_dtoa_r+0x62c>
80009d38:	33 09       	mov	r9,48
80009d3a:	0a 98       	mov	r8,r5
80009d3c:	11 7a       	ld.ub	r10,--r8
80009d3e:	f2 0a 18 00 	cp.b	r10,r9
80009d42:	e0 81 02 d1 	brne	8000a2e4 <_dtoa_r+0xbb4>
80009d46:	10 95       	mov	r5,r8
80009d48:	cf 9b       	rjmp	80009d3a <_dtoa_r+0x60a>
80009d4a:	d7 03       	nop
80009d4c:	30 08       	mov	r8,0
80009d4e:	fc 19 40 24 	movh	r9,0x4024
80009d52:	e0 a0 0b 4b 	rcall	8000b3e8 <__avr32_f64_mul>
80009d56:	fa eb 00 08 	st.d	sp[8],r10
80009d5a:	cb db       	rjmp	80009cd4 <_dtoa_r+0x5a4>
80009d5c:	fa ea 00 3c 	ld.d	r10,sp[60]
80009d60:	fa eb 00 08 	st.d	sp[8],r10
80009d64:	58 e6       	cp.w	r6,14
80009d66:	5f ab       	srle	r11
80009d68:	41 8a       	lddsp	r10,sp[0x60]
80009d6a:	30 08       	mov	r8,0
80009d6c:	f4 09 11 ff 	rsub	r9,r10,-1
80009d70:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80009d74:	f0 09 18 00 	cp.b	r9,r8
80009d78:	e0 80 00 82 	breq	80009e7c <_dtoa_r+0x74c>
80009d7c:	40 ea       	lddsp	r10,sp[0x38]
80009d7e:	58 01       	cp.w	r1,0
80009d80:	5f a9       	srle	r9
80009d82:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
80009d86:	fe ca c3 6e 	sub	r10,pc,-15506
80009d8a:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
80009d8e:	fa e5 00 10 	st.d	sp[16],r4
80009d92:	f0 09 18 00 	cp.b	r9,r8
80009d96:	c1 40       	breq	80009dbe <_dtoa_r+0x68e>
80009d98:	58 01       	cp.w	r1,0
80009d9a:	e0 81 01 77 	brne	8000a088 <_dtoa_r+0x958>
80009d9e:	30 08       	mov	r8,0
80009da0:	fc 19 40 14 	movh	r9,0x4014
80009da4:	08 9a       	mov	r10,r4
80009da6:	0a 9b       	mov	r11,r5
80009da8:	e0 a0 0b 20 	rcall	8000b3e8 <__avr32_f64_mul>
80009dac:	fa e8 00 08 	ld.d	r8,sp[8]
80009db0:	e0 a0 0d fa 	rcall	8000b9a4 <__avr32_f64_cmp_ge>
80009db4:	e0 81 01 6a 	brne	8000a088 <_dtoa_r+0x958>
80009db8:	02 92       	mov	r2,r1
80009dba:	e0 8f 01 72 	bral	8000a09e <_dtoa_r+0x96e>
80009dbe:	40 85       	lddsp	r5,sp[0x20]
80009dc0:	30 14       	mov	r4,1
80009dc2:	fa e8 00 10 	ld.d	r8,sp[16]
80009dc6:	fa ea 00 08 	ld.d	r10,sp[8]
80009dca:	e0 a0 0e 55 	rcall	8000ba74 <__avr32_f64_div>
80009dce:	e0 a0 0d 51 	rcall	8000b870 <__avr32_f64_to_s32>
80009dd2:	18 92       	mov	r2,r12
80009dd4:	e0 a0 0d 65 	rcall	8000b89e <__avr32_s32_to_f64>
80009dd8:	fa e8 00 10 	ld.d	r8,sp[16]
80009ddc:	e0 a0 0b 06 	rcall	8000b3e8 <__avr32_f64_mul>
80009de0:	14 98       	mov	r8,r10
80009de2:	16 99       	mov	r9,r11
80009de4:	fa ea 00 08 	ld.d	r10,sp[8]
80009de8:	e0 a0 0b ec 	rcall	8000b5c0 <__avr32_f64_sub>
80009dec:	fa eb 00 08 	st.d	sp[8],r10
80009df0:	e4 c8 ff d0 	sub	r8,r2,-48
80009df4:	0a c8       	st.b	r5++,r8
80009df6:	fc 19 40 24 	movh	r9,0x4024
80009dfa:	30 08       	mov	r8,0
80009dfc:	02 34       	cp.w	r4,r1
80009dfe:	c3 31       	brne	80009e64 <_dtoa_r+0x734>
80009e00:	fa e8 00 08 	ld.d	r8,sp[8]
80009e04:	e0 a0 0c ac 	rcall	8000b75c <__avr32_f64_add>
80009e08:	16 91       	mov	r1,r11
80009e0a:	14 90       	mov	r0,r10
80009e0c:	14 98       	mov	r8,r10
80009e0e:	02 99       	mov	r9,r1
80009e10:	fa ea 00 10 	ld.d	r10,sp[16]
80009e14:	e0 a0 0d fc 	rcall	8000ba0c <__avr32_f64_cmp_lt>
80009e18:	c1 a1       	brne	80009e4c <_dtoa_r+0x71c>
80009e1a:	fa e8 00 10 	ld.d	r8,sp[16]
80009e1e:	00 9a       	mov	r10,r0
80009e20:	02 9b       	mov	r11,r1
80009e22:	e0 a0 0d ae 	rcall	8000b97e <__avr32_f64_cmp_eq>
80009e26:	e0 80 02 5e 	breq	8000a2e2 <_dtoa_r+0xbb2>
80009e2a:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80009e2e:	c0 f1       	brne	80009e4c <_dtoa_r+0x71c>
80009e30:	e0 8f 02 59 	bral	8000a2e2 <_dtoa_r+0xbb2>
80009e34:	40 8a       	lddsp	r10,sp[0x20]
80009e36:	14 38       	cp.w	r8,r10
80009e38:	c0 30       	breq	80009e3e <_dtoa_r+0x70e>
80009e3a:	10 95       	mov	r5,r8
80009e3c:	c0 98       	rjmp	80009e4e <_dtoa_r+0x71e>
80009e3e:	33 08       	mov	r8,48
80009e40:	40 89       	lddsp	r9,sp[0x20]
80009e42:	2f f6       	sub	r6,-1
80009e44:	b2 88       	st.b	r9[0x0],r8
80009e46:	40 88       	lddsp	r8,sp[0x20]
80009e48:	c0 88       	rjmp	80009e58 <_dtoa_r+0x728>
80009e4a:	40 66       	lddsp	r6,sp[0x18]
80009e4c:	33 99       	mov	r9,57
80009e4e:	0a 98       	mov	r8,r5
80009e50:	11 7a       	ld.ub	r10,--r8
80009e52:	f2 0a 18 00 	cp.b	r10,r9
80009e56:	ce f0       	breq	80009e34 <_dtoa_r+0x704>
80009e58:	50 66       	stdsp	sp[0x18],r6
80009e5a:	11 89       	ld.ub	r9,r8[0x0]
80009e5c:	2f f9       	sub	r9,-1
80009e5e:	b0 89       	st.b	r8[0x0],r9
80009e60:	e0 8f 02 42 	bral	8000a2e4 <_dtoa_r+0xbb4>
80009e64:	e0 a0 0a c2 	rcall	8000b3e8 <__avr32_f64_mul>
80009e68:	2f f4       	sub	r4,-1
80009e6a:	fa eb 00 08 	st.d	sp[8],r10
80009e6e:	30 08       	mov	r8,0
80009e70:	30 09       	mov	r9,0
80009e72:	e0 a0 0d 86 	rcall	8000b97e <__avr32_f64_cmp_eq>
80009e76:	ca 60       	breq	80009dc2 <_dtoa_r+0x692>
80009e78:	e0 8f 02 35 	bral	8000a2e2 <_dtoa_r+0xbb2>
80009e7c:	40 d8       	lddsp	r8,sp[0x34]
80009e7e:	58 08       	cp.w	r8,0
80009e80:	c0 51       	brne	80009e8a <_dtoa_r+0x75a>
80009e82:	04 98       	mov	r8,r2
80009e84:	00 95       	mov	r5,r0
80009e86:	40 d4       	lddsp	r4,sp[0x34]
80009e88:	c3 78       	rjmp	80009ef6 <_dtoa_r+0x7c6>
80009e8a:	40 c5       	lddsp	r5,sp[0x30]
80009e8c:	58 15       	cp.w	r5,1
80009e8e:	e0 89 00 0f 	brgt	80009eac <_dtoa_r+0x77c>
80009e92:	41 74       	lddsp	r4,sp[0x5c]
80009e94:	58 04       	cp.w	r4,0
80009e96:	c0 40       	breq	80009e9e <_dtoa_r+0x76e>
80009e98:	f4 c9 fb cd 	sub	r9,r10,-1075
80009e9c:	c0 48       	rjmp	80009ea4 <_dtoa_r+0x774>
80009e9e:	41 99       	lddsp	r9,sp[0x64]
80009ea0:	f2 09 11 36 	rsub	r9,r9,54
80009ea4:	04 98       	mov	r8,r2
80009ea6:	00 95       	mov	r5,r0
80009ea8:	c1 c8       	rjmp	80009ee0 <_dtoa_r+0x7b0>
80009eaa:	d7 03       	nop
80009eac:	e2 c8 00 01 	sub	r8,r1,1
80009eb0:	58 01       	cp.w	r1,0
80009eb2:	e0 05 17 40 	movge	r5,r0
80009eb6:	e2 09 17 40 	movge	r9,r1
80009eba:	e1 d1 e5 15 	sublt	r5,r0,r1
80009ebe:	f9 b9 05 00 	movlt	r9,0
80009ec2:	10 32       	cp.w	r2,r8
80009ec4:	e5 d8 e4 18 	subge	r8,r2,r8
80009ec8:	f1 d2 e5 18 	sublt	r8,r8,r2
80009ecc:	e5 d8 e5 02 	addlt	r2,r2,r8
80009ed0:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80009ed4:	f9 d8 e5 0c 	addlt	r12,r12,r8
80009ed8:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80009edc:	f9 b8 05 00 	movlt	r8,0
80009ee0:	40 4b       	lddsp	r11,sp[0x10]
80009ee2:	12 0b       	add	r11,r9
80009ee4:	50 08       	stdsp	sp[0x0],r8
80009ee6:	50 4b       	stdsp	sp[0x10],r11
80009ee8:	12 00       	add	r0,r9
80009eea:	30 1b       	mov	r11,1
80009eec:	0e 9c       	mov	r12,r7
80009eee:	e0 a0 08 a7 	rcall	8000b03c <__i2b>
80009ef2:	40 08       	lddsp	r8,sp[0x0]
80009ef4:	18 94       	mov	r4,r12
80009ef6:	40 4a       	lddsp	r10,sp[0x10]
80009ef8:	58 05       	cp.w	r5,0
80009efa:	5f 99       	srgt	r9
80009efc:	58 0a       	cp.w	r10,0
80009efe:	5f 9a       	srgt	r10
80009f00:	f5 e9 00 09 	and	r9,r10,r9
80009f04:	c0 80       	breq	80009f14 <_dtoa_r+0x7e4>
80009f06:	40 4c       	lddsp	r12,sp[0x10]
80009f08:	f8 05 0d 49 	min	r9,r12,r5
80009f0c:	12 1c       	sub	r12,r9
80009f0e:	12 10       	sub	r0,r9
80009f10:	50 4c       	stdsp	sp[0x10],r12
80009f12:	12 15       	sub	r5,r9
80009f14:	58 02       	cp.w	r2,0
80009f16:	e0 8a 00 27 	brle	80009f64 <_dtoa_r+0x834>
80009f1a:	40 db       	lddsp	r11,sp[0x34]
80009f1c:	58 0b       	cp.w	r11,0
80009f1e:	c1 d0       	breq	80009f58 <_dtoa_r+0x828>
80009f20:	58 08       	cp.w	r8,0
80009f22:	e0 8a 00 17 	brle	80009f50 <_dtoa_r+0x820>
80009f26:	10 9a       	mov	r10,r8
80009f28:	50 08       	stdsp	sp[0x0],r8
80009f2a:	08 9b       	mov	r11,r4
80009f2c:	0e 9c       	mov	r12,r7
80009f2e:	e0 a0 08 cd 	rcall	8000b0c8 <__pow5mult>
80009f32:	06 9a       	mov	r10,r3
80009f34:	18 9b       	mov	r11,r12
80009f36:	18 94       	mov	r4,r12
80009f38:	0e 9c       	mov	r12,r7
80009f3a:	e0 a0 08 01 	rcall	8000af3c <__multiply>
80009f3e:	18 99       	mov	r9,r12
80009f40:	06 9b       	mov	r11,r3
80009f42:	50 19       	stdsp	sp[0x4],r9
80009f44:	0e 9c       	mov	r12,r7
80009f46:	e0 a0 06 ad 	rcall	8000aca0 <_Bfree>
80009f4a:	40 19       	lddsp	r9,sp[0x4]
80009f4c:	40 08       	lddsp	r8,sp[0x0]
80009f4e:	12 93       	mov	r3,r9
80009f50:	e4 08 01 0a 	sub	r10,r2,r8
80009f54:	c0 80       	breq	80009f64 <_dtoa_r+0x834>
80009f56:	c0 28       	rjmp	80009f5a <_dtoa_r+0x82a>
80009f58:	04 9a       	mov	r10,r2
80009f5a:	06 9b       	mov	r11,r3
80009f5c:	0e 9c       	mov	r12,r7
80009f5e:	e0 a0 08 b5 	rcall	8000b0c8 <__pow5mult>
80009f62:	18 93       	mov	r3,r12
80009f64:	30 1b       	mov	r11,1
80009f66:	0e 9c       	mov	r12,r7
80009f68:	e0 a0 08 6a 	rcall	8000b03c <__i2b>
80009f6c:	41 1a       	lddsp	r10,sp[0x44]
80009f6e:	18 92       	mov	r2,r12
80009f70:	58 0a       	cp.w	r10,0
80009f72:	e0 8a 00 07 	brle	80009f80 <_dtoa_r+0x850>
80009f76:	18 9b       	mov	r11,r12
80009f78:	0e 9c       	mov	r12,r7
80009f7a:	e0 a0 08 a7 	rcall	8000b0c8 <__pow5mult>
80009f7e:	18 92       	mov	r2,r12
80009f80:	40 c9       	lddsp	r9,sp[0x30]
80009f82:	58 19       	cp.w	r9,1
80009f84:	e0 89 00 14 	brgt	80009fac <_dtoa_r+0x87c>
80009f88:	40 38       	lddsp	r8,sp[0xc]
80009f8a:	58 08       	cp.w	r8,0
80009f8c:	c1 01       	brne	80009fac <_dtoa_r+0x87c>
80009f8e:	40 29       	lddsp	r9,sp[0x8]
80009f90:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80009f94:	c0 c1       	brne	80009fac <_dtoa_r+0x87c>
80009f96:	12 98       	mov	r8,r9
80009f98:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009f9c:	c0 80       	breq	80009fac <_dtoa_r+0x87c>
80009f9e:	40 4c       	lddsp	r12,sp[0x10]
80009fa0:	30 1b       	mov	r11,1
80009fa2:	2f fc       	sub	r12,-1
80009fa4:	2f f0       	sub	r0,-1
80009fa6:	50 4c       	stdsp	sp[0x10],r12
80009fa8:	50 6b       	stdsp	sp[0x18],r11
80009faa:	c0 38       	rjmp	80009fb0 <_dtoa_r+0x880>
80009fac:	30 0a       	mov	r10,0
80009fae:	50 6a       	stdsp	sp[0x18],r10
80009fb0:	41 19       	lddsp	r9,sp[0x44]
80009fb2:	58 09       	cp.w	r9,0
80009fb4:	c0 31       	brne	80009fba <_dtoa_r+0x88a>
80009fb6:	30 1c       	mov	r12,1
80009fb8:	c0 98       	rjmp	80009fca <_dtoa_r+0x89a>
80009fba:	64 48       	ld.w	r8,r2[0x10]
80009fbc:	2f c8       	sub	r8,-4
80009fbe:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
80009fc2:	e0 a0 05 df 	rcall	8000ab80 <__hi0bits>
80009fc6:	f8 0c 11 20 	rsub	r12,r12,32
80009fca:	40 4b       	lddsp	r11,sp[0x10]
80009fcc:	f8 0b 00 08 	add	r8,r12,r11
80009fd0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80009fd4:	c0 c0       	breq	80009fec <_dtoa_r+0x8bc>
80009fd6:	f0 08 11 20 	rsub	r8,r8,32
80009fda:	58 48       	cp.w	r8,4
80009fdc:	e0 8a 00 06 	brle	80009fe8 <_dtoa_r+0x8b8>
80009fe0:	20 48       	sub	r8,4
80009fe2:	10 0b       	add	r11,r8
80009fe4:	50 4b       	stdsp	sp[0x10],r11
80009fe6:	c0 78       	rjmp	80009ff4 <_dtoa_r+0x8c4>
80009fe8:	58 48       	cp.w	r8,4
80009fea:	c0 70       	breq	80009ff8 <_dtoa_r+0x8c8>
80009fec:	40 4a       	lddsp	r10,sp[0x10]
80009fee:	2e 48       	sub	r8,-28
80009ff0:	10 0a       	add	r10,r8
80009ff2:	50 4a       	stdsp	sp[0x10],r10
80009ff4:	10 00       	add	r0,r8
80009ff6:	10 05       	add	r5,r8
80009ff8:	58 00       	cp.w	r0,0
80009ffa:	e0 8a 00 08 	brle	8000a00a <_dtoa_r+0x8da>
80009ffe:	06 9b       	mov	r11,r3
8000a000:	00 9a       	mov	r10,r0
8000a002:	0e 9c       	mov	r12,r7
8000a004:	e0 a0 07 58 	rcall	8000aeb4 <__lshift>
8000a008:	18 93       	mov	r3,r12
8000a00a:	40 49       	lddsp	r9,sp[0x10]
8000a00c:	58 09       	cp.w	r9,0
8000a00e:	e0 8a 00 08 	brle	8000a01e <_dtoa_r+0x8ee>
8000a012:	04 9b       	mov	r11,r2
8000a014:	12 9a       	mov	r10,r9
8000a016:	0e 9c       	mov	r12,r7
8000a018:	e0 a0 07 4e 	rcall	8000aeb4 <__lshift>
8000a01c:	18 92       	mov	r2,r12
8000a01e:	41 48       	lddsp	r8,sp[0x50]
8000a020:	58 08       	cp.w	r8,0
8000a022:	c1 b0       	breq	8000a058 <_dtoa_r+0x928>
8000a024:	04 9b       	mov	r11,r2
8000a026:	06 9c       	mov	r12,r3
8000a028:	e0 a0 06 23 	rcall	8000ac6e <__mcmp>
8000a02c:	c1 64       	brge	8000a058 <_dtoa_r+0x928>
8000a02e:	06 9b       	mov	r11,r3
8000a030:	30 09       	mov	r9,0
8000a032:	30 aa       	mov	r10,10
8000a034:	0e 9c       	mov	r12,r7
8000a036:	e0 a0 08 0b 	rcall	8000b04c <__multadd>
8000a03a:	20 16       	sub	r6,1
8000a03c:	18 93       	mov	r3,r12
8000a03e:	40 dc       	lddsp	r12,sp[0x34]
8000a040:	58 0c       	cp.w	r12,0
8000a042:	c0 31       	brne	8000a048 <_dtoa_r+0x918>
8000a044:	40 91       	lddsp	r1,sp[0x24]
8000a046:	c0 98       	rjmp	8000a058 <_dtoa_r+0x928>
8000a048:	08 9b       	mov	r11,r4
8000a04a:	40 91       	lddsp	r1,sp[0x24]
8000a04c:	30 09       	mov	r9,0
8000a04e:	30 aa       	mov	r10,10
8000a050:	0e 9c       	mov	r12,r7
8000a052:	e0 a0 07 fd 	rcall	8000b04c <__multadd>
8000a056:	18 94       	mov	r4,r12
8000a058:	58 01       	cp.w	r1,0
8000a05a:	5f a9       	srle	r9
8000a05c:	40 cb       	lddsp	r11,sp[0x30]
8000a05e:	58 2b       	cp.w	r11,2
8000a060:	5f 98       	srgt	r8
8000a062:	f3 e8 00 08 	and	r8,r9,r8
8000a066:	c2 50       	breq	8000a0b0 <_dtoa_r+0x980>
8000a068:	58 01       	cp.w	r1,0
8000a06a:	c1 11       	brne	8000a08c <_dtoa_r+0x95c>
8000a06c:	04 9b       	mov	r11,r2
8000a06e:	02 99       	mov	r9,r1
8000a070:	30 5a       	mov	r10,5
8000a072:	0e 9c       	mov	r12,r7
8000a074:	e0 a0 07 ec 	rcall	8000b04c <__multadd>
8000a078:	18 92       	mov	r2,r12
8000a07a:	18 9b       	mov	r11,r12
8000a07c:	06 9c       	mov	r12,r3
8000a07e:	e0 a0 05 f8 	rcall	8000ac6e <__mcmp>
8000a082:	e0 89 00 0f 	brgt	8000a0a0 <_dtoa_r+0x970>
8000a086:	c0 38       	rjmp	8000a08c <_dtoa_r+0x95c>
8000a088:	30 02       	mov	r2,0
8000a08a:	04 94       	mov	r4,r2
8000a08c:	40 ea       	lddsp	r10,sp[0x38]
8000a08e:	30 09       	mov	r9,0
8000a090:	5c da       	com	r10
8000a092:	40 85       	lddsp	r5,sp[0x20]
8000a094:	50 6a       	stdsp	sp[0x18],r10
8000a096:	50 49       	stdsp	sp[0x10],r9
8000a098:	c0 f9       	rjmp	8000a2b6 <_dtoa_r+0xb86>
8000a09a:	08 92       	mov	r2,r4
8000a09c:	40 66       	lddsp	r6,sp[0x18]
8000a09e:	04 94       	mov	r4,r2
8000a0a0:	2f f6       	sub	r6,-1
8000a0a2:	50 66       	stdsp	sp[0x18],r6
8000a0a4:	33 18       	mov	r8,49
8000a0a6:	40 85       	lddsp	r5,sp[0x20]
8000a0a8:	0a c8       	st.b	r5++,r8
8000a0aa:	30 08       	mov	r8,0
8000a0ac:	50 48       	stdsp	sp[0x10],r8
8000a0ae:	c0 49       	rjmp	8000a2b6 <_dtoa_r+0xb86>
8000a0b0:	40 dc       	lddsp	r12,sp[0x34]
8000a0b2:	58 0c       	cp.w	r12,0
8000a0b4:	e0 80 00 b5 	breq	8000a21e <_dtoa_r+0xaee>
8000a0b8:	58 05       	cp.w	r5,0
8000a0ba:	e0 8a 00 08 	brle	8000a0ca <_dtoa_r+0x99a>
8000a0be:	08 9b       	mov	r11,r4
8000a0c0:	0a 9a       	mov	r10,r5
8000a0c2:	0e 9c       	mov	r12,r7
8000a0c4:	e0 a0 06 f8 	rcall	8000aeb4 <__lshift>
8000a0c8:	18 94       	mov	r4,r12
8000a0ca:	40 6b       	lddsp	r11,sp[0x18]
8000a0cc:	58 0b       	cp.w	r11,0
8000a0ce:	c0 31       	brne	8000a0d4 <_dtoa_r+0x9a4>
8000a0d0:	08 9c       	mov	r12,r4
8000a0d2:	c1 38       	rjmp	8000a0f8 <_dtoa_r+0x9c8>
8000a0d4:	68 1b       	ld.w	r11,r4[0x4]
8000a0d6:	0e 9c       	mov	r12,r7
8000a0d8:	e0 a0 05 fe 	rcall	8000acd4 <_Balloc>
8000a0dc:	68 4a       	ld.w	r10,r4[0x10]
8000a0de:	18 95       	mov	r5,r12
8000a0e0:	e8 cb ff f4 	sub	r11,r4,-12
8000a0e4:	2f ea       	sub	r10,-2
8000a0e6:	2f 4c       	sub	r12,-12
8000a0e8:	a3 6a       	lsl	r10,0x2
8000a0ea:	fe b0 e6 43 	rcall	80006d70 <memcpy>
8000a0ee:	0a 9b       	mov	r11,r5
8000a0f0:	30 1a       	mov	r10,1
8000a0f2:	0e 9c       	mov	r12,r7
8000a0f4:	e0 a0 06 e0 	rcall	8000aeb4 <__lshift>
8000a0f8:	50 44       	stdsp	sp[0x10],r4
8000a0fa:	40 3a       	lddsp	r10,sp[0xc]
8000a0fc:	30 19       	mov	r9,1
8000a0fe:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a102:	18 94       	mov	r4,r12
8000a104:	50 da       	stdsp	sp[0x34],r10
8000a106:	40 85       	lddsp	r5,sp[0x20]
8000a108:	50 99       	stdsp	sp[0x24],r9
8000a10a:	50 26       	stdsp	sp[0x8],r6
8000a10c:	50 e1       	stdsp	sp[0x38],r1
8000a10e:	04 9b       	mov	r11,r2
8000a110:	06 9c       	mov	r12,r3
8000a112:	fe b0 fa 7f 	rcall	80009610 <quorem>
8000a116:	40 4b       	lddsp	r11,sp[0x10]
8000a118:	f8 c0 ff d0 	sub	r0,r12,-48
8000a11c:	06 9c       	mov	r12,r3
8000a11e:	e0 a0 05 a8 	rcall	8000ac6e <__mcmp>
8000a122:	08 9a       	mov	r10,r4
8000a124:	50 6c       	stdsp	sp[0x18],r12
8000a126:	04 9b       	mov	r11,r2
8000a128:	0e 9c       	mov	r12,r7
8000a12a:	e0 a0 06 5d 	rcall	8000ade4 <__mdiff>
8000a12e:	18 91       	mov	r1,r12
8000a130:	78 38       	ld.w	r8,r12[0xc]
8000a132:	58 08       	cp.w	r8,0
8000a134:	c0 30       	breq	8000a13a <_dtoa_r+0xa0a>
8000a136:	30 16       	mov	r6,1
8000a138:	c0 68       	rjmp	8000a144 <_dtoa_r+0xa14>
8000a13a:	18 9b       	mov	r11,r12
8000a13c:	06 9c       	mov	r12,r3
8000a13e:	e0 a0 05 98 	rcall	8000ac6e <__mcmp>
8000a142:	18 96       	mov	r6,r12
8000a144:	0e 9c       	mov	r12,r7
8000a146:	02 9b       	mov	r11,r1
8000a148:	e0 a0 05 ac 	rcall	8000aca0 <_Bfree>
8000a14c:	40 cc       	lddsp	r12,sp[0x30]
8000a14e:	ed ec 10 08 	or	r8,r6,r12
8000a152:	c0 d1       	brne	8000a16c <_dtoa_r+0xa3c>
8000a154:	40 db       	lddsp	r11,sp[0x34]
8000a156:	58 0b       	cp.w	r11,0
8000a158:	c0 a1       	brne	8000a16c <_dtoa_r+0xa3c>
8000a15a:	40 26       	lddsp	r6,sp[0x8]
8000a15c:	e0 40 00 39 	cp.w	r0,57
8000a160:	c3 00       	breq	8000a1c0 <_dtoa_r+0xa90>
8000a162:	40 6a       	lddsp	r10,sp[0x18]
8000a164:	58 0a       	cp.w	r10,0
8000a166:	e0 89 00 24 	brgt	8000a1ae <_dtoa_r+0xa7e>
8000a16a:	c2 f8       	rjmp	8000a1c8 <_dtoa_r+0xa98>
8000a16c:	40 69       	lddsp	r9,sp[0x18]
8000a16e:	58 09       	cp.w	r9,0
8000a170:	c0 85       	brlt	8000a180 <_dtoa_r+0xa50>
8000a172:	12 98       	mov	r8,r9
8000a174:	40 cc       	lddsp	r12,sp[0x30]
8000a176:	18 48       	or	r8,r12
8000a178:	c1 d1       	brne	8000a1b2 <_dtoa_r+0xa82>
8000a17a:	40 db       	lddsp	r11,sp[0x34]
8000a17c:	58 0b       	cp.w	r11,0
8000a17e:	c1 a1       	brne	8000a1b2 <_dtoa_r+0xa82>
8000a180:	0c 99       	mov	r9,r6
8000a182:	40 26       	lddsp	r6,sp[0x8]
8000a184:	58 09       	cp.w	r9,0
8000a186:	e0 8a 00 21 	brle	8000a1c8 <_dtoa_r+0xa98>
8000a18a:	06 9b       	mov	r11,r3
8000a18c:	30 1a       	mov	r10,1
8000a18e:	0e 9c       	mov	r12,r7
8000a190:	e0 a0 06 92 	rcall	8000aeb4 <__lshift>
8000a194:	04 9b       	mov	r11,r2
8000a196:	18 93       	mov	r3,r12
8000a198:	e0 a0 05 6b 	rcall	8000ac6e <__mcmp>
8000a19c:	e0 89 00 06 	brgt	8000a1a8 <_dtoa_r+0xa78>
8000a1a0:	c1 41       	brne	8000a1c8 <_dtoa_r+0xa98>
8000a1a2:	ed b0 00 00 	bld	r0,0x0
8000a1a6:	c1 11       	brne	8000a1c8 <_dtoa_r+0xa98>
8000a1a8:	e0 40 00 39 	cp.w	r0,57
8000a1ac:	c0 a0       	breq	8000a1c0 <_dtoa_r+0xa90>
8000a1ae:	2f f0       	sub	r0,-1
8000a1b0:	c0 c8       	rjmp	8000a1c8 <_dtoa_r+0xa98>
8000a1b2:	58 06       	cp.w	r6,0
8000a1b4:	e0 8a 00 0c 	brle	8000a1cc <_dtoa_r+0xa9c>
8000a1b8:	40 26       	lddsp	r6,sp[0x8]
8000a1ba:	e0 40 00 39 	cp.w	r0,57
8000a1be:	c0 41       	brne	8000a1c6 <_dtoa_r+0xa96>
8000a1c0:	33 98       	mov	r8,57
8000a1c2:	0a c8       	st.b	r5++,r8
8000a1c4:	c6 78       	rjmp	8000a292 <_dtoa_r+0xb62>
8000a1c6:	2f f0       	sub	r0,-1
8000a1c8:	0a c0       	st.b	r5++,r0
8000a1ca:	c7 58       	rjmp	8000a2b4 <_dtoa_r+0xb84>
8000a1cc:	0a c0       	st.b	r5++,r0
8000a1ce:	40 9a       	lddsp	r10,sp[0x24]
8000a1d0:	40 e9       	lddsp	r9,sp[0x38]
8000a1d2:	12 3a       	cp.w	r10,r9
8000a1d4:	c4 30       	breq	8000a25a <_dtoa_r+0xb2a>
8000a1d6:	06 9b       	mov	r11,r3
8000a1d8:	30 09       	mov	r9,0
8000a1da:	30 aa       	mov	r10,10
8000a1dc:	0e 9c       	mov	r12,r7
8000a1de:	e0 a0 07 37 	rcall	8000b04c <__multadd>
8000a1e2:	40 48       	lddsp	r8,sp[0x10]
8000a1e4:	18 93       	mov	r3,r12
8000a1e6:	08 38       	cp.w	r8,r4
8000a1e8:	c0 91       	brne	8000a1fa <_dtoa_r+0xaca>
8000a1ea:	10 9b       	mov	r11,r8
8000a1ec:	30 09       	mov	r9,0
8000a1ee:	30 aa       	mov	r10,10
8000a1f0:	0e 9c       	mov	r12,r7
8000a1f2:	e0 a0 07 2d 	rcall	8000b04c <__multadd>
8000a1f6:	50 4c       	stdsp	sp[0x10],r12
8000a1f8:	c0 e8       	rjmp	8000a214 <_dtoa_r+0xae4>
8000a1fa:	40 4b       	lddsp	r11,sp[0x10]
8000a1fc:	30 09       	mov	r9,0
8000a1fe:	30 aa       	mov	r10,10
8000a200:	0e 9c       	mov	r12,r7
8000a202:	e0 a0 07 25 	rcall	8000b04c <__multadd>
8000a206:	08 9b       	mov	r11,r4
8000a208:	50 4c       	stdsp	sp[0x10],r12
8000a20a:	30 09       	mov	r9,0
8000a20c:	30 aa       	mov	r10,10
8000a20e:	0e 9c       	mov	r12,r7
8000a210:	e0 a0 07 1e 	rcall	8000b04c <__multadd>
8000a214:	18 94       	mov	r4,r12
8000a216:	40 9c       	lddsp	r12,sp[0x24]
8000a218:	2f fc       	sub	r12,-1
8000a21a:	50 9c       	stdsp	sp[0x24],r12
8000a21c:	c7 9b       	rjmp	8000a10e <_dtoa_r+0x9de>
8000a21e:	30 18       	mov	r8,1
8000a220:	06 90       	mov	r0,r3
8000a222:	40 85       	lddsp	r5,sp[0x20]
8000a224:	08 93       	mov	r3,r4
8000a226:	0c 94       	mov	r4,r6
8000a228:	10 96       	mov	r6,r8
8000a22a:	04 9b       	mov	r11,r2
8000a22c:	00 9c       	mov	r12,r0
8000a22e:	fe b0 f9 f1 	rcall	80009610 <quorem>
8000a232:	2d 0c       	sub	r12,-48
8000a234:	0a cc       	st.b	r5++,r12
8000a236:	02 36       	cp.w	r6,r1
8000a238:	c0 a4       	brge	8000a24c <_dtoa_r+0xb1c>
8000a23a:	00 9b       	mov	r11,r0
8000a23c:	30 09       	mov	r9,0
8000a23e:	30 aa       	mov	r10,10
8000a240:	0e 9c       	mov	r12,r7
8000a242:	2f f6       	sub	r6,-1
8000a244:	e0 a0 07 04 	rcall	8000b04c <__multadd>
8000a248:	18 90       	mov	r0,r12
8000a24a:	cf 0b       	rjmp	8000a22a <_dtoa_r+0xafa>
8000a24c:	08 96       	mov	r6,r4
8000a24e:	30 0b       	mov	r11,0
8000a250:	06 94       	mov	r4,r3
8000a252:	50 4b       	stdsp	sp[0x10],r11
8000a254:	00 93       	mov	r3,r0
8000a256:	18 90       	mov	r0,r12
8000a258:	c0 28       	rjmp	8000a25c <_dtoa_r+0xb2c>
8000a25a:	40 26       	lddsp	r6,sp[0x8]
8000a25c:	06 9b       	mov	r11,r3
8000a25e:	30 1a       	mov	r10,1
8000a260:	0e 9c       	mov	r12,r7
8000a262:	e0 a0 06 29 	rcall	8000aeb4 <__lshift>
8000a266:	04 9b       	mov	r11,r2
8000a268:	18 93       	mov	r3,r12
8000a26a:	e0 a0 05 02 	rcall	8000ac6e <__mcmp>
8000a26e:	e0 89 00 12 	brgt	8000a292 <_dtoa_r+0xb62>
8000a272:	c1 b1       	brne	8000a2a8 <_dtoa_r+0xb78>
8000a274:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a278:	c0 d1       	brne	8000a292 <_dtoa_r+0xb62>
8000a27a:	c1 78       	rjmp	8000a2a8 <_dtoa_r+0xb78>
8000a27c:	40 89       	lddsp	r9,sp[0x20]
8000a27e:	12 38       	cp.w	r8,r9
8000a280:	c0 30       	breq	8000a286 <_dtoa_r+0xb56>
8000a282:	10 95       	mov	r5,r8
8000a284:	c0 88       	rjmp	8000a294 <_dtoa_r+0xb64>
8000a286:	2f f6       	sub	r6,-1
8000a288:	50 66       	stdsp	sp[0x18],r6
8000a28a:	33 18       	mov	r8,49
8000a28c:	40 8c       	lddsp	r12,sp[0x20]
8000a28e:	b8 88       	st.b	r12[0x0],r8
8000a290:	c1 38       	rjmp	8000a2b6 <_dtoa_r+0xb86>
8000a292:	33 9a       	mov	r10,57
8000a294:	0a 98       	mov	r8,r5
8000a296:	11 79       	ld.ub	r9,--r8
8000a298:	f4 09 18 00 	cp.b	r9,r10
8000a29c:	cf 00       	breq	8000a27c <_dtoa_r+0xb4c>
8000a29e:	2f f9       	sub	r9,-1
8000a2a0:	b0 89       	st.b	r8[0x0],r9
8000a2a2:	c0 98       	rjmp	8000a2b4 <_dtoa_r+0xb84>
8000a2a4:	10 95       	mov	r5,r8
8000a2a6:	c0 28       	rjmp	8000a2aa <_dtoa_r+0xb7a>
8000a2a8:	33 09       	mov	r9,48
8000a2aa:	0a 98       	mov	r8,r5
8000a2ac:	11 7a       	ld.ub	r10,--r8
8000a2ae:	f2 0a 18 00 	cp.b	r10,r9
8000a2b2:	cf 90       	breq	8000a2a4 <_dtoa_r+0xb74>
8000a2b4:	50 66       	stdsp	sp[0x18],r6
8000a2b6:	04 9b       	mov	r11,r2
8000a2b8:	0e 9c       	mov	r12,r7
8000a2ba:	e0 a0 04 f3 	rcall	8000aca0 <_Bfree>
8000a2be:	58 04       	cp.w	r4,0
8000a2c0:	c1 20       	breq	8000a2e4 <_dtoa_r+0xbb4>
8000a2c2:	40 4b       	lddsp	r11,sp[0x10]
8000a2c4:	08 3b       	cp.w	r11,r4
8000a2c6:	5f 19       	srne	r9
8000a2c8:	58 0b       	cp.w	r11,0
8000a2ca:	5f 18       	srne	r8
8000a2cc:	f3 e8 00 08 	and	r8,r9,r8
8000a2d0:	c0 40       	breq	8000a2d8 <_dtoa_r+0xba8>
8000a2d2:	0e 9c       	mov	r12,r7
8000a2d4:	e0 a0 04 e6 	rcall	8000aca0 <_Bfree>
8000a2d8:	08 9b       	mov	r11,r4
8000a2da:	0e 9c       	mov	r12,r7
8000a2dc:	e0 a0 04 e2 	rcall	8000aca0 <_Bfree>
8000a2e0:	c0 28       	rjmp	8000a2e4 <_dtoa_r+0xbb4>
8000a2e2:	50 66       	stdsp	sp[0x18],r6
8000a2e4:	0e 9c       	mov	r12,r7
8000a2e6:	06 9b       	mov	r11,r3
8000a2e8:	e0 a0 04 dc 	rcall	8000aca0 <_Bfree>
8000a2ec:	30 08       	mov	r8,0
8000a2ee:	aa 88       	st.b	r5[0x0],r8
8000a2f0:	40 68       	lddsp	r8,sp[0x18]
8000a2f2:	41 5a       	lddsp	r10,sp[0x54]
8000a2f4:	2f f8       	sub	r8,-1
8000a2f6:	41 29       	lddsp	r9,sp[0x48]
8000a2f8:	95 08       	st.w	r10[0x0],r8
8000a2fa:	40 8c       	lddsp	r12,sp[0x20]
8000a2fc:	58 09       	cp.w	r9,0
8000a2fe:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a302:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a306:	2e 6d       	sub	sp,-104
8000a308:	d8 32       	popm	r0-r7,pc
8000a30a:	d7 03       	nop

8000a30c <__errno>:
8000a30c:	e0 68 0a 38 	mov	r8,2616
8000a310:	70 0c       	ld.w	r12,r8[0x0]
8000a312:	2f 4c       	sub	r12,-12
8000a314:	5e fc       	retal	r12
8000a316:	d7 03       	nop

8000a318 <_fflush_r>:
8000a318:	d4 21       	pushm	r4-r7,lr
8000a31a:	16 97       	mov	r7,r11
8000a31c:	18 96       	mov	r6,r12
8000a31e:	76 48       	ld.w	r8,r11[0x10]
8000a320:	58 08       	cp.w	r8,0
8000a322:	c7 f0       	breq	8000a420 <_fflush_r+0x108>
8000a324:	58 0c       	cp.w	r12,0
8000a326:	c0 50       	breq	8000a330 <_fflush_r+0x18>
8000a328:	78 68       	ld.w	r8,r12[0x18]
8000a32a:	58 08       	cp.w	r8,0
8000a32c:	c0 21       	brne	8000a330 <_fflush_r+0x18>
8000a32e:	cc dc       	rcall	8000a4c8 <__sinit>
8000a330:	fe c8 c9 c8 	sub	r8,pc,-13880
8000a334:	10 37       	cp.w	r7,r8
8000a336:	c0 31       	brne	8000a33c <_fflush_r+0x24>
8000a338:	6c 07       	ld.w	r7,r6[0x0]
8000a33a:	c0 c8       	rjmp	8000a352 <_fflush_r+0x3a>
8000a33c:	fe c8 c9 b4 	sub	r8,pc,-13900
8000a340:	10 37       	cp.w	r7,r8
8000a342:	c0 31       	brne	8000a348 <_fflush_r+0x30>
8000a344:	6c 17       	ld.w	r7,r6[0x4]
8000a346:	c0 68       	rjmp	8000a352 <_fflush_r+0x3a>
8000a348:	fe c8 c9 a0 	sub	r8,pc,-13920
8000a34c:	10 37       	cp.w	r7,r8
8000a34e:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a352:	8e 6a       	ld.sh	r10,r7[0xc]
8000a354:	14 98       	mov	r8,r10
8000a356:	ed ba 00 03 	bld	r10,0x3
8000a35a:	c4 20       	breq	8000a3de <_fflush_r+0xc6>
8000a35c:	ab ba       	sbr	r10,0xb
8000a35e:	ae 6a       	st.h	r7[0xc],r10
8000a360:	6e 18       	ld.w	r8,r7[0x4]
8000a362:	58 08       	cp.w	r8,0
8000a364:	e0 89 00 06 	brgt	8000a370 <_fflush_r+0x58>
8000a368:	6f 08       	ld.w	r8,r7[0x40]
8000a36a:	58 08       	cp.w	r8,0
8000a36c:	e0 8a 00 5a 	brle	8000a420 <_fflush_r+0x108>
8000a370:	6e b8       	ld.w	r8,r7[0x2c]
8000a372:	58 08       	cp.w	r8,0
8000a374:	c5 60       	breq	8000a420 <_fflush_r+0x108>
8000a376:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a37a:	c0 30       	breq	8000a380 <_fflush_r+0x68>
8000a37c:	6f 55       	ld.w	r5,r7[0x54]
8000a37e:	c0 f8       	rjmp	8000a39c <_fflush_r+0x84>
8000a380:	30 19       	mov	r9,1
8000a382:	6e 8b       	ld.w	r11,r7[0x20]
8000a384:	0c 9c       	mov	r12,r6
8000a386:	5d 18       	icall	r8
8000a388:	18 95       	mov	r5,r12
8000a38a:	5b fc       	cp.w	r12,-1
8000a38c:	c0 81       	brne	8000a39c <_fflush_r+0x84>
8000a38e:	6c 38       	ld.w	r8,r6[0xc]
8000a390:	59 d8       	cp.w	r8,29
8000a392:	c4 70       	breq	8000a420 <_fflush_r+0x108>
8000a394:	8e 68       	ld.sh	r8,r7[0xc]
8000a396:	a7 a8       	sbr	r8,0x6
8000a398:	ae 68       	st.h	r7[0xc],r8
8000a39a:	d8 22       	popm	r4-r7,pc
8000a39c:	8e 68       	ld.sh	r8,r7[0xc]
8000a39e:	ed b8 00 02 	bld	r8,0x2
8000a3a2:	c0 91       	brne	8000a3b4 <_fflush_r+0x9c>
8000a3a4:	6e 18       	ld.w	r8,r7[0x4]
8000a3a6:	10 15       	sub	r5,r8
8000a3a8:	6e d8       	ld.w	r8,r7[0x34]
8000a3aa:	58 08       	cp.w	r8,0
8000a3ac:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a3b0:	eb d8 e1 15 	subne	r5,r5,r8
8000a3b4:	6e b8       	ld.w	r8,r7[0x2c]
8000a3b6:	0c 9c       	mov	r12,r6
8000a3b8:	30 09       	mov	r9,0
8000a3ba:	0a 9a       	mov	r10,r5
8000a3bc:	6e 8b       	ld.w	r11,r7[0x20]
8000a3be:	5d 18       	icall	r8
8000a3c0:	8e 68       	ld.sh	r8,r7[0xc]
8000a3c2:	0a 3c       	cp.w	r12,r5
8000a3c4:	c2 61       	brne	8000a410 <_fflush_r+0xf8>
8000a3c6:	ab d8       	cbr	r8,0xb
8000a3c8:	30 0c       	mov	r12,0
8000a3ca:	6e 49       	ld.w	r9,r7[0x10]
8000a3cc:	ae 68       	st.h	r7[0xc],r8
8000a3ce:	8f 1c       	st.w	r7[0x4],r12
8000a3d0:	8f 09       	st.w	r7[0x0],r9
8000a3d2:	ed b8 00 0c 	bld	r8,0xc
8000a3d6:	c2 51       	brne	8000a420 <_fflush_r+0x108>
8000a3d8:	ef 45 00 54 	st.w	r7[84],r5
8000a3dc:	d8 22       	popm	r4-r7,pc
8000a3de:	6e 45       	ld.w	r5,r7[0x10]
8000a3e0:	58 05       	cp.w	r5,0
8000a3e2:	c1 f0       	breq	8000a420 <_fflush_r+0x108>
8000a3e4:	6e 04       	ld.w	r4,r7[0x0]
8000a3e6:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a3ea:	8f 05       	st.w	r7[0x0],r5
8000a3ec:	f9 b8 01 00 	movne	r8,0
8000a3f0:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a3f4:	0a 14       	sub	r4,r5
8000a3f6:	8f 28       	st.w	r7[0x8],r8
8000a3f8:	c1 18       	rjmp	8000a41a <_fflush_r+0x102>
8000a3fa:	08 99       	mov	r9,r4
8000a3fc:	0a 9a       	mov	r10,r5
8000a3fe:	6e a8       	ld.w	r8,r7[0x28]
8000a400:	6e 8b       	ld.w	r11,r7[0x20]
8000a402:	0c 9c       	mov	r12,r6
8000a404:	5d 18       	icall	r8
8000a406:	18 14       	sub	r4,r12
8000a408:	58 0c       	cp.w	r12,0
8000a40a:	e0 89 00 07 	brgt	8000a418 <_fflush_r+0x100>
8000a40e:	8e 68       	ld.sh	r8,r7[0xc]
8000a410:	a7 a8       	sbr	r8,0x6
8000a412:	3f fc       	mov	r12,-1
8000a414:	ae 68       	st.h	r7[0xc],r8
8000a416:	d8 22       	popm	r4-r7,pc
8000a418:	18 05       	add	r5,r12
8000a41a:	58 04       	cp.w	r4,0
8000a41c:	fe 99 ff ef 	brgt	8000a3fa <_fflush_r+0xe2>
8000a420:	d8 2a       	popm	r4-r7,pc,r12=0
8000a422:	d7 03       	nop

8000a424 <__sfp_lock_acquire>:
8000a424:	5e fc       	retal	r12

8000a426 <__sfp_lock_release>:
8000a426:	5e fc       	retal	r12

8000a428 <_cleanup_r>:
8000a428:	d4 01       	pushm	lr
8000a42a:	fe cb f0 c6 	sub	r11,pc,-3898
8000a42e:	e0 a0 02 f7 	rcall	8000aa1c <_fwalk>
8000a432:	d8 02       	popm	pc

8000a434 <__sfmoreglue>:
8000a434:	d4 21       	pushm	r4-r7,lr
8000a436:	16 95       	mov	r5,r11
8000a438:	f6 06 10 5c 	mul	r6,r11,92
8000a43c:	ec cb ff f4 	sub	r11,r6,-12
8000a440:	fe b0 e2 7c 	rcall	80006938 <_malloc_r>
8000a444:	18 97       	mov	r7,r12
8000a446:	c0 90       	breq	8000a458 <__sfmoreglue+0x24>
8000a448:	99 15       	st.w	r12[0x4],r5
8000a44a:	30 0b       	mov	r11,0
8000a44c:	2f 4c       	sub	r12,-12
8000a44e:	0c 9a       	mov	r10,r6
8000a450:	8f 2c       	st.w	r7[0x8],r12
8000a452:	8f 0b       	st.w	r7[0x0],r11
8000a454:	fe b0 e5 32 	rcall	80006eb8 <memset>
8000a458:	0e 9c       	mov	r12,r7
8000a45a:	d8 22       	popm	r4-r7,pc

8000a45c <__sfp>:
8000a45c:	d4 21       	pushm	r4-r7,lr
8000a45e:	fe c8 ca 92 	sub	r8,pc,-13678
8000a462:	18 96       	mov	r6,r12
8000a464:	70 07       	ld.w	r7,r8[0x0]
8000a466:	6e 68       	ld.w	r8,r7[0x18]
8000a468:	58 08       	cp.w	r8,0
8000a46a:	c0 31       	brne	8000a470 <__sfp+0x14>
8000a46c:	0e 9c       	mov	r12,r7
8000a46e:	c2 dc       	rcall	8000a4c8 <__sinit>
8000a470:	ee c7 ff 28 	sub	r7,r7,-216
8000a474:	30 05       	mov	r5,0
8000a476:	6e 2c       	ld.w	r12,r7[0x8]
8000a478:	6e 18       	ld.w	r8,r7[0x4]
8000a47a:	c0 68       	rjmp	8000a486 <__sfp+0x2a>
8000a47c:	98 69       	ld.sh	r9,r12[0xc]
8000a47e:	ea 09 19 00 	cp.h	r9,r5
8000a482:	c1 10       	breq	8000a4a4 <__sfp+0x48>
8000a484:	2a 4c       	sub	r12,-92
8000a486:	20 18       	sub	r8,1
8000a488:	cf a7       	brpl	8000a47c <__sfp+0x20>
8000a48a:	6e 08       	ld.w	r8,r7[0x0]
8000a48c:	58 08       	cp.w	r8,0
8000a48e:	c0 61       	brne	8000a49a <__sfp+0x3e>
8000a490:	30 4b       	mov	r11,4
8000a492:	0c 9c       	mov	r12,r6
8000a494:	cd 0f       	rcall	8000a434 <__sfmoreglue>
8000a496:	8f 0c       	st.w	r7[0x0],r12
8000a498:	c0 30       	breq	8000a49e <__sfp+0x42>
8000a49a:	6e 07       	ld.w	r7,r7[0x0]
8000a49c:	ce db       	rjmp	8000a476 <__sfp+0x1a>
8000a49e:	30 c8       	mov	r8,12
8000a4a0:	8d 38       	st.w	r6[0xc],r8
8000a4a2:	d8 22       	popm	r4-r7,pc
8000a4a4:	30 08       	mov	r8,0
8000a4a6:	f9 48 00 4c 	st.w	r12[76],r8
8000a4aa:	99 08       	st.w	r12[0x0],r8
8000a4ac:	99 28       	st.w	r12[0x8],r8
8000a4ae:	99 18       	st.w	r12[0x4],r8
8000a4b0:	99 48       	st.w	r12[0x10],r8
8000a4b2:	99 58       	st.w	r12[0x14],r8
8000a4b4:	99 68       	st.w	r12[0x18],r8
8000a4b6:	99 d8       	st.w	r12[0x34],r8
8000a4b8:	99 e8       	st.w	r12[0x38],r8
8000a4ba:	f9 48 00 48 	st.w	r12[72],r8
8000a4be:	3f f8       	mov	r8,-1
8000a4c0:	b8 78       	st.h	r12[0xe],r8
8000a4c2:	30 18       	mov	r8,1
8000a4c4:	b8 68       	st.h	r12[0xc],r8
8000a4c6:	d8 22       	popm	r4-r7,pc

8000a4c8 <__sinit>:
8000a4c8:	d4 21       	pushm	r4-r7,lr
8000a4ca:	18 96       	mov	r6,r12
8000a4cc:	78 67       	ld.w	r7,r12[0x18]
8000a4ce:	58 07       	cp.w	r7,0
8000a4d0:	c4 91       	brne	8000a562 <__sinit+0x9a>
8000a4d2:	fe c8 00 aa 	sub	r8,pc,170
8000a4d6:	30 15       	mov	r5,1
8000a4d8:	99 a8       	st.w	r12[0x28],r8
8000a4da:	f9 47 00 d8 	st.w	r12[216],r7
8000a4de:	f9 47 00 dc 	st.w	r12[220],r7
8000a4e2:	f9 47 00 e0 	st.w	r12[224],r7
8000a4e6:	99 65       	st.w	r12[0x18],r5
8000a4e8:	cb af       	rcall	8000a45c <__sfp>
8000a4ea:	8d 0c       	st.w	r6[0x0],r12
8000a4ec:	0c 9c       	mov	r12,r6
8000a4ee:	cb 7f       	rcall	8000a45c <__sfp>
8000a4f0:	8d 1c       	st.w	r6[0x4],r12
8000a4f2:	0c 9c       	mov	r12,r6
8000a4f4:	cb 4f       	rcall	8000a45c <__sfp>
8000a4f6:	6c 09       	ld.w	r9,r6[0x0]
8000a4f8:	30 48       	mov	r8,4
8000a4fa:	93 07       	st.w	r9[0x0],r7
8000a4fc:	b2 68       	st.h	r9[0xc],r8
8000a4fe:	93 17       	st.w	r9[0x4],r7
8000a500:	93 27       	st.w	r9[0x8],r7
8000a502:	6c 18       	ld.w	r8,r6[0x4]
8000a504:	b2 77       	st.h	r9[0xe],r7
8000a506:	93 47       	st.w	r9[0x10],r7
8000a508:	93 57       	st.w	r9[0x14],r7
8000a50a:	93 67       	st.w	r9[0x18],r7
8000a50c:	93 89       	st.w	r9[0x20],r9
8000a50e:	91 07       	st.w	r8[0x0],r7
8000a510:	91 17       	st.w	r8[0x4],r7
8000a512:	91 27       	st.w	r8[0x8],r7
8000a514:	fe ce f3 24 	sub	lr,pc,-3292
8000a518:	fe cb f3 54 	sub	r11,pc,-3244
8000a51c:	93 9e       	st.w	r9[0x24],lr
8000a51e:	93 ab       	st.w	r9[0x28],r11
8000a520:	fe ca f3 7c 	sub	r10,pc,-3204
8000a524:	fe c4 f3 88 	sub	r4,pc,-3192
8000a528:	93 ba       	st.w	r9[0x2c],r10
8000a52a:	93 c4       	st.w	r9[0x30],r4
8000a52c:	30 99       	mov	r9,9
8000a52e:	b0 69       	st.h	r8[0xc],r9
8000a530:	b0 75       	st.h	r8[0xe],r5
8000a532:	91 c4       	st.w	r8[0x30],r4
8000a534:	91 47       	st.w	r8[0x10],r7
8000a536:	91 57       	st.w	r8[0x14],r7
8000a538:	91 67       	st.w	r8[0x18],r7
8000a53a:	91 88       	st.w	r8[0x20],r8
8000a53c:	91 9e       	st.w	r8[0x24],lr
8000a53e:	91 ab       	st.w	r8[0x28],r11
8000a540:	91 ba       	st.w	r8[0x2c],r10
8000a542:	8d 2c       	st.w	r6[0x8],r12
8000a544:	31 28       	mov	r8,18
8000a546:	99 07       	st.w	r12[0x0],r7
8000a548:	b8 68       	st.h	r12[0xc],r8
8000a54a:	99 17       	st.w	r12[0x4],r7
8000a54c:	99 27       	st.w	r12[0x8],r7
8000a54e:	30 28       	mov	r8,2
8000a550:	b8 78       	st.h	r12[0xe],r8
8000a552:	99 c4       	st.w	r12[0x30],r4
8000a554:	99 67       	st.w	r12[0x18],r7
8000a556:	99 9e       	st.w	r12[0x24],lr
8000a558:	99 ab       	st.w	r12[0x28],r11
8000a55a:	99 ba       	st.w	r12[0x2c],r10
8000a55c:	99 47       	st.w	r12[0x10],r7
8000a55e:	99 57       	st.w	r12[0x14],r7
8000a560:	99 8c       	st.w	r12[0x20],r12
8000a562:	d8 22       	popm	r4-r7,pc

8000a564 <_malloc_trim_r>:
8000a564:	d4 21       	pushm	r4-r7,lr
8000a566:	16 95       	mov	r5,r11
8000a568:	18 97       	mov	r7,r12
8000a56a:	fe b0 d7 53 	rcall	80005410 <__malloc_lock>
8000a56e:	e0 64 05 38 	mov	r4,1336
8000a572:	68 28       	ld.w	r8,r4[0x8]
8000a574:	70 16       	ld.w	r6,r8[0x4]
8000a576:	e0 16 ff fc 	andl	r6,0xfffc
8000a57a:	ec c8 ff 91 	sub	r8,r6,-111
8000a57e:	f0 05 01 05 	sub	r5,r8,r5
8000a582:	e0 15 ff 80 	andl	r5,0xff80
8000a586:	ea c5 00 80 	sub	r5,r5,128
8000a58a:	e0 45 00 7f 	cp.w	r5,127
8000a58e:	e0 8a 00 25 	brle	8000a5d8 <_malloc_trim_r+0x74>
8000a592:	30 0b       	mov	r11,0
8000a594:	0e 9c       	mov	r12,r7
8000a596:	fe b0 e5 f9 	rcall	80007188 <_sbrk_r>
8000a59a:	68 28       	ld.w	r8,r4[0x8]
8000a59c:	0c 08       	add	r8,r6
8000a59e:	10 3c       	cp.w	r12,r8
8000a5a0:	c1 c1       	brne	8000a5d8 <_malloc_trim_r+0x74>
8000a5a2:	ea 0b 11 00 	rsub	r11,r5,0
8000a5a6:	0e 9c       	mov	r12,r7
8000a5a8:	fe b0 e5 f0 	rcall	80007188 <_sbrk_r>
8000a5ac:	5b fc       	cp.w	r12,-1
8000a5ae:	c1 91       	brne	8000a5e0 <_malloc_trim_r+0x7c>
8000a5b0:	30 0b       	mov	r11,0
8000a5b2:	0e 9c       	mov	r12,r7
8000a5b4:	fe b0 e5 ea 	rcall	80007188 <_sbrk_r>
8000a5b8:	68 28       	ld.w	r8,r4[0x8]
8000a5ba:	f8 08 01 09 	sub	r9,r12,r8
8000a5be:	58 f9       	cp.w	r9,15
8000a5c0:	e0 8a 00 0c 	brle	8000a5d8 <_malloc_trim_r+0x74>
8000a5c4:	a1 a9       	sbr	r9,0x0
8000a5c6:	91 19       	st.w	r8[0x4],r9
8000a5c8:	e0 68 09 44 	mov	r8,2372
8000a5cc:	70 09       	ld.w	r9,r8[0x0]
8000a5ce:	e0 68 0d 80 	mov	r8,3456
8000a5d2:	f8 09 01 09 	sub	r9,r12,r9
8000a5d6:	91 09       	st.w	r8[0x0],r9
8000a5d8:	0e 9c       	mov	r12,r7
8000a5da:	fe b0 d7 21 	rcall	8000541c <__malloc_unlock>
8000a5de:	d8 2a       	popm	r4-r7,pc,r12=0
8000a5e0:	68 28       	ld.w	r8,r4[0x8]
8000a5e2:	0a 16       	sub	r6,r5
8000a5e4:	a1 a6       	sbr	r6,0x0
8000a5e6:	91 16       	st.w	r8[0x4],r6
8000a5e8:	e0 68 0d 80 	mov	r8,3456
8000a5ec:	70 09       	ld.w	r9,r8[0x0]
8000a5ee:	0a 19       	sub	r9,r5
8000a5f0:	0e 9c       	mov	r12,r7
8000a5f2:	91 09       	st.w	r8[0x0],r9
8000a5f4:	fe b0 d7 14 	rcall	8000541c <__malloc_unlock>
8000a5f8:	da 2a       	popm	r4-r7,pc,r12=1
8000a5fa:	d7 03       	nop

8000a5fc <_free_r>:
8000a5fc:	d4 21       	pushm	r4-r7,lr
8000a5fe:	16 96       	mov	r6,r11
8000a600:	18 97       	mov	r7,r12
8000a602:	58 0b       	cp.w	r11,0
8000a604:	e0 80 00 c0 	breq	8000a784 <_free_r+0x188>
8000a608:	fe b0 d7 04 	rcall	80005410 <__malloc_lock>
8000a60c:	20 86       	sub	r6,8
8000a60e:	e0 6a 05 38 	mov	r10,1336
8000a612:	6c 18       	ld.w	r8,r6[0x4]
8000a614:	74 2e       	ld.w	lr,r10[0x8]
8000a616:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a61a:	a1 c8       	cbr	r8,0x0
8000a61c:	ec 08 00 09 	add	r9,r6,r8
8000a620:	72 1b       	ld.w	r11,r9[0x4]
8000a622:	e0 1b ff fc 	andl	r11,0xfffc
8000a626:	1c 39       	cp.w	r9,lr
8000a628:	c1 e1       	brne	8000a664 <_free_r+0x68>
8000a62a:	f6 08 00 08 	add	r8,r11,r8
8000a62e:	58 0c       	cp.w	r12,0
8000a630:	c0 81       	brne	8000a640 <_free_r+0x44>
8000a632:	6c 09       	ld.w	r9,r6[0x0]
8000a634:	12 16       	sub	r6,r9
8000a636:	12 08       	add	r8,r9
8000a638:	6c 3b       	ld.w	r11,r6[0xc]
8000a63a:	6c 29       	ld.w	r9,r6[0x8]
8000a63c:	97 29       	st.w	r11[0x8],r9
8000a63e:	93 3b       	st.w	r9[0xc],r11
8000a640:	10 99       	mov	r9,r8
8000a642:	95 26       	st.w	r10[0x8],r6
8000a644:	a1 a9       	sbr	r9,0x0
8000a646:	8d 19       	st.w	r6[0x4],r9
8000a648:	e0 69 09 40 	mov	r9,2368
8000a64c:	72 09       	ld.w	r9,r9[0x0]
8000a64e:	12 38       	cp.w	r8,r9
8000a650:	c0 63       	brcs	8000a65c <_free_r+0x60>
8000a652:	e0 68 0d 7c 	mov	r8,3452
8000a656:	0e 9c       	mov	r12,r7
8000a658:	70 0b       	ld.w	r11,r8[0x0]
8000a65a:	c8 5f       	rcall	8000a564 <_malloc_trim_r>
8000a65c:	0e 9c       	mov	r12,r7
8000a65e:	fe b0 d6 df 	rcall	8000541c <__malloc_unlock>
8000a662:	d8 22       	popm	r4-r7,pc
8000a664:	93 1b       	st.w	r9[0x4],r11
8000a666:	58 0c       	cp.w	r12,0
8000a668:	c0 30       	breq	8000a66e <_free_r+0x72>
8000a66a:	30 0c       	mov	r12,0
8000a66c:	c1 08       	rjmp	8000a68c <_free_r+0x90>
8000a66e:	6c 0e       	ld.w	lr,r6[0x0]
8000a670:	f4 c5 ff f8 	sub	r5,r10,-8
8000a674:	1c 16       	sub	r6,lr
8000a676:	1c 08       	add	r8,lr
8000a678:	6c 2e       	ld.w	lr,r6[0x8]
8000a67a:	0a 3e       	cp.w	lr,r5
8000a67c:	f9 bc 00 01 	moveq	r12,1
8000a680:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a684:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a688:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a68c:	f2 0b 00 0e 	add	lr,r9,r11
8000a690:	7c 1e       	ld.w	lr,lr[0x4]
8000a692:	ed be 00 00 	bld	lr,0x0
8000a696:	c1 40       	breq	8000a6be <_free_r+0xc2>
8000a698:	16 08       	add	r8,r11
8000a69a:	58 0c       	cp.w	r12,0
8000a69c:	c0 d1       	brne	8000a6b6 <_free_r+0xba>
8000a69e:	e0 6e 05 38 	mov	lr,1336
8000a6a2:	72 2b       	ld.w	r11,r9[0x8]
8000a6a4:	2f 8e       	sub	lr,-8
8000a6a6:	1c 3b       	cp.w	r11,lr
8000a6a8:	c0 71       	brne	8000a6b6 <_free_r+0xba>
8000a6aa:	97 36       	st.w	r11[0xc],r6
8000a6ac:	97 26       	st.w	r11[0x8],r6
8000a6ae:	8d 2b       	st.w	r6[0x8],r11
8000a6b0:	8d 3b       	st.w	r6[0xc],r11
8000a6b2:	30 1c       	mov	r12,1
8000a6b4:	c0 58       	rjmp	8000a6be <_free_r+0xc2>
8000a6b6:	72 2b       	ld.w	r11,r9[0x8]
8000a6b8:	72 39       	ld.w	r9,r9[0xc]
8000a6ba:	93 2b       	st.w	r9[0x8],r11
8000a6bc:	97 39       	st.w	r11[0xc],r9
8000a6be:	10 99       	mov	r9,r8
8000a6c0:	ec 08 09 08 	st.w	r6[r8],r8
8000a6c4:	a1 a9       	sbr	r9,0x0
8000a6c6:	8d 19       	st.w	r6[0x4],r9
8000a6c8:	58 0c       	cp.w	r12,0
8000a6ca:	c5 a1       	brne	8000a77e <_free_r+0x182>
8000a6cc:	e0 48 01 ff 	cp.w	r8,511
8000a6d0:	e0 8b 00 13 	brhi	8000a6f6 <_free_r+0xfa>
8000a6d4:	a3 98       	lsr	r8,0x3
8000a6d6:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a6da:	72 2b       	ld.w	r11,r9[0x8]
8000a6dc:	8d 39       	st.w	r6[0xc],r9
8000a6de:	8d 2b       	st.w	r6[0x8],r11
8000a6e0:	97 36       	st.w	r11[0xc],r6
8000a6e2:	93 26       	st.w	r9[0x8],r6
8000a6e4:	a3 48       	asr	r8,0x2
8000a6e6:	74 19       	ld.w	r9,r10[0x4]
8000a6e8:	30 1b       	mov	r11,1
8000a6ea:	f6 08 09 48 	lsl	r8,r11,r8
8000a6ee:	f3 e8 10 08 	or	r8,r9,r8
8000a6f2:	95 18       	st.w	r10[0x4],r8
8000a6f4:	c4 58       	rjmp	8000a77e <_free_r+0x182>
8000a6f6:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a6fa:	58 4b       	cp.w	r11,4
8000a6fc:	e0 8b 00 06 	brhi	8000a708 <_free_r+0x10c>
8000a700:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a704:	2c 8b       	sub	r11,-56
8000a706:	c2 08       	rjmp	8000a746 <_free_r+0x14a>
8000a708:	59 4b       	cp.w	r11,20
8000a70a:	e0 8b 00 04 	brhi	8000a712 <_free_r+0x116>
8000a70e:	2a 5b       	sub	r11,-91
8000a710:	c1 b8       	rjmp	8000a746 <_free_r+0x14a>
8000a712:	e0 4b 00 54 	cp.w	r11,84
8000a716:	e0 8b 00 06 	brhi	8000a722 <_free_r+0x126>
8000a71a:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a71e:	29 2b       	sub	r11,-110
8000a720:	c1 38       	rjmp	8000a746 <_free_r+0x14a>
8000a722:	e0 4b 01 54 	cp.w	r11,340
8000a726:	e0 8b 00 06 	brhi	8000a732 <_free_r+0x136>
8000a72a:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a72e:	28 9b       	sub	r11,-119
8000a730:	c0 b8       	rjmp	8000a746 <_free_r+0x14a>
8000a732:	e0 4b 05 54 	cp.w	r11,1364
8000a736:	e0 88 00 05 	brls	8000a740 <_free_r+0x144>
8000a73a:	37 eb       	mov	r11,126
8000a73c:	c0 58       	rjmp	8000a746 <_free_r+0x14a>
8000a73e:	d7 03       	nop
8000a740:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a744:	28 4b       	sub	r11,-124
8000a746:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a74a:	78 29       	ld.w	r9,r12[0x8]
8000a74c:	18 39       	cp.w	r9,r12
8000a74e:	c0 e1       	brne	8000a76a <_free_r+0x16e>
8000a750:	74 18       	ld.w	r8,r10[0x4]
8000a752:	a3 4b       	asr	r11,0x2
8000a754:	30 1c       	mov	r12,1
8000a756:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a75a:	f1 eb 10 0b 	or	r11,r8,r11
8000a75e:	12 98       	mov	r8,r9
8000a760:	95 1b       	st.w	r10[0x4],r11
8000a762:	c0 a8       	rjmp	8000a776 <_free_r+0x17a>
8000a764:	72 29       	ld.w	r9,r9[0x8]
8000a766:	18 39       	cp.w	r9,r12
8000a768:	c0 60       	breq	8000a774 <_free_r+0x178>
8000a76a:	72 1a       	ld.w	r10,r9[0x4]
8000a76c:	e0 1a ff fc 	andl	r10,0xfffc
8000a770:	14 38       	cp.w	r8,r10
8000a772:	cf 93       	brcs	8000a764 <_free_r+0x168>
8000a774:	72 38       	ld.w	r8,r9[0xc]
8000a776:	8d 38       	st.w	r6[0xc],r8
8000a778:	8d 29       	st.w	r6[0x8],r9
8000a77a:	93 36       	st.w	r9[0xc],r6
8000a77c:	91 26       	st.w	r8[0x8],r6
8000a77e:	0e 9c       	mov	r12,r7
8000a780:	fe b0 d6 4e 	rcall	8000541c <__malloc_unlock>
8000a784:	d8 22       	popm	r4-r7,pc
8000a786:	d7 03       	nop

8000a788 <__sfvwrite_r>:
8000a788:	d4 31       	pushm	r0-r7,lr
8000a78a:	20 3d       	sub	sp,12
8000a78c:	14 94       	mov	r4,r10
8000a78e:	18 95       	mov	r5,r12
8000a790:	16 97       	mov	r7,r11
8000a792:	74 28       	ld.w	r8,r10[0x8]
8000a794:	58 08       	cp.w	r8,0
8000a796:	e0 80 01 40 	breq	8000aa16 <__sfvwrite_r+0x28e>
8000a79a:	96 68       	ld.sh	r8,r11[0xc]
8000a79c:	ed b8 00 03 	bld	r8,0x3
8000a7a0:	c0 41       	brne	8000a7a8 <__sfvwrite_r+0x20>
8000a7a2:	76 48       	ld.w	r8,r11[0x10]
8000a7a4:	58 08       	cp.w	r8,0
8000a7a6:	c0 c1       	brne	8000a7be <__sfvwrite_r+0x36>
8000a7a8:	0e 9b       	mov	r11,r7
8000a7aa:	0a 9c       	mov	r12,r5
8000a7ac:	fe b0 f6 c4 	rcall	80009534 <__swsetup_r>
8000a7b0:	c0 70       	breq	8000a7be <__sfvwrite_r+0x36>
8000a7b2:	8e 68       	ld.sh	r8,r7[0xc]
8000a7b4:	a7 a8       	sbr	r8,0x6
8000a7b6:	ae 68       	st.h	r7[0xc],r8
8000a7b8:	30 98       	mov	r8,9
8000a7ba:	8b 38       	st.w	r5[0xc],r8
8000a7bc:	c2 b9       	rjmp	8000aa12 <__sfvwrite_r+0x28a>
8000a7be:	8e 63       	ld.sh	r3,r7[0xc]
8000a7c0:	68 00       	ld.w	r0,r4[0x0]
8000a7c2:	06 96       	mov	r6,r3
8000a7c4:	e2 16 00 02 	andl	r6,0x2,COH
8000a7c8:	c2 10       	breq	8000a80a <__sfvwrite_r+0x82>
8000a7ca:	30 03       	mov	r3,0
8000a7cc:	e0 62 04 00 	mov	r2,1024
8000a7d0:	06 96       	mov	r6,r3
8000a7d2:	c0 48       	rjmp	8000a7da <__sfvwrite_r+0x52>
8000a7d4:	60 03       	ld.w	r3,r0[0x0]
8000a7d6:	60 16       	ld.w	r6,r0[0x4]
8000a7d8:	2f 80       	sub	r0,-8
8000a7da:	58 06       	cp.w	r6,0
8000a7dc:	cf c0       	breq	8000a7d4 <__sfvwrite_r+0x4c>
8000a7de:	e0 46 04 00 	cp.w	r6,1024
8000a7e2:	ec 09 17 80 	movls	r9,r6
8000a7e6:	e4 09 17 b0 	movhi	r9,r2
8000a7ea:	06 9a       	mov	r10,r3
8000a7ec:	6e a8       	ld.w	r8,r7[0x28]
8000a7ee:	6e 8b       	ld.w	r11,r7[0x20]
8000a7f0:	0a 9c       	mov	r12,r5
8000a7f2:	5d 18       	icall	r8
8000a7f4:	18 16       	sub	r6,r12
8000a7f6:	58 0c       	cp.w	r12,0
8000a7f8:	e0 8a 01 0a 	brle	8000aa0c <__sfvwrite_r+0x284>
8000a7fc:	68 28       	ld.w	r8,r4[0x8]
8000a7fe:	18 18       	sub	r8,r12
8000a800:	89 28       	st.w	r4[0x8],r8
8000a802:	e0 80 01 0a 	breq	8000aa16 <__sfvwrite_r+0x28e>
8000a806:	18 03       	add	r3,r12
8000a808:	ce 9b       	rjmp	8000a7da <__sfvwrite_r+0x52>
8000a80a:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000a80e:	c0 70       	breq	8000a81c <__sfvwrite_r+0x94>
8000a810:	50 06       	stdsp	sp[0x0],r6
8000a812:	0c 93       	mov	r3,r6
8000a814:	0c 91       	mov	r1,r6
8000a816:	50 15       	stdsp	sp[0x4],r5
8000a818:	08 92       	mov	r2,r4
8000a81a:	c9 c8       	rjmp	8000a952 <__sfvwrite_r+0x1ca>
8000a81c:	06 96       	mov	r6,r3
8000a81e:	08 91       	mov	r1,r4
8000a820:	c0 48       	rjmp	8000a828 <__sfvwrite_r+0xa0>
8000a822:	60 03       	ld.w	r3,r0[0x0]
8000a824:	60 16       	ld.w	r6,r0[0x4]
8000a826:	2f 80       	sub	r0,-8
8000a828:	58 06       	cp.w	r6,0
8000a82a:	cf c0       	breq	8000a822 <__sfvwrite_r+0x9a>
8000a82c:	8e 68       	ld.sh	r8,r7[0xc]
8000a82e:	6e 24       	ld.w	r4,r7[0x8]
8000a830:	10 99       	mov	r9,r8
8000a832:	e2 19 02 00 	andl	r9,0x200,COH
8000a836:	c5 50       	breq	8000a8e0 <__sfvwrite_r+0x158>
8000a838:	08 36       	cp.w	r6,r4
8000a83a:	c4 43       	brcs	8000a8c2 <__sfvwrite_r+0x13a>
8000a83c:	10 99       	mov	r9,r8
8000a83e:	e2 19 04 80 	andl	r9,0x480,COH
8000a842:	c4 00       	breq	8000a8c2 <__sfvwrite_r+0x13a>
8000a844:	6e 4b       	ld.w	r11,r7[0x10]
8000a846:	6e 09       	ld.w	r9,r7[0x0]
8000a848:	16 19       	sub	r9,r11
8000a84a:	50 09       	stdsp	sp[0x0],r9
8000a84c:	6e 59       	ld.w	r9,r7[0x14]
8000a84e:	10 9c       	mov	r12,r8
8000a850:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000a854:	30 28       	mov	r8,2
8000a856:	f4 08 0c 08 	divs	r8,r10,r8
8000a85a:	fa e9 00 04 	st.d	sp[4],r8
8000a85e:	10 94       	mov	r4,r8
8000a860:	40 09       	lddsp	r9,sp[0x0]
8000a862:	e2 1c 04 00 	andl	r12,0x400,COH
8000a866:	2f f9       	sub	r9,-1
8000a868:	0c 09       	add	r9,r6
8000a86a:	12 38       	cp.w	r8,r9
8000a86c:	f2 04 17 30 	movlo	r4,r9
8000a870:	58 0c       	cp.w	r12,0
8000a872:	c1 10       	breq	8000a894 <__sfvwrite_r+0x10c>
8000a874:	08 9b       	mov	r11,r4
8000a876:	0a 9c       	mov	r12,r5
8000a878:	fe b0 e0 60 	rcall	80006938 <_malloc_r>
8000a87c:	18 92       	mov	r2,r12
8000a87e:	c1 40       	breq	8000a8a6 <__sfvwrite_r+0x11e>
8000a880:	40 0a       	lddsp	r10,sp[0x0]
8000a882:	6e 4b       	ld.w	r11,r7[0x10]
8000a884:	fe b0 e2 76 	rcall	80006d70 <memcpy>
8000a888:	8e 68       	ld.sh	r8,r7[0xc]
8000a88a:	e0 18 fb 7f 	andl	r8,0xfb7f
8000a88e:	a7 b8       	sbr	r8,0x7
8000a890:	ae 68       	st.h	r7[0xc],r8
8000a892:	c0 d8       	rjmp	8000a8ac <__sfvwrite_r+0x124>
8000a894:	08 9a       	mov	r10,r4
8000a896:	0a 9c       	mov	r12,r5
8000a898:	fe b0 e3 18 	rcall	80006ec8 <_realloc_r>
8000a89c:	18 92       	mov	r2,r12
8000a89e:	c0 71       	brne	8000a8ac <__sfvwrite_r+0x124>
8000a8a0:	6e 4b       	ld.w	r11,r7[0x10]
8000a8a2:	0a 9c       	mov	r12,r5
8000a8a4:	ca ce       	rcall	8000a5fc <_free_r>
8000a8a6:	30 c8       	mov	r8,12
8000a8a8:	8b 38       	st.w	r5[0xc],r8
8000a8aa:	cb 18       	rjmp	8000aa0c <__sfvwrite_r+0x284>
8000a8ac:	40 0a       	lddsp	r10,sp[0x0]
8000a8ae:	40 09       	lddsp	r9,sp[0x0]
8000a8b0:	e8 0a 01 0a 	sub	r10,r4,r10
8000a8b4:	e4 09 00 08 	add	r8,r2,r9
8000a8b8:	8f 54       	st.w	r7[0x14],r4
8000a8ba:	8f 2a       	st.w	r7[0x8],r10
8000a8bc:	8f 08       	st.w	r7[0x0],r8
8000a8be:	8f 42       	st.w	r7[0x10],r2
8000a8c0:	0c 94       	mov	r4,r6
8000a8c2:	08 36       	cp.w	r6,r4
8000a8c4:	ec 04 17 30 	movlo	r4,r6
8000a8c8:	06 9b       	mov	r11,r3
8000a8ca:	08 9a       	mov	r10,r4
8000a8cc:	6e 0c       	ld.w	r12,r7[0x0]
8000a8ce:	c3 ad       	rcall	8000ab42 <memmove>
8000a8d0:	6e 08       	ld.w	r8,r7[0x0]
8000a8d2:	08 08       	add	r8,r4
8000a8d4:	8f 08       	st.w	r7[0x0],r8
8000a8d6:	6e 28       	ld.w	r8,r7[0x8]
8000a8d8:	08 18       	sub	r8,r4
8000a8da:	0c 94       	mov	r4,r6
8000a8dc:	8f 28       	st.w	r7[0x8],r8
8000a8de:	c2 e8       	rjmp	8000a93a <__sfvwrite_r+0x1b2>
8000a8e0:	08 36       	cp.w	r6,r4
8000a8e2:	5f ba       	srhi	r10
8000a8e4:	6e 0c       	ld.w	r12,r7[0x0]
8000a8e6:	6e 48       	ld.w	r8,r7[0x10]
8000a8e8:	10 3c       	cp.w	r12,r8
8000a8ea:	5f b8       	srhi	r8
8000a8ec:	f5 e8 00 08 	and	r8,r10,r8
8000a8f0:	f2 08 18 00 	cp.b	r8,r9
8000a8f4:	c0 d0       	breq	8000a90e <__sfvwrite_r+0x186>
8000a8f6:	06 9b       	mov	r11,r3
8000a8f8:	08 9a       	mov	r10,r4
8000a8fa:	c2 4d       	rcall	8000ab42 <memmove>
8000a8fc:	6e 08       	ld.w	r8,r7[0x0]
8000a8fe:	08 08       	add	r8,r4
8000a900:	0e 9b       	mov	r11,r7
8000a902:	8f 08       	st.w	r7[0x0],r8
8000a904:	0a 9c       	mov	r12,r5
8000a906:	fe b0 fd 09 	rcall	8000a318 <_fflush_r>
8000a90a:	c1 80       	breq	8000a93a <__sfvwrite_r+0x1b2>
8000a90c:	c8 08       	rjmp	8000aa0c <__sfvwrite_r+0x284>
8000a90e:	6e 59       	ld.w	r9,r7[0x14]
8000a910:	12 36       	cp.w	r6,r9
8000a912:	c0 a3       	brcs	8000a926 <__sfvwrite_r+0x19e>
8000a914:	6e a8       	ld.w	r8,r7[0x28]
8000a916:	06 9a       	mov	r10,r3
8000a918:	6e 8b       	ld.w	r11,r7[0x20]
8000a91a:	0a 9c       	mov	r12,r5
8000a91c:	5d 18       	icall	r8
8000a91e:	18 94       	mov	r4,r12
8000a920:	e0 89 00 0d 	brgt	8000a93a <__sfvwrite_r+0x1b2>
8000a924:	c7 48       	rjmp	8000aa0c <__sfvwrite_r+0x284>
8000a926:	0c 9a       	mov	r10,r6
8000a928:	06 9b       	mov	r11,r3
8000a92a:	c0 cd       	rcall	8000ab42 <memmove>
8000a92c:	6e 08       	ld.w	r8,r7[0x0]
8000a92e:	0c 08       	add	r8,r6
8000a930:	0c 94       	mov	r4,r6
8000a932:	8f 08       	st.w	r7[0x0],r8
8000a934:	6e 28       	ld.w	r8,r7[0x8]
8000a936:	0c 18       	sub	r8,r6
8000a938:	8f 28       	st.w	r7[0x8],r8
8000a93a:	62 28       	ld.w	r8,r1[0x8]
8000a93c:	08 18       	sub	r8,r4
8000a93e:	83 28       	st.w	r1[0x8],r8
8000a940:	c6 b0       	breq	8000aa16 <__sfvwrite_r+0x28e>
8000a942:	08 16       	sub	r6,r4
8000a944:	08 03       	add	r3,r4
8000a946:	c7 1b       	rjmp	8000a828 <__sfvwrite_r+0xa0>
8000a948:	60 03       	ld.w	r3,r0[0x0]
8000a94a:	60 11       	ld.w	r1,r0[0x4]
8000a94c:	30 08       	mov	r8,0
8000a94e:	2f 80       	sub	r0,-8
8000a950:	50 08       	stdsp	sp[0x0],r8
8000a952:	58 01       	cp.w	r1,0
8000a954:	cf a0       	breq	8000a948 <__sfvwrite_r+0x1c0>
8000a956:	40 0a       	lddsp	r10,sp[0x0]
8000a958:	58 0a       	cp.w	r10,0
8000a95a:	c1 41       	brne	8000a982 <__sfvwrite_r+0x1fa>
8000a95c:	e2 c6 ff ff 	sub	r6,r1,-1
8000a960:	02 9a       	mov	r10,r1
8000a962:	30 ab       	mov	r11,10
8000a964:	06 9c       	mov	r12,r3
8000a966:	ce 3c       	rcall	8000ab2c <memchr>
8000a968:	f8 c8 ff ff 	sub	r8,r12,-1
8000a96c:	58 0c       	cp.w	r12,0
8000a96e:	f1 d3 e1 16 	subne	r6,r8,r3
8000a972:	f9 b9 01 01 	movne	r9,1
8000a976:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a97a:	f9 b8 00 01 	moveq	r8,1
8000a97e:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000a982:	02 36       	cp.w	r6,r1
8000a984:	ec 04 17 80 	movls	r4,r6
8000a988:	e2 04 17 b0 	movhi	r4,r1
8000a98c:	6e 59       	ld.w	r9,r7[0x14]
8000a98e:	6e 25       	ld.w	r5,r7[0x8]
8000a990:	f2 05 00 05 	add	r5,r9,r5
8000a994:	0a 34       	cp.w	r4,r5
8000a996:	5f 9a       	srgt	r10
8000a998:	6e 0c       	ld.w	r12,r7[0x0]
8000a99a:	6e 48       	ld.w	r8,r7[0x10]
8000a99c:	10 3c       	cp.w	r12,r8
8000a99e:	5f b8       	srhi	r8
8000a9a0:	f5 e8 00 08 	and	r8,r10,r8
8000a9a4:	30 0a       	mov	r10,0
8000a9a6:	f4 08 18 00 	cp.b	r8,r10
8000a9aa:	c0 d0       	breq	8000a9c4 <__sfvwrite_r+0x23c>
8000a9ac:	06 9b       	mov	r11,r3
8000a9ae:	0a 9a       	mov	r10,r5
8000a9b0:	cc 9c       	rcall	8000ab42 <memmove>
8000a9b2:	6e 08       	ld.w	r8,r7[0x0]
8000a9b4:	0a 08       	add	r8,r5
8000a9b6:	0e 9b       	mov	r11,r7
8000a9b8:	8f 08       	st.w	r7[0x0],r8
8000a9ba:	40 1c       	lddsp	r12,sp[0x4]
8000a9bc:	fe b0 fc ae 	rcall	8000a318 <_fflush_r>
8000a9c0:	c1 70       	breq	8000a9ee <__sfvwrite_r+0x266>
8000a9c2:	c2 58       	rjmp	8000aa0c <__sfvwrite_r+0x284>
8000a9c4:	12 34       	cp.w	r4,r9
8000a9c6:	c0 a5       	brlt	8000a9da <__sfvwrite_r+0x252>
8000a9c8:	6e a8       	ld.w	r8,r7[0x28]
8000a9ca:	06 9a       	mov	r10,r3
8000a9cc:	6e 8b       	ld.w	r11,r7[0x20]
8000a9ce:	40 1c       	lddsp	r12,sp[0x4]
8000a9d0:	5d 18       	icall	r8
8000a9d2:	18 95       	mov	r5,r12
8000a9d4:	e0 89 00 0d 	brgt	8000a9ee <__sfvwrite_r+0x266>
8000a9d8:	c1 a8       	rjmp	8000aa0c <__sfvwrite_r+0x284>
8000a9da:	08 9a       	mov	r10,r4
8000a9dc:	06 9b       	mov	r11,r3
8000a9de:	cb 2c       	rcall	8000ab42 <memmove>
8000a9e0:	6e 08       	ld.w	r8,r7[0x0]
8000a9e2:	08 08       	add	r8,r4
8000a9e4:	08 95       	mov	r5,r4
8000a9e6:	8f 08       	st.w	r7[0x0],r8
8000a9e8:	6e 28       	ld.w	r8,r7[0x8]
8000a9ea:	08 18       	sub	r8,r4
8000a9ec:	8f 28       	st.w	r7[0x8],r8
8000a9ee:	0a 16       	sub	r6,r5
8000a9f0:	c0 71       	brne	8000a9fe <__sfvwrite_r+0x276>
8000a9f2:	0e 9b       	mov	r11,r7
8000a9f4:	40 1c       	lddsp	r12,sp[0x4]
8000a9f6:	fe b0 fc 91 	rcall	8000a318 <_fflush_r>
8000a9fa:	c0 91       	brne	8000aa0c <__sfvwrite_r+0x284>
8000a9fc:	50 06       	stdsp	sp[0x0],r6
8000a9fe:	64 28       	ld.w	r8,r2[0x8]
8000aa00:	0a 18       	sub	r8,r5
8000aa02:	85 28       	st.w	r2[0x8],r8
8000aa04:	c0 90       	breq	8000aa16 <__sfvwrite_r+0x28e>
8000aa06:	0a 11       	sub	r1,r5
8000aa08:	0a 03       	add	r3,r5
8000aa0a:	ca 4b       	rjmp	8000a952 <__sfvwrite_r+0x1ca>
8000aa0c:	8e 68       	ld.sh	r8,r7[0xc]
8000aa0e:	a7 a8       	sbr	r8,0x6
8000aa10:	ae 68       	st.h	r7[0xc],r8
8000aa12:	3f fc       	mov	r12,-1
8000aa14:	c0 28       	rjmp	8000aa18 <__sfvwrite_r+0x290>
8000aa16:	30 0c       	mov	r12,0
8000aa18:	2f dd       	sub	sp,-12
8000aa1a:	d8 32       	popm	r0-r7,pc

8000aa1c <_fwalk>:
8000aa1c:	d4 31       	pushm	r0-r7,lr
8000aa1e:	30 05       	mov	r5,0
8000aa20:	16 91       	mov	r1,r11
8000aa22:	f8 c7 ff 28 	sub	r7,r12,-216
8000aa26:	0a 92       	mov	r2,r5
8000aa28:	fe b0 fc fe 	rcall	8000a424 <__sfp_lock_acquire>
8000aa2c:	3f f3       	mov	r3,-1
8000aa2e:	c1 68       	rjmp	8000aa5a <_fwalk+0x3e>
8000aa30:	6e 26       	ld.w	r6,r7[0x8]
8000aa32:	6e 14       	ld.w	r4,r7[0x4]
8000aa34:	2f 46       	sub	r6,-12
8000aa36:	c0 c8       	rjmp	8000aa4e <_fwalk+0x32>
8000aa38:	8c 08       	ld.sh	r8,r6[0x0]
8000aa3a:	e4 08 19 00 	cp.h	r8,r2
8000aa3e:	c0 70       	breq	8000aa4c <_fwalk+0x30>
8000aa40:	8c 18       	ld.sh	r8,r6[0x2]
8000aa42:	e6 08 19 00 	cp.h	r8,r3
8000aa46:	c0 30       	breq	8000aa4c <_fwalk+0x30>
8000aa48:	5d 11       	icall	r1
8000aa4a:	18 45       	or	r5,r12
8000aa4c:	2a 46       	sub	r6,-92
8000aa4e:	20 14       	sub	r4,1
8000aa50:	ec cc 00 0c 	sub	r12,r6,12
8000aa54:	58 04       	cp.w	r4,0
8000aa56:	cf 14       	brge	8000aa38 <_fwalk+0x1c>
8000aa58:	6e 07       	ld.w	r7,r7[0x0]
8000aa5a:	58 07       	cp.w	r7,0
8000aa5c:	ce a1       	brne	8000aa30 <_fwalk+0x14>
8000aa5e:	fe b0 fc e4 	rcall	8000a426 <__sfp_lock_release>
8000aa62:	0a 9c       	mov	r12,r5
8000aa64:	d8 32       	popm	r0-r7,pc
8000aa66:	d7 03       	nop

8000aa68 <_localeconv_r>:
8000aa68:	fe cc d0 98 	sub	r12,pc,-12136
8000aa6c:	5e fc       	retal	r12
8000aa6e:	d7 03       	nop

8000aa70 <__smakebuf_r>:
8000aa70:	d4 21       	pushm	r4-r7,lr
8000aa72:	20 fd       	sub	sp,60
8000aa74:	96 68       	ld.sh	r8,r11[0xc]
8000aa76:	16 97       	mov	r7,r11
8000aa78:	18 96       	mov	r6,r12
8000aa7a:	e2 18 00 02 	andl	r8,0x2,COH
8000aa7e:	c3 d1       	brne	8000aaf8 <__smakebuf_r+0x88>
8000aa80:	96 7b       	ld.sh	r11,r11[0xe]
8000aa82:	f0 0b 19 00 	cp.h	r11,r8
8000aa86:	c0 55       	brlt	8000aa90 <__smakebuf_r+0x20>
8000aa88:	1a 9a       	mov	r10,sp
8000aa8a:	e0 a0 04 75 	rcall	8000b374 <_fstat_r>
8000aa8e:	c0 f4       	brge	8000aaac <__smakebuf_r+0x3c>
8000aa90:	8e 65       	ld.sh	r5,r7[0xc]
8000aa92:	0a 98       	mov	r8,r5
8000aa94:	ab b8       	sbr	r8,0xb
8000aa96:	e2 15 00 80 	andl	r5,0x80,COH
8000aa9a:	ae 68       	st.h	r7[0xc],r8
8000aa9c:	30 04       	mov	r4,0
8000aa9e:	e0 68 04 00 	mov	r8,1024
8000aaa2:	f9 b5 01 40 	movne	r5,64
8000aaa6:	f0 05 17 00 	moveq	r5,r8
8000aaaa:	c1 c8       	rjmp	8000aae2 <__smakebuf_r+0x72>
8000aaac:	40 18       	lddsp	r8,sp[0x4]
8000aaae:	e2 18 f0 00 	andl	r8,0xf000,COH
8000aab2:	e0 48 20 00 	cp.w	r8,8192
8000aab6:	5f 04       	sreq	r4
8000aab8:	e0 48 80 00 	cp.w	r8,32768
8000aabc:	c0 e1       	brne	8000aad8 <__smakebuf_r+0x68>
8000aabe:	6e b9       	ld.w	r9,r7[0x2c]
8000aac0:	fe c8 f9 1c 	sub	r8,pc,-1764
8000aac4:	10 39       	cp.w	r9,r8
8000aac6:	c0 91       	brne	8000aad8 <__smakebuf_r+0x68>
8000aac8:	8e 68       	ld.sh	r8,r7[0xc]
8000aaca:	e0 65 04 00 	mov	r5,1024
8000aace:	ab a8       	sbr	r8,0xa
8000aad0:	ef 45 00 50 	st.w	r7[80],r5
8000aad4:	ae 68       	st.h	r7[0xc],r8
8000aad6:	c0 68       	rjmp	8000aae2 <__smakebuf_r+0x72>
8000aad8:	8e 68       	ld.sh	r8,r7[0xc]
8000aada:	e0 65 04 00 	mov	r5,1024
8000aade:	ab b8       	sbr	r8,0xb
8000aae0:	ae 68       	st.h	r7[0xc],r8
8000aae2:	0a 9b       	mov	r11,r5
8000aae4:	0c 9c       	mov	r12,r6
8000aae6:	fe b0 df 29 	rcall	80006938 <_malloc_r>
8000aaea:	8e 68       	ld.sh	r8,r7[0xc]
8000aaec:	c0 d1       	brne	8000ab06 <__smakebuf_r+0x96>
8000aaee:	ed b8 00 09 	bld	r8,0x9
8000aaf2:	c1 b0       	breq	8000ab28 <__smakebuf_r+0xb8>
8000aaf4:	a1 b8       	sbr	r8,0x1
8000aaf6:	ae 68       	st.h	r7[0xc],r8
8000aaf8:	ee c8 ff b9 	sub	r8,r7,-71
8000aafc:	8f 48       	st.w	r7[0x10],r8
8000aafe:	8f 08       	st.w	r7[0x0],r8
8000ab00:	30 18       	mov	r8,1
8000ab02:	8f 58       	st.w	r7[0x14],r8
8000ab04:	c1 28       	rjmp	8000ab28 <__smakebuf_r+0xb8>
8000ab06:	a7 b8       	sbr	r8,0x7
8000ab08:	8f 4c       	st.w	r7[0x10],r12
8000ab0a:	ae 68       	st.h	r7[0xc],r8
8000ab0c:	8f 55       	st.w	r7[0x14],r5
8000ab0e:	fe c8 06 e6 	sub	r8,pc,1766
8000ab12:	8f 0c       	st.w	r7[0x0],r12
8000ab14:	8d a8       	st.w	r6[0x28],r8
8000ab16:	58 04       	cp.w	r4,0
8000ab18:	c0 80       	breq	8000ab28 <__smakebuf_r+0xb8>
8000ab1a:	8e 7c       	ld.sh	r12,r7[0xe]
8000ab1c:	fe b0 e3 94 	rcall	80007244 <isatty>
8000ab20:	c0 40       	breq	8000ab28 <__smakebuf_r+0xb8>
8000ab22:	8e 68       	ld.sh	r8,r7[0xc]
8000ab24:	a1 a8       	sbr	r8,0x0
8000ab26:	ae 68       	st.h	r7[0xc],r8
8000ab28:	2f 1d       	sub	sp,-60
8000ab2a:	d8 22       	popm	r4-r7,pc

8000ab2c <memchr>:
8000ab2c:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000ab30:	c0 68       	rjmp	8000ab3c <memchr+0x10>
8000ab32:	20 1a       	sub	r10,1
8000ab34:	19 88       	ld.ub	r8,r12[0x0]
8000ab36:	16 38       	cp.w	r8,r11
8000ab38:	5e 0c       	reteq	r12
8000ab3a:	2f fc       	sub	r12,-1
8000ab3c:	58 0a       	cp.w	r10,0
8000ab3e:	cf a1       	brne	8000ab32 <memchr+0x6>
8000ab40:	5e fa       	retal	r10

8000ab42 <memmove>:
8000ab42:	d4 01       	pushm	lr
8000ab44:	18 3b       	cp.w	r11,r12
8000ab46:	c1 92       	brcc	8000ab78 <memmove+0x36>
8000ab48:	f6 0a 00 09 	add	r9,r11,r10
8000ab4c:	12 3c       	cp.w	r12,r9
8000ab4e:	c1 52       	brcc	8000ab78 <memmove+0x36>
8000ab50:	f8 0a 00 0b 	add	r11,r12,r10
8000ab54:	30 08       	mov	r8,0
8000ab56:	c0 68       	rjmp	8000ab62 <memmove+0x20>
8000ab58:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000ab5c:	20 1a       	sub	r10,1
8000ab5e:	f6 08 0b 0e 	st.b	r11[r8],lr
8000ab62:	20 18       	sub	r8,1
8000ab64:	58 0a       	cp.w	r10,0
8000ab66:	cf 91       	brne	8000ab58 <memmove+0x16>
8000ab68:	d8 02       	popm	pc
8000ab6a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000ab6e:	20 1a       	sub	r10,1
8000ab70:	f8 08 0b 09 	st.b	r12[r8],r9
8000ab74:	2f f8       	sub	r8,-1
8000ab76:	c0 28       	rjmp	8000ab7a <memmove+0x38>
8000ab78:	30 08       	mov	r8,0
8000ab7a:	58 0a       	cp.w	r10,0
8000ab7c:	cf 71       	brne	8000ab6a <memmove+0x28>
8000ab7e:	d8 02       	popm	pc

8000ab80 <__hi0bits>:
8000ab80:	18 98       	mov	r8,r12
8000ab82:	e0 1c 00 00 	andl	r12,0x0
8000ab86:	f0 09 15 10 	lsl	r9,r8,0x10
8000ab8a:	58 0c       	cp.w	r12,0
8000ab8c:	f2 08 17 00 	moveq	r8,r9
8000ab90:	f9 bc 00 10 	moveq	r12,16
8000ab94:	f9 bc 01 00 	movne	r12,0
8000ab98:	10 9a       	mov	r10,r8
8000ab9a:	f0 09 15 08 	lsl	r9,r8,0x8
8000ab9e:	e6 1a ff 00 	andh	r10,0xff00,COH
8000aba2:	f7 bc 00 f8 	subeq	r12,-8
8000aba6:	f2 08 17 00 	moveq	r8,r9
8000abaa:	10 9a       	mov	r10,r8
8000abac:	f0 09 15 04 	lsl	r9,r8,0x4
8000abb0:	e6 1a f0 00 	andh	r10,0xf000,COH
8000abb4:	f7 bc 00 fc 	subeq	r12,-4
8000abb8:	f2 08 17 00 	moveq	r8,r9
8000abbc:	10 9a       	mov	r10,r8
8000abbe:	f0 09 15 02 	lsl	r9,r8,0x2
8000abc2:	e6 1a c0 00 	andh	r10,0xc000,COH
8000abc6:	f7 bc 00 fe 	subeq	r12,-2
8000abca:	f2 08 17 00 	moveq	r8,r9
8000abce:	58 08       	cp.w	r8,0
8000abd0:	5e 5c       	retlt	r12
8000abd2:	ed b8 00 1e 	bld	r8,0x1e
8000abd6:	f9 bc 01 20 	movne	r12,32
8000abda:	f7 bc 00 ff 	subeq	r12,-1
8000abde:	5e fc       	retal	r12

8000abe0 <__lo0bits>:
8000abe0:	18 99       	mov	r9,r12
8000abe2:	78 08       	ld.w	r8,r12[0x0]
8000abe4:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000abe8:	c1 50       	breq	8000ac12 <__lo0bits+0x32>
8000abea:	ed b8 00 00 	bld	r8,0x0
8000abee:	c0 21       	brne	8000abf2 <__lo0bits+0x12>
8000abf0:	5e fd       	retal	0
8000abf2:	10 9b       	mov	r11,r8
8000abf4:	f0 0a 16 01 	lsr	r10,r8,0x1
8000abf8:	e2 1b 00 02 	andl	r11,0x2,COH
8000abfc:	a3 88       	lsr	r8,0x2
8000abfe:	58 0b       	cp.w	r11,0
8000ac00:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000ac04:	f9 bc 01 01 	movne	r12,1
8000ac08:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000ac0c:	f9 bc 00 02 	moveq	r12,2
8000ac10:	5e fc       	retal	r12
8000ac12:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000ac16:	f0 0b 16 10 	lsr	r11,r8,0x10
8000ac1a:	58 0a       	cp.w	r10,0
8000ac1c:	f6 08 17 00 	moveq	r8,r11
8000ac20:	f9 bc 00 10 	moveq	r12,16
8000ac24:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000ac28:	f0 0a 16 08 	lsr	r10,r8,0x8
8000ac2c:	58 0b       	cp.w	r11,0
8000ac2e:	f7 bc 00 f8 	subeq	r12,-8
8000ac32:	f4 08 17 00 	moveq	r8,r10
8000ac36:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000ac3a:	f0 0a 16 04 	lsr	r10,r8,0x4
8000ac3e:	58 0b       	cp.w	r11,0
8000ac40:	f7 bc 00 fc 	subeq	r12,-4
8000ac44:	f4 08 17 00 	moveq	r8,r10
8000ac48:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000ac4c:	f0 0a 16 02 	lsr	r10,r8,0x2
8000ac50:	58 0b       	cp.w	r11,0
8000ac52:	f7 bc 00 fe 	subeq	r12,-2
8000ac56:	f4 08 17 00 	moveq	r8,r10
8000ac5a:	ed b8 00 00 	bld	r8,0x0
8000ac5e:	c0 60       	breq	8000ac6a <__lo0bits+0x8a>
8000ac60:	a1 98       	lsr	r8,0x1
8000ac62:	c0 31       	brne	8000ac68 <__lo0bits+0x88>
8000ac64:	32 0c       	mov	r12,32
8000ac66:	5e fc       	retal	r12
8000ac68:	2f fc       	sub	r12,-1
8000ac6a:	93 08       	st.w	r9[0x0],r8
8000ac6c:	5e fc       	retal	r12

8000ac6e <__mcmp>:
8000ac6e:	d4 01       	pushm	lr
8000ac70:	18 98       	mov	r8,r12
8000ac72:	76 49       	ld.w	r9,r11[0x10]
8000ac74:	78 4c       	ld.w	r12,r12[0x10]
8000ac76:	12 1c       	sub	r12,r9
8000ac78:	c1 31       	brne	8000ac9e <__mcmp+0x30>
8000ac7a:	2f b9       	sub	r9,-5
8000ac7c:	a3 69       	lsl	r9,0x2
8000ac7e:	12 0b       	add	r11,r9
8000ac80:	f0 09 00 09 	add	r9,r8,r9
8000ac84:	2e c8       	sub	r8,-20
8000ac86:	13 4e       	ld.w	lr,--r9
8000ac88:	17 4a       	ld.w	r10,--r11
8000ac8a:	14 3e       	cp.w	lr,r10
8000ac8c:	c0 60       	breq	8000ac98 <__mcmp+0x2a>
8000ac8e:	f9 bc 03 ff 	movlo	r12,-1
8000ac92:	f9 bc 02 01 	movhs	r12,1
8000ac96:	d8 02       	popm	pc
8000ac98:	10 39       	cp.w	r9,r8
8000ac9a:	fe 9b ff f6 	brhi	8000ac86 <__mcmp+0x18>
8000ac9e:	d8 02       	popm	pc

8000aca0 <_Bfree>:
8000aca0:	d4 21       	pushm	r4-r7,lr
8000aca2:	18 97       	mov	r7,r12
8000aca4:	16 95       	mov	r5,r11
8000aca6:	78 96       	ld.w	r6,r12[0x24]
8000aca8:	58 06       	cp.w	r6,0
8000acaa:	c0 91       	brne	8000acbc <_Bfree+0x1c>
8000acac:	31 0c       	mov	r12,16
8000acae:	fe b0 de 3d 	rcall	80006928 <malloc>
8000acb2:	99 36       	st.w	r12[0xc],r6
8000acb4:	8f 9c       	st.w	r7[0x24],r12
8000acb6:	99 16       	st.w	r12[0x4],r6
8000acb8:	99 26       	st.w	r12[0x8],r6
8000acba:	99 06       	st.w	r12[0x0],r6
8000acbc:	58 05       	cp.w	r5,0
8000acbe:	c0 90       	breq	8000acd0 <_Bfree+0x30>
8000acc0:	6a 19       	ld.w	r9,r5[0x4]
8000acc2:	6e 98       	ld.w	r8,r7[0x24]
8000acc4:	70 38       	ld.w	r8,r8[0xc]
8000acc6:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000acca:	8b 0a       	st.w	r5[0x0],r10
8000accc:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000acd0:	d8 22       	popm	r4-r7,pc
8000acd2:	d7 03       	nop

8000acd4 <_Balloc>:
8000acd4:	d4 21       	pushm	r4-r7,lr
8000acd6:	18 97       	mov	r7,r12
8000acd8:	16 96       	mov	r6,r11
8000acda:	78 95       	ld.w	r5,r12[0x24]
8000acdc:	58 05       	cp.w	r5,0
8000acde:	c0 91       	brne	8000acf0 <_Balloc+0x1c>
8000ace0:	31 0c       	mov	r12,16
8000ace2:	fe b0 de 23 	rcall	80006928 <malloc>
8000ace6:	99 35       	st.w	r12[0xc],r5
8000ace8:	8f 9c       	st.w	r7[0x24],r12
8000acea:	99 15       	st.w	r12[0x4],r5
8000acec:	99 25       	st.w	r12[0x8],r5
8000acee:	99 05       	st.w	r12[0x0],r5
8000acf0:	6e 95       	ld.w	r5,r7[0x24]
8000acf2:	6a 38       	ld.w	r8,r5[0xc]
8000acf4:	58 08       	cp.w	r8,0
8000acf6:	c0 b1       	brne	8000ad0c <_Balloc+0x38>
8000acf8:	31 0a       	mov	r10,16
8000acfa:	30 4b       	mov	r11,4
8000acfc:	0e 9c       	mov	r12,r7
8000acfe:	e0 a0 02 9b 	rcall	8000b234 <_calloc_r>
8000ad02:	8b 3c       	st.w	r5[0xc],r12
8000ad04:	6e 98       	ld.w	r8,r7[0x24]
8000ad06:	70 3c       	ld.w	r12,r8[0xc]
8000ad08:	58 0c       	cp.w	r12,0
8000ad0a:	c1 b0       	breq	8000ad40 <_Balloc+0x6c>
8000ad0c:	6e 98       	ld.w	r8,r7[0x24]
8000ad0e:	70 38       	ld.w	r8,r8[0xc]
8000ad10:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000ad14:	70 0c       	ld.w	r12,r8[0x0]
8000ad16:	58 0c       	cp.w	r12,0
8000ad18:	c0 40       	breq	8000ad20 <_Balloc+0x4c>
8000ad1a:	78 09       	ld.w	r9,r12[0x0]
8000ad1c:	91 09       	st.w	r8[0x0],r9
8000ad1e:	c0 e8       	rjmp	8000ad3a <_Balloc+0x66>
8000ad20:	0e 9c       	mov	r12,r7
8000ad22:	30 17       	mov	r7,1
8000ad24:	0e 9b       	mov	r11,r7
8000ad26:	ee 06 09 47 	lsl	r7,r7,r6
8000ad2a:	ee ca ff fb 	sub	r10,r7,-5
8000ad2e:	a3 6a       	lsl	r10,0x2
8000ad30:	e0 a0 02 82 	rcall	8000b234 <_calloc_r>
8000ad34:	c0 60       	breq	8000ad40 <_Balloc+0x6c>
8000ad36:	99 16       	st.w	r12[0x4],r6
8000ad38:	99 27       	st.w	r12[0x8],r7
8000ad3a:	30 08       	mov	r8,0
8000ad3c:	99 38       	st.w	r12[0xc],r8
8000ad3e:	99 48       	st.w	r12[0x10],r8
8000ad40:	d8 22       	popm	r4-r7,pc
8000ad42:	d7 03       	nop

8000ad44 <__d2b>:
8000ad44:	d4 31       	pushm	r0-r7,lr
8000ad46:	20 2d       	sub	sp,8
8000ad48:	16 93       	mov	r3,r11
8000ad4a:	12 96       	mov	r6,r9
8000ad4c:	10 95       	mov	r5,r8
8000ad4e:	14 92       	mov	r2,r10
8000ad50:	30 1b       	mov	r11,1
8000ad52:	cc 1f       	rcall	8000acd4 <_Balloc>
8000ad54:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000ad58:	50 09       	stdsp	sp[0x0],r9
8000ad5a:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000ad5e:	b5 a9       	sbr	r9,0x14
8000ad60:	f0 01 16 14 	lsr	r1,r8,0x14
8000ad64:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000ad68:	18 94       	mov	r4,r12
8000ad6a:	58 02       	cp.w	r2,0
8000ad6c:	c1 d0       	breq	8000ada6 <__d2b+0x62>
8000ad6e:	fa cc ff f8 	sub	r12,sp,-8
8000ad72:	18 d2       	st.w	--r12,r2
8000ad74:	c3 6f       	rcall	8000abe0 <__lo0bits>
8000ad76:	40 18       	lddsp	r8,sp[0x4]
8000ad78:	c0 d0       	breq	8000ad92 <__d2b+0x4e>
8000ad7a:	40 09       	lddsp	r9,sp[0x0]
8000ad7c:	f8 0a 11 20 	rsub	r10,r12,32
8000ad80:	f2 0a 09 4a 	lsl	r10,r9,r10
8000ad84:	f5 e8 10 08 	or	r8,r10,r8
8000ad88:	89 58       	st.w	r4[0x14],r8
8000ad8a:	f2 0c 0a 49 	lsr	r9,r9,r12
8000ad8e:	50 09       	stdsp	sp[0x0],r9
8000ad90:	c0 28       	rjmp	8000ad94 <__d2b+0x50>
8000ad92:	89 58       	st.w	r4[0x14],r8
8000ad94:	40 08       	lddsp	r8,sp[0x0]
8000ad96:	58 08       	cp.w	r8,0
8000ad98:	f9 b3 01 02 	movne	r3,2
8000ad9c:	f9 b3 00 01 	moveq	r3,1
8000ada0:	89 68       	st.w	r4[0x18],r8
8000ada2:	89 43       	st.w	r4[0x10],r3
8000ada4:	c0 88       	rjmp	8000adb4 <__d2b+0x70>
8000ada6:	1a 9c       	mov	r12,sp
8000ada8:	c1 cf       	rcall	8000abe0 <__lo0bits>
8000adaa:	30 13       	mov	r3,1
8000adac:	40 08       	lddsp	r8,sp[0x0]
8000adae:	2e 0c       	sub	r12,-32
8000adb0:	89 43       	st.w	r4[0x10],r3
8000adb2:	89 58       	st.w	r4[0x14],r8
8000adb4:	58 01       	cp.w	r1,0
8000adb6:	c0 90       	breq	8000adc8 <__d2b+0x84>
8000adb8:	e2 c1 04 33 	sub	r1,r1,1075
8000adbc:	18 01       	add	r1,r12
8000adbe:	8d 01       	st.w	r6[0x0],r1
8000adc0:	f8 0c 11 35 	rsub	r12,r12,53
8000adc4:	8b 0c       	st.w	r5[0x0],r12
8000adc6:	c0 c8       	rjmp	8000adde <__d2b+0x9a>
8000adc8:	e6 c8 ff fc 	sub	r8,r3,-4
8000adcc:	f8 cc 04 32 	sub	r12,r12,1074
8000add0:	a5 73       	lsl	r3,0x5
8000add2:	8d 0c       	st.w	r6[0x0],r12
8000add4:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000add8:	cd 4e       	rcall	8000ab80 <__hi0bits>
8000adda:	18 13       	sub	r3,r12
8000addc:	8b 03       	st.w	r5[0x0],r3
8000adde:	08 9c       	mov	r12,r4
8000ade0:	2f ed       	sub	sp,-8
8000ade2:	d8 32       	popm	r0-r7,pc

8000ade4 <__mdiff>:
8000ade4:	d4 31       	pushm	r0-r7,lr
8000ade6:	74 48       	ld.w	r8,r10[0x10]
8000ade8:	76 45       	ld.w	r5,r11[0x10]
8000adea:	16 97       	mov	r7,r11
8000adec:	14 96       	mov	r6,r10
8000adee:	10 15       	sub	r5,r8
8000adf0:	c1 31       	brne	8000ae16 <__mdiff+0x32>
8000adf2:	2f b8       	sub	r8,-5
8000adf4:	ee ce ff ec 	sub	lr,r7,-20
8000adf8:	a3 68       	lsl	r8,0x2
8000adfa:	f4 08 00 0b 	add	r11,r10,r8
8000adfe:	ee 08 00 08 	add	r8,r7,r8
8000ae02:	11 4a       	ld.w	r10,--r8
8000ae04:	17 49       	ld.w	r9,--r11
8000ae06:	12 3a       	cp.w	r10,r9
8000ae08:	c0 30       	breq	8000ae0e <__mdiff+0x2a>
8000ae0a:	c0 e2       	brcc	8000ae26 <__mdiff+0x42>
8000ae0c:	c0 78       	rjmp	8000ae1a <__mdiff+0x36>
8000ae0e:	1c 38       	cp.w	r8,lr
8000ae10:	fe 9b ff f9 	brhi	8000ae02 <__mdiff+0x1e>
8000ae14:	c4 98       	rjmp	8000aea6 <__mdiff+0xc2>
8000ae16:	58 05       	cp.w	r5,0
8000ae18:	c0 64       	brge	8000ae24 <__mdiff+0x40>
8000ae1a:	0e 98       	mov	r8,r7
8000ae1c:	30 15       	mov	r5,1
8000ae1e:	0c 97       	mov	r7,r6
8000ae20:	10 96       	mov	r6,r8
8000ae22:	c0 28       	rjmp	8000ae26 <__mdiff+0x42>
8000ae24:	30 05       	mov	r5,0
8000ae26:	6e 1b       	ld.w	r11,r7[0x4]
8000ae28:	c5 6f       	rcall	8000acd4 <_Balloc>
8000ae2a:	6e 49       	ld.w	r9,r7[0x10]
8000ae2c:	6c 44       	ld.w	r4,r6[0x10]
8000ae2e:	99 35       	st.w	r12[0xc],r5
8000ae30:	2f b4       	sub	r4,-5
8000ae32:	f2 c5 ff fb 	sub	r5,r9,-5
8000ae36:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000ae3a:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000ae3e:	2e c6       	sub	r6,-20
8000ae40:	2e c7       	sub	r7,-20
8000ae42:	f8 c8 ff ec 	sub	r8,r12,-20
8000ae46:	30 0a       	mov	r10,0
8000ae48:	0f 0e       	ld.w	lr,r7++
8000ae4a:	0d 0b       	ld.w	r11,r6++
8000ae4c:	fc 02 16 10 	lsr	r2,lr,0x10
8000ae50:	f6 03 16 10 	lsr	r3,r11,0x10
8000ae54:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000ae58:	e4 03 01 03 	sub	r3,r2,r3
8000ae5c:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ae60:	fc 0b 01 0b 	sub	r11,lr,r11
8000ae64:	f6 0a 00 0a 	add	r10,r11,r10
8000ae68:	b0 1a       	st.h	r8[0x2],r10
8000ae6a:	b1 4a       	asr	r10,0x10
8000ae6c:	e6 0a 00 0a 	add	r10,r3,r10
8000ae70:	b0 0a       	st.h	r8[0x0],r10
8000ae72:	2f c8       	sub	r8,-4
8000ae74:	b1 4a       	asr	r10,0x10
8000ae76:	08 36       	cp.w	r6,r4
8000ae78:	ce 83       	brcs	8000ae48 <__mdiff+0x64>
8000ae7a:	c0 d8       	rjmp	8000ae94 <__mdiff+0xb0>
8000ae7c:	0f 0b       	ld.w	r11,r7++
8000ae7e:	f6 0e 16 10 	lsr	lr,r11,0x10
8000ae82:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ae86:	16 0a       	add	r10,r11
8000ae88:	b0 1a       	st.h	r8[0x2],r10
8000ae8a:	b1 4a       	asr	r10,0x10
8000ae8c:	1c 0a       	add	r10,lr
8000ae8e:	b0 0a       	st.h	r8[0x0],r10
8000ae90:	2f c8       	sub	r8,-4
8000ae92:	b1 4a       	asr	r10,0x10
8000ae94:	0a 37       	cp.w	r7,r5
8000ae96:	cf 33       	brcs	8000ae7c <__mdiff+0x98>
8000ae98:	c0 28       	rjmp	8000ae9c <__mdiff+0xb8>
8000ae9a:	20 19       	sub	r9,1
8000ae9c:	11 4a       	ld.w	r10,--r8
8000ae9e:	58 0a       	cp.w	r10,0
8000aea0:	cf d0       	breq	8000ae9a <__mdiff+0xb6>
8000aea2:	99 49       	st.w	r12[0x10],r9
8000aea4:	d8 32       	popm	r0-r7,pc
8000aea6:	30 0b       	mov	r11,0
8000aea8:	c1 6f       	rcall	8000acd4 <_Balloc>
8000aeaa:	30 18       	mov	r8,1
8000aeac:	99 48       	st.w	r12[0x10],r8
8000aeae:	30 08       	mov	r8,0
8000aeb0:	99 58       	st.w	r12[0x14],r8
8000aeb2:	d8 32       	popm	r0-r7,pc

8000aeb4 <__lshift>:
8000aeb4:	d4 31       	pushm	r0-r7,lr
8000aeb6:	16 97       	mov	r7,r11
8000aeb8:	76 46       	ld.w	r6,r11[0x10]
8000aeba:	f4 02 14 05 	asr	r2,r10,0x5
8000aebe:	2f f6       	sub	r6,-1
8000aec0:	14 93       	mov	r3,r10
8000aec2:	18 94       	mov	r4,r12
8000aec4:	04 06       	add	r6,r2
8000aec6:	76 1b       	ld.w	r11,r11[0x4]
8000aec8:	6e 28       	ld.w	r8,r7[0x8]
8000aeca:	c0 38       	rjmp	8000aed0 <__lshift+0x1c>
8000aecc:	2f fb       	sub	r11,-1
8000aece:	a1 78       	lsl	r8,0x1
8000aed0:	10 36       	cp.w	r6,r8
8000aed2:	fe 99 ff fd 	brgt	8000aecc <__lshift+0x18>
8000aed6:	08 9c       	mov	r12,r4
8000aed8:	cf ee       	rcall	8000acd4 <_Balloc>
8000aeda:	30 09       	mov	r9,0
8000aedc:	18 95       	mov	r5,r12
8000aede:	f8 c8 ff ec 	sub	r8,r12,-20
8000aee2:	12 9a       	mov	r10,r9
8000aee4:	c0 38       	rjmp	8000aeea <__lshift+0x36>
8000aee6:	10 aa       	st.w	r8++,r10
8000aee8:	2f f9       	sub	r9,-1
8000aeea:	04 39       	cp.w	r9,r2
8000aeec:	cf d5       	brlt	8000aee6 <__lshift+0x32>
8000aeee:	6e 4b       	ld.w	r11,r7[0x10]
8000aef0:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000aef4:	2f bb       	sub	r11,-5
8000aef6:	ee c9 ff ec 	sub	r9,r7,-20
8000aefa:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000aefe:	58 03       	cp.w	r3,0
8000af00:	c1 30       	breq	8000af26 <__lshift+0x72>
8000af02:	e6 0c 11 20 	rsub	r12,r3,32
8000af06:	30 0a       	mov	r10,0
8000af08:	72 02       	ld.w	r2,r9[0x0]
8000af0a:	e4 03 09 42 	lsl	r2,r2,r3
8000af0e:	04 4a       	or	r10,r2
8000af10:	10 aa       	st.w	r8++,r10
8000af12:	13 0a       	ld.w	r10,r9++
8000af14:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000af18:	16 39       	cp.w	r9,r11
8000af1a:	cf 73       	brcs	8000af08 <__lshift+0x54>
8000af1c:	91 0a       	st.w	r8[0x0],r10
8000af1e:	58 0a       	cp.w	r10,0
8000af20:	c0 70       	breq	8000af2e <__lshift+0x7a>
8000af22:	2f f6       	sub	r6,-1
8000af24:	c0 58       	rjmp	8000af2e <__lshift+0x7a>
8000af26:	13 0a       	ld.w	r10,r9++
8000af28:	10 aa       	st.w	r8++,r10
8000af2a:	16 39       	cp.w	r9,r11
8000af2c:	cf d3       	brcs	8000af26 <__lshift+0x72>
8000af2e:	08 9c       	mov	r12,r4
8000af30:	20 16       	sub	r6,1
8000af32:	0e 9b       	mov	r11,r7
8000af34:	8b 46       	st.w	r5[0x10],r6
8000af36:	cb 5e       	rcall	8000aca0 <_Bfree>
8000af38:	0a 9c       	mov	r12,r5
8000af3a:	d8 32       	popm	r0-r7,pc

8000af3c <__multiply>:
8000af3c:	d4 31       	pushm	r0-r7,lr
8000af3e:	20 2d       	sub	sp,8
8000af40:	76 49       	ld.w	r9,r11[0x10]
8000af42:	74 48       	ld.w	r8,r10[0x10]
8000af44:	16 96       	mov	r6,r11
8000af46:	14 95       	mov	r5,r10
8000af48:	10 39       	cp.w	r9,r8
8000af4a:	ec 08 17 50 	movlt	r8,r6
8000af4e:	ea 06 17 50 	movlt	r6,r5
8000af52:	f0 05 17 50 	movlt	r5,r8
8000af56:	6c 28       	ld.w	r8,r6[0x8]
8000af58:	76 43       	ld.w	r3,r11[0x10]
8000af5a:	74 42       	ld.w	r2,r10[0x10]
8000af5c:	76 1b       	ld.w	r11,r11[0x4]
8000af5e:	e4 03 00 07 	add	r7,r2,r3
8000af62:	10 37       	cp.w	r7,r8
8000af64:	f7 bb 09 ff 	subgt	r11,-1
8000af68:	cb 6e       	rcall	8000acd4 <_Balloc>
8000af6a:	ee c4 ff fb 	sub	r4,r7,-5
8000af6e:	f8 c9 ff ec 	sub	r9,r12,-20
8000af72:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000af76:	30 0a       	mov	r10,0
8000af78:	12 98       	mov	r8,r9
8000af7a:	c0 28       	rjmp	8000af7e <__multiply+0x42>
8000af7c:	10 aa       	st.w	r8++,r10
8000af7e:	08 38       	cp.w	r8,r4
8000af80:	cf e3       	brcs	8000af7c <__multiply+0x40>
8000af82:	2f b3       	sub	r3,-5
8000af84:	2f b2       	sub	r2,-5
8000af86:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000af8a:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000af8e:	ec cb ff ec 	sub	r11,r6,-20
8000af92:	50 12       	stdsp	sp[0x4],r2
8000af94:	ea ca ff ec 	sub	r10,r5,-20
8000af98:	c4 48       	rjmp	8000b020 <__multiply+0xe4>
8000af9a:	94 95       	ld.uh	r5,r10[0x2]
8000af9c:	58 05       	cp.w	r5,0
8000af9e:	c2 00       	breq	8000afde <__multiply+0xa2>
8000afa0:	12 98       	mov	r8,r9
8000afa2:	16 96       	mov	r6,r11
8000afa4:	30 0e       	mov	lr,0
8000afa6:	50 09       	stdsp	sp[0x0],r9
8000afa8:	0d 02       	ld.w	r2,r6++
8000afaa:	e4 00 16 10 	lsr	r0,r2,0x10
8000afae:	70 01       	ld.w	r1,r8[0x0]
8000afb0:	70 09       	ld.w	r9,r8[0x0]
8000afb2:	b1 81       	lsr	r1,0x10
8000afb4:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000afb8:	e0 05 03 41 	mac	r1,r0,r5
8000afbc:	ab 32       	mul	r2,r5
8000afbe:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000afc2:	00 02       	add	r2,r0
8000afc4:	e4 0e 00 0e 	add	lr,r2,lr
8000afc8:	b0 1e       	st.h	r8[0x2],lr
8000afca:	b1 8e       	lsr	lr,0x10
8000afcc:	1c 01       	add	r1,lr
8000afce:	b0 01       	st.h	r8[0x0],r1
8000afd0:	e2 0e 16 10 	lsr	lr,r1,0x10
8000afd4:	2f c8       	sub	r8,-4
8000afd6:	06 36       	cp.w	r6,r3
8000afd8:	ce 83       	brcs	8000afa8 <__multiply+0x6c>
8000afda:	40 09       	lddsp	r9,sp[0x0]
8000afdc:	91 0e       	st.w	r8[0x0],lr
8000afde:	94 86       	ld.uh	r6,r10[0x0]
8000afe0:	58 06       	cp.w	r6,0
8000afe2:	c1 d0       	breq	8000b01c <__multiply+0xe0>
8000afe4:	72 02       	ld.w	r2,r9[0x0]
8000afe6:	12 98       	mov	r8,r9
8000afe8:	16 9e       	mov	lr,r11
8000afea:	30 05       	mov	r5,0
8000afec:	b0 12       	st.h	r8[0x2],r2
8000afee:	1d 01       	ld.w	r1,lr++
8000aff0:	90 82       	ld.uh	r2,r8[0x0]
8000aff2:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000aff6:	ad 30       	mul	r0,r6
8000aff8:	e0 02 00 02 	add	r2,r0,r2
8000affc:	e4 05 00 05 	add	r5,r2,r5
8000b000:	b0 05       	st.h	r8[0x0],r5
8000b002:	b1 85       	lsr	r5,0x10
8000b004:	b1 81       	lsr	r1,0x10
8000b006:	2f c8       	sub	r8,-4
8000b008:	ad 31       	mul	r1,r6
8000b00a:	90 92       	ld.uh	r2,r8[0x2]
8000b00c:	e2 02 00 02 	add	r2,r1,r2
8000b010:	0a 02       	add	r2,r5
8000b012:	e4 05 16 10 	lsr	r5,r2,0x10
8000b016:	06 3e       	cp.w	lr,r3
8000b018:	ce a3       	brcs	8000afec <__multiply+0xb0>
8000b01a:	91 02       	st.w	r8[0x0],r2
8000b01c:	2f ca       	sub	r10,-4
8000b01e:	2f c9       	sub	r9,-4
8000b020:	40 18       	lddsp	r8,sp[0x4]
8000b022:	10 3a       	cp.w	r10,r8
8000b024:	cb b3       	brcs	8000af9a <__multiply+0x5e>
8000b026:	c0 28       	rjmp	8000b02a <__multiply+0xee>
8000b028:	20 17       	sub	r7,1
8000b02a:	58 07       	cp.w	r7,0
8000b02c:	e0 8a 00 05 	brle	8000b036 <__multiply+0xfa>
8000b030:	09 48       	ld.w	r8,--r4
8000b032:	58 08       	cp.w	r8,0
8000b034:	cf a0       	breq	8000b028 <__multiply+0xec>
8000b036:	99 47       	st.w	r12[0x10],r7
8000b038:	2f ed       	sub	sp,-8
8000b03a:	d8 32       	popm	r0-r7,pc

8000b03c <__i2b>:
8000b03c:	d4 21       	pushm	r4-r7,lr
8000b03e:	16 97       	mov	r7,r11
8000b040:	30 1b       	mov	r11,1
8000b042:	c4 9e       	rcall	8000acd4 <_Balloc>
8000b044:	30 19       	mov	r9,1
8000b046:	99 57       	st.w	r12[0x14],r7
8000b048:	99 49       	st.w	r12[0x10],r9
8000b04a:	d8 22       	popm	r4-r7,pc

8000b04c <__multadd>:
8000b04c:	d4 31       	pushm	r0-r7,lr
8000b04e:	30 08       	mov	r8,0
8000b050:	12 95       	mov	r5,r9
8000b052:	16 97       	mov	r7,r11
8000b054:	18 96       	mov	r6,r12
8000b056:	76 44       	ld.w	r4,r11[0x10]
8000b058:	f6 c9 ff ec 	sub	r9,r11,-20
8000b05c:	72 0b       	ld.w	r11,r9[0x0]
8000b05e:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b062:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b066:	f4 0c 02 4c 	mul	r12,r10,r12
8000b06a:	f4 0b 03 45 	mac	r5,r10,r11
8000b06e:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b072:	b1 85       	lsr	r5,0x10
8000b074:	18 05       	add	r5,r12
8000b076:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b07a:	f8 0b 00 0b 	add	r11,r12,r11
8000b07e:	12 ab       	st.w	r9++,r11
8000b080:	2f f8       	sub	r8,-1
8000b082:	b1 85       	lsr	r5,0x10
8000b084:	08 38       	cp.w	r8,r4
8000b086:	ce b5       	brlt	8000b05c <__multadd+0x10>
8000b088:	58 05       	cp.w	r5,0
8000b08a:	c1 c0       	breq	8000b0c2 <__multadd+0x76>
8000b08c:	6e 28       	ld.w	r8,r7[0x8]
8000b08e:	10 34       	cp.w	r4,r8
8000b090:	c1 35       	brlt	8000b0b6 <__multadd+0x6a>
8000b092:	6e 1b       	ld.w	r11,r7[0x4]
8000b094:	0c 9c       	mov	r12,r6
8000b096:	2f fb       	sub	r11,-1
8000b098:	c1 ee       	rcall	8000acd4 <_Balloc>
8000b09a:	6e 4a       	ld.w	r10,r7[0x10]
8000b09c:	ee cb ff f4 	sub	r11,r7,-12
8000b0a0:	18 93       	mov	r3,r12
8000b0a2:	2f ea       	sub	r10,-2
8000b0a4:	2f 4c       	sub	r12,-12
8000b0a6:	a3 6a       	lsl	r10,0x2
8000b0a8:	fe b0 de 64 	rcall	80006d70 <memcpy>
8000b0ac:	0e 9b       	mov	r11,r7
8000b0ae:	0c 9c       	mov	r12,r6
8000b0b0:	fe b0 fd f8 	rcall	8000aca0 <_Bfree>
8000b0b4:	06 97       	mov	r7,r3
8000b0b6:	e8 c8 ff ff 	sub	r8,r4,-1
8000b0ba:	2f b4       	sub	r4,-5
8000b0bc:	8f 48       	st.w	r7[0x10],r8
8000b0be:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b0c2:	0e 9c       	mov	r12,r7
8000b0c4:	d8 32       	popm	r0-r7,pc
8000b0c6:	d7 03       	nop

8000b0c8 <__pow5mult>:
8000b0c8:	d4 31       	pushm	r0-r7,lr
8000b0ca:	14 96       	mov	r6,r10
8000b0cc:	18 97       	mov	r7,r12
8000b0ce:	16 94       	mov	r4,r11
8000b0d0:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b0d4:	c0 90       	breq	8000b0e6 <__pow5mult+0x1e>
8000b0d6:	20 18       	sub	r8,1
8000b0d8:	fe c9 d6 cc 	sub	r9,pc,-10548
8000b0dc:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b0e0:	30 09       	mov	r9,0
8000b0e2:	cb 5f       	rcall	8000b04c <__multadd>
8000b0e4:	18 94       	mov	r4,r12
8000b0e6:	a3 46       	asr	r6,0x2
8000b0e8:	c3 40       	breq	8000b150 <__pow5mult+0x88>
8000b0ea:	6e 95       	ld.w	r5,r7[0x24]
8000b0ec:	58 05       	cp.w	r5,0
8000b0ee:	c0 91       	brne	8000b100 <__pow5mult+0x38>
8000b0f0:	31 0c       	mov	r12,16
8000b0f2:	fe b0 dc 1b 	rcall	80006928 <malloc>
8000b0f6:	99 35       	st.w	r12[0xc],r5
8000b0f8:	8f 9c       	st.w	r7[0x24],r12
8000b0fa:	99 15       	st.w	r12[0x4],r5
8000b0fc:	99 25       	st.w	r12[0x8],r5
8000b0fe:	99 05       	st.w	r12[0x0],r5
8000b100:	6e 93       	ld.w	r3,r7[0x24]
8000b102:	66 25       	ld.w	r5,r3[0x8]
8000b104:	58 05       	cp.w	r5,0
8000b106:	c0 c1       	brne	8000b11e <__pow5mult+0x56>
8000b108:	e0 6b 02 71 	mov	r11,625
8000b10c:	0e 9c       	mov	r12,r7
8000b10e:	c9 7f       	rcall	8000b03c <__i2b>
8000b110:	87 2c       	st.w	r3[0x8],r12
8000b112:	30 08       	mov	r8,0
8000b114:	18 95       	mov	r5,r12
8000b116:	99 08       	st.w	r12[0x0],r8
8000b118:	c0 38       	rjmp	8000b11e <__pow5mult+0x56>
8000b11a:	06 9c       	mov	r12,r3
8000b11c:	18 95       	mov	r5,r12
8000b11e:	ed b6 00 00 	bld	r6,0x0
8000b122:	c0 b1       	brne	8000b138 <__pow5mult+0x70>
8000b124:	08 9b       	mov	r11,r4
8000b126:	0a 9a       	mov	r10,r5
8000b128:	0e 9c       	mov	r12,r7
8000b12a:	c0 9f       	rcall	8000af3c <__multiply>
8000b12c:	08 9b       	mov	r11,r4
8000b12e:	18 93       	mov	r3,r12
8000b130:	0e 9c       	mov	r12,r7
8000b132:	06 94       	mov	r4,r3
8000b134:	fe b0 fd b6 	rcall	8000aca0 <_Bfree>
8000b138:	a1 56       	asr	r6,0x1
8000b13a:	c0 b0       	breq	8000b150 <__pow5mult+0x88>
8000b13c:	6a 03       	ld.w	r3,r5[0x0]
8000b13e:	58 03       	cp.w	r3,0
8000b140:	ce d1       	brne	8000b11a <__pow5mult+0x52>
8000b142:	0a 9a       	mov	r10,r5
8000b144:	0a 9b       	mov	r11,r5
8000b146:	0e 9c       	mov	r12,r7
8000b148:	cf ae       	rcall	8000af3c <__multiply>
8000b14a:	8b 0c       	st.w	r5[0x0],r12
8000b14c:	99 03       	st.w	r12[0x0],r3
8000b14e:	ce 7b       	rjmp	8000b11c <__pow5mult+0x54>
8000b150:	08 9c       	mov	r12,r4
8000b152:	d8 32       	popm	r0-r7,pc

8000b154 <__isinfd>:
8000b154:	14 98       	mov	r8,r10
8000b156:	fc 19 7f f0 	movh	r9,0x7ff0
8000b15a:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b15e:	f0 0b 11 00 	rsub	r11,r8,0
8000b162:	f7 e8 10 08 	or	r8,r11,r8
8000b166:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b16a:	f2 08 01 08 	sub	r8,r9,r8
8000b16e:	f0 0c 11 00 	rsub	r12,r8,0
8000b172:	f9 e8 10 08 	or	r8,r12,r8
8000b176:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b17a:	2f fc       	sub	r12,-1
8000b17c:	5e fc       	retal	r12

8000b17e <__isnand>:
8000b17e:	14 98       	mov	r8,r10
8000b180:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b184:	f0 0c 11 00 	rsub	r12,r8,0
8000b188:	10 4c       	or	r12,r8
8000b18a:	fc 18 7f f0 	movh	r8,0x7ff0
8000b18e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b192:	f0 0c 01 0c 	sub	r12,r8,r12
8000b196:	bf 9c       	lsr	r12,0x1f
8000b198:	5e fc       	retal	r12
8000b19a:	d7 03       	nop

8000b19c <__sclose>:
8000b19c:	d4 01       	pushm	lr
8000b19e:	96 7b       	ld.sh	r11,r11[0xe]
8000b1a0:	c7 6c       	rcall	8000b28c <_close_r>
8000b1a2:	d8 02       	popm	pc

8000b1a4 <__sseek>:
8000b1a4:	d4 21       	pushm	r4-r7,lr
8000b1a6:	16 97       	mov	r7,r11
8000b1a8:	96 7b       	ld.sh	r11,r11[0xe]
8000b1aa:	cf 7c       	rcall	8000b398 <_lseek_r>
8000b1ac:	8e 68       	ld.sh	r8,r7[0xc]
8000b1ae:	10 99       	mov	r9,r8
8000b1b0:	ad c8       	cbr	r8,0xc
8000b1b2:	ad a9       	sbr	r9,0xc
8000b1b4:	5b fc       	cp.w	r12,-1
8000b1b6:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b1ba:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b1be:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b1c2:	d8 22       	popm	r4-r7,pc

8000b1c4 <__swrite>:
8000b1c4:	d4 21       	pushm	r4-r7,lr
8000b1c6:	96 68       	ld.sh	r8,r11[0xc]
8000b1c8:	16 97       	mov	r7,r11
8000b1ca:	14 95       	mov	r5,r10
8000b1cc:	12 94       	mov	r4,r9
8000b1ce:	e2 18 01 00 	andl	r8,0x100,COH
8000b1d2:	18 96       	mov	r6,r12
8000b1d4:	c0 50       	breq	8000b1de <__swrite+0x1a>
8000b1d6:	30 29       	mov	r9,2
8000b1d8:	30 0a       	mov	r10,0
8000b1da:	96 7b       	ld.sh	r11,r11[0xe]
8000b1dc:	cd ec       	rcall	8000b398 <_lseek_r>
8000b1de:	8e 68       	ld.sh	r8,r7[0xc]
8000b1e0:	ad c8       	cbr	r8,0xc
8000b1e2:	08 99       	mov	r9,r4
8000b1e4:	0a 9a       	mov	r10,r5
8000b1e6:	8e 7b       	ld.sh	r11,r7[0xe]
8000b1e8:	0c 9c       	mov	r12,r6
8000b1ea:	ae 68       	st.h	r7[0xc],r8
8000b1ec:	c1 0c       	rcall	8000b20c <_write_r>
8000b1ee:	d8 22       	popm	r4-r7,pc

8000b1f0 <__sread>:
8000b1f0:	d4 21       	pushm	r4-r7,lr
8000b1f2:	16 97       	mov	r7,r11
8000b1f4:	96 7b       	ld.sh	r11,r11[0xe]
8000b1f6:	ce 5c       	rcall	8000b3c0 <_read_r>
8000b1f8:	c0 65       	brlt	8000b204 <__sread+0x14>
8000b1fa:	6f 58       	ld.w	r8,r7[0x54]
8000b1fc:	18 08       	add	r8,r12
8000b1fe:	ef 48 00 54 	st.w	r7[84],r8
8000b202:	d8 22       	popm	r4-r7,pc
8000b204:	8e 68       	ld.sh	r8,r7[0xc]
8000b206:	ad c8       	cbr	r8,0xc
8000b208:	ae 68       	st.h	r7[0xc],r8
8000b20a:	d8 22       	popm	r4-r7,pc

8000b20c <_write_r>:
8000b20c:	d4 21       	pushm	r4-r7,lr
8000b20e:	16 98       	mov	r8,r11
8000b210:	18 97       	mov	r7,r12
8000b212:	10 9c       	mov	r12,r8
8000b214:	30 08       	mov	r8,0
8000b216:	14 9b       	mov	r11,r10
8000b218:	e0 66 41 18 	mov	r6,16664
8000b21c:	12 9a       	mov	r10,r9
8000b21e:	8d 08       	st.w	r6[0x0],r8
8000b220:	fe b0 d1 24 	rcall	80005468 <_write>
8000b224:	5b fc       	cp.w	r12,-1
8000b226:	c0 51       	brne	8000b230 <_write_r+0x24>
8000b228:	6c 08       	ld.w	r8,r6[0x0]
8000b22a:	58 08       	cp.w	r8,0
8000b22c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b230:	d8 22       	popm	r4-r7,pc
8000b232:	d7 03       	nop

8000b234 <_calloc_r>:
8000b234:	d4 21       	pushm	r4-r7,lr
8000b236:	f4 0b 02 4b 	mul	r11,r10,r11
8000b23a:	fe b0 db 7f 	rcall	80006938 <_malloc_r>
8000b23e:	18 97       	mov	r7,r12
8000b240:	c2 30       	breq	8000b286 <_calloc_r+0x52>
8000b242:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b246:	e0 1a ff fc 	andl	r10,0xfffc
8000b24a:	20 4a       	sub	r10,4
8000b24c:	e0 4a 00 24 	cp.w	r10,36
8000b250:	e0 8b 00 18 	brhi	8000b280 <_calloc_r+0x4c>
8000b254:	18 98       	mov	r8,r12
8000b256:	59 3a       	cp.w	r10,19
8000b258:	e0 88 00 0f 	brls	8000b276 <_calloc_r+0x42>
8000b25c:	30 09       	mov	r9,0
8000b25e:	10 a9       	st.w	r8++,r9
8000b260:	10 a9       	st.w	r8++,r9
8000b262:	59 ba       	cp.w	r10,27
8000b264:	e0 88 00 09 	brls	8000b276 <_calloc_r+0x42>
8000b268:	10 a9       	st.w	r8++,r9
8000b26a:	10 a9       	st.w	r8++,r9
8000b26c:	e0 4a 00 24 	cp.w	r10,36
8000b270:	c0 31       	brne	8000b276 <_calloc_r+0x42>
8000b272:	10 a9       	st.w	r8++,r9
8000b274:	10 a9       	st.w	r8++,r9
8000b276:	30 09       	mov	r9,0
8000b278:	10 a9       	st.w	r8++,r9
8000b27a:	91 19       	st.w	r8[0x4],r9
8000b27c:	91 09       	st.w	r8[0x0],r9
8000b27e:	c0 48       	rjmp	8000b286 <_calloc_r+0x52>
8000b280:	30 0b       	mov	r11,0
8000b282:	fe b0 de 1b 	rcall	80006eb8 <memset>
8000b286:	0e 9c       	mov	r12,r7
8000b288:	d8 22       	popm	r4-r7,pc
8000b28a:	d7 03       	nop

8000b28c <_close_r>:
8000b28c:	d4 21       	pushm	r4-r7,lr
8000b28e:	30 08       	mov	r8,0
8000b290:	18 97       	mov	r7,r12
8000b292:	e0 66 41 18 	mov	r6,16664
8000b296:	16 9c       	mov	r12,r11
8000b298:	8d 08       	st.w	r6[0x0],r8
8000b29a:	fe b0 df c1 	rcall	8000721c <_close>
8000b29e:	5b fc       	cp.w	r12,-1
8000b2a0:	c0 51       	brne	8000b2aa <_close_r+0x1e>
8000b2a2:	6c 08       	ld.w	r8,r6[0x0]
8000b2a4:	58 08       	cp.w	r8,0
8000b2a6:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b2aa:	d8 22       	popm	r4-r7,pc

8000b2ac <_fclose_r>:
8000b2ac:	d4 21       	pushm	r4-r7,lr
8000b2ae:	18 96       	mov	r6,r12
8000b2b0:	16 97       	mov	r7,r11
8000b2b2:	58 0b       	cp.w	r11,0
8000b2b4:	c0 31       	brne	8000b2ba <_fclose_r+0xe>
8000b2b6:	16 95       	mov	r5,r11
8000b2b8:	c5 38       	rjmp	8000b35e <_fclose_r+0xb2>
8000b2ba:	fe b0 f8 b5 	rcall	8000a424 <__sfp_lock_acquire>
8000b2be:	58 06       	cp.w	r6,0
8000b2c0:	c0 70       	breq	8000b2ce <_fclose_r+0x22>
8000b2c2:	6c 68       	ld.w	r8,r6[0x18]
8000b2c4:	58 08       	cp.w	r8,0
8000b2c6:	c0 41       	brne	8000b2ce <_fclose_r+0x22>
8000b2c8:	0c 9c       	mov	r12,r6
8000b2ca:	fe b0 f8 ff 	rcall	8000a4c8 <__sinit>
8000b2ce:	fe c8 d9 66 	sub	r8,pc,-9882
8000b2d2:	10 37       	cp.w	r7,r8
8000b2d4:	c0 31       	brne	8000b2da <_fclose_r+0x2e>
8000b2d6:	6c 07       	ld.w	r7,r6[0x0]
8000b2d8:	c0 c8       	rjmp	8000b2f0 <_fclose_r+0x44>
8000b2da:	fe c8 d9 52 	sub	r8,pc,-9902
8000b2de:	10 37       	cp.w	r7,r8
8000b2e0:	c0 31       	brne	8000b2e6 <_fclose_r+0x3a>
8000b2e2:	6c 17       	ld.w	r7,r6[0x4]
8000b2e4:	c0 68       	rjmp	8000b2f0 <_fclose_r+0x44>
8000b2e6:	fe c8 d9 3e 	sub	r8,pc,-9922
8000b2ea:	10 37       	cp.w	r7,r8
8000b2ec:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b2f0:	8e 69       	ld.sh	r9,r7[0xc]
8000b2f2:	30 08       	mov	r8,0
8000b2f4:	f0 09 19 00 	cp.h	r9,r8
8000b2f8:	c0 51       	brne	8000b302 <_fclose_r+0x56>
8000b2fa:	fe b0 f8 96 	rcall	8000a426 <__sfp_lock_release>
8000b2fe:	30 05       	mov	r5,0
8000b300:	c2 f8       	rjmp	8000b35e <_fclose_r+0xb2>
8000b302:	0e 9b       	mov	r11,r7
8000b304:	0c 9c       	mov	r12,r6
8000b306:	fe b0 f8 09 	rcall	8000a318 <_fflush_r>
8000b30a:	6e c8       	ld.w	r8,r7[0x30]
8000b30c:	18 95       	mov	r5,r12
8000b30e:	58 08       	cp.w	r8,0
8000b310:	c0 60       	breq	8000b31c <_fclose_r+0x70>
8000b312:	6e 8b       	ld.w	r11,r7[0x20]
8000b314:	0c 9c       	mov	r12,r6
8000b316:	5d 18       	icall	r8
8000b318:	f9 b5 05 ff 	movlt	r5,-1
8000b31c:	8e 68       	ld.sh	r8,r7[0xc]
8000b31e:	ed b8 00 07 	bld	r8,0x7
8000b322:	c0 51       	brne	8000b32c <_fclose_r+0x80>
8000b324:	6e 4b       	ld.w	r11,r7[0x10]
8000b326:	0c 9c       	mov	r12,r6
8000b328:	fe b0 f9 6a 	rcall	8000a5fc <_free_r>
8000b32c:	6e db       	ld.w	r11,r7[0x34]
8000b32e:	58 0b       	cp.w	r11,0
8000b330:	c0 a0       	breq	8000b344 <_fclose_r+0x98>
8000b332:	ee c8 ff bc 	sub	r8,r7,-68
8000b336:	10 3b       	cp.w	r11,r8
8000b338:	c0 40       	breq	8000b340 <_fclose_r+0x94>
8000b33a:	0c 9c       	mov	r12,r6
8000b33c:	fe b0 f9 60 	rcall	8000a5fc <_free_r>
8000b340:	30 08       	mov	r8,0
8000b342:	8f d8       	st.w	r7[0x34],r8
8000b344:	6f 2b       	ld.w	r11,r7[0x48]
8000b346:	58 0b       	cp.w	r11,0
8000b348:	c0 70       	breq	8000b356 <_fclose_r+0xaa>
8000b34a:	0c 9c       	mov	r12,r6
8000b34c:	fe b0 f9 58 	rcall	8000a5fc <_free_r>
8000b350:	30 08       	mov	r8,0
8000b352:	ef 48 00 48 	st.w	r7[72],r8
8000b356:	30 08       	mov	r8,0
8000b358:	ae 68       	st.h	r7[0xc],r8
8000b35a:	fe b0 f8 66 	rcall	8000a426 <__sfp_lock_release>
8000b35e:	0a 9c       	mov	r12,r5
8000b360:	d8 22       	popm	r4-r7,pc
8000b362:	d7 03       	nop

8000b364 <fclose>:
8000b364:	d4 01       	pushm	lr
8000b366:	e0 68 0a 38 	mov	r8,2616
8000b36a:	18 9b       	mov	r11,r12
8000b36c:	70 0c       	ld.w	r12,r8[0x0]
8000b36e:	c9 ff       	rcall	8000b2ac <_fclose_r>
8000b370:	d8 02       	popm	pc
8000b372:	d7 03       	nop

8000b374 <_fstat_r>:
8000b374:	d4 21       	pushm	r4-r7,lr
8000b376:	16 98       	mov	r8,r11
8000b378:	18 97       	mov	r7,r12
8000b37a:	10 9c       	mov	r12,r8
8000b37c:	30 08       	mov	r8,0
8000b37e:	e0 66 41 18 	mov	r6,16664
8000b382:	14 9b       	mov	r11,r10
8000b384:	8d 08       	st.w	r6[0x0],r8
8000b386:	fe b0 df 73 	rcall	8000726c <_fstat>
8000b38a:	5b fc       	cp.w	r12,-1
8000b38c:	c0 51       	brne	8000b396 <_fstat_r+0x22>
8000b38e:	6c 08       	ld.w	r8,r6[0x0]
8000b390:	58 08       	cp.w	r8,0
8000b392:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b396:	d8 22       	popm	r4-r7,pc

8000b398 <_lseek_r>:
8000b398:	d4 21       	pushm	r4-r7,lr
8000b39a:	16 98       	mov	r8,r11
8000b39c:	18 97       	mov	r7,r12
8000b39e:	10 9c       	mov	r12,r8
8000b3a0:	30 08       	mov	r8,0
8000b3a2:	14 9b       	mov	r11,r10
8000b3a4:	e0 66 41 18 	mov	r6,16664
8000b3a8:	12 9a       	mov	r10,r9
8000b3aa:	8d 08       	st.w	r6[0x0],r8
8000b3ac:	fe b0 df 42 	rcall	80007230 <_lseek>
8000b3b0:	5b fc       	cp.w	r12,-1
8000b3b2:	c0 51       	brne	8000b3bc <_lseek_r+0x24>
8000b3b4:	6c 08       	ld.w	r8,r6[0x0]
8000b3b6:	58 08       	cp.w	r8,0
8000b3b8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b3bc:	d8 22       	popm	r4-r7,pc
8000b3be:	d7 03       	nop

8000b3c0 <_read_r>:
8000b3c0:	d4 21       	pushm	r4-r7,lr
8000b3c2:	16 98       	mov	r8,r11
8000b3c4:	18 97       	mov	r7,r12
8000b3c6:	10 9c       	mov	r12,r8
8000b3c8:	30 08       	mov	r8,0
8000b3ca:	14 9b       	mov	r11,r10
8000b3cc:	e0 66 41 18 	mov	r6,16664
8000b3d0:	12 9a       	mov	r10,r9
8000b3d2:	8d 08       	st.w	r6[0x0],r8
8000b3d4:	fe b0 d0 2a 	rcall	80005428 <_read>
8000b3d8:	5b fc       	cp.w	r12,-1
8000b3da:	c0 51       	brne	8000b3e4 <_read_r+0x24>
8000b3dc:	6c 08       	ld.w	r8,r6[0x0]
8000b3de:	58 08       	cp.w	r8,0
8000b3e0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b3e4:	d8 22       	popm	r4-r7,pc
8000b3e6:	d7 03       	nop

8000b3e8 <__avr32_f64_mul>:
8000b3e8:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b3ec:	e0 80 00 dc 	breq	8000b5a4 <__avr32_f64_mul_op1_zero>
8000b3f0:	d4 21       	pushm	r4-r7,lr
8000b3f2:	f7 e9 20 0e 	eor	lr,r11,r9
8000b3f6:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b3fa:	30 15       	mov	r5,1
8000b3fc:	c4 30       	breq	8000b482 <__avr32_f64_mul_op1_subnormal>
8000b3fe:	ab 6b       	lsl	r11,0xa
8000b400:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b404:	ab 6a       	lsl	r10,0xa
8000b406:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b40a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b40e:	c5 c0       	breq	8000b4c6 <__avr32_f64_mul_op2_subnormal>
8000b410:	a1 78       	lsl	r8,0x1
8000b412:	5c f9       	rol	r9
8000b414:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b418:	e0 47 07 ff 	cp.w	r7,2047
8000b41c:	c7 70       	breq	8000b50a <__avr32_f64_mul_op_nan_or_inf>
8000b41e:	e0 46 07 ff 	cp.w	r6,2047
8000b422:	c7 40       	breq	8000b50a <__avr32_f64_mul_op_nan_or_inf>
8000b424:	ee 06 00 0c 	add	r12,r7,r6
8000b428:	e0 2c 03 fe 	sub	r12,1022
8000b42c:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b430:	f4 09 07 44 	macu.d	r4,r10,r9
8000b434:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b438:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b43c:	08 07       	add	r7,r4
8000b43e:	f4 05 00 4a 	adc	r10,r10,r5
8000b442:	5c 0b       	acr	r11
8000b444:	ed bb 00 14 	bld	r11,0x14
8000b448:	c0 50       	breq	8000b452 <__avr32_f64_mul+0x6a>
8000b44a:	a1 77       	lsl	r7,0x1
8000b44c:	5c fa       	rol	r10
8000b44e:	5c fb       	rol	r11
8000b450:	20 1c       	sub	r12,1
8000b452:	58 0c       	cp.w	r12,0
8000b454:	e0 8a 00 6f 	brle	8000b532 <__avr32_f64_mul_res_subnormal>
8000b458:	e0 4c 07 ff 	cp.w	r12,2047
8000b45c:	e0 84 00 9c 	brge	8000b594 <__avr32_f64_mul_res_inf>
8000b460:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b464:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b468:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b46c:	ee 17 80 00 	eorh	r7,0x8000
8000b470:	f1 b7 04 20 	satu	r7,0x1
8000b474:	0e 0a       	add	r10,r7
8000b476:	5c 0b       	acr	r11
8000b478:	ed be 00 1f 	bld	lr,0x1f
8000b47c:	ef bb 00 1f 	bst	r11,0x1f
8000b480:	d8 22       	popm	r4-r7,pc

8000b482 <__avr32_f64_mul_op1_subnormal>:
8000b482:	e4 1b 00 0f 	andh	r11,0xf
8000b486:	f4 0c 12 00 	clz	r12,r10
8000b48a:	f6 06 12 00 	clz	r6,r11
8000b48e:	f7 bc 03 e1 	sublo	r12,-31
8000b492:	f8 06 17 30 	movlo	r6,r12
8000b496:	f7 b6 02 01 	subhs	r6,1
8000b49a:	e0 46 00 20 	cp.w	r6,32
8000b49e:	c0 d4       	brge	8000b4b8 <__avr32_f64_mul_op1_subnormal+0x36>
8000b4a0:	ec 0c 11 20 	rsub	r12,r6,32
8000b4a4:	f6 06 09 4b 	lsl	r11,r11,r6
8000b4a8:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b4ac:	18 4b       	or	r11,r12
8000b4ae:	f4 06 09 4a 	lsl	r10,r10,r6
8000b4b2:	20 b6       	sub	r6,11
8000b4b4:	0c 17       	sub	r7,r6
8000b4b6:	ca ab       	rjmp	8000b40a <__avr32_f64_mul+0x22>
8000b4b8:	f4 06 09 4b 	lsl	r11,r10,r6
8000b4bc:	c6 40       	breq	8000b584 <__avr32_f64_mul_res_zero>
8000b4be:	30 0a       	mov	r10,0
8000b4c0:	20 b6       	sub	r6,11
8000b4c2:	0c 17       	sub	r7,r6
8000b4c4:	ca 3b       	rjmp	8000b40a <__avr32_f64_mul+0x22>

8000b4c6 <__avr32_f64_mul_op2_subnormal>:
8000b4c6:	e4 19 00 0f 	andh	r9,0xf
8000b4ca:	f0 0c 12 00 	clz	r12,r8
8000b4ce:	f2 05 12 00 	clz	r5,r9
8000b4d2:	f7 bc 03 ea 	sublo	r12,-22
8000b4d6:	f8 05 17 30 	movlo	r5,r12
8000b4da:	f7 b5 02 0a 	subhs	r5,10
8000b4de:	e0 45 00 20 	cp.w	r5,32
8000b4e2:	c0 d4       	brge	8000b4fc <__avr32_f64_mul_op2_subnormal+0x36>
8000b4e4:	ea 0c 11 20 	rsub	r12,r5,32
8000b4e8:	f2 05 09 49 	lsl	r9,r9,r5
8000b4ec:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b4f0:	18 49       	or	r9,r12
8000b4f2:	f0 05 09 48 	lsl	r8,r8,r5
8000b4f6:	20 25       	sub	r5,2
8000b4f8:	0a 16       	sub	r6,r5
8000b4fa:	c8 fb       	rjmp	8000b418 <__avr32_f64_mul+0x30>
8000b4fc:	f0 05 09 49 	lsl	r9,r8,r5
8000b500:	c4 20       	breq	8000b584 <__avr32_f64_mul_res_zero>
8000b502:	30 08       	mov	r8,0
8000b504:	20 25       	sub	r5,2
8000b506:	0a 16       	sub	r6,r5
8000b508:	c8 8b       	rjmp	8000b418 <__avr32_f64_mul+0x30>

8000b50a <__avr32_f64_mul_op_nan_or_inf>:
8000b50a:	e4 19 00 0f 	andh	r9,0xf
8000b50e:	e4 1b 00 0f 	andh	r11,0xf
8000b512:	14 4b       	or	r11,r10
8000b514:	10 49       	or	r9,r8
8000b516:	e0 47 07 ff 	cp.w	r7,2047
8000b51a:	c0 91       	brne	8000b52c <__avr32_f64_mul_op1_not_naninf>
8000b51c:	58 0b       	cp.w	r11,0
8000b51e:	c3 81       	brne	8000b58e <__avr32_f64_mul_res_nan>
8000b520:	e0 46 07 ff 	cp.w	r6,2047
8000b524:	c3 81       	brne	8000b594 <__avr32_f64_mul_res_inf>
8000b526:	58 09       	cp.w	r9,0
8000b528:	c3 60       	breq	8000b594 <__avr32_f64_mul_res_inf>
8000b52a:	c3 28       	rjmp	8000b58e <__avr32_f64_mul_res_nan>

8000b52c <__avr32_f64_mul_op1_not_naninf>:
8000b52c:	58 09       	cp.w	r9,0
8000b52e:	c3 30       	breq	8000b594 <__avr32_f64_mul_res_inf>
8000b530:	c2 f8       	rjmp	8000b58e <__avr32_f64_mul_res_nan>

8000b532 <__avr32_f64_mul_res_subnormal>:
8000b532:	5c 3c       	neg	r12
8000b534:	2f fc       	sub	r12,-1
8000b536:	f1 bc 04 c0 	satu	r12,0x6
8000b53a:	e0 4c 00 20 	cp.w	r12,32
8000b53e:	c1 14       	brge	8000b560 <__avr32_f64_mul_res_subnormal+0x2e>
8000b540:	f8 08 11 20 	rsub	r8,r12,32
8000b544:	0e 46       	or	r6,r7
8000b546:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b54a:	f4 08 09 49 	lsl	r9,r10,r8
8000b54e:	12 47       	or	r7,r9
8000b550:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b554:	f6 08 09 49 	lsl	r9,r11,r8
8000b558:	12 4a       	or	r10,r9
8000b55a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b55e:	c8 3b       	rjmp	8000b464 <__avr32_f64_mul+0x7c>
8000b560:	f8 08 11 20 	rsub	r8,r12,32
8000b564:	f9 b9 00 00 	moveq	r9,0
8000b568:	c0 30       	breq	8000b56e <__avr32_f64_mul_res_subnormal+0x3c>
8000b56a:	f6 08 09 49 	lsl	r9,r11,r8
8000b56e:	0e 46       	or	r6,r7
8000b570:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b574:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b578:	f3 ea 10 07 	or	r7,r9,r10
8000b57c:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b580:	30 0b       	mov	r11,0
8000b582:	c7 1b       	rjmp	8000b464 <__avr32_f64_mul+0x7c>

8000b584 <__avr32_f64_mul_res_zero>:
8000b584:	1c 9b       	mov	r11,lr
8000b586:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b58a:	30 0a       	mov	r10,0
8000b58c:	d8 22       	popm	r4-r7,pc

8000b58e <__avr32_f64_mul_res_nan>:
8000b58e:	3f fb       	mov	r11,-1
8000b590:	3f fa       	mov	r10,-1
8000b592:	d8 22       	popm	r4-r7,pc

8000b594 <__avr32_f64_mul_res_inf>:
8000b594:	f0 6b 00 00 	mov	r11,-1048576
8000b598:	ed be 00 1f 	bld	lr,0x1f
8000b59c:	ef bb 00 1f 	bst	r11,0x1f
8000b5a0:	30 0a       	mov	r10,0
8000b5a2:	d8 22       	popm	r4-r7,pc

8000b5a4 <__avr32_f64_mul_op1_zero>:
8000b5a4:	f7 e9 20 0b 	eor	r11,r11,r9
8000b5a8:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b5ac:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b5b0:	e0 4c 07 ff 	cp.w	r12,2047
8000b5b4:	5e 1c       	retne	r12
8000b5b6:	3f fa       	mov	r10,-1
8000b5b8:	3f fb       	mov	r11,-1
8000b5ba:	5e fc       	retal	r12

8000b5bc <__avr32_f64_sub_from_add>:
8000b5bc:	ee 19 80 00 	eorh	r9,0x8000

8000b5c0 <__avr32_f64_sub>:
8000b5c0:	f7 e9 20 0c 	eor	r12,r11,r9
8000b5c4:	e0 86 00 ca 	brmi	8000b758 <__avr32_f64_add_from_sub>
8000b5c8:	eb cd 40 e0 	pushm	r5-r7,lr
8000b5cc:	16 9c       	mov	r12,r11
8000b5ce:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b5d2:	bf db       	cbr	r11,0x1f
8000b5d4:	bf d9       	cbr	r9,0x1f
8000b5d6:	10 3a       	cp.w	r10,r8
8000b5d8:	f2 0b 13 00 	cpc	r11,r9
8000b5dc:	c0 92       	brcc	8000b5ee <__avr32_f64_sub+0x2e>
8000b5de:	16 97       	mov	r7,r11
8000b5e0:	12 9b       	mov	r11,r9
8000b5e2:	0e 99       	mov	r9,r7
8000b5e4:	14 97       	mov	r7,r10
8000b5e6:	10 9a       	mov	r10,r8
8000b5e8:	0e 98       	mov	r8,r7
8000b5ea:	ee 1c 80 00 	eorh	r12,0x8000
8000b5ee:	f6 07 16 14 	lsr	r7,r11,0x14
8000b5f2:	ab 7b       	lsl	r11,0xb
8000b5f4:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b5f8:	ab 7a       	lsl	r10,0xb
8000b5fa:	bf bb       	sbr	r11,0x1f
8000b5fc:	f2 06 16 14 	lsr	r6,r9,0x14
8000b600:	c4 40       	breq	8000b688 <__avr32_f64_sub_opL_subnormal>
8000b602:	ab 79       	lsl	r9,0xb
8000b604:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b608:	ab 78       	lsl	r8,0xb
8000b60a:	bf b9       	sbr	r9,0x1f

8000b60c <__avr32_f64_sub_opL_subnormal_done>:
8000b60c:	e0 47 07 ff 	cp.w	r7,2047
8000b610:	c4 f0       	breq	8000b6ae <__avr32_f64_sub_opH_nan_or_inf>
8000b612:	0e 26       	rsub	r6,r7
8000b614:	c1 20       	breq	8000b638 <__avr32_f64_sub_shift_done>
8000b616:	ec 05 11 20 	rsub	r5,r6,32
8000b61a:	e0 46 00 20 	cp.w	r6,32
8000b61e:	c7 c2       	brcc	8000b716 <__avr32_f64_sub_longshift>
8000b620:	f0 05 09 4e 	lsl	lr,r8,r5
8000b624:	f2 05 09 45 	lsl	r5,r9,r5
8000b628:	f0 06 0a 48 	lsr	r8,r8,r6
8000b62c:	f2 06 0a 49 	lsr	r9,r9,r6
8000b630:	0a 48       	or	r8,r5
8000b632:	58 0e       	cp.w	lr,0
8000b634:	5f 1e       	srne	lr
8000b636:	1c 48       	or	r8,lr

8000b638 <__avr32_f64_sub_shift_done>:
8000b638:	10 1a       	sub	r10,r8
8000b63a:	f6 09 01 4b 	sbc	r11,r11,r9
8000b63e:	f6 06 12 00 	clz	r6,r11
8000b642:	c0 e0       	breq	8000b65e <__avr32_f64_sub_longnormalize_done>
8000b644:	c7 83       	brcs	8000b734 <__avr32_f64_sub_longnormalize>
8000b646:	ec 0e 11 20 	rsub	lr,r6,32
8000b64a:	f6 06 09 4b 	lsl	r11,r11,r6
8000b64e:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b652:	1c 4b       	or	r11,lr
8000b654:	f4 06 09 4a 	lsl	r10,r10,r6
8000b658:	0c 17       	sub	r7,r6
8000b65a:	e0 8a 00 39 	brle	8000b6cc <__avr32_f64_sub_subnormal_result>

8000b65e <__avr32_f64_sub_longnormalize_done>:
8000b65e:	f4 09 15 15 	lsl	r9,r10,0x15
8000b662:	ab 9a       	lsr	r10,0xb
8000b664:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b668:	ab 9b       	lsr	r11,0xb
8000b66a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b66e:	18 4b       	or	r11,r12

8000b670 <__avr32_f64_sub_round>:
8000b670:	fc 17 80 00 	movh	r7,0x8000
8000b674:	ed ba 00 00 	bld	r10,0x0
8000b678:	f7 b7 01 ff 	subne	r7,-1
8000b67c:	0e 39       	cp.w	r9,r7
8000b67e:	5f 29       	srhs	r9
8000b680:	12 0a       	add	r10,r9
8000b682:	5c 0b       	acr	r11
8000b684:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b688 <__avr32_f64_sub_opL_subnormal>:
8000b688:	ab 79       	lsl	r9,0xb
8000b68a:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b68e:	ab 78       	lsl	r8,0xb
8000b690:	f3 e8 10 0e 	or	lr,r9,r8
8000b694:	f9 b6 01 01 	movne	r6,1
8000b698:	ee 0e 11 00 	rsub	lr,r7,0
8000b69c:	f9 b7 00 01 	moveq	r7,1
8000b6a0:	ef bb 00 1f 	bst	r11,0x1f
8000b6a4:	f7 ea 10 0e 	or	lr,r11,r10
8000b6a8:	f9 b7 00 00 	moveq	r7,0
8000b6ac:	cb 0b       	rjmp	8000b60c <__avr32_f64_sub_opL_subnormal_done>

8000b6ae <__avr32_f64_sub_opH_nan_or_inf>:
8000b6ae:	bf db       	cbr	r11,0x1f
8000b6b0:	f7 ea 10 0e 	or	lr,r11,r10
8000b6b4:	c0 81       	brne	8000b6c4 <__avr32_f64_sub_return_nan>
8000b6b6:	e0 46 07 ff 	cp.w	r6,2047
8000b6ba:	c0 50       	breq	8000b6c4 <__avr32_f64_sub_return_nan>
8000b6bc:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b6c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b6c4 <__avr32_f64_sub_return_nan>:
8000b6c4:	3f fa       	mov	r10,-1
8000b6c6:	3f fb       	mov	r11,-1
8000b6c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b6cc <__avr32_f64_sub_subnormal_result>:
8000b6cc:	5c 37       	neg	r7
8000b6ce:	2f f7       	sub	r7,-1
8000b6d0:	f1 b7 04 c0 	satu	r7,0x6
8000b6d4:	e0 47 00 20 	cp.w	r7,32
8000b6d8:	c1 14       	brge	8000b6fa <__avr32_f64_sub_subnormal_result+0x2e>
8000b6da:	ee 08 11 20 	rsub	r8,r7,32
8000b6de:	f4 08 09 49 	lsl	r9,r10,r8
8000b6e2:	5f 16       	srne	r6
8000b6e4:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b6e8:	0c 4a       	or	r10,r6
8000b6ea:	f6 08 09 49 	lsl	r9,r11,r8
8000b6ee:	f5 e9 10 0a 	or	r10,r10,r9
8000b6f2:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b6f6:	30 07       	mov	r7,0
8000b6f8:	cb 3b       	rjmp	8000b65e <__avr32_f64_sub_longnormalize_done>
8000b6fa:	ee 08 11 40 	rsub	r8,r7,64
8000b6fe:	f6 08 09 49 	lsl	r9,r11,r8
8000b702:	14 49       	or	r9,r10
8000b704:	5f 16       	srne	r6
8000b706:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b70a:	0c 4a       	or	r10,r6
8000b70c:	30 0b       	mov	r11,0
8000b70e:	30 07       	mov	r7,0
8000b710:	ca 7b       	rjmp	8000b65e <__avr32_f64_sub_longnormalize_done>
8000b712:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b716 <__avr32_f64_sub_longshift>:
8000b716:	f1 b6 04 c0 	satu	r6,0x6
8000b71a:	f0 0e 17 00 	moveq	lr,r8
8000b71e:	c0 40       	breq	8000b726 <__avr32_f64_sub_longshift+0x10>
8000b720:	f2 05 09 4e 	lsl	lr,r9,r5
8000b724:	10 4e       	or	lr,r8
8000b726:	f2 06 0a 48 	lsr	r8,r9,r6
8000b72a:	30 09       	mov	r9,0
8000b72c:	58 0e       	cp.w	lr,0
8000b72e:	5f 1e       	srne	lr
8000b730:	1c 48       	or	r8,lr
8000b732:	c8 3b       	rjmp	8000b638 <__avr32_f64_sub_shift_done>

8000b734 <__avr32_f64_sub_longnormalize>:
8000b734:	f4 06 12 00 	clz	r6,r10
8000b738:	f9 b7 03 00 	movlo	r7,0
8000b73c:	f9 b6 03 00 	movlo	r6,0
8000b740:	f9 bc 03 00 	movlo	r12,0
8000b744:	f7 b6 02 e0 	subhs	r6,-32
8000b748:	f4 06 09 4b 	lsl	r11,r10,r6
8000b74c:	30 0a       	mov	r10,0
8000b74e:	0c 17       	sub	r7,r6
8000b750:	fe 9a ff be 	brle	8000b6cc <__avr32_f64_sub_subnormal_result>
8000b754:	c8 5b       	rjmp	8000b65e <__avr32_f64_sub_longnormalize_done>
8000b756:	d7 03       	nop

8000b758 <__avr32_f64_add_from_sub>:
8000b758:	ee 19 80 00 	eorh	r9,0x8000

8000b75c <__avr32_f64_add>:
8000b75c:	f7 e9 20 0c 	eor	r12,r11,r9
8000b760:	fe 96 ff 2e 	brmi	8000b5bc <__avr32_f64_sub_from_add>
8000b764:	eb cd 40 e0 	pushm	r5-r7,lr
8000b768:	16 9c       	mov	r12,r11
8000b76a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b76e:	bf db       	cbr	r11,0x1f
8000b770:	bf d9       	cbr	r9,0x1f
8000b772:	12 3b       	cp.w	r11,r9
8000b774:	c0 72       	brcc	8000b782 <__avr32_f64_add+0x26>
8000b776:	16 97       	mov	r7,r11
8000b778:	12 9b       	mov	r11,r9
8000b77a:	0e 99       	mov	r9,r7
8000b77c:	14 97       	mov	r7,r10
8000b77e:	10 9a       	mov	r10,r8
8000b780:	0e 98       	mov	r8,r7
8000b782:	30 0e       	mov	lr,0
8000b784:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b788:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000b78c:	b5 ab       	sbr	r11,0x14
8000b78e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b792:	c6 20       	breq	8000b856 <__avr32_f64_add_op2_subnormal>
8000b794:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b798:	b5 a9       	sbr	r9,0x14
8000b79a:	e0 47 07 ff 	cp.w	r7,2047
8000b79e:	c2 80       	breq	8000b7ee <__avr32_f64_add_opH_nan_or_inf>
8000b7a0:	0e 26       	rsub	r6,r7
8000b7a2:	c1 20       	breq	8000b7c6 <__avr32_f64_add_shift_done>
8000b7a4:	e0 46 00 36 	cp.w	r6,54
8000b7a8:	c1 52       	brcc	8000b7d2 <__avr32_f64_add_res_of_done>
8000b7aa:	ec 05 11 20 	rsub	r5,r6,32
8000b7ae:	e0 46 00 20 	cp.w	r6,32
8000b7b2:	c3 52       	brcc	8000b81c <__avr32_f64_add_longshift>
8000b7b4:	f0 05 09 4e 	lsl	lr,r8,r5
8000b7b8:	f2 05 09 45 	lsl	r5,r9,r5
8000b7bc:	f0 06 0a 48 	lsr	r8,r8,r6
8000b7c0:	f2 06 0a 49 	lsr	r9,r9,r6
8000b7c4:	0a 48       	or	r8,r5

8000b7c6 <__avr32_f64_add_shift_done>:
8000b7c6:	10 0a       	add	r10,r8
8000b7c8:	f6 09 00 4b 	adc	r11,r11,r9
8000b7cc:	ed bb 00 15 	bld	r11,0x15
8000b7d0:	c3 40       	breq	8000b838 <__avr32_f64_add_res_of>

8000b7d2 <__avr32_f64_add_res_of_done>:
8000b7d2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b7d6:	18 4b       	or	r11,r12

8000b7d8 <__avr32_f64_add_round>:
8000b7d8:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000b7dc:	18 4e       	or	lr,r12
8000b7de:	ee 1e 80 00 	eorh	lr,0x8000
8000b7e2:	f1 be 04 20 	satu	lr,0x1
8000b7e6:	1c 0a       	add	r10,lr
8000b7e8:	5c 0b       	acr	r11
8000b7ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b7ee <__avr32_f64_add_opH_nan_or_inf>:
8000b7ee:	b5 cb       	cbr	r11,0x14
8000b7f0:	f7 ea 10 0e 	or	lr,r11,r10
8000b7f4:	c1 01       	brne	8000b814 <__avr32_f64_add_return_nan>
8000b7f6:	e0 46 07 ff 	cp.w	r6,2047
8000b7fa:	c0 30       	breq	8000b800 <__avr32_f64_add_opL_nan_or_inf>
8000b7fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b800 <__avr32_f64_add_opL_nan_or_inf>:
8000b800:	b5 c9       	cbr	r9,0x14
8000b802:	f3 e8 10 0e 	or	lr,r9,r8
8000b806:	c0 71       	brne	8000b814 <__avr32_f64_add_return_nan>
8000b808:	30 0a       	mov	r10,0
8000b80a:	fc 1b 7f f0 	movh	r11,0x7ff0
8000b80e:	18 4b       	or	r11,r12
8000b810:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b814 <__avr32_f64_add_return_nan>:
8000b814:	3f fa       	mov	r10,-1
8000b816:	3f fb       	mov	r11,-1
8000b818:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b81c <__avr32_f64_add_longshift>:
8000b81c:	f1 b6 04 c0 	satu	r6,0x6
8000b820:	f0 0e 17 00 	moveq	lr,r8
8000b824:	c0 60       	breq	8000b830 <__avr32_f64_add_longshift+0x14>
8000b826:	f2 05 09 4e 	lsl	lr,r9,r5
8000b82a:	58 08       	cp.w	r8,0
8000b82c:	5f 18       	srne	r8
8000b82e:	10 4e       	or	lr,r8
8000b830:	f2 06 0a 48 	lsr	r8,r9,r6
8000b834:	30 09       	mov	r9,0
8000b836:	cc 8b       	rjmp	8000b7c6 <__avr32_f64_add_shift_done>

8000b838 <__avr32_f64_add_res_of>:
8000b838:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000b83c:	a1 9b       	lsr	r11,0x1
8000b83e:	5d 0a       	ror	r10
8000b840:	5d 0e       	ror	lr
8000b842:	2f f7       	sub	r7,-1
8000b844:	e0 47 07 ff 	cp.w	r7,2047
8000b848:	f9 ba 00 00 	moveq	r10,0
8000b84c:	f9 bb 00 00 	moveq	r11,0
8000b850:	f9 be 00 00 	moveq	lr,0
8000b854:	cb fb       	rjmp	8000b7d2 <__avr32_f64_add_res_of_done>

8000b856 <__avr32_f64_add_op2_subnormal>:
8000b856:	30 16       	mov	r6,1
8000b858:	58 07       	cp.w	r7,0
8000b85a:	ca 01       	brne	8000b79a <__avr32_f64_add+0x3e>
8000b85c:	b5 cb       	cbr	r11,0x14
8000b85e:	10 0a       	add	r10,r8
8000b860:	f6 09 00 4b 	adc	r11,r11,r9
8000b864:	18 4b       	or	r11,r12
8000b866:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b86a:	d7 03       	nop

8000b86c <__avr32_f64_to_u32>:
8000b86c:	58 0b       	cp.w	r11,0
8000b86e:	5e 6d       	retmi	0

8000b870 <__avr32_f64_to_s32>:
8000b870:	f6 0c 15 01 	lsl	r12,r11,0x1
8000b874:	b5 9c       	lsr	r12,0x15
8000b876:	e0 2c 03 ff 	sub	r12,1023
8000b87a:	5e 3d       	retlo	0
8000b87c:	f8 0c 11 1f 	rsub	r12,r12,31
8000b880:	16 99       	mov	r9,r11
8000b882:	ab 7b       	lsl	r11,0xb
8000b884:	bf bb       	sbr	r11,0x1f
8000b886:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b88a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b88e:	a1 79       	lsl	r9,0x1
8000b890:	5e 2b       	reths	r11
8000b892:	5c 3b       	neg	r11
8000b894:	5e fb       	retal	r11

8000b896 <__avr32_u32_to_f64>:
8000b896:	f8 cb 00 00 	sub	r11,r12,0
8000b89a:	30 0c       	mov	r12,0
8000b89c:	c0 38       	rjmp	8000b8a2 <__avr32_s32_to_f64+0x4>

8000b89e <__avr32_s32_to_f64>:
8000b89e:	18 9b       	mov	r11,r12
8000b8a0:	5c 4b       	abs	r11
8000b8a2:	30 0a       	mov	r10,0
8000b8a4:	5e 0b       	reteq	r11
8000b8a6:	d4 01       	pushm	lr
8000b8a8:	e0 69 04 1e 	mov	r9,1054
8000b8ac:	f6 08 12 00 	clz	r8,r11
8000b8b0:	c1 70       	breq	8000b8de <__avr32_s32_to_f64+0x40>
8000b8b2:	c0 c3       	brcs	8000b8ca <__avr32_s32_to_f64+0x2c>
8000b8b4:	f0 0e 11 20 	rsub	lr,r8,32
8000b8b8:	f6 08 09 4b 	lsl	r11,r11,r8
8000b8bc:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b8c0:	1c 4b       	or	r11,lr
8000b8c2:	f4 08 09 4a 	lsl	r10,r10,r8
8000b8c6:	10 19       	sub	r9,r8
8000b8c8:	c0 b8       	rjmp	8000b8de <__avr32_s32_to_f64+0x40>
8000b8ca:	f4 08 12 00 	clz	r8,r10
8000b8ce:	f9 b8 03 00 	movlo	r8,0
8000b8d2:	f7 b8 02 e0 	subhs	r8,-32
8000b8d6:	f4 08 09 4b 	lsl	r11,r10,r8
8000b8da:	30 0a       	mov	r10,0
8000b8dc:	10 19       	sub	r9,r8
8000b8de:	58 09       	cp.w	r9,0
8000b8e0:	e0 89 00 30 	brgt	8000b940 <__avr32_s32_to_f64+0xa2>
8000b8e4:	5c 39       	neg	r9
8000b8e6:	2f f9       	sub	r9,-1
8000b8e8:	e0 49 00 36 	cp.w	r9,54
8000b8ec:	c0 43       	brcs	8000b8f4 <__avr32_s32_to_f64+0x56>
8000b8ee:	30 0b       	mov	r11,0
8000b8f0:	30 0a       	mov	r10,0
8000b8f2:	c2 68       	rjmp	8000b93e <__avr32_s32_to_f64+0xa0>
8000b8f4:	2f 69       	sub	r9,-10
8000b8f6:	f2 08 11 20 	rsub	r8,r9,32
8000b8fa:	e0 49 00 20 	cp.w	r9,32
8000b8fe:	c0 b2       	brcc	8000b914 <__avr32_s32_to_f64+0x76>
8000b900:	f4 08 09 4e 	lsl	lr,r10,r8
8000b904:	f6 08 09 48 	lsl	r8,r11,r8
8000b908:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b90c:	f6 09 0a 4b 	lsr	r11,r11,r9
8000b910:	10 4b       	or	r11,r8
8000b912:	c0 88       	rjmp	8000b922 <__avr32_s32_to_f64+0x84>
8000b914:	f6 08 09 4e 	lsl	lr,r11,r8
8000b918:	14 4e       	or	lr,r10
8000b91a:	16 9a       	mov	r10,r11
8000b91c:	30 0b       	mov	r11,0
8000b91e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b922:	ed ba 00 00 	bld	r10,0x0
8000b926:	c0 92       	brcc	8000b938 <__avr32_s32_to_f64+0x9a>
8000b928:	1c 7e       	tst	lr,lr
8000b92a:	c0 41       	brne	8000b932 <__avr32_s32_to_f64+0x94>
8000b92c:	ed ba 00 01 	bld	r10,0x1
8000b930:	c0 42       	brcc	8000b938 <__avr32_s32_to_f64+0x9a>
8000b932:	2f fa       	sub	r10,-1
8000b934:	f7 bb 02 ff 	subhs	r11,-1
8000b938:	5c fc       	rol	r12
8000b93a:	5d 0b       	ror	r11
8000b93c:	5d 0a       	ror	r10
8000b93e:	d8 02       	popm	pc
8000b940:	e0 68 03 ff 	mov	r8,1023
8000b944:	ed ba 00 0b 	bld	r10,0xb
8000b948:	f7 b8 00 ff 	subeq	r8,-1
8000b94c:	10 0a       	add	r10,r8
8000b94e:	5c 0b       	acr	r11
8000b950:	f7 b9 03 fe 	sublo	r9,-2
8000b954:	e0 49 07 ff 	cp.w	r9,2047
8000b958:	c0 55       	brlt	8000b962 <__avr32_s32_to_f64+0xc4>
8000b95a:	30 0a       	mov	r10,0
8000b95c:	fc 1b ff e0 	movh	r11,0xffe0
8000b960:	c0 c8       	rjmp	8000b978 <__floatsidf_return_op1>
8000b962:	ed bb 00 1f 	bld	r11,0x1f
8000b966:	f7 b9 01 01 	subne	r9,1
8000b96a:	ab 9a       	lsr	r10,0xb
8000b96c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b970:	a1 7b       	lsl	r11,0x1
8000b972:	ab 9b       	lsr	r11,0xb
8000b974:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000b978 <__floatsidf_return_op1>:
8000b978:	a1 7c       	lsl	r12,0x1
8000b97a:	5d 0b       	ror	r11
8000b97c:	d8 02       	popm	pc

8000b97e <__avr32_f64_cmp_eq>:
8000b97e:	10 3a       	cp.w	r10,r8
8000b980:	f2 0b 13 00 	cpc	r11,r9
8000b984:	c0 80       	breq	8000b994 <__avr32_f64_cmp_eq+0x16>
8000b986:	a1 7b       	lsl	r11,0x1
8000b988:	a1 79       	lsl	r9,0x1
8000b98a:	14 4b       	or	r11,r10
8000b98c:	12 4b       	or	r11,r9
8000b98e:	10 4b       	or	r11,r8
8000b990:	5e 0f       	reteq	1
8000b992:	5e fd       	retal	0
8000b994:	a1 7b       	lsl	r11,0x1
8000b996:	fc 1c ff e0 	movh	r12,0xffe0
8000b99a:	58 0a       	cp.w	r10,0
8000b99c:	f8 0b 13 00 	cpc	r11,r12
8000b9a0:	5e 8f       	retls	1
8000b9a2:	5e fd       	retal	0

8000b9a4 <__avr32_f64_cmp_ge>:
8000b9a4:	1a de       	st.w	--sp,lr
8000b9a6:	1a d7       	st.w	--sp,r7
8000b9a8:	a1 7b       	lsl	r11,0x1
8000b9aa:	5f 3c       	srlo	r12
8000b9ac:	a1 79       	lsl	r9,0x1
8000b9ae:	5f 37       	srlo	r7
8000b9b0:	5c fc       	rol	r12
8000b9b2:	fc 1e ff e0 	movh	lr,0xffe0
8000b9b6:	58 0a       	cp.w	r10,0
8000b9b8:	fc 0b 13 00 	cpc	r11,lr
8000b9bc:	e0 8b 00 1d 	brhi	8000b9f6 <__avr32_f64_cmp_ge+0x52>
8000b9c0:	58 08       	cp.w	r8,0
8000b9c2:	fc 09 13 00 	cpc	r9,lr
8000b9c6:	e0 8b 00 18 	brhi	8000b9f6 <__avr32_f64_cmp_ge+0x52>
8000b9ca:	58 0b       	cp.w	r11,0
8000b9cc:	f5 ba 00 00 	subfeq	r10,0
8000b9d0:	c1 50       	breq	8000b9fa <__avr32_f64_cmp_ge+0x56>
8000b9d2:	1b 07       	ld.w	r7,sp++
8000b9d4:	1b 0e       	ld.w	lr,sp++
8000b9d6:	58 3c       	cp.w	r12,3
8000b9d8:	c0 a0       	breq	8000b9ec <__avr32_f64_cmp_ge+0x48>
8000b9da:	58 1c       	cp.w	r12,1
8000b9dc:	c0 33       	brcs	8000b9e2 <__avr32_f64_cmp_ge+0x3e>
8000b9de:	5e 0f       	reteq	1
8000b9e0:	5e 1d       	retne	0
8000b9e2:	10 3a       	cp.w	r10,r8
8000b9e4:	f2 0b 13 00 	cpc	r11,r9
8000b9e8:	5e 2f       	reths	1
8000b9ea:	5e 3d       	retlo	0
8000b9ec:	14 38       	cp.w	r8,r10
8000b9ee:	f6 09 13 00 	cpc	r9,r11
8000b9f2:	5e 2f       	reths	1
8000b9f4:	5e 3d       	retlo	0
8000b9f6:	1b 07       	ld.w	r7,sp++
8000b9f8:	d8 0a       	popm	pc,r12=0
8000b9fa:	58 17       	cp.w	r7,1
8000b9fc:	5f 0c       	sreq	r12
8000b9fe:	58 09       	cp.w	r9,0
8000ba00:	f5 b8 00 00 	subfeq	r8,0
8000ba04:	1b 07       	ld.w	r7,sp++
8000ba06:	1b 0e       	ld.w	lr,sp++
8000ba08:	5e 0f       	reteq	1
8000ba0a:	5e fc       	retal	r12

8000ba0c <__avr32_f64_cmp_lt>:
8000ba0c:	1a de       	st.w	--sp,lr
8000ba0e:	1a d7       	st.w	--sp,r7
8000ba10:	a1 7b       	lsl	r11,0x1
8000ba12:	5f 3c       	srlo	r12
8000ba14:	a1 79       	lsl	r9,0x1
8000ba16:	5f 37       	srlo	r7
8000ba18:	5c fc       	rol	r12
8000ba1a:	fc 1e ff e0 	movh	lr,0xffe0
8000ba1e:	58 0a       	cp.w	r10,0
8000ba20:	fc 0b 13 00 	cpc	r11,lr
8000ba24:	e0 8b 00 1d 	brhi	8000ba5e <__avr32_f64_cmp_lt+0x52>
8000ba28:	58 08       	cp.w	r8,0
8000ba2a:	fc 09 13 00 	cpc	r9,lr
8000ba2e:	e0 8b 00 18 	brhi	8000ba5e <__avr32_f64_cmp_lt+0x52>
8000ba32:	58 0b       	cp.w	r11,0
8000ba34:	f5 ba 00 00 	subfeq	r10,0
8000ba38:	c1 50       	breq	8000ba62 <__avr32_f64_cmp_lt+0x56>
8000ba3a:	1b 07       	ld.w	r7,sp++
8000ba3c:	1b 0e       	ld.w	lr,sp++
8000ba3e:	58 3c       	cp.w	r12,3
8000ba40:	c0 a0       	breq	8000ba54 <__avr32_f64_cmp_lt+0x48>
8000ba42:	58 1c       	cp.w	r12,1
8000ba44:	c0 33       	brcs	8000ba4a <__avr32_f64_cmp_lt+0x3e>
8000ba46:	5e 0d       	reteq	0
8000ba48:	5e 1f       	retne	1
8000ba4a:	10 3a       	cp.w	r10,r8
8000ba4c:	f2 0b 13 00 	cpc	r11,r9
8000ba50:	5e 2d       	reths	0
8000ba52:	5e 3f       	retlo	1
8000ba54:	14 38       	cp.w	r8,r10
8000ba56:	f6 09 13 00 	cpc	r9,r11
8000ba5a:	5e 2d       	reths	0
8000ba5c:	5e 3f       	retlo	1
8000ba5e:	1b 07       	ld.w	r7,sp++
8000ba60:	d8 0a       	popm	pc,r12=0
8000ba62:	58 17       	cp.w	r7,1
8000ba64:	5f 1c       	srne	r12
8000ba66:	58 09       	cp.w	r9,0
8000ba68:	f5 b8 00 00 	subfeq	r8,0
8000ba6c:	1b 07       	ld.w	r7,sp++
8000ba6e:	1b 0e       	ld.w	lr,sp++
8000ba70:	5e 0d       	reteq	0
8000ba72:	5e fc       	retal	r12

8000ba74 <__avr32_f64_div>:
8000ba74:	eb cd 40 ff 	pushm	r0-r7,lr
8000ba78:	f7 e9 20 0e 	eor	lr,r11,r9
8000ba7c:	f6 07 16 14 	lsr	r7,r11,0x14
8000ba80:	a9 7b       	lsl	r11,0x9
8000ba82:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000ba86:	a9 7a       	lsl	r10,0x9
8000ba88:	bd bb       	sbr	r11,0x1d
8000ba8a:	e4 1b 3f ff 	andh	r11,0x3fff
8000ba8e:	ab d7       	cbr	r7,0xb
8000ba90:	e0 80 00 cc 	breq	8000bc28 <__avr32_f64_div_round_subnormal+0x54>
8000ba94:	e0 47 07 ff 	cp.w	r7,2047
8000ba98:	e0 84 00 b5 	brge	8000bc02 <__avr32_f64_div_round_subnormal+0x2e>
8000ba9c:	f2 06 16 14 	lsr	r6,r9,0x14
8000baa0:	a9 79       	lsl	r9,0x9
8000baa2:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000baa6:	a9 78       	lsl	r8,0x9
8000baa8:	bd b9       	sbr	r9,0x1d
8000baaa:	e4 19 3f ff 	andh	r9,0x3fff
8000baae:	ab d6       	cbr	r6,0xb
8000bab0:	e0 80 00 e2 	breq	8000bc74 <__avr32_f64_div_round_subnormal+0xa0>
8000bab4:	e0 46 07 ff 	cp.w	r6,2047
8000bab8:	e0 84 00 b2 	brge	8000bc1c <__avr32_f64_div_round_subnormal+0x48>
8000babc:	0c 17       	sub	r7,r6
8000babe:	fe 37 fc 01 	sub	r7,-1023
8000bac2:	fc 1c 80 00 	movh	r12,0x8000
8000bac6:	f8 03 16 01 	lsr	r3,r12,0x1
8000baca:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000bace:	5c d4       	com	r4
8000bad0:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000bad4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bad8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000badc:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bae0:	ea 03 15 02 	lsl	r3,r5,0x2
8000bae4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bae8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000baec:	e6 05 06 44 	mulu.d	r4,r3,r5
8000baf0:	ea 03 15 02 	lsl	r3,r5,0x2
8000baf4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000baf8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bafc:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bb00:	ea 03 15 02 	lsl	r3,r5,0x2
8000bb04:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bb08:	e4 09 07 40 	macu.d	r0,r2,r9
8000bb0c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bb10:	02 04       	add	r4,r1
8000bb12:	5c 05       	acr	r5
8000bb14:	a3 65       	lsl	r5,0x2
8000bb16:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bb1a:	a3 64       	lsl	r4,0x2
8000bb1c:	5c 34       	neg	r4
8000bb1e:	f8 05 01 45 	sbc	r5,r12,r5
8000bb22:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bb26:	e4 05 07 40 	macu.d	r0,r2,r5
8000bb2a:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bb2e:	02 04       	add	r4,r1
8000bb30:	5c 05       	acr	r5
8000bb32:	ea 03 15 02 	lsl	r3,r5,0x2
8000bb36:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bb3a:	e8 02 15 02 	lsl	r2,r4,0x2
8000bb3e:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bb42:	e4 09 07 40 	macu.d	r0,r2,r9
8000bb46:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bb4a:	02 04       	add	r4,r1
8000bb4c:	5c 05       	acr	r5
8000bb4e:	a3 65       	lsl	r5,0x2
8000bb50:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bb54:	a3 64       	lsl	r4,0x2
8000bb56:	5c 34       	neg	r4
8000bb58:	f8 05 01 45 	sbc	r5,r12,r5
8000bb5c:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bb60:	e4 05 07 40 	macu.d	r0,r2,r5
8000bb64:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bb68:	02 04       	add	r4,r1
8000bb6a:	5c 05       	acr	r5
8000bb6c:	ea 03 15 02 	lsl	r3,r5,0x2
8000bb70:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bb74:	e8 02 15 02 	lsl	r2,r4,0x2
8000bb78:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000bb7c:	e4 0b 07 40 	macu.d	r0,r2,r11
8000bb80:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000bb84:	02 02       	add	r2,r1
8000bb86:	5c 03       	acr	r3
8000bb88:	ed b3 00 1c 	bld	r3,0x1c
8000bb8c:	c0 90       	breq	8000bb9e <__avr32_f64_div+0x12a>
8000bb8e:	a1 72       	lsl	r2,0x1
8000bb90:	5c f3       	rol	r3
8000bb92:	20 17       	sub	r7,1
8000bb94:	a3 9a       	lsr	r10,0x3
8000bb96:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000bb9a:	a3 9b       	lsr	r11,0x3
8000bb9c:	c0 58       	rjmp	8000bba6 <__avr32_f64_div+0x132>
8000bb9e:	a5 8a       	lsr	r10,0x4
8000bba0:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000bba4:	a5 8b       	lsr	r11,0x4
8000bba6:	58 07       	cp.w	r7,0
8000bba8:	e0 8a 00 8b 	brle	8000bcbe <__avr32_f64_div_res_subnormal>
8000bbac:	e0 12 ff 00 	andl	r2,0xff00
8000bbb0:	e8 12 00 80 	orl	r2,0x80
8000bbb4:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bbb8:	e4 09 07 40 	macu.d	r0,r2,r9
8000bbbc:	e4 08 06 44 	mulu.d	r4,r2,r8
8000bbc0:	e6 09 06 48 	mulu.d	r8,r3,r9
8000bbc4:	00 05       	add	r5,r0
8000bbc6:	f0 01 00 48 	adc	r8,r8,r1
8000bbca:	5c 09       	acr	r9
8000bbcc:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000bbd0:	58 04       	cp.w	r4,0
8000bbd2:	5c 25       	cpc	r5

8000bbd4 <__avr32_f64_div_round_subnormal>:
8000bbd4:	f4 08 13 00 	cpc	r8,r10
8000bbd8:	f6 09 13 00 	cpc	r9,r11
8000bbdc:	5f 36       	srlo	r6
8000bbde:	f8 06 17 00 	moveq	r6,r12
8000bbe2:	e4 0a 16 08 	lsr	r10,r2,0x8
8000bbe6:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000bbea:	e6 0b 16 08 	lsr	r11,r3,0x8
8000bbee:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bbf2:	ed be 00 1f 	bld	lr,0x1f
8000bbf6:	ef bb 00 1f 	bst	r11,0x1f
8000bbfa:	0c 0a       	add	r10,r6
8000bbfc:	5c 0b       	acr	r11
8000bbfe:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bc02:	e4 1b 00 0f 	andh	r11,0xf
8000bc06:	14 4b       	or	r11,r10
8000bc08:	e0 81 00 a7 	brne	8000bd56 <__avr32_f64_div_res_subnormal+0x98>
8000bc0c:	f2 06 16 14 	lsr	r6,r9,0x14
8000bc10:	ab d6       	cbr	r6,0xb
8000bc12:	e0 46 07 ff 	cp.w	r6,2047
8000bc16:	e0 81 00 a4 	brne	8000bd5e <__avr32_f64_div_res_subnormal+0xa0>
8000bc1a:	c9 e8       	rjmp	8000bd56 <__avr32_f64_div_res_subnormal+0x98>
8000bc1c:	e4 19 00 0f 	andh	r9,0xf
8000bc20:	10 49       	or	r9,r8
8000bc22:	e0 81 00 9a 	brne	8000bd56 <__avr32_f64_div_res_subnormal+0x98>
8000bc26:	c9 28       	rjmp	8000bd4a <__avr32_f64_div_res_subnormal+0x8c>
8000bc28:	a3 7b       	lsl	r11,0x3
8000bc2a:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000bc2e:	a3 7a       	lsl	r10,0x3
8000bc30:	f5 eb 10 04 	or	r4,r10,r11
8000bc34:	e0 80 00 a0 	breq	8000bd74 <__avr32_f64_div_op1_zero>
8000bc38:	f6 04 12 00 	clz	r4,r11
8000bc3c:	c1 70       	breq	8000bc6a <__avr32_f64_div_round_subnormal+0x96>
8000bc3e:	c0 c3       	brcs	8000bc56 <__avr32_f64_div_round_subnormal+0x82>
8000bc40:	e8 05 11 20 	rsub	r5,r4,32
8000bc44:	f6 04 09 4b 	lsl	r11,r11,r4
8000bc48:	f4 05 0a 45 	lsr	r5,r10,r5
8000bc4c:	0a 4b       	or	r11,r5
8000bc4e:	f4 04 09 4a 	lsl	r10,r10,r4
8000bc52:	08 17       	sub	r7,r4
8000bc54:	c0 b8       	rjmp	8000bc6a <__avr32_f64_div_round_subnormal+0x96>
8000bc56:	f4 04 12 00 	clz	r4,r10
8000bc5a:	f9 b4 03 00 	movlo	r4,0
8000bc5e:	f7 b4 02 e0 	subhs	r4,-32
8000bc62:	f4 04 09 4b 	lsl	r11,r10,r4
8000bc66:	30 0a       	mov	r10,0
8000bc68:	08 17       	sub	r7,r4
8000bc6a:	a3 8a       	lsr	r10,0x2
8000bc6c:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000bc70:	a3 8b       	lsr	r11,0x2
8000bc72:	c1 1b       	rjmp	8000ba94 <__avr32_f64_div+0x20>
8000bc74:	a3 79       	lsl	r9,0x3
8000bc76:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000bc7a:	a3 78       	lsl	r8,0x3
8000bc7c:	f3 e8 10 04 	or	r4,r9,r8
8000bc80:	c6 f0       	breq	8000bd5e <__avr32_f64_div_res_subnormal+0xa0>
8000bc82:	f2 04 12 00 	clz	r4,r9
8000bc86:	c1 70       	breq	8000bcb4 <__avr32_f64_div_round_subnormal+0xe0>
8000bc88:	c0 c3       	brcs	8000bca0 <__avr32_f64_div_round_subnormal+0xcc>
8000bc8a:	e8 05 11 20 	rsub	r5,r4,32
8000bc8e:	f2 04 09 49 	lsl	r9,r9,r4
8000bc92:	f0 05 0a 45 	lsr	r5,r8,r5
8000bc96:	0a 49       	or	r9,r5
8000bc98:	f0 04 09 48 	lsl	r8,r8,r4
8000bc9c:	08 16       	sub	r6,r4
8000bc9e:	c0 b8       	rjmp	8000bcb4 <__avr32_f64_div_round_subnormal+0xe0>
8000bca0:	f0 04 12 00 	clz	r4,r8
8000bca4:	f9 b4 03 00 	movlo	r4,0
8000bca8:	f7 b4 02 e0 	subhs	r4,-32
8000bcac:	f0 04 09 49 	lsl	r9,r8,r4
8000bcb0:	30 08       	mov	r8,0
8000bcb2:	08 16       	sub	r6,r4
8000bcb4:	a3 88       	lsr	r8,0x2
8000bcb6:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000bcba:	a3 89       	lsr	r9,0x2
8000bcbc:	cf ca       	rjmp	8000bab4 <__avr32_f64_div+0x40>

8000bcbe <__avr32_f64_div_res_subnormal>:
8000bcbe:	5c 37       	neg	r7
8000bcc0:	2f f7       	sub	r7,-1
8000bcc2:	f1 b7 04 c0 	satu	r7,0x6
8000bcc6:	e0 47 00 20 	cp.w	r7,32
8000bcca:	c1 54       	brge	8000bcf4 <__avr32_f64_div_res_subnormal+0x36>
8000bccc:	ee 06 11 20 	rsub	r6,r7,32
8000bcd0:	e4 07 0a 42 	lsr	r2,r2,r7
8000bcd4:	e6 06 09 4c 	lsl	r12,r3,r6
8000bcd8:	18 42       	or	r2,r12
8000bcda:	e6 07 0a 43 	lsr	r3,r3,r7
8000bcde:	f4 06 09 41 	lsl	r1,r10,r6
8000bce2:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bce6:	f6 06 09 4c 	lsl	r12,r11,r6
8000bcea:	18 4a       	or	r10,r12
8000bcec:	f6 07 0a 4b 	lsr	r11,r11,r7
8000bcf0:	30 00       	mov	r0,0
8000bcf2:	c1 58       	rjmp	8000bd1c <__avr32_f64_div_res_subnormal+0x5e>
8000bcf4:	ee 06 11 20 	rsub	r6,r7,32
8000bcf8:	f9 b0 00 00 	moveq	r0,0
8000bcfc:	f9 bc 00 00 	moveq	r12,0
8000bd00:	c0 50       	breq	8000bd0a <__avr32_f64_div_res_subnormal+0x4c>
8000bd02:	f4 06 09 40 	lsl	r0,r10,r6
8000bd06:	f6 06 09 4c 	lsl	r12,r11,r6
8000bd0a:	e6 07 0a 42 	lsr	r2,r3,r7
8000bd0e:	30 03       	mov	r3,0
8000bd10:	f4 07 0a 41 	lsr	r1,r10,r7
8000bd14:	18 41       	or	r1,r12
8000bd16:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bd1a:	30 0b       	mov	r11,0
8000bd1c:	e0 12 ff 00 	andl	r2,0xff00
8000bd20:	e8 12 00 80 	orl	r2,0x80
8000bd24:	e6 08 06 46 	mulu.d	r6,r3,r8
8000bd28:	e4 09 07 46 	macu.d	r6,r2,r9
8000bd2c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000bd30:	e6 09 06 48 	mulu.d	r8,r3,r9
8000bd34:	0c 05       	add	r5,r6
8000bd36:	f0 07 00 48 	adc	r8,r8,r7
8000bd3a:	5c 09       	acr	r9
8000bd3c:	30 07       	mov	r7,0
8000bd3e:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000bd42:	00 34       	cp.w	r4,r0
8000bd44:	e2 05 13 00 	cpc	r5,r1
8000bd48:	c4 6b       	rjmp	8000bbd4 <__avr32_f64_div_round_subnormal>
8000bd4a:	1c 9b       	mov	r11,lr
8000bd4c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bd50:	30 0a       	mov	r10,0
8000bd52:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bd56:	3f fb       	mov	r11,-1
8000bd58:	30 0a       	mov	r10,0
8000bd5a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bd5e:	f5 eb 10 04 	or	r4,r10,r11
8000bd62:	c0 90       	breq	8000bd74 <__avr32_f64_div_op1_zero>
8000bd64:	1c 9b       	mov	r11,lr
8000bd66:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bd6a:	ea 1b 7f f0 	orh	r11,0x7ff0
8000bd6e:	30 0a       	mov	r10,0
8000bd70:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000bd74 <__avr32_f64_div_op1_zero>:
8000bd74:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000bd78:	ce f0       	breq	8000bd56 <__avr32_f64_div_res_subnormal+0x98>
8000bd7a:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000bd7e:	e0 44 07 ff 	cp.w	r4,2047
8000bd82:	ce 41       	brne	8000bd4a <__avr32_f64_div_res_subnormal+0x8c>
8000bd84:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000bd88:	ce 10       	breq	8000bd4a <__avr32_f64_div_res_subnormal+0x8c>
8000bd8a:	ce 6b       	rjmp	8000bd56 <__avr32_f64_div_res_subnormal+0x98>

8000bd8c <__avr32_udiv64>:
8000bd8c:	d4 31       	pushm	r0-r7,lr
8000bd8e:	1a 97       	mov	r7,sp
8000bd90:	20 3d       	sub	sp,12
8000bd92:	10 9c       	mov	r12,r8
8000bd94:	12 9e       	mov	lr,r9
8000bd96:	14 93       	mov	r3,r10
8000bd98:	58 09       	cp.w	r9,0
8000bd9a:	e0 81 00 bd 	brne	8000bf14 <__avr32_udiv64+0x188>
8000bd9e:	16 38       	cp.w	r8,r11
8000bda0:	e0 88 00 40 	brls	8000be20 <__avr32_udiv64+0x94>
8000bda4:	f0 08 12 00 	clz	r8,r8
8000bda8:	c0 d0       	breq	8000bdc2 <__avr32_udiv64+0x36>
8000bdaa:	f6 08 09 4b 	lsl	r11,r11,r8
8000bdae:	f0 09 11 20 	rsub	r9,r8,32
8000bdb2:	f8 08 09 4c 	lsl	r12,r12,r8
8000bdb6:	f4 09 0a 49 	lsr	r9,r10,r9
8000bdba:	f4 08 09 43 	lsl	r3,r10,r8
8000bdbe:	f3 eb 10 0b 	or	r11,r9,r11
8000bdc2:	f8 0e 16 10 	lsr	lr,r12,0x10
8000bdc6:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000bdca:	f6 0e 0d 00 	divu	r0,r11,lr
8000bdce:	e6 0b 16 10 	lsr	r11,r3,0x10
8000bdd2:	00 99       	mov	r9,r0
8000bdd4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bdd8:	e0 0a 02 48 	mul	r8,r0,r10
8000bddc:	10 3b       	cp.w	r11,r8
8000bdde:	c0 a2       	brcc	8000bdf2 <__avr32_udiv64+0x66>
8000bde0:	20 19       	sub	r9,1
8000bde2:	18 0b       	add	r11,r12
8000bde4:	18 3b       	cp.w	r11,r12
8000bde6:	c0 63       	brcs	8000bdf2 <__avr32_udiv64+0x66>
8000bde8:	10 3b       	cp.w	r11,r8
8000bdea:	f7 b9 03 01 	sublo	r9,1
8000bdee:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bdf2:	f6 08 01 01 	sub	r1,r11,r8
8000bdf6:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000bdfa:	e2 0e 0d 00 	divu	r0,r1,lr
8000bdfe:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000be02:	00 98       	mov	r8,r0
8000be04:	e0 0a 02 4a 	mul	r10,r0,r10
8000be08:	14 33       	cp.w	r3,r10
8000be0a:	c0 82       	brcc	8000be1a <__avr32_udiv64+0x8e>
8000be0c:	20 18       	sub	r8,1
8000be0e:	18 03       	add	r3,r12
8000be10:	18 33       	cp.w	r3,r12
8000be12:	c0 43       	brcs	8000be1a <__avr32_udiv64+0x8e>
8000be14:	14 33       	cp.w	r3,r10
8000be16:	f7 b8 03 01 	sublo	r8,1
8000be1a:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000be1e:	cd f8       	rjmp	8000bfdc <__avr32_udiv64+0x250>
8000be20:	58 08       	cp.w	r8,0
8000be22:	c0 51       	brne	8000be2c <__avr32_udiv64+0xa0>
8000be24:	30 19       	mov	r9,1
8000be26:	f2 08 0d 08 	divu	r8,r9,r8
8000be2a:	10 9c       	mov	r12,r8
8000be2c:	f8 06 12 00 	clz	r6,r12
8000be30:	c0 41       	brne	8000be38 <__avr32_udiv64+0xac>
8000be32:	18 1b       	sub	r11,r12
8000be34:	30 19       	mov	r9,1
8000be36:	c4 08       	rjmp	8000beb6 <__avr32_udiv64+0x12a>
8000be38:	ec 01 11 20 	rsub	r1,r6,32
8000be3c:	f4 01 0a 49 	lsr	r9,r10,r1
8000be40:	f8 06 09 4c 	lsl	r12,r12,r6
8000be44:	f6 06 09 48 	lsl	r8,r11,r6
8000be48:	f6 01 0a 41 	lsr	r1,r11,r1
8000be4c:	f3 e8 10 08 	or	r8,r9,r8
8000be50:	f8 03 16 10 	lsr	r3,r12,0x10
8000be54:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000be58:	e2 03 0d 00 	divu	r0,r1,r3
8000be5c:	f0 0b 16 10 	lsr	r11,r8,0x10
8000be60:	00 9e       	mov	lr,r0
8000be62:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000be66:	e0 05 02 49 	mul	r9,r0,r5
8000be6a:	12 3b       	cp.w	r11,r9
8000be6c:	c0 a2       	brcc	8000be80 <__avr32_udiv64+0xf4>
8000be6e:	20 1e       	sub	lr,1
8000be70:	18 0b       	add	r11,r12
8000be72:	18 3b       	cp.w	r11,r12
8000be74:	c0 63       	brcs	8000be80 <__avr32_udiv64+0xf4>
8000be76:	12 3b       	cp.w	r11,r9
8000be78:	f7 be 03 01 	sublo	lr,1
8000be7c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000be80:	12 1b       	sub	r11,r9
8000be82:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000be86:	f6 03 0d 02 	divu	r2,r11,r3
8000be8a:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000be8e:	04 99       	mov	r9,r2
8000be90:	e4 05 02 4b 	mul	r11,r2,r5
8000be94:	16 38       	cp.w	r8,r11
8000be96:	c0 a2       	brcc	8000beaa <__avr32_udiv64+0x11e>
8000be98:	20 19       	sub	r9,1
8000be9a:	18 08       	add	r8,r12
8000be9c:	18 38       	cp.w	r8,r12
8000be9e:	c0 63       	brcs	8000beaa <__avr32_udiv64+0x11e>
8000bea0:	16 38       	cp.w	r8,r11
8000bea2:	f7 b9 03 01 	sublo	r9,1
8000bea6:	f1 dc e3 08 	addcs	r8,r8,r12
8000beaa:	f4 06 09 43 	lsl	r3,r10,r6
8000beae:	f0 0b 01 0b 	sub	r11,r8,r11
8000beb2:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000beb6:	f8 06 16 10 	lsr	r6,r12,0x10
8000beba:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000bebe:	f6 06 0d 00 	divu	r0,r11,r6
8000bec2:	e6 0b 16 10 	lsr	r11,r3,0x10
8000bec6:	00 9a       	mov	r10,r0
8000bec8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000becc:	e0 0e 02 48 	mul	r8,r0,lr
8000bed0:	10 3b       	cp.w	r11,r8
8000bed2:	c0 a2       	brcc	8000bee6 <__avr32_udiv64+0x15a>
8000bed4:	20 1a       	sub	r10,1
8000bed6:	18 0b       	add	r11,r12
8000bed8:	18 3b       	cp.w	r11,r12
8000beda:	c0 63       	brcs	8000bee6 <__avr32_udiv64+0x15a>
8000bedc:	10 3b       	cp.w	r11,r8
8000bede:	f7 ba 03 01 	sublo	r10,1
8000bee2:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bee6:	f6 08 01 01 	sub	r1,r11,r8
8000beea:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000beee:	e2 06 0d 00 	divu	r0,r1,r6
8000bef2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000bef6:	00 98       	mov	r8,r0
8000bef8:	e0 0e 02 4b 	mul	r11,r0,lr
8000befc:	16 33       	cp.w	r3,r11
8000befe:	c0 82       	brcc	8000bf0e <__avr32_udiv64+0x182>
8000bf00:	20 18       	sub	r8,1
8000bf02:	18 03       	add	r3,r12
8000bf04:	18 33       	cp.w	r3,r12
8000bf06:	c0 43       	brcs	8000bf0e <__avr32_udiv64+0x182>
8000bf08:	16 33       	cp.w	r3,r11
8000bf0a:	f7 b8 03 01 	sublo	r8,1
8000bf0e:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000bf12:	c6 98       	rjmp	8000bfe4 <__avr32_udiv64+0x258>
8000bf14:	16 39       	cp.w	r9,r11
8000bf16:	e0 8b 00 65 	brhi	8000bfe0 <__avr32_udiv64+0x254>
8000bf1a:	f2 09 12 00 	clz	r9,r9
8000bf1e:	c0 b1       	brne	8000bf34 <__avr32_udiv64+0x1a8>
8000bf20:	10 3a       	cp.w	r10,r8
8000bf22:	5f 2a       	srhs	r10
8000bf24:	1c 3b       	cp.w	r11,lr
8000bf26:	5f b8       	srhi	r8
8000bf28:	10 4a       	or	r10,r8
8000bf2a:	f2 0a 18 00 	cp.b	r10,r9
8000bf2e:	c5 90       	breq	8000bfe0 <__avr32_udiv64+0x254>
8000bf30:	30 18       	mov	r8,1
8000bf32:	c5 98       	rjmp	8000bfe4 <__avr32_udiv64+0x258>
8000bf34:	f0 09 09 46 	lsl	r6,r8,r9
8000bf38:	f2 03 11 20 	rsub	r3,r9,32
8000bf3c:	fc 09 09 4e 	lsl	lr,lr,r9
8000bf40:	f0 03 0a 48 	lsr	r8,r8,r3
8000bf44:	f6 09 09 4c 	lsl	r12,r11,r9
8000bf48:	f4 03 0a 42 	lsr	r2,r10,r3
8000bf4c:	ef 46 ff f4 	st.w	r7[-12],r6
8000bf50:	f6 03 0a 43 	lsr	r3,r11,r3
8000bf54:	18 42       	or	r2,r12
8000bf56:	f1 ee 10 0c 	or	r12,r8,lr
8000bf5a:	f8 01 16 10 	lsr	r1,r12,0x10
8000bf5e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bf62:	e6 01 0d 04 	divu	r4,r3,r1
8000bf66:	e4 03 16 10 	lsr	r3,r2,0x10
8000bf6a:	08 9e       	mov	lr,r4
8000bf6c:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000bf70:	e8 06 02 48 	mul	r8,r4,r6
8000bf74:	10 33       	cp.w	r3,r8
8000bf76:	c0 a2       	brcc	8000bf8a <__avr32_udiv64+0x1fe>
8000bf78:	20 1e       	sub	lr,1
8000bf7a:	18 03       	add	r3,r12
8000bf7c:	18 33       	cp.w	r3,r12
8000bf7e:	c0 63       	brcs	8000bf8a <__avr32_udiv64+0x1fe>
8000bf80:	10 33       	cp.w	r3,r8
8000bf82:	f7 be 03 01 	sublo	lr,1
8000bf86:	e7 dc e3 03 	addcs	r3,r3,r12
8000bf8a:	10 13       	sub	r3,r8
8000bf8c:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000bf90:	e6 01 0d 00 	divu	r0,r3,r1
8000bf94:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bf98:	00 98       	mov	r8,r0
8000bf9a:	e0 06 02 46 	mul	r6,r0,r6
8000bf9e:	0c 3b       	cp.w	r11,r6
8000bfa0:	c0 a2       	brcc	8000bfb4 <__avr32_udiv64+0x228>
8000bfa2:	20 18       	sub	r8,1
8000bfa4:	18 0b       	add	r11,r12
8000bfa6:	18 3b       	cp.w	r11,r12
8000bfa8:	c0 63       	brcs	8000bfb4 <__avr32_udiv64+0x228>
8000bfaa:	0c 3b       	cp.w	r11,r6
8000bfac:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bfb0:	f7 b8 03 01 	sublo	r8,1
8000bfb4:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000bfb8:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000bfbc:	0c 1b       	sub	r11,r6
8000bfbe:	f0 04 06 42 	mulu.d	r2,r8,r4
8000bfc2:	06 95       	mov	r5,r3
8000bfc4:	16 35       	cp.w	r5,r11
8000bfc6:	e0 8b 00 0a 	brhi	8000bfda <__avr32_udiv64+0x24e>
8000bfca:	5f 0b       	sreq	r11
8000bfcc:	f4 09 09 49 	lsl	r9,r10,r9
8000bfd0:	12 32       	cp.w	r2,r9
8000bfd2:	5f b9       	srhi	r9
8000bfd4:	f7 e9 00 09 	and	r9,r11,r9
8000bfd8:	c0 60       	breq	8000bfe4 <__avr32_udiv64+0x258>
8000bfda:	20 18       	sub	r8,1
8000bfdc:	30 09       	mov	r9,0
8000bfde:	c0 38       	rjmp	8000bfe4 <__avr32_udiv64+0x258>
8000bfe0:	30 09       	mov	r9,0
8000bfe2:	12 98       	mov	r8,r9
8000bfe4:	10 9a       	mov	r10,r8
8000bfe6:	12 93       	mov	r3,r9
8000bfe8:	10 92       	mov	r2,r8
8000bfea:	12 9b       	mov	r11,r9
8000bfec:	2f dd       	sub	sp,-12
8000bfee:	d8 32       	popm	r0-r7,pc

8000bff0 <__avr32_umod64>:
8000bff0:	d4 31       	pushm	r0-r7,lr
8000bff2:	1a 97       	mov	r7,sp
8000bff4:	20 3d       	sub	sp,12
8000bff6:	10 9c       	mov	r12,r8
8000bff8:	12 95       	mov	r5,r9
8000bffa:	14 9e       	mov	lr,r10
8000bffc:	16 91       	mov	r1,r11
8000bffe:	16 96       	mov	r6,r11
8000c000:	58 09       	cp.w	r9,0
8000c002:	e0 81 00 81 	brne	8000c104 <__avr32_umod64+0x114>
8000c006:	16 38       	cp.w	r8,r11
8000c008:	e0 88 00 12 	brls	8000c02c <__avr32_umod64+0x3c>
8000c00c:	f0 08 12 00 	clz	r8,r8
8000c010:	c4 e0       	breq	8000c0ac <__avr32_umod64+0xbc>
8000c012:	f6 08 09 46 	lsl	r6,r11,r8
8000c016:	f8 08 09 4c 	lsl	r12,r12,r8
8000c01a:	f0 0b 11 20 	rsub	r11,r8,32
8000c01e:	f4 08 09 4e 	lsl	lr,r10,r8
8000c022:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c026:	f7 e6 10 06 	or	r6,r11,r6
8000c02a:	c4 18       	rjmp	8000c0ac <__avr32_umod64+0xbc>
8000c02c:	58 08       	cp.w	r8,0
8000c02e:	c0 51       	brne	8000c038 <__avr32_umod64+0x48>
8000c030:	30 19       	mov	r9,1
8000c032:	f2 08 0d 08 	divu	r8,r9,r8
8000c036:	10 9c       	mov	r12,r8
8000c038:	f8 08 12 00 	clz	r8,r12
8000c03c:	c0 31       	brne	8000c042 <__avr32_umod64+0x52>
8000c03e:	18 16       	sub	r6,r12
8000c040:	c3 68       	rjmp	8000c0ac <__avr32_umod64+0xbc>
8000c042:	f0 03 11 20 	rsub	r3,r8,32
8000c046:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c04a:	f8 08 09 4c 	lsl	r12,r12,r8
8000c04e:	ec 08 09 49 	lsl	r9,r6,r8
8000c052:	ec 03 0a 43 	lsr	r3,r6,r3
8000c056:	f7 e9 10 09 	or	r9,r11,r9
8000c05a:	f8 05 16 10 	lsr	r5,r12,0x10
8000c05e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c062:	e6 05 0d 02 	divu	r2,r3,r5
8000c066:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c06a:	ec 02 02 4b 	mul	r11,r6,r2
8000c06e:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c072:	16 3e       	cp.w	lr,r11
8000c074:	c0 72       	brcc	8000c082 <__avr32_umod64+0x92>
8000c076:	18 0e       	add	lr,r12
8000c078:	18 3e       	cp.w	lr,r12
8000c07a:	c0 43       	brcs	8000c082 <__avr32_umod64+0x92>
8000c07c:	16 3e       	cp.w	lr,r11
8000c07e:	fd dc e3 0e 	addcs	lr,lr,r12
8000c082:	fc 0b 01 03 	sub	r3,lr,r11
8000c086:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c08a:	e6 05 0d 02 	divu	r2,r3,r5
8000c08e:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c092:	a5 36       	mul	r6,r2
8000c094:	0c 39       	cp.w	r9,r6
8000c096:	c0 72       	brcc	8000c0a4 <__avr32_umod64+0xb4>
8000c098:	18 09       	add	r9,r12
8000c09a:	18 39       	cp.w	r9,r12
8000c09c:	c0 43       	brcs	8000c0a4 <__avr32_umod64+0xb4>
8000c09e:	0c 39       	cp.w	r9,r6
8000c0a0:	f3 dc e3 09 	addcs	r9,r9,r12
8000c0a4:	f2 06 01 06 	sub	r6,r9,r6
8000c0a8:	f4 08 09 4e 	lsl	lr,r10,r8
8000c0ac:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c0b0:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c0b4:	ec 0a 0d 02 	divu	r2,r6,r10
8000c0b8:	fc 09 16 10 	lsr	r9,lr,0x10
8000c0bc:	ea 02 02 4b 	mul	r11,r5,r2
8000c0c0:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c0c4:	16 39       	cp.w	r9,r11
8000c0c6:	c0 72       	brcc	8000c0d4 <__avr32_umod64+0xe4>
8000c0c8:	18 09       	add	r9,r12
8000c0ca:	18 39       	cp.w	r9,r12
8000c0cc:	c0 43       	brcs	8000c0d4 <__avr32_umod64+0xe4>
8000c0ce:	16 39       	cp.w	r9,r11
8000c0d0:	f3 dc e3 09 	addcs	r9,r9,r12
8000c0d4:	f2 0b 01 0b 	sub	r11,r9,r11
8000c0d8:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c0dc:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c0e0:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c0e4:	ea 0a 02 4a 	mul	r10,r5,r10
8000c0e8:	14 3e       	cp.w	lr,r10
8000c0ea:	c0 72       	brcc	8000c0f8 <__avr32_umod64+0x108>
8000c0ec:	18 0e       	add	lr,r12
8000c0ee:	18 3e       	cp.w	lr,r12
8000c0f0:	c0 43       	brcs	8000c0f8 <__avr32_umod64+0x108>
8000c0f2:	14 3e       	cp.w	lr,r10
8000c0f4:	fd dc e3 0e 	addcs	lr,lr,r12
8000c0f8:	fc 0a 01 0a 	sub	r10,lr,r10
8000c0fc:	30 0b       	mov	r11,0
8000c0fe:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c102:	c7 b8       	rjmp	8000c1f8 <__avr32_umod64+0x208>
8000c104:	16 39       	cp.w	r9,r11
8000c106:	e0 8b 00 79 	brhi	8000c1f8 <__avr32_umod64+0x208>
8000c10a:	f2 09 12 00 	clz	r9,r9
8000c10e:	c1 21       	brne	8000c132 <__avr32_umod64+0x142>
8000c110:	10 3a       	cp.w	r10,r8
8000c112:	5f 2b       	srhs	r11
8000c114:	0a 31       	cp.w	r1,r5
8000c116:	5f ba       	srhi	r10
8000c118:	f7 ea 10 0a 	or	r10,r11,r10
8000c11c:	f2 0a 18 00 	cp.b	r10,r9
8000c120:	c0 60       	breq	8000c12c <__avr32_umod64+0x13c>
8000c122:	fc 08 01 0c 	sub	r12,lr,r8
8000c126:	e2 05 01 46 	sbc	r6,r1,r5
8000c12a:	18 9e       	mov	lr,r12
8000c12c:	0c 9b       	mov	r11,r6
8000c12e:	1c 9a       	mov	r10,lr
8000c130:	c6 48       	rjmp	8000c1f8 <__avr32_umod64+0x208>
8000c132:	ea 09 09 4c 	lsl	r12,r5,r9
8000c136:	f2 06 11 20 	rsub	r6,r9,32
8000c13a:	f6 09 09 4b 	lsl	r11,r11,r9
8000c13e:	f0 09 09 42 	lsl	r2,r8,r9
8000c142:	ef 46 ff f4 	st.w	r7[-12],r6
8000c146:	f0 06 0a 48 	lsr	r8,r8,r6
8000c14a:	18 48       	or	r8,r12
8000c14c:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c150:	f4 09 09 43 	lsl	r3,r10,r9
8000c154:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c158:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c15c:	16 4a       	or	r10,r11
8000c15e:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c162:	f8 0b 0d 04 	divu	r4,r12,r11
8000c166:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c16a:	08 91       	mov	r1,r4
8000c16c:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c170:	e8 0e 02 46 	mul	r6,r4,lr
8000c174:	0c 3c       	cp.w	r12,r6
8000c176:	c0 a2       	brcc	8000c18a <__avr32_umod64+0x19a>
8000c178:	20 11       	sub	r1,1
8000c17a:	10 0c       	add	r12,r8
8000c17c:	10 3c       	cp.w	r12,r8
8000c17e:	c0 63       	brcs	8000c18a <__avr32_umod64+0x19a>
8000c180:	0c 3c       	cp.w	r12,r6
8000c182:	f7 b1 03 01 	sublo	r1,1
8000c186:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c18a:	0c 1c       	sub	r12,r6
8000c18c:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c190:	f8 0b 0d 04 	divu	r4,r12,r11
8000c194:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c198:	08 96       	mov	r6,r4
8000c19a:	e8 0e 02 4e 	mul	lr,r4,lr
8000c19e:	1c 3b       	cp.w	r11,lr
8000c1a0:	c0 a2       	brcc	8000c1b4 <__avr32_umod64+0x1c4>
8000c1a2:	20 16       	sub	r6,1
8000c1a4:	10 0b       	add	r11,r8
8000c1a6:	10 3b       	cp.w	r11,r8
8000c1a8:	c0 63       	brcs	8000c1b4 <__avr32_umod64+0x1c4>
8000c1aa:	1c 3b       	cp.w	r11,lr
8000c1ac:	f7 b6 03 01 	sublo	r6,1
8000c1b0:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c1b4:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c1b8:	1c 1b       	sub	r11,lr
8000c1ba:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c1be:	00 9e       	mov	lr,r0
8000c1c0:	02 9c       	mov	r12,r1
8000c1c2:	16 3c       	cp.w	r12,r11
8000c1c4:	e0 8b 00 08 	brhi	8000c1d4 <__avr32_umod64+0x1e4>
8000c1c8:	5f 06       	sreq	r6
8000c1ca:	06 30       	cp.w	r0,r3
8000c1cc:	5f ba       	srhi	r10
8000c1ce:	ed ea 00 0a 	and	r10,r6,r10
8000c1d2:	c0 60       	breq	8000c1de <__avr32_umod64+0x1ee>
8000c1d4:	fc 02 01 04 	sub	r4,lr,r2
8000c1d8:	f8 08 01 4c 	sbc	r12,r12,r8
8000c1dc:	08 9e       	mov	lr,r4
8000c1de:	e6 0e 01 0a 	sub	r10,r3,lr
8000c1e2:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c1e6:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c1ea:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c1ee:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c1f2:	f8 01 09 4c 	lsl	r12,r12,r1
8000c1f6:	18 4a       	or	r10,r12
8000c1f8:	2f dd       	sub	sp,-12
8000c1fa:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c200 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c200:	c0 08       	rjmp	8000c200 <_evba>
	...

8000c204 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c204:	c0 08       	rjmp	8000c204 <_handle_TLB_Multiple_Hit>
	...

8000c208 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c208:	c0 08       	rjmp	8000c208 <_handle_Bus_Error_Data_Fetch>
	...

8000c20c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c20c:	c0 08       	rjmp	8000c20c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c210 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c210:	c0 08       	rjmp	8000c210 <_handle_NMI>
	...

8000c214 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c214:	c0 08       	rjmp	8000c214 <_handle_Instruction_Address>
	...

8000c218 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c218:	c0 08       	rjmp	8000c218 <_handle_ITLB_Protection>
	...

8000c21c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c21c:	c0 08       	rjmp	8000c21c <_handle_Breakpoint>
	...

8000c220 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c220:	c0 08       	rjmp	8000c220 <_handle_Illegal_Opcode>
	...

8000c224 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c224:	c0 08       	rjmp	8000c224 <_handle_Unimplemented_Instruction>
	...

8000c228 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c228:	c0 08       	rjmp	8000c228 <_handle_Privilege_Violation>
	...

8000c22c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c22c:	c0 08       	rjmp	8000c22c <_handle_Floating_Point>
	...

8000c230 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c230:	c0 08       	rjmp	8000c230 <_handle_Coprocessor_Absent>
	...

8000c234 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c234:	c0 08       	rjmp	8000c234 <_handle_Data_Address_Read>
	...

8000c238 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c238:	c0 08       	rjmp	8000c238 <_handle_Data_Address_Write>
	...

8000c23c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c23c:	c0 08       	rjmp	8000c23c <_handle_DTLB_Protection_Read>
	...

8000c240 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c240:	c0 08       	rjmp	8000c240 <_handle_DTLB_Protection_Write>
	...

8000c244 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c244:	c0 08       	rjmp	8000c244 <_handle_DTLB_Modified>
	...

8000c250 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c250:	c0 08       	rjmp	8000c250 <_handle_ITLB_Miss>
	...

8000c260 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c260:	c0 08       	rjmp	8000c260 <_handle_DTLB_Miss_Read>
	...

8000c270 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c270:	c0 08       	rjmp	8000c270 <_handle_DTLB_Miss_Write>
	...

8000c300 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c300:	fe cf 70 38 	sub	pc,pc,28728

8000c304 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c304:	30 0c       	mov	r12,0
8000c306:	fe b0 c4 55 	rcall	80004bb0 <_get_interrupt_handler>
8000c30a:	58 0c       	cp.w	r12,0
8000c30c:	f8 0f 17 10 	movne	pc,r12
8000c310:	d6 03       	rete

8000c312 <_int1>:
8000c312:	30 1c       	mov	r12,1
8000c314:	fe b0 c4 4e 	rcall	80004bb0 <_get_interrupt_handler>
8000c318:	58 0c       	cp.w	r12,0
8000c31a:	f8 0f 17 10 	movne	pc,r12
8000c31e:	d6 03       	rete

8000c320 <_int2>:
8000c320:	30 2c       	mov	r12,2
8000c322:	fe b0 c4 47 	rcall	80004bb0 <_get_interrupt_handler>
8000c326:	58 0c       	cp.w	r12,0
8000c328:	f8 0f 17 10 	movne	pc,r12
8000c32c:	d6 03       	rete

8000c32e <_int3>:
8000c32e:	30 3c       	mov	r12,3
8000c330:	fe b0 c4 40 	rcall	80004bb0 <_get_interrupt_handler>
8000c334:	58 0c       	cp.w	r12,0
8000c336:	f8 0f 17 10 	movne	pc,r12
8000c33a:	d6 03       	rete

8000c33c <ipr_val>:
8000c33c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c34c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c35c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c36c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c37c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c38c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c39c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3fc:	d7 03 d7 03                                         ....
