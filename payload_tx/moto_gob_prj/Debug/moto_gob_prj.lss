
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         000097a8  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000b800  8000b800  0000bc00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       0000117c  8000ba00  8000ba00  0000be00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .lalign       00000004  8000cb7c  8000cb7c  0000cf7c  2**0
                  ALLOC
  6 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  7 .data         00000a34  00000008  8000cb80  0000d008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .balign       00000004  00000a3c  8000d5b4  0000da3c  2**0
                  ALLOC
  9 .bss          000035b0  00000a40  00000a40  00000000  2**2
                  ALLOC
 10 .heap         00013010  00003ff0  00003ff0  00000000  2**0
                  ALLOC
 11 .comment      00000030  00000000  00000000  0000da3c  2**0
                  CONTENTS, READONLY
 12 .debug_aranges 00001120  00000000  00000000  0000da70  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubnames 000023e5  00000000  00000000  0000eb90  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_info   0002802b  00000000  00000000  00010f75  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_abbrev 000066d4  00000000  00000000  00038fa0  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_line   0000bf18  00000000  00000000  0003f674  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_frame  00002d0c  00000000  00000000  0004b58c  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    00006c41  00000000  00000000  0004e298  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_loc    0000c7f3  00000000  00000000  00054ed9  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 21 .debug_ranges 00001210  00000000  00000000  000616d0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf a1 74 	sub	pc,pc,-24204

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf c1 78 	sub	pc,pc,-16008

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d 8c       	ld.ub	r12,r6[0x0]

8000202c <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
8000202c:	5e fc       	retal	r12
8000202e:	d7 03       	nop

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 5c       	eor	r12,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	20 94       	sub	r4,9
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 8c       	sub	r12,-120
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	29 58       	sub	r8,-107
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	36 50       	mov	r0,101
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	ba 00       	st.h	sp[0x0],r0
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	27 d0       	sub	r0,125
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	56 00       	stdsp	sp[0x180],r0
80002090:	00 00       	add	r0,r0
80002092:	0a 44       	or	r4,r5

80002094 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002094:	d4 01       	pushm	lr
  log("R");
80002096:	48 3c       	lddpc	r12,800020a0 <app_payload_tx_proc+0xc>
80002098:	f0 1f 00 03 	mcall	800020a4 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
8000209c:	d8 02       	popm	pc
8000209e:	00 00       	add	r0,r0
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	ba 08       	st.h	sp[0x0],r8
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	59 c4       	cp.w	r4,28

800020a8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020a8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020aa:	48 3c       	lddpc	r12,800020b4 <FD_brdcst_func+0xc>
800020ac:	f0 1f 00 03 	mcall	800020b8 <FD_brdcst_func+0x10>
	
}
800020b0:	d8 02       	popm	pc
800020b2:	00 00       	add	r0,r0
800020b4:	80 00       	ld.sh	r0,r0[0x0]
800020b6:	ba 0c       	st.h	sp[0x0],r12
800020b8:	80 00       	ld.sh	r0,r0[0x0]
800020ba:	59 c4       	cp.w	r4,28

800020bc <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020bc:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020be:	48 3c       	lddpc	r12,800020c8 <FD_reply_func+0xc>
800020c0:	f0 1f 00 03 	mcall	800020cc <FD_reply_func+0x10>
	
	
}
800020c4:	d8 02       	popm	pc
800020c6:	00 00       	add	r0,r0
800020c8:	80 00       	ld.sh	r0,r0[0x0]
800020ca:	ba 2c       	st.h	sp[0x4],r12
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	59 c4       	cp.w	r4,28

800020d0 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020d0:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020d2:	48 3c       	lddpc	r12,800020dc <FD_request_func+0xc>
800020d4:	f0 1f 00 03 	mcall	800020e0 <FD_request_func+0x10>
	
	
}
800020d8:	d8 02       	popm	pc
800020da:	00 00       	add	r0,r0
800020dc:	80 00       	ld.sh	r0,r0[0x0]
800020de:	ba 48       	st.h	sp[0x8],r8
800020e0:	80 00       	ld.sh	r0,r0[0x0]
800020e2:	59 c4       	cp.w	r4,28

800020e4 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020e4:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020e6:	48 3c       	lddpc	r12,800020f0 <EnOB_brdcst_func+0xc>
800020e8:	f0 1f 00 03 	mcall	800020f4 <EnOB_brdcst_func+0x10>
}
800020ec:	d8 02       	popm	pc
800020ee:	00 00       	add	r0,r0
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	ba 64       	st.h	sp[0xc],r4
800020f4:	80 00       	ld.sh	r0,r0[0x0]
800020f6:	59 c4       	cp.w	r4,28

800020f8 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020f8:	eb cd 40 80 	pushm	r7,lr
800020fc:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020fe:	19 a9       	ld.ub	r9,r12[0x2]
80002100:	30 08       	mov	r8,0
80002102:	f0 09 18 00 	cp.b	r9,r8
80002106:	c1 91       	brne	80002138 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002108:	19 b8       	ld.ub	r8,r12[0x3]
8000210a:	30 19       	mov	r9,1
8000210c:	f2 08 18 00 	cp.b	r8,r9
80002110:	c0 61       	brne	8000211c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002112:	49 0c       	lddpc	r12,80002150 <EnOB_reply_func+0x58>
80002114:	f0 1f 00 10 	mcall	80002154 <EnOB_reply_func+0x5c>
80002118:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000211c:	58 08       	cp.w	r8,0
8000211e:	c0 61       	brne	8000212a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002120:	48 ec       	lddpc	r12,80002158 <EnOB_reply_func+0x60>
80002122:	f0 1f 00 0d 	mcall	80002154 <EnOB_reply_func+0x5c>
80002126:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000212a:	1a d8       	st.w	--sp,r8
8000212c:	48 cc       	lddpc	r12,8000215c <EnOB_reply_func+0x64>
8000212e:	f0 1f 00 0a 	mcall	80002154 <EnOB_reply_func+0x5c>
80002132:	2f fd       	sub	sp,-4
80002134:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002138:	48 ac       	lddpc	r12,80002160 <EnOB_reply_func+0x68>
8000213a:	f0 1f 00 07 	mcall	80002154 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000213e:	0f a8       	ld.ub	r8,r7[0x2]
80002140:	1a d8       	st.w	--sp,r8
80002142:	48 9c       	lddpc	r12,80002164 <EnOB_reply_func+0x6c>
80002144:	f0 1f 00 04 	mcall	80002154 <EnOB_reply_func+0x5c>
80002148:	2f fd       	sub	sp,-4
8000214a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000214e:	00 00       	add	r0,r0
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	ba 7c       	st.h	sp[0xe],r12
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	59 c4       	cp.w	r4,28
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	ba 94       	st.b	sp[0x1],r4
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	ba a8       	st.b	sp[0x2],r8
80002160:	80 00       	ld.sh	r0,r0[0x0]
80002162:	ba c0       	st.b	sp[0x4],r0
80002164:	80 00       	ld.sh	r0,r0[0x0]
80002166:	ba dc       	st.b	sp[0x5],r12

80002168 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002168:	eb cd 40 80 	pushm	r7,lr
8000216c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000216e:	19 a9       	ld.ub	r9,r12[0x2]
80002170:	31 18       	mov	r8,17
80002172:	f0 09 18 00 	cp.b	r9,r8
80002176:	c0 61       	brne	80002182 <SingleDetection_brdcst_func+0x1a>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002178:	48 8c       	lddpc	r12,80002198 <SingleDetection_brdcst_func+0x30>
8000217a:	f0 1f 00 09 	mcall	8000219c <SingleDetection_brdcst_func+0x34>
8000217e:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error");
80002182:	48 8c       	lddpc	r12,800021a0 <SingleDetection_brdcst_func+0x38>
80002184:	f0 1f 00 06 	mcall	8000219c <SingleDetection_brdcst_func+0x34>
		log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
80002188:	0f a8       	ld.ub	r8,r7[0x2]
8000218a:	1a d8       	st.w	--sp,r8
8000218c:	48 6c       	lddpc	r12,800021a4 <SingleDetection_brdcst_func+0x3c>
8000218e:	f0 1f 00 04 	mcall	8000219c <SingleDetection_brdcst_func+0x34>
80002192:	2f fd       	sub	sp,-4
80002194:	e3 cd 80 80 	ldm	sp++,r7,pc
80002198:	80 00       	ld.sh	r0,r0[0x0]
8000219a:	ba f4       	st.b	sp[0x7],r4
8000219c:	80 00       	ld.sh	r0,r0[0x0]
8000219e:	59 c4       	cp.w	r4,28
800021a0:	80 00       	ld.sh	r0,r0[0x0]
800021a2:	bb 08       	ld.d	r8,sp
800021a4:	80 00       	ld.sh	r0,r0[0x0]
800021a6:	bb 18       	ld.d	r8,--sp

800021a8 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021a8:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021aa:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ae:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021b0:	4a bc       	lddpc	r12,8000225c <ButtonConfig_brdcst_func+0xb4>
800021b2:	f0 1f 00 2c 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021b6:	0f 88       	ld.ub	r8,r7[0x0]
800021b8:	1a d8       	st.w	--sp,r8
800021ba:	4a bc       	lddpc	r12,80002264 <ButtonConfig_brdcst_func+0xbc>
800021bc:	f0 1f 00 29 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021c0:	1a d5       	st.w	--sp,r5
800021c2:	4a ac       	lddpc	r12,80002268 <ButtonConfig_brdcst_func+0xc0>
800021c4:	f0 1f 00 27 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021c8:	0f a8       	ld.ub	r8,r7[0x2]
800021ca:	1a d8       	st.w	--sp,r8
800021cc:	4a 8c       	lddpc	r12,8000226c <ButtonConfig_brdcst_func+0xc4>
800021ce:	f0 1f 00 25 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021d2:	2f dd       	sub	sp,-12
800021d4:	58 05       	cp.w	r5,0
800021d6:	c4 10       	breq	80002258 <ButtonConfig_brdcst_func+0xb0>
800021d8:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021da:	4a 64       	lddpc	r4,80002270 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021dc:	4a 63       	lddpc	r3,80002274 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021de:	4a 72       	lddpc	r2,80002278 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021e0:	4a 71       	lddpc	r1,8000227c <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021e2:	4a 80       	lddpc	r0,80002280 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021e4:	0f b9       	ld.ub	r9,r7[0x3]
800021e6:	0f c8       	ld.ub	r8,r7[0x4]
800021e8:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021ec:	1a d8       	st.w	--sp,r8
800021ee:	1a d6       	st.w	--sp,r6
800021f0:	08 9c       	mov	r12,r4
800021f2:	f0 1f 00 1c 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021f6:	0f d9       	ld.ub	r9,r7[0x5]
800021f8:	0f e8       	ld.ub	r8,r7[0x6]
800021fa:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021fe:	1a d8       	st.w	--sp,r8
80002200:	1a d6       	st.w	--sp,r6
80002202:	06 9c       	mov	r12,r3
80002204:	f0 1f 00 17 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002208:	0f f9       	ld.ub	r9,r7[0x7]
8000220a:	ef 38 00 08 	ld.ub	r8,r7[8]
8000220e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002212:	1a d8       	st.w	--sp,r8
80002214:	1a d6       	st.w	--sp,r6
80002216:	04 9c       	mov	r12,r2
80002218:	f0 1f 00 12 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	ef 39 00 09 	ld.ub	r9,r7[9]
80002220:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	02 9c       	mov	r12,r1
8000222e:	f0 1f 00 0d 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002232:	2f 8d       	sub	sp,-32
80002234:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002238:	ef 38 00 0c 	ld.ub	r8,r7[12]
8000223c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002240:	1a d8       	st.w	--sp,r8
80002242:	1a d6       	st.w	--sp,r6
80002244:	00 9c       	mov	r12,r0
80002246:	f0 1f 00 07 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
8000224a:	2f f6       	sub	r6,-1
8000224c:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000224e:	2f ed       	sub	sp,-8
80002250:	ec 05 18 00 	cp.b	r5,r6
80002254:	fe 9b ff c8 	brhi	800021e4 <ButtonConfig_brdcst_func+0x3c>
80002258:	d8 32       	popm	r0-r7,pc
8000225a:	00 00       	add	r0,r0
8000225c:	80 00       	ld.sh	r0,r0[0x0]
8000225e:	bb 30       	mul	r0,sp
80002260:	80 00       	ld.sh	r0,r0[0x0]
80002262:	59 c4       	cp.w	r4,28
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	bb 50       	asr	r0,0x1b
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	bb 64       	lsl	r4,0x1a
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	bb 7c       	lsl	r12,0x1b
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	bb 9c       	lsr	r12,0x1b
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	bb c4       	cbr	r4,0x1a
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	bb ec       	*unknown*
8000227c:	80 00       	ld.sh	r0,r0[0x0]
8000227e:	bc 10       	st.h	lr[0x2],r0
80002280:	80 00       	ld.sh	r0,r0[0x0]
80002282:	bc 38       	st.h	lr[0x6],r8

80002284 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002284:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
80002288:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
8000228a:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
8000228c:	19 c7       	ld.ub	r7,r12[0x4]
8000228e:	19 d8       	ld.ub	r8,r12[0x5]
80002290:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002294:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
80002296:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
80002298:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
8000229c:	49 0c       	lddpc	r12,800022dc <Phyuserinput_brdcst_func+0x58>
8000229e:	f0 1f 00 11 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
800022a2:	1a d6       	st.w	--sp,r6
800022a4:	49 0c       	lddpc	r12,800022e4 <Phyuserinput_brdcst_func+0x60>
800022a6:	f0 1f 00 0f 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
800022aa:	1a d5       	st.w	--sp,r5
800022ac:	48 fc       	lddpc	r12,800022e8 <Phyuserinput_brdcst_func+0x64>
800022ae:	f0 1f 00 0d 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
800022b2:	5c 77       	castu.h	r7
800022b4:	1a d7       	st.w	--sp,r7
800022b6:	48 ec       	lddpc	r12,800022ec <Phyuserinput_brdcst_func+0x68>
800022b8:	f0 1f 00 0a 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
800022bc:	1a d4       	st.w	--sp,r4
800022be:	48 dc       	lddpc	r12,800022f0 <Phyuserinput_brdcst_func+0x6c>
800022c0:	f0 1f 00 08 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
800022c4:	1a d3       	st.w	--sp,r3
800022c6:	48 cc       	lddpc	r12,800022f4 <Phyuserinput_brdcst_func+0x70>
800022c8:	f0 1f 00 06 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
800022cc:	1a d2       	st.w	--sp,r2
800022ce:	48 bc       	lddpc	r12,800022f8 <Phyuserinput_brdcst_func+0x74>
800022d0:	f0 1f 00 04 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
800022d4:	2f ad       	sub	sp,-24
	
	
	
	
	
}
800022d6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800022da:	00 00       	add	r0,r0
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	bc 5c       	st.h	lr[0xa],r12
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	59 c4       	cp.w	r4,28
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	bc 80       	st.b	lr[0x0],r0
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	bc 98       	st.b	lr[0x1],r8
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	bc ac       	st.b	lr[0x2],r12
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	bc c0       	st.b	lr[0x4],r0
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	bc d4       	st.b	lr[0x5],r4
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	bc f4       	st.b	lr[0x7],r4

800022fc <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022fc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002300:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002304:	0f 89       	ld.ub	r9,r7[0x0]
80002306:	30 08       	mov	r8,0
80002308:	f0 09 18 00 	cp.b	r9,r8
8000230c:	c0 c1       	brne	80002324 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000230e:	48 9c       	lddpc	r12,80002330 <ButtonConfig_reply_func+0x34>
80002310:	f0 1f 00 09 	mcall	80002334 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002314:	0f 98       	ld.ub	r8,r7[0x1]
80002316:	1a d8       	st.w	--sp,r8
80002318:	48 8c       	lddpc	r12,80002338 <ButtonConfig_reply_func+0x3c>
8000231a:	f0 1f 00 07 	mcall	80002334 <ButtonConfig_reply_func+0x38>
8000231e:	2f fd       	sub	sp,-4
80002320:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002324:	48 6c       	lddpc	r12,8000233c <ButtonConfig_reply_func+0x40>
80002326:	f0 1f 00 04 	mcall	80002334 <ButtonConfig_reply_func+0x38>
8000232a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000232e:	00 00       	add	r0,r0
80002330:	80 00       	ld.sh	r0,r0[0x0]
80002332:	bd 14       	ld.d	r4,--lr
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	59 c4       	cp.w	r4,28
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	bb 50       	asr	r0,0x1b
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	bd 2c       	st.d	lr++,r12

80002340 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002340:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002342:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
80002346:	0d 88       	ld.ub	r8,r6[0x0]
80002348:	32 49       	mov	r9,36
8000234a:	f2 08 18 00 	cp.b	r8,r9
8000234e:	c2 91       	brne	800023a0 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002350:	49 7c       	lddpc	r12,800023ac <DataSession_brdcst_func+0x6c>
80002352:	f0 1f 00 18 	mcall	800023b0 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002356:	0d a5       	ld.ub	r5,r6[0x2]
80002358:	0d b8       	ld.ub	r8,r6[0x3]
8000235a:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000235e:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002360:	0d 98       	ld.ub	r8,r6[0x1]
80002362:	1a d8       	st.w	--sp,r8
80002364:	49 4c       	lddpc	r12,800023b4 <DataSession_brdcst_func+0x74>
80002366:	f0 1f 00 13 	mcall	800023b0 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000236a:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000236e:	1a d8       	st.w	--sp,r8
80002370:	49 2c       	lddpc	r12,800023b8 <DataSession_brdcst_func+0x78>
80002372:	f0 1f 00 10 	mcall	800023b0 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
80002376:	2f ed       	sub	sp,-8
80002378:	58 05       	cp.w	r5,0
8000237a:	c1 80       	breq	800023aa <DataSession_brdcst_func+0x6a>
8000237c:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000237e:	49 04       	lddpc	r4,800023bc <DataSession_brdcst_func+0x7c>
80002380:	ec 07 00 08 	add	r8,r6,r7
80002384:	11 c8       	ld.ub	r8,r8[0x4]
80002386:	1a d8       	st.w	--sp,r8
80002388:	1a d7       	st.w	--sp,r7
8000238a:	08 9c       	mov	r12,r4
8000238c:	f0 1f 00 09 	mcall	800023b0 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002390:	2f f7       	sub	r7,-1
80002392:	5c 57       	castu.b	r7
80002394:	2f ed       	sub	sp,-8
80002396:	ee 05 19 00 	cp.h	r5,r7
8000239a:	fe 9b ff f3 	brhi	80002380 <DataSession_brdcst_func+0x40>
8000239e:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
800023a0:	1a d8       	st.w	--sp,r8
800023a2:	48 8c       	lddpc	r12,800023c0 <DataSession_brdcst_func+0x80>
800023a4:	f0 1f 00 03 	mcall	800023b0 <DataSession_brdcst_func+0x70>
800023a8:	2f fd       	sub	sp,-4
800023aa:	d8 22       	popm	r4-r7,pc
800023ac:	80 00       	ld.sh	r0,r0[0x0]
800023ae:	bd 48       	asr	r8,0x1c
800023b0:	80 00       	ld.sh	r0,r0[0x0]
800023b2:	59 c4       	cp.w	r4,28
800023b4:	80 00       	ld.sh	r0,r0[0x0]
800023b6:	bd 5c       	asr	r12,0x1d
800023b8:	80 00       	ld.sh	r0,r0[0x0]
800023ba:	bd 74       	lsl	r4,0x1d
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	bd 90       	lsr	r0,0x1d
800023c0:	80 00       	ld.sh	r0,r0[0x0]
800023c2:	bd a8       	sbr	r8,0x1c

800023c4 <DataSession_reply_func>:
	
}


void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800023c4:	eb cd 40 80 	pushm	r7,lr
800023c8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023ca:	19 a8       	ld.ub	r8,r12[0x2]
800023cc:	58 08       	cp.w	r8,0
800023ce:	c0 61       	brne	800023da <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
800023d0:	48 dc       	lddpc	r12,80002404 <DataSession_reply_func+0x40>
800023d2:	f0 1f 00 0e 	mcall	80002408 <DataSession_reply_func+0x44>
800023d6:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
800023da:	1a d8       	st.w	--sp,r8
800023dc:	48 cc       	lddpc	r12,8000240c <DataSession_reply_func+0x48>
800023de:	f0 1f 00 0b 	mcall	80002408 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
800023e2:	48 cc       	lddpc	r12,80002410 <DataSession_reply_func+0x4c>
800023e4:	f0 1f 00 09 	mcall	80002408 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
800023e8:	0f b8       	ld.ub	r8,r7[0x3]
800023ea:	1a d8       	st.w	--sp,r8
800023ec:	48 ac       	lddpc	r12,80002414 <DataSession_reply_func+0x50>
800023ee:	f0 1f 00 07 	mcall	80002408 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
800023f2:	0f c8       	ld.ub	r8,r7[0x4]
800023f4:	1a d8       	st.w	--sp,r8
800023f6:	48 9c       	lddpc	r12,80002418 <DataSession_reply_func+0x54>
800023f8:	f0 1f 00 04 	mcall	80002408 <DataSession_reply_func+0x44>
800023fc:	2f dd       	sub	sp,-12
800023fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002402:	00 00       	add	r0,r0
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	bd bc       	sbr	r12,0x1d
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	59 c4       	cp.w	r4,28
8000240c:	80 00       	ld.sh	r0,r0[0x0]
8000240e:	bd d0       	cbr	r0,0x1d
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	bd e4       	*unknown*
80002414:	80 00       	ld.sh	r0,r0[0x0]
80002416:	bd f8       	*unknown*
80002418:	80 00       	ld.sh	r0,r0[0x0]
8000241a:	be 08       	st.h	pc[0x0],r8

8000241c <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000241c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002420:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002424:	0f 99       	ld.ub	r9,r7[0x1]
80002426:	30 08       	mov	r8,0
80002428:	f0 09 18 00 	cp.b	r9,r8
8000242c:	c0 71       	brne	8000243a <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
8000242e:	48 ac       	lddpc	r12,80002454 <TransmitControl_brdcst_func+0x38>
80002430:	f0 1f 00 0a 	mcall	80002458 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002434:	30 09       	mov	r9,0
80002436:	48 a8       	lddpc	r8,8000245c <TransmitControl_brdcst_func+0x40>
80002438:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000243a:	0f 99       	ld.ub	r9,r7[0x1]
8000243c:	30 18       	mov	r8,1
8000243e:	f0 09 18 00 	cp.b	r9,r8
80002442:	c0 71       	brne	80002450 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002444:	48 7c       	lddpc	r12,80002460 <TransmitControl_brdcst_func+0x44>
80002446:	f0 1f 00 05 	mcall	80002458 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000244a:	30 19       	mov	r9,1
8000244c:	48 48       	lddpc	r8,8000245c <TransmitControl_brdcst_func+0x40>
8000244e:	b0 89       	st.b	r8[0x0],r9
80002450:	e3 cd 80 80 	ldm	sp++,r7,pc
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	be 18       	st.h	pc[0x2],r8
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	59 c4       	cp.w	r4,28
8000245c:	00 00       	add	r0,r0
8000245e:	0a 49       	or	r9,r5
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	be 30       	st.h	pc[0x6],r0

80002464 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002464:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002468:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000246c:	0f 89       	ld.ub	r9,r7[0x0]
8000246e:	30 08       	mov	r8,0
80002470:	f0 09 18 00 	cp.b	r9,r8
80002474:	c2 21       	brne	800024b8 <TransmitControl_reply_func+0x54>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002476:	49 4c       	lddpc	r12,800024c4 <TransmitControl_reply_func+0x60>
80002478:	f0 1f 00 14 	mcall	800024c8 <TransmitControl_reply_func+0x64>
		log("\n\r Function: %x \n\r", ptr->Function);
8000247c:	0f 98       	ld.ub	r8,r7[0x1]
8000247e:	1a d8       	st.w	--sp,r8
80002480:	49 3c       	lddpc	r12,800024cc <TransmitControl_reply_func+0x68>
80002482:	f0 1f 00 12 	mcall	800024c8 <TransmitControl_reply_func+0x64>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002486:	0f a8       	ld.ub	r8,r7[0x2]
80002488:	1a d8       	st.w	--sp,r8
8000248a:	49 2c       	lddpc	r12,800024d0 <TransmitControl_reply_func+0x6c>
8000248c:	f0 1f 00 0f 	mcall	800024c8 <TransmitControl_reply_func+0x64>
		log("\n\r State: %x \n\r", ptr->State);
80002490:	0f b8       	ld.ub	r8,r7[0x3]
80002492:	1a d8       	st.w	--sp,r8
80002494:	49 0c       	lddpc	r12,800024d4 <TransmitControl_reply_func+0x70>
80002496:	f0 1f 00 0d 	mcall	800024c8 <TransmitControl_reply_func+0x64>
		
		if (ptr->Function == KEY_UP)
8000249a:	0f 98       	ld.ub	r8,r7[0x1]
8000249c:	2f dd       	sub	sp,-12
8000249e:	30 19       	mov	r9,1
800024a0:	f2 08 18 00 	cp.b	r8,r9
800024a4:	c0 d0       	breq	800024be <TransmitControl_reply_func+0x5a>
		{
			//is_unmute = 1;
		}
		else if (ptr->Function ==DE_KEY)
800024a6:	30 29       	mov	r9,2
800024a8:	f2 08 18 00 	cp.b	r8,r9
800024ac:	c0 91       	brne	800024be <TransmitControl_reply_func+0x5a>
		{
			is_unmute = 0;
800024ae:	30 09       	mov	r9,0
800024b0:	48 a8       	lddpc	r8,800024d8 <TransmitControl_reply_func+0x74>
800024b2:	b0 89       	st.b	r8[0x0],r9
800024b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800024b8:	48 9c       	lddpc	r12,800024dc <TransmitControl_reply_func+0x78>
800024ba:	f0 1f 00 04 	mcall	800024c8 <TransmitControl_reply_func+0x64>
800024be:	e3 cd 80 80 	ldm	sp++,r7,pc
800024c2:	00 00       	add	r0,r0
800024c4:	80 00       	ld.sh	r0,r0[0x0]
800024c6:	be 44       	st.h	pc[0x8],r4
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	59 c4       	cp.w	r4,28
800024cc:	80 00       	ld.sh	r0,r0[0x0]
800024ce:	be 60       	st.h	pc[0xc],r0
800024d0:	80 00       	ld.sh	r0,r0[0x0]
800024d2:	be 74       	st.h	pc[0xe],r4
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	be 90       	st.b	pc[0x1],r0
800024d8:	00 00       	add	r0,r0
800024da:	0a 50       	eor	r0,r5
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	be a0       	st.b	pc[0x2],r0

800024e0 <AudioRoutingControl_brdcst_func>:
	}
}


void AudioRoutingControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024e0:	eb cd 40 f8 	pushm	r3-r7,lr
800024e4:	18 96       	mov	r6,r12
	
	U16 num_routings = 0;
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
800024e6:	19 a5       	ld.ub	r5,r12[0x2]
800024e8:	19 b8       	ld.ub	r8,r12[0x3]
800024ea:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800024ee:	5c 85       	casts.h	r5
	log("\n\r num_routings: %d \n\r", num_routings);
800024f0:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800024f4:	1a d8       	st.w	--sp,r8
800024f6:	49 6c       	lddpc	r12,8000254c <AudioRoutingControl_brdcst_func+0x6c>
800024f8:	f0 1f 00 16 	mcall	80002550 <AudioRoutingControl_brdcst_func+0x70>
	
	for(j = 0; j< num_routings ; j++ )
800024fc:	2f fd       	sub	sp,-4
800024fe:	58 05       	cp.w	r5,0
80002500:	c0 31       	brne	80002506 <AudioRoutingControl_brdcst_func+0x26>
80002502:	30 07       	mov	r7,0
80002504:	c1 98       	rjmp	80002536 <AudioRoutingControl_brdcst_func+0x56>
80002506:	30 07       	mov	r7,0
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
80002508:	49 34       	lddpc	r4,80002554 <AudioRoutingControl_brdcst_func+0x74>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
8000250a:	49 43       	lddpc	r3,80002558 <AudioRoutingControl_brdcst_func+0x78>
	
	for(j = 0; j< num_routings ; j++ )
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
8000250c:	ec 07 00 18 	add	r8,r6,r7<<0x1
80002510:	11 c8       	ld.ub	r8,r8[0x4]
80002512:	1a d8       	st.w	--sp,r8
80002514:	08 9c       	mov	r12,r4
80002516:	f0 1f 00 0f 	mcall	80002550 <AudioRoutingControl_brdcst_func+0x70>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
8000251a:	ec 07 00 18 	add	r8,r6,r7<<0x1
8000251e:	11 d8       	ld.ub	r8,r8[0x5]
80002520:	1a d8       	st.w	--sp,r8
80002522:	06 9c       	mov	r12,r3
80002524:	f0 1f 00 0b 	mcall	80002550 <AudioRoutingControl_brdcst_func+0x70>
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
	log("\n\r num_routings: %d \n\r", num_routings);
	
	for(j = 0; j< num_routings ; j++ )
80002528:	2f f7       	sub	r7,-1
8000252a:	5c 57       	castu.b	r7
8000252c:	2f ed       	sub	sp,-8
8000252e:	ee 05 19 00 	cp.h	r5,r7
80002532:	fe 9b ff ed 	brhi	8000250c <AudioRoutingControl_brdcst_func+0x2c>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
		
		
	}
	
	log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
80002536:	ec 07 00 17 	add	r7,r6,r7<<0x1
8000253a:	0f c8       	ld.ub	r8,r7[0x4]
8000253c:	1a d8       	st.w	--sp,r8
8000253e:	48 8c       	lddpc	r12,8000255c <AudioRoutingControl_brdcst_func+0x7c>
80002540:	f0 1f 00 04 	mcall	80002550 <AudioRoutingControl_brdcst_func+0x70>
80002544:	2f fd       	sub	sp,-4
	
	
	
}
80002546:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000254a:	00 00       	add	r0,r0
8000254c:	80 00       	ld.sh	r0,r0[0x0]
8000254e:	be b8       	st.b	pc[0x3],r8
80002550:	80 00       	ld.sh	r0,r0[0x0]
80002552:	59 c4       	cp.w	r4,28
80002554:	80 00       	ld.sh	r0,r0[0x0]
80002556:	be d0       	st.b	pc[0x5],r0
80002558:	80 00       	ld.sh	r0,r0[0x0]
8000255a:	be e8       	st.b	pc[0x6],r8
8000255c:	80 00       	ld.sh	r0,r0[0x0]
8000255e:	bf 00       	ld.d	r0,pc

80002560 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002560:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002564:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002568:	0f 89       	ld.ub	r9,r7[0x0]
8000256a:	30 08       	mov	r8,0
8000256c:	f0 09 18 00 	cp.b	r9,r8
80002570:	c1 b1       	brne	800025a6 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002572:	0f b8       	ld.ub	r8,r7[0x3]
80002574:	31 09       	mov	r9,16
80002576:	f2 08 18 00 	cp.b	r8,r9
8000257a:	c0 f1       	brne	80002598 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
8000257c:	48 dc       	lddpc	r12,800025b0 <Volume_reply_func+0x50>
8000257e:	f0 1f 00 0e 	mcall	800025b4 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002582:	0f 99       	ld.ub	r9,r7[0x1]
80002584:	0f a8       	ld.ub	r8,r7[0x2]
80002586:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000258a:	1a d8       	st.w	--sp,r8
8000258c:	48 bc       	lddpc	r12,800025b8 <Volume_reply_func+0x58>
8000258e:	f0 1f 00 0a 	mcall	800025b4 <Volume_reply_func+0x54>
80002592:	2f fd       	sub	sp,-4
80002594:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002598:	1a d8       	st.w	--sp,r8
8000259a:	48 9c       	lddpc	r12,800025bc <Volume_reply_func+0x5c>
8000259c:	f0 1f 00 06 	mcall	800025b4 <Volume_reply_func+0x54>
800025a0:	2f fd       	sub	sp,-4
800025a2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025a6:	48 7c       	lddpc	r12,800025c0 <Volume_reply_func+0x60>
800025a8:	f0 1f 00 03 	mcall	800025b4 <Volume_reply_func+0x54>
800025ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800025b0:	80 00       	ld.sh	r0,r0[0x0]
800025b2:	bf 1c       	ld.d	r12,--pc
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	59 c4       	cp.w	r4,28
800025b8:	80 00       	ld.sh	r0,r0[0x0]
800025ba:	bf 30       	mul	r0,pc
800025bc:	80 00       	ld.sh	r0,r0[0x0]
800025be:	bf 4c       	asr	r12,0x1e
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	bf 64       	lsl	r4,0x1e

800025c4 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025c4:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025c6:	19 d9       	ld.ub	r9,r12[0x5]
800025c8:	30 08       	mov	r8,0
800025ca:	f0 09 18 00 	cp.b	r9,r8
800025ce:	c0 51       	brne	800025d8 <spk_brdcst_func+0x14>
	{
		//is_unmute =0;
		//Silent_flag = 0;
		log("spk_s_close ");
800025d0:	48 4c       	lddpc	r12,800025e0 <spk_brdcst_func+0x1c>
800025d2:	f0 1f 00 05 	mcall	800025e4 <spk_brdcst_func+0x20>
800025d6:	d8 02       	popm	pc
	}
	else
	{
		//Silent_flag = 1;
		//is_unmute = 1;
		log("spk_s_open ");
800025d8:	48 4c       	lddpc	r12,800025e8 <spk_brdcst_func+0x24>
800025da:	f0 1f 00 03 	mcall	800025e4 <spk_brdcst_func+0x20>
800025de:	d8 02       	popm	pc
800025e0:	80 00       	ld.sh	r0,r0[0x0]
800025e2:	bf 7c       	lsl	r12,0x1f
800025e4:	80 00       	ld.sh	r0,r0[0x0]
800025e6:	59 c4       	cp.w	r4,28
800025e8:	80 00       	ld.sh	r0,r0[0x0]
800025ea:	bf 8c       	lsr	r12,0x1e

800025ec <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800025ec:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025ee:	19 a9       	ld.ub	r9,r12[0x2]
800025f0:	30 08       	mov	r8,0
800025f2:	f0 09 18 00 	cp.b	r9,r8
800025f6:	c0 81       	brne	80002606 <spk_reply_func+0x1a>
		{
			//is_unmute = 1;
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800025f8:	19 e8       	ld.ub	r8,r12[0x6]
800025fa:	1a d8       	st.w	--sp,r8
800025fc:	48 5c       	lddpc	r12,80002610 <spk_reply_func+0x24>
800025fe:	f0 1f 00 06 	mcall	80002614 <spk_reply_func+0x28>
80002602:	2f fd       	sub	sp,-4
80002604:	d8 02       	popm	pc
		
	}
	else
	{
		log("spk error");
80002606:	48 5c       	lddpc	r12,80002618 <spk_reply_func+0x2c>
80002608:	f0 1f 00 03 	mcall	80002614 <spk_reply_func+0x28>
8000260c:	d8 02       	popm	pc
8000260e:	00 00       	add	r0,r0
80002610:	80 00       	ld.sh	r0,r0[0x0]
80002612:	bf 98       	lsr	r8,0x1f
80002614:	80 00       	ld.sh	r0,r0[0x0]
80002616:	59 c4       	cp.w	r4,28
80002618:	80 00       	ld.sh	r0,r0[0x0]
8000261a:	bf a8       	sbr	r8,0x1e

8000261c <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
8000261c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002620:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002624:	0f a9       	ld.ub	r9,r7[0x2]
80002626:	30 08       	mov	r8,0
80002628:	f0 09 18 00 	cp.b	r9,r8
8000262c:	c0 71       	brne	8000263a <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000262e:	48 ac       	lddpc	r12,80002654 <mic_brdcst_func+0x38>
80002630:	f0 1f 00 0a 	mcall	80002658 <mic_brdcst_func+0x3c>
		Mic_is_Enabled = 0;
80002634:	30 09       	mov	r9,0
80002636:	48 a8       	lddpc	r8,8000265c <mic_brdcst_func+0x40>
80002638:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
8000263a:	0f a9       	ld.ub	r9,r7[0x2]
8000263c:	31 18       	mov	r8,17
8000263e:	f0 09 18 00 	cp.b	r9,r8
80002642:	c0 71       	brne	80002650 <mic_brdcst_func+0x34>
	{
		log("\n\r Mic_Enabled \n\r");	
80002644:	48 7c       	lddpc	r12,80002660 <mic_brdcst_func+0x44>
80002646:	f0 1f 00 05 	mcall	80002658 <mic_brdcst_func+0x3c>
		Mic_is_Enabled = 1;
8000264a:	30 19       	mov	r9,1
8000264c:	48 48       	lddpc	r8,8000265c <mic_brdcst_func+0x40>
8000264e:	b0 89       	st.b	r8[0x0],r9
80002650:	e3 cd 80 80 	ldm	sp++,r7,pc
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	bf b4       	sbr	r4,0x1f
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	59 c4       	cp.w	r4,28
8000265c:	00 00       	add	r0,r0
8000265e:	0a 51       	eor	r1,r5
80002660:	80 00       	ld.sh	r0,r0[0x0]
80002662:	bf c8       	cbr	r8,0x1e

80002664 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002664:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002668:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
8000266c:	49 ac       	lddpc	r12,800026d4 <mic_reply_func+0x70>
8000266e:	f0 1f 00 1b 	mcall	800026d8 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
80002672:	0f 89       	ld.ub	r9,r7[0x0]
80002674:	30 08       	mov	r8,0
80002676:	f0 09 18 00 	cp.b	r9,r8
8000267a:	c2 71       	brne	800026c8 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
8000267c:	0f 98       	ld.ub	r8,r7[0x1]
8000267e:	30 29       	mov	r9,2
80002680:	f2 08 18 00 	cp.b	r8,r9
80002684:	c1 b1       	brne	800026ba <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002686:	49 6c       	lddpc	r12,800026dc <mic_reply_func+0x78>
80002688:	f0 1f 00 14 	mcall	800026d8 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
8000268c:	0f a8       	ld.ub	r8,r7[0x2]
8000268e:	1a d8       	st.w	--sp,r8
80002690:	49 4c       	lddpc	r12,800026e0 <mic_reply_func+0x7c>
80002692:	f0 1f 00 12 	mcall	800026d8 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002696:	0f b8       	ld.ub	r8,r7[0x3]
80002698:	1a d8       	st.w	--sp,r8
8000269a:	49 3c       	lddpc	r12,800026e4 <mic_reply_func+0x80>
8000269c:	f0 1f 00 0f 	mcall	800026d8 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800026a0:	0f c8       	ld.ub	r8,r7[0x4]
800026a2:	1a d8       	st.w	--sp,r8
800026a4:	49 1c       	lddpc	r12,800026e8 <mic_reply_func+0x84>
800026a6:	f0 1f 00 0d 	mcall	800026d8 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800026aa:	0f d8       	ld.ub	r8,r7[0x5]
800026ac:	1a d8       	st.w	--sp,r8
800026ae:	49 0c       	lddpc	r12,800026ec <mic_reply_func+0x88>
800026b0:	f0 1f 00 0a 	mcall	800026d8 <mic_reply_func+0x74>
800026b4:	2f cd       	sub	sp,-16
800026b6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026ba:	1a d8       	st.w	--sp,r8
800026bc:	48 dc       	lddpc	r12,800026f0 <mic_reply_func+0x8c>
800026be:	f0 1f 00 07 	mcall	800026d8 <mic_reply_func+0x74>
800026c2:	2f fd       	sub	sp,-4
800026c4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026c8:	48 bc       	lddpc	r12,800026f4 <mic_reply_func+0x90>
800026ca:	f0 1f 00 04 	mcall	800026d8 <mic_reply_func+0x74>
800026ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800026d2:	00 00       	add	r0,r0
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	bf dc       	cbr	r12,0x1f
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	59 c4       	cp.w	r4,28
800026dc:	80 00       	ld.sh	r0,r0[0x0]
800026de:	bf ec       	*unknown*
800026e0:	80 00       	ld.sh	r0,r0[0x0]
800026e2:	c0 00       	breq	800026e2 <mic_reply_func+0x7e>
800026e4:	80 00       	ld.sh	r0,r0[0x0]
800026e6:	c0 14       	brge	800026e8 <mic_reply_func+0x84>
800026e8:	80 00       	ld.sh	r0,r0[0x0]
800026ea:	c0 30       	breq	800026f0 <mic_reply_func+0x8c>
800026ec:	80 00       	ld.sh	r0,r0[0x0]
800026ee:	c0 48       	rjmp	800026f6 <mic_reply_func+0x92>
800026f0:	80 00       	ld.sh	r0,r0[0x0]
800026f2:	c0 60       	breq	800026fe <dcm_brdcst_func+0x6>
800026f4:	80 00       	ld.sh	r0,r0[0x0]
800026f6:	c0 78       	rjmp	80002704 <dcm_brdcst_func+0xc>

800026f8 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026f8:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026fc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002700:	48 bc       	lddpc	r12,8000272c <dcm_brdcst_func+0x34>
80002702:	f0 1f 00 0c 	mcall	80002730 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002706:	0f 88       	ld.ub	r8,r7[0x0]
80002708:	1a d8       	st.w	--sp,r8
8000270a:	48 bc       	lddpc	r12,80002734 <dcm_brdcst_func+0x3c>
8000270c:	f0 1f 00 09 	mcall	80002730 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002710:	0f a8       	ld.ub	r8,r7[0x2]
80002712:	1a d8       	st.w	--sp,r8
80002714:	48 9c       	lddpc	r12,80002738 <dcm_brdcst_func+0x40>
80002716:	f0 1f 00 07 	mcall	80002730 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000271a:	0f 98       	ld.ub	r8,r7[0x1]
8000271c:	1a d8       	st.w	--sp,r8
8000271e:	48 8c       	lddpc	r12,8000273c <dcm_brdcst_func+0x44>
80002720:	f0 1f 00 04 	mcall	80002730 <dcm_brdcst_func+0x38>
80002724:	2f dd       	sub	sp,-12
	
	
}
80002726:	e3 cd 80 80 	ldm	sp++,r7,pc
8000272a:	00 00       	add	r0,r0
8000272c:	80 00       	ld.sh	r0,r0[0x0]
8000272e:	c0 88       	rjmp	8000273e <dcm_brdcst_func+0x46>
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	59 c4       	cp.w	r4,28
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	c0 9c       	rcall	80002748 <dcm_reply_func+0x8>
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	c0 b0       	breq	80002750 <dcm_reply_func+0x10>
8000273c:	80 00       	ld.sh	r0,r0[0x0]
8000273e:	c0 c8       	rjmp	80002756 <dcm_reply_func+0x16>

80002740 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002740:	eb cd 40 80 	pushm	r7,lr
80002744:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002746:	19 a9       	ld.ub	r9,r12[0x2]
80002748:	30 08       	mov	r8,0
8000274a:	f0 09 18 00 	cp.b	r9,r8
8000274e:	c1 b1       	brne	80002784 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002750:	19 b8       	ld.ub	r8,r12[0x3]
80002752:	30 19       	mov	r9,1
80002754:	f2 08 18 00 	cp.b	r8,r9
80002758:	c0 51       	brne	80002762 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
8000275a:	48 ec       	lddpc	r12,80002790 <dcm_reply_func+0x50>
8000275c:	f0 1f 00 0e 	mcall	80002794 <dcm_reply_func+0x54>
80002760:	c0 a8       	rjmp	80002774 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
80002762:	58 08       	cp.w	r8,0
80002764:	c0 51       	brne	8000276e <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002766:	48 dc       	lddpc	r12,80002798 <dcm_reply_func+0x58>
80002768:	f0 1f 00 0b 	mcall	80002794 <dcm_reply_func+0x54>
8000276c:	c0 48       	rjmp	80002774 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000276e:	48 cc       	lddpc	r12,8000279c <dcm_reply_func+0x5c>
80002770:	f0 1f 00 09 	mcall	80002794 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002774:	0f d8       	ld.ub	r8,r7[0x5]
80002776:	1a d8       	st.w	--sp,r8
80002778:	48 ac       	lddpc	r12,800027a0 <dcm_reply_func+0x60>
8000277a:	f0 1f 00 07 	mcall	80002794 <dcm_reply_func+0x54>
8000277e:	2f fd       	sub	sp,-4
80002780:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002784:	48 8c       	lddpc	r12,800027a4 <dcm_reply_func+0x64>
80002786:	f0 1f 00 04 	mcall	80002794 <dcm_reply_func+0x54>
8000278a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000278e:	00 00       	add	r0,r0
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	c0 e4       	brge	800027ae <ToneControl_reply_func+0x6>
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	59 c4       	cp.w	r4,28
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	c0 f8       	rjmp	800027b8 <ToneControl_reply_func+0x10>
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	c1 0c       	rcall	800027be <ToneControl_reply_func+0x16>
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	c1 20       	breq	800027c6 <ToneControl_reply_func+0x1e>
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	c1 2c       	rcall	800027ca <ToneControl_reply_func+0x22>

800027a8 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800027a8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800027aa:	19 a9       	ld.ub	r9,r12[0x2]
800027ac:	30 08       	mov	r8,0
800027ae:	f0 09 18 00 	cp.b	r9,r8
800027b2:	c0 51       	brne	800027bc <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
800027b4:	48 4c       	lddpc	r12,800027c4 <ToneControl_reply_func+0x1c>
800027b6:	f0 1f 00 05 	mcall	800027c8 <ToneControl_reply_func+0x20>
800027ba:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027bc:	48 4c       	lddpc	r12,800027cc <ToneControl_reply_func+0x24>
800027be:	f0 1f 00 03 	mcall	800027c8 <ToneControl_reply_func+0x20>
800027c2:	d8 02       	popm	pc
800027c4:	80 00       	ld.sh	r0,r0[0x0]
800027c6:	c1 38       	rjmp	800027ec <app_cfg+0x1c>
800027c8:	80 00       	ld.sh	r0,r0[0x0]
800027ca:	59 c4       	cp.w	r4,28
800027cc:	80 00       	ld.sh	r0,r0[0x0]
800027ce:	c1 40       	breq	800027f6 <app_cfg+0x26>

800027d0 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
800027d0:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
800027d2:	f0 1f 00 22 	mcall	80002858 <app_cfg+0x88>
800027d6:	4a 28       	lddpc	r8,8000285c <app_cfg+0x8c>
800027d8:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800027da:	4a 27       	lddpc	r7,80002860 <app_cfg+0x90>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800027dc:	4a 26       	lddpc	r6,80002864 <app_cfg+0x94>
				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				//log("\n\r un: %d \n\r", is_unmute);
				//log("\n\r S_flag: %d \n\r", Silent_flag);
				//log("\n\r Tend_flag: %d \n\r", Terminator_Flag);
				
				log("\n\r Tone_flag: %d \n\r", Tone_flag);
800027de:	4a 35       	lddpc	r5,80002868 <app_cfg+0x98>
800027e0:	4a 34       	lddpc	r4,8000286c <app_cfg+0x9c>
				log("\n\r Terminator_Flag: %d \n\r", Terminator_Flag);
800027e2:	4a 43       	lddpc	r3,80002870 <app_cfg+0xa0>
800027e4:	4a 42       	lddpc	r2,80002874 <app_cfg+0xa4>
				//Terminator_Flag
				//log("\n\r Tone_counters: %d \n\r", Tone_Counters);
				log("\n\r Silent_flag: %d \n\r", Silent_flag);
800027e6:	4a 51       	lddpc	r1,80002878 <app_cfg+0xa8>
800027e8:	4a 50       	lddpc	r0,8000287c <app_cfg+0xac>
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800027ea:	6e 08       	ld.w	r8,r7[0x0]
800027ec:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027f0:	58 38       	cp.w	r8,3
800027f2:	c2 c1       	brne	8000284a <app_cfg+0x7a>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800027f4:	6c 08       	ld.w	r8,r6[0x0]
800027f6:	58 08       	cp.w	r8,0
800027f8:	c0 61       	brne	80002804 <app_cfg+0x34>
				{
					//xcmp_data_session();
					//xcmp_audio_route_mic();
					//xcmp_button_config();
					xcmp_audio_route_speaker();
800027fa:	f0 1f 00 22 	mcall	80002880 <app_cfg+0xb0>
					//xcmp_enter_device_control_mode();//3
					//xcmp_unmute_speaker();
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027fe:	30 18       	mov	r8,1
80002800:	8d 08       	st.w	r6[0x0],r8
80002802:	c1 48       	rjmp	8000282a <app_cfg+0x5a>
				}
				else if(isAudioRouting == 1)
80002804:	58 18       	cp.w	r8,1
80002806:	c0 41       	brne	8000280e <app_cfg+0x3e>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
80002808:	30 28       	mov	r8,2
8000280a:	8d 08       	st.w	r6[0x0],r8
8000280c:	c0 f8       	rjmp	8000282a <app_cfg+0x5a>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
8000280e:	58 28       	cp.w	r8,2
80002810:	c0 41       	brne	80002818 <app_cfg+0x48>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
80002812:	30 38       	mov	r8,3
80002814:	8d 08       	st.w	r6[0x0],r8
80002816:	c0 a8       	rjmp	8000282a <app_cfg+0x5a>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
80002818:	58 38       	cp.w	r8,3
8000281a:	f9 b8 00 04 	moveq	r8,4
8000281e:	ed f8 0a 00 	st.weq	r6[0x0],r8
					
				}
				else
				{
					isAudioRouting++;
80002822:	f7 b8 01 ff 	subne	r8,-1
80002826:	ed f8 1a 00 	st.wne	r6[0x0],r8
				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				//log("\n\r un: %d \n\r", is_unmute);
				//log("\n\r S_flag: %d \n\r", Silent_flag);
				//log("\n\r Tend_flag: %d \n\r", Terminator_Flag);
				
				log("\n\r Tone_flag: %d \n\r", Tone_flag);
8000282a:	0b 88       	ld.ub	r8,r5[0x0]
8000282c:	1a d8       	st.w	--sp,r8
8000282e:	08 9c       	mov	r12,r4
80002830:	f0 1f 00 15 	mcall	80002884 <app_cfg+0xb4>
				log("\n\r Terminator_Flag: %d \n\r", Terminator_Flag);
80002834:	05 88       	ld.ub	r8,r2[0x0]
80002836:	1a d8       	st.w	--sp,r8
80002838:	06 9c       	mov	r12,r3
8000283a:	f0 1f 00 13 	mcall	80002884 <app_cfg+0xb4>
				//Terminator_Flag
				//log("\n\r Tone_counters: %d \n\r", Tone_Counters);
				log("\n\r Silent_flag: %d \n\r", Silent_flag);
8000283e:	03 88       	ld.ub	r8,r1[0x0]
80002840:	1a d8       	st.w	--sp,r8
80002842:	00 9c       	mov	r12,r0
80002844:	f0 1f 00 10 	mcall	80002884 <app_cfg+0xb4>
80002848:	2f dd       	sub	sp,-12
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//2000ms
8000284a:	e0 6b 0f a0 	mov	r11,4000
8000284e:	48 4c       	lddpc	r12,8000285c <app_cfg+0x8c>
80002850:	f0 1f 00 0e 	mcall	80002888 <app_cfg+0xb8>
	}
80002854:	cc bb       	rjmp	800027ea <app_cfg+0x1a>
80002856:	00 00       	add	r0,r0
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	53 38       	stdsp	sp[0xcc],r8
8000285c:	00 00       	add	r0,r0
8000285e:	0a 40       	or	r0,r5
80002860:	00 00       	add	r0,r0
80002862:	0d 8c       	ld.ub	r12,r6[0x0]
80002864:	00 00       	add	r0,r0
80002866:	0a 54       	eor	r4,r5
80002868:	00 00       	add	r0,r0
8000286a:	0a 4b       	or	r11,r5
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	c1 4c       	rcall	80002896 <app_payload_rx_proc+0xa>
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	c1 60       	breq	8000289e <app_payload_rx_proc+0x12>
80002874:	00 00       	add	r0,r0
80002876:	0a 5a       	eor	r10,r5
80002878:	00 00       	add	r0,r0
8000287a:	0a 59       	eor	r9,r5
8000287c:	80 00       	ld.sh	r0,r0[0x0]
8000287e:	c1 7c       	rcall	800028ac <app_payload_rx_proc+0x20>
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	36 a4       	mov	r4,106
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	59 c4       	cp.w	r4,28
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	54 a0       	stdsp	sp[0x128],r0

8000288c <app_payload_rx_proc>:
}


static void app_payload_rx_proc(void  * payload)
{
8000288c:	eb cd 40 80 	pushm	r7,lr
80002890:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
80002892:	48 b9       	lddpc	r9,800028bc <app_payload_rx_proc+0x30>
80002894:	13 88       	ld.ub	r8,r9[0x0]
80002896:	2f f8       	sub	r8,-1
80002898:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 30)
8000289a:	31 e9       	mov	r9,30
8000289c:	f2 08 18 00 	cp.b	r8,r9
800028a0:	c0 71       	brne	800028ae <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
800028a2:	30 09       	mov	r9,0
800028a4:	48 68       	lddpc	r8,800028bc <app_payload_rx_proc+0x30>
800028a6:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800028a8:	48 6c       	lddpc	r12,800028c0 <app_payload_rx_proc+0x34>
800028aa:	f0 1f 00 07 	mcall	800028c4 <app_payload_rx_proc+0x38>
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
800028ae:	48 78       	lddpc	r8,800028c8 <app_payload_rx_proc+0x3c>
800028b0:	70 0c       	ld.w	r12,r8[0x0]
800028b2:	0e 9b       	mov	r11,r7
800028b4:	f0 1f 00 06 	mcall	800028cc <app_payload_rx_proc+0x40>

}
800028b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800028bc:	00 00       	add	r0,r0
800028be:	0a 58       	eor	r8,r5
800028c0:	80 00       	ld.sh	r0,r0[0x0]
800028c2:	c1 94       	brge	800028f4 <AudioRoutingControl_reply_func+0x24>
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	59 c4       	cp.w	r4,28
800028c8:	00 00       	add	r0,r0
800028ca:	0a 74       	tst	r4,r5
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	2a 30       	sub	r0,-93

800028d0 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800028d0:	eb cd 40 80 	pushm	r7,lr
800028d4:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800028d6:	19 a9       	ld.ub	r9,r12[0x2]
800028d8:	30 08       	mov	r8,0
800028da:	f0 09 18 00 	cp.b	r9,r8
800028de:	c0 c1       	brne	800028f6 <AudioRoutingControl_reply_func+0x26>
	{
		log("AudioRouting OK");
800028e0:	48 bc       	lddpc	r12,8000290c <AudioRoutingControl_reply_func+0x3c>
800028e2:	f0 1f 00 0c 	mcall	80002910 <AudioRoutingControl_reply_func+0x40>
		xcmp_IdleTestTone();//
800028e6:	f0 1f 00 0c 	mcall	80002914 <AudioRoutingControl_reply_func+0x44>
		xcmp_IdleTestTone();
800028ea:	f0 1f 00 0b 	mcall	80002914 <AudioRoutingControl_reply_func+0x44>
		xcmp_IdleTestTone();
800028ee:	f0 1f 00 0a 	mcall	80002914 <AudioRoutingControl_reply_func+0x44>
800028f2:	e3 cd 80 80 	ldm	sp++,r7,pc
		//is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
800028f6:	48 9c       	lddpc	r12,80002918 <AudioRoutingControl_reply_func+0x48>
800028f8:	f0 1f 00 06 	mcall	80002910 <AudioRoutingControl_reply_func+0x40>
		log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
800028fc:	0f a8       	ld.ub	r8,r7[0x2]
800028fe:	1a d8       	st.w	--sp,r8
80002900:	48 7c       	lddpc	r12,8000291c <AudioRoutingControl_reply_func+0x4c>
80002902:	f0 1f 00 04 	mcall	80002910 <AudioRoutingControl_reply_func+0x40>
80002906:	2f fd       	sub	sp,-4
80002908:	e3 cd 80 80 	ldm	sp++,r7,pc
8000290c:	80 00       	ld.sh	r0,r0[0x0]
8000290e:	c1 a0       	breq	80002942 <DeviceInitializationStatus_brdcst_func+0x22>
80002910:	80 00       	ld.sh	r0,r0[0x0]
80002912:	59 c4       	cp.w	r4,28
80002914:	80 00       	ld.sh	r0,r0[0x0]
80002916:	37 98       	mov	r8,121
80002918:	80 00       	ld.sh	r0,r0[0x0]
8000291a:	c1 b0       	breq	80002950 <DeviceInitializationStatus_brdcst_func+0x30>
8000291c:	80 00       	ld.sh	r0,r0[0x0]
8000291e:	c1 c4       	brge	80002956 <DeviceInitializationStatus_brdcst_func+0x36>

80002920 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002920:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002922:	19 e8       	ld.ub	r8,r12[0x6]
80002924:	30 19       	mov	r9,1
80002926:	f2 08 18 00 	cp.b	r8,r9
8000292a:	c0 61       	brne	80002936 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
8000292c:	48 98       	lddpc	r8,80002950 <DeviceInitializationStatus_brdcst_func+0x30>
8000292e:	70 09       	ld.w	r9,r8[0x0]
80002930:	a1 a9       	sbr	r9,0x0
80002932:	91 09       	st.w	r8[0x0],r9
80002934:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002936:	30 29       	mov	r9,2
80002938:	f2 08 18 00 	cp.b	r8,r9
8000293c:	c0 80       	breq	8000294c <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
8000293e:	48 58       	lddpc	r8,80002950 <DeviceInitializationStatus_brdcst_func+0x30>
80002940:	70 09       	ld.w	r9,r8[0x0]
80002942:	e0 19 ff fc 	andl	r9,0xfffc
80002946:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002948:	f0 1f 00 03 	mcall	80002954 <DeviceInitializationStatus_brdcst_func+0x34>
8000294c:	d8 02       	popm	pc
8000294e:	00 00       	add	r0,r0
80002950:	00 00       	add	r0,r0
80002952:	0d 8c       	ld.ub	r12,r6[0x0]
80002954:	80 00       	ld.sh	r0,r0[0x0]
80002956:	36 ec       	mov	r12,110

80002958 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80002958:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
8000295a:	48 98       	lddpc	r8,8000297c <payload_init+0x24>
8000295c:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
8000295e:	48 98       	lddpc	r8,80002980 <payload_init+0x28>
80002960:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002962:	30 09       	mov	r9,0
80002964:	1a d9       	st.w	--sp,r9
80002966:	1a d9       	st.w	--sp,r9
80002968:	1a d9       	st.w	--sp,r9
8000296a:	30 28       	mov	r8,2
8000296c:	e0 6a 04 00 	mov	r10,1024
80002970:	48 5b       	lddpc	r11,80002984 <payload_init+0x2c>
80002972:	48 6c       	lddpc	r12,80002988 <payload_init+0x30>
80002974:	f0 1f 00 06 	mcall	8000298c <payload_init+0x34>
80002978:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
8000297a:	d8 02       	popm	pc
8000297c:	00 00       	add	r0,r0
8000297e:	0a 60       	and	r0,r5
80002980:	00 00       	add	r0,r0
80002982:	0a 64       	and	r4,r5
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	c1 e4       	brge	800029c2 <payload_rx_process+0x32>
80002988:	80 00       	ld.sh	r0,r0[0x0]
8000298a:	29 90       	sub	r0,-103
8000298c:	80 00       	ld.sh	r0,r0[0x0]
8000298e:	56 00       	stdsp	sp[0x180],r0

80002990 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002990:	eb cd 40 f8 	pushm	r3-r7,lr
80002994:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002996:	48 e8       	lddpc	r8,800029cc <payload_rx_process+0x3c>
80002998:	70 08       	ld.w	r8,r8[0x0]
8000299a:	58 08       	cp.w	r8,0
8000299c:	c0 71       	brne	800029aa <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000299e:	30 4b       	mov	r11,4
800029a0:	30 5c       	mov	r12,5
800029a2:	f0 1f 00 0c 	mcall	800029d0 <payload_rx_process+0x40>
800029a6:	48 a8       	lddpc	r8,800029cc <payload_rx_process+0x3c>
800029a8:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
800029aa:	48 96       	lddpc	r6,800029cc <payload_rx_process+0x3c>
800029ac:	30 05       	mov	r5,0
800029ae:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
800029b0:	48 93       	lddpc	r3,800029d4 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
800029b2:	6c 0c       	ld.w	r12,r6[0x0]
800029b4:	0a 99       	mov	r9,r5
800029b6:	08 9a       	mov	r10,r4
800029b8:	1a 9b       	mov	r11,sp
800029ba:	f0 1f 00 08 	mcall	800029d8 <payload_rx_process+0x48>
800029be:	58 1c       	cp.w	r12,1
800029c0:	cf 91       	brne	800029b2 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
800029c2:	66 08       	ld.w	r8,r3[0x0]
800029c4:	40 0c       	lddsp	r12,sp[0x0]
800029c6:	5d 18       	icall	r8
800029c8:	cf 5b       	rjmp	800029b2 <payload_rx_process+0x22>
800029ca:	00 00       	add	r0,r0
800029cc:	00 00       	add	r0,r0
800029ce:	0a 78       	tst	r8,r5
800029d0:	80 00       	ld.sh	r0,r0[0x0]
800029d2:	4f 2c       	lddpc	r12,80002b98 <phy_tx_func+0xc4>
800029d4:	00 00       	add	r0,r0
800029d6:	0a 60       	and	r0,r5
800029d8:	80 00       	ld.sh	r0,r0[0x0]
800029da:	4b c8       	lddpc	r8,80002ac8 <get_idle_store_isr+0x1c>

800029dc <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
800029dc:	d4 01       	pushm	lr
800029de:	20 2d       	sub	sp,8
800029e0:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800029e2:	30 09       	mov	r9,0
800029e4:	fa ca ff f8 	sub	r10,sp,-8
800029e8:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
800029ea:	1a 9b       	mov	r11,sp
800029ec:	f0 1f 00 02 	mcall	800029f4 <set_idle_store_isr+0x18>
}
800029f0:	2f ed       	sub	sp,-8
800029f2:	d8 02       	popm	pc
800029f4:	80 00       	ld.sh	r0,r0[0x0]
800029f6:	4d 84       	lddpc	r4,80002b54 <phy_tx_func+0x80>

800029f8 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
800029f8:	d4 01       	pushm	lr
800029fa:	20 2d       	sub	sp,8
800029fc:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
800029fe:	58 0c       	cp.w	r12,0
80002a00:	c1 10       	breq	80002a22 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a02:	30 08       	mov	r8,0
80002a04:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002a06:	98 88       	ld.uh	r8,r12[0x0]
80002a08:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a0c:	e0 48 40 00 	cp.w	r8,16384
80002a10:	c0 91       	brne	80002a22 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002a12:	48 68       	lddpc	r8,80002a28 <phy_rx+0x30>
80002a14:	70 0c       	ld.w	r12,r8[0x0]
80002a16:	30 09       	mov	r9,0
80002a18:	fa ca ff fc 	sub	r10,sp,-4
80002a1c:	1a 9b       	mov	r11,sp
80002a1e:	f0 1f 00 04 	mcall	80002a2c <phy_rx+0x34>
		}	

    }
		
 
}
80002a22:	2f ed       	sub	sp,-8
80002a24:	d8 02       	popm	pc
80002a26:	00 00       	add	r0,r0
80002a28:	00 00       	add	r0,r0
80002a2a:	0a ac       	st.w	r5++,r12
80002a2c:	80 00       	ld.sh	r0,r0[0x0]
80002a2e:	4d 84       	lddpc	r4,80002b8c <phy_tx_func+0xb8>

80002a30 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002a30:	eb cd 40 80 	pushm	r7,lr
80002a34:	20 1d       	sub	sp,4
80002a36:	fa c7 ff fc 	sub	r7,sp,-4
80002a3a:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002a3c:	30 09       	mov	r9,0
80002a3e:	12 9a       	mov	r10,r9
80002a40:	1a 9b       	mov	r11,sp
80002a42:	f0 1f 00 03 	mcall	80002a4c <set_idle_store+0x1c>
}
80002a46:	2f fd       	sub	sp,-4
80002a48:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a4c:	80 00       	ld.sh	r0,r0[0x0]
80002a4e:	4d d4       	lddpc	r4,80002bc0 <phy_tx_func+0xec>

80002a50 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002a50:	d4 01       	pushm	lr
80002a52:	20 1d       	sub	sp,4
80002a54:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002a56:	98 88       	ld.uh	r8,r12[0x0]
80002a58:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a5c:	e0 48 40 00 	cp.w	r8,16384
80002a60:	c0 d1       	brne	80002a7a <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002a62:	49 08       	lddpc	r8,80002aa0 <phy_tx+0x50>
80002a64:	70 08       	ld.w	r8,r8[0x0]
80002a66:	58 08       	cp.w	r8,0
80002a68:	c1 a0       	breq	80002a9c <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002a6a:	48 e8       	lddpc	r8,80002aa0 <phy_tx+0x50>
80002a6c:	70 0c       	ld.w	r12,r8[0x0]
80002a6e:	30 09       	mov	r9,0
80002a70:	12 9a       	mov	r10,r9
80002a72:	1a 9b       	mov	r11,sp
80002a74:	f0 1f 00 0c 	mcall	80002aa4 <phy_tx+0x54>
80002a78:	c1 28       	rjmp	80002a9c <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002a7a:	e0 48 10 00 	cp.w	r8,4096
80002a7e:	5f 0a       	sreq	r10
80002a80:	e0 48 20 00 	cp.w	r8,8192
80002a84:	5f 09       	sreq	r9
80002a86:	f5 e9 10 09 	or	r9,r10,r9
80002a8a:	c0 71       	brne	80002a98 <phy_tx+0x48>
80002a8c:	e0 48 50 00 	cp.w	r8,20480
80002a90:	c0 40       	breq	80002a98 <phy_tx+0x48>
80002a92:	e0 48 60 00 	cp.w	r8,24576
80002a96:	c0 31       	brne	80002a9c <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a98:	48 48       	lddpc	r8,80002aa8 <phy_tx+0x58>
80002a9a:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a9c:	2f fd       	sub	sp,-4
80002a9e:	d8 02       	popm	pc
80002aa0:	00 00       	add	r0,r0
80002aa2:	0a bc       	st.h	r5++,r12
80002aa4:	80 00       	ld.sh	r0,r0[0x0]
80002aa6:	4d d4       	lddpc	r4,80002c18 <phy_tx_func+0x144>
80002aa8:	00 00       	add	r0,r0
80002aaa:	0a a4       	st.w	r5++,r4

80002aac <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002aac:	d4 01       	pushm	lr
80002aae:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002ab0:	30 08       	mov	r8,0
80002ab2:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002ab4:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002ab6:	1a 9a       	mov	r10,sp
80002ab8:	fa cb ff fc 	sub	r11,sp,-4
80002abc:	f0 1f 00 05 	mcall	80002ad0 <get_idle_store_isr+0x24>
80002ac0:	58 1c       	cp.w	r12,1
80002ac2:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002ac6:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002aca:	2f ed       	sub	sp,-8
80002acc:	d8 02       	popm	pc
80002ace:	00 00       	add	r0,r0
80002ad0:	80 00       	ld.sh	r0,r0[0x0]
80002ad2:	4a d8       	lddpc	r8,80002b84 <phy_tx_func+0xb0>

80002ad4 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002ad4:	eb cd 40 c0 	pushm	r6-r7,lr
80002ad8:	20 1d       	sub	sp,4
80002ada:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002adc:	fe f8 02 5c 	ld.w	r8,pc[604]
80002ae0:	70 08       	ld.w	r8,r8[0x0]
80002ae2:	58 08       	cp.w	r8,0
80002ae4:	c6 c0       	breq	80002bbc <phy_tx_func+0xe8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002ae6:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002ae8:	30 08       	mov	r8,0
80002aea:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002aec:	fe f8 02 50 	ld.w	r8,pc[592]
80002af0:	70 08       	ld.w	r8,r8[0x0]
80002af2:	58 18       	cp.w	r8,1
80002af4:	c2 90       	breq	80002b46 <phy_tx_func+0x72>
80002af6:	c0 43       	brcs	80002afe <phy_tx_func+0x2a>
80002af8:	58 28       	cp.w	r8,2
80002afa:	c6 11       	brne	80002bbc <phy_tx_func+0xe8>
80002afc:	c5 a8       	rjmp	80002bb0 <phy_tx_func+0xdc>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002afe:	fe f8 02 3a 	ld.w	r8,pc[570]
80002b02:	70 0c       	ld.w	r12,r8[0x0]
80002b04:	1a 9a       	mov	r10,sp
80002b06:	fe fb 02 3a 	ld.w	r11,pc[570]
80002b0a:	f0 1f 00 8f 	mcall	80002d44 <phy_tx_func+0x270>
80002b0e:	58 1c       	cp.w	r12,1
80002b10:	c1 51       	brne	80002b3a <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002b12:	fe f8 02 2e 	ld.w	r8,pc[558]
80002b16:	70 08       	ld.w	r8,r8[0x0]
80002b18:	11 9a       	ld.ub	r10,r8[0x1]
80002b1a:	fe f9 02 2e 	ld.w	r9,pc[558]
80002b1e:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002b20:	90 88       	ld.uh	r8,r8[0x0]
80002b22:	ea 18 ab cd 	orh	r8,0xabcd
80002b26:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002b28:	30 19       	mov	r9,1
80002b2a:	fe f8 02 22 	ld.w	r8,pc[546]
80002b2e:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002b30:	30 19       	mov	r9,1
80002b32:	fe f8 02 0a 	ld.w	r8,pc[522]
80002b36:	91 09       	st.w	r8[0x0],r9
80002b38:	c4 28       	rjmp	80002bbc <phy_tx_func+0xe8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002b3a:	e0 68 5a 5a 	mov	r8,23130
80002b3e:	ea 18 ab cd 	orh	r8,0xabcd
80002b42:	8f 18       	st.w	r7[0x4],r8
80002b44:	c3 c8       	rjmp	80002bbc <phy_tx_func+0xe8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b46:	fe f9 02 06 	ld.w	r9,pc[518]
80002b4a:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002b4c:	4f da       	lddpc	r10,80002d40 <phy_tx_func+0x26c>
80002b4e:	74 0a       	ld.w	r10,r10[0x0]
80002b50:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002b54:	b1 6a       	lsl	r10,0x10
80002b56:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b58:	2f f8       	sub	r8,-1
80002b5a:	5c 58       	castu.b	r8
80002b5c:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b5e:	4f ba       	lddpc	r10,80002d48 <phy_tx_func+0x274>
80002b60:	94 09       	ld.sh	r9,r10[0x0]
80002b62:	20 29       	sub	r9,2
80002b64:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b66:	30 0a       	mov	r10,0
80002b68:	f4 09 19 00 	cp.h	r9,r10
80002b6c:	e0 89 00 0a 	brgt	80002b80 <phy_tx_func+0xac>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002b70:	78 18       	ld.w	r8,r12[0x4]
80002b72:	e8 18 00 ba 	orl	r8,0xba
80002b76:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b78:	30 09       	mov	r9,0
80002b7a:	4f 18       	lddpc	r8,80002d3c <phy_tx_func+0x268>
80002b7c:	91 09       	st.w	r8[0x0],r9
80002b7e:	c1 f8       	rjmp	80002bbc <phy_tx_func+0xe8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b80:	4f 09       	lddpc	r9,80002d40 <phy_tx_func+0x26c>
80002b82:	72 09       	ld.w	r9,r9[0x0]
80002b84:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002b88:	78 1a       	ld.w	r10,r12[0x4]
80002b8a:	f5 e9 10 09 	or	r9,r10,r9
80002b8e:	99 19       	st.w	r12[0x4],r9
80002b90:	2f f8       	sub	r8,-1
80002b92:	4e f9       	lddpc	r9,80002d4c <phy_tx_func+0x278>
80002b94:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b96:	4e d9       	lddpc	r9,80002d48 <phy_tx_func+0x274>
80002b98:	92 08       	ld.sh	r8,r9[0x0]
80002b9a:	20 28       	sub	r8,2
80002b9c:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b9e:	30 09       	mov	r9,0
80002ba0:	f2 08 19 00 	cp.h	r8,r9
80002ba4:	e0 89 00 0c 	brgt	80002bbc <phy_tx_func+0xe8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002ba8:	30 29       	mov	r9,2
80002baa:	4e 58       	lddpc	r8,80002d3c <phy_tx_func+0x268>
80002bac:	91 09       	st.w	r8[0x0],r9
80002bae:	c0 78       	rjmp	80002bbc <phy_tx_func+0xe8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002bb0:	fc 18 00 ba 	movh	r8,0xba
80002bb4:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002bb6:	30 09       	mov	r9,0
80002bb8:	4e 18       	lddpc	r8,80002d3c <phy_tx_func+0x268>
80002bba:	91 09       	st.w	r8[0x0],r9

		//else//Send-PCM-data320bytes/20ms)
	//	{
			
			
			Payload_frame_DATA_1 = ((PCM_frame_Payload[0]<<16) | (PCM_frame_Payload[1]));
80002bbc:	4e 58       	lddpc	r8,80002d50 <phy_tx_func+0x27c>
80002bbe:	90 0a       	ld.sh	r10,r8[0x0]
80002bc0:	90 19       	ld.sh	r9,r8[0x2]
80002bc2:	5c 79       	castu.h	r9
80002bc4:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80002bc8:	4e 3a       	lddpc	r10,80002d54 <phy_tx_func+0x280>
80002bca:	95 09       	st.w	r10[0x0],r9
			Payload_frame_DATA_2 = ((PCM_frame_Payload[2]<<16) | (PCM_frame_Payload[3]));
80002bcc:	90 2a       	ld.sh	r10,r8[0x4]
80002bce:	90 38       	ld.sh	r8,r8[0x6]
80002bd0:	5c 78       	castu.h	r8
80002bd2:	f1 ea 11 08 	or	r8,r8,r10<<0x10
80002bd6:	4e 1a       	lddpc	r10,80002d58 <phy_tx_func+0x284>
80002bd8:	95 08       	st.w	r10[0x0],r8
			
			if ((Payload_frame_DATA_1 == PAYLOADIDLE0) || (0x00000003 != (bunchofrandomstatusflags & 0x00000003)) || ((Tone_flag)))
80002bda:	e0 6c 5a 5a 	mov	r12,23130
80002bde:	ea 1c ab cd 	orh	r12,0xabcd
80002be2:	18 39       	cp.w	r9,r12
80002be4:	c0 b0       	breq	80002bfa <phy_tx_func+0x126>
80002be6:	4d ea       	lddpc	r10,80002d5c <phy_tx_func+0x288>
80002be8:	74 0a       	ld.w	r10,r10[0x0]
80002bea:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80002bee:	58 3a       	cp.w	r10,3
80002bf0:	c0 51       	brne	80002bfa <phy_tx_func+0x126>
80002bf2:	4d ca       	lddpc	r10,80002d60 <phy_tx_func+0x28c>
80002bf4:	15 8a       	ld.ub	r10,r10[0x0]
80002bf6:	58 0a       	cp.w	r10,0
80002bf8:	c0 90       	breq	80002c0a <phy_tx_func+0x136>
			{
				payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002bfa:	e0 68 5a 5a 	mov	r8,23130
80002bfe:	ea 18 ab cd 	orh	r8,0xabcd
80002c02:	8f 28       	st.w	r7[0x8],r8
				payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002c04:	30 08       	mov	r8,0
80002c06:	8f 38       	st.w	r7[0xc],r8
80002c08:	c9 48       	rjmp	80002d30 <phy_tx_func+0x25c>
					
					//if((Radio_Transmit_State == 1) && (Mic_is_Enabled == 1))//
					//
					//
					
					if ( ((Payload_frame_DATA_1 & 0xFFFFF000) == 0xABCD2000) || ((Payload_frame_DATA_1 & 0xFFFFF000) == 0xABCD1000)
80002c0a:	12 9a       	mov	r10,r9
80002c0c:	e0 1a f0 00 	andl	r10,0xf000
80002c10:	e0 6b 20 00 	mov	r11,8192
80002c14:	ea 1b ab cd 	orh	r11,0xabcd
80002c18:	16 3a       	cp.w	r10,r11
80002c1a:	5f 0b       	sreq	r11
80002c1c:	e0 6c 10 00 	mov	r12,4096
80002c20:	ea 1c ab cd 	orh	r12,0xabcd
80002c24:	18 3a       	cp.w	r10,r12
80002c26:	5f 0a       	sreq	r10
80002c28:	f7 ea 10 0a 	or	r10,r11,r10
80002c2c:	c1 81       	brne	80002c5c <phy_tx_func+0x188>
80002c2e:	12 9a       	mov	r10,r9
80002c30:	e0 1a 00 00 	andl	r10,0x0
80002c34:	fc 1b 00 ba 	movh	r11,0xba
80002c38:	16 3a       	cp.w	r10,r11
80002c3a:	c1 10       	breq	80002c5c <phy_tx_func+0x188>
80002c3c:	f5 d9 c0 10 	bfextu	r10,r9,0x0,0x10
80002c40:	e0 4a 00 ba 	cp.w	r10,186
80002c44:	c0 c0       	breq	80002c5c <phy_tx_func+0x188>
80002c46:	10 9a       	mov	r10,r8
80002c48:	e0 1a 00 00 	andl	r10,0x0
80002c4c:	16 3a       	cp.w	r10,r11
80002c4e:	c0 e0       	breq	80002c6a <phy_tx_func+0x196>
80002c50:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
80002c54:	e0 48 00 ba 	cp.w	r8,186
80002c58:	c4 21       	brne	80002cdc <phy_tx_func+0x208>
80002c5a:	c2 18       	rjmp	80002c9c <phy_tx_func+0x1c8>
					|| ((Payload_frame_DATA_2 & 0xFFFF0000) == 0x00BA0000) || ((Payload_frame_DATA_2 & 0x0000FFFF) == 0x000000BA) )//header terminator
					{
						
						//logFromISR("\n\r MMQ:%X \n\r", Payload_frame_DATA_1);
						
						if (((Payload_frame_DATA_2 & 0xFFFF0000) == 0x00BA0000))
80002c5c:	10 9a       	mov	r10,r8
80002c5e:	e0 1a 00 00 	andl	r10,0x0
80002c62:	fc 1c 00 ba 	movh	r12,0xba
80002c66:	18 3a       	cp.w	r10,r12
80002c68:	c1 51       	brne	80002c92 <phy_tx_func+0x1be>
						{
							
							payload_tx_channel->word[0] = ((PCM_frame_Payload[0] & 0x00FF) + (PCM_frame_Payload[0] & 0xFF00)) ;
80002c6a:	4b a8       	lddpc	r8,80002d50 <phy_tx_func+0x27c>
80002c6c:	90 09       	ld.sh	r9,r8[0x0]
80002c6e:	90 0a       	ld.sh	r10,r8[0x0]
80002c70:	e0 1a ff 00 	andl	r10,0xff00
80002c74:	5c 59       	castu.b	r9
80002c76:	14 09       	add	r9,r10
80002c78:	ae 49       	st.h	r7[0x8],r9
							payload_tx_channel->word[1] = ((PCM_frame_Payload[1] & 0x00FF) + (PCM_frame_Payload[1] & 0xFF00)) ;
80002c7a:	90 1a       	ld.sh	r10,r8[0x2]
80002c7c:	90 19       	ld.sh	r9,r8[0x2]
80002c7e:	e0 19 ff 00 	andl	r9,0xff00
80002c82:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80002c86:	12 08       	add	r8,r9
80002c88:	ae 58       	st.h	r7[0xa],r8
							payload_tx_channel->dword[1] = Payload_frame_DATA_2;
80002c8a:	4b 48       	lddpc	r8,80002d58 <phy_tx_func+0x284>
80002c8c:	70 08       	ld.w	r8,r8[0x0]
80002c8e:	8f 38       	st.w	r7[0xc],r8
80002c90:	c5 08       	rjmp	80002d30 <phy_tx_func+0x25c>
							
						}
						else if (((Payload_frame_DATA_2 & 0x0000FFFF) == 0x000000BA))
80002c92:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
80002c96:	e0 48 00 ba 	cp.w	r8,186
80002c9a:	c1 c1       	brne	80002cd2 <phy_tx_func+0x1fe>
						{
							payload_tx_channel->word[0] = ((PCM_frame_Payload[0] & 0x00FF) + (PCM_frame_Payload[0] & 0xFF00)) ;
80002c9c:	4a d8       	lddpc	r8,80002d50 <phy_tx_func+0x27c>
80002c9e:	90 09       	ld.sh	r9,r8[0x0]
80002ca0:	90 0a       	ld.sh	r10,r8[0x0]
80002ca2:	e0 1a ff 00 	andl	r10,0xff00
80002ca6:	5c 59       	castu.b	r9
80002ca8:	14 09       	add	r9,r10
80002caa:	ae 49       	st.h	r7[0x8],r9
							payload_tx_channel->word[1] = ((PCM_frame_Payload[1] & 0x00FF) + (PCM_frame_Payload[1] & 0xFF00)) ;
80002cac:	90 19       	ld.sh	r9,r8[0x2]
80002cae:	90 1a       	ld.sh	r10,r8[0x2]
80002cb0:	e0 1a ff 00 	andl	r10,0xff00
80002cb4:	5c 59       	castu.b	r9
80002cb6:	14 09       	add	r9,r10
80002cb8:	ae 59       	st.h	r7[0xa],r9
							payload_tx_channel->word[2] = ((PCM_frame_Payload[2] & 0x00FF) + (PCM_frame_Payload[2] & 0xFF00)) ;//^ Public_PCMkey);
80002cba:	90 2a       	ld.sh	r10,r8[0x4]
80002cbc:	90 29       	ld.sh	r9,r8[0x4]
80002cbe:	e0 19 ff 00 	andl	r9,0xff00
80002cc2:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80002cc6:	12 08       	add	r8,r9
80002cc8:	ae 68       	st.h	r7[0xc],r8
							payload_tx_channel->word[3] = 0x00BA ;
80002cca:	e0 68 00 ba 	mov	r8,186
80002cce:	ae 78       	st.h	r7[0xe],r8
80002cd0:	c3 08       	rjmp	80002d30 <phy_tx_func+0x25c>
						}
						else
						{
							
						
							payload_tx_channel->dword[0] = Payload_frame_DATA_1;
80002cd2:	8f 29       	st.w	r7[0x8],r9
							payload_tx_channel->dword[1] = Payload_frame_DATA_2;
80002cd4:	4a 18       	lddpc	r8,80002d58 <phy_tx_func+0x284>
80002cd6:	70 08       	ld.w	r8,r8[0x0]
80002cd8:	8f 38       	st.w	r7[0xc],r8
80002cda:	c2 b8       	rjmp	80002d30 <phy_tx_func+0x25c>
					//
					else//PCM encryption
					{
						//(Tone_flag == 1)
						//logFromISR("\n\r MMQ:%X \n\r", Payload_frame_DATA_1);
						if (Silent_flag)
80002cdc:	4a 28       	lddpc	r8,80002d64 <phy_tx_func+0x290>
80002cde:	11 88       	ld.ub	r8,r8[0x0]
80002ce0:	58 08       	cp.w	r8,0
80002ce2:	c0 60       	breq	80002cee <phy_tx_func+0x21a>
						{
							//logFromISR("\n\r MMQ:%X \n\r", Payload_frame_DATA_1);
							payload_tx_channel->dword[0] = Payload_frame_DATA_1;
80002ce4:	8f 29       	st.w	r7[0x8],r9
							payload_tx_channel->dword[1] = Payload_frame_DATA_2;
80002ce6:	49 d8       	lddpc	r8,80002d58 <phy_tx_func+0x284>
80002ce8:	70 08       	ld.w	r8,r8[0x0]
80002cea:	8f 38       	st.w	r7[0xc],r8
80002cec:	c2 28       	rjmp	80002d30 <phy_tx_func+0x25c>
									////payload_tx_channel->dword[0] = Payload_frame_DATA_1;
									////payload_tx_channel->dword[1] = Payload_frame_DATA_2;
								//}
								//else
								{
									payload_tx_channel->word[0] = ((PCM_frame_Payload[0] & 0x00FF) + (PCM_frame_Payload[0] & 0xFF00)) ;
80002cee:	49 98       	lddpc	r8,80002d50 <phy_tx_func+0x27c>
80002cf0:	90 0a       	ld.sh	r10,r8[0x0]
80002cf2:	90 09       	ld.sh	r9,r8[0x0]
80002cf4:	e0 19 ff 00 	andl	r9,0xff00
80002cf8:	5c 5a       	castu.b	r10
80002cfa:	f4 09 00 09 	add	r9,r10,r9
80002cfe:	ae 49       	st.h	r7[0x8],r9
									payload_tx_channel->word[1] = ((PCM_frame_Payload[1] & 0x00FF) + (PCM_frame_Payload[1] & 0xFF00)) ;
80002d00:	90 1a       	ld.sh	r10,r8[0x2]
80002d02:	90 19       	ld.sh	r9,r8[0x2]
80002d04:	e0 19 ff 00 	andl	r9,0xff00
80002d08:	5c 5a       	castu.b	r10
80002d0a:	f4 09 00 09 	add	r9,r10,r9
80002d0e:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = ((PCM_frame_Payload[2] & 0x00FF) + (PCM_frame_Payload[2] & 0xFF00)) ;//^ Public_PCMkey);
80002d10:	90 2a       	ld.sh	r10,r8[0x4]
80002d12:	90 29       	ld.sh	r9,r8[0x4]
80002d14:	e0 19 ff 00 	andl	r9,0xff00
80002d18:	5c 5a       	castu.b	r10
80002d1a:	f4 09 00 09 	add	r9,r10,r9
80002d1e:	ae 69       	st.h	r7[0xc],r9
									payload_tx_channel->word[3] = ((PCM_frame_Payload[3] & 0x00FF) + (PCM_frame_Payload[3] & 0xFF00)) ;//^ Public_PCMkey);//bug,
80002d20:	90 39       	ld.sh	r9,r8[0x6]
80002d22:	90 38       	ld.sh	r8,r8[0x6]
80002d24:	e0 18 ff 00 	andl	r8,0xff00
80002d28:	5c 59       	castu.b	r9
80002d2a:	f2 08 00 08 	add	r8,r9,r8
80002d2e:	ae 78       	st.h	r7[0xe],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80002d30:	2f fd       	sub	sp,-4
80002d32:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002d36:	00 00       	add	r0,r0
80002d38:	00 00       	add	r0,r0
80002d3a:	0a bc       	st.h	r5++,r12
80002d3c:	00 00       	add	r0,r0
80002d3e:	0a 98       	mov	r8,r5
80002d40:	00 00       	add	r0,r0
80002d42:	0a 7c       	tst	r12,r5
80002d44:	80 00       	ld.sh	r0,r0[0x0]
80002d46:	4a d8       	lddpc	r8,80002df8 <phy_init+0x68>
80002d48:	00 00       	add	r0,r0
80002d4a:	0a b8       	st.h	r5++,r8
80002d4c:	00 00       	add	r0,r0
80002d4e:	0a 88       	andn	r8,r5
80002d50:	00 00       	add	r0,r0
80002d52:	04 f4       	st.b	--r2,r4
80002d54:	00 00       	add	r0,r0
80002d56:	0a b4       	st.h	r5++,r4
80002d58:	00 00       	add	r0,r0
80002d5a:	0a 80       	andn	r0,r5
80002d5c:	00 00       	add	r0,r0
80002d5e:	0d 8c       	ld.ub	r12,r6[0x0]
80002d60:	00 00       	add	r0,r0
80002d62:	0a 4b       	or	r11,r5
80002d64:	00 00       	add	r0,r0
80002d66:	0a 59       	eor	r9,r5

80002d68 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002d68:	d4 01       	pushm	lr
80002d6a:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002d6c:	30 0a       	mov	r10,0
80002d6e:	fa cb ff fc 	sub	r11,sp,-4
80002d72:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002d74:	14 99       	mov	r9,r10
80002d76:	1a 9b       	mov	r11,sp
80002d78:	f0 1f 00 05 	mcall	80002d8c <get_idle_store+0x24>
80002d7c:	58 1c       	cp.w	r12,1
80002d7e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002d82:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002d86:	2f fd       	sub	sp,-4
80002d88:	d8 02       	popm	pc
80002d8a:	00 00       	add	r0,r0
80002d8c:	80 00       	ld.sh	r0,r0[0x0]
80002d8e:	4b c8       	lddpc	r8,80002e7c <payload_rx+0x30>

80002d90 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002d90:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80002d94:	f0 1f 00 21 	mcall	80002e18 <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002d98:	4a 1b       	lddpc	r11,80002e1c <phy_init+0x8c>
80002d9a:	4a 2c       	lddpc	r12,80002e20 <phy_init+0x90>
80002d9c:	f0 1f 00 22 	mcall	80002e24 <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80002da0:	30 4b       	mov	r11,4
80002da2:	31 ec       	mov	r12,30
80002da4:	f0 1f 00 21 	mcall	80002e28 <phy_init+0x98>
80002da8:	4a 18       	lddpc	r8,80002e2c <phy_init+0x9c>
80002daa:	91 0c       	st.w	r8[0x0],r12
80002dac:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80002dae:	10 96       	mov	r6,r8
80002db0:	4a 05       	lddpc	r5,80002e30 <phy_init+0xa0>
80002db2:	6c 0c       	ld.w	r12,r6[0x0]
80002db4:	ea 07 00 0b 	add	r11,r5,r7
80002db8:	f0 1f 00 1f 	mcall	80002e34 <phy_init+0xa4>
80002dbc:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80002dc0:	e0 47 1e 00 	cp.w	r7,7680
80002dc4:	cf 71       	brne	80002db2 <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002dc6:	30 4b       	mov	r11,4
80002dc8:	31 4c       	mov	r12,20
80002dca:	f0 1f 00 18 	mcall	80002e28 <phy_init+0x98>
80002dce:	49 b8       	lddpc	r8,80002e38 <phy_init+0xa8>
80002dd0:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002dd2:	30 4b       	mov	r11,4
80002dd4:	30 ac       	mov	r12,10
80002dd6:	f0 1f 00 15 	mcall	80002e28 <phy_init+0x98>
80002dda:	49 98       	lddpc	r8,80002e3c <phy_init+0xac>
80002ddc:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80002dde:	30 4b       	mov	r11,4
80002de0:	30 ac       	mov	r12,10
80002de2:	f0 1f 00 12 	mcall	80002e28 <phy_init+0x98>
80002de6:	49 78       	lddpc	r8,80002e40 <phy_init+0xb0>
80002de8:	91 0c       	st.w	r8[0x0],r12
80002dea:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80002dec:	10 96       	mov	r6,r8
80002dee:	49 65       	lddpc	r5,80002e44 <phy_init+0xb4>
80002df0:	6c 0c       	ld.w	r12,r6[0x0]
80002df2:	ea 07 00 0b 	add	r11,r5,r7
80002df6:	f0 1f 00 10 	mcall	80002e34 <phy_init+0xa4>
80002dfa:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80002dfe:	e0 47 14 00 	cp.w	r7,5120
80002e02:	cf 71       	brne	80002df0 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
80002e04:	e0 6b 01 00 	mov	r11,256
80002e08:	30 5c       	mov	r12,5
80002e0a:	f0 1f 00 08 	mcall	80002e28 <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
80002e0e:	48 f8       	lddpc	r8,80002e48 <phy_init+0xb8>
80002e10:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
80002e12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002e16:	00 00       	add	r0,r0
80002e18:	80 00       	ld.sh	r0,r0[0x0]
80002e1a:	35 e8       	mov	r8,94
80002e1c:	80 00       	ld.sh	r0,r0[0x0]
80002e1e:	2a d4       	sub	r4,-83
80002e20:	80 00       	ld.sh	r0,r0[0x0]
80002e22:	2e ac       	sub	r12,-22
80002e24:	80 00       	ld.sh	r0,r0[0x0]
80002e26:	35 d4       	mov	r4,93
80002e28:	80 00       	ld.sh	r0,r0[0x0]
80002e2a:	4f 2c       	lddpc	r12,80002ff0 <phy_rx_func+0x144>
80002e2c:	00 00       	add	r0,r0
80002e2e:	0a 90       	mov	r0,r5
80002e30:	00 00       	add	r0,r0
80002e32:	21 90       	sub	r0,25
80002e34:	80 00       	ld.sh	r0,r0[0x0]
80002e36:	2a 30       	sub	r0,-93
80002e38:	00 00       	add	r0,r0
80002e3a:	0a bc       	st.h	r5++,r12
80002e3c:	00 00       	add	r0,r0
80002e3e:	0a ac       	st.w	r5++,r12
80002e40:	00 00       	add	r0,r0
80002e42:	0a 74       	tst	r4,r5
80002e44:	00 00       	add	r0,r0
80002e46:	0d 90       	ld.ub	r0,r6[0x1]
80002e48:	00 00       	add	r0,r0
80002e4a:	0a a4       	st.w	r5++,r4

80002e4c <payload_rx>:




static void payload_rx(void * payload)
{
80002e4c:	d4 01       	pushm	lr
80002e4e:	20 2d       	sub	sp,8
80002e50:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002e52:	30 08       	mov	r8,0
80002e54:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
80002e56:	48 f8       	lddpc	r8,80002e90 <payload_rx+0x44>
80002e58:	70 08       	ld.w	r8,r8[0x0]
80002e5a:	58 08       	cp.w	r8,0
80002e5c:	c0 71       	brne	80002e6a <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80002e5e:	30 4b       	mov	r11,4
80002e60:	30 5c       	mov	r12,5
80002e62:	f0 1f 00 0d 	mcall	80002e94 <payload_rx+0x48>
80002e66:	48 b8       	lddpc	r8,80002e90 <payload_rx+0x44>
80002e68:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80002e6a:	48 a8       	lddpc	r8,80002e90 <payload_rx+0x44>
80002e6c:	70 0c       	ld.w	r12,r8[0x0]
80002e6e:	30 09       	mov	r9,0
80002e70:	fa ca ff fc 	sub	r10,sp,-4
80002e74:	1a 9b       	mov	r11,sp
80002e76:	f0 1f 00 09 	mcall	80002e98 <payload_rx+0x4c>
80002e7a:	c0 91       	brne	80002e8c <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80002e7c:	48 88       	lddpc	r8,80002e9c <payload_rx+0x50>
80002e7e:	70 0c       	ld.w	r12,r8[0x0]
80002e80:	40 0b       	lddsp	r11,sp[0x0]
80002e82:	f0 1f 00 08 	mcall	80002ea0 <payload_rx+0x54>
		logFromISR("mm");
80002e86:	48 8c       	lddpc	r12,80002ea4 <payload_rx+0x58>
80002e88:	f0 1f 00 08 	mcall	80002ea8 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
80002e8c:	2f ed       	sub	sp,-8
80002e8e:	d8 02       	popm	pc
80002e90:	00 00       	add	r0,r0
80002e92:	0a 78       	tst	r8,r5
80002e94:	80 00       	ld.sh	r0,r0[0x0]
80002e96:	4f 2c       	lddpc	r12,8000305c <phy_rx_func+0x1b0>
80002e98:	80 00       	ld.sh	r0,r0[0x0]
80002e9a:	4d 84       	lddpc	r4,80002ff8 <phy_rx_func+0x14c>
80002e9c:	00 00       	add	r0,r0
80002e9e:	0a 74       	tst	r4,r5
80002ea0:	80 00       	ld.sh	r0,r0[0x0]
80002ea2:	29 dc       	sub	r12,-99
80002ea4:	80 00       	ld.sh	r0,r0[0x0]
80002ea6:	c1 f0       	breq	80002ee4 <phy_rx_func+0x38>
80002ea8:	80 00       	ld.sh	r0,r0[0x0]
80002eaa:	5b 50       	cp.w	r0,-11

80002eac <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002eac:	eb cd 40 e0 	pushm	r5-r7,lr
80002eb0:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002eb2:	fe f8 05 86 	ld.w	r8,pc[1414]
80002eb6:	70 08       	ld.w	r8,r8[0x0]
80002eb8:	58 08       	cp.w	r8,0
80002eba:	e0 80 01 05 	breq	800030c4 <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002ebe:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002ec0:	fe f8 05 7c 	ld.w	r8,pc[1404]
80002ec4:	70 09       	ld.w	r9,r8[0x0]
80002ec6:	2f f9       	sub	r9,-1
80002ec8:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002eca:	fe f8 05 76 	ld.w	r8,pc[1398]
80002ece:	70 08       	ld.w	r8,r8[0x0]
80002ed0:	58 18       	cp.w	r8,1
80002ed2:	e0 80 00 84 	breq	80002fda <phy_rx_func+0x12e>
80002ed6:	c0 73       	brcs	80002ee4 <phy_rx_func+0x38>
80002ed8:	58 28       	cp.w	r8,2
80002eda:	c5 b0       	breq	80002f90 <phy_rx_func+0xe4>
80002edc:	58 38       	cp.w	r8,3
80002ede:	e0 81 00 f3 	brne	800030c4 <phy_rx_func+0x218>
80002ee2:	cd 38       	rjmp	80003088 <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002ee4:	e0 6a 5a 5a 	mov	r10,23130
80002ee8:	ea 1a ab cd 	orh	r10,0xabcd
80002eec:	14 36       	cp.w	r6,r10
80002eee:	e0 80 00 eb 	breq	800030c4 <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002ef2:	ec 08 16 10 	lsr	r8,r6,0x10
80002ef6:	e0 48 ab cd 	cp.w	r8,43981
80002efa:	e0 81 00 e5 	brne	800030c4 <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002efe:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002f02:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002f06:	20 28       	sub	r8,2
80002f08:	fe f9 05 3c 	ld.w	r9,pc[1340]
80002f0c:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002f0e:	30 09       	mov	r9,0
80002f10:	f2 08 19 00 	cp.h	r8,r9
80002f14:	e0 8a 00 d8 	brle	800030c4 <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
80002f18:	fe f8 05 30 	ld.w	r8,pc[1328]
80002f1c:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
80002f1e:	fe f8 05 2e 	ld.w	r8,pc[1326]
80002f22:	70 0c       	ld.w	r12,r8[0x0]
80002f24:	f0 1f 01 4b 	mcall	80003450 <phy_rx_func+0x5a4>
80002f28:	fe f8 05 2c 	ld.w	r8,pc[1324]
80002f2c:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002f2e:	58 0c       	cp.w	r12,0
80002f30:	e0 80 00 ca 	breq	800030c4 <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002f34:	fe f8 05 14 	ld.w	r8,pc[1300]
80002f38:	90 09       	ld.sh	r9,r8[0x0]
80002f3a:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002f3e:	2f f9       	sub	r9,-1
80002f40:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002f42:	fe fa 05 12 	ld.w	r10,pc[1298]
80002f46:	74 0a       	ld.w	r10,r10[0x0]
80002f48:	fe fb 04 f4 	ld.w	r11,pc[1268]
80002f4c:	76 0b       	ld.w	r11,r11[0x0]
80002f4e:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002f52:	2f f9       	sub	r9,-1
80002f54:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002f56:	e2 16 0f 00 	andl	r6,0xf00,COH
80002f5a:	e0 46 01 00 	cp.w	r6,256
80002f5e:	c0 c0       	breq	80002f76 <phy_rx_func+0xca>
80002f60:	e0 8b 00 05 	brhi	80002f6a <phy_rx_func+0xbe>
80002f64:	58 06       	cp.w	r6,0
80002f66:	c0 80       	breq	80002f76 <phy_rx_func+0xca>
80002f68:	c0 c8       	rjmp	80002f80 <phy_rx_func+0xd4>
80002f6a:	e0 46 02 00 	cp.w	r6,512
80002f6e:	c0 40       	breq	80002f76 <phy_rx_func+0xca>
80002f70:	e0 46 03 00 	cp.w	r6,768
80002f74:	c0 61       	brne	80002f80 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002f76:	30 29       	mov	r9,2
80002f78:	fe f8 04 c8 	ld.w	r8,pc[1224]
80002f7c:	91 09       	st.w	r8[0x0],r9
80002f7e:	ca 38       	rjmp	800030c4 <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
80002f80:	fe f6 04 d4 	ld.w	r6,pc[1236]
80002f84:	6c 0c       	ld.w	r12,r6[0x0]
80002f86:	f0 1f 01 35 	mcall	80003458 <phy_rx_func+0x5ac>
					phy_frame_ptr = NULL;					
80002f8a:	30 08       	mov	r8,0
80002f8c:	8d 08       	st.w	r6[0x0],r8
80002f8e:	c9 b8       	rjmp	800030c4 <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002f90:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002f94:	b1 86       	lsr	r6,0x10
80002f96:	14 06       	add	r6,r10
80002f98:	fe f8 04 c4 	ld.w	r8,pc[1220]
80002f9c:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002f9e:	fe f8 04 aa 	ld.w	r8,pc[1194]
80002fa2:	90 09       	ld.sh	r9,r8[0x0]
80002fa4:	fe fb 04 b0 	ld.w	r11,pc[1200]
80002fa8:	76 0b       	ld.w	r11,r11[0x0]
80002faa:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002fae:	2f f9       	sub	r9,-1
80002fb0:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002fb2:	fe f9 04 92 	ld.w	r9,pc[1170]
80002fb6:	92 08       	ld.sh	r8,r9[0x0]
80002fb8:	20 28       	sub	r8,2
80002fba:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002fbc:	30 09       	mov	r9,0
80002fbe:	f2 08 19 00 	cp.h	r8,r9
80002fc2:	e0 8a 00 07 	brle	80002fd0 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002fc6:	30 19       	mov	r9,1
80002fc8:	fe f8 04 78 	ld.w	r8,pc[1144]
80002fcc:	91 09       	st.w	r8[0x0],r9
80002fce:	c7 b8       	rjmp	800030c4 <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002fd0:	30 39       	mov	r9,3
80002fd2:	fe f8 04 6e 	ld.w	r8,pc[1134]
80002fd6:	91 09       	st.w	r8[0x0],r9
80002fd8:	c7 68       	rjmp	800030c4 <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002fda:	ec 0a 14 10 	asr	r10,r6,0x10
80002fde:	fe f8 04 7e 	ld.w	r8,pc[1150]
80002fe2:	90 09       	ld.sh	r9,r8[0x0]
80002fe4:	14 09       	add	r9,r10
80002fe6:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002fe8:	fe f9 04 60 	ld.w	r9,pc[1120]
80002fec:	92 08       	ld.sh	r8,r9[0x0]
80002fee:	fe fb 04 66 	ld.w	r11,pc[1126]
80002ff2:	76 0b       	ld.w	r11,r11[0x0]
80002ff4:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002ff8:	2f f8       	sub	r8,-1
80002ffa:	5c 88       	casts.h	r8
80002ffc:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002ffe:	fe fa 04 46 	ld.w	r10,pc[1094]
80003002:	94 09       	ld.sh	r9,r10[0x0]
80003004:	20 29       	sub	r9,2
80003006:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80003008:	30 0a       	mov	r10,0
8000300a:	f4 09 19 00 	cp.h	r9,r10
8000300e:	e0 89 00 1f 	brgt	8000304c <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003012:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003016:	e0 46 00 ba 	cp.w	r6,186
8000301a:	c0 d1       	brne	80003034 <phy_rx_func+0x188>
8000301c:	fe f8 04 40 	ld.w	r8,pc[1088]
80003020:	90 09       	ld.sh	r9,r8[0x0]
80003022:	f4 09 19 00 	cp.h	r9,r10
80003026:	c0 71       	brne	80003034 <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003028:	fe f8 04 2c 	ld.w	r8,pc[1068]
8000302c:	70 0c       	ld.w	r12,r8[0x0]
8000302e:	f0 1f 01 0d 	mcall	80003460 <phy_rx_func+0x5b4>
80003032:	c0 88       	rjmp	80003042 <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
80003034:	fe f6 04 20 	ld.w	r6,pc[1056]
80003038:	6c 0c       	ld.w	r12,r6[0x0]
8000303a:	f0 1f 01 08 	mcall	80003458 <phy_rx_func+0x5ac>
					phy_frame_ptr = NULL;
8000303e:	30 08       	mov	r8,0
80003040:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
80003042:	30 09       	mov	r9,0
80003044:	fe f8 03 fc 	ld.w	r8,pc[1020]
80003048:	91 09       	st.w	r8[0x0],r9
8000304a:	c3 d8       	rjmp	800030c4 <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
8000304c:	5c 86       	casts.h	r6
8000304e:	fe f9 04 0e 	ld.w	r9,pc[1038]
80003052:	92 0a       	ld.sh	r10,r9[0x0]
80003054:	0c 0a       	add	r10,r6
80003056:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003058:	fe f9 03 fc 	ld.w	r9,pc[1020]
8000305c:	72 09       	ld.w	r9,r9[0x0]
8000305e:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80003062:	2f f8       	sub	r8,-1
80003064:	fe f9 03 e4 	ld.w	r9,pc[996]
80003068:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000306a:	fe f9 03 da 	ld.w	r9,pc[986]
8000306e:	92 08       	ld.sh	r8,r9[0x0]
80003070:	20 28       	sub	r8,2
80003072:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003074:	30 09       	mov	r9,0
80003076:	f2 08 19 00 	cp.h	r8,r9
8000307a:	e0 89 00 25 	brgt	800030c4 <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
8000307e:	30 39       	mov	r9,3
80003080:	fe f8 03 c0 	ld.w	r8,pc[960]
80003084:	91 09       	st.w	r8[0x0],r9
80003086:	c1 f8       	rjmp	800030c4 <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003088:	e6 16 00 ff 	andh	r6,0xff,COH
8000308c:	fc 19 00 ba 	movh	r9,0xba
80003090:	12 36       	cp.w	r6,r9
80003092:	c0 e1       	brne	800030ae <phy_rx_func+0x202>
80003094:	fe f8 03 c8 	ld.w	r8,pc[968]
80003098:	90 09       	ld.sh	r9,r8[0x0]
8000309a:	30 08       	mov	r8,0
8000309c:	f0 09 19 00 	cp.h	r9,r8
800030a0:	c0 71       	brne	800030ae <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800030a2:	fe f8 03 b2 	ld.w	r8,pc[946]
800030a6:	70 0c       	ld.w	r12,r8[0x0]
800030a8:	f0 1f 00 ee 	mcall	80003460 <phy_rx_func+0x5b4>
800030ac:	c0 88       	rjmp	800030bc <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
800030ae:	fe f6 03 a6 	ld.w	r6,pc[934]
800030b2:	6c 0c       	ld.w	r12,r6[0x0]
800030b4:	f0 1f 00 e9 	mcall	80003458 <phy_rx_func+0x5ac>
				phy_frame_ptr = NULL;
800030b8:	30 08       	mov	r8,0
800030ba:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800030bc:	30 09       	mov	r9,0
800030be:	fe f8 03 82 	ld.w	r8,pc[898]
800030c2:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
800030c4:	fe f8 03 a0 	ld.w	r8,pc[928]
800030c8:	11 89       	ld.ub	r9,r8[0x0]
800030ca:	30 08       	mov	r8,0
800030cc:	f0 09 18 00 	cp.b	r9,r8
800030d0:	c0 d1       	brne	800030ea <phy_rx_func+0x23e>
	{
		payload_ptr = get_payload_idle_isr();
800030d2:	fe f8 03 96 	ld.w	r8,pc[918]
800030d6:	70 0c       	ld.w	r12,r8[0x0]
800030d8:	f0 1f 00 de 	mcall	80003450 <phy_rx_func+0x5a4>
800030dc:	fe f8 03 90 	ld.w	r8,pc[912]
800030e0:	91 0c       	st.w	r8[0x0],r12
		//AMBE_payload_ptr = get_payload_idle_isr();
		is_first = TRUE;
800030e2:	30 19       	mov	r9,1
800030e4:	fe f8 03 80 	ld.w	r8,pc[896]
800030e8:	b0 89       	st.b	r8[0x0],r9
	}	
	
	PCM_frame_Payload[0] = payload_rx_channel->word[0];
800030ea:	8e 49       	ld.sh	r9,r7[0x8]
800030ec:	fe f8 03 84 	ld.w	r8,pc[900]
800030f0:	b0 09       	st.h	r8[0x0],r9
	PCM_frame_Payload[1] = payload_rx_channel->word[1];
800030f2:	8e 59       	ld.sh	r9,r7[0xa]
800030f4:	b0 19       	st.h	r8[0x2],r9
	PCM_frame_Payload[2] = payload_rx_channel->word[2];
800030f6:	8e 69       	ld.sh	r9,r7[0xc]
800030f8:	b0 29       	st.h	r8[0x4],r9
	PCM_frame_Payload[3] = payload_rx_channel->word[3];
800030fa:	8e 79       	ld.sh	r9,r7[0xe]
800030fc:	b0 39       	st.h	r8[0x6],r9
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800030fe:	fe f8 03 76 	ld.w	r8,pc[886]
80003102:	70 08       	ld.w	r8,r8[0x0]
80003104:	58 08       	cp.w	r8,0
80003106:	c0 50       	breq	80003110 <phy_rx_func+0x264>
80003108:	58 28       	cp.w	r8,2
8000310a:	e0 81 01 94 	brne	80003432 <phy_rx_func+0x586>
8000310e:	cf 08       	rjmp	800032ee <phy_rx_func+0x442>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003110:	6e 28       	ld.w	r8,r7[0x8]
80003112:	e0 6a 5a 5a 	mov	r10,23130
80003116:	ea 1a ab cd 	orh	r10,0xabcd
8000311a:	14 38       	cp.w	r8,r10
8000311c:	c0 71       	brne	8000312a <phy_rx_func+0x27e>
			{
				m_RxBurstType = VOICE_WATING;
8000311e:	30 09       	mov	r9,0
80003120:	fe f8 03 58 	ld.w	r8,pc[856]
80003124:	91 09       	st.w	r8[0x0],r9
80003126:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
8000312a:	10 99       	mov	r9,r8
8000312c:	e0 19 00 00 	andl	r9,0x0
80003130:	fc 1a ab cd 	movh	r10,0xabcd
80003134:	14 39       	cp.w	r9,r10
80003136:	e0 81 01 7e 	brne	80003432 <phy_rx_func+0x586>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
8000313a:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000313e:	fe f9 03 3e 	ld.w	r9,pc[830]
80003142:	93 08       	st.w	r9[0x0],r8
		
			if((NULL== payload_ptr) )
80003144:	fe f8 03 28 	ld.w	r8,pc[808]
80003148:	70 08       	ld.w	r8,r8[0x0]
8000314a:	58 08       	cp.w	r8,0
8000314c:	c1 11       	brne	8000316e <phy_rx_func+0x2c2>
			{
				payload_ptr = get_payload_idle_isr();
8000314e:	fe f8 03 1a 	ld.w	r8,pc[794]
80003152:	70 0c       	ld.w	r12,r8[0x0]
80003154:	f0 1f 00 bf 	mcall	80003450 <phy_rx_func+0x5a4>
80003158:	fe f8 03 14 	ld.w	r8,pc[788]
8000315c:	91 0c       	st.w	r8[0x0],r12
				//AMBE_payload_ptr = get_payload_idle_isr();
				
				if((NULL== payload_ptr) )
8000315e:	58 0c       	cp.w	r12,0
80003160:	c0 71       	brne	8000316e <phy_rx_func+0x2c2>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//
80003162:	fe fc 03 1e 	ld.w	r12,pc[798]
80003166:	f0 1f 00 c8 	mcall	80003484 <phy_rx_func+0x5d8>
8000316a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
#endif			
			//else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000316e:	6e 28       	ld.w	r8,r7[0x8]
80003170:	e2 18 f0 00 	andl	r8,0xf000,COH
80003174:	e0 48 10 00 	cp.w	r8,4096
80003178:	5f 19       	srne	r9
8000317a:	e0 48 20 00 	cp.w	r8,8192
8000317e:	5f 18       	srne	r8
80003180:	f3 e8 00 08 	and	r8,r9,r8
80003184:	e0 81 01 57 	brne	80003432 <phy_rx_func+0x586>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003188:	fe f9 03 00 	ld.w	r9,pc[768]
8000318c:	b2 88       	st.b	r9[0x0],r8
				AMBE_rx_flag = 0;
8000318e:	fe f9 02 fe 	ld.w	r9,pc[766]
80003192:	b2 88       	st.b	r9[0x0],r8
				
				Item_ID = 0;//To make sure your save PCM data.
80003194:	fe f9 02 fc 	ld.w	r9,pc[764]
80003198:	b2 88       	st.b	r9[0x0],r8
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000319a:	6e 28       	ld.w	r8,r7[0x8]
8000319c:	e2 18 0f 00 	andl	r8,0xf00,COH
800031a0:	e0 48 01 00 	cp.w	r8,256
800031a4:	e0 8b 00 79 	brhi	80003296 <phy_rx_func+0x3ea>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 0x00000100){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
				if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800031a8:	fe f9 02 d4 	ld.w	r9,pc[724]
800031ac:	72 08       	ld.w	r8,r9[0x0]
800031ae:	20 48       	sub	r8,4
800031b0:	93 08       	st.w	r9[0x0],r8
800031b2:	e0 80 01 40 	breq	80003432 <phy_rx_func+0x586>
				ArrayDiscLength = payload_rx_channel->word[2];
800031b6:	8e e9       	ld.uh	r9,r7[0xc]
800031b8:	fe f8 02 dc 	ld.w	r8,pc[732]
800031bc:	91 09       	st.w	r8[0x0],r9
					//Terminator_Flag = 0;
					//Tone_flag = 0;
					//Silent_flag = 0;
				//}
		
				switch (ArrayDiscLength){
800031be:	70 08       	ld.w	r8,r8[0x0]
800031c0:	58 08       	cp.w	r8,0
800031c2:	c0 50       	breq	800031cc <phy_rx_func+0x320>
800031c4:	58 18       	cp.w	r8,1
800031c6:	e0 81 01 36 	brne	80003432 <phy_rx_func+0x586>
800031ca:	c3 08       	rjmp	8000322a <phy_rx_func+0x37e>
					case 0:          //The usual case. Remaining word in Phy buffer is Audio.
							
						Terminator_Flag = 0;
800031cc:	30 08       	mov	r8,0
800031ce:	fe f9 02 ca 	ld.w	r9,pc[714]
800031d2:	b2 88       	st.b	r9[0x0],r8
						Tone_flag = 0;
800031d4:	fe f9 02 c8 	ld.w	r9,pc[712]
800031d8:	b2 88       	st.b	r9[0x0],r8
						Silent_flag = 0;
800031da:	fe f9 02 c6 	ld.w	r9,pc[710]
800031de:	b2 88       	st.b	r9[0x0],r8
						//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);		
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800031e0:	fe f8 02 c4 	ld.w	r8,pc[708]
800031e4:	70 0a       	ld.w	r10,r8[0x0]
800031e6:	fe f9 02 86 	ld.w	r9,pc[646]
800031ea:	72 09       	ld.w	r9,r9[0x0]
800031ec:	8e 7b       	ld.sh	r11,r7[0xe]
800031ee:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
800031f2:	70 09       	ld.w	r9,r8[0x0]
800031f4:	2f f9       	sub	r9,-1
800031f6:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800031f8:	e0 49 00 ff 	cp.w	r9,255
800031fc:	e0 88 00 11 	brls	8000321e <phy_rx_func+0x372>
						{
							RxMedia_IsFillingNext16 = 0;	
80003200:	30 09       	mov	r9,0
80003202:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);	
80003204:	fe f7 02 68 	ld.w	r7,pc[616]
80003208:	6e 0c       	ld.w	r12,r7[0x0]
8000320a:	f0 1f 00 a8 	mcall	800034a8 <phy_rx_func+0x5fc>
							payload_ptr = get_payload_idle_isr();
8000320e:	fe f8 02 5a 	ld.w	r8,pc[602]
80003212:	70 0c       	ld.w	r12,r8[0x0]
80003214:	f0 1f 00 8f 	mcall	80003450 <phy_rx_func+0x5a4>
80003218:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
8000321a:	e0 80 01 0c 	breq	80003432 <phy_rx_func+0x586>
							{
								break;
							}				
						}
							RxMediaState = READINGMEDIA;
8000321e:	30 29       	mov	r9,2
80003220:	fe f8 02 54 	ld.w	r8,pc[596]
80003224:	91 09       	st.w	r8[0x0],r9
80003226:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				
					case 1: //The next usual case.
							//In general case, add code to process single word Array descriptor.
							if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
8000322a:	8e 78       	ld.sh	r8,r7[0xe]
8000322c:	30 39       	mov	r9,3
8000322e:	f2 08 19 00 	cp.h	r8,r9
80003232:	c0 61       	brne	8000323e <phy_rx_func+0x392>
							{
								Terminator_Flag = 1;
80003234:	30 19       	mov	r9,1
80003236:	fe f8 02 62 	ld.w	r8,pc[610]
8000323a:	b0 89       	st.b	r8[0x0],r9
8000323c:	c2 88       	rjmp	8000328c <phy_rx_func+0x3e0>

							}
							else if(payload_rx_channel->word[3] == 0x0004)//Silent Descriptor
8000323e:	30 49       	mov	r9,4
80003240:	f2 08 19 00 	cp.h	r8,r9
80003244:	c0 61       	brne	80003250 <phy_rx_func+0x3a4>
							{
							
								Silent_flag = 1;
80003246:	30 19       	mov	r9,1
80003248:	fe f8 02 58 	ld.w	r8,pc[600]
8000324c:	b0 89       	st.b	r8[0x0],r9
8000324e:	c1 f8       	rjmp	8000328c <phy_rx_func+0x3e0>
							}
							else if (payload_rx_channel->word[3] == 0x1026)//Tone Descriptor
80003250:	e0 69 10 26 	mov	r9,4134
80003254:	f2 08 19 00 	cp.h	r8,r9
80003258:	c1 01       	brne	80003278 <phy_rx_func+0x3cc>
							{
								Tone_flag = 1;
8000325a:	30 19       	mov	r9,1
8000325c:	fe f8 02 40 	ld.w	r8,pc[576]
80003260:	b0 89       	st.b	r8[0x0],r9
								Tone_Counters++;
80003262:	fe f8 02 4a 	ld.w	r8,pc[586]
80003266:	70 09       	ld.w	r9,r8[0x0]
80003268:	2f f9       	sub	r9,-1
8000326a:	91 09       	st.w	r8[0x0],r9
								RxMediaState = WAITINGABAB;
8000326c:	30 09       	mov	r9,0
8000326e:	fe f8 02 06 	ld.w	r8,pc[518]
80003272:	91 09       	st.w	r8[0x0],r9
80003274:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
							
							}
							else
							{
								Terminator_Flag = 0;
80003278:	30 08       	mov	r8,0
8000327a:	fe f9 02 1e 	ld.w	r9,pc[542]
8000327e:	b2 88       	st.b	r9[0x0],r8
								Tone_flag = 0;
80003280:	fe f9 02 1c 	ld.w	r9,pc[540]
80003284:	b2 88       	st.b	r9[0x0],r8
								Silent_flag = 0;
80003286:	fe f9 02 1a 	ld.w	r9,pc[538]
8000328a:	b2 88       	st.b	r9[0x0],r8
								
							}
					
					
							RxMediaState = READINGMEDIA;
8000328c:	30 29       	mov	r9,2
8000328e:	4f a8       	lddpc	r8,80003474 <phy_rx_func+0x5c8>
80003290:	91 09       	st.w	r8[0x0],r9
80003292:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
				}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003296:	4f a8       	lddpc	r8,8000347c <phy_rx_func+0x5d0>
80003298:	70 08       	ld.w	r8,r8[0x0]
8000329a:	58 18       	cp.w	r8,1
8000329c:	e0 88 00 cb 	brls	80003432 <phy_rx_func+0x586>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
800032a0:	fe f8 02 04 	ld.w	r8,pc[516]
800032a4:	70 0a       	ld.w	r10,r8[0x0]
800032a6:	4f 29       	lddpc	r9,8000346c <phy_rx_func+0x5c0>
800032a8:	72 09       	ld.w	r9,r9[0x0]
800032aa:	6e 3b       	ld.w	r11,r7[0xc]
800032ac:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800032b0:	70 09       	ld.w	r9,r8[0x0]
800032b2:	2f f9       	sub	r9,-1
800032b4:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032b6:	e0 49 00 ff 	cp.w	r9,255
800032ba:	e0 88 00 0f 	brls	800032d8 <phy_rx_func+0x42c>
				{
					RxMedia_IsFillingNext16 = 0;
800032be:	30 09       	mov	r9,0
800032c0:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800032c2:	4e b7       	lddpc	r7,8000346c <phy_rx_func+0x5c0>
800032c4:	6e 0c       	ld.w	r12,r7[0x0]
800032c6:	f0 1f 00 79 	mcall	800034a8 <phy_rx_func+0x5fc>
								payload_ptr = get_payload_idle_isr();
800032ca:	4e 88       	lddpc	r8,80003468 <phy_rx_func+0x5bc>
800032cc:	70 0c       	ld.w	r12,r8[0x0]
800032ce:	f0 1f 00 61 	mcall	80003450 <phy_rx_func+0x5a4>
800032d2:	8f 0c       	st.w	r7[0x0],r12
													if(NULL == payload_ptr)
800032d4:	e0 80 00 af 	breq	80003432 <phy_rx_func+0x586>
													{
														break;
													}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
800032d8:	4e 99       	lddpc	r9,8000347c <phy_rx_func+0x5d0>
800032da:	72 08       	ld.w	r8,r9[0x0]
800032dc:	20 28       	sub	r8,2
800032de:	93 08       	st.w	r9[0x0],r8
800032e0:	e0 80 00 a9 	breq	80003432 <phy_rx_func+0x586>
				RxMediaState = READINGMEDIA;
800032e4:	30 29       	mov	r9,2
800032e6:	4e 48       	lddpc	r8,80003474 <phy_rx_func+0x5c8>
800032e8:	91 09       	st.w	r8[0x0],r9
800032ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800032ee:	4e e8       	lddpc	r8,800034a4 <phy_rx_func+0x5f8>
800032f0:	70 0a       	ld.w	r10,r8[0x0]
800032f2:	4d f9       	lddpc	r9,8000346c <phy_rx_func+0x5c0>
800032f4:	72 09       	ld.w	r9,r9[0x0]
800032f6:	8e 4b       	ld.sh	r11,r7[0x8]
800032f8:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800032fc:	70 09       	ld.w	r9,r8[0x0]
800032fe:	2f f9       	sub	r9,-1
80003300:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003302:	e0 49 00 ff 	cp.w	r9,255
80003306:	e0 88 00 13 	brls	8000332c <phy_rx_func+0x480>
					{
							RxMedia_IsFillingNext16 = 0;
8000330a:	30 09       	mov	r9,0
8000330c:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
8000330e:	4d 86       	lddpc	r6,8000346c <phy_rx_func+0x5c0>
80003310:	6c 0c       	ld.w	r12,r6[0x0]
80003312:	f0 1f 00 66 	mcall	800034a8 <phy_rx_func+0x5fc>
							payload_ptr = get_payload_idle_isr();
80003316:	4d 58       	lddpc	r8,80003468 <phy_rx_func+0x5bc>
80003318:	70 0c       	ld.w	r12,r8[0x0]
8000331a:	f0 1f 00 4e 	mcall	80003450 <phy_rx_func+0x5a4>
8000331e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == payload_ptr)
80003320:	c0 61       	brne	8000332c <phy_rx_func+0x480>
							{
								RxMediaState = WAITINGABAB;
80003322:	30 09       	mov	r9,0
80003324:	4d 48       	lddpc	r8,80003474 <phy_rx_func+0x5c8>
80003326:	91 09       	st.w	r8[0x0],r9
80003328:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
					}
				if ((RxBytesWaiting -= 2) <= 0)
8000332c:	4d 49       	lddpc	r9,8000347c <phy_rx_func+0x5d0>
8000332e:	72 08       	ld.w	r8,r9[0x0]
80003330:	20 28       	sub	r8,2
80003332:	93 08       	st.w	r9[0x0],r8
80003334:	c0 61       	brne	80003340 <phy_rx_func+0x494>
				{
					RxMediaState = WAITINGABAB;
80003336:	30 09       	mov	r9,0
80003338:	4c f8       	lddpc	r8,80003474 <phy_rx_func+0x5c8>
8000333a:	91 09       	st.w	r8[0x0],r9
8000333c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003340:	4d 98       	lddpc	r8,800034a4 <phy_rx_func+0x5f8>
80003342:	70 0a       	ld.w	r10,r8[0x0]
80003344:	4c a9       	lddpc	r9,8000346c <phy_rx_func+0x5c0>
80003346:	72 09       	ld.w	r9,r9[0x0]
80003348:	8e 5b       	ld.sh	r11,r7[0xa]
8000334a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000334e:	70 09       	ld.w	r9,r8[0x0]
80003350:	2f f9       	sub	r9,-1
80003352:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003354:	e0 49 00 ff 	cp.w	r9,255
80003358:	e0 88 00 13 	brls	8000337e <phy_rx_func+0x4d2>
						{
							RxMedia_IsFillingNext16 = 0;
8000335c:	30 09       	mov	r9,0
8000335e:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80003360:	4c 36       	lddpc	r6,8000346c <phy_rx_func+0x5c0>
80003362:	6c 0c       	ld.w	r12,r6[0x0]
80003364:	f0 1f 00 51 	mcall	800034a8 <phy_rx_func+0x5fc>
								payload_ptr = get_payload_idle_isr();
80003368:	4c 08       	lddpc	r8,80003468 <phy_rx_func+0x5bc>
8000336a:	70 0c       	ld.w	r12,r8[0x0]
8000336c:	f0 1f 00 39 	mcall	80003450 <phy_rx_func+0x5a4>
80003370:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
80003372:	c0 61       	brne	8000337e <phy_rx_func+0x4d2>
								{
									RxMediaState = WAITINGABAB;
80003374:	30 09       	mov	r9,0
80003376:	4c 08       	lddpc	r8,80003474 <phy_rx_func+0x5c8>
80003378:	91 09       	st.w	r8[0x0],r9
8000337a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
						}
				if ((RxBytesWaiting -= 2) <= 0){
8000337e:	4c 09       	lddpc	r9,8000347c <phy_rx_func+0x5d0>
80003380:	72 08       	ld.w	r8,r9[0x0]
80003382:	20 28       	sub	r8,2
80003384:	93 08       	st.w	r9[0x0],r8
80003386:	c0 61       	brne	80003392 <phy_rx_func+0x4e6>
					RxMediaState = WAITINGABAB;
80003388:	30 09       	mov	r9,0
8000338a:	4b b8       	lddpc	r8,80003474 <phy_rx_func+0x5c8>
8000338c:	91 09       	st.w	r8[0x0],r9
8000338e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003392:	4c 58       	lddpc	r8,800034a4 <phy_rx_func+0x5f8>
80003394:	70 0a       	ld.w	r10,r8[0x0]
80003396:	4b 69       	lddpc	r9,8000346c <phy_rx_func+0x5c0>
80003398:	72 09       	ld.w	r9,r9[0x0]
8000339a:	8e 6b       	ld.sh	r11,r7[0xc]
8000339c:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800033a0:	70 09       	ld.w	r9,r8[0x0]
800033a2:	2f f9       	sub	r9,-1
800033a4:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800033a6:	e0 49 00 ff 	cp.w	r9,255
800033aa:	e0 88 00 13 	brls	800033d0 <phy_rx_func+0x524>
						{
							RxMedia_IsFillingNext16 = 0;
800033ae:	30 09       	mov	r9,0
800033b0:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800033b2:	4a f6       	lddpc	r6,8000346c <phy_rx_func+0x5c0>
800033b4:	6c 0c       	ld.w	r12,r6[0x0]
800033b6:	f0 1f 00 3d 	mcall	800034a8 <phy_rx_func+0x5fc>
									payload_ptr = get_payload_idle_isr();
800033ba:	4a c8       	lddpc	r8,80003468 <phy_rx_func+0x5bc>
800033bc:	70 0c       	ld.w	r12,r8[0x0]
800033be:	f0 1f 00 25 	mcall	80003450 <phy_rx_func+0x5a4>
800033c2:	8d 0c       	st.w	r6[0x0],r12
									if(NULL == payload_ptr)
800033c4:	c0 61       	brne	800033d0 <phy_rx_func+0x524>
									{
										RxMediaState = WAITINGABAB;
800033c6:	30 09       	mov	r9,0
800033c8:	4a b8       	lddpc	r8,80003474 <phy_rx_func+0x5c8>
800033ca:	91 09       	st.w	r8[0x0],r9
800033cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
						}
				if ((RxBytesWaiting -= 2) <= 0){
800033d0:	4a b9       	lddpc	r9,8000347c <phy_rx_func+0x5d0>
800033d2:	72 08       	ld.w	r8,r9[0x0]
800033d4:	20 28       	sub	r8,2
800033d6:	93 08       	st.w	r9[0x0],r8
800033d8:	c0 61       	brne	800033e4 <phy_rx_func+0x538>
					RxMediaState = WAITINGABAB;
800033da:	30 09       	mov	r9,0
800033dc:	4a 68       	lddpc	r8,80003474 <phy_rx_func+0x5c8>
800033de:	91 09       	st.w	r8[0x0],r9
800033e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800033e4:	4b 08       	lddpc	r8,800034a4 <phy_rx_func+0x5f8>
800033e6:	70 0a       	ld.w	r10,r8[0x0]
800033e8:	4a 19       	lddpc	r9,8000346c <phy_rx_func+0x5c0>
800033ea:	72 09       	ld.w	r9,r9[0x0]
800033ec:	8e 7b       	ld.sh	r11,r7[0xe]
800033ee:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800033f2:	70 09       	ld.w	r9,r8[0x0]
800033f4:	2f f9       	sub	r9,-1
800033f6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800033f8:	e0 49 00 ff 	cp.w	r9,255
800033fc:	e0 88 00 13 	brls	80003422 <phy_rx_func+0x576>
						{
							RxMedia_IsFillingNext16 = 0;
80003400:	30 09       	mov	r9,0
80003402:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80003404:	49 a7       	lddpc	r7,8000346c <phy_rx_func+0x5c0>
80003406:	6e 0c       	ld.w	r12,r7[0x0]
80003408:	f0 1f 00 28 	mcall	800034a8 <phy_rx_func+0x5fc>
							payload_ptr = get_payload_idle_isr();
8000340c:	49 78       	lddpc	r8,80003468 <phy_rx_func+0x5bc>
8000340e:	70 0c       	ld.w	r12,r8[0x0]
80003410:	f0 1f 00 10 	mcall	80003450 <phy_rx_func+0x5a4>
80003414:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
80003416:	c0 61       	brne	80003422 <phy_rx_func+0x576>
							{
								RxMediaState = WAITINGABAB;
80003418:	30 09       	mov	r9,0
8000341a:	49 78       	lddpc	r8,80003474 <phy_rx_func+0x5c8>
8000341c:	91 09       	st.w	r8[0x0],r9
8000341e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80003422:	49 79       	lddpc	r9,8000347c <phy_rx_func+0x5d0>
80003424:	72 08       	ld.w	r8,r9[0x0]
80003426:	20 28       	sub	r8,2
80003428:	93 08       	st.w	r9[0x0],r8
8000342a:	c0 41       	brne	80003432 <phy_rx_func+0x586>
					RxMediaState = WAITINGABAB;
8000342c:	30 09       	mov	r9,0
8000342e:	49 28       	lddpc	r8,80003474 <phy_rx_func+0x5c8>
80003430:	91 09       	st.w	r8[0x0],r9
80003432:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003436:	00 00       	add	r0,r0
80003438:	00 00       	add	r0,r0
8000343a:	0a ac       	st.w	r5++,r12
8000343c:	00 00       	add	r0,r0
8000343e:	0a a8       	st.w	r5++,r8
80003440:	00 00       	add	r0,r0
80003442:	0a 8c       	andn	r12,r5
80003444:	00 00       	add	r0,r0
80003446:	0a c4       	st.b	r5++,r4
80003448:	00 00       	add	r0,r0
8000344a:	0a c2       	st.b	r5++,r2
8000344c:	00 00       	add	r0,r0
8000344e:	0a 90       	mov	r0,r5
80003450:	80 00       	ld.sh	r0,r0[0x0]
80003452:	2a ac       	sub	r12,-86
80003454:	00 00       	add	r0,r0
80003456:	0a 70       	tst	r0,r5
80003458:	80 00       	ld.sh	r0,r0[0x0]
8000345a:	4a 58       	lddpc	r8,800034ec <pdca_int_handler+0x3c>
8000345c:	00 00       	add	r0,r0
8000345e:	0a 94       	mov	r4,r5
80003460:	80 00       	ld.sh	r0,r0[0x0]
80003462:	29 f8       	sub	r8,-97
80003464:	00 00       	add	r0,r0
80003466:	0a c1       	st.b	r5++,r1
80003468:	00 00       	add	r0,r0
8000346a:	0a 74       	tst	r4,r5
8000346c:	00 00       	add	r0,r0
8000346e:	0a 84       	andn	r4,r5
80003470:	00 00       	add	r0,r0
80003472:	04 f4       	st.b	--r2,r4
80003474:	00 00       	add	r0,r0
80003476:	0a 9c       	mov	r12,r5
80003478:	00 00       	add	r0,r0
8000347a:	0a 6c       	and	r12,r5
8000347c:	00 00       	add	r0,r0
8000347e:	0a b0       	st.h	r5++,r0
80003480:	80 00       	ld.sh	r0,r0[0x0]
80003482:	c1 f4       	brge	800034c0 <pdca_int_handler+0x10>
80003484:	80 00       	ld.sh	r0,r0[0x0]
80003486:	5b 50       	cp.w	r0,-11
80003488:	00 00       	add	r0,r0
8000348a:	0a 48       	or	r8,r5
8000348c:	00 00       	add	r0,r0
8000348e:	0a 4a       	or	r10,r5
80003490:	00 00       	add	r0,r0
80003492:	0a c0       	st.b	r5++,r0
80003494:	00 00       	add	r0,r0
80003496:	0a a0       	st.w	r5++,r0
80003498:	00 00       	add	r0,r0
8000349a:	0a 5a       	eor	r10,r5
8000349c:	00 00       	add	r0,r0
8000349e:	0a 4b       	or	r11,r5
800034a0:	00 00       	add	r0,r0
800034a2:	0a 59       	eor	r9,r5
800034a4:	00 00       	add	r0,r0
800034a6:	0a 68       	and	r8,r5
800034a8:	80 00       	ld.sh	r0,r0[0x0]
800034aa:	2e 4c       	sub	r12,-28
800034ac:	00 00       	add	r0,r0
800034ae:	0a 4c       	or	r12,r5

800034b0 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
800034b0:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
800034b2:	49 88       	lddpc	r8,80003510 <pdca_int_handler+0x60>
800034b4:	11 89       	ld.ub	r9,r8[0x0]
800034b6:	ec 19 00 01 	eorl	r9,0x1
800034ba:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
800034bc:	11 89       	ld.ub	r9,r8[0x0]
800034be:	a5 69       	lsl	r9,0x4
800034c0:	2f c9       	sub	r9,-4
800034c2:	49 5a       	lddpc	r10,80003514 <pdca_int_handler+0x64>
800034c4:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
800034c6:	fe 7a 00 40 	mov	r10,-65472
800034ca:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
800034cc:	30 39       	mov	r9,3
800034ce:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
800034d0:	11 8a       	ld.ub	r10,r8[0x0]
800034d2:	a5 6a       	lsl	r10,0x4
800034d4:	2f ca       	sub	r10,-4
800034d6:	49 18       	lddpc	r8,80003518 <pdca_int_handler+0x68>
800034d8:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
800034da:	fe 78 00 00 	mov	r8,-65536
800034de:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800034e0:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
800034e2:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
800034e4:	48 e8       	lddpc	r8,8000351c <pdca_int_handler+0x6c>
800034e6:	70 08       	ld.w	r8,r8[0x0]
800034e8:	58 08       	cp.w	r8,0
800034ea:	c0 70       	breq	800034f8 <pdca_int_handler+0x48>
800034ec:	48 99       	lddpc	r9,80003510 <pdca_int_handler+0x60>
800034ee:	13 89       	ld.ub	r9,r9[0x0]
800034f0:	a5 69       	lsl	r9,0x4
800034f2:	48 ac       	lddpc	r12,80003518 <pdca_int_handler+0x68>
800034f4:	12 0c       	add	r12,r9
800034f6:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
800034f8:	48 a8       	lddpc	r8,80003520 <pdca_int_handler+0x70>
800034fa:	70 08       	ld.w	r8,r8[0x0]
800034fc:	58 08       	cp.w	r8,0
800034fe:	c0 70       	breq	8000350c <pdca_int_handler+0x5c>
80003500:	48 49       	lddpc	r9,80003510 <pdca_int_handler+0x60>
80003502:	13 89       	ld.ub	r9,r9[0x0]
80003504:	a5 69       	lsl	r9,0x4
80003506:	48 4c       	lddpc	r12,80003514 <pdca_int_handler+0x64>
80003508:	12 0c       	add	r12,r9
8000350a:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
8000350c:	d4 02       	popm	lr
8000350e:	d6 03       	rete
80003510:	00 00       	add	r0,r0
80003512:	3f 94       	mov	r4,-7
80003514:	00 00       	add	r0,r0
80003516:	3f bc       	mov	r12,-5
80003518:	00 00       	add	r0,r0
8000351a:	3f 9c       	mov	r12,-7
8000351c:	00 00       	add	r0,r0
8000351e:	0a c8       	st.b	r5++,r8
80003520:	00 00       	add	r0,r0
80003522:	0a cc       	st.b	r5++,r12

80003524 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003524:	fe 78 10 00 	mov	r8,-61440
80003528:	e0 69 0d c0 	mov	r9,3520
8000352c:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003530:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003534:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003538:	fe 78 34 00 	mov	r8,-52224
8000353c:	e0 69 80 00 	mov	r9,32768
80003540:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003542:	30 09       	mov	r9,0
80003544:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003546:	e0 69 04 21 	mov	r9,1057
8000354a:	ea 19 3f 20 	orh	r9,0x3f20
8000354e:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80003550:	e0 69 02 9f 	mov	r9,671
80003554:	ea 19 01 00 	orh	r9,0x100
80003558:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
8000355a:	e0 6a 04 02 	mov	r10,1026
8000355e:	ea 1a 3f 20 	orh	r10,0x3f20
80003562:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80003564:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003566:	5e fc       	retal	r12

80003568 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003568:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
8000356a:	30 19       	mov	r9,1
8000356c:	49 78       	lddpc	r8,800035c8 <local_start_PDC+0x60>
8000356e:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003570:	fe 78 00 00 	mov	r8,-65536
80003574:	30 7b       	mov	r11,7
80003576:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003578:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
8000357a:	49 59       	lddpc	r9,800035cc <local_start_PDC+0x64>
8000357c:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003580:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003582:	30 3a       	mov	r10,3
80003584:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003586:	30 1c       	mov	r12,1
80003588:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
8000358a:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
8000358c:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
8000358e:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003590:	30 2c       	mov	r12,2
80003592:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003594:	48 f9       	lddpc	r9,800035d0 <local_start_PDC+0x68>
80003596:	e0 68 5a 5a 	mov	r8,23130
8000359a:	ea 18 ab cd 	orh	r8,0xabcd
8000359e:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
800035a0:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
800035a2:	30 0e       	mov	lr,0
800035a4:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
800035a6:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
800035a8:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
800035aa:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
800035ac:	fe 78 00 40 	mov	r8,-65472
800035b0:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
800035b2:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
800035b4:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
800035b8:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
800035ba:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
800035bc:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
800035be:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
800035c0:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
800035c2:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800035c4:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
800035c6:	d8 02       	popm	pc
800035c8:	00 00       	add	r0,r0
800035ca:	3f 94       	mov	r4,-7
800035cc:	00 00       	add	r0,r0
800035ce:	3f 9c       	mov	r12,-7
800035d0:	00 00       	add	r0,r0
800035d2:	3f bc       	mov	r12,-5

800035d4 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
800035d4:	48 38       	lddpc	r8,800035e0 <register_rx_tx_func+0xc>
800035d6:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
800035d8:	48 38       	lddpc	r8,800035e4 <register_rx_tx_func+0x10>
800035da:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
800035dc:	5e fc       	retal	r12
800035de:	00 00       	add	r0,r0
800035e0:	00 00       	add	r0,r0
800035e2:	0a c8       	st.b	r5++,r8
800035e4:	00 00       	add	r0,r0
800035e6:	0a cc       	st.b	r5++,r12

800035e8 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
800035e8:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
800035ea:	fe 78 10 00 	mov	r8,-61440
800035ee:	30 29       	mov	r9,2
800035f0:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
800035f4:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800035f8:	10 99       	mov	r9,r8
800035fa:	f2 f8 01 60 	ld.w	r8,r9[352]
800035fe:	e2 18 00 02 	andl	r8,0x2,COH
80003602:	cf c0       	breq	800035fa <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003604:	fe 79 10 00 	mov	r9,-61440
80003608:	f2 f8 01 60 	ld.w	r8,r9[352]
8000360c:	e2 18 00 02 	andl	r8,0x2,COH
80003610:	cf c1       	brne	80003608 <ssc_init+0x20>
				
    INTC_register_interrupt (
80003612:	30 3a       	mov	r10,3
80003614:	36 0b       	mov	r11,96
80003616:	48 bc       	lddpc	r12,80003640 <ssc_init+0x58>
80003618:	f0 1f 00 0b 	mcall	80003644 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
8000361c:	f0 1f 00 0b 	mcall	80003648 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80003620:	f0 1f 00 0b 	mcall	8000364c <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003624:	fe 79 00 00 	mov	r9,-65536
80003628:	30 18       	mov	r8,1
8000362a:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
8000362c:	fe 7a 00 40 	mov	r10,-65472
80003630:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003632:	e0 6b 01 01 	mov	r11,257
80003636:	fe 7a 34 00 	mov	r10,-52224
8000363a:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
8000363c:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
8000363e:	d8 02       	popm	pc
80003640:	80 00       	ld.sh	r0,r0[0x0]
80003642:	34 b0       	mov	r0,75
80003644:	80 00       	ld.sh	r0,r0[0x0]
80003646:	40 90       	lddsp	r0,sp[0x24]
80003648:	80 00       	ld.sh	r0,r0[0x0]
8000364a:	35 24       	mov	r4,82
8000364c:	80 00       	ld.sh	r0,r0[0x0]
8000364e:	35 68       	mov	r8,86

80003650 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003650:	48 28       	lddpc	r8,80003658 <xcmp_register_app_list+0x8>
80003652:	91 0c       	st.w	r8[0x0],r12
}
80003654:	5e fc       	retal	r12
80003656:	00 00       	add	r0,r0
80003658:	00 00       	add	r0,r0
8000365a:	3f dc       	mov	r12,-3

8000365c <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
8000365c:	eb cd 40 80 	pushm	r7,lr
80003660:	fa cd 01 00 	sub	sp,sp,256
80003664:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003666:	16 98       	mov	r8,r11
80003668:	2f 08       	sub	r8,-16
8000366a:	af a8       	sbr	r8,0xe
8000366c:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
8000366e:	3f f8       	mov	r8,-1
80003670:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003672:	30 b9       	mov	r9,11
80003674:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003676:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003678:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
8000367a:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000367c:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
8000367e:	f6 ca ff fe 	sub	r10,r11,-2
80003682:	18 9b       	mov	r11,r12
80003684:	fa cc ff f0 	sub	r12,sp,-16
80003688:	f0 1f 00 05 	mcall	8000369c <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
8000368c:	2f e7       	sub	r7,-2
8000368e:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003690:	1a 9c       	mov	r12,sp
80003692:	f0 1f 00 04 	mcall	800036a0 <xcmp_tx+0x44>
}
80003696:	2c 0d       	sub	sp,-256
80003698:	e3 cd 80 80 	ldm	sp++,r7,pc
8000369c:	80 00       	ld.sh	r0,r0[0x0]
8000369e:	63 24       	ld.w	r4,r1[0x48]
800036a0:	80 00       	ld.sh	r0,r0[0x0]
800036a2:	3a f4       	mov	r4,-81

800036a4 <xcmp_audio_route_speaker>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_audio_route_speaker(void)
{
800036a4:	d4 01       	pushm	lr
800036a6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
800036aa:	e0 68 04 14 	mov	r8,1044
800036ae:	ba 18       	st.h	sp[0x2],r8
		
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
800036b0:	fa c8 ff fc 	sub	r8,sp,-4
		
	ptr->Function = Routing_Func_Update_Source;
800036b4:	30 1a       	mov	r10,1
800036b6:	b0 8a       	st.b	r8[0x0],r10
		
		
	unsigned short NumberofRoutings =  4;//2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
800036b8:	30 09       	mov	r9,0
800036ba:	b0 99       	st.b	r8[0x1],r9
	ptr->NumberofRoutings[1] =  NumberofRoutings & 0xFF;
800036bc:	30 49       	mov	r9,4
800036be:	b0 a9       	st.b	r8[0x2],r9
		
	
	ptr->RoutingData[0].audioInput = IN_Pre_Speaker_Audio_Data;//IN_Pre_Speaker_Audio_Data;//IN_Microphone;//IN_Option_Board;
800036c0:	30 db       	mov	r11,13
800036c2:	b0 bb       	st.b	r8[0x3],r11
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;//OUT_Option_Board;//OUT_Microphone_Data;//
800036c4:	30 c9       	mov	r9,12
800036c6:	b0 c9       	st.b	r8[0x4],r9
	
	ptr->RoutingData[1].audioInput = IN_Option_Board;//IN_Option_Board;
800036c8:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = OUT_Speaker;//OUT_Microphone_Data;//
800036ca:	b0 ea       	st.b	r8[0x6],r10
	
	ptr->RoutingData[2].audioInput = IN_Microphone;//IN_Option_Board;
800036cc:	b0 fa       	st.b	r8[0x7],r10
	ptr->RoutingData[2].audioOutput =OUT_Option_Board;// OUT_Speaker;
800036ce:	f1 69 00 08 	st.b	r8[8],r9
	
	ptr->RoutingData[3].audioInput = IN_Option_Board;
800036d2:	f1 69 00 09 	st.b	r8[9],r9
	ptr->RoutingData[3].audioOutput = OUT_Microphone_Data;//OUT_Speaker;//
800036d6:	f1 6b 00 0a 	st.b	r8[10],r11
		
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
800036da:	30 bb       	mov	r11,11
800036dc:	fa cc ff fe 	sub	r12,sp,-2
800036e0:	f0 1f 00 02 	mcall	800036e8 <xcmp_audio_route_speaker+0x44>
}
800036e4:	2c dd       	sub	sp,-204
800036e6:	d8 02       	popm	pc
800036e8:	80 00       	ld.sh	r0,r0[0x0]
800036ea:	36 5c       	mov	r12,101

800036ec <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
800036ec:	d4 01       	pushm	lr
800036ee:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
800036f2:	fe 78 b4 00 	mov	r8,-19456
800036f6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
800036f8:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///
	ptr->XCMPVersion[0] = 0x08;
800036fc:	30 89       	mov	r9,8
800036fe:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003700:	30 19       	mov	r9,1
80003702:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003704:	30 09       	mov	r9,0
80003706:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003708:	30 5a       	mov	r10,5
8000370a:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
8000370c:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
8000370e:	30 7a       	mov	r10,7
80003710:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003712:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003714:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003716:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
8000371a:	30 9b       	mov	r11,9
8000371c:	fa cc ff fe 	sub	r12,sp,-2
80003720:	f0 1f 00 02 	mcall	80003728 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003724:	2c dd       	sub	sp,-204
80003726:	d8 02       	popm	pc
80003728:	80 00       	ld.sh	r0,r0[0x0]
8000372a:	36 5c       	mov	r12,101

8000372c <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
8000372c:	d4 01       	pushm	lr
8000372e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003732:	fe 78 80 00 	mov	r8,-32768
80003736:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003738:	30 38       	mov	r8,3
8000373a:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
8000373c:	30 1b       	mov	r11,1
8000373e:	fa cc ff fe 	sub	r12,sp,-2
80003742:	f0 1f 00 03 	mcall	8000374c <xcmp_opcode_not_supported+0x20>
}
80003746:	2c dd       	sub	sp,-204
80003748:	d8 02       	popm	pc
8000374a:	00 00       	add	r0,r0
8000374c:	80 00       	ld.sh	r0,r0[0x0]
8000374e:	36 5c       	mov	r12,101

80003750 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003750:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003752:	96 88       	ld.uh	r8,r11[0x0]
80003754:	e2 18 f0 00 	andl	r8,0xf000,COH
80003758:	e0 48 80 00 	cp.w	r8,32768
8000375c:	c0 f0       	breq	8000377a <xcmp_exec_func+0x2a>
8000375e:	e0 48 b0 00 	cp.w	r8,45056
80003762:	c1 20       	breq	80003786 <xcmp_exec_func+0x36>
80003764:	58 08       	cp.w	r8,0
80003766:	c1 51       	brne	80003790 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003768:	78 08       	ld.w	r8,r12[0x0]
8000376a:	58 08       	cp.w	r8,0
8000376c:	c0 40       	breq	80003774 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000376e:	16 9c       	mov	r12,r11
80003770:	5d 18       	icall	r8
80003772:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80003774:	f0 1f 00 08 	mcall	80003794 <xcmp_exec_func+0x44>
80003778:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000377a:	78 18       	ld.w	r8,r12[0x4]
8000377c:	58 08       	cp.w	r8,0
8000377e:	c0 90       	breq	80003790 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003780:	16 9c       	mov	r12,r11
80003782:	5d 18       	icall	r8
80003784:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003786:	78 28       	ld.w	r8,r12[0x8]
80003788:	58 08       	cp.w	r8,0
8000378a:	c0 30       	breq	80003790 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
8000378c:	16 9c       	mov	r12,r11
8000378e:	5d 18       	icall	r8
80003790:	d8 02       	popm	pc
80003792:	00 00       	add	r0,r0
80003794:	80 00       	ld.sh	r0,r0[0x0]
80003796:	37 2c       	mov	r12,114

80003798 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80003798:	d4 01       	pushm	lr
8000379a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000379e:	e0 68 04 09 	mov	r8,1033
800037a2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
800037a4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
800037a8:	30 19       	mov	r9,1
800037aa:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
800037ac:	30 09       	mov	r9,0
800037ae:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
800037b0:	30 ca       	mov	r10,12
800037b2:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
800037b4:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
800037b6:	fb 69 00 08 	st.b	sp[8],r9
800037ba:	fa c8 ff f7 	sub	r8,sp,-9
800037be:	b0 89       	st.b	r8[0x0],r9
800037c0:	fa c8 ff f6 	sub	r8,sp,-10
800037c4:	b0 89       	st.b	r8[0x0],r9
800037c6:	fa c8 ff f5 	sub	r8,sp,-11
800037ca:	b0 89       	st.b	r8[0x0],r9
800037cc:	fa c8 ff f4 	sub	r8,sp,-12
800037d0:	b0 89       	st.b	r8[0x0],r9
800037d2:	fa c8 ff f3 	sub	r8,sp,-13
800037d6:	b0 89       	st.b	r8[0x0],r9
800037d8:	fa c8 ff f2 	sub	r8,sp,-14
800037dc:	b0 89       	st.b	r8[0x0],r9
800037de:	fa c8 ff f1 	sub	r8,sp,-15
800037e2:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800037e4:	30 cb       	mov	r11,12
800037e6:	fa cc ff fe 	sub	r12,sp,-2
800037ea:	f0 1f 00 03 	mcall	800037f4 <xcmp_IdleTestTone+0x5c>
}
800037ee:	2c dd       	sub	sp,-204
800037f0:	d8 02       	popm	pc
800037f2:	00 00       	add	r0,r0
800037f4:	80 00       	ld.sh	r0,r0[0x0]
800037f6:	36 5c       	mov	r12,101

800037f8 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800037f8:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
800037fa:	f0 1f 00 0d 	mcall	8000382c <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800037fe:	48 dc       	lddpc	r12,80003830 <xcmp_init+0x38>
80003800:	f0 1f 00 0d 	mcall	80003834 <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80003804:	30 4b       	mov	r11,4
80003806:	31 4c       	mov	r12,20
80003808:	f0 1f 00 0c 	mcall	80003838 <xcmp_init+0x40>
8000380c:	48 c8       	lddpc	r8,8000383c <xcmp_init+0x44>
8000380e:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80003810:	30 09       	mov	r9,0
80003812:	1a d9       	st.w	--sp,r9
80003814:	1a d9       	st.w	--sp,r9
80003816:	1a d9       	st.w	--sp,r9
80003818:	30 38       	mov	r8,3
8000381a:	e0 6a 01 80 	mov	r10,384
8000381e:	48 9b       	lddpc	r11,80003840 <xcmp_init+0x48>
80003820:	48 9c       	lddpc	r12,80003844 <xcmp_init+0x4c>
80003822:	f0 1f 00 0a 	mcall	80003848 <xcmp_init+0x50>
80003826:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
80003828:	d8 02       	popm	pc
8000382a:	00 00       	add	r0,r0
8000382c:	80 00       	ld.sh	r0,r0[0x0]
8000382e:	3b d8       	mov	r8,-67
80003830:	80 00       	ld.sh	r0,r0[0x0]
80003832:	39 48       	mov	r8,-108
80003834:	80 00       	ld.sh	r0,r0[0x0]
80003836:	39 94       	mov	r4,-103
80003838:	80 00       	ld.sh	r0,r0[0x0]
8000383a:	4f 2c       	lddpc	r12,80003a00 <xnl_tx_process+0x34>
8000383c:	00 00       	add	r0,r0
8000383e:	0a dc       	st.w	--r5,r12
80003840:	80 00       	ld.sh	r0,r0[0x0]
80003842:	c2 0c       	rcall	80003882 <xcmp_rx_process+0x36>
80003844:	80 00       	ld.sh	r0,r0[0x0]
80003846:	38 4c       	mov	r12,-124
80003848:	80 00       	ld.sh	r0,r0[0x0]
8000384a:	56 00       	stdsp	sp[0x180],r0

8000384c <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
8000384c:	d4 31       	pushm	r0-r7,lr
8000384e:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
80003850:	4b 16       	lddpc	r6,80003914 <xcmp_rx_process+0xc8>
80003852:	30 05       	mov	r5,0
80003854:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003856:	4b 13       	lddpc	r3,80003918 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80003858:	4b 12       	lddpc	r2,8000391c <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000385a:	4b 21       	lddpc	r1,80003920 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000385c:	4b 20       	lddpc	r0,80003924 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
8000385e:	6c 0c       	ld.w	r12,r6[0x0]
80003860:	0a 99       	mov	r9,r5
80003862:	08 9a       	mov	r10,r4
80003864:	1a 9b       	mov	r11,sp
80003866:	f0 1f 00 31 	mcall	80003928 <xcmp_rx_process+0xdc>
8000386a:	58 1c       	cp.w	r12,1
8000386c:	cf 91       	brne	8000385e <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000386e:	40 0b       	lddsp	r11,sp[0x0]
80003870:	58 0b       	cp.w	r11,0
80003872:	cf 60       	breq	8000385e <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80003874:	96 0a       	ld.sh	r10,r11[0x0]
80003876:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000387a:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000387e:	59 c8       	cp.w	r8,28
80003880:	c1 e0       	breq	800038bc <xcmp_rx_process+0x70>
80003882:	e0 89 00 07 	brgt	80003890 <xcmp_rx_process+0x44>
80003886:	58 e8       	cp.w	r8,14
80003888:	c0 e0       	breq	800038a4 <xcmp_rx_process+0x58>
8000388a:	58 f8       	cp.w	r8,15
8000388c:	c2 41       	brne	800038d4 <xcmp_rx_process+0x88>
8000388e:	c0 f8       	rjmp	800038ac <xcmp_rx_process+0x60>
80003890:	e0 48 01 09 	cp.w	r8,265
80003894:	c1 80       	breq	800038c4 <xcmp_rx_process+0x78>
80003896:	e0 48 01 0a 	cp.w	r8,266
8000389a:	c1 90       	breq	800038cc <xcmp_rx_process+0x80>
8000389c:	e0 48 00 2c 	cp.w	r8,44
800038a0:	c1 a1       	brne	800038d4 <xcmp_rx_process+0x88>
800038a2:	c0 98       	rjmp	800038b4 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
800038a4:	4a 2c       	lddpc	r12,8000392c <xcmp_rx_process+0xe0>
800038a6:	f0 1f 00 23 	mcall	80003930 <xcmp_rx_process+0xe4>
					break;
800038aa:	c2 f8       	rjmp	80003908 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
800038ac:	4a 2c       	lddpc	r12,80003934 <xcmp_rx_process+0xe8>
800038ae:	f0 1f 00 21 	mcall	80003930 <xcmp_rx_process+0xe4>
					break;
800038b2:	c2 b8       	rjmp	80003908 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800038b4:	4a 1c       	lddpc	r12,80003938 <xcmp_rx_process+0xec>
800038b6:	f0 1f 00 1f 	mcall	80003930 <xcmp_rx_process+0xe4>
					break;
800038ba:	c2 78       	rjmp	80003908 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800038bc:	04 9c       	mov	r12,r2
800038be:	f0 1f 00 1d 	mcall	80003930 <xcmp_rx_process+0xe4>
						, ptr);
					break;
800038c2:	c2 38       	rjmp	80003908 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800038c4:	02 9c       	mov	r12,r1
800038c6:	f0 1f 00 1b 	mcall	80003930 <xcmp_rx_process+0xe4>
					break;
800038ca:	c1 f8       	rjmp	80003908 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800038cc:	00 9c       	mov	r12,r0
800038ce:	f0 1f 00 19 	mcall	80003930 <xcmp_rx_process+0xe4>
					break;
800038d2:	c1 b8       	rjmp	80003908 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800038d4:	12 98       	mov	r8,r9
800038d6:	e2 18 04 00 	andl	r8,0x400,COH
800038da:	c0 70       	breq	800038e8 <xcmp_rx_process+0x9c>
800038dc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800038e0:	e0 48 00 68 	cp.w	r8,104
800038e4:	e0 8a 00 08 	brle	800038f4 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800038e8:	e2 19 f0 00 	andl	r9,0xf000,COH
800038ec:	c0 e1       	brne	80003908 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800038ee:	f0 1f 00 14 	mcall	8000393c <xcmp_rx_process+0xf0>
800038f2:	c0 b8       	rjmp	80003908 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800038f4:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800038f8:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800038fc:	49 19       	lddpc	r9,80003940 <xcmp_rx_process+0xf4>
800038fe:	72 08       	ld.w	r8,r9[0x0]
80003900:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80003904:	f0 1f 00 0b 	mcall	80003930 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003908:	66 0c       	ld.w	r12,r3[0x0]
8000390a:	40 0b       	lddsp	r11,sp[0x0]
8000390c:	f0 1f 00 0e 	mcall	80003944 <xcmp_rx_process+0xf8>
80003910:	ca 7b       	rjmp	8000385e <xcmp_rx_process+0x12>
80003912:	00 00       	add	r0,r0
80003914:	00 00       	add	r0,r0
80003916:	0a dc       	st.w	--r5,r12
80003918:	00 00       	add	r0,r0
8000391a:	0a 90       	mov	r0,r5
8000391c:	00 00       	add	r0,r0
8000391e:	0a ec       	st.h	--r5,r12
80003920:	00 00       	add	r0,r0
80003922:	0a e0       	st.h	--r5,r0
80003924:	00 00       	add	r0,r0
80003926:	0a f8       	st.b	--r5,r8
80003928:	80 00       	ld.sh	r0,r0[0x0]
8000392a:	4b c8       	lddpc	r8,80003a18 <xnl_tx_process+0x4c>
8000392c:	00 00       	add	r0,r0
8000392e:	0b 10       	ld.sh	r0,r5++
80003930:	80 00       	ld.sh	r0,r0[0x0]
80003932:	37 50       	mov	r0,117
80003934:	00 00       	add	r0,r0
80003936:	0a d0       	st.w	--r5,r0
80003938:	00 00       	add	r0,r0
8000393a:	0b 04       	ld.w	r4,r5++
8000393c:	80 00       	ld.sh	r0,r0[0x0]
8000393e:	37 2c       	mov	r12,114
80003940:	00 00       	add	r0,r0
80003942:	3f dc       	mov	r12,-3
80003944:	80 00       	ld.sh	r0,r0[0x0]
80003946:	2a 30       	sub	r0,-93

80003948 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80003948:	eb cd 40 90 	pushm	r4,r7,lr
8000394c:	20 1d       	sub	sp,4
8000394e:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80003952:	48 c8       	lddpc	r8,80003980 <xcmp_rx+0x38>
80003954:	70 0c       	ld.w	r12,r8[0x0]
80003956:	f0 1f 00 0c 	mcall	80003984 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000395a:	c1 00       	breq	8000397a <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000395c:	fa c7 ff fc 	sub	r7,sp,-4
80003960:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80003962:	e0 6a 00 ca 	mov	r10,202
80003966:	08 9b       	mov	r11,r4
80003968:	f0 1f 00 08 	mcall	80003988 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
8000396c:	48 88       	lddpc	r8,8000398c <xcmp_rx+0x44>
8000396e:	70 0c       	ld.w	r12,r8[0x0]
80003970:	30 09       	mov	r9,0
80003972:	12 9a       	mov	r10,r9
80003974:	1a 9b       	mov	r11,sp
80003976:	f0 1f 00 07 	mcall	80003990 <xcmp_rx+0x48>
	}	
}
8000397a:	2f fd       	sub	sp,-4
8000397c:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80003980:	00 00       	add	r0,r0
80003982:	0a 90       	mov	r0,r5
80003984:	80 00       	ld.sh	r0,r0[0x0]
80003986:	2d 68       	sub	r8,-42
80003988:	80 00       	ld.sh	r0,r0[0x0]
8000398a:	63 24       	ld.w	r4,r1[0x48]
8000398c:	00 00       	add	r0,r0
8000398e:	0a dc       	st.w	--r5,r12
80003990:	80 00       	ld.sh	r0,r0[0x0]
80003992:	4d d4       	lddpc	r4,80003b04 <xnl_tx+0x10>

80003994 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80003994:	48 28       	lddpc	r8,8000399c <xnl_register_xcmp_func+0x8>
80003996:	91 0c       	st.w	r8[0x0],r12
}
80003998:	5e fc       	retal	r12
8000399a:	00 00       	add	r0,r0
8000399c:	00 00       	add	r0,r0
8000399e:	0b 40       	ld.w	r0,--r5

800039a0 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
800039a0:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
800039a2:	48 88       	lddpc	r8,800039c0 <xnl_get_msg_ack_func+0x20>
800039a4:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
800039a6:	98 49       	ld.sh	r9,r12[0x8]
800039a8:	f0 09 19 00 	cp.h	r9,r8
800039ac:	c0 81       	brne	800039bc <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
800039ae:	48 68       	lddpc	r8,800039c4 <xnl_get_msg_ack_func+0x24>
800039b0:	70 0c       	ld.w	r12,r8[0x0]
800039b2:	30 09       	mov	r9,0
800039b4:	12 9a       	mov	r10,r9
800039b6:	12 9b       	mov	r11,r9
800039b8:	f0 1f 00 04 	mcall	800039c8 <xnl_get_msg_ack_func+0x28>
800039bc:	d8 02       	popm	pc
800039be:	00 00       	add	r0,r0
800039c0:	00 00       	add	r0,r0
800039c2:	0b 20       	ld.uh	r0,r5++
800039c4:	00 00       	add	r0,r0
800039c6:	0b 1c       	ld.sh	r12,r5++
800039c8:	80 00       	ld.sh	r0,r0[0x0]
800039ca:	4d d4       	lddpc	r4,80003b3c <xnl_tx+0x48>

800039cc <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
800039cc:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800039ce:	4a 86       	lddpc	r6,80003a6c <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800039d0:	4a 82       	lddpc	r2,80003a70 <xnl_tx_process+0xa4>
800039d2:	4a 94       	lddpc	r4,80003a74 <xnl_tx_process+0xa8>
800039d4:	30 07       	mov	r7,0
800039d6:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800039d8:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800039da:	4a 85       	lddpc	r5,80003a78 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800039dc:	4a 83       	lddpc	r3,80003a7c <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800039de:	6c 08       	ld.w	r8,r6[0x0]
800039e0:	58 08       	cp.w	r8,0
800039e2:	c0 40       	breq	800039ea <xnl_tx_process+0x1e>
800039e4:	58 18       	cp.w	r8,1
800039e6:	cf d1       	brne	800039e0 <xnl_tx_process+0x14>
800039e8:	c2 08       	rjmp	80003a28 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800039ea:	64 0c       	ld.w	r12,r2[0x0]
800039ec:	0e 99       	mov	r9,r7
800039ee:	02 9a       	mov	r10,r1
800039f0:	08 9b       	mov	r11,r4
800039f2:	f0 1f 00 24 	mcall	80003a80 <xnl_tx_process+0xb4>
800039f6:	58 1c       	cp.w	r12,1
800039f8:	cf 31       	brne	800039de <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800039fa:	68 0c       	ld.w	r12,r4[0x0]
800039fc:	58 0c       	cp.w	r12,0
800039fe:	cf 00       	breq	800039de <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80003a00:	98 28       	ld.sh	r8,r12[0x4]
80003a02:	e0 08 19 00 	cp.h	r8,r0
80003a06:	c0 41       	brne	80003a0e <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
80003a08:	f0 1f 00 1f 	mcall	80003a84 <xnl_tx_process+0xb8>
						break;
80003a0c:	ce 9b       	rjmp	800039de <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80003a0e:	f0 1f 00 1f 	mcall	80003a88 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80003a12:	30 18       	mov	r8,1
80003a14:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80003a16:	66 0c       	ld.w	r12,r3[0x0]
80003a18:	0e 99       	mov	r9,r7
80003a1a:	0e 9a       	mov	r10,r7
80003a1c:	0e 9b       	mov	r11,r7
80003a1e:	f0 1f 00 19 	mcall	80003a80 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
80003a22:	30 18       	mov	r8,1
80003a24:	8d 08       	st.w	r6[0x0],r8
80003a26:	cd cb       	rjmp	800039de <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://ACKdata/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80003a28:	66 0c       	ld.w	r12,r3[0x0]
80003a2a:	0e 99       	mov	r9,r7
80003a2c:	36 4a       	mov	r10,100
80003a2e:	0e 9b       	mov	r11,r7
80003a30:	f0 1f 00 14 	mcall	80003a80 <xnl_tx_process+0xb4>
80003a34:	58 1c       	cp.w	r12,1
80003a36:	c0 81       	brne	80003a46 <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//ADK500ms,freertos
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
80003a38:	49 58       	lddpc	r8,80003a8c <xnl_tx_process+0xc0>
80003a3a:	70 0c       	ld.w	r12,r8[0x0]
80003a3c:	68 0b       	ld.w	r11,r4[0x0]
80003a3e:	f0 1f 00 15 	mcall	80003a90 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80003a42:	8d 07       	st.w	r6[0x0],r7
80003a44:	cc db       	rjmp	800039de <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80003a46:	6a 08       	ld.w	r8,r5[0x0]
80003a48:	58 38       	cp.w	r8,3
80003a4a:	e0 89 00 09 	brgt	80003a5c <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80003a4e:	68 0c       	ld.w	r12,r4[0x0]
80003a50:	f0 1f 00 0e 	mcall	80003a88 <xnl_tx_process+0xbc>
						xnl_send_times++;
80003a54:	6a 08       	ld.w	r8,r5[0x0]
80003a56:	2f f8       	sub	r8,-1
80003a58:	8b 08       	st.w	r5[0x0],r8
80003a5a:	cc 2b       	rjmp	800039de <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80003a5c:	48 c8       	lddpc	r8,80003a8c <xnl_tx_process+0xc0>
80003a5e:	70 0c       	ld.w	r12,r8[0x0]
80003a60:	68 0b       	ld.w	r11,r4[0x0]
80003a62:	f0 1f 00 0c 	mcall	80003a90 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80003a66:	8d 07       	st.w	r6[0x0],r7
80003a68:	cb bb       	rjmp	800039de <xnl_tx_process+0x12>
80003a6a:	00 00       	add	r0,r0
80003a6c:	00 00       	add	r0,r0
80003a6e:	0b 3c       	ld.ub	r12,r5++
80003a70:	00 00       	add	r0,r0
80003a72:	0b 30       	ld.ub	r0,r5++
80003a74:	00 00       	add	r0,r0
80003a76:	0b 34       	ld.ub	r4,r5++
80003a78:	00 00       	add	r0,r0
80003a7a:	0b 2c       	ld.uh	r12,r5++
80003a7c:	00 00       	add	r0,r0
80003a7e:	0b 1c       	ld.sh	r12,r5++
80003a80:	80 00       	ld.sh	r0,r0[0x0]
80003a82:	4b c8       	lddpc	r8,80003b70 <xnl_tx+0x7c>
80003a84:	80 00       	ld.sh	r0,r0[0x0]
80003a86:	4a 58       	lddpc	r8,80003b18 <xnl_tx+0x24>
80003a88:	80 00       	ld.sh	r0,r0[0x0]
80003a8a:	2a 50       	sub	r0,-91
80003a8c:	00 00       	add	r0,r0
80003a8e:	0a 90       	mov	r0,r5
80003a90:	80 00       	ld.sh	r0,r0[0x0]
80003a92:	2a 30       	sub	r0,-93

80003a94 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80003a94:	eb cd 40 fe 	pushm	r1-r7,lr
80003a98:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80003a9a:	49 26       	lddpc	r6,80003ae0 <xnl_rx_process+0x4c>
80003a9c:	30 05       	mov	r5,0
80003a9e:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80003aa0:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80003aa2:	49 11       	lddpc	r1,80003ae4 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80003aa4:	49 12       	lddpc	r2,80003ae8 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80003aa6:	6c 0c       	ld.w	r12,r6[0x0]
80003aa8:	0a 99       	mov	r9,r5
80003aaa:	08 9a       	mov	r10,r4
80003aac:	1a 9b       	mov	r11,sp
80003aae:	f0 1f 00 10 	mcall	80003aec <xnl_rx_process+0x58>
80003ab2:	58 1c       	cp.w	r12,1
80003ab4:	cf 91       	brne	80003aa6 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80003ab6:	40 0c       	lddsp	r12,sp[0x0]
80003ab8:	58 0c       	cp.w	r12,0
80003aba:	cf 60       	breq	80003aa6 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80003abc:	98 28       	ld.sh	r8,r12[0x4]
80003abe:	e6 08 19 00 	cp.h	r8,r3
80003ac2:	e0 8b 00 0a 	brhi	80003ad6 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80003ac6:	5c 78       	castu.h	r8
80003ac8:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80003acc:	58 09       	cp.w	r9,0
80003ace:	c0 40       	breq	80003ad6 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80003ad0:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80003ad4:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80003ad6:	62 0c       	ld.w	r12,r1[0x0]
80003ad8:	40 0b       	lddsp	r11,sp[0x0]
80003ada:	f0 1f 00 06 	mcall	80003af0 <xnl_rx_process+0x5c>
80003ade:	ce 4b       	rjmp	80003aa6 <xnl_rx_process+0x12>
80003ae0:	00 00       	add	r0,r0
80003ae2:	0a ac       	st.w	r5++,r12
80003ae4:	00 00       	add	r0,r0
80003ae6:	0a 90       	mov	r0,r5
80003ae8:	00 00       	add	r0,r0
80003aea:	04 fc       	st.b	--r2,r12
80003aec:	80 00       	ld.sh	r0,r0[0x0]
80003aee:	4b c8       	lddpc	r8,80003bdc <xnl_init+0x4>
80003af0:	80 00       	ld.sh	r0,r0[0x0]
80003af2:	2a 30       	sub	r0,-93

80003af4 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80003af4:	eb cd 40 c0 	pushm	r6-r7,lr
80003af8:	20 1d       	sub	sp,4
80003afa:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80003afc:	98 39       	ld.sh	r9,r12[0x6]
80003afe:	3f f8       	mov	r8,-1
80003b00:	f0 09 19 00 	cp.h	r9,r8
80003b04:	c0 a1       	brne	80003b18 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80003b06:	4a e9       	lddpc	r9,80003bbc <xnl_tx+0xc8>
80003b08:	13 88       	ld.ub	r8,r9[0x0]
80003b0a:	2f f8       	sub	r8,-1
80003b0c:	5c 58       	castu.b	r8
80003b0e:	b2 88       	st.b	r9[0x0],r8
80003b10:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80003b14:	a9 a8       	sbr	r8,0x8
80003b16:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80003b18:	8c 49       	ld.sh	r9,r6[0x8]
80003b1a:	3f f8       	mov	r8,-1
80003b1c:	f0 09 19 00 	cp.h	r9,r8
80003b20:	c0 41       	brne	80003b28 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80003b22:	4a 88       	lddpc	r8,80003bc0 <xnl_tx+0xcc>
80003b24:	90 18       	ld.sh	r8,r8[0x2]
80003b26:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80003b28:	8c 59       	ld.sh	r9,r6[0xa]
80003b2a:	3f f8       	mov	r8,-1
80003b2c:	f0 09 19 00 	cp.h	r9,r8
80003b30:	c0 41       	brne	80003b38 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80003b32:	4a 48       	lddpc	r8,80003bc0 <xnl_tx+0xcc>
80003b34:	90 28       	ld.sh	r8,r8[0x4]
80003b36:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80003b38:	8c 69       	ld.sh	r9,r6[0xc]
80003b3a:	3f f8       	mov	r8,-1
80003b3c:	f0 09 19 00 	cp.h	r9,r8
80003b40:	c0 e1       	brne	80003b5c <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80003b42:	4a 08       	lddpc	r8,80003bc0 <xnl_tx+0xcc>
80003b44:	90 49       	ld.sh	r9,r8[0x8]
80003b46:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80003b48:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80003b4a:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80003b4c:	90 49       	ld.sh	r9,r8[0x8]
80003b4e:	e0 19 ff 00 	andl	r9,0xff00
80003b52:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80003b56:	f3 e8 10 08 	or	r8,r9,r8
80003b5a:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80003b5c:	0d 98       	ld.ub	r8,r6[0x1]
80003b5e:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80003b60:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80003b64:	10 0c       	add	r12,r8
80003b66:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80003b68:	58 0c       	cp.w	r12,0
80003b6a:	e0 89 00 04 	brgt	80003b72 <xnl_tx+0x7e>
80003b6e:	30 09       	mov	r9,0
80003b70:	c0 d8       	rjmp	80003b8a <xnl_tx+0x96>
80003b72:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80003b76:	2f ec       	sub	r12,-2
80003b78:	30 09       	mov	r9,0
80003b7a:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80003b7c:	15 1b       	ld.sh	r11,r10++
80003b7e:	f6 09 00 09 	add	r9,r11,r9
80003b82:	5c 89       	casts.h	r9
		indextohWord     += 1;
80003b84:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80003b86:	18 38       	cp.w	r8,r12
80003b88:	cf a1       	brne	80003b7c <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80003b8a:	5c 39       	neg	r9
80003b8c:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80003b8e:	48 e8       	lddpc	r8,80003bc4 <xnl_tx+0xd0>
80003b90:	70 0c       	ld.w	r12,r8[0x0]
80003b92:	f0 1f 00 0e 	mcall	80003bc8 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80003b96:	c1 00       	breq	80003bb6 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80003b98:	fa c7 ff fc 	sub	r7,sp,-4
80003b9c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80003b9e:	e0 6a 01 00 	mov	r10,256
80003ba2:	0c 9b       	mov	r11,r6
80003ba4:	f0 1f 00 0a 	mcall	80003bcc <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80003ba8:	48 a8       	lddpc	r8,80003bd0 <xnl_tx+0xdc>
80003baa:	70 0c       	ld.w	r12,r8[0x0]
80003bac:	30 09       	mov	r9,0
80003bae:	12 9a       	mov	r10,r9
80003bb0:	1a 9b       	mov	r11,sp
80003bb2:	f0 1f 00 09 	mcall	80003bd4 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80003bb6:	2f fd       	sub	sp,-4
80003bb8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003bbc:	00 00       	add	r0,r0
80003bbe:	0b 38       	ld.ub	r8,r5++
80003bc0:	00 00       	add	r0,r0
80003bc2:	0b 20       	ld.uh	r0,r5++
80003bc4:	00 00       	add	r0,r0
80003bc6:	0a 90       	mov	r0,r5
80003bc8:	80 00       	ld.sh	r0,r0[0x0]
80003bca:	2d 68       	sub	r8,-42
80003bcc:	80 00       	ld.sh	r0,r0[0x0]
80003bce:	63 24       	ld.w	r4,r1[0x48]
80003bd0:	00 00       	add	r0,r0
80003bd2:	0b 30       	ld.ub	r0,r5++
80003bd4:	80 00       	ld.sh	r0,r0[0x0]
80003bd6:	4d d4       	lddpc	r4,80003d48 <xnl_device_auth_reply_func+0x3c>

80003bd8 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80003bd8:	eb cd 40 80 	pushm	r7,lr
80003bdc:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
80003be0:	f0 1f 00 27 	mcall	80003c7c <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
80003be4:	30 09       	mov	r9,0
80003be6:	4a 78       	lddpc	r8,80003c80 <xnl_init+0xa8>
80003be8:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80003bea:	30 0b       	mov	r11,0
80003bec:	30 1c       	mov	r12,1
80003bee:	f0 1f 00 26 	mcall	80003c84 <xnl_init+0xac>
80003bf2:	4a 68       	lddpc	r8,80003c88 <xnl_init+0xb0>
80003bf4:	91 0c       	st.w	r8[0x0],r12
80003bf6:	70 08       	ld.w	r8,r8[0x0]
80003bf8:	58 08       	cp.w	r8,0
80003bfa:	c0 80       	breq	80003c0a <xnl_init+0x32>
80003bfc:	4a 38       	lddpc	r8,80003c88 <xnl_init+0xb0>
80003bfe:	70 0c       	ld.w	r12,r8[0x0]
80003c00:	30 09       	mov	r9,0
80003c02:	12 9a       	mov	r10,r9
80003c04:	12 9b       	mov	r11,r9
80003c06:	f0 1f 00 22 	mcall	80003c8c <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //xnl_frame_tx
80003c0a:	30 4b       	mov	r11,4
80003c0c:	31 4c       	mov	r12,20
80003c0e:	f0 1f 00 1e 	mcall	80003c84 <xnl_init+0xac>
80003c12:	4a 08       	lddpc	r8,80003c90 <xnl_init+0xb8>
80003c14:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80003c16:	30 07       	mov	r7,0
80003c18:	1a d7       	st.w	--sp,r7
80003c1a:	1a d7       	st.w	--sp,r7
80003c1c:	1a d7       	st.w	--sp,r7
80003c1e:	30 38       	mov	r8,3
80003c20:	0e 99       	mov	r9,r7
80003c22:	e0 6a 02 00 	mov	r10,512
80003c26:	49 cb       	lddpc	r11,80003c94 <xnl_init+0xbc>
80003c28:	49 cc       	lddpc	r12,80003c98 <xnl_init+0xc0>
80003c2a:	f0 1f 00 1d 	mcall	80003c9c <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80003c2e:	1a d7       	st.w	--sp,r7
80003c30:	1a d7       	st.w	--sp,r7
80003c32:	1a d7       	st.w	--sp,r7
80003c34:	30 38       	mov	r8,3
80003c36:	0e 99       	mov	r9,r7
80003c38:	e0 6a 03 20 	mov	r10,800
80003c3c:	49 9b       	lddpc	r11,80003ca0 <xnl_init+0xc8>
80003c3e:	49 ac       	lddpc	r12,80003ca4 <xnl_init+0xcc>
80003c40:	f0 1f 00 17 	mcall	80003c9c <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80003c44:	e0 68 40 0e 	mov	r8,16398
80003c48:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80003c4c:	3f f8       	mov	r8,-1
80003c4e:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80003c52:	30 38       	mov	r8,3
80003c54:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80003c58:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80003c5c:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80003c60:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80003c64:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80003c68:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80003c6c:	fa cc ff e8 	sub	r12,sp,-24
80003c70:	f0 1f 00 0e 	mcall	80003ca8 <xnl_init+0xd0>
80003c74:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
80003c76:	2c 0d       	sub	sp,-256
80003c78:	e3 cd 80 80 	ldm	sp++,r7,pc
80003c7c:	80 00       	ld.sh	r0,r0[0x0]
80003c7e:	2d 90       	sub	r0,-39
80003c80:	00 00       	add	r0,r0
80003c82:	0b 20       	ld.uh	r0,r5++
80003c84:	80 00       	ld.sh	r0,r0[0x0]
80003c86:	4f 2c       	lddpc	r12,80003e4c <xnl_master_status_brdcst_func+0x20>
80003c88:	00 00       	add	r0,r0
80003c8a:	0b 1c       	ld.sh	r12,r5++
80003c8c:	80 00       	ld.sh	r0,r0[0x0]
80003c8e:	4d d4       	lddpc	r4,80003e00 <xnl_device_auth_reply_func+0xf4>
80003c90:	00 00       	add	r0,r0
80003c92:	0b 30       	ld.ub	r0,r5++
80003c94:	80 00       	ld.sh	r0,r0[0x0]
80003c96:	c2 14       	brge	80003cd8 <xnl_data_msg_func+0x2c>
80003c98:	80 00       	ld.sh	r0,r0[0x0]
80003c9a:	3a 94       	mov	r4,-87
80003c9c:	80 00       	ld.sh	r0,r0[0x0]
80003c9e:	56 00       	stdsp	sp[0x180],r0
80003ca0:	80 00       	ld.sh	r0,r0[0x0]
80003ca2:	ba 00       	st.h	sp[0x0],r0
80003ca4:	80 00       	ld.sh	r0,r0[0x0]
80003ca6:	39 cc       	mov	r12,-100
80003ca8:	80 00       	ld.sh	r0,r0[0x0]
80003caa:	3a f4       	mov	r4,-81

80003cac <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80003cac:	eb cd 40 80 	pushm	r7,lr
80003cb0:	fa cd 01 00 	sub	sp,sp,256
80003cb4:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80003cb6:	e0 68 40 0e 	mov	r8,16398
80003cba:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80003cbc:	3f f8       	mov	r8,-1
80003cbe:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80003cc0:	30 c8       	mov	r8,12
80003cc2:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80003cc4:	98 38       	ld.sh	r8,r12[0x6]
80003cc6:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80003cc8:	98 58       	ld.sh	r8,r12[0xa]
80003cca:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80003ccc:	98 48       	ld.sh	r8,r12[0x8]
80003cce:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80003cd0:	98 68       	ld.sh	r8,r12[0xc]
80003cd2:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80003cd4:	30 08       	mov	r8,0
80003cd6:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80003cd8:	1a 9c       	mov	r12,sp
80003cda:	f0 1f 00 0a 	mcall	80003d00 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80003cde:	fa cd 00 cc 	sub	sp,sp,204
80003ce2:	e0 6a 00 ca 	mov	r10,202
80003ce6:	ee cb ff f0 	sub	r11,r7,-16
80003cea:	1a 9c       	mov	r12,sp
80003cec:	f0 1f 00 06 	mcall	80003d04 <xnl_data_msg_func+0x58>
80003cf0:	48 68       	lddpc	r8,80003d08 <xnl_data_msg_func+0x5c>
80003cf2:	70 08       	ld.w	r8,r8[0x0]
80003cf4:	5d 18       	icall	r8
80003cf6:	fa cd ff 34 	sub	sp,sp,-204
}
80003cfa:	2c 0d       	sub	sp,-256
80003cfc:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d00:	80 00       	ld.sh	r0,r0[0x0]
80003d02:	3a f4       	mov	r4,-81
80003d04:	80 00       	ld.sh	r0,r0[0x0]
80003d06:	63 24       	ld.w	r4,r1[0x48]
80003d08:	00 00       	add	r0,r0
80003d0a:	0b 40       	ld.w	r0,--r5

80003d0c <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80003d0c:	d4 21       	pushm	r4-r7,lr
80003d0e:	fa cd 01 00 	sub	sp,sp,256
80003d12:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80003d14:	4c 28       	lddpc	r8,80003e1c <xnl_device_auth_reply_func+0x110>
80003d16:	11 88       	ld.ub	r8,r8[0x0]
80003d18:	58 08       	cp.w	r8,0
80003d1a:	e0 81 00 7f 	brne	80003e18 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80003d1e:	4c 18       	lddpc	r8,80003e20 <xnl_device_auth_reply_func+0x114>
80003d20:	70 0c       	ld.w	r12,r8[0x0]
80003d22:	30 09       	mov	r9,0
80003d24:	12 9a       	mov	r10,r9
80003d26:	12 9b       	mov	r11,r9
80003d28:	f0 1f 00 3f 	mcall	80003e24 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80003d2c:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80003d30:	4b b8       	lddpc	r8,80003e1c <xnl_device_auth_reply_func+0x110>
80003d32:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80003d34:	ef 39 00 12 	ld.ub	r9,r7[18]
80003d38:	ef 38 00 13 	ld.ub	r8,r7[19]
80003d3c:	b1 68       	lsl	r8,0x10
80003d3e:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80003d42:	ef 38 00 15 	ld.ub	r8,r7[21]
80003d46:	f3 e8 10 08 	or	r8,r9,r8
80003d4a:	ef 39 00 14 	ld.ub	r9,r7[20]
80003d4e:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80003d52:	ef 3a 00 16 	ld.ub	r10,r7[22]
80003d56:	ef 38 00 17 	ld.ub	r8,r7[23]
80003d5a:	b1 68       	lsl	r8,0x10
80003d5c:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80003d60:	ef 38 00 19 	ld.ub	r8,r7[25]
80003d64:	f5 e8 10 08 	or	r8,r10,r8
80003d68:	ef 3a 00 18 	ld.ub	r10,r7[24]
80003d6c:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80003d70:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80003d72:	e0 64 79 b9 	mov	r4,31161
80003d76:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80003d7a:	e0 65 45 07 	mov	r5,17671
80003d7e:	ea 15 8a bd 	orh	r5,0x8abd
80003d82:	e0 66 f9 3d 	mov	r6,63805
80003d86:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80003d8a:	e0 6e b8 cf 	mov	lr,47311
80003d8e:	ea 1e 36 83 	orh	lr,0x3683
80003d92:	e0 67 aa 1c 	mov	r7,43548
80003d96:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80003d9a:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80003d9c:	f4 08 00 0c 	add	r12,r10,r8
80003da0:	f0 0b 15 04 	lsl	r11,r8,0x4
80003da4:	0a 0b       	add	r11,r5
80003da6:	f9 eb 20 0b 	eor	r11,r12,r11
80003daa:	f0 0c 16 05 	lsr	r12,r8,0x5
80003dae:	0c 0c       	add	r12,r6
80003db0:	18 5b       	eor	r11,r12
80003db2:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80003db4:	f2 0c 15 04 	lsl	r12,r9,0x4
80003db8:	1c 0c       	add	r12,lr
80003dba:	f2 0b 16 05 	lsr	r11,r9,0x5
80003dbe:	0e 0b       	add	r11,r7
80003dc0:	f9 eb 20 0b 	eor	r11,r12,r11
80003dc4:	f2 0a 00 0c 	add	r12,r9,r10
80003dc8:	18 5b       	eor	r11,r12
80003dca:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80003dcc:	e0 6b 37 20 	mov	r11,14112
80003dd0:	ea 1b c6 ef 	orh	r11,0xc6ef
80003dd4:	16 3a       	cp.w	r10,r11
80003dd6:	ce 21       	brne	80003d9a <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80003dd8:	e0 6a 40 1a 	mov	r10,16410
80003ddc:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80003dde:	3f fa       	mov	r10,-1
80003de0:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80003de2:	30 6b       	mov	r11,6
80003de4:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80003de6:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80003de8:	48 db       	lddpc	r11,80003e1c <xnl_device_auth_reply_func+0x110>
80003dea:	96 1c       	ld.sh	r12,r11[0x2]
80003dec:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80003dee:	96 2b       	ld.sh	r11,r11[0x4]
80003df0:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003df2:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80003df4:	30 ca       	mov	r10,12
80003df6:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80003df8:	30 0a       	mov	r10,0
80003dfa:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80003dfe:	30 7a       	mov	r10,7
80003e00:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80003e04:	30 2a       	mov	r10,2
80003e06:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80003e0a:	fa ca ff ec 	sub	r10,sp,-20
80003e0e:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80003e10:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80003e12:	1a 9c       	mov	r12,sp
80003e14:	f0 1f 00 05 	mcall	80003e28 <xnl_device_auth_reply_func+0x11c>
}
80003e18:	2c 0d       	sub	sp,-256
80003e1a:	d8 22       	popm	r4-r7,pc
80003e1c:	00 00       	add	r0,r0
80003e1e:	0b 20       	ld.uh	r0,r5++
80003e20:	00 00       	add	r0,r0
80003e22:	0b 1c       	ld.sh	r12,r5++
80003e24:	80 00       	ld.sh	r0,r0[0x0]
80003e26:	4d d4       	lddpc	r4,80003f98 <rtc_init+0x54>
80003e28:	80 00       	ld.sh	r0,r0[0x0]
80003e2a:	3a f4       	mov	r4,-81

80003e2c <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80003e2c:	eb cd 40 80 	pushm	r7,lr
80003e30:	fa cd 01 00 	sub	sp,sp,256
80003e34:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80003e36:	49 28       	lddpc	r8,80003e7c <xnl_master_status_brdcst_func+0x50>
80003e38:	11 88       	ld.ub	r8,r8[0x0]
80003e3a:	58 08       	cp.w	r8,0
80003e3c:	c1 c1       	brne	80003e74 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80003e3e:	49 18       	lddpc	r8,80003e80 <xnl_master_status_brdcst_func+0x54>
80003e40:	70 0c       	ld.w	r12,r8[0x0]
80003e42:	30 09       	mov	r9,0
80003e44:	12 9a       	mov	r10,r9
80003e46:	12 9b       	mov	r11,r9
80003e48:	f0 1f 00 0f 	mcall	80003e84 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80003e4c:	8e 58       	ld.sh	r8,r7[0xa]
80003e4e:	48 c9       	lddpc	r9,80003e7c <xnl_master_status_brdcst_func+0x50>
80003e50:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80003e52:	e0 68 40 0e 	mov	r8,16398
80003e56:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80003e58:	3f f8       	mov	r8,-1
80003e5a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80003e5c:	30 4a       	mov	r10,4
80003e5e:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80003e60:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80003e62:	92 19       	ld.sh	r9,r9[0x2]
80003e64:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80003e66:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003e68:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80003e6a:	30 08       	mov	r8,0
80003e6c:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80003e6e:	1a 9c       	mov	r12,sp
80003e70:	f0 1f 00 06 	mcall	80003e88 <xnl_master_status_brdcst_func+0x5c>
}
80003e74:	2c 0d       	sub	sp,-256
80003e76:	e3 cd 80 80 	ldm	sp++,r7,pc
80003e7a:	00 00       	add	r0,r0
80003e7c:	00 00       	add	r0,r0
80003e7e:	0b 20       	ld.uh	r0,r5++
80003e80:	00 00       	add	r0,r0
80003e82:	0b 1c       	ld.sh	r12,r5++
80003e84:	80 00       	ld.sh	r0,r0[0x0]
80003e86:	4d d4       	lddpc	r4,80003ff8 <local_start_timer+0x28>
80003e88:	80 00       	ld.sh	r0,r0[0x0]
80003e8a:	3a f4       	mov	r4,-81

80003e8c <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80003e8c:	eb cd 40 80 	pushm	r7,lr
80003e90:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80003e92:	49 38       	lddpc	r8,80003edc <xnl_device_conn_reply_func+0x50>
80003e94:	70 0c       	ld.w	r12,r8[0x0]
80003e96:	30 09       	mov	r9,0
80003e98:	12 9a       	mov	r10,r9
80003e9a:	12 9b       	mov	r11,r9
80003e9c:	f0 1f 00 11 	mcall	80003ee0 <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80003ea0:	ef 18 00 10 	ld.uh	r8,r7[16]
80003ea4:	10 99       	mov	r9,r8
80003ea6:	e2 19 ff 00 	andl	r9,0xff00,COH
80003eaa:	e0 49 01 00 	cp.w	r9,256
80003eae:	c0 60       	breq	80003eba <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80003eb0:	0e 9c       	mov	r12,r7
80003eb2:	f0 1f 00 0d 	mcall	80003ee4 <xnl_device_conn_reply_func+0x58>
80003eb6:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80003eba:	a9 68       	lsl	r8,0x8
80003ebc:	48 b9       	lddpc	r9,80003ee8 <xnl_device_conn_reply_func+0x5c>
80003ebe:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80003ec0:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80003ec4:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80003ec6:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80003eca:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80003ecc:	30 18       	mov	r8,1
80003ece:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
80003ed0:	48 7c       	lddpc	r12,80003eec <xnl_device_conn_reply_func+0x60>
80003ed2:	f0 1f 00 08 	mcall	80003ef0 <xnl_device_conn_reply_func+0x64>
80003ed6:	e3 cd 80 80 	ldm	sp++,r7,pc
80003eda:	00 00       	add	r0,r0
80003edc:	00 00       	add	r0,r0
80003ede:	0b 1c       	ld.sh	r12,r5++
80003ee0:	80 00       	ld.sh	r0,r0[0x0]
80003ee2:	4d d4       	lddpc	r4,80004054 <tc_init+0x48>
80003ee4:	80 00       	ld.sh	r0,r0[0x0]
80003ee6:	3e 2c       	mov	r12,-30
80003ee8:	00 00       	add	r0,r0
80003eea:	0b 20       	ld.uh	r0,r5++
80003eec:	80 00       	ld.sh	r0,r0[0x0]
80003eee:	c2 1c       	rcall	80003f30 <local_start_pll0+0x3c>
80003ef0:	80 00       	ld.sh	r0,r0[0x0]
80003ef2:	59 c4       	cp.w	r4,28

80003ef4 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80003ef4:	fe 78 0c 00 	mov	r8,-62464
80003ef8:	e0 69 03 07 	mov	r9,775
80003efc:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80003efe:	30 49       	mov	r9,4
80003f00:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80003f02:	71 59       	ld.w	r9,r8[0x54]
80003f04:	e2 19 00 80 	andl	r9,0x80,COH
80003f08:	cf d0       	breq	80003f02 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80003f0a:	fe 78 0c 00 	mov	r8,-62464
80003f0e:	30 59       	mov	r9,5
80003f10:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80003f12:	e0 69 01 0d 	mov	r9,269
80003f16:	ea 19 10 07 	orh	r9,0x1007
80003f1a:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80003f1c:	71 59       	ld.w	r9,r8[0x54]
80003f1e:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80003f22:	cf d0       	breq	80003f1c <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80003f24:	fe 78 0c 00 	mov	r8,-62464
80003f28:	fc 19 00 80 	movh	r9,0x80
80003f2c:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80003f2e:	34 0a       	mov	r10,64
80003f30:	fe 69 14 00 	mov	r9,-125952
80003f34:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80003f36:	30 69       	mov	r9,6
80003f38:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80003f3a:	30 19       	mov	r9,1
80003f3c:	fe 68 10 00 	mov	r8,-126976
80003f40:	91 19       	st.w	r8[0x4],r9
}
80003f42:	5e fc       	retal	r12

80003f44 <rtc_init>:
    PCF8563_init
Called By: ..
Return:rtc_err_t
*/
rtc_err_t rtc_init(void)
{
80003f44:	eb cd 40 c0 	pushm	r6-r7,lr
80003f48:	20 3d       	sub	sp,12
	/* Create the mutex semaphore to guard a shared RTC(TWI).*/	
	rtc_mutex = xSemaphoreCreateMutex();
80003f4a:	f0 1f 00 1a 	mcall	80003fb0 <rtc_init+0x6c>
80003f4e:	49 a8       	lddpc	r8,80003fb4 <rtc_init+0x70>
80003f50:	91 0c       	st.w	r8[0x0],r12
	
	if(NULL != rtc_mutex)
80003f52:	70 08       	ld.w	r8,r8[0x0]
80003f54:	58 08       	cp.w	r8,0
80003f56:	c0 31       	brne	80003f5c <rtc_init+0x18>
80003f58:	30 3c       	mov	r12,3
80003f5a:	c2 78       	rjmp	80003fa8 <rtc_init+0x64>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80003f5c:	49 66       	lddpc	r6,80003fb4 <rtc_init+0x70>
80003f5e:	6c 0c       	ld.w	r12,r6[0x0]
80003f60:	30 09       	mov	r9,0
80003f62:	3f fa       	mov	r10,-1
80003f64:	12 9b       	mov	r11,r9
80003f66:	f0 1f 00 15 	mcall	80003fb8 <rtc_init+0x74>
	
	/*twi_package_t packet, packet_received*/
	static int status;

	/*TWI gpio pins configuration*/	
	gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
80003f6a:	30 2b       	mov	r11,2
80003f6c:	49 4c       	lddpc	r12,80003fbc <rtc_init+0x78>
80003f6e:	f0 1f 00 15 	mcall	80003fc0 <rtc_init+0x7c>
	
	/* options settings*/
	opt.pba_hz = RTC_PBACLK_FREQ_HZ;//FOSC0;24Mhz
80003f72:	e0 68 36 00 	mov	r8,13824
80003f76:	ea 18 01 6e 	orh	r8,0x16e
80003f7a:	50 08       	stdsp	sp[0x0],r8
	opt.speed  = TWI_SPEED;//200Khz
80003f7c:	e2 78 0d 40 	mov	r8,200000
80003f80:	50 18       	stdsp	sp[0x4],r8
	opt.chip   = PCF8563_ADDRESS;
80003f82:	35 18       	mov	r8,81
80003f84:	fb 68 00 08 	st.b	sp[8],r8

	/*initialize TWI driver with options*/
	status = twi_master_init(&AVR32_TWI, &opt);
80003f88:	1a 9b       	mov	r11,sp
80003f8a:	fe 7c 2c 00 	mov	r12,-54272
80003f8e:	f0 1f 00 0e 	mcall	80003fc4 <rtc_init+0x80>
80003f92:	48 e7       	lddpc	r7,80003fc8 <rtc_init+0x84>
80003f94:	8f 0c       	st.w	r7[0x0],r12
	
	/*finished accessing the shared resource.Release the semaphore.*/
	xSemaphoreGive(rtc_mutex);		
80003f96:	6c 0c       	ld.w	r12,r6[0x0]
80003f98:	30 09       	mov	r9,0
80003f9a:	12 9a       	mov	r10,r9
80003f9c:	12 9b       	mov	r11,r9
80003f9e:	f0 1f 00 0c 	mcall	80003fcc <rtc_init+0x88>
80003fa2:	6e 08       	ld.w	r8,r7[0x0]
80003fa4:	58 08       	cp.w	r8,0
80003fa6:	5f 1c       	srne	r12
	{
		return rtc_success;
	}
		
	return rtc_init_err;
}
80003fa8:	2f dd       	sub	sp,-12
80003faa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003fae:	00 00       	add	r0,r0
80003fb0:	80 00       	ld.sh	r0,r0[0x0]
80003fb2:	4e d4       	lddpc	r4,80004164 <_get_interrupt_handler>
80003fb4:	00 00       	add	r0,r0
80003fb6:	0b 48       	ld.w	r8,--r5
80003fb8:	80 00       	ld.sh	r0,r0[0x0]
80003fba:	4b c8       	lddpc	r8,800040a8 <INTC_register_interrupt+0x18>
80003fbc:	80 00       	ld.sh	r0,r0[0x0]
80003fbe:	c2 30       	breq	80004004 <local_start_timer+0x34>
80003fc0:	80 00       	ld.sh	r0,r0[0x0]
80003fc2:	5e 5c       	retlt	r12
80003fc4:	80 00       	ld.sh	r0,r0[0x0]
80003fc6:	44 54       	lddsp	r4,sp[0x114]
80003fc8:	00 00       	add	r0,r0
80003fca:	0b 44       	ld.w	r4,--r5
80003fcc:	80 00       	ld.sh	r0,r0[0x0]
80003fce:	4d d4       	lddpc	r4,80004140 <INTC_init_interrupts+0x30>

80003fd0 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80003fd0:	fe 78 10 00 	mov	r8,-61440
80003fd4:	fc 19 00 10 	movh	r9,0x10
80003fd8:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80003fda:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80003fdc:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80003fde:	30 39       	mov	r9,3
80003fe0:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80003fe4:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80003fe8:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80003fec:	fe 78 38 00 	mov	r8,-51200
80003ff0:	30 49       	mov	r9,4
80003ff2:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80003ff6:	e0 69 91 0d 	mov	r9,37133
80003ffa:	ea 19 00 52 	orh	r9,0x52
80003ffe:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80004000:	32 09       	mov	r9,32
80004002:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004004:	30 59       	mov	r9,5
80004006:	91 09       	st.w	r8[0x0],r9
}
80004008:	5e fc       	retal	r12
8000400a:	d7 03       	nop

8000400c <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
8000400c:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
8000400e:	30 2a       	mov	r10,2
80004010:	e0 6b 01 c1 	mov	r11,449
80004014:	48 ec       	lddpc	r12,8000404c <tc_init+0x40>
80004016:	f0 1f 00 0f 	mcall	80004050 <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
8000401a:	48 fb       	lddpc	r11,80004054 <tc_init+0x48>
8000401c:	fe 7c 38 00 	mov	r12,-51200
80004020:	f0 1f 00 0e 	mcall	80004058 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80004024:	e0 6a 75 30 	mov	r10,30000
80004028:	30 1b       	mov	r11,1
8000402a:	fe 7c 38 00 	mov	r12,-51200
8000402e:	f0 1f 00 0c 	mcall	8000405c <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80004032:	48 ca       	lddpc	r10,80004060 <tc_init+0x54>
80004034:	30 1b       	mov	r11,1
80004036:	fe 7c 38 00 	mov	r12,-51200
8000403a:	f0 1f 00 0b 	mcall	80004064 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
8000403e:	30 1b       	mov	r11,1
80004040:	fe 7c 38 00 	mov	r12,-51200
80004044:	f0 1f 00 09 	mcall	80004068 <tc_init+0x5c>
80004048:	d8 02       	popm	pc
8000404a:	00 00       	add	r0,r0
8000404c:	80 00       	ld.sh	r0,r0[0x0]
8000404e:	40 6c       	lddsp	r12,sp[0x18]
80004050:	80 00       	ld.sh	r0,r0[0x0]
80004052:	40 90       	lddsp	r0,sp[0x24]
80004054:	80 00       	ld.sh	r0,r0[0x0]
80004056:	c2 44       	brge	8000409e <INTC_register_interrupt+0xe>
80004058:	80 00       	ld.sh	r0,r0[0x0]
8000405a:	41 9c       	lddsp	r12,sp[0x64]
8000405c:	80 00       	ld.sh	r0,r0[0x0]
8000405e:	42 5c       	lddsp	r12,sp[0x94]
80004060:	80 00       	ld.sh	r0,r0[0x0]
80004062:	c2 40       	breq	800040aa <INTC_register_interrupt+0x1a>
80004064:	80 00       	ld.sh	r0,r0[0x0]
80004066:	42 90       	lddsp	r0,sp[0xa4]
80004068:	80 00       	ld.sh	r0,r0[0x0]
8000406a:	42 38       	lddsp	r8,sp[0x8c]

8000406c <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
8000406c:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
8000406e:	48 68       	lddpc	r8,80004084 <_tc_interrupt+0x18>
80004070:	70 09       	ld.w	r9,r8[0x0]
80004072:	2f f9       	sub	r9,-1
80004074:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80004076:	30 1b       	mov	r11,1
80004078:	fe 7c 38 00 	mov	r12,-51200
8000407c:	f0 1f 00 03 	mcall	80004088 <_tc_interrupt+0x1c>
	
}
80004080:	d4 02       	popm	lr
80004082:	d6 03       	rete
80004084:	00 00       	add	r0,r0
80004086:	0b 4c       	ld.w	r12,--r5
80004088:	80 00       	ld.sh	r0,r0[0x0]
8000408a:	42 4a       	lddsp	r10,sp[0x90]

8000408c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000408c:	c0 08       	rjmp	8000408c <_unhandled_interrupt>
8000408e:	d7 03       	nop

80004090 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004090:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004094:	49 99       	lddpc	r9,800040f8 <INTC_register_interrupt+0x68>
80004096:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000409a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000409e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800040a0:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800040a4:	58 0a       	cp.w	r10,0
800040a6:	c0 91       	brne	800040b8 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800040a8:	49 59       	lddpc	r9,800040fc <INTC_register_interrupt+0x6c>
800040aa:	49 6a       	lddpc	r10,80004100 <INTC_register_interrupt+0x70>
800040ac:	12 1a       	sub	r10,r9
800040ae:	fe 79 08 00 	mov	r9,-63488
800040b2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800040b6:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800040b8:	58 1a       	cp.w	r10,1
800040ba:	c0 a1       	brne	800040ce <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800040bc:	49 09       	lddpc	r9,800040fc <INTC_register_interrupt+0x6c>
800040be:	49 2a       	lddpc	r10,80004104 <INTC_register_interrupt+0x74>
800040c0:	12 1a       	sub	r10,r9
800040c2:	bf aa       	sbr	r10,0x1e
800040c4:	fe 79 08 00 	mov	r9,-63488
800040c8:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800040cc:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800040ce:	58 2a       	cp.w	r10,2
800040d0:	c0 a1       	brne	800040e4 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800040d2:	48 b9       	lddpc	r9,800040fc <INTC_register_interrupt+0x6c>
800040d4:	48 da       	lddpc	r10,80004108 <INTC_register_interrupt+0x78>
800040d6:	12 1a       	sub	r10,r9
800040d8:	bf ba       	sbr	r10,0x1f
800040da:	fe 79 08 00 	mov	r9,-63488
800040de:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800040e2:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800040e4:	48 69       	lddpc	r9,800040fc <INTC_register_interrupt+0x6c>
800040e6:	48 aa       	lddpc	r10,8000410c <INTC_register_interrupt+0x7c>
800040e8:	12 1a       	sub	r10,r9
800040ea:	ea 1a c0 00 	orh	r10,0xc000
800040ee:	fe 79 08 00 	mov	r9,-63488
800040f2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800040f6:	5e fc       	retal	r12
800040f8:	80 00       	ld.sh	r0,r0[0x0]
800040fa:	c2 4c       	rcall	80004142 <INTC_init_interrupts+0x32>
800040fc:	80 00       	ld.sh	r0,r0[0x0]
800040fe:	b8 00       	st.h	r12[0x0],r0
80004100:	80 00       	ld.sh	r0,r0[0x0]
80004102:	b9 04       	ld.d	r4,r12
80004104:	80 00       	ld.sh	r0,r0[0x0]
80004106:	b9 12       	ld.d	r2,--r12
80004108:	80 00       	ld.sh	r0,r0[0x0]
8000410a:	b9 20       	st.d	r12++,r0
8000410c:	80 00       	ld.sh	r0,r0[0x0]
8000410e:	b9 2e       	st.d	r12++,lr

80004110 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004110:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004112:	49 18       	lddpc	r8,80004154 <INTC_init_interrupts+0x44>
80004114:	e3 b8 00 01 	mtsr	0x4,r8
80004118:	49 0e       	lddpc	lr,80004158 <INTC_init_interrupts+0x48>
8000411a:	30 07       	mov	r7,0
8000411c:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000411e:	49 0c       	lddpc	r12,8000415c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004120:	49 05       	lddpc	r5,80004160 <INTC_init_interrupts+0x50>
80004122:	10 15       	sub	r5,r8
80004124:	fe 76 08 00 	mov	r6,-63488
80004128:	c1 08       	rjmp	80004148 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000412a:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
8000412c:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000412e:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004130:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004134:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004136:	10 3a       	cp.w	r10,r8
80004138:	fe 9b ff fc 	brhi	80004130 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000413c:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004140:	2f f7       	sub	r7,-1
80004142:	2f 8e       	sub	lr,-8
80004144:	59 37       	cp.w	r7,19
80004146:	c0 50       	breq	80004150 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004148:	7c 08       	ld.w	r8,lr[0x0]
8000414a:	58 08       	cp.w	r8,0
8000414c:	ce f1       	brne	8000412a <INTC_init_interrupts+0x1a>
8000414e:	cf 7b       	rjmp	8000413c <INTC_init_interrupts+0x2c>
80004150:	d8 22       	popm	r4-r7,pc
80004152:	00 00       	add	r0,r0
80004154:	80 00       	ld.sh	r0,r0[0x0]
80004156:	b8 00       	st.h	r12[0x0],r0
80004158:	80 00       	ld.sh	r0,r0[0x0]
8000415a:	c2 4c       	rcall	800041a2 <tc_init_waveform+0x6>
8000415c:	80 00       	ld.sh	r0,r0[0x0]
8000415e:	40 8c       	lddsp	r12,sp[0x20]
80004160:	80 00       	ld.sh	r0,r0[0x0]
80004162:	b9 04       	ld.d	r4,r12

80004164 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004164:	fe 78 08 00 	mov	r8,-63488
80004168:	e0 69 00 83 	mov	r9,131
8000416c:	f2 0c 01 0c 	sub	r12,r9,r12
80004170:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004174:	f2 ca ff c0 	sub	r10,r9,-64
80004178:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
8000417c:	58 08       	cp.w	r8,0
8000417e:	c0 21       	brne	80004182 <_get_interrupt_handler+0x1e>
80004180:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004182:	f0 08 12 00 	clz	r8,r8
80004186:	48 5a       	lddpc	r10,80004198 <_get_interrupt_handler+0x34>
80004188:	f4 09 00 39 	add	r9,r10,r9<<0x3
8000418c:	f0 08 11 1f 	rsub	r8,r8,31
80004190:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004192:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004196:	5e fc       	retal	r12
80004198:	80 00       	ld.sh	r0,r0[0x0]
8000419a:	c2 4c       	rcall	800041e2 <tc_init_waveform+0x46>

8000419c <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
8000419c:	76 09       	ld.w	r9,r11[0x0]
8000419e:	58 29       	cp.w	r9,2
800041a0:	e0 88 00 03 	brls	800041a6 <tc_init_waveform+0xa>
800041a4:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
800041a6:	76 18       	ld.w	r8,r11[0x4]
800041a8:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800041ac:	af ba       	sbr	r10,0xf
800041ae:	10 9b       	mov	r11,r8
800041b0:	e6 1b c0 00 	andh	r11,0xc000,COH
800041b4:	16 4a       	or	r10,r11
800041b6:	10 9b       	mov	r11,r8
800041b8:	e6 1b 30 00 	andh	r11,0x3000,COH
800041bc:	16 4a       	or	r10,r11
800041be:	10 9b       	mov	r11,r8
800041c0:	e6 1b 0c 00 	andh	r11,0xc00,COH
800041c4:	16 4a       	or	r10,r11
800041c6:	10 9b       	mov	r11,r8
800041c8:	e6 1b 03 00 	andh	r11,0x300,COH
800041cc:	16 4a       	or	r10,r11
800041ce:	10 9b       	mov	r11,r8
800041d0:	e6 1b 00 c0 	andh	r11,0xc0,COH
800041d4:	16 4a       	or	r10,r11
800041d6:	10 9b       	mov	r11,r8
800041d8:	e6 1b 00 30 	andh	r11,0x30,COH
800041dc:	16 4a       	or	r10,r11
800041de:	10 9b       	mov	r11,r8
800041e0:	e6 1b 00 0c 	andh	r11,0xc,COH
800041e4:	16 4a       	or	r10,r11
800041e6:	10 9b       	mov	r11,r8
800041e8:	e6 1b 00 03 	andh	r11,0x3,COH
800041ec:	16 4a       	or	r10,r11
800041ee:	10 9b       	mov	r11,r8
800041f0:	e2 1b 60 00 	andl	r11,0x6000,COH
800041f4:	16 4a       	or	r10,r11
800041f6:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
800041fa:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
800041fe:	10 9b       	mov	r11,r8
80004200:	e2 1b 0c 00 	andl	r11,0xc00,COH
80004204:	16 4a       	or	r10,r11
80004206:	10 9b       	mov	r11,r8
80004208:	e2 1b 03 00 	andl	r11,0x300,COH
8000420c:	16 4a       	or	r10,r11
8000420e:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80004212:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
80004216:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
8000421a:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
8000421e:	10 9b       	mov	r11,r8
80004220:	e2 1b 00 30 	andl	r11,0x30,COH
80004224:	16 4a       	or	r10,r11
80004226:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
8000422a:	f5 e8 10 38 	or	r8,r10,r8<<0x3
8000422e:	a5 69       	lsl	r9,0x4
80004230:	2f f9       	sub	r9,-1
80004232:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80004236:	5e fd       	retal	0

80004238 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004238:	58 2b       	cp.w	r11,2
8000423a:	e0 88 00 03 	brls	80004240 <tc_start+0x8>
8000423e:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004240:	a7 6b       	lsl	r11,0x6
80004242:	16 0c       	add	r12,r11
80004244:	30 58       	mov	r8,5
80004246:	99 08       	st.w	r12[0x0],r8
80004248:	5e fd       	retal	0

8000424a <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
8000424a:	58 2b       	cp.w	r11,2
8000424c:	e0 88 00 03 	brls	80004252 <tc_read_sr+0x8>
80004250:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80004252:	a7 6b       	lsl	r11,0x6
80004254:	2e 0b       	sub	r11,-32
80004256:	16 0c       	add	r12,r11
80004258:	78 0c       	ld.w	r12,r12[0x0]
}
8000425a:	5e fc       	retal	r12

8000425c <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
8000425c:	58 2b       	cp.w	r11,2
8000425e:	e0 88 00 03 	brls	80004264 <tc_write_rc+0x8>
80004262:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80004264:	f6 08 15 04 	lsl	r8,r11,0x4
80004268:	2f f8       	sub	r8,-1
8000426a:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
8000426e:	e2 18 80 00 	andl	r8,0x8000,COH
80004272:	c0 c0       	breq	8000428a <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80004274:	a7 6b       	lsl	r11,0x6
80004276:	16 0c       	add	r12,r11
80004278:	2e 4c       	sub	r12,-28
8000427a:	78 08       	ld.w	r8,r12[0x0]
8000427c:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004280:	e0 18 00 00 	andl	r8,0x0
80004284:	f3 e8 10 08 	or	r8,r9,r8
80004288:	99 08       	st.w	r12[0x0],r8

  return value;
8000428a:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
8000428e:	5e fc       	retal	r12

80004290 <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80004290:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80004294:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004298:	58 2b       	cp.w	r11,2
8000429a:	e0 88 00 04 	brls	800042a2 <tc_configure_interrupts+0x12>
8000429e:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
800042a2:	ee 19 00 01 	eorh	r9,0x1
800042a6:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
800042aa:	74 08       	ld.w	r8,r10[0x0]
800042ac:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
800042b0:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
800042b4:	a7 6e       	lsl	lr,0x6
800042b6:	fd e7 10 7e 	or	lr,lr,r7<<0x7
800042ba:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
800042be:	0e 4e       	or	lr,r7
800042c0:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
800042c4:	fd e7 10 5e 	or	lr,lr,r7<<0x5
800042c8:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
800042cc:	fd e7 10 4e 	or	lr,lr,r7<<0x4
800042d0:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
800042d4:	fd e7 10 3e 	or	lr,lr,r7<<0x3
800042d8:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
800042dc:	fd e7 10 2e 	or	lr,lr,r7<<0x2
800042e0:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
800042e4:	fd e8 10 18 	or	r8,lr,r8<<0x1
800042e8:	f6 0e 15 06 	lsl	lr,r11,0x6
800042ec:	f8 0e 00 0e 	add	lr,r12,lr
800042f0:	2d ce       	sub	lr,-36
800042f2:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
800042f4:	58 09       	cp.w	r9,0
800042f6:	c0 20       	breq	800042fa <tc_configure_interrupts+0x6a>
800042f8:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
800042fa:	74 08       	ld.w	r8,r10[0x0]
800042fc:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80004300:	e0 65 00 80 	mov	r5,128
80004304:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80004308:	74 08       	ld.w	r8,r10[0x0]
8000430a:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
8000430e:	f9 b4 00 40 	moveq	r4,64
80004312:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80004316:	74 08       	ld.w	r8,r10[0x0]
80004318:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
8000431c:	f9 b3 00 20 	moveq	r3,32
80004320:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80004324:	74 08       	ld.w	r8,r10[0x0]
80004326:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
8000432a:	f9 b2 00 10 	moveq	r2,16
8000432e:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80004332:	74 08       	ld.w	r8,r10[0x0]
80004334:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80004338:	f9 b6 00 08 	moveq	r6,8
8000433c:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80004340:	74 08       	ld.w	r8,r10[0x0]
80004342:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80004346:	f9 b7 00 04 	moveq	r7,4
8000434a:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
8000434e:	74 08       	ld.w	r8,r10[0x0]
80004350:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004354:	f9 be 00 02 	moveq	lr,2
80004358:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
8000435c:	74 08       	ld.w	r8,r10[0x0]
8000435e:	ec 18 00 01 	eorl	r8,0x1
80004362:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004366:	eb e8 10 08 	or	r8,r5,r8
8000436a:	08 48       	or	r8,r4
8000436c:	06 48       	or	r8,r3
8000436e:	04 48       	or	r8,r2
80004370:	0c 48       	or	r8,r6
80004372:	0e 48       	or	r8,r7
80004374:	1c 48       	or	r8,lr
80004376:	f6 0a 15 06 	lsl	r10,r11,0x6
8000437a:	f8 0a 00 0a 	add	r10,r12,r10
8000437e:	2d 8a       	sub	r10,-40
80004380:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80004382:	a7 6b       	lsl	r11,0x6
80004384:	2e 0b       	sub	r11,-32
80004386:	16 0c       	add	r12,r11
80004388:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
8000438a:	58 09       	cp.w	r9,0
8000438c:	c0 31       	brne	80004392 <tc_configure_interrupts+0x102>
8000438e:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80004392:	d5 03       	csrf	0x10
80004394:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

80004398 <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
80004398:	4a 78       	lddpc	r8,80004434 <twi_master_interrupt_handler+0x9c>
8000439a:	70 08       	ld.w	r8,r8[0x0]
8000439c:	70 89       	ld.w	r9,r8[0x20]
8000439e:	4a 7a       	lddpc	r10,80004438 <twi_master_interrupt_handler+0xa0>
800043a0:	74 0a       	ld.w	r10,r10[0x0]
800043a2:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
800043a6:	12 9a       	mov	r10,r9
800043a8:	e2 1a 01 00 	andl	r10,0x100,COH
800043ac:	c3 91       	brne	8000441e <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
800043ae:	12 9a       	mov	r10,r9
800043b0:	e2 1a 00 02 	andl	r10,0x2,COH
800043b4:	c1 70       	breq	800043e2 <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
800043b6:	4a 29       	lddpc	r9,8000443c <twi_master_interrupt_handler+0xa4>
800043b8:	72 0a       	ld.w	r10,r9[0x0]
800043ba:	70 cb       	ld.w	r11,r8[0x30]
800043bc:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
800043be:	72 0a       	ld.w	r10,r9[0x0]
800043c0:	2f fa       	sub	r10,-1
800043c2:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
800043c4:	49 f9       	lddpc	r9,80004440 <twi_master_interrupt_handler+0xa8>
800043c6:	72 0a       	ld.w	r10,r9[0x0]
800043c8:	20 1a       	sub	r10,1
800043ca:	93 0a       	st.w	r9[0x0],r10
800043cc:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
800043ce:	58 19       	cp.w	r9,1
800043d0:	f9 b9 00 02 	moveq	r9,2
800043d4:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
800043d8:	49 a9       	lddpc	r9,80004440 <twi_master_interrupt_handler+0xa8>
800043da:	72 09       	ld.w	r9,r9[0x0]
800043dc:	58 09       	cp.w	r9,0
800043de:	c2 30       	breq	80004424 <twi_master_interrupt_handler+0x8c>
800043e0:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
800043e2:	12 9a       	mov	r10,r9
800043e4:	e2 1a 00 04 	andl	r10,0x4,COH
800043e8:	c1 70       	breq	80004416 <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
800043ea:	49 79       	lddpc	r9,80004444 <twi_master_interrupt_handler+0xac>
800043ec:	72 0a       	ld.w	r10,r9[0x0]
800043ee:	20 1a       	sub	r10,1
800043f0:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
800043f2:	72 09       	ld.w	r9,r9[0x0]
800043f4:	58 09       	cp.w	r9,0
800043f6:	e0 89 00 0a 	brgt	8000440a <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
800043fa:	49 09       	lddpc	r9,80004438 <twi_master_interrupt_handler+0xa0>
800043fc:	30 1a       	mov	r10,1
800043fe:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
80004400:	3f fa       	mov	r10,-1
80004402:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
80004404:	72 09       	ld.w	r9,r9[0x0]
80004406:	91 99       	st.w	r8[0x24],r9
80004408:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
8000440a:	49 0a       	lddpc	r10,80004448 <twi_master_interrupt_handler+0xb0>
8000440c:	74 09       	ld.w	r9,r10[0x0]
8000440e:	13 3b       	ld.ub	r11,r9++
80004410:	91 db       	st.w	r8[0x34],r11
80004412:	95 09       	st.w	r10[0x0],r9
80004414:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
80004416:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000441a:	c0 51       	brne	80004424 <twi_master_interrupt_handler+0x8c>
8000441c:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
8000441e:	30 1a       	mov	r10,1
80004420:	48 b9       	lddpc	r9,8000444c <twi_master_interrupt_handler+0xb4>
80004422:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
80004424:	3f f9       	mov	r9,-1
80004426:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
80004428:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
8000442a:	30 09       	mov	r9,0
8000442c:	48 98       	lddpc	r8,80004450 <twi_master_interrupt_handler+0xb8>
8000442e:	b0 89       	st.b	r8[0x0],r9
80004430:	d6 03       	rete
80004432:	00 00       	add	r0,r0
80004434:	00 00       	add	r0,r0
80004436:	0c 04       	add	r4,r6
80004438:	00 00       	add	r0,r0
8000443a:	0c 00       	add	r0,r6
8000443c:	00 00       	add	r0,r0
8000443e:	0c 10       	sub	r0,r6
80004440:	00 00       	add	r0,r0
80004442:	0c 0c       	add	r12,r6
80004444:	00 00       	add	r0,r0
80004446:	0b fc       	ld.ub	r12,r5[0x7]
80004448:	00 00       	add	r0,r0
8000444a:	0c 08       	add	r8,r6
8000444c:	00 00       	add	r0,r0
8000444e:	0b f9       	ld.ub	r9,r5[0x7]
80004450:	00 00       	add	r0,r0
80004452:	0b f8       	ld.ub	r8,r5[0x7]

80004454 <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
80004454:	eb cd 40 e0 	pushm	r5-r7,lr
80004458:	18 97       	mov	r7,r12
8000445a:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
8000445c:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
80004460:	49 f9       	lddpc	r9,800044dc <twi_master_init+0x88>
80004462:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
80004464:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
80004466:	3f f9       	mov	r9,-1
80004468:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
8000446a:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
8000446c:	e0 69 00 80 	mov	r9,128
80004470:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004472:	e6 18 00 01 	andh	r8,0x1,COH
80004476:	c0 21       	brne	8000447a <twi_master_init+0x26>
      cpu_irq_enable();
80004478:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
8000447a:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000447c:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80004480:	d3 03       	ssrf	0x10
	
	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();

	irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL);
80004482:	30 3a       	mov	r10,3
80004484:	e0 6b 01 60 	mov	r11,352
80004488:	49 6c       	lddpc	r12,800044e0 <twi_master_init+0x8c>
8000448a:	f0 1f 00 17 	mcall	800044e4 <twi_master_init+0x90>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000448e:	e6 16 00 01 	andh	r6,0x1,COH
80004492:	c0 21       	brne	80004496 <twi_master_init+0x42>
      cpu_irq_enable();
80004494:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
80004496:	6a 19       	ld.w	r9,r5[0x4]
80004498:	a1 79       	lsl	r9,0x1
8000449a:	6a 08       	ld.w	r8,r5[0x0]
8000449c:	f0 09 0d 08 	divu	r8,r8,r9
800044a0:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
800044a2:	e0 48 00 ff 	cp.w	r8,255
800044a6:	e0 8b 00 04 	brhi	800044ae <twi_master_init+0x5a>
800044aa:	30 09       	mov	r9,0
800044ac:	c0 f8       	rjmp	800044ca <twi_master_init+0x76>
800044ae:	30 09       	mov	r9,0
800044b0:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
800044b2:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
800044b4:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
800044b6:	e0 48 00 ff 	cp.w	r8,255
800044ba:	5f bb       	srhi	r11
800044bc:	58 69       	cp.w	r9,6
800044be:	5f 8a       	srls	r10
800044c0:	f7 ea 00 0a 	and	r10,r11,r10
800044c4:	f8 0a 18 00 	cp.b	r10,r12
800044c8:	cf 51       	brne	800044b2 <twi_master_init+0x5e>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
800044ca:	b1 69       	lsl	r9,0x10
800044cc:	f3 e8 10 89 	or	r9,r9,r8<<0x8
800044d0:	f3 e8 10 08 	or	r8,r9,r8
800044d4:	8f 48       	st.w	r7[0x10],r8

	//Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
800044d6:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800044da:	00 00       	add	r0,r0
800044dc:	00 00       	add	r0,r0
800044de:	0c 04       	add	r4,r6
800044e0:	80 00       	ld.sh	r0,r0[0x0]
800044e2:	43 98       	lddsp	r8,sp[0xe4]
800044e4:	80 00       	ld.sh	r0,r0[0x0]
800044e6:	40 90       	lddsp	r0,sp[0x24]

800044e8 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800044e8:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800044ea:	f6 08 15 04 	lsl	r8,r11,0x4
800044ee:	14 38       	cp.w	r8,r10
800044f0:	f9 b8 08 10 	movls	r8,16
800044f4:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800044f8:	f0 0b 02 4b 	mul	r11,r8,r11
800044fc:	f6 09 16 01 	lsr	r9,r11,0x1
80004500:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80004504:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80004508:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
8000450c:	f2 cb 00 01 	sub	r11,r9,1
80004510:	e0 4b ff fe 	cp.w	r11,65534
80004514:	e0 88 00 03 	brls	8000451a <usart_set_async_baudrate+0x32>
80004518:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
8000451a:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
8000451c:	e8 6e 00 00 	mov	lr,524288
80004520:	59 08       	cp.w	r8,16
80004522:	fc 08 17 10 	movne	r8,lr
80004526:	f9 b8 00 00 	moveq	r8,0
8000452a:	e4 1b ff f7 	andh	r11,0xfff7
8000452e:	e0 1b fe cf 	andl	r11,0xfecf
80004532:	16 48       	or	r8,r11
80004534:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80004536:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
8000453a:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000453e:	99 89       	st.w	r12[0x20],r9
80004540:	d8 0a       	popm	pc,r12=0

80004542 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004542:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80004544:	e2 18 00 02 	andl	r8,0x2,COH
80004548:	c0 31       	brne	8000454e <usart_write_char+0xc>
8000454a:	30 2c       	mov	r12,2
8000454c:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000454e:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80004552:	99 7b       	st.w	r12[0x1c],r11
80004554:	5e fd       	retal	0
80004556:	d7 03       	nop

80004558 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004558:	eb cd 40 e0 	pushm	r5-r7,lr
8000455c:	18 96       	mov	r6,r12
8000455e:	16 95       	mov	r5,r11
80004560:	e0 67 27 0f 	mov	r7,9999
80004564:	c0 68       	rjmp	80004570 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80004566:	58 07       	cp.w	r7,0
80004568:	c0 31       	brne	8000456e <usart_putchar+0x16>
8000456a:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000456e:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004570:	0a 9b       	mov	r11,r5
80004572:	0c 9c       	mov	r12,r6
80004574:	f0 1f 00 03 	mcall	80004580 <usart_putchar+0x28>
80004578:	cf 71       	brne	80004566 <usart_putchar+0xe>

  return USART_SUCCESS;
}
8000457a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000457e:	00 00       	add	r0,r0
80004580:	80 00       	ld.sh	r0,r0[0x0]
80004582:	45 42       	lddsp	r2,sp[0x150]

80004584 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004584:	78 58       	ld.w	r8,r12[0x14]
80004586:	e2 18 00 e0 	andl	r8,0xe0,COH
8000458a:	c0 30       	breq	80004590 <usart_read_char+0xc>
8000458c:	30 4c       	mov	r12,4
8000458e:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004590:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004592:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004596:	c0 31       	brne	8000459c <usart_read_char+0x18>
80004598:	30 3c       	mov	r12,3
8000459a:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
8000459c:	78 68       	ld.w	r8,r12[0x18]
8000459e:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800045a2:	97 08       	st.w	r11[0x0],r8
800045a4:	5e fd       	retal	0
800045a6:	d7 03       	nop

800045a8 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800045a8:	eb cd 40 c0 	pushm	r6-r7,lr
800045ac:	20 1d       	sub	sp,4
800045ae:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800045b0:	1a 97       	mov	r7,sp
800045b2:	1a 9b       	mov	r11,sp
800045b4:	0c 9c       	mov	r12,r6
800045b6:	f0 1f 00 07 	mcall	800045d0 <usart_getchar+0x28>
800045ba:	58 3c       	cp.w	r12,3
800045bc:	cf b0       	breq	800045b2 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800045be:	58 4c       	cp.w	r12,4
800045c0:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800045c4:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800045c8:	2f fd       	sub	sp,-4
800045ca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800045ce:	00 00       	add	r0,r0
800045d0:	80 00       	ld.sh	r0,r0[0x0]
800045d2:	45 84       	lddsp	r4,sp[0x160]

800045d4 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800045d4:	eb cd 40 c0 	pushm	r6-r7,lr
800045d8:	18 96       	mov	r6,r12
800045da:	16 97       	mov	r7,r11
  while (*string != '\0')
800045dc:	17 8b       	ld.ub	r11,r11[0x0]
800045de:	58 0b       	cp.w	r11,0
800045e0:	c0 80       	breq	800045f0 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800045e2:	2f f7       	sub	r7,-1
800045e4:	0c 9c       	mov	r12,r6
800045e6:	f0 1f 00 04 	mcall	800045f4 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800045ea:	0f 8b       	ld.ub	r11,r7[0x0]
800045ec:	58 0b       	cp.w	r11,0
800045ee:	cf a1       	brne	800045e2 <usart_write_line+0xe>
800045f0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800045f4:	80 00       	ld.sh	r0,r0[0x0]
800045f6:	45 58       	lddsp	r8,sp[0x154]

800045f8 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800045f8:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800045fc:	e6 18 00 01 	andh	r8,0x1,COH
80004600:	c0 71       	brne	8000460e <usart_reset+0x16>
80004602:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80004604:	3f f8       	mov	r8,-1
80004606:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004608:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
8000460a:	d5 03       	csrf	0x10
8000460c:	c0 48       	rjmp	80004614 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
8000460e:	3f f8       	mov	r8,-1
80004610:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004612:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004614:	30 08       	mov	r8,0
80004616:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80004618:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
8000461a:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
8000461c:	ea 68 61 0c 	mov	r8,680204
80004620:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004622:	5e fc       	retal	r12

80004624 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004624:	eb cd 40 e0 	pushm	r5-r7,lr
80004628:	18 96       	mov	r6,r12
8000462a:	16 97       	mov	r7,r11
8000462c:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000462e:	f0 1f 00 2f 	mcall	800046e8 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80004632:	58 07       	cp.w	r7,0
80004634:	c5 80       	breq	800046e4 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80004636:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004638:	30 49       	mov	r9,4
8000463a:	f2 08 18 00 	cp.b	r8,r9
8000463e:	e0 88 00 53 	brls	800046e4 <usart_init_rs232+0xc0>
80004642:	30 99       	mov	r9,9
80004644:	f2 08 18 00 	cp.b	r8,r9
80004648:	e0 8b 00 4e 	brhi	800046e4 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
8000464c:	0f d9       	ld.ub	r9,r7[0x5]
8000464e:	30 78       	mov	r8,7
80004650:	f0 09 18 00 	cp.b	r9,r8
80004654:	e0 8b 00 48 	brhi	800046e4 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80004658:	8e 39       	ld.sh	r9,r7[0x6]
8000465a:	e0 68 01 01 	mov	r8,257
8000465e:	f0 09 19 00 	cp.h	r9,r8
80004662:	e0 8b 00 41 	brhi	800046e4 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80004666:	ef 39 00 08 	ld.ub	r9,r7[8]
8000466a:	30 38       	mov	r8,3
8000466c:	f0 09 18 00 	cp.b	r9,r8
80004670:	e0 8b 00 3a 	brhi	800046e4 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004674:	0a 9a       	mov	r10,r5
80004676:	6e 0b       	ld.w	r11,r7[0x0]
80004678:	0c 9c       	mov	r12,r6
8000467a:	f0 1f 00 1d 	mcall	800046ec <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000467e:	58 1c       	cp.w	r12,1
80004680:	c3 20       	breq	800046e4 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80004682:	0f c8       	ld.ub	r8,r7[0x4]
80004684:	30 99       	mov	r9,9
80004686:	f2 08 18 00 	cp.b	r8,r9
8000468a:	c0 51       	brne	80004694 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
8000468c:	6c 18       	ld.w	r8,r6[0x4]
8000468e:	b1 b8       	sbr	r8,0x11
80004690:	8d 18       	st.w	r6[0x4],r8
80004692:	c0 68       	rjmp	8000469e <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004694:	6c 19       	ld.w	r9,r6[0x4]
80004696:	20 58       	sub	r8,5
80004698:	f3 e8 10 68 	or	r8,r9,r8<<0x6
8000469c:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
8000469e:	6c 19       	ld.w	r9,r6[0x4]
800046a0:	ef 3a 00 08 	ld.ub	r10,r7[8]
800046a4:	0f d8       	ld.ub	r8,r7[0x5]
800046a6:	a9 78       	lsl	r8,0x9
800046a8:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800046ac:	12 48       	or	r8,r9
800046ae:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800046b0:	8e 38       	ld.sh	r8,r7[0x6]
800046b2:	30 29       	mov	r9,2
800046b4:	f2 08 19 00 	cp.h	r8,r9
800046b8:	e0 88 00 09 	brls	800046ca <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800046bc:	6c 18       	ld.w	r8,r6[0x4]
800046be:	ad b8       	sbr	r8,0xd
800046c0:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800046c2:	8e b8       	ld.uh	r8,r7[0x6]
800046c4:	20 28       	sub	r8,2
800046c6:	8d a8       	st.w	r6[0x28],r8
800046c8:	c0 68       	rjmp	800046d4 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800046ca:	6c 19       	ld.w	r9,r6[0x4]
800046cc:	5c 78       	castu.h	r8
800046ce:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800046d2:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800046d4:	6c 18       	ld.w	r8,r6[0x4]
800046d6:	e0 18 ff f0 	andl	r8,0xfff0
800046da:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800046dc:	35 08       	mov	r8,80
800046de:	8d 08       	st.w	r6[0x0],r8
800046e0:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800046e4:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800046e8:	80 00       	ld.sh	r0,r0[0x0]
800046ea:	45 f8       	lddsp	r8,sp[0x17c]
800046ec:	80 00       	ld.sh	r0,r0[0x0]
800046ee:	44 e8       	lddsp	r8,sp[0x138]

800046f0 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
800046f0:	f8 c8 ff f8 	sub	r8,r12,-8
800046f4:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
800046f6:	3f f9       	mov	r9,-1
800046f8:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
800046fa:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
800046fc:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
800046fe:	30 08       	mov	r8,0
80004700:	99 08       	st.w	r12[0x0],r8
}
80004702:	5e fc       	retal	r12

80004704 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004704:	30 08       	mov	r8,0
80004706:	99 48       	st.w	r12[0x10],r8
}
80004708:	5e fc       	retal	r12

8000470a <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
8000470a:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
8000470c:	70 19       	ld.w	r9,r8[0x4]
8000470e:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004710:	78 19       	ld.w	r9,r12[0x4]
80004712:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004714:	70 19       	ld.w	r9,r8[0x4]
80004716:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004718:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
8000471a:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
8000471c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000471e:	78 08       	ld.w	r8,r12[0x0]
80004720:	2f f8       	sub	r8,-1
80004722:	99 08       	st.w	r12[0x0],r8
}
80004724:	5e fc       	retal	r12

80004726 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004726:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004728:	5b fa       	cp.w	r10,-1
8000472a:	c0 31       	brne	80004730 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
8000472c:	78 48       	ld.w	r8,r12[0x10]
8000472e:	c0 c8       	rjmp	80004746 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004730:	f8 c8 ff f8 	sub	r8,r12,-8
80004734:	70 19       	ld.w	r9,r8[0x4]
80004736:	72 09       	ld.w	r9,r9[0x0]
80004738:	12 3a       	cp.w	r10,r9
8000473a:	c0 63       	brcs	80004746 <vListInsert+0x20>
8000473c:	70 18       	ld.w	r8,r8[0x4]
8000473e:	70 19       	ld.w	r9,r8[0x4]
80004740:	72 09       	ld.w	r9,r9[0x0]
80004742:	12 3a       	cp.w	r10,r9
80004744:	cf c2       	brcc	8000473c <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80004746:	70 19       	ld.w	r9,r8[0x4]
80004748:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
8000474a:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
8000474c:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
8000474e:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004750:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004752:	78 08       	ld.w	r8,r12[0x0]
80004754:	2f f8       	sub	r8,-1
80004756:	99 08       	st.w	r12[0x0],r8
}
80004758:	5e fc       	retal	r12

8000475a <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
8000475a:	78 18       	ld.w	r8,r12[0x4]
8000475c:	78 29       	ld.w	r9,r12[0x8]
8000475e:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80004760:	78 28       	ld.w	r8,r12[0x8]
80004762:	78 19       	ld.w	r9,r12[0x4]
80004764:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80004766:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80004768:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
8000476a:	18 39       	cp.w	r9,r12
8000476c:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80004770:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004774:	30 09       	mov	r9,0
80004776:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80004778:	70 09       	ld.w	r9,r8[0x0]
8000477a:	20 19       	sub	r9,1
8000477c:	91 09       	st.w	r8[0x0],r9
}
8000477e:	5e fc       	retal	r12

80004780 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80004780:	e0 68 08 08 	mov	r8,2056
80004784:	ea 18 08 08 	orh	r8,0x808
80004788:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
8000478a:	e0 68 09 09 	mov	r8,2313
8000478e:	ea 18 09 09 	orh	r8,0x909
80004792:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80004794:	e0 68 0a 0a 	mov	r8,2570
80004798:	ea 18 0a 0a 	orh	r8,0xa0a
8000479c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
8000479e:	e0 68 0b 0b 	mov	r8,2827
800047a2:	ea 18 0b 0b 	orh	r8,0xb0b
800047a6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800047a8:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
800047aa:	e0 68 be ef 	mov	r8,48879
800047ae:	ea 18 de ad 	orh	r8,0xdead
800047b2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
800047b4:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
800047b6:	fc 18 00 40 	movh	r8,0x40
800047ba:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
800047bc:	e0 68 00 ff 	mov	r8,255
800047c0:	ea 18 ff 00 	orh	r8,0xff00
800047c4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
800047c6:	e0 68 01 01 	mov	r8,257
800047ca:	ea 18 01 01 	orh	r8,0x101
800047ce:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
800047d0:	e0 68 02 02 	mov	r8,514
800047d4:	ea 18 02 02 	orh	r8,0x202
800047d8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
800047da:	e0 68 03 03 	mov	r8,771
800047de:	ea 18 03 03 	orh	r8,0x303
800047e2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
800047e4:	e0 68 04 04 	mov	r8,1028
800047e8:	ea 18 04 04 	orh	r8,0x404
800047ec:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800047ee:	e0 68 05 05 	mov	r8,1285
800047f2:	ea 18 05 05 	orh	r8,0x505
800047f6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800047f8:	e0 68 06 06 	mov	r8,1542
800047fc:	ea 18 06 06 	orh	r8,0x606
80004800:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80004802:	e0 68 07 07 	mov	r8,1799
80004806:	ea 18 07 07 	orh	r8,0x707
8000480a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
8000480c:	30 08       	mov	r8,0
8000480e:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80004810:	5e fc       	retal	r12
80004812:	d7 03       	nop

80004814 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80004814:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80004816:	48 38       	lddpc	r8,80004820 <vPortEnterCritical+0xc>
80004818:	70 09       	ld.w	r9,r8[0x0]
8000481a:	2f f9       	sub	r9,-1
8000481c:	91 09       	st.w	r8[0x0],r9
}
8000481e:	5e fc       	retal	r12
80004820:	00 00       	add	r0,r0
80004822:	05 30       	ld.ub	r0,r2++

80004824 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80004824:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80004826:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80004828:	30 0a       	mov	r10,0
8000482a:	14 9b       	mov	r11,r10
8000482c:	49 2c       	lddpc	r12,80004874 <xPortStartScheduler+0x50>
8000482e:	f0 1f 00 13 	mcall	80004878 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80004832:	e0 68 5d c0 	mov	r8,24000
80004836:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
8000483a:	30 08       	mov	r8,0
8000483c:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80004840:	e0 68 0c e4 	mov	r8,3300
80004844:	ea 18 00 00 	orh	r8,0x0
80004848:	70 00       	ld.w	r0,r8[0x0]
8000484a:	60 0d       	ld.w	sp,r0[0x0]
8000484c:	1b 00       	ld.w	r0,sp++
8000484e:	e0 68 05 30 	mov	r8,1328
80004852:	ea 18 00 00 	orh	r8,0x0
80004856:	91 00       	st.w	r8[0x0],r0
80004858:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000485c:	2f ed       	sub	sp,-8
8000485e:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80004862:	fa f0 ff e0 	ld.w	r0,sp[-32]
80004866:	e3 b0 00 00 	mtsr	0x0,r0
8000486a:	fa f0 ff dc 	ld.w	r0,sp[-36]
8000486e:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80004872:	d8 0a       	popm	pc,r12=0
80004874:	80 00       	ld.sh	r0,r0[0x0]
80004876:	49 40       	lddpc	r0,800048c4 <SCALLYield+0x48>
80004878:	80 00       	ld.sh	r0,r0[0x0]
8000487a:	40 90       	lddsp	r0,sp[0x24]

8000487c <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
8000487c:	20 6d       	sub	sp,24
8000487e:	eb cd 00 ff 	pushm	r0-r7
80004882:	fa c7 ff c0 	sub	r7,sp,-64
80004886:	ee f0 ff f8 	ld.w	r0,r7[-8]
8000488a:	ef 40 ff e0 	st.w	r7[-32],r0
8000488e:	ee f0 ff fc 	ld.w	r0,r7[-4]
80004892:	ef 40 ff e4 	st.w	r7[-28],r0
80004896:	eb c7 5f 00 	stm	--r7,r8-r12,lr
8000489a:	e0 68 05 30 	mov	r8,1328
8000489e:	ea 18 00 00 	orh	r8,0x0
800048a2:	70 00       	ld.w	r0,r8[0x0]
800048a4:	1a d0       	st.w	--sp,r0
800048a6:	f0 1f 00 1a 	mcall	8000490c <LABEL_RET_SCALL_263+0x14>
800048aa:	e0 68 0c e4 	mov	r8,3300
800048ae:	ea 18 00 00 	orh	r8,0x0
800048b2:	70 00       	ld.w	r0,r8[0x0]
800048b4:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800048b6:	f0 1f 00 17 	mcall	80004910 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
800048ba:	e0 68 0c e4 	mov	r8,3300
800048be:	ea 18 00 00 	orh	r8,0x0
800048c2:	70 00       	ld.w	r0,r8[0x0]
800048c4:	60 0d       	ld.w	sp,r0[0x0]
800048c6:	1b 00       	ld.w	r0,sp++
800048c8:	e0 68 05 30 	mov	r8,1328
800048cc:	ea 18 00 00 	orh	r8,0x0
800048d0:	91 00       	st.w	r8[0x0],r0
800048d2:	fa c7 ff d8 	sub	r7,sp,-40
800048d6:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800048da:	ee f0 ff e0 	ld.w	r0,r7[-32]
800048de:	e0 61 05 30 	mov	r1,1328
800048e2:	ea 11 00 00 	orh	r1,0x0
800048e6:	62 02       	ld.w	r2,r1[0x0]
800048e8:	58 02       	cp.w	r2,0
800048ea:	c0 70       	breq	800048f8 <LABEL_RET_SCALL_263>
800048ec:	e4 c2 00 01 	sub	r2,r2,1
800048f0:	83 02       	st.w	r1[0x0],r2
800048f2:	58 02       	cp.w	r2,0
800048f4:	c0 21       	brne	800048f8 <LABEL_RET_SCALL_263>
800048f6:	b1 c0       	cbr	r0,0x10

800048f8 <LABEL_RET_SCALL_263>:
800048f8:	ef 40 ff f8 	st.w	r7[-8],r0
800048fc:	ee f0 ff e4 	ld.w	r0,r7[-28]
80004900:	ef 40 ff fc 	st.w	r7[-4],r0
80004904:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004908:	2f ad       	sub	sp,-24
8000490a:	d6 13       	rets
8000490c:	80 00       	ld.sh	r0,r0[0x0]
8000490e:	48 14       	lddpc	r4,80004910 <LABEL_RET_SCALL_263+0x18>
80004910:	80 00       	ld.sh	r0,r0[0x0]
80004912:	4f b0       	lddpc	r0,80004afc <xQueueReceiveFromISR+0x24>

80004914 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80004914:	e1 b8 00 43 	mfsr	r8,0x10c
80004918:	e3 b8 00 43 	mtsr	0x10c,r8
	}
8000491c:	5e fc       	retal	r12
8000491e:	d7 03       	nop

80004920 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80004920:	48 78       	lddpc	r8,8000493c <vPortExitCritical+0x1c>
80004922:	70 08       	ld.w	r8,r8[0x0]
80004924:	58 08       	cp.w	r8,0
80004926:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80004928:	48 58       	lddpc	r8,8000493c <vPortExitCritical+0x1c>
8000492a:	70 09       	ld.w	r9,r8[0x0]
8000492c:	20 19       	sub	r9,1
8000492e:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80004930:	70 08       	ld.w	r8,r8[0x0]
80004932:	58 08       	cp.w	r8,0
80004934:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80004936:	d5 03       	csrf	0x10
80004938:	5e fc       	retal	r12
8000493a:	00 00       	add	r0,r0
8000493c:	00 00       	add	r0,r0
8000493e:	05 30       	ld.ub	r0,r2++

80004940 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80004940:	eb cd 00 ff 	pushm	r0-r7
80004944:	e0 68 05 30 	mov	r8,1328
80004948:	ea 18 00 00 	orh	r8,0x0
8000494c:	70 00       	ld.w	r0,r8[0x0]
8000494e:	1a d0       	st.w	--sp,r0
80004950:	7a 90       	ld.w	r0,sp[0x24]
80004952:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004956:	58 10       	cp.w	r0,1
80004958:	e0 8b 00 08 	brhi	80004968 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
8000495c:	e0 68 0c e4 	mov	r8,3300
80004960:	ea 18 00 00 	orh	r8,0x0
80004964:	70 00       	ld.w	r0,r8[0x0]
80004966:	81 0d       	st.w	r0[0x0],sp

80004968 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80004968:	f0 1f 00 12 	mcall	800049b0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
8000496c:	f0 1f 00 12 	mcall	800049b4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80004970:	f0 1f 00 12 	mcall	800049b8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80004974:	f0 1f 00 12 	mcall	800049bc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80004978:	7a 90       	ld.w	r0,sp[0x24]
8000497a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000497e:	58 10       	cp.w	r0,1
80004980:	e0 8b 00 0e 	brhi	8000499c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80004984:	f0 1f 00 0c 	mcall	800049b4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80004988:	f0 1f 00 0e 	mcall	800049c0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
8000498c:	f0 1f 00 0c 	mcall	800049bc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80004990:	e0 68 0c e4 	mov	r8,3300
80004994:	ea 18 00 00 	orh	r8,0x0
80004998:	70 00       	ld.w	r0,r8[0x0]
8000499a:	60 0d       	ld.w	sp,r0[0x0]

8000499c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
8000499c:	1b 00       	ld.w	r0,sp++
8000499e:	e0 68 05 30 	mov	r8,1328
800049a2:	ea 18 00 00 	orh	r8,0x0
800049a6:	91 00       	st.w	r8[0x0],r0
800049a8:	e3 cd 00 ff 	ldm	sp++,r0-r7
800049ac:	d6 03       	rete
800049ae:	00 00       	add	r0,r0
800049b0:	80 00       	ld.sh	r0,r0[0x0]
800049b2:	49 14       	lddpc	r4,800049f4 <_read+0x18>
800049b4:	80 00       	ld.sh	r0,r0[0x0]
800049b6:	48 14       	lddpc	r4,800049b8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
800049b8:	80 00       	ld.sh	r0,r0[0x0]
800049ba:	51 b4       	stdsp	sp[0x6c],r4
800049bc:	80 00       	ld.sh	r0,r0[0x0]
800049be:	49 20       	lddpc	r0,80004a04 <_read+0x28>
800049c0:	80 00       	ld.sh	r0,r0[0x0]
800049c2:	4f b0       	lddpc	r0,80004bac <prvUnlockQueue+0x84>

800049c4 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
800049c4:	d4 01       	pushm	lr
	vTaskSuspendAll();
800049c6:	f0 1f 00 02 	mcall	800049cc <__malloc_lock+0x8>
}
800049ca:	d8 02       	popm	pc
800049cc:	80 00       	ld.sh	r0,r0[0x0]
800049ce:	4f a0       	lddpc	r0,80004bb4 <prvUnlockQueue+0x8c>

800049d0 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
800049d0:	d4 01       	pushm	lr
	xTaskResumeAll();
800049d2:	f0 1f 00 02 	mcall	800049d8 <__malloc_unlock+0x8>
}
800049d6:	d8 02       	popm	pc
800049d8:	80 00       	ld.sh	r0,r0[0x0]
800049da:	53 5c       	stdsp	sp[0xd4],r12

800049dc <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
800049dc:	d4 21       	pushm	r4-r7,lr
800049de:	16 95       	mov	r5,r11
800049e0:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
800049e2:	58 0c       	cp.w	r12,0
800049e4:	c0 30       	breq	800049ea <_read+0xe>
800049e6:	3f f7       	mov	r7,-1
800049e8:	c1 48       	rjmp	80004a10 <_read+0x34>
    return -1;

  for (; len > 0; --len)
800049ea:	58 0a       	cp.w	r10,0
800049ec:	e0 89 00 04 	brgt	800049f4 <_read+0x18>
800049f0:	30 07       	mov	r7,0
800049f2:	c0 f8       	rjmp	80004a10 <_read+0x34>
800049f4:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
800049f6:	48 84       	lddpc	r4,80004a14 <_read+0x38>
800049f8:	68 0c       	ld.w	r12,r4[0x0]
800049fa:	f0 1f 00 08 	mcall	80004a18 <_read+0x3c>
    if (c < 0)
800049fe:	c0 95       	brlt	80004a10 <_read+0x34>
      break;

    *ptr++ = c;
80004a00:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80004a04:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80004a06:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80004a0a:	58 08       	cp.w	r8,0
80004a0c:	fe 99 ff f6 	brgt	800049f8 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80004a10:	0e 9c       	mov	r12,r7
80004a12:	d8 22       	popm	r4-r7,pc
80004a14:	00 00       	add	r0,r0
80004a16:	3f e0       	mov	r0,-2
80004a18:	80 00       	ld.sh	r0,r0[0x0]
80004a1a:	45 a8       	lddsp	r8,sp[0x168]

80004a1c <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80004a1c:	d4 21       	pushm	r4-r7,lr
80004a1e:	16 95       	mov	r5,r11
80004a20:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80004a22:	20 1c       	sub	r12,1
80004a24:	58 2c       	cp.w	r12,2
80004a26:	e0 8b 00 12 	brhi	80004a4a <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80004a2a:	58 0a       	cp.w	r10,0
80004a2c:	c0 31       	brne	80004a32 <_write+0x16>
80004a2e:	30 07       	mov	r7,0
80004a30:	c0 e8       	rjmp	80004a4c <_write+0x30>
80004a32:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80004a34:	48 74       	lddpc	r4,80004a50 <_write+0x34>
80004a36:	68 0c       	ld.w	r12,r4[0x0]
80004a38:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80004a3c:	f0 1f 00 06 	mcall	80004a54 <_write+0x38>
80004a40:	c0 55       	brlt	80004a4a <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80004a42:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80004a44:	0e 36       	cp.w	r6,r7
80004a46:	cf 81       	brne	80004a36 <_write+0x1a>
80004a48:	c0 28       	rjmp	80004a4c <_write+0x30>
80004a4a:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80004a4c:	0e 9c       	mov	r12,r7
80004a4e:	d8 22       	popm	r4-r7,pc
80004a50:	00 00       	add	r0,r0
80004a52:	3f e0       	mov	r0,-2
80004a54:	80 00       	ld.sh	r0,r0[0x0]
80004a56:	45 58       	lddsp	r8,sp[0x154]

80004a58 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80004a58:	eb cd 40 80 	pushm	r7,lr
80004a5c:	18 97       	mov	r7,r12
	if( pv )
80004a5e:	58 0c       	cp.w	r12,0
80004a60:	c0 80       	breq	80004a70 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80004a62:	f0 1f 00 05 	mcall	80004a74 <vPortFree+0x1c>
		{
			free( pv );
80004a66:	0e 9c       	mov	r12,r7
80004a68:	f0 1f 00 04 	mcall	80004a78 <vPortFree+0x20>
		}
		xTaskResumeAll();
80004a6c:	f0 1f 00 04 	mcall	80004a7c <vPortFree+0x24>
80004a70:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a74:	80 00       	ld.sh	r0,r0[0x0]
80004a76:	4f a0       	lddpc	r0,80004c5c <xQueueGenericReceive+0x94>
80004a78:	80 00       	ld.sh	r0,r0[0x0]
80004a7a:	5e cc       	retvs	r12
80004a7c:	80 00       	ld.sh	r0,r0[0x0]
80004a7e:	53 5c       	stdsp	sp[0xd4],r12

80004a80 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80004a80:	eb cd 40 80 	pushm	r7,lr
80004a84:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80004a86:	f0 1f 00 06 	mcall	80004a9c <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80004a8a:	0e 9c       	mov	r12,r7
80004a8c:	f0 1f 00 05 	mcall	80004aa0 <pvPortMalloc+0x20>
80004a90:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80004a92:	f0 1f 00 05 	mcall	80004aa4 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80004a96:	0e 9c       	mov	r12,r7
80004a98:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a9c:	80 00       	ld.sh	r0,r0[0x0]
80004a9e:	4f a0       	lddpc	r0,80004c84 <xQueueGenericReceive+0xbc>
80004aa0:	80 00       	ld.sh	r0,r0[0x0]
80004aa2:	5e dc       	retvc	r12
80004aa4:	80 00       	ld.sh	r0,r0[0x0]
80004aa6:	53 5c       	stdsp	sp[0xd4],r12

80004aa8 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80004aa8:	d4 01       	pushm	lr
80004aaa:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80004aac:	78 09       	ld.w	r9,r12[0x0]
80004aae:	58 09       	cp.w	r9,0
80004ab0:	c1 10       	breq	80004ad2 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80004ab2:	78 3a       	ld.w	r10,r12[0xc]
80004ab4:	79 09       	ld.w	r9,r12[0x40]
80004ab6:	f4 09 00 09 	add	r9,r10,r9
80004aba:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80004abc:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80004abe:	14 39       	cp.w	r9,r10
80004ac0:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80004ac4:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80004ac8:	79 0a       	ld.w	r10,r12[0x40]
80004aca:	78 3b       	ld.w	r11,r12[0xc]
80004acc:	10 9c       	mov	r12,r8
80004ace:	f0 1f 00 02 	mcall	80004ad4 <prvCopyDataFromQueue+0x2c>
80004ad2:	d8 02       	popm	pc
80004ad4:	80 00       	ld.sh	r0,r0[0x0]
80004ad6:	63 24       	ld.w	r4,r1[0x48]

80004ad8 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80004ad8:	eb cd 40 c0 	pushm	r6-r7,lr
80004adc:	18 97       	mov	r7,r12
80004ade:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80004ae0:	78 e8       	ld.w	r8,r12[0x38]
80004ae2:	58 08       	cp.w	r8,0
80004ae4:	c0 31       	brne	80004aea <xQueueReceiveFromISR+0x12>
80004ae6:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80004aea:	f0 1f 00 0e 	mcall	80004b20 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80004aee:	6e e8       	ld.w	r8,r7[0x38]
80004af0:	20 18       	sub	r8,1
80004af2:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80004af4:	6f 18       	ld.w	r8,r7[0x44]
80004af6:	5b f8       	cp.w	r8,-1
80004af8:	c0 d1       	brne	80004b12 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004afa:	6e 48       	ld.w	r8,r7[0x10]
80004afc:	58 08       	cp.w	r8,0
80004afe:	c0 f0       	breq	80004b1c <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004b00:	ee cc ff f0 	sub	r12,r7,-16
80004b04:	f0 1f 00 08 	mcall	80004b24 <xQueueReceiveFromISR+0x4c>
80004b08:	c0 a0       	breq	80004b1c <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80004b0a:	30 1c       	mov	r12,1
80004b0c:	8d 0c       	st.w	r6[0x0],r12
80004b0e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80004b12:	2f f8       	sub	r8,-1
80004b14:	ef 48 00 44 	st.w	r7[68],r8
80004b18:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004b1c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004b20:	80 00       	ld.sh	r0,r0[0x0]
80004b22:	4a a8       	lddpc	r8,80004bc8 <xQueueGenericReceive>
80004b24:	80 00       	ld.sh	r0,r0[0x0]
80004b26:	51 38       	stdsp	sp[0x4c],r8

80004b28 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80004b28:	eb cd 40 c0 	pushm	r6-r7,lr
80004b2c:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80004b2e:	f0 1f 00 23 	mcall	80004bb8 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80004b32:	6f 28       	ld.w	r8,r7[0x48]
80004b34:	58 08       	cp.w	r8,0
80004b36:	e0 8a 00 18 	brle	80004b66 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004b3a:	6e 98       	ld.w	r8,r7[0x24]
80004b3c:	58 08       	cp.w	r8,0
80004b3e:	c1 40       	breq	80004b66 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004b40:	ee c6 ff dc 	sub	r6,r7,-36
80004b44:	c0 48       	rjmp	80004b4c <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004b46:	6e 98       	ld.w	r8,r7[0x24]
80004b48:	58 08       	cp.w	r8,0
80004b4a:	c0 e0       	breq	80004b66 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004b4c:	0c 9c       	mov	r12,r6
80004b4e:	f0 1f 00 1c 	mcall	80004bbc <prvUnlockQueue+0x94>
80004b52:	c0 30       	breq	80004b58 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80004b54:	f0 1f 00 1b 	mcall	80004bc0 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80004b58:	6f 28       	ld.w	r8,r7[0x48]
80004b5a:	20 18       	sub	r8,1
80004b5c:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80004b60:	58 08       	cp.w	r8,0
80004b62:	fe 99 ff f2 	brgt	80004b46 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80004b66:	3f f8       	mov	r8,-1
80004b68:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80004b6c:	f0 1f 00 16 	mcall	80004bc4 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80004b70:	f0 1f 00 12 	mcall	80004bb8 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80004b74:	6f 18       	ld.w	r8,r7[0x44]
80004b76:	58 08       	cp.w	r8,0
80004b78:	e0 8a 00 18 	brle	80004ba8 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004b7c:	6e 48       	ld.w	r8,r7[0x10]
80004b7e:	58 08       	cp.w	r8,0
80004b80:	c1 40       	breq	80004ba8 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004b82:	ee c6 ff f0 	sub	r6,r7,-16
80004b86:	c0 48       	rjmp	80004b8e <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004b88:	6e 48       	ld.w	r8,r7[0x10]
80004b8a:	58 08       	cp.w	r8,0
80004b8c:	c0 e0       	breq	80004ba8 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004b8e:	0c 9c       	mov	r12,r6
80004b90:	f0 1f 00 0b 	mcall	80004bbc <prvUnlockQueue+0x94>
80004b94:	c0 30       	breq	80004b9a <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80004b96:	f0 1f 00 0b 	mcall	80004bc0 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80004b9a:	6f 18       	ld.w	r8,r7[0x44]
80004b9c:	20 18       	sub	r8,1
80004b9e:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80004ba2:	58 08       	cp.w	r8,0
80004ba4:	fe 99 ff f2 	brgt	80004b88 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80004ba8:	3f f8       	mov	r8,-1
80004baa:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80004bae:	f0 1f 00 06 	mcall	80004bc4 <prvUnlockQueue+0x9c>
}
80004bb2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004bb6:	00 00       	add	r0,r0
80004bb8:	80 00       	ld.sh	r0,r0[0x0]
80004bba:	48 14       	lddpc	r4,80004bbc <prvUnlockQueue+0x94>
80004bbc:	80 00       	ld.sh	r0,r0[0x0]
80004bbe:	51 38       	stdsp	sp[0x4c],r8
80004bc0:	80 00       	ld.sh	r0,r0[0x0]
80004bc2:	50 44       	stdsp	sp[0x10],r4
80004bc4:	80 00       	ld.sh	r0,r0[0x0]
80004bc6:	49 20       	lddpc	r0,80004c0c <xQueueGenericReceive+0x44>

80004bc8 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80004bc8:	d4 31       	pushm	r0-r7,lr
80004bca:	20 5d       	sub	sp,20
80004bcc:	18 97       	mov	r7,r12
80004bce:	50 0b       	stdsp	sp[0x0],r11
80004bd0:	50 2a       	stdsp	sp[0x8],r10
80004bd2:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80004bd4:	f8 c2 ff dc 	sub	r2,r12,-36
80004bd8:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80004bda:	fa c4 ff f4 	sub	r4,sp,-12
80004bde:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80004be0:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004be2:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80004be6:	f0 1f 00 3e 	mcall	80004cdc <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80004bea:	6e e8       	ld.w	r8,r7[0x38]
80004bec:	58 08       	cp.w	r8,0
80004bee:	c2 a0       	breq	80004c42 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80004bf0:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80004bf2:	40 0b       	lddsp	r11,sp[0x0]
80004bf4:	0e 9c       	mov	r12,r7
80004bf6:	f0 1f 00 3b 	mcall	80004ce0 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80004bfa:	40 18       	lddsp	r8,sp[0x4]
80004bfc:	58 08       	cp.w	r8,0
80004bfe:	c1 51       	brne	80004c28 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80004c00:	6e e8       	ld.w	r8,r7[0x38]
80004c02:	20 18       	sub	r8,1
80004c04:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80004c06:	6e 08       	ld.w	r8,r7[0x0]
80004c08:	58 08       	cp.w	r8,0
80004c0a:	c0 41       	brne	80004c12 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80004c0c:	f0 1f 00 36 	mcall	80004ce4 <xQueueGenericReceive+0x11c>
80004c10:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004c12:	6e 48       	ld.w	r8,r7[0x10]
80004c14:	58 08       	cp.w	r8,0
80004c16:	c1 20       	breq	80004c3a <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80004c18:	ee cc ff f0 	sub	r12,r7,-16
80004c1c:	f0 1f 00 33 	mcall	80004ce8 <xQueueGenericReceive+0x120>
80004c20:	58 1c       	cp.w	r12,1
80004c22:	c0 c1       	brne	80004c3a <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80004c24:	d7 33       	scall
80004c26:	c0 a8       	rjmp	80004c3a <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80004c28:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004c2a:	6e 98       	ld.w	r8,r7[0x24]
80004c2c:	58 08       	cp.w	r8,0
80004c2e:	c0 60       	breq	80004c3a <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004c30:	04 9c       	mov	r12,r2
80004c32:	f0 1f 00 2e 	mcall	80004ce8 <xQueueGenericReceive+0x120>
80004c36:	c0 20       	breq	80004c3a <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80004c38:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80004c3a:	f0 1f 00 2d 	mcall	80004cec <xQueueGenericReceive+0x124>
80004c3e:	30 1c       	mov	r12,1
				return pdPASS;
80004c40:	c4 c8       	rjmp	80004cd8 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80004c42:	40 28       	lddsp	r8,sp[0x8]
80004c44:	58 08       	cp.w	r8,0
80004c46:	c0 51       	brne	80004c50 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80004c48:	f0 1f 00 29 	mcall	80004cec <xQueueGenericReceive+0x124>
80004c4c:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80004c4e:	c4 58       	rjmp	80004cd8 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80004c50:	58 05       	cp.w	r5,0
80004c52:	c0 51       	brne	80004c5c <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80004c54:	08 9c       	mov	r12,r4
80004c56:	f0 1f 00 27 	mcall	80004cf0 <xQueueGenericReceive+0x128>
80004c5a:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80004c5c:	f0 1f 00 24 	mcall	80004cec <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80004c60:	f0 1f 00 25 	mcall	80004cf4 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80004c64:	f0 1f 00 1e 	mcall	80004cdc <xQueueGenericReceive+0x114>
80004c68:	6f 18       	ld.w	r8,r7[0x44]
80004c6a:	5b f8       	cp.w	r8,-1
80004c6c:	ef f1 0a 11 	st.weq	r7[0x44],r1
80004c70:	6f 28       	ld.w	r8,r7[0x48]
80004c72:	5b f8       	cp.w	r8,-1
80004c74:	ef f1 0a 12 	st.weq	r7[0x48],r1
80004c78:	f0 1f 00 1d 	mcall	80004cec <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004c7c:	06 9b       	mov	r11,r3
80004c7e:	08 9c       	mov	r12,r4
80004c80:	f0 1f 00 1e 	mcall	80004cf8 <xQueueGenericReceive+0x130>
80004c84:	c2 41       	brne	80004ccc <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80004c86:	f0 1f 00 16 	mcall	80004cdc <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80004c8a:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80004c8c:	f0 1f 00 18 	mcall	80004cec <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80004c90:	58 06       	cp.w	r6,0
80004c92:	c1 71       	brne	80004cc0 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80004c94:	6e 08       	ld.w	r8,r7[0x0]
80004c96:	58 08       	cp.w	r8,0
80004c98:	c0 81       	brne	80004ca8 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80004c9a:	f0 1f 00 11 	mcall	80004cdc <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80004c9e:	6e 1c       	ld.w	r12,r7[0x4]
80004ca0:	f0 1f 00 17 	mcall	80004cfc <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80004ca4:	f0 1f 00 12 	mcall	80004cec <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80004ca8:	40 2b       	lddsp	r11,sp[0x8]
80004caa:	04 9c       	mov	r12,r2
80004cac:	f0 1f 00 15 	mcall	80004d00 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80004cb0:	0e 9c       	mov	r12,r7
80004cb2:	f0 1f 00 15 	mcall	80004d04 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80004cb6:	f0 1f 00 15 	mcall	80004d08 <xQueueGenericReceive+0x140>
80004cba:	c9 61       	brne	80004be6 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80004cbc:	d7 33       	scall
80004cbe:	c9 4b       	rjmp	80004be6 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80004cc0:	0e 9c       	mov	r12,r7
80004cc2:	f0 1f 00 11 	mcall	80004d04 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80004cc6:	f0 1f 00 11 	mcall	80004d08 <xQueueGenericReceive+0x140>
80004cca:	c8 eb       	rjmp	80004be6 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80004ccc:	0e 9c       	mov	r12,r7
80004cce:	f0 1f 00 0e 	mcall	80004d04 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80004cd2:	f0 1f 00 0e 	mcall	80004d08 <xQueueGenericReceive+0x140>
80004cd6:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80004cd8:	2f bd       	sub	sp,-20
80004cda:	d8 32       	popm	r0-r7,pc
80004cdc:	80 00       	ld.sh	r0,r0[0x0]
80004cde:	48 14       	lddpc	r4,80004ce0 <xQueueGenericReceive+0x118>
80004ce0:	80 00       	ld.sh	r0,r0[0x0]
80004ce2:	4a a8       	lddpc	r8,80004d88 <xQueueGenericSendFromISR+0x4>
80004ce4:	80 00       	ld.sh	r0,r0[0x0]
80004ce6:	50 50       	stdsp	sp[0x14],r0
80004ce8:	80 00       	ld.sh	r0,r0[0x0]
80004cea:	51 38       	stdsp	sp[0x4c],r8
80004cec:	80 00       	ld.sh	r0,r0[0x0]
80004cee:	49 20       	lddpc	r0,80004d34 <prvCopyDataToQueue+0x28>
80004cf0:	80 00       	ld.sh	r0,r0[0x0]
80004cf2:	50 2c       	stdsp	sp[0x8],r12
80004cf4:	80 00       	ld.sh	r0,r0[0x0]
80004cf6:	4f a0       	lddpc	r0,80004edc <xQueueCreateMutex+0x8>
80004cf8:	80 00       	ld.sh	r0,r0[0x0]
80004cfa:	52 c8       	stdsp	sp[0xb0],r8
80004cfc:	80 00       	ld.sh	r0,r0[0x0]
80004cfe:	50 b4       	stdsp	sp[0x2c],r4
80004d00:	80 00       	ld.sh	r0,r0[0x0]
80004d02:	55 20       	stdsp	sp[0x148],r0
80004d04:	80 00       	ld.sh	r0,r0[0x0]
80004d06:	4b 28       	lddpc	r8,80004dcc <xQueueGenericSendFromISR+0x48>
80004d08:	80 00       	ld.sh	r0,r0[0x0]
80004d0a:	53 5c       	stdsp	sp[0xd4],r12

80004d0c <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80004d0c:	eb cd 40 80 	pushm	r7,lr
80004d10:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80004d12:	79 08       	ld.w	r8,r12[0x40]
80004d14:	58 08       	cp.w	r8,0
80004d16:	c0 a1       	brne	80004d2a <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80004d18:	78 08       	ld.w	r8,r12[0x0]
80004d1a:	58 08       	cp.w	r8,0
80004d1c:	c2 b1       	brne	80004d72 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80004d1e:	78 1c       	ld.w	r12,r12[0x4]
80004d20:	f0 1f 00 17 	mcall	80004d7c <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80004d24:	30 08       	mov	r8,0
80004d26:	8f 18       	st.w	r7[0x4],r8
80004d28:	c2 58       	rjmp	80004d72 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80004d2a:	58 0a       	cp.w	r10,0
80004d2c:	c1 01       	brne	80004d4c <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80004d2e:	10 9a       	mov	r10,r8
80004d30:	78 2c       	ld.w	r12,r12[0x8]
80004d32:	f0 1f 00 14 	mcall	80004d80 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80004d36:	6e 29       	ld.w	r9,r7[0x8]
80004d38:	6f 08       	ld.w	r8,r7[0x40]
80004d3a:	f2 08 00 08 	add	r8,r9,r8
80004d3e:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80004d40:	6e 19       	ld.w	r9,r7[0x4]
80004d42:	12 38       	cp.w	r8,r9
80004d44:	c1 73       	brcs	80004d72 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80004d46:	6e 08       	ld.w	r8,r7[0x0]
80004d48:	8f 28       	st.w	r7[0x8],r8
80004d4a:	c1 48       	rjmp	80004d72 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80004d4c:	10 9a       	mov	r10,r8
80004d4e:	78 3c       	ld.w	r12,r12[0xc]
80004d50:	f0 1f 00 0c 	mcall	80004d80 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80004d54:	6f 08       	ld.w	r8,r7[0x40]
80004d56:	6e 39       	ld.w	r9,r7[0xc]
80004d58:	f2 08 01 08 	sub	r8,r9,r8
80004d5c:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80004d5e:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80004d60:	12 38       	cp.w	r8,r9
80004d62:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80004d66:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80004d6a:	f3 d8 e3 19 	subcs	r9,r9,r8
80004d6e:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80004d72:	6e e8       	ld.w	r8,r7[0x38]
80004d74:	2f f8       	sub	r8,-1
80004d76:	8f e8       	st.w	r7[0x38],r8
}
80004d78:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d7c:	80 00       	ld.sh	r0,r0[0x0]
80004d7e:	50 5c       	stdsp	sp[0x14],r12
80004d80:	80 00       	ld.sh	r0,r0[0x0]
80004d82:	63 24       	ld.w	r4,r1[0x48]

80004d84 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80004d84:	eb cd 40 c0 	pushm	r6-r7,lr
80004d88:	18 97       	mov	r7,r12
80004d8a:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80004d8c:	78 ec       	ld.w	r12,r12[0x38]
80004d8e:	6e f8       	ld.w	r8,r7[0x3c]
80004d90:	10 3c       	cp.w	r12,r8
80004d92:	c0 33       	brcs	80004d98 <xQueueGenericSendFromISR+0x14>
80004d94:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80004d98:	12 9a       	mov	r10,r9
80004d9a:	0e 9c       	mov	r12,r7
80004d9c:	f0 1f 00 0c 	mcall	80004dcc <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80004da0:	6f 28       	ld.w	r8,r7[0x48]
80004da2:	5b f8       	cp.w	r8,-1
80004da4:	c0 d1       	brne	80004dbe <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004da6:	6e 98       	ld.w	r8,r7[0x24]
80004da8:	58 08       	cp.w	r8,0
80004daa:	c0 f0       	breq	80004dc8 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004dac:	ee cc ff dc 	sub	r12,r7,-36
80004db0:	f0 1f 00 08 	mcall	80004dd0 <xQueueGenericSendFromISR+0x4c>
80004db4:	c0 a0       	breq	80004dc8 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80004db6:	30 1c       	mov	r12,1
80004db8:	8d 0c       	st.w	r6[0x0],r12
80004dba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80004dbe:	2f f8       	sub	r8,-1
80004dc0:	ef 48 00 48 	st.w	r7[72],r8
80004dc4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004dc8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004dcc:	80 00       	ld.sh	r0,r0[0x0]
80004dce:	4d 0c       	lddpc	r12,80004f0c <xQueueCreateMutex+0x38>
80004dd0:	80 00       	ld.sh	r0,r0[0x0]
80004dd2:	51 38       	stdsp	sp[0x4c],r8

80004dd4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80004dd4:	d4 31       	pushm	r0-r7,lr
80004dd6:	20 5d       	sub	sp,20
80004dd8:	18 97       	mov	r7,r12
80004dda:	50 0b       	stdsp	sp[0x0],r11
80004ddc:	50 2a       	stdsp	sp[0x8],r10
80004dde:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80004de0:	f8 c0 ff f0 	sub	r0,r12,-16
80004de4:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80004de6:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80004dea:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004dec:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80004df0:	f0 1f 00 2f 	mcall	80004eac <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80004df4:	6e e9       	ld.w	r9,r7[0x38]
80004df6:	6e f8       	ld.w	r8,r7[0x3c]
80004df8:	10 39       	cp.w	r9,r8
80004dfa:	c1 42       	brcc	80004e22 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80004dfc:	40 1a       	lddsp	r10,sp[0x4]
80004dfe:	40 0b       	lddsp	r11,sp[0x0]
80004e00:	0e 9c       	mov	r12,r7
80004e02:	f0 1f 00 2c 	mcall	80004eb0 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004e06:	6e 98       	ld.w	r8,r7[0x24]
80004e08:	58 08       	cp.w	r8,0
80004e0a:	c0 80       	breq	80004e1a <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80004e0c:	ee cc ff dc 	sub	r12,r7,-36
80004e10:	f0 1f 00 29 	mcall	80004eb4 <xQueueGenericSend+0xe0>
80004e14:	58 1c       	cp.w	r12,1
80004e16:	c0 21       	brne	80004e1a <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80004e18:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80004e1a:	f0 1f 00 28 	mcall	80004eb8 <xQueueGenericSend+0xe4>
80004e1e:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80004e20:	c4 38       	rjmp	80004ea6 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80004e22:	40 28       	lddsp	r8,sp[0x8]
80004e24:	58 08       	cp.w	r8,0
80004e26:	c0 51       	brne	80004e30 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80004e28:	f0 1f 00 24 	mcall	80004eb8 <xQueueGenericSend+0xe4>
80004e2c:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80004e2e:	c3 c8       	rjmp	80004ea6 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80004e30:	58 04       	cp.w	r4,0
80004e32:	c0 51       	brne	80004e3c <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80004e34:	06 9c       	mov	r12,r3
80004e36:	f0 1f 00 22 	mcall	80004ebc <xQueueGenericSend+0xe8>
80004e3a:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80004e3c:	f0 1f 00 1f 	mcall	80004eb8 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80004e40:	f0 1f 00 20 	mcall	80004ec0 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80004e44:	f0 1f 00 1a 	mcall	80004eac <xQueueGenericSend+0xd8>
80004e48:	6f 18       	ld.w	r8,r7[0x44]
80004e4a:	5b f8       	cp.w	r8,-1
80004e4c:	ef f1 0a 11 	st.weq	r7[0x44],r1
80004e50:	6f 28       	ld.w	r8,r7[0x48]
80004e52:	5b f8       	cp.w	r8,-1
80004e54:	ef f1 0a 12 	st.weq	r7[0x48],r1
80004e58:	f0 1f 00 18 	mcall	80004eb8 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004e5c:	04 9b       	mov	r11,r2
80004e5e:	06 9c       	mov	r12,r3
80004e60:	f0 1f 00 19 	mcall	80004ec4 <xQueueGenericSend+0xf0>
80004e64:	c1 b1       	brne	80004e9a <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80004e66:	f0 1f 00 12 	mcall	80004eac <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80004e6a:	6e e5       	ld.w	r5,r7[0x38]
80004e6c:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80004e6e:	f0 1f 00 13 	mcall	80004eb8 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80004e72:	0c 35       	cp.w	r5,r6
80004e74:	c0 d1       	brne	80004e8e <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80004e76:	40 2b       	lddsp	r11,sp[0x8]
80004e78:	00 9c       	mov	r12,r0
80004e7a:	f0 1f 00 14 	mcall	80004ec8 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80004e7e:	0e 9c       	mov	r12,r7
80004e80:	f0 1f 00 13 	mcall	80004ecc <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80004e84:	f0 1f 00 13 	mcall	80004ed0 <xQueueGenericSend+0xfc>
80004e88:	cb 41       	brne	80004df0 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80004e8a:	d7 33       	scall
80004e8c:	cb 2b       	rjmp	80004df0 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80004e8e:	0e 9c       	mov	r12,r7
80004e90:	f0 1f 00 0f 	mcall	80004ecc <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80004e94:	f0 1f 00 0f 	mcall	80004ed0 <xQueueGenericSend+0xfc>
80004e98:	ca cb       	rjmp	80004df0 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80004e9a:	0e 9c       	mov	r12,r7
80004e9c:	f0 1f 00 0c 	mcall	80004ecc <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80004ea0:	f0 1f 00 0c 	mcall	80004ed0 <xQueueGenericSend+0xfc>
80004ea4:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80004ea6:	2f bd       	sub	sp,-20
80004ea8:	d8 32       	popm	r0-r7,pc
80004eaa:	00 00       	add	r0,r0
80004eac:	80 00       	ld.sh	r0,r0[0x0]
80004eae:	48 14       	lddpc	r4,80004eb0 <xQueueGenericSend+0xdc>
80004eb0:	80 00       	ld.sh	r0,r0[0x0]
80004eb2:	4d 0c       	lddpc	r12,80004ff0 <vTaskSwitchContext+0x40>
80004eb4:	80 00       	ld.sh	r0,r0[0x0]
80004eb6:	51 38       	stdsp	sp[0x4c],r8
80004eb8:	80 00       	ld.sh	r0,r0[0x0]
80004eba:	49 20       	lddpc	r0,80004f00 <xQueueCreateMutex+0x2c>
80004ebc:	80 00       	ld.sh	r0,r0[0x0]
80004ebe:	50 2c       	stdsp	sp[0x8],r12
80004ec0:	80 00       	ld.sh	r0,r0[0x0]
80004ec2:	4f a0       	lddpc	r0,800050a8 <vTaskPriorityDisinherit+0x4c>
80004ec4:	80 00       	ld.sh	r0,r0[0x0]
80004ec6:	52 c8       	stdsp	sp[0xb0],r8
80004ec8:	80 00       	ld.sh	r0,r0[0x0]
80004eca:	55 20       	stdsp	sp[0x148],r0
80004ecc:	80 00       	ld.sh	r0,r0[0x0]
80004ece:	4b 28       	lddpc	r8,80004f94 <xQueueCreate+0x68>
80004ed0:	80 00       	ld.sh	r0,r0[0x0]
80004ed2:	53 5c       	stdsp	sp[0xd4],r12

80004ed4 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80004ed4:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80004ed8:	34 cc       	mov	r12,76
80004eda:	f0 1f 00 12 	mcall	80004f20 <xQueueCreateMutex+0x4c>
80004ede:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80004ee0:	c1 d0       	breq	80004f1a <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80004ee2:	30 06       	mov	r6,0
80004ee4:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80004ee6:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80004ee8:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80004eea:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80004eec:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
80004eee:	30 18       	mov	r8,1
80004ef0:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
80004ef2:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80004ef6:	3f f8       	mov	r8,-1
80004ef8:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80004efc:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80004f00:	2f 0c       	sub	r12,-16
80004f02:	f0 1f 00 09 	mcall	80004f24 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80004f06:	ee cc ff dc 	sub	r12,r7,-36
80004f0a:	f0 1f 00 07 	mcall	80004f24 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
80004f0e:	0c 99       	mov	r9,r6
80004f10:	0c 9a       	mov	r10,r6
80004f12:	0c 9b       	mov	r11,r6
80004f14:	0e 9c       	mov	r12,r7
80004f16:	f0 1f 00 05 	mcall	80004f28 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80004f1a:	0e 9c       	mov	r12,r7
80004f1c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f20:	80 00       	ld.sh	r0,r0[0x0]
80004f22:	4a 80       	lddpc	r0,80004fc0 <vTaskSwitchContext+0x10>
80004f24:	80 00       	ld.sh	r0,r0[0x0]
80004f26:	46 f0       	lddsp	r0,sp[0x1bc]
80004f28:	80 00       	ld.sh	r0,r0[0x0]
80004f2a:	4d d4       	lddpc	r4,8000509c <vTaskPriorityDisinherit+0x40>

80004f2c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80004f2c:	d4 21       	pushm	r4-r7,lr
80004f2e:	18 97       	mov	r7,r12
80004f30:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80004f32:	58 0c       	cp.w	r12,0
80004f34:	c2 f0       	breq	80004f92 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80004f36:	34 cc       	mov	r12,76
80004f38:	f0 1f 00 17 	mcall	80004f94 <xQueueCreate+0x68>
80004f3c:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80004f3e:	c2 a0       	breq	80004f92 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80004f40:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80004f44:	e8 cc ff ff 	sub	r12,r4,-1
80004f48:	f0 1f 00 13 	mcall	80004f94 <xQueueCreate+0x68>
80004f4c:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80004f4e:	c1 e0       	breq	80004f8a <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80004f50:	f8 04 00 04 	add	r4,r12,r4
80004f54:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80004f56:	30 08       	mov	r8,0
80004f58:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80004f5a:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80004f5c:	ee c8 00 01 	sub	r8,r7,1
80004f60:	ad 38       	mul	r8,r6
80004f62:	10 0c       	add	r12,r8
80004f64:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80004f66:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80004f68:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80004f6c:	3f f8       	mov	r8,-1
80004f6e:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80004f72:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80004f76:	ea cc ff f0 	sub	r12,r5,-16
80004f7a:	f0 1f 00 08 	mcall	80004f98 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80004f7e:	ea cc ff dc 	sub	r12,r5,-36
80004f82:	f0 1f 00 06 	mcall	80004f98 <xQueueCreate+0x6c>
80004f86:	0a 9c       	mov	r12,r5
80004f88:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80004f8a:	0a 9c       	mov	r12,r5
80004f8c:	f0 1f 00 04 	mcall	80004f9c <xQueueCreate+0x70>
80004f90:	d8 2a       	popm	r4-r7,pc,r12=0
80004f92:	d8 2a       	popm	r4-r7,pc,r12=0
80004f94:	80 00       	ld.sh	r0,r0[0x0]
80004f96:	4a 80       	lddpc	r0,80005034 <vTaskSetTimeOutState+0x8>
80004f98:	80 00       	ld.sh	r0,r0[0x0]
80004f9a:	46 f0       	lddsp	r0,sp[0x1bc]
80004f9c:	80 00       	ld.sh	r0,r0[0x0]
80004f9e:	4a 58       	lddpc	r8,80005030 <vTaskSetTimeOutState+0x4>

80004fa0 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80004fa0:	48 38       	lddpc	r8,80004fac <vTaskSuspendAll+0xc>
80004fa2:	70 09       	ld.w	r9,r8[0x0]
80004fa4:	2f f9       	sub	r9,-1
80004fa6:	91 09       	st.w	r8[0x0],r9
}
80004fa8:	5e fc       	retal	r12
80004faa:	00 00       	add	r0,r0
80004fac:	00 00       	add	r0,r0
80004fae:	0d 14       	ld.sh	r4,r6++

80004fb0 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80004fb0:	49 a8       	lddpc	r8,80005018 <vTaskSwitchContext+0x68>
80004fb2:	70 08       	ld.w	r8,r8[0x0]
80004fb4:	58 08       	cp.w	r8,0
80004fb6:	c0 b1       	brne	80004fcc <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80004fb8:	49 98       	lddpc	r8,8000501c <vTaskSwitchContext+0x6c>
80004fba:	70 08       	ld.w	r8,r8[0x0]
80004fbc:	f0 08 00 28 	add	r8,r8,r8<<0x2
80004fc0:	49 89       	lddpc	r9,80005020 <vTaskSwitchContext+0x70>
80004fc2:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80004fc6:	58 08       	cp.w	r8,0
80004fc8:	c0 60       	breq	80004fd4 <vTaskSwitchContext+0x24>
80004fca:	c1 18       	rjmp	80004fec <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80004fcc:	30 19       	mov	r9,1
80004fce:	49 68       	lddpc	r8,80005024 <vTaskSwitchContext+0x74>
80004fd0:	91 09       	st.w	r8[0x0],r9
80004fd2:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80004fd4:	49 28       	lddpc	r8,8000501c <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80004fd6:	49 3a       	lddpc	r10,80005020 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80004fd8:	70 09       	ld.w	r9,r8[0x0]
80004fda:	20 19       	sub	r9,1
80004fdc:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80004fde:	70 09       	ld.w	r9,r8[0x0]
80004fe0:	f2 09 00 29 	add	r9,r9,r9<<0x2
80004fe4:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80004fe8:	58 09       	cp.w	r9,0
80004fea:	cf 70       	breq	80004fd8 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80004fec:	48 c8       	lddpc	r8,8000501c <vTaskSwitchContext+0x6c>
80004fee:	70 08       	ld.w	r8,r8[0x0]
80004ff0:	f0 08 00 28 	add	r8,r8,r8<<0x2
80004ff4:	48 b9       	lddpc	r9,80005020 <vTaskSwitchContext+0x70>
80004ff6:	f2 08 00 28 	add	r8,r9,r8<<0x2
80004ffa:	70 19       	ld.w	r9,r8[0x4]
80004ffc:	72 19       	ld.w	r9,r9[0x4]
80004ffe:	91 19       	st.w	r8[0x4],r9
80005000:	f0 ca ff f8 	sub	r10,r8,-8
80005004:	14 39       	cp.w	r9,r10
80005006:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000500a:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000500e:	70 18       	ld.w	r8,r8[0x4]
80005010:	70 39       	ld.w	r9,r8[0xc]
80005012:	48 68       	lddpc	r8,80005028 <vTaskSwitchContext+0x78>
80005014:	91 09       	st.w	r8[0x0],r9
80005016:	5e fc       	retal	r12
80005018:	00 00       	add	r0,r0
8000501a:	0d 14       	ld.sh	r4,r6++
8000501c:	00 00       	add	r0,r0
8000501e:	0d 4c       	ld.w	r12,--r6
80005020:	00 00       	add	r0,r0
80005022:	0c 30       	cp.w	r0,r6
80005024:	00 00       	add	r0,r0
80005026:	0d 34       	ld.ub	r4,r6++
80005028:	00 00       	add	r0,r0
8000502a:	0c e4       	st.h	--r6,r4

8000502c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
8000502c:	48 48       	lddpc	r8,8000503c <vTaskSetTimeOutState+0x10>
8000502e:	70 08       	ld.w	r8,r8[0x0]
80005030:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80005032:	48 48       	lddpc	r8,80005040 <vTaskSetTimeOutState+0x14>
80005034:	70 08       	ld.w	r8,r8[0x0]
80005036:	99 18       	st.w	r12[0x4],r8
}
80005038:	5e fc       	retal	r12
8000503a:	00 00       	add	r0,r0
8000503c:	00 00       	add	r0,r0
8000503e:	0c 28       	rsub	r8,r6
80005040:	00 00       	add	r0,r0
80005042:	0d 10       	ld.sh	r0,r6++

80005044 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80005044:	30 19       	mov	r9,1
80005046:	48 28       	lddpc	r8,8000504c <vTaskMissedYield+0x8>
80005048:	91 09       	st.w	r8[0x0],r9
}
8000504a:	5e fc       	retal	r12
8000504c:	00 00       	add	r0,r0
8000504e:	0d 34       	ld.ub	r4,r6++

80005050 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80005050:	48 28       	lddpc	r8,80005058 <xTaskGetCurrentTaskHandle+0x8>
80005052:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80005054:	5e fc       	retal	r12
80005056:	00 00       	add	r0,r0
80005058:	00 00       	add	r0,r0
8000505a:	0c e4       	st.h	--r6,r4

8000505c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
8000505c:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80005060:	58 0c       	cp.w	r12,0
80005062:	c1 f0       	breq	800050a0 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005064:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80005066:	78 b9       	ld.w	r9,r12[0x2c]
80005068:	79 18       	ld.w	r8,r12[0x44]
8000506a:	10 39       	cp.w	r9,r8
8000506c:	c1 a0       	breq	800050a0 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000506e:	f8 c6 ff fc 	sub	r6,r12,-4
80005072:	0c 9c       	mov	r12,r6
80005074:	f0 1f 00 0c 	mcall	800050a4 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80005078:	6f 1c       	ld.w	r12,r7[0x44]
8000507a:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
8000507c:	f8 08 11 08 	rsub	r8,r12,8
80005080:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80005082:	48 a8       	lddpc	r8,800050a8 <vTaskPriorityDisinherit+0x4c>
80005084:	70 08       	ld.w	r8,r8[0x0]
80005086:	10 3c       	cp.w	r12,r8
80005088:	e0 88 00 04 	brls	80005090 <vTaskPriorityDisinherit+0x34>
8000508c:	48 78       	lddpc	r8,800050a8 <vTaskPriorityDisinherit+0x4c>
8000508e:	91 0c       	st.w	r8[0x0],r12
80005090:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005094:	0c 9b       	mov	r11,r6
80005096:	48 68       	lddpc	r8,800050ac <vTaskPriorityDisinherit+0x50>
80005098:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000509c:	f0 1f 00 05 	mcall	800050b0 <vTaskPriorityDisinherit+0x54>
800050a0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800050a4:	80 00       	ld.sh	r0,r0[0x0]
800050a6:	47 5a       	lddsp	r10,sp[0x1d4]
800050a8:	00 00       	add	r0,r0
800050aa:	0d 4c       	ld.w	r12,--r6
800050ac:	00 00       	add	r0,r0
800050ae:	0c 30       	cp.w	r0,r6
800050b0:	80 00       	ld.sh	r0,r0[0x0]
800050b2:	47 0a       	lddsp	r10,sp[0x1c0]

800050b4 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800050b4:	eb cd 40 c0 	pushm	r6-r7,lr
800050b8:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800050ba:	49 b8       	lddpc	r8,80005124 <vTaskPriorityInherit+0x70>
800050bc:	70 08       	ld.w	r8,r8[0x0]
800050be:	78 b9       	ld.w	r9,r12[0x2c]
800050c0:	70 b8       	ld.w	r8,r8[0x2c]
800050c2:	10 39       	cp.w	r9,r8
800050c4:	c2 d2       	brcc	8000511e <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800050c6:	49 88       	lddpc	r8,80005124 <vTaskPriorityInherit+0x70>
800050c8:	70 08       	ld.w	r8,r8[0x0]
800050ca:	70 b8       	ld.w	r8,r8[0x2c]
800050cc:	f0 08 11 08 	rsub	r8,r8,8
800050d0:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800050d2:	f2 09 00 28 	add	r8,r9,r9<<0x2
800050d6:	49 59       	lddpc	r9,80005128 <vTaskPriorityInherit+0x74>
800050d8:	f2 08 00 28 	add	r8,r9,r8<<0x2
800050dc:	78 59       	ld.w	r9,r12[0x14]
800050de:	10 39       	cp.w	r9,r8
800050e0:	c1 b1       	brne	80005116 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800050e2:	f8 c6 ff fc 	sub	r6,r12,-4
800050e6:	0c 9c       	mov	r12,r6
800050e8:	f0 1f 00 11 	mcall	8000512c <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800050ec:	48 e8       	lddpc	r8,80005124 <vTaskPriorityInherit+0x70>
800050ee:	70 08       	ld.w	r8,r8[0x0]
800050f0:	70 bc       	ld.w	r12,r8[0x2c]
800050f2:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800050f4:	48 f8       	lddpc	r8,80005130 <vTaskPriorityInherit+0x7c>
800050f6:	70 08       	ld.w	r8,r8[0x0]
800050f8:	10 3c       	cp.w	r12,r8
800050fa:	e0 88 00 04 	brls	80005102 <vTaskPriorityInherit+0x4e>
800050fe:	48 d8       	lddpc	r8,80005130 <vTaskPriorityInherit+0x7c>
80005100:	91 0c       	st.w	r8[0x0],r12
80005102:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005106:	0c 9b       	mov	r11,r6
80005108:	48 88       	lddpc	r8,80005128 <vTaskPriorityInherit+0x74>
8000510a:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000510e:	f0 1f 00 0a 	mcall	80005134 <vTaskPriorityInherit+0x80>
80005112:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005116:	48 48       	lddpc	r8,80005124 <vTaskPriorityInherit+0x70>
80005118:	70 08       	ld.w	r8,r8[0x0]
8000511a:	70 b8       	ld.w	r8,r8[0x2c]
8000511c:	99 b8       	st.w	r12[0x2c],r8
8000511e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005122:	00 00       	add	r0,r0
80005124:	00 00       	add	r0,r0
80005126:	0c e4       	st.h	--r6,r4
80005128:	00 00       	add	r0,r0
8000512a:	0c 30       	cp.w	r0,r6
8000512c:	80 00       	ld.sh	r0,r0[0x0]
8000512e:	47 5a       	lddsp	r10,sp[0x1d4]
80005130:	00 00       	add	r0,r0
80005132:	0d 4c       	ld.w	r12,--r6
80005134:	80 00       	ld.sh	r0,r0[0x0]
80005136:	47 0a       	lddsp	r10,sp[0x1c0]

80005138 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80005138:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
8000513c:	78 38       	ld.w	r8,r12[0xc]
8000513e:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80005140:	ee c6 ff e8 	sub	r6,r7,-24
80005144:	0c 9c       	mov	r12,r6
80005146:	f0 1f 00 15 	mcall	80005198 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000514a:	49 58       	lddpc	r8,8000519c <xTaskRemoveFromEventList+0x64>
8000514c:	70 08       	ld.w	r8,r8[0x0]
8000514e:	58 08       	cp.w	r8,0
80005150:	c1 71       	brne	8000517e <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80005152:	ee c6 ff fc 	sub	r6,r7,-4
80005156:	0c 9c       	mov	r12,r6
80005158:	f0 1f 00 10 	mcall	80005198 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
8000515c:	6e bc       	ld.w	r12,r7[0x2c]
8000515e:	49 18       	lddpc	r8,800051a0 <xTaskRemoveFromEventList+0x68>
80005160:	70 08       	ld.w	r8,r8[0x0]
80005162:	10 3c       	cp.w	r12,r8
80005164:	e0 88 00 04 	brls	8000516c <xTaskRemoveFromEventList+0x34>
80005168:	48 e8       	lddpc	r8,800051a0 <xTaskRemoveFromEventList+0x68>
8000516a:	91 0c       	st.w	r8[0x0],r12
8000516c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005170:	0c 9b       	mov	r11,r6
80005172:	48 d8       	lddpc	r8,800051a4 <xTaskRemoveFromEventList+0x6c>
80005174:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005178:	f0 1f 00 0c 	mcall	800051a8 <xTaskRemoveFromEventList+0x70>
8000517c:	c0 58       	rjmp	80005186 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000517e:	0c 9b       	mov	r11,r6
80005180:	48 bc       	lddpc	r12,800051ac <xTaskRemoveFromEventList+0x74>
80005182:	f0 1f 00 0a 	mcall	800051a8 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005186:	48 b8       	lddpc	r8,800051b0 <xTaskRemoveFromEventList+0x78>
80005188:	70 08       	ld.w	r8,r8[0x0]
8000518a:	6e b9       	ld.w	r9,r7[0x2c]
8000518c:	70 b8       	ld.w	r8,r8[0x2c]
8000518e:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005190:	5f 2c       	srhs	r12
80005192:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005196:	00 00       	add	r0,r0
80005198:	80 00       	ld.sh	r0,r0[0x0]
8000519a:	47 5a       	lddsp	r10,sp[0x1d4]
8000519c:	00 00       	add	r0,r0
8000519e:	0d 14       	ld.sh	r4,r6++
800051a0:	00 00       	add	r0,r0
800051a2:	0d 4c       	ld.w	r12,--r6
800051a4:	00 00       	add	r0,r0
800051a6:	0c 30       	cp.w	r0,r6
800051a8:	80 00       	ld.sh	r0,r0[0x0]
800051aa:	47 0a       	lddsp	r10,sp[0x1c0]
800051ac:	00 00       	add	r0,r0
800051ae:	0c e8       	st.h	--r6,r8
800051b0:	00 00       	add	r0,r0
800051b2:	0c e4       	st.h	--r6,r4

800051b4 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800051b4:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800051b8:	4b 98       	lddpc	r8,8000529c <vTaskIncrementTick+0xe8>
800051ba:	70 08       	ld.w	r8,r8[0x0]
800051bc:	58 08       	cp.w	r8,0
800051be:	c6 91       	brne	80005290 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800051c0:	4b 88       	lddpc	r8,800052a0 <vTaskIncrementTick+0xec>
800051c2:	70 09       	ld.w	r9,r8[0x0]
800051c4:	2f f9       	sub	r9,-1
800051c6:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800051c8:	70 08       	ld.w	r8,r8[0x0]
800051ca:	58 08       	cp.w	r8,0
800051cc:	c1 a1       	brne	80005200 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800051ce:	4b 68       	lddpc	r8,800052a4 <vTaskIncrementTick+0xf0>
800051d0:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800051d2:	4b 69       	lddpc	r9,800052a8 <vTaskIncrementTick+0xf4>
800051d4:	72 0b       	ld.w	r11,r9[0x0]
800051d6:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800051d8:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800051da:	4b 59       	lddpc	r9,800052ac <vTaskIncrementTick+0xf8>
800051dc:	72 0a       	ld.w	r10,r9[0x0]
800051de:	2f fa       	sub	r10,-1
800051e0:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800051e2:	70 08       	ld.w	r8,r8[0x0]
800051e4:	70 08       	ld.w	r8,r8[0x0]
800051e6:	58 08       	cp.w	r8,0
800051e8:	c0 51       	brne	800051f2 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800051ea:	3f f9       	mov	r9,-1
800051ec:	4b 18       	lddpc	r8,800052b0 <vTaskIncrementTick+0xfc>
800051ee:	91 09       	st.w	r8[0x0],r9
800051f0:	c0 88       	rjmp	80005200 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800051f2:	4a d8       	lddpc	r8,800052a4 <vTaskIncrementTick+0xf0>
800051f4:	70 08       	ld.w	r8,r8[0x0]
800051f6:	70 38       	ld.w	r8,r8[0xc]
800051f8:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800051fa:	70 19       	ld.w	r9,r8[0x4]
800051fc:	4a d8       	lddpc	r8,800052b0 <vTaskIncrementTick+0xfc>
800051fe:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005200:	4a 88       	lddpc	r8,800052a0 <vTaskIncrementTick+0xec>
80005202:	70 09       	ld.w	r9,r8[0x0]
80005204:	4a b8       	lddpc	r8,800052b0 <vTaskIncrementTick+0xfc>
80005206:	70 08       	ld.w	r8,r8[0x0]
80005208:	10 39       	cp.w	r9,r8
8000520a:	c4 73       	brcs	80005298 <vTaskIncrementTick+0xe4>
8000520c:	4a 68       	lddpc	r8,800052a4 <vTaskIncrementTick+0xf0>
8000520e:	70 08       	ld.w	r8,r8[0x0]
80005210:	70 08       	ld.w	r8,r8[0x0]
80005212:	58 08       	cp.w	r8,0
80005214:	c0 c0       	breq	8000522c <vTaskIncrementTick+0x78>
80005216:	4a 48       	lddpc	r8,800052a4 <vTaskIncrementTick+0xf0>
80005218:	70 08       	ld.w	r8,r8[0x0]
8000521a:	70 38       	ld.w	r8,r8[0xc]
8000521c:	70 37       	ld.w	r7,r8[0xc]
8000521e:	6e 18       	ld.w	r8,r7[0x4]
80005220:	4a 09       	lddpc	r9,800052a0 <vTaskIncrementTick+0xec>
80005222:	72 09       	ld.w	r9,r9[0x0]
80005224:	12 38       	cp.w	r8,r9
80005226:	e0 88 00 14 	brls	8000524e <vTaskIncrementTick+0x9a>
8000522a:	c0 e8       	rjmp	80005246 <vTaskIncrementTick+0x92>
8000522c:	3f f9       	mov	r9,-1
8000522e:	4a 18       	lddpc	r8,800052b0 <vTaskIncrementTick+0xfc>
80005230:	91 09       	st.w	r8[0x0],r9
80005232:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005236:	6a 08       	ld.w	r8,r5[0x0]
80005238:	70 38       	ld.w	r8,r8[0xc]
8000523a:	70 37       	ld.w	r7,r8[0xc]
8000523c:	6e 18       	ld.w	r8,r7[0x4]
8000523e:	64 09       	ld.w	r9,r2[0x0]
80005240:	12 38       	cp.w	r8,r9
80005242:	e0 88 00 0a 	brls	80005256 <vTaskIncrementTick+0xa2>
80005246:	49 b9       	lddpc	r9,800052b0 <vTaskIncrementTick+0xfc>
80005248:	93 08       	st.w	r9[0x0],r8
8000524a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000524e:	49 a4       	lddpc	r4,800052b4 <vTaskIncrementTick+0x100>
80005250:	49 a3       	lddpc	r3,800052b8 <vTaskIncrementTick+0x104>
80005252:	49 55       	lddpc	r5,800052a4 <vTaskIncrementTick+0xf0>
80005254:	49 32       	lddpc	r2,800052a0 <vTaskIncrementTick+0xec>
80005256:	ee c6 ff fc 	sub	r6,r7,-4
8000525a:	0c 9c       	mov	r12,r6
8000525c:	f0 1f 00 18 	mcall	800052bc <vTaskIncrementTick+0x108>
80005260:	6e a8       	ld.w	r8,r7[0x28]
80005262:	58 08       	cp.w	r8,0
80005264:	c0 50       	breq	8000526e <vTaskIncrementTick+0xba>
80005266:	ee cc ff e8 	sub	r12,r7,-24
8000526a:	f0 1f 00 15 	mcall	800052bc <vTaskIncrementTick+0x108>
8000526e:	6e bc       	ld.w	r12,r7[0x2c]
80005270:	68 08       	ld.w	r8,r4[0x0]
80005272:	10 3c       	cp.w	r12,r8
80005274:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005278:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000527c:	0c 9b       	mov	r11,r6
8000527e:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005282:	f0 1f 00 10 	mcall	800052c0 <vTaskIncrementTick+0x10c>
80005286:	6a 08       	ld.w	r8,r5[0x0]
80005288:	70 08       	ld.w	r8,r8[0x0]
8000528a:	58 08       	cp.w	r8,0
8000528c:	cd 51       	brne	80005236 <vTaskIncrementTick+0x82>
8000528e:	cc fb       	rjmp	8000522c <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005290:	48 d8       	lddpc	r8,800052c4 <vTaskIncrementTick+0x110>
80005292:	70 09       	ld.w	r9,r8[0x0]
80005294:	2f f9       	sub	r9,-1
80005296:	91 09       	st.w	r8[0x0],r9
80005298:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000529c:	00 00       	add	r0,r0
8000529e:	0d 14       	ld.sh	r4,r6++
800052a0:	00 00       	add	r0,r0
800052a2:	0d 10       	ld.sh	r0,r6++
800052a4:	00 00       	add	r0,r0
800052a6:	0c 1c       	sub	r12,r6
800052a8:	00 00       	add	r0,r0
800052aa:	0c 2c       	rsub	r12,r6
800052ac:	00 00       	add	r0,r0
800052ae:	0c 28       	rsub	r8,r6
800052b0:	00 00       	add	r0,r0
800052b2:	05 34       	ld.ub	r4,r2++
800052b4:	00 00       	add	r0,r0
800052b6:	0d 4c       	ld.w	r12,--r6
800052b8:	00 00       	add	r0,r0
800052ba:	0c 30       	cp.w	r0,r6
800052bc:	80 00       	ld.sh	r0,r0[0x0]
800052be:	47 5a       	lddsp	r10,sp[0x1d4]
800052c0:	80 00       	ld.sh	r0,r0[0x0]
800052c2:	47 0a       	lddsp	r10,sp[0x1c0]
800052c4:	00 00       	add	r0,r0
800052c6:	0c 14       	sub	r4,r6

800052c8 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800052c8:	eb cd 40 c0 	pushm	r6-r7,lr
800052cc:	18 97       	mov	r7,r12
800052ce:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800052d0:	f0 1f 00 15 	mcall	80005324 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800052d4:	6c 08       	ld.w	r8,r6[0x0]
800052d6:	5b f8       	cp.w	r8,-1
800052d8:	c0 31       	brne	800052de <xTaskCheckForTimeOut+0x16>
800052da:	30 07       	mov	r7,0
800052dc:	c1 f8       	rjmp	8000531a <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800052de:	49 39       	lddpc	r9,80005328 <xTaskCheckForTimeOut+0x60>
800052e0:	72 09       	ld.w	r9,r9[0x0]
800052e2:	6e 0a       	ld.w	r10,r7[0x0]
800052e4:	12 3a       	cp.w	r10,r9
800052e6:	c0 70       	breq	800052f4 <xTaskCheckForTimeOut+0x2c>
800052e8:	49 19       	lddpc	r9,8000532c <xTaskCheckForTimeOut+0x64>
800052ea:	72 09       	ld.w	r9,r9[0x0]
800052ec:	6e 1a       	ld.w	r10,r7[0x4]
800052ee:	12 3a       	cp.w	r10,r9
800052f0:	e0 88 00 14 	brls	80005318 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800052f4:	48 e9       	lddpc	r9,8000532c <xTaskCheckForTimeOut+0x64>
800052f6:	72 0a       	ld.w	r10,r9[0x0]
800052f8:	6e 19       	ld.w	r9,r7[0x4]
800052fa:	12 1a       	sub	r10,r9
800052fc:	14 38       	cp.w	r8,r10
800052fe:	e0 88 00 0d 	brls	80005318 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80005302:	48 ba       	lddpc	r10,8000532c <xTaskCheckForTimeOut+0x64>
80005304:	74 0a       	ld.w	r10,r10[0x0]
80005306:	14 19       	sub	r9,r10
80005308:	f2 08 00 08 	add	r8,r9,r8
8000530c:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000530e:	0e 9c       	mov	r12,r7
80005310:	f0 1f 00 08 	mcall	80005330 <xTaskCheckForTimeOut+0x68>
80005314:	30 07       	mov	r7,0
80005316:	c0 28       	rjmp	8000531a <xTaskCheckForTimeOut+0x52>
80005318:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000531a:	f0 1f 00 07 	mcall	80005334 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000531e:	0e 9c       	mov	r12,r7
80005320:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005324:	80 00       	ld.sh	r0,r0[0x0]
80005326:	48 14       	lddpc	r4,80005328 <xTaskCheckForTimeOut+0x60>
80005328:	00 00       	add	r0,r0
8000532a:	0c 28       	rsub	r8,r6
8000532c:	00 00       	add	r0,r0
8000532e:	0d 10       	ld.sh	r0,r6++
80005330:	80 00       	ld.sh	r0,r0[0x0]
80005332:	50 2c       	stdsp	sp[0x8],r12
80005334:	80 00       	ld.sh	r0,r0[0x0]
80005336:	49 20       	lddpc	r0,8000537c <xTaskResumeAll+0x20>

80005338 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005338:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
8000533c:	f0 1f 00 05 	mcall	80005350 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80005340:	48 58       	lddpc	r8,80005354 <xTaskGetTickCount+0x1c>
80005342:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80005344:	f0 1f 00 05 	mcall	80005358 <xTaskGetTickCount+0x20>

	return xTicks;
}
80005348:	0e 9c       	mov	r12,r7
8000534a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000534e:	00 00       	add	r0,r0
80005350:	80 00       	ld.sh	r0,r0[0x0]
80005352:	48 14       	lddpc	r4,80005354 <xTaskGetTickCount+0x1c>
80005354:	00 00       	add	r0,r0
80005356:	0d 10       	ld.sh	r0,r6++
80005358:	80 00       	ld.sh	r0,r0[0x0]
8000535a:	49 20       	lddpc	r0,800053a0 <xTaskResumeAll+0x44>

8000535c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
8000535c:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005360:	f0 1f 00 2c 	mcall	80005410 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80005364:	4a c8       	lddpc	r8,80005414 <xTaskResumeAll+0xb8>
80005366:	70 09       	ld.w	r9,r8[0x0]
80005368:	20 19       	sub	r9,1
8000536a:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000536c:	70 08       	ld.w	r8,r8[0x0]
8000536e:	58 08       	cp.w	r8,0
80005370:	c4 91       	brne	80005402 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005372:	4a a8       	lddpc	r8,80005418 <xTaskResumeAll+0xbc>
80005374:	70 08       	ld.w	r8,r8[0x0]
80005376:	58 08       	cp.w	r8,0
80005378:	c4 50       	breq	80005402 <xTaskResumeAll+0xa6>
8000537a:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000537c:	4a 85       	lddpc	r5,8000541c <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000537e:	4a 93       	lddpc	r3,80005420 <xTaskResumeAll+0xc4>
80005380:	4a 92       	lddpc	r2,80005424 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005382:	4a a1       	lddpc	r1,80005428 <xTaskResumeAll+0xcc>
80005384:	c1 e8       	rjmp	800053c0 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005386:	6a 38       	ld.w	r8,r5[0xc]
80005388:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000538a:	ee cc ff e8 	sub	r12,r7,-24
8000538e:	f0 1f 00 28 	mcall	8000542c <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005392:	ee c6 ff fc 	sub	r6,r7,-4
80005396:	0c 9c       	mov	r12,r6
80005398:	f0 1f 00 25 	mcall	8000542c <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
8000539c:	6e bc       	ld.w	r12,r7[0x2c]
8000539e:	66 08       	ld.w	r8,r3[0x0]
800053a0:	10 3c       	cp.w	r12,r8
800053a2:	e7 fc ba 00 	st.whi	r3[0x0],r12
800053a6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800053aa:	0c 9b       	mov	r11,r6
800053ac:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800053b0:	f0 1f 00 20 	mcall	80005430 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800053b4:	62 08       	ld.w	r8,r1[0x0]
800053b6:	6e b9       	ld.w	r9,r7[0x2c]
800053b8:	70 b8       	ld.w	r8,r8[0x2c]
800053ba:	10 39       	cp.w	r9,r8
800053bc:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800053c0:	6a 08       	ld.w	r8,r5[0x0]
800053c2:	58 08       	cp.w	r8,0
800053c4:	ce 11       	brne	80005386 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800053c6:	49 c8       	lddpc	r8,80005434 <xTaskResumeAll+0xd8>
800053c8:	70 08       	ld.w	r8,r8[0x0]
800053ca:	58 08       	cp.w	r8,0
800053cc:	c0 f0       	breq	800053ea <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800053ce:	49 a8       	lddpc	r8,80005434 <xTaskResumeAll+0xd8>
800053d0:	70 08       	ld.w	r8,r8[0x0]
800053d2:	58 08       	cp.w	r8,0
800053d4:	c1 10       	breq	800053f6 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800053d6:	49 87       	lddpc	r7,80005434 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800053d8:	f0 1f 00 18 	mcall	80005438 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800053dc:	6e 08       	ld.w	r8,r7[0x0]
800053de:	20 18       	sub	r8,1
800053e0:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800053e2:	6e 08       	ld.w	r8,r7[0x0]
800053e4:	58 08       	cp.w	r8,0
800053e6:	cf 91       	brne	800053d8 <xTaskResumeAll+0x7c>
800053e8:	c0 78       	rjmp	800053f6 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800053ea:	58 14       	cp.w	r4,1
800053ec:	c0 50       	breq	800053f6 <xTaskResumeAll+0x9a>
800053ee:	49 48       	lddpc	r8,8000543c <xTaskResumeAll+0xe0>
800053f0:	70 08       	ld.w	r8,r8[0x0]
800053f2:	58 18       	cp.w	r8,1
800053f4:	c0 71       	brne	80005402 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800053f6:	30 09       	mov	r9,0
800053f8:	49 18       	lddpc	r8,8000543c <xTaskResumeAll+0xe0>
800053fa:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800053fc:	d7 33       	scall
800053fe:	30 17       	mov	r7,1
80005400:	c0 28       	rjmp	80005404 <xTaskResumeAll+0xa8>
80005402:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005404:	f0 1f 00 0f 	mcall	80005440 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005408:	0e 9c       	mov	r12,r7
8000540a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000540e:	00 00       	add	r0,r0
80005410:	80 00       	ld.sh	r0,r0[0x0]
80005412:	48 14       	lddpc	r4,80005414 <xTaskResumeAll+0xb8>
80005414:	00 00       	add	r0,r0
80005416:	0d 14       	ld.sh	r4,r6++
80005418:	00 00       	add	r0,r0
8000541a:	0d 30       	ld.ub	r0,r6++
8000541c:	00 00       	add	r0,r0
8000541e:	0c e8       	st.h	--r6,r8
80005420:	00 00       	add	r0,r0
80005422:	0d 4c       	ld.w	r12,--r6
80005424:	00 00       	add	r0,r0
80005426:	0c 30       	cp.w	r0,r6
80005428:	00 00       	add	r0,r0
8000542a:	0c e4       	st.h	--r6,r4
8000542c:	80 00       	ld.sh	r0,r0[0x0]
8000542e:	47 5a       	lddsp	r10,sp[0x1d4]
80005430:	80 00       	ld.sh	r0,r0[0x0]
80005432:	47 0a       	lddsp	r10,sp[0x1c0]
80005434:	00 00       	add	r0,r0
80005436:	0c 14       	sub	r4,r6
80005438:	80 00       	ld.sh	r0,r0[0x0]
8000543a:	51 b4       	stdsp	sp[0x6c],r4
8000543c:	00 00       	add	r0,r0
8000543e:	0d 34       	ld.ub	r4,r6++
80005440:	80 00       	ld.sh	r0,r0[0x0]
80005442:	49 20       	lddpc	r0,80005488 <prvAddCurrentTaskToDelayedList+0x44>

80005444 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80005444:	eb cd 40 80 	pushm	r7,lr
80005448:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000544a:	49 08       	lddpc	r8,80005488 <prvAddCurrentTaskToDelayedList+0x44>
8000544c:	70 08       	ld.w	r8,r8[0x0]
8000544e:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80005450:	48 f8       	lddpc	r8,8000548c <prvAddCurrentTaskToDelayedList+0x48>
80005452:	70 08       	ld.w	r8,r8[0x0]
80005454:	10 3c       	cp.w	r12,r8
80005456:	c0 a2       	brcc	8000546a <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005458:	48 c8       	lddpc	r8,80005488 <prvAddCurrentTaskToDelayedList+0x44>
8000545a:	70 0b       	ld.w	r11,r8[0x0]
8000545c:	48 d8       	lddpc	r8,80005490 <prvAddCurrentTaskToDelayedList+0x4c>
8000545e:	70 0c       	ld.w	r12,r8[0x0]
80005460:	2f cb       	sub	r11,-4
80005462:	f0 1f 00 0d 	mcall	80005494 <prvAddCurrentTaskToDelayedList+0x50>
80005466:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000546a:	48 88       	lddpc	r8,80005488 <prvAddCurrentTaskToDelayedList+0x44>
8000546c:	70 0b       	ld.w	r11,r8[0x0]
8000546e:	48 b8       	lddpc	r8,80005498 <prvAddCurrentTaskToDelayedList+0x54>
80005470:	70 0c       	ld.w	r12,r8[0x0]
80005472:	2f cb       	sub	r11,-4
80005474:	f0 1f 00 08 	mcall	80005494 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005478:	48 98       	lddpc	r8,8000549c <prvAddCurrentTaskToDelayedList+0x58>
8000547a:	70 08       	ld.w	r8,r8[0x0]
8000547c:	10 37       	cp.w	r7,r8
8000547e:	c0 32       	brcc	80005484 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005480:	48 78       	lddpc	r8,8000549c <prvAddCurrentTaskToDelayedList+0x58>
80005482:	91 07       	st.w	r8[0x0],r7
80005484:	e3 cd 80 80 	ldm	sp++,r7,pc
80005488:	00 00       	add	r0,r0
8000548a:	0c e4       	st.h	--r6,r4
8000548c:	00 00       	add	r0,r0
8000548e:	0d 10       	ld.sh	r0,r6++
80005490:	00 00       	add	r0,r0
80005492:	0c 2c       	rsub	r12,r6
80005494:	80 00       	ld.sh	r0,r0[0x0]
80005496:	47 26       	lddsp	r6,sp[0x1c8]
80005498:	00 00       	add	r0,r0
8000549a:	0c 1c       	sub	r12,r6
8000549c:	00 00       	add	r0,r0
8000549e:	05 34       	ld.ub	r4,r2++

800054a0 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
800054a0:	eb cd 40 c0 	pushm	r6-r7,lr
800054a4:	18 96       	mov	r6,r12
800054a6:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
800054a8:	f0 1f 00 18 	mcall	80005508 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
800054ac:	6c 08       	ld.w	r8,r6[0x0]
800054ae:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
800054b0:	49 79       	lddpc	r9,8000550c <vTaskDelayUntil+0x6c>
800054b2:	72 09       	ld.w	r9,r9[0x0]
800054b4:	12 38       	cp.w	r8,r9
800054b6:	e0 88 00 0c 	brls	800054ce <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
800054ba:	0e 38       	cp.w	r8,r7
800054bc:	e0 88 00 22 	brls	80005500 <vTaskDelayUntil+0x60>
800054c0:	49 38       	lddpc	r8,8000550c <vTaskDelayUntil+0x6c>
800054c2:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800054c4:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
800054c6:	10 37       	cp.w	r7,r8
800054c8:	e0 88 00 14 	brls	800054f0 <vTaskDelayUntil+0x50>
800054cc:	c0 a8       	rjmp	800054e0 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
800054ce:	0e 38       	cp.w	r8,r7
800054d0:	e0 8b 00 16 	brhi	800054fc <vTaskDelayUntil+0x5c>
800054d4:	48 e8       	lddpc	r8,8000550c <vTaskDelayUntil+0x6c>
800054d6:	70 08       	ld.w	r8,r8[0x0]
800054d8:	10 37       	cp.w	r7,r8
800054da:	e0 8b 00 11 	brhi	800054fc <vTaskDelayUntil+0x5c>
800054de:	c1 18       	rjmp	80005500 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800054e0:	48 c8       	lddpc	r8,80005510 <vTaskDelayUntil+0x70>
800054e2:	70 0c       	ld.w	r12,r8[0x0]
800054e4:	2f cc       	sub	r12,-4
800054e6:	f0 1f 00 0c 	mcall	80005514 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800054ea:	0e 9c       	mov	r12,r7
800054ec:	f0 1f 00 0b 	mcall	80005518 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
800054f0:	f0 1f 00 0b 	mcall	8000551c <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800054f4:	c0 81       	brne	80005504 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
800054f6:	d7 33       	scall
800054f8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800054fc:	8d 07       	st.w	r6[0x0],r7
800054fe:	cf 1b       	rjmp	800054e0 <vTaskDelayUntil+0x40>
80005500:	8d 07       	st.w	r6[0x0],r7
80005502:	cf 7b       	rjmp	800054f0 <vTaskDelayUntil+0x50>
80005504:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005508:	80 00       	ld.sh	r0,r0[0x0]
8000550a:	4f a0       	lddpc	r0,800056f0 <xTaskGenericCreate+0xf0>
8000550c:	00 00       	add	r0,r0
8000550e:	0d 10       	ld.sh	r0,r6++
80005510:	00 00       	add	r0,r0
80005512:	0c e4       	st.h	--r6,r4
80005514:	80 00       	ld.sh	r0,r0[0x0]
80005516:	47 5a       	lddsp	r10,sp[0x1d4]
80005518:	80 00       	ld.sh	r0,r0[0x0]
8000551a:	54 44       	stdsp	sp[0x110],r4
8000551c:	80 00       	ld.sh	r0,r0[0x0]
8000551e:	53 5c       	stdsp	sp[0xd4],r12

80005520 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80005520:	eb cd 40 c0 	pushm	r6-r7,lr
80005524:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80005526:	48 e7       	lddpc	r7,8000555c <vTaskPlaceOnEventList+0x3c>
80005528:	6e 0b       	ld.w	r11,r7[0x0]
8000552a:	2e 8b       	sub	r11,-24
8000552c:	f0 1f 00 0d 	mcall	80005560 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005530:	6e 0c       	ld.w	r12,r7[0x0]
80005532:	2f cc       	sub	r12,-4
80005534:	f0 1f 00 0c 	mcall	80005564 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80005538:	5b f6       	cp.w	r6,-1
8000553a:	c0 81       	brne	8000554a <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000553c:	6e 0b       	ld.w	r11,r7[0x0]
8000553e:	2f cb       	sub	r11,-4
80005540:	48 ac       	lddpc	r12,80005568 <vTaskPlaceOnEventList+0x48>
80005542:	f0 1f 00 0b 	mcall	8000556c <vTaskPlaceOnEventList+0x4c>
80005546:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
8000554a:	48 a8       	lddpc	r8,80005570 <vTaskPlaceOnEventList+0x50>
8000554c:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000554e:	ec 0c 00 0c 	add	r12,r6,r12
80005552:	f0 1f 00 09 	mcall	80005574 <vTaskPlaceOnEventList+0x54>
80005556:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000555a:	00 00       	add	r0,r0
8000555c:	00 00       	add	r0,r0
8000555e:	0c e4       	st.h	--r6,r4
80005560:	80 00       	ld.sh	r0,r0[0x0]
80005562:	47 26       	lddsp	r6,sp[0x1c8]
80005564:	80 00       	ld.sh	r0,r0[0x0]
80005566:	47 5a       	lddsp	r10,sp[0x1d4]
80005568:	00 00       	add	r0,r0
8000556a:	0d 38       	ld.ub	r8,r6++
8000556c:	80 00       	ld.sh	r0,r0[0x0]
8000556e:	47 0a       	lddsp	r10,sp[0x1c0]
80005570:	00 00       	add	r0,r0
80005572:	0d 10       	ld.sh	r0,r6++
80005574:	80 00       	ld.sh	r0,r0[0x0]
80005576:	54 44       	stdsp	sp[0x110],r4

80005578 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80005578:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
8000557c:	49 67       	lddpc	r7,800055d4 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000557e:	49 74       	lddpc	r4,800055d8 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005580:	49 73       	lddpc	r3,800055dc <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005582:	49 85       	lddpc	r5,800055e0 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005584:	6e 08       	ld.w	r8,r7[0x0]
80005586:	58 08       	cp.w	r8,0
80005588:	c1 e0       	breq	800055c4 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
8000558a:	f0 1f 00 17 	mcall	800055e4 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000558e:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005590:	f0 1f 00 16 	mcall	800055e8 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80005594:	58 06       	cp.w	r6,0
80005596:	c1 70       	breq	800055c4 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80005598:	f0 1f 00 15 	mcall	800055ec <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
8000559c:	68 38       	ld.w	r8,r4[0xc]
8000559e:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
800055a0:	ec cc ff fc 	sub	r12,r6,-4
800055a4:	f0 1f 00 13 	mcall	800055f0 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
800055a8:	66 08       	ld.w	r8,r3[0x0]
800055aa:	20 18       	sub	r8,1
800055ac:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
800055ae:	6e 08       	ld.w	r8,r7[0x0]
800055b0:	20 18       	sub	r8,1
800055b2:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
800055b4:	f0 1f 00 10 	mcall	800055f4 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
800055b8:	6c cc       	ld.w	r12,r6[0x30]
800055ba:	f0 1f 00 10 	mcall	800055f8 <prvIdleTask+0x80>
		vPortFree( pxTCB );
800055be:	0c 9c       	mov	r12,r6
800055c0:	f0 1f 00 0e 	mcall	800055f8 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800055c4:	6a 08       	ld.w	r8,r5[0x0]
800055c6:	58 18       	cp.w	r8,1
800055c8:	e0 88 00 03 	brls	800055ce <prvIdleTask+0x56>
			{
				taskYIELD();
800055cc:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
800055ce:	f0 1f 00 0c 	mcall	800055fc <prvIdleTask+0x84>
		}
		#endif
	}
800055d2:	cd 9b       	rjmp	80005584 <prvIdleTask+0xc>
800055d4:	00 00       	add	r0,r0
800055d6:	0c 24       	rsub	r4,r6
800055d8:	00 00       	add	r0,r0
800055da:	0c d0       	st.w	--r6,r0
800055dc:	00 00       	add	r0,r0
800055de:	0d 30       	ld.ub	r0,r6++
800055e0:	00 00       	add	r0,r0
800055e2:	0c 30       	cp.w	r0,r6
800055e4:	80 00       	ld.sh	r0,r0[0x0]
800055e6:	4f a0       	lddpc	r0,800057cc <xTaskGenericCreate+0x1cc>
800055e8:	80 00       	ld.sh	r0,r0[0x0]
800055ea:	53 5c       	stdsp	sp[0xd4],r12
800055ec:	80 00       	ld.sh	r0,r0[0x0]
800055ee:	48 14       	lddpc	r4,800055f0 <prvIdleTask+0x78>
800055f0:	80 00       	ld.sh	r0,r0[0x0]
800055f2:	47 5a       	lddsp	r10,sp[0x1d4]
800055f4:	80 00       	ld.sh	r0,r0[0x0]
800055f6:	49 20       	lddpc	r0,8000563c <xTaskGenericCreate+0x3c>
800055f8:	80 00       	ld.sh	r0,r0[0x0]
800055fa:	4a 58       	lddpc	r8,8000568c <xTaskGenericCreate+0x8c>
800055fc:	80 00       	ld.sh	r0,r0[0x0]
800055fe:	20 30       	sub	r0,3

80005600 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005600:	d4 31       	pushm	r0-r7,lr
80005602:	20 1d       	sub	sp,4
80005604:	fa c4 ff d8 	sub	r4,sp,-40
80005608:	50 0c       	stdsp	sp[0x0],r12
8000560a:	16 91       	mov	r1,r11
8000560c:	14 97       	mov	r7,r10
8000560e:	12 90       	mov	r0,r9
80005610:	10 93       	mov	r3,r8
80005612:	68 02       	ld.w	r2,r4[0x0]
80005614:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80005616:	34 8c       	mov	r12,72
80005618:	f0 1f 00 5c 	mcall	80005788 <xTaskGenericCreate+0x188>
8000561c:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
8000561e:	c0 31       	brne	80005624 <xTaskGenericCreate+0x24>
80005620:	3f fc       	mov	r12,-1
80005622:	ca f8       	rjmp	80005780 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005624:	58 06       	cp.w	r6,0
80005626:	e0 81 00 af 	brne	80005784 <xTaskGenericCreate+0x184>
8000562a:	0e 9c       	mov	r12,r7
8000562c:	5c 7c       	castu.h	r12
8000562e:	a3 6c       	lsl	r12,0x2
80005630:	f0 1f 00 56 	mcall	80005788 <xTaskGenericCreate+0x188>
80005634:	18 96       	mov	r6,r12
80005636:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80005638:	c0 61       	brne	80005644 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
8000563a:	0a 9c       	mov	r12,r5
8000563c:	f0 1f 00 54 	mcall	8000578c <xTaskGenericCreate+0x18c>
80005640:	3f fc       	mov	r12,-1
80005642:	c9 f8       	rjmp	80005780 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80005644:	5c 77       	castu.h	r7
80005646:	ee 0a 15 02 	lsl	r10,r7,0x2
8000564a:	e0 6b 00 a5 	mov	r11,165
8000564e:	0c 9c       	mov	r12,r6
80005650:	f0 1f 00 50 	mcall	80005790 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80005654:	ee c6 00 01 	sub	r6,r7,1
80005658:	6a c8       	ld.w	r8,r5[0x30]
8000565a:	f0 06 00 26 	add	r6,r8,r6<<0x2
8000565e:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80005662:	31 0a       	mov	r10,16
80005664:	02 9b       	mov	r11,r1
80005666:	ea cc ff cc 	sub	r12,r5,-52
8000566a:	f0 1f 00 4b 	mcall	80005794 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
8000566e:	30 08       	mov	r8,0
80005670:	eb 68 00 43 	st.b	r5[67],r8
80005674:	58 73       	cp.w	r3,7
80005676:	e6 07 17 80 	movls	r7,r3
8000567a:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
8000567e:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80005680:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80005684:	ea c4 ff fc 	sub	r4,r5,-4
80005688:	08 9c       	mov	r12,r4
8000568a:	f0 1f 00 44 	mcall	80005798 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
8000568e:	ea cc ff e8 	sub	r12,r5,-24
80005692:	f0 1f 00 42 	mcall	80005798 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80005696:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80005698:	ee 07 11 08 	rsub	r7,r7,8
8000569c:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
8000569e:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
800056a0:	00 9a       	mov	r10,r0
800056a2:	40 0b       	lddsp	r11,sp[0x0]
800056a4:	0c 9c       	mov	r12,r6
800056a6:	f0 1f 00 3e 	mcall	8000579c <xTaskGenericCreate+0x19c>
800056aa:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
800056ac:	58 02       	cp.w	r2,0
800056ae:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
800056b2:	f0 1f 00 3c 	mcall	800057a0 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
800056b6:	4b c8       	lddpc	r8,800057a4 <xTaskGenericCreate+0x1a4>
800056b8:	70 09       	ld.w	r9,r8[0x0]
800056ba:	2f f9       	sub	r9,-1
800056bc:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
800056be:	4b b8       	lddpc	r8,800057a8 <xTaskGenericCreate+0x1a8>
800056c0:	70 08       	ld.w	r8,r8[0x0]
800056c2:	58 08       	cp.w	r8,0
800056c4:	c2 61       	brne	80005710 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
800056c6:	4b 98       	lddpc	r8,800057a8 <xTaskGenericCreate+0x1a8>
800056c8:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
800056ca:	4b 78       	lddpc	r8,800057a4 <xTaskGenericCreate+0x1a4>
800056cc:	70 08       	ld.w	r8,r8[0x0]
800056ce:	58 18       	cp.w	r8,1
800056d0:	c2 b1       	brne	80005726 <xTaskGenericCreate+0x126>
800056d2:	4b 77       	lddpc	r7,800057ac <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
800056d4:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
800056d8:	0e 9c       	mov	r12,r7
800056da:	f0 1f 00 36 	mcall	800057b0 <xTaskGenericCreate+0x1b0>
800056de:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
800056e0:	0c 37       	cp.w	r7,r6
800056e2:	cf b1       	brne	800056d8 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
800056e4:	4b 47       	lddpc	r7,800057b4 <xTaskGenericCreate+0x1b4>
800056e6:	0e 9c       	mov	r12,r7
800056e8:	f0 1f 00 32 	mcall	800057b0 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
800056ec:	4b 36       	lddpc	r6,800057b8 <xTaskGenericCreate+0x1b8>
800056ee:	0c 9c       	mov	r12,r6
800056f0:	f0 1f 00 30 	mcall	800057b0 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
800056f4:	4b 2c       	lddpc	r12,800057bc <xTaskGenericCreate+0x1bc>
800056f6:	f0 1f 00 2f 	mcall	800057b0 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
800056fa:	4b 2c       	lddpc	r12,800057c0 <xTaskGenericCreate+0x1c0>
800056fc:	f0 1f 00 2d 	mcall	800057b0 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80005700:	4b 1c       	lddpc	r12,800057c4 <xTaskGenericCreate+0x1c4>
80005702:	f0 1f 00 2c 	mcall	800057b0 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80005706:	4b 18       	lddpc	r8,800057c8 <xTaskGenericCreate+0x1c8>
80005708:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
8000570a:	4b 18       	lddpc	r8,800057cc <xTaskGenericCreate+0x1cc>
8000570c:	91 06       	st.w	r8[0x0],r6
8000570e:	c0 c8       	rjmp	80005726 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005710:	4b 08       	lddpc	r8,800057d0 <xTaskGenericCreate+0x1d0>
80005712:	70 08       	ld.w	r8,r8[0x0]
80005714:	58 08       	cp.w	r8,0
80005716:	c0 81       	brne	80005726 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005718:	4a 48       	lddpc	r8,800057a8 <xTaskGenericCreate+0x1a8>
8000571a:	70 08       	ld.w	r8,r8[0x0]
8000571c:	70 b8       	ld.w	r8,r8[0x2c]
8000571e:	10 33       	cp.w	r3,r8
80005720:	c0 33       	brcs	80005726 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80005722:	4a 28       	lddpc	r8,800057a8 <xTaskGenericCreate+0x1a8>
80005724:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80005726:	6a b8       	ld.w	r8,r5[0x2c]
80005728:	4a b9       	lddpc	r9,800057d4 <xTaskGenericCreate+0x1d4>
8000572a:	72 09       	ld.w	r9,r9[0x0]
8000572c:	12 38       	cp.w	r8,r9
8000572e:	e0 88 00 04 	brls	80005736 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005732:	4a 99       	lddpc	r9,800057d4 <xTaskGenericCreate+0x1d4>
80005734:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80005736:	4a 98       	lddpc	r8,800057d8 <xTaskGenericCreate+0x1d8>
80005738:	70 09       	ld.w	r9,r8[0x0]
8000573a:	2f f9       	sub	r9,-1
8000573c:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
8000573e:	6a b8       	ld.w	r8,r5[0x2c]
80005740:	4a 79       	lddpc	r9,800057dc <xTaskGenericCreate+0x1dc>
80005742:	72 09       	ld.w	r9,r9[0x0]
80005744:	12 38       	cp.w	r8,r9
80005746:	e0 88 00 04 	brls	8000574e <xTaskGenericCreate+0x14e>
8000574a:	4a 59       	lddpc	r9,800057dc <xTaskGenericCreate+0x1dc>
8000574c:	93 08       	st.w	r9[0x0],r8
8000574e:	6a bc       	ld.w	r12,r5[0x2c]
80005750:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005754:	08 9b       	mov	r11,r4
80005756:	49 68       	lddpc	r8,800057ac <xTaskGenericCreate+0x1ac>
80005758:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000575c:	f0 1f 00 21 	mcall	800057e0 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80005760:	f0 1f 00 21 	mcall	800057e4 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80005764:	49 b8       	lddpc	r8,800057d0 <xTaskGenericCreate+0x1d0>
80005766:	70 08       	ld.w	r8,r8[0x0]
80005768:	58 08       	cp.w	r8,0
8000576a:	c0 a0       	breq	8000577e <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
8000576c:	48 f8       	lddpc	r8,800057a8 <xTaskGenericCreate+0x1a8>
8000576e:	70 08       	ld.w	r8,r8[0x0]
80005770:	70 b8       	ld.w	r8,r8[0x2c]
80005772:	10 33       	cp.w	r3,r8
80005774:	e0 88 00 05 	brls	8000577e <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80005778:	d7 33       	scall
8000577a:	30 1c       	mov	r12,1
8000577c:	c0 28       	rjmp	80005780 <xTaskGenericCreate+0x180>
8000577e:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80005780:	2f fd       	sub	sp,-4
80005782:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005784:	99 c6       	st.w	r12[0x30],r6
80005786:	c5 fb       	rjmp	80005644 <xTaskGenericCreate+0x44>
80005788:	80 00       	ld.sh	r0,r0[0x0]
8000578a:	4a 80       	lddpc	r0,80005828 <vTaskStartScheduler+0x40>
8000578c:	80 00       	ld.sh	r0,r0[0x0]
8000578e:	4a 58       	lddpc	r8,80005820 <vTaskStartScheduler+0x38>
80005790:	80 00       	ld.sh	r0,r0[0x0]
80005792:	64 6c       	ld.w	r12,r2[0x18]
80005794:	80 00       	ld.sh	r0,r0[0x0]
80005796:	67 b0       	ld.w	r0,r3[0x6c]
80005798:	80 00       	ld.sh	r0,r0[0x0]
8000579a:	47 04       	lddsp	r4,sp[0x1c0]
8000579c:	80 00       	ld.sh	r0,r0[0x0]
8000579e:	47 80       	lddsp	r0,sp[0x1e0]
800057a0:	80 00       	ld.sh	r0,r0[0x0]
800057a2:	48 14       	lddpc	r4,800057a4 <xTaskGenericCreate+0x1a4>
800057a4:	00 00       	add	r0,r0
800057a6:	0d 30       	ld.ub	r0,r6++
800057a8:	00 00       	add	r0,r0
800057aa:	0c e4       	st.h	--r6,r4
800057ac:	00 00       	add	r0,r0
800057ae:	0c 30       	cp.w	r0,r6
800057b0:	80 00       	ld.sh	r0,r0[0x0]
800057b2:	46 f0       	lddsp	r0,sp[0x1bc]
800057b4:	00 00       	add	r0,r0
800057b6:	0c fc       	st.b	--r6,r12
800057b8:	00 00       	add	r0,r0
800057ba:	0d 18       	ld.sh	r8,r6++
800057bc:	00 00       	add	r0,r0
800057be:	0c e8       	st.h	--r6,r8
800057c0:	00 00       	add	r0,r0
800057c2:	0c d0       	st.w	--r6,r0
800057c4:	00 00       	add	r0,r0
800057c6:	0d 38       	ld.ub	r8,r6++
800057c8:	00 00       	add	r0,r0
800057ca:	0c 1c       	sub	r12,r6
800057cc:	00 00       	add	r0,r0
800057ce:	0c 2c       	rsub	r12,r6
800057d0:	00 00       	add	r0,r0
800057d2:	0c 20       	rsub	r0,r6
800057d4:	00 00       	add	r0,r0
800057d6:	0c 18       	sub	r8,r6
800057d8:	00 00       	add	r0,r0
800057da:	0d 2c       	ld.uh	r12,r6++
800057dc:	00 00       	add	r0,r0
800057de:	0d 4c       	ld.w	r12,--r6
800057e0:	80 00       	ld.sh	r0,r0[0x0]
800057e2:	47 0a       	lddsp	r10,sp[0x1c0]
800057e4:	80 00       	ld.sh	r0,r0[0x0]
800057e6:	49 20       	lddpc	r0,8000582c <vTaskStartScheduler+0x44>

800057e8 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
800057e8:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
800057ea:	30 09       	mov	r9,0
800057ec:	1a d9       	st.w	--sp,r9
800057ee:	1a d9       	st.w	--sp,r9
800057f0:	1a d9       	st.w	--sp,r9
800057f2:	12 98       	mov	r8,r9
800057f4:	e0 6a 01 00 	mov	r10,256
800057f8:	48 9b       	lddpc	r11,8000581c <vTaskStartScheduler+0x34>
800057fa:	48 ac       	lddpc	r12,80005820 <vTaskStartScheduler+0x38>
800057fc:	f0 1f 00 0a 	mcall	80005824 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005800:	2f dd       	sub	sp,-12
80005802:	58 1c       	cp.w	r12,1
80005804:	c0 a1       	brne	80005818 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80005806:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80005808:	30 19       	mov	r9,1
8000580a:	48 88       	lddpc	r8,80005828 <vTaskStartScheduler+0x40>
8000580c:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
8000580e:	30 09       	mov	r9,0
80005810:	48 78       	lddpc	r8,8000582c <vTaskStartScheduler+0x44>
80005812:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80005814:	f0 1f 00 07 	mcall	80005830 <vTaskStartScheduler+0x48>
80005818:	d8 02       	popm	pc
8000581a:	00 00       	add	r0,r0
8000581c:	80 00       	ld.sh	r0,r0[0x0]
8000581e:	c2 e4       	brge	8000587a <PrintHex+0x42>
80005820:	80 00       	ld.sh	r0,r0[0x0]
80005822:	55 78       	stdsp	sp[0x15c],r8
80005824:	80 00       	ld.sh	r0,r0[0x0]
80005826:	56 00       	stdsp	sp[0x180],r0
80005828:	00 00       	add	r0,r0
8000582a:	0c 20       	rsub	r0,r6
8000582c:	00 00       	add	r0,r0
8000582e:	0d 10       	ld.sh	r0,r6++
80005830:	80 00       	ld.sh	r0,r0[0x0]
80005832:	48 24       	lddpc	r4,80005838 <PrintHex>

80005834 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80005834:	16 cc       	st.b	r11++,r12
	return str;
}
80005836:	5e fb       	retal	r11

80005838 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80005838:	eb cd 40 c0 	pushm	r6-r7,lr
8000583c:	20 3d       	sub	sp,12
8000583e:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80005840:	30 06       	mov	r6,0
80005842:	30 07       	mov	r7,0
80005844:	fa e7 00 00 	st.d	sp[0],r6
80005848:	30 0c       	mov	r12,0
8000584a:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
8000584c:	58 08       	cp.w	r8,0
8000584e:	c1 30       	breq	80005874 <PrintHex+0x3c>
80005850:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80005852:	1a 9c       	mov	r12,sp
80005854:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005858:	58 9e       	cp.w	lr,9
8000585a:	e0 8a 00 04 	brle	80005862 <PrintHex+0x2a>
8000585e:	2c 9e       	sub	lr,-55
80005860:	c0 48       	rjmp	80005868 <PrintHex+0x30>
80005862:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005866:	2d 0e       	sub	lr,-48
80005868:	f8 09 0b 0e 	st.b	r12[r9],lr
8000586c:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
8000586e:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80005870:	cf 21       	brne	80005854 <PrintHex+0x1c>
80005872:	c0 48       	rjmp	8000587a <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80005874:	33 08       	mov	r8,48
80005876:	ba 88       	st.b	sp[0x0],r8
80005878:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
8000587a:	f6 09 01 08 	sub	r8,r11,r9
8000587e:	58 08       	cp.w	r8,0
80005880:	e0 8a 00 13 	brle	800058a6 <PrintHex+0x6e>
	{
		char num = len - cnt;
80005884:	12 1b       	sub	r11,r9
80005886:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
8000588a:	18 9e       	mov	lr,r12
8000588c:	58 0c       	cp.w	r12,0
8000588e:	e0 8a 00 0c 	brle	800058a6 <PrintHex+0x6e>
80005892:	1a 9b       	mov	r11,sp
80005894:	12 0b       	add	r11,r9
80005896:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005898:	33 07       	mov	r7,48
8000589a:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
8000589c:	2f f8       	sub	r8,-1
8000589e:	1c 38       	cp.w	r8,lr
800058a0:	cf d5       	brlt	8000589a <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
800058a2:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
800058a6:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
800058aa:	f0 cb ff ff 	sub	r11,r8,-1
800058ae:	58 0b       	cp.w	r11,0
800058b0:	e0 8a 00 19 	brle	800058e2 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
800058b4:	fa cb ff f4 	sub	r11,sp,-12
800058b8:	f6 09 00 09 	add	r9,r11,r9
800058bc:	37 8b       	mov	r11,120
800058be:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
800058c2:	fa c9 ff f4 	sub	r9,sp,-12
800058c6:	10 09       	add	r9,r8
800058c8:	33 0b       	mov	r11,48
800058ca:	f3 6b ff f4 	st.b	r9[-12],r11
800058ce:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
800058d2:	fa ce 00 01 	sub	lr,sp,1
800058d6:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
800058d8:	11 8b       	ld.ub	r11,r8[0x0]
800058da:	12 cb       	st.b	r9++,r11
800058dc:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
800058de:	1c 38       	cp.w	r8,lr
800058e0:	cf c1       	brne	800058d8 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
800058e2:	14 9c       	mov	r12,r10
800058e4:	2f dd       	sub	sp,-12
800058e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800058ea <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
800058ea:	d4 21       	pushm	r4-r7,lr
800058ec:	20 3d       	sub	sp,12
800058ee:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
800058f0:	30 06       	mov	r6,0
800058f2:	30 07       	mov	r7,0
800058f4:	fa e7 00 00 	st.d	sp[0],r6
800058f8:	30 0c       	mov	r12,0
800058fa:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
800058fc:	58 08       	cp.w	r8,0
800058fe:	c0 35       	brlt	80005904 <PrintDec+0x1a>
80005900:	14 97       	mov	r7,r10
80005902:	c0 58       	rjmp	8000590c <PrintDec+0x22>
	{
		*p++ = '-';
80005904:	14 97       	mov	r7,r10
80005906:	32 d9       	mov	r9,45
80005908:	0e c9       	st.b	r7++,r9
		i = -i;
8000590a:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
8000590c:	58 08       	cp.w	r8,0
8000590e:	c0 51       	brne	80005918 <PrintDec+0x2e>
80005910:	33 08       	mov	r8,48
80005912:	ba 88       	st.b	sp[0x0],r8
80005914:	30 1e       	mov	lr,1
80005916:	c2 f8       	rjmp	80005974 <PrintDec+0x8a>
	
	int ten = i%10;
80005918:	e0 65 66 67 	mov	r5,26215
8000591c:	ea 15 66 66 	orh	r5,0x6666
80005920:	f0 05 04 44 	muls.d	r4,r8,r5
80005924:	ea 0c 14 02 	asr	r12,r5,0x2
80005928:	f0 09 14 1f 	asr	r9,r8,0x1f
8000592c:	f8 09 01 09 	sub	r9,r12,r9
80005930:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005934:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80005938:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
8000593a:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
8000593c:	e0 66 66 67 	mov	r6,26215
80005940:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80005944:	2d 09       	sub	r9,-48
80005946:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
8000594a:	2f fe       	sub	lr,-1
		i /= 10;
8000594c:	f0 06 04 44 	muls.d	r4,r8,r6
80005950:	ea 09 14 02 	asr	r9,r5,0x2
80005954:	bf 58       	asr	r8,0x1f
80005956:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
8000595a:	f0 06 04 44 	muls.d	r4,r8,r6
8000595e:	ea 09 14 02 	asr	r9,r5,0x2
80005962:	f0 05 14 1f 	asr	r5,r8,0x1f
80005966:	0a 19       	sub	r9,r5
80005968:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000596c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80005970:	58 08       	cp.w	r8,0
80005972:	ce 91       	brne	80005944 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80005974:	f6 0e 01 08 	sub	r8,r11,lr
80005978:	58 08       	cp.w	r8,0
8000597a:	e0 89 00 06 	brgt	80005986 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000597e:	58 0e       	cp.w	lr,0
80005980:	e0 89 00 14 	brgt	800059a8 <PrintDec+0xbe>
80005984:	c1 d8       	rjmp	800059be <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80005986:	1c 1b       	sub	r11,lr
80005988:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
8000598a:	16 9c       	mov	r12,r11
8000598c:	58 0b       	cp.w	r11,0
8000598e:	fe 9a ff f8 	brle	8000597e <PrintDec+0x94>
80005992:	1a 99       	mov	r9,sp
80005994:	1c 09       	add	r9,lr
80005996:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005998:	33 06       	mov	r6,48
8000599a:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
8000599c:	2f f8       	sub	r8,-1
8000599e:	18 38       	cp.w	r8,r12
800059a0:	cf d5       	brlt	8000599a <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
800059a2:	f6 0e 00 0e 	add	lr,r11,lr
800059a6:	ce cb       	rjmp	8000597e <PrintDec+0x94>
800059a8:	fa c8 ff f4 	sub	r8,sp,-12
800059ac:	1c 08       	add	r8,lr
800059ae:	20 d8       	sub	r8,13
800059b0:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
800059b4:	11 89       	ld.ub	r9,r8[0x0]
800059b6:	0e c9       	st.b	r7++,r9
800059b8:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
800059ba:	16 38       	cp.w	r8,r11
800059bc:	cf c1       	brne	800059b4 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
800059be:	14 9c       	mov	r12,r10
800059c0:	2f dd       	sub	sp,-12
800059c2:	d8 22       	popm	r4-r7,pc

800059c4 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
800059c4:	d4 31       	pushm	r0-r7,lr
800059c6:	fa cd 02 08 	sub	sp,sp,520
800059ca:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
800059cc:	e0 6a 01 00 	mov	r10,256
800059d0:	30 0b       	mov	r11,0
800059d2:	fa cc fe f8 	sub	r12,sp,-264
800059d6:	f0 1f 00 4e 	mcall	80005b0c <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
800059da:	fa c4 fd d4 	sub	r4,sp,-556
800059de:	30 0a       	mov	r10,0
800059e0:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800059e2:	fa c3 ff fc 	sub	r3,sp,-4
800059e6:	e0 61 01 00 	mov	r1,256
800059ea:	14 90       	mov	r0,r10
			
					if(*str == '%')
800059ec:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800059ee:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800059f2:	02 9a       	mov	r10,r1
800059f4:	00 9b       	mov	r11,r0
800059f6:	06 9c       	mov	r12,r3
800059f8:	f0 1f 00 45 	mcall	80005b0c <log+0x148>
			
					if(*str == '%')
800059fc:	0f 88       	ld.ub	r8,r7[0x0]
800059fe:	e4 08 18 00 	cp.b	r8,r2
80005a02:	c5 71       	brne	80005ab0 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80005a04:	ee c8 ff ff 	sub	r8,r7,-1
80005a08:	11 89       	ld.ub	r9,r8[0x0]
80005a0a:	4c 2a       	lddpc	r10,80005b10 <log+0x14c>
80005a0c:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80005a0e:	23 09       	sub	r9,48
80005a10:	30 9a       	mov	r10,9
80005a12:	f4 09 18 00 	cp.b	r9,r10
80005a16:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80005a1a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80005a1e:	f7 b9 08 30 	subls	r9,48
80005a22:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80005a26:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80005a2a:	0f 88       	ld.ub	r8,r7[0x0]
80005a2c:	22 58       	sub	r8,37
80005a2e:	e0 48 00 53 	cp.w	r8,83
80005a32:	e0 8b 00 31 	brhi	80005a94 <log+0xd0>
80005a36:	4b 89       	lddpc	r9,80005b14 <log+0x150>
80005a38:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80005a3c:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80005a40:	06 9a       	mov	r10,r3
80005a42:	40 0b       	lddsp	r11,sp[0x0]
80005a44:	5c 5b       	castu.b	r11
80005a46:	68 0c       	ld.w	r12,r4[0x0]
80005a48:	f0 1f 00 34 	mcall	80005b18 <log+0x154>
							break;
80005a4c:	c2 98       	rjmp	80005a9e <log+0xda>
							
							case('f')://
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80005a4e:	4b 4c       	lddpc	r12,80005b1c <log+0x158>
80005a50:	f0 1f 00 34 	mcall	80005b20 <log+0x15c>
80005a54:	08 95       	mov	r5,r4
80005a56:	06 9c       	mov	r12,r3
							break;
80005a58:	c2 38       	rjmp	80005a9e <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80005a5a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80005a5e:	06 9a       	mov	r10,r3
80005a60:	40 0b       	lddsp	r11,sp[0x0]
80005a62:	5c 5b       	castu.b	r11
80005a64:	68 0c       	ld.w	r12,r4[0x0]
80005a66:	f0 1f 00 30 	mcall	80005b24 <log+0x160>
80005a6a:	06 9c       	mov	r12,r3
							break;
80005a6c:	c1 98       	rjmp	80005a9e <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80005a6e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80005a72:	06 9b       	mov	r11,r3
80005a74:	09 bc       	ld.ub	r12,r4[0x3]
80005a76:	f0 1f 00 2d 	mcall	80005b28 <log+0x164>
80005a7a:	06 9c       	mov	r12,r3
							break;
80005a7c:	c1 18       	rjmp	80005a9e <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80005a7e:	e8 c5 ff fc 	sub	r5,r4,-4
80005a82:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80005a84:	c0 d8       	rjmp	80005a9e <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80005a86:	06 9b       	mov	r11,r3
80005a88:	32 5c       	mov	r12,37
80005a8a:	f0 1f 00 28 	mcall	80005b28 <log+0x164>
80005a8e:	08 95       	mov	r5,r4
80005a90:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80005a92:	c0 68       	rjmp	80005a9e <log+0xda>
							
							default:
							log("I need relax.");
80005a94:	4a 6c       	lddpc	r12,80005b2c <log+0x168>
80005a96:	f0 1f 00 23 	mcall	80005b20 <log+0x15c>
80005a9a:	08 95       	mov	r5,r4
80005a9c:	06 9c       	mov	r12,r3
						}
						str++;
80005a9e:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80005aa0:	1a dc       	st.w	--sp,r12
80005aa2:	1a d6       	st.w	--sp,r6
80005aa4:	4a 3b       	lddpc	r11,80005b30 <log+0x16c>
80005aa6:	0c 9c       	mov	r12,r6
80005aa8:	f0 1f 00 23 	mcall	80005b34 <log+0x170>
80005aac:	2f ed       	sub	sp,-8
80005aae:	c0 a8       	rjmp	80005ac2 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005ab0:	2f f7       	sub	r7,-1
80005ab2:	1a d8       	st.w	--sp,r8
80005ab4:	1a d6       	st.w	--sp,r6
80005ab6:	4a 1b       	lddpc	r11,80005b38 <log+0x174>
80005ab8:	0c 9c       	mov	r12,r6
80005aba:	f0 1f 00 1f 	mcall	80005b34 <log+0x170>
80005abe:	08 95       	mov	r5,r4
80005ac0:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80005ac2:	0f 89       	ld.ub	r9,r7[0x0]
80005ac4:	30 08       	mov	r8,0
80005ac6:	f0 09 18 00 	cp.b	r9,r8
80005aca:	c0 30       	breq	80005ad0 <log+0x10c>
80005acc:	0a 94       	mov	r4,r5
80005ace:	c9 2b       	rjmp	800059f2 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80005ad0:	fa c7 fe f8 	sub	r7,sp,-264
80005ad4:	1a d7       	st.w	--sp,r7
80005ad6:	49 ab       	lddpc	r11,80005b3c <log+0x178>
80005ad8:	0e 9c       	mov	r12,r7
80005ada:	f0 1f 00 17 	mcall	80005b34 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80005ade:	5c 5c       	castu.b	r12
80005ae0:	f8 c6 ff ff 	sub	r6,r12,-1
80005ae4:	0c 9c       	mov	r12,r6
80005ae6:	f0 1f 00 17 	mcall	80005b40 <log+0x17c>
80005aea:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80005aec:	0c 9a       	mov	r10,r6
80005aee:	0e 9b       	mov	r11,r7
80005af0:	f0 1f 00 15 	mcall	80005b44 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
80005af4:	30 09       	mov	r9,0
80005af6:	30 5a       	mov	r10,5
80005af8:	fa cb fe f8 	sub	r11,sp,-264
80005afc:	49 38       	lddpc	r8,80005b48 <log+0x184>
80005afe:	70 0c       	ld.w	r12,r8[0x0]
80005b00:	f0 1f 00 13 	mcall	80005b4c <log+0x188>
80005b04:	2f fd       	sub	sp,-4
}
80005b06:	fe 3d fd f8 	sub	sp,-520
80005b0a:	d8 32       	popm	r0-r7,pc
80005b0c:	80 00       	ld.sh	r0,r0[0x0]
80005b0e:	64 6c       	ld.w	r12,r2[0x18]
80005b10:	00 00       	add	r0,r0
80005b12:	0d 50       	ld.sh	r0,--r6
80005b14:	80 00       	ld.sh	r0,r0[0x0]
80005b16:	c2 ec       	rcall	80005b72 <logFromISR+0x22>
80005b18:	80 00       	ld.sh	r0,r0[0x0]
80005b1a:	58 ea       	cp.w	r10,14
80005b1c:	80 00       	ld.sh	r0,r0[0x0]
80005b1e:	c5 98       	rjmp	80005bd0 <logFromISR+0x80>
80005b20:	80 00       	ld.sh	r0,r0[0x0]
80005b22:	59 c4       	cp.w	r4,28
80005b24:	80 00       	ld.sh	r0,r0[0x0]
80005b26:	58 38       	cp.w	r8,3
80005b28:	80 00       	ld.sh	r0,r0[0x0]
80005b2a:	58 34       	cp.w	r4,3
80005b2c:	80 00       	ld.sh	r0,r0[0x0]
80005b2e:	c5 a8       	rjmp	80005be2 <logFromISR+0x92>
80005b30:	80 00       	ld.sh	r0,r0[0x0]
80005b32:	c5 b8       	rjmp	80005be8 <logFromISR+0x98>
80005b34:	80 00       	ld.sh	r0,r0[0x0]
80005b36:	67 5c       	ld.w	r12,r3[0x54]
80005b38:	80 00       	ld.sh	r0,r0[0x0]
80005b3a:	c5 c0       	breq	80005bf2 <logFromISR+0xa2>
80005b3c:	80 00       	ld.sh	r0,r0[0x0]
80005b3e:	c5 c8       	rjmp	80005bf6 <logFromISR+0xa6>
80005b40:	80 00       	ld.sh	r0,r0[0x0]
80005b42:	4a 80       	lddpc	r0,80005be0 <logFromISR+0x90>
80005b44:	80 00       	ld.sh	r0,r0[0x0]
80005b46:	63 24       	ld.w	r4,r1[0x48]
80005b48:	00 00       	add	r0,r0
80005b4a:	3f e4       	mov	r4,-2
80005b4c:	80 00       	ld.sh	r0,r0[0x0]
80005b4e:	4d d4       	lddpc	r4,80005cc0 <logFromISR+0x170>

80005b50 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80005b50:	d4 31       	pushm	r0-r7,lr
80005b52:	fa cd 02 0c 	sub	sp,sp,524
80005b56:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80005b58:	e0 6a 01 00 	mov	r10,256
80005b5c:	30 0b       	mov	r11,0
80005b5e:	fa cc fe f4 	sub	r12,sp,-268
80005b62:	f0 1f 00 4c 	mcall	80005c90 <logFromISR+0x140>
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
}
	
	
int logFromISR(char * content, ...)
80005b66:	fa c4 fd d0 	sub	r4,sp,-560
80005b6a:	30 0a       	mov	r10,0
80005b6c:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005b6e:	fa c3 ff fc 	sub	r3,sp,-4
80005b72:	e0 61 01 00 	mov	r1,256
80005b76:	14 90       	mov	r0,r10
			
			if(*str == '%')
80005b78:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005b7a:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005b7e:	02 9a       	mov	r10,r1
80005b80:	00 9b       	mov	r11,r0
80005b82:	06 9c       	mov	r12,r3
80005b84:	f0 1f 00 43 	mcall	80005c90 <logFromISR+0x140>
			
			if(*str == '%')
80005b88:	0f 88       	ld.ub	r8,r7[0x0]
80005b8a:	e4 08 18 00 	cp.b	r8,r2
80005b8e:	c5 11       	brne	80005c30 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80005b90:	ee c8 ff ff 	sub	r8,r7,-1
80005b94:	11 89       	ld.ub	r9,r8[0x0]
80005b96:	4c 0a       	lddpc	r10,80005c94 <logFromISR+0x144>
80005b98:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80005b9a:	23 09       	sub	r9,48
80005b9c:	30 9a       	mov	r10,9
80005b9e:	f4 09 18 00 	cp.b	r9,r10
80005ba2:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80005ba6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80005baa:	f7 b9 08 30 	subls	r9,48
80005bae:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80005bb2:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80005bb6:	0f 88       	ld.ub	r8,r7[0x0]
80005bb8:	22 58       	sub	r8,37
80005bba:	e0 48 00 53 	cp.w	r8,83
80005bbe:	e0 8b 00 2b 	brhi	80005c14 <logFromISR+0xc4>
80005bc2:	4b 69       	lddpc	r9,80005c98 <logFromISR+0x148>
80005bc4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80005bc8:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80005bcc:	06 9a       	mov	r10,r3
80005bce:	40 0b       	lddsp	r11,sp[0x0]
80005bd0:	5c 5b       	castu.b	r11
80005bd2:	68 0c       	ld.w	r12,r4[0x0]
80005bd4:	f0 1f 00 32 	mcall	80005c9c <logFromISR+0x14c>
					break;
80005bd8:	c2 38       	rjmp	80005c1e <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80005bda:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80005bde:	06 9a       	mov	r10,r3
80005be0:	40 0b       	lddsp	r11,sp[0x0]
80005be2:	5c 5b       	castu.b	r11
80005be4:	68 0c       	ld.w	r12,r4[0x0]
80005be6:	f0 1f 00 2f 	mcall	80005ca0 <logFromISR+0x150>
80005bea:	06 9c       	mov	r12,r3
					break;
80005bec:	c1 98       	rjmp	80005c1e <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80005bee:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80005bf2:	06 9b       	mov	r11,r3
80005bf4:	09 bc       	ld.ub	r12,r4[0x3]
80005bf6:	f0 1f 00 2c 	mcall	80005ca4 <logFromISR+0x154>
80005bfa:	06 9c       	mov	r12,r3
					break;
80005bfc:	c1 18       	rjmp	80005c1e <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80005bfe:	e8 c5 ff fc 	sub	r5,r4,-4
80005c02:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80005c04:	c0 d8       	rjmp	80005c1e <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80005c06:	06 9b       	mov	r11,r3
80005c08:	32 5c       	mov	r12,37
80005c0a:	f0 1f 00 27 	mcall	80005ca4 <logFromISR+0x154>
80005c0e:	08 95       	mov	r5,r4
80005c10:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80005c12:	c0 68       	rjmp	80005c1e <logFromISR+0xce>
					default:
					log("I need relax.");
80005c14:	4a 5c       	lddpc	r12,80005ca8 <logFromISR+0x158>
80005c16:	f0 1f 00 26 	mcall	80005cac <logFromISR+0x15c>
80005c1a:	08 95       	mov	r5,r4
80005c1c:	06 9c       	mov	r12,r3
				}
				str++;
80005c1e:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80005c20:	1a dc       	st.w	--sp,r12
80005c22:	1a d6       	st.w	--sp,r6
80005c24:	4a 3b       	lddpc	r11,80005cb0 <logFromISR+0x160>
80005c26:	0c 9c       	mov	r12,r6
80005c28:	f0 1f 00 23 	mcall	80005cb4 <logFromISR+0x164>
80005c2c:	2f ed       	sub	sp,-8
80005c2e:	c0 a8       	rjmp	80005c42 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005c30:	2f f7       	sub	r7,-1
80005c32:	1a d8       	st.w	--sp,r8
80005c34:	1a d6       	st.w	--sp,r6
80005c36:	4a 1b       	lddpc	r11,80005cb8 <logFromISR+0x168>
80005c38:	0c 9c       	mov	r12,r6
80005c3a:	f0 1f 00 1f 	mcall	80005cb4 <logFromISR+0x164>
80005c3e:	08 95       	mov	r5,r4
80005c40:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80005c42:	0f 89       	ld.ub	r9,r7[0x0]
80005c44:	30 08       	mov	r8,0
80005c46:	f0 09 18 00 	cp.b	r9,r8
80005c4a:	c0 30       	breq	80005c50 <logFromISR+0x100>
80005c4c:	0a 94       	mov	r4,r5
80005c4e:	c9 8b       	rjmp	80005b7e <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80005c50:	fa c7 fe f4 	sub	r7,sp,-268
80005c54:	1a d7       	st.w	--sp,r7
80005c56:	49 ab       	lddpc	r11,80005cbc <logFromISR+0x16c>
80005c58:	0e 9c       	mov	r12,r7
80005c5a:	f0 1f 00 17 	mcall	80005cb4 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80005c5e:	5c 5c       	castu.b	r12
80005c60:	f8 c6 ff ff 	sub	r6,r12,-1
80005c64:	0c 9c       	mov	r12,r6
80005c66:	f0 1f 00 17 	mcall	80005cc0 <logFromISR+0x170>
80005c6a:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80005c6c:	0c 9a       	mov	r10,r6
80005c6e:	0e 9b       	mov	r11,r7
80005c70:	f0 1f 00 15 	mcall	80005cc4 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80005c74:	30 09       	mov	r9,0
80005c76:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80005c78:	fa ca fe f8 	sub	r10,sp,-264
80005c7c:	fa cb fe f4 	sub	r11,sp,-268
80005c80:	49 28       	lddpc	r8,80005cc8 <logFromISR+0x178>
80005c82:	70 0c       	ld.w	r12,r8[0x0]
80005c84:	f0 1f 00 12 	mcall	80005ccc <logFromISR+0x17c>
80005c88:	2f fd       	sub	sp,-4
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80005c8a:	fe 3d fd f4 	sub	sp,-524
80005c8e:	d8 32       	popm	r0-r7,pc
80005c90:	80 00       	ld.sh	r0,r0[0x0]
80005c92:	64 6c       	ld.w	r12,r2[0x18]
80005c94:	00 00       	add	r0,r0
80005c96:	0d 51       	ld.sh	r1,--r6
80005c98:	80 00       	ld.sh	r0,r0[0x0]
80005c9a:	c4 3c       	rcall	80005d20 <log_init+0x50>
80005c9c:	80 00       	ld.sh	r0,r0[0x0]
80005c9e:	58 ea       	cp.w	r10,14
80005ca0:	80 00       	ld.sh	r0,r0[0x0]
80005ca2:	58 38       	cp.w	r8,3
80005ca4:	80 00       	ld.sh	r0,r0[0x0]
80005ca6:	58 34       	cp.w	r4,3
80005ca8:	80 00       	ld.sh	r0,r0[0x0]
80005caa:	c5 a8       	rjmp	80005d5e <task_log+0x26>
80005cac:	80 00       	ld.sh	r0,r0[0x0]
80005cae:	59 c4       	cp.w	r4,28
80005cb0:	80 00       	ld.sh	r0,r0[0x0]
80005cb2:	c5 b8       	rjmp	80005d68 <task_log+0x30>
80005cb4:	80 00       	ld.sh	r0,r0[0x0]
80005cb6:	67 5c       	ld.w	r12,r3[0x54]
80005cb8:	80 00       	ld.sh	r0,r0[0x0]
80005cba:	c5 c0       	breq	80005d72 <task_log+0x3a>
80005cbc:	80 00       	ld.sh	r0,r0[0x0]
80005cbe:	c5 c8       	rjmp	80005d76 <task_log+0x3e>
80005cc0:	80 00       	ld.sh	r0,r0[0x0]
80005cc2:	4a 80       	lddpc	r0,80005d60 <task_log+0x28>
80005cc4:	80 00       	ld.sh	r0,r0[0x0]
80005cc6:	63 24       	ld.w	r4,r1[0x48]
80005cc8:	00 00       	add	r0,r0
80005cca:	3f e4       	mov	r4,-2
80005ccc:	80 00       	ld.sh	r0,r0[0x0]
80005cce:	4d 84       	lddpc	r4,80005e2c <gpio_enable_module_pin+0x24>

80005cd0 <log_init>:
		
	return str;
}

void log_init(void)
{
80005cd0:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80005cd2:	30 2b       	mov	r11,2
80005cd4:	49 0c       	lddpc	r12,80005d14 <log_init+0x44>
80005cd6:	f0 1f 00 11 	mcall	80005d18 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80005cda:	e0 6a 36 00 	mov	r10,13824
80005cde:	ea 1a 01 6e 	orh	r10,0x16e
80005ce2:	48 fb       	lddpc	r11,80005d1c <log_init+0x4c>
80005ce4:	fe 7c 18 00 	mov	r12,-59392
80005ce8:	f0 1f 00 0e 	mcall	80005d20 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80005cec:	30 4b       	mov	r11,4
80005cee:	33 2c       	mov	r12,50
80005cf0:	f0 1f 00 0d 	mcall	80005d24 <log_init+0x54>
80005cf4:	48 d8       	lddpc	r8,80005d28 <log_init+0x58>
80005cf6:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80005cf8:	30 09       	mov	r9,0
80005cfa:	1a d9       	st.w	--sp,r9
80005cfc:	1a d9       	st.w	--sp,r9
80005cfe:	1a d9       	st.w	--sp,r9
80005d00:	30 28       	mov	r8,2
80005d02:	e0 6a 01 80 	mov	r10,384
80005d06:	48 ab       	lddpc	r11,80005d2c <log_init+0x5c>
80005d08:	48 ac       	lddpc	r12,80005d30 <log_init+0x60>
80005d0a:	f0 1f 00 0b 	mcall	80005d34 <log_init+0x64>
80005d0e:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80005d10:	d8 02       	popm	pc
80005d12:	00 00       	add	r0,r0
80005d14:	80 00       	ld.sh	r0,r0[0x0]
80005d16:	c5 d4       	brge	80005dd0 <main+0x54>
80005d18:	80 00       	ld.sh	r0,r0[0x0]
80005d1a:	5e 5c       	retlt	r12
80005d1c:	80 00       	ld.sh	r0,r0[0x0]
80005d1e:	c5 8c       	rcall	80005dce <main+0x52>
80005d20:	80 00       	ld.sh	r0,r0[0x0]
80005d22:	46 24       	lddsp	r4,sp[0x188]
80005d24:	80 00       	ld.sh	r0,r0[0x0]
80005d26:	4f 2c       	lddpc	r12,80005eec <_malloc_r>
80005d28:	00 00       	add	r0,r0
80005d2a:	3f e4       	mov	r4,-2
80005d2c:	80 00       	ld.sh	r0,r0[0x0]
80005d2e:	c5 d0       	breq	80005de8 <main+0x6c>
80005d30:	80 00       	ld.sh	r0,r0[0x0]
80005d32:	5d 38       	musfr	r8
80005d34:	80 00       	ld.sh	r0,r0[0x0]
80005d36:	56 00       	stdsp	sp[0x180],r0

80005d38 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80005d38:	eb cd 40 f8 	pushm	r3-r7,lr
80005d3c:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80005d3e:	48 c7       	lddpc	r7,80005d6c <task_log+0x34>
80005d40:	30 05       	mov	r5,0
80005d42:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80005d44:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80005d48:	0a 99       	mov	r9,r5
80005d4a:	08 9a       	mov	r10,r4
80005d4c:	1a 9b       	mov	r11,sp
80005d4e:	6e 0c       	ld.w	r12,r7[0x0]
80005d50:	f0 1f 00 08 	mcall	80005d70 <task_log+0x38>
80005d54:	58 1c       	cp.w	r12,1
80005d56:	cf 91       	brne	80005d48 <task_log+0x10>
		{
			if( NULL != str)
80005d58:	40 0b       	lddsp	r11,sp[0x0]
80005d5a:	58 0b       	cp.w	r11,0
80005d5c:	cf 60       	breq	80005d48 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80005d5e:	06 9c       	mov	r12,r3
80005d60:	f0 1f 00 05 	mcall	80005d74 <task_log+0x3c>
				vPortFree(str);
80005d64:	40 0c       	lddsp	r12,sp[0x0]
80005d66:	f0 1f 00 05 	mcall	80005d78 <task_log+0x40>
80005d6a:	ce fb       	rjmp	80005d48 <task_log+0x10>
80005d6c:	00 00       	add	r0,r0
80005d6e:	3f e4       	mov	r4,-2
80005d70:	80 00       	ld.sh	r0,r0[0x0]
80005d72:	4b c8       	lddpc	r8,80005e60 <gpio_enable_module+0x4>
80005d74:	80 00       	ld.sh	r0,r0[0x0]
80005d76:	45 d4       	lddsp	r4,sp[0x174]
80005d78:	80 00       	ld.sh	r0,r0[0x0]
80005d7a:	4a 58       	lddpc	r8,80005e0c <gpio_enable_module_pin+0x4>

80005d7c <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
80005d7c:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80005d7e:	fe 78 10 00 	mov	r8,-61440
80005d82:	30 19       	mov	r9,1
80005d84:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80005d88:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80005d8c:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80005d90:	d3 03       	ssrf	0x10
	local_start_pll0();
80005d92:	f0 1f 00 13 	mcall	80005ddc <main+0x60>
		
	INTC_init_interrupts();
80005d96:	f0 1f 00 13 	mcall	80005de0 <main+0x64>
	
	log_init();		
80005d9a:	f0 1f 00 13 	mcall	80005de4 <main+0x68>
	log("----start debug----");	
80005d9e:	49 3c       	lddpc	r12,80005de8 <main+0x6c>
80005da0:	f0 1f 00 13 	mcall	80005dec <main+0x70>
		
	rtc_init();
80005da4:	f0 1f 00 13 	mcall	80005df0 <main+0x74>
	
	//fs_init();//65795

	tc_init();	
80005da8:	f0 1f 00 13 	mcall	80005df4 <main+0x78>
			
	xcmp_init();
80005dac:	f0 1f 00 13 	mcall	80005df8 <main+0x7c>
	
	app_init();
80005db0:	f0 1f 00 13 	mcall	80005dfc <main+0x80>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80005db4:	fe 79 10 00 	mov	r9,-61440
80005db8:	f2 f8 01 60 	ld.w	r8,r9[352]
80005dbc:	e2 18 00 02 	andl	r8,0x2,COH
80005dc0:	cf c0       	breq	80005db8 <main+0x3c>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80005dc2:	fe 79 10 00 	mov	r9,-61440
80005dc6:	f2 f8 01 60 	ld.w	r8,r9[352]
80005dca:	e2 18 00 02 	andl	r8,0x2,COH
80005dce:	cf c1       	brne	80005dc6 <main+0x4a>
	local_start_timer();
80005dd0:	f0 1f 00 0c 	mcall	80005e00 <main+0x84>
	
	Enable_global_interrupt();
80005dd4:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
80005dd6:	f0 1f 00 0c 	mcall	80005e04 <main+0x88>
	return 0;
}
80005dda:	d8 0a       	popm	pc,r12=0
80005ddc:	80 00       	ld.sh	r0,r0[0x0]
80005dde:	3e f4       	mov	r4,-17
80005de0:	80 00       	ld.sh	r0,r0[0x0]
80005de2:	41 10       	lddsp	r0,sp[0x44]
80005de4:	80 00       	ld.sh	r0,r0[0x0]
80005de6:	5c d0       	com	r0
80005de8:	80 00       	ld.sh	r0,r0[0x0]
80005dea:	c5 e4       	brge	80005ea6 <_stext+0x1a>
80005dec:	80 00       	ld.sh	r0,r0[0x0]
80005dee:	59 c4       	cp.w	r4,28
80005df0:	80 00       	ld.sh	r0,r0[0x0]
80005df2:	3f 44       	mov	r4,-12
80005df4:	80 00       	ld.sh	r0,r0[0x0]
80005df6:	40 0c       	lddsp	r12,sp[0x0]
80005df8:	80 00       	ld.sh	r0,r0[0x0]
80005dfa:	37 f8       	mov	r8,127
80005dfc:	80 00       	ld.sh	r0,r0[0x0]
80005dfe:	20 40       	sub	r0,4
80005e00:	80 00       	ld.sh	r0,r0[0x0]
80005e02:	3f d0       	mov	r0,-3
80005e04:	80 00       	ld.sh	r0,r0[0x0]
80005e06:	57 e8       	stdsp	sp[0x1f8],r8

80005e08 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005e08:	f8 08 16 05 	lsr	r8,r12,0x5
80005e0c:	a9 68       	lsl	r8,0x8
80005e0e:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80005e12:	58 1b       	cp.w	r11,1
80005e14:	c0 d0       	breq	80005e2e <gpio_enable_module_pin+0x26>
80005e16:	c0 63       	brcs	80005e22 <gpio_enable_module_pin+0x1a>
80005e18:	58 2b       	cp.w	r11,2
80005e1a:	c1 00       	breq	80005e3a <gpio_enable_module_pin+0x32>
80005e1c:	58 3b       	cp.w	r11,3
80005e1e:	c1 40       	breq	80005e46 <gpio_enable_module_pin+0x3e>
80005e20:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005e22:	30 19       	mov	r9,1
80005e24:	f2 0c 09 49 	lsl	r9,r9,r12
80005e28:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005e2a:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005e2c:	c1 28       	rjmp	80005e50 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005e2e:	30 19       	mov	r9,1
80005e30:	f2 0c 09 49 	lsl	r9,r9,r12
80005e34:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005e36:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005e38:	c0 c8       	rjmp	80005e50 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005e3a:	30 19       	mov	r9,1
80005e3c:	f2 0c 09 49 	lsl	r9,r9,r12
80005e40:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005e42:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005e44:	c0 68       	rjmp	80005e50 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005e46:	30 19       	mov	r9,1
80005e48:	f2 0c 09 49 	lsl	r9,r9,r12
80005e4c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005e4e:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80005e50:	30 19       	mov	r9,1
80005e52:	f2 0c 09 4c 	lsl	r12,r9,r12
80005e56:	91 2c       	st.w	r8[0x8],r12
80005e58:	5e fd       	retal	0
80005e5a:	d7 03       	nop

80005e5c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80005e5c:	d4 21       	pushm	r4-r7,lr
80005e5e:	18 97       	mov	r7,r12
80005e60:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005e62:	58 0b       	cp.w	r11,0
80005e64:	c0 31       	brne	80005e6a <gpio_enable_module+0xe>
80005e66:	30 05       	mov	r5,0
80005e68:	c0 d8       	rjmp	80005e82 <gpio_enable_module+0x26>
80005e6a:	30 06       	mov	r6,0
80005e6c:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80005e6e:	6e 1b       	ld.w	r11,r7[0x4]
80005e70:	6e 0c       	ld.w	r12,r7[0x0]
80005e72:	f0 1f 00 06 	mcall	80005e88 <gpio_enable_module+0x2c>
80005e76:	18 45       	or	r5,r12
		gpiomap++;
80005e78:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005e7a:	2f f6       	sub	r6,-1
80005e7c:	0c 34       	cp.w	r4,r6
80005e7e:	fe 9b ff f8 	brhi	80005e6e <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80005e82:	0a 9c       	mov	r12,r5
80005e84:	d8 22       	popm	r4-r7,pc
80005e86:	00 00       	add	r0,r0
80005e88:	80 00       	ld.sh	r0,r0[0x0]
80005e8a:	5e 08       	reteq	r8

80005e8c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005e8c:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005e90:	fe c0 a6 90 	sub	r0,pc,-22896

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005e94:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005e98:	d5 53       	csrf	0x15
  cp      r0, r1
80005e9a:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80005e9c:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005ea0:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005ea2:	c0 72       	brcc	80005eb0 <idata_load_loop_end>
  cp      r0, r1
80005ea4:	fe c2 93 24 	sub	r2,pc,-27868

80005ea8 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005ea8:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
80005eaa:	a1 24       	st.d	r0++,r4
  cp      r0, r1
80005eac:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
80005eae:	cf d3       	brcs	80005ea8 <idata_load_loop>

80005eb0 <idata_load_loop_end>:
  mov     r2, 0
80005eb0:	e0 60 0a 40 	mov	r0,2624
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
80005eb4:	e0 61 3f f0 	mov	r1,16368
  cp      r0, r1
  brlo    udata_clear_loop
80005eb8:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005eba:	c0 62       	brcc	80005ec6 <udata_clear_loop_end>
80005ebc:	30 02       	mov	r2,0
80005ebe:	30 03       	mov	r3,0

80005ec0 <udata_clear_loop>:
80005ec0:	a1 22       	st.d	r0++,r2
80005ec2:	02 30       	cp.w	r0,r1
80005ec4:	cf e3       	brcs	80005ec0 <udata_clear_loop>

80005ec6 <udata_clear_loop_end>:
80005ec6:	fe cf 01 4a 	sub	pc,pc,330
80005eca:	d7 03       	nop

80005ecc <free>:
80005ecc:	d4 01       	pushm	lr
80005ece:	e0 68 0a 38 	mov	r8,2616
80005ed2:	18 9b       	mov	r11,r12
80005ed4:	70 0c       	ld.w	r12,r8[0x0]
80005ed6:	e0 a0 1e 6d 	rcall	80009bb0 <_free_r>
80005eda:	d8 02       	popm	pc

80005edc <malloc>:
80005edc:	d4 01       	pushm	lr
80005ede:	e0 68 0a 38 	mov	r8,2616
80005ee2:	18 9b       	mov	r11,r12
80005ee4:	70 0c       	ld.w	r12,r8[0x0]
80005ee6:	c0 3c       	rcall	80005eec <_malloc_r>
80005ee8:	d8 02       	popm	pc
80005eea:	d7 03       	nop

80005eec <_malloc_r>:
80005eec:	d4 31       	pushm	r0-r7,lr
80005eee:	f6 c8 ff f5 	sub	r8,r11,-11
80005ef2:	18 95       	mov	r5,r12
80005ef4:	10 97       	mov	r7,r8
80005ef6:	e0 17 ff f8 	andl	r7,0xfff8
80005efa:	59 68       	cp.w	r8,22
80005efc:	f9 b7 08 10 	movls	r7,16
80005f00:	16 37       	cp.w	r7,r11
80005f02:	5f 38       	srlo	r8
80005f04:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80005f08:	c0 50       	breq	80005f12 <_malloc_r+0x26>
80005f0a:	30 c8       	mov	r8,12
80005f0c:	99 38       	st.w	r12[0xc],r8
80005f0e:	e0 8f 01 fa 	bral	80006302 <_malloc_r+0x416>
80005f12:	fe b0 f5 59 	rcall	800049c4 <__malloc_lock>
80005f16:	e0 47 01 f7 	cp.w	r7,503
80005f1a:	e0 8b 00 1d 	brhi	80005f54 <_malloc_r+0x68>
80005f1e:	ee 03 16 03 	lsr	r3,r7,0x3
80005f22:	e0 68 05 38 	mov	r8,1336
80005f26:	f0 03 00 38 	add	r8,r8,r3<<0x3
80005f2a:	70 36       	ld.w	r6,r8[0xc]
80005f2c:	10 36       	cp.w	r6,r8
80005f2e:	c0 61       	brne	80005f3a <_malloc_r+0x4e>
80005f30:	ec c8 ff f8 	sub	r8,r6,-8
80005f34:	70 36       	ld.w	r6,r8[0xc]
80005f36:	10 36       	cp.w	r6,r8
80005f38:	c0 c0       	breq	80005f50 <_malloc_r+0x64>
80005f3a:	6c 18       	ld.w	r8,r6[0x4]
80005f3c:	e0 18 ff fc 	andl	r8,0xfffc
80005f40:	6c 3a       	ld.w	r10,r6[0xc]
80005f42:	ec 08 00 09 	add	r9,r6,r8
80005f46:	0a 9c       	mov	r12,r5
80005f48:	6c 28       	ld.w	r8,r6[0x8]
80005f4a:	95 28       	st.w	r10[0x8],r8
80005f4c:	91 3a       	st.w	r8[0xc],r10
80005f4e:	c4 78       	rjmp	80005fdc <_malloc_r+0xf0>
80005f50:	2f e3       	sub	r3,-2
80005f52:	c4 d8       	rjmp	80005fec <_malloc_r+0x100>
80005f54:	ee 03 16 09 	lsr	r3,r7,0x9
80005f58:	c0 41       	brne	80005f60 <_malloc_r+0x74>
80005f5a:	ee 03 16 03 	lsr	r3,r7,0x3
80005f5e:	c2 68       	rjmp	80005faa <_malloc_r+0xbe>
80005f60:	58 43       	cp.w	r3,4
80005f62:	e0 8b 00 06 	brhi	80005f6e <_malloc_r+0x82>
80005f66:	ee 03 16 06 	lsr	r3,r7,0x6
80005f6a:	2c 83       	sub	r3,-56
80005f6c:	c1 f8       	rjmp	80005faa <_malloc_r+0xbe>
80005f6e:	59 43       	cp.w	r3,20
80005f70:	e0 8b 00 04 	brhi	80005f78 <_malloc_r+0x8c>
80005f74:	2a 53       	sub	r3,-91
80005f76:	c1 a8       	rjmp	80005faa <_malloc_r+0xbe>
80005f78:	e0 43 00 54 	cp.w	r3,84
80005f7c:	e0 8b 00 06 	brhi	80005f88 <_malloc_r+0x9c>
80005f80:	ee 03 16 0c 	lsr	r3,r7,0xc
80005f84:	29 23       	sub	r3,-110
80005f86:	c1 28       	rjmp	80005faa <_malloc_r+0xbe>
80005f88:	e0 43 01 54 	cp.w	r3,340
80005f8c:	e0 8b 00 06 	brhi	80005f98 <_malloc_r+0xac>
80005f90:	ee 03 16 0f 	lsr	r3,r7,0xf
80005f94:	28 93       	sub	r3,-119
80005f96:	c0 a8       	rjmp	80005faa <_malloc_r+0xbe>
80005f98:	e0 43 05 54 	cp.w	r3,1364
80005f9c:	e0 88 00 04 	brls	80005fa4 <_malloc_r+0xb8>
80005fa0:	37 e3       	mov	r3,126
80005fa2:	c0 48       	rjmp	80005faa <_malloc_r+0xbe>
80005fa4:	ee 03 16 12 	lsr	r3,r7,0x12
80005fa8:	28 43       	sub	r3,-124
80005faa:	e0 6a 05 38 	mov	r10,1336
80005fae:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80005fb2:	74 36       	ld.w	r6,r10[0xc]
80005fb4:	c1 98       	rjmp	80005fe6 <_malloc_r+0xfa>
80005fb6:	6c 19       	ld.w	r9,r6[0x4]
80005fb8:	e0 19 ff fc 	andl	r9,0xfffc
80005fbc:	f2 07 01 0b 	sub	r11,r9,r7
80005fc0:	58 fb       	cp.w	r11,15
80005fc2:	e0 8a 00 04 	brle	80005fca <_malloc_r+0xde>
80005fc6:	20 13       	sub	r3,1
80005fc8:	c1 18       	rjmp	80005fea <_malloc_r+0xfe>
80005fca:	6c 38       	ld.w	r8,r6[0xc]
80005fcc:	58 0b       	cp.w	r11,0
80005fce:	c0 b5       	brlt	80005fe4 <_malloc_r+0xf8>
80005fd0:	6c 2a       	ld.w	r10,r6[0x8]
80005fd2:	ec 09 00 09 	add	r9,r6,r9
80005fd6:	0a 9c       	mov	r12,r5
80005fd8:	91 2a       	st.w	r8[0x8],r10
80005fda:	95 38       	st.w	r10[0xc],r8
80005fdc:	72 18       	ld.w	r8,r9[0x4]
80005fde:	a1 a8       	sbr	r8,0x0
80005fe0:	93 18       	st.w	r9[0x4],r8
80005fe2:	cb c8       	rjmp	8000615a <_malloc_r+0x26e>
80005fe4:	10 96       	mov	r6,r8
80005fe6:	14 36       	cp.w	r6,r10
80005fe8:	ce 71       	brne	80005fb6 <_malloc_r+0xca>
80005fea:	2f f3       	sub	r3,-1
80005fec:	e0 6a 05 38 	mov	r10,1336
80005ff0:	f4 cc ff f8 	sub	r12,r10,-8
80005ff4:	78 26       	ld.w	r6,r12[0x8]
80005ff6:	18 36       	cp.w	r6,r12
80005ff8:	c6 c0       	breq	800060d0 <_malloc_r+0x1e4>
80005ffa:	6c 19       	ld.w	r9,r6[0x4]
80005ffc:	e0 19 ff fc 	andl	r9,0xfffc
80006000:	f2 07 01 08 	sub	r8,r9,r7
80006004:	58 f8       	cp.w	r8,15
80006006:	e0 89 00 8f 	brgt	80006124 <_malloc_r+0x238>
8000600a:	99 3c       	st.w	r12[0xc],r12
8000600c:	99 2c       	st.w	r12[0x8],r12
8000600e:	58 08       	cp.w	r8,0
80006010:	c0 55       	brlt	8000601a <_malloc_r+0x12e>
80006012:	ec 09 00 09 	add	r9,r6,r9
80006016:	0a 9c       	mov	r12,r5
80006018:	ce 2b       	rjmp	80005fdc <_malloc_r+0xf0>
8000601a:	e0 49 01 ff 	cp.w	r9,511
8000601e:	e0 8b 00 13 	brhi	80006044 <_malloc_r+0x158>
80006022:	a3 99       	lsr	r9,0x3
80006024:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006028:	70 2b       	ld.w	r11,r8[0x8]
8000602a:	8d 38       	st.w	r6[0xc],r8
8000602c:	8d 2b       	st.w	r6[0x8],r11
8000602e:	97 36       	st.w	r11[0xc],r6
80006030:	91 26       	st.w	r8[0x8],r6
80006032:	a3 49       	asr	r9,0x2
80006034:	74 18       	ld.w	r8,r10[0x4]
80006036:	30 1b       	mov	r11,1
80006038:	f6 09 09 49 	lsl	r9,r11,r9
8000603c:	f1 e9 10 09 	or	r9,r8,r9
80006040:	95 19       	st.w	r10[0x4],r9
80006042:	c4 78       	rjmp	800060d0 <_malloc_r+0x1e4>
80006044:	f2 0a 16 09 	lsr	r10,r9,0x9
80006048:	58 4a       	cp.w	r10,4
8000604a:	e0 8b 00 07 	brhi	80006058 <_malloc_r+0x16c>
8000604e:	f2 0a 16 06 	lsr	r10,r9,0x6
80006052:	2c 8a       	sub	r10,-56
80006054:	c2 08       	rjmp	80006094 <_malloc_r+0x1a8>
80006056:	d7 03       	nop
80006058:	59 4a       	cp.w	r10,20
8000605a:	e0 8b 00 04 	brhi	80006062 <_malloc_r+0x176>
8000605e:	2a 5a       	sub	r10,-91
80006060:	c1 a8       	rjmp	80006094 <_malloc_r+0x1a8>
80006062:	e0 4a 00 54 	cp.w	r10,84
80006066:	e0 8b 00 06 	brhi	80006072 <_malloc_r+0x186>
8000606a:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000606e:	29 2a       	sub	r10,-110
80006070:	c1 28       	rjmp	80006094 <_malloc_r+0x1a8>
80006072:	e0 4a 01 54 	cp.w	r10,340
80006076:	e0 8b 00 06 	brhi	80006082 <_malloc_r+0x196>
8000607a:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000607e:	28 9a       	sub	r10,-119
80006080:	c0 a8       	rjmp	80006094 <_malloc_r+0x1a8>
80006082:	e0 4a 05 54 	cp.w	r10,1364
80006086:	e0 88 00 04 	brls	8000608e <_malloc_r+0x1a2>
8000608a:	37 ea       	mov	r10,126
8000608c:	c0 48       	rjmp	80006094 <_malloc_r+0x1a8>
8000608e:	f2 0a 16 12 	lsr	r10,r9,0x12
80006092:	28 4a       	sub	r10,-124
80006094:	e0 6b 05 38 	mov	r11,1336
80006098:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000609c:	68 28       	ld.w	r8,r4[0x8]
8000609e:	08 38       	cp.w	r8,r4
800060a0:	c0 e1       	brne	800060bc <_malloc_r+0x1d0>
800060a2:	76 19       	ld.w	r9,r11[0x4]
800060a4:	a3 4a       	asr	r10,0x2
800060a6:	30 1e       	mov	lr,1
800060a8:	fc 0a 09 4a 	lsl	r10,lr,r10
800060ac:	f3 ea 10 0a 	or	r10,r9,r10
800060b0:	10 99       	mov	r9,r8
800060b2:	97 1a       	st.w	r11[0x4],r10
800060b4:	c0 a8       	rjmp	800060c8 <_malloc_r+0x1dc>
800060b6:	70 28       	ld.w	r8,r8[0x8]
800060b8:	08 38       	cp.w	r8,r4
800060ba:	c0 60       	breq	800060c6 <_malloc_r+0x1da>
800060bc:	70 1a       	ld.w	r10,r8[0x4]
800060be:	e0 1a ff fc 	andl	r10,0xfffc
800060c2:	14 39       	cp.w	r9,r10
800060c4:	cf 93       	brcs	800060b6 <_malloc_r+0x1ca>
800060c6:	70 39       	ld.w	r9,r8[0xc]
800060c8:	8d 39       	st.w	r6[0xc],r9
800060ca:	8d 28       	st.w	r6[0x8],r8
800060cc:	91 36       	st.w	r8[0xc],r6
800060ce:	93 26       	st.w	r9[0x8],r6
800060d0:	e6 08 14 02 	asr	r8,r3,0x2
800060d4:	30 1b       	mov	r11,1
800060d6:	e0 64 05 38 	mov	r4,1336
800060da:	f6 08 09 4b 	lsl	r11,r11,r8
800060de:	68 18       	ld.w	r8,r4[0x4]
800060e0:	10 3b       	cp.w	r11,r8
800060e2:	e0 8b 00 6b 	brhi	800061b8 <_malloc_r+0x2cc>
800060e6:	f7 e8 00 09 	and	r9,r11,r8
800060ea:	c0 b1       	brne	80006100 <_malloc_r+0x214>
800060ec:	e0 13 ff fc 	andl	r3,0xfffc
800060f0:	a1 7b       	lsl	r11,0x1
800060f2:	2f c3       	sub	r3,-4
800060f4:	c0 38       	rjmp	800060fa <_malloc_r+0x20e>
800060f6:	2f c3       	sub	r3,-4
800060f8:	a1 7b       	lsl	r11,0x1
800060fa:	f7 e8 00 09 	and	r9,r11,r8
800060fe:	cf c0       	breq	800060f6 <_malloc_r+0x20a>
80006100:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80006104:	06 92       	mov	r2,r3
80006106:	1c 91       	mov	r1,lr
80006108:	62 36       	ld.w	r6,r1[0xc]
8000610a:	c2 e8       	rjmp	80006166 <_malloc_r+0x27a>
8000610c:	6c 1a       	ld.w	r10,r6[0x4]
8000610e:	e0 1a ff fc 	andl	r10,0xfffc
80006112:	f4 07 01 08 	sub	r8,r10,r7
80006116:	58 f8       	cp.w	r8,15
80006118:	e0 8a 00 15 	brle	80006142 <_malloc_r+0x256>
8000611c:	6c 3a       	ld.w	r10,r6[0xc]
8000611e:	6c 29       	ld.w	r9,r6[0x8]
80006120:	95 29       	st.w	r10[0x8],r9
80006122:	93 3a       	st.w	r9[0xc],r10
80006124:	0e 99       	mov	r9,r7
80006126:	ec 07 00 07 	add	r7,r6,r7
8000612a:	a1 a9       	sbr	r9,0x0
8000612c:	99 37       	st.w	r12[0xc],r7
8000612e:	99 27       	st.w	r12[0x8],r7
80006130:	8d 19       	st.w	r6[0x4],r9
80006132:	ee 08 09 08 	st.w	r7[r8],r8
80006136:	8f 2c       	st.w	r7[0x8],r12
80006138:	8f 3c       	st.w	r7[0xc],r12
8000613a:	a1 a8       	sbr	r8,0x0
8000613c:	0a 9c       	mov	r12,r5
8000613e:	8f 18       	st.w	r7[0x4],r8
80006140:	c0 d8       	rjmp	8000615a <_malloc_r+0x26e>
80006142:	6c 39       	ld.w	r9,r6[0xc]
80006144:	58 08       	cp.w	r8,0
80006146:	c0 f5       	brlt	80006164 <_malloc_r+0x278>
80006148:	ec 0a 00 0a 	add	r10,r6,r10
8000614c:	74 18       	ld.w	r8,r10[0x4]
8000614e:	a1 a8       	sbr	r8,0x0
80006150:	0a 9c       	mov	r12,r5
80006152:	95 18       	st.w	r10[0x4],r8
80006154:	6c 28       	ld.w	r8,r6[0x8]
80006156:	93 28       	st.w	r9[0x8],r8
80006158:	91 39       	st.w	r8[0xc],r9
8000615a:	fe b0 f4 3b 	rcall	800049d0 <__malloc_unlock>
8000615e:	ec cc ff f8 	sub	r12,r6,-8
80006162:	d8 32       	popm	r0-r7,pc
80006164:	12 96       	mov	r6,r9
80006166:	02 36       	cp.w	r6,r1
80006168:	cd 21       	brne	8000610c <_malloc_r+0x220>
8000616a:	2f f2       	sub	r2,-1
8000616c:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006170:	c0 30       	breq	80006176 <_malloc_r+0x28a>
80006172:	2f 81       	sub	r1,-8
80006174:	cc ab       	rjmp	80006108 <_malloc_r+0x21c>
80006176:	1c 98       	mov	r8,lr
80006178:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000617c:	c0 81       	brne	8000618c <_malloc_r+0x2a0>
8000617e:	68 19       	ld.w	r9,r4[0x4]
80006180:	f6 08 11 ff 	rsub	r8,r11,-1
80006184:	f3 e8 00 08 	and	r8,r9,r8
80006188:	89 18       	st.w	r4[0x4],r8
8000618a:	c0 78       	rjmp	80006198 <_malloc_r+0x2ac>
8000618c:	f0 c9 00 08 	sub	r9,r8,8
80006190:	20 13       	sub	r3,1
80006192:	70 08       	ld.w	r8,r8[0x0]
80006194:	12 38       	cp.w	r8,r9
80006196:	cf 10       	breq	80006178 <_malloc_r+0x28c>
80006198:	a1 7b       	lsl	r11,0x1
8000619a:	68 18       	ld.w	r8,r4[0x4]
8000619c:	10 3b       	cp.w	r11,r8
8000619e:	e0 8b 00 0d 	brhi	800061b8 <_malloc_r+0x2cc>
800061a2:	58 0b       	cp.w	r11,0
800061a4:	c0 a0       	breq	800061b8 <_malloc_r+0x2cc>
800061a6:	04 93       	mov	r3,r2
800061a8:	c0 38       	rjmp	800061ae <_malloc_r+0x2c2>
800061aa:	2f c3       	sub	r3,-4
800061ac:	a1 7b       	lsl	r11,0x1
800061ae:	f7 e8 00 09 	and	r9,r11,r8
800061b2:	ca 71       	brne	80006100 <_malloc_r+0x214>
800061b4:	cf bb       	rjmp	800061aa <_malloc_r+0x2be>
800061b6:	d7 03       	nop
800061b8:	68 23       	ld.w	r3,r4[0x8]
800061ba:	66 12       	ld.w	r2,r3[0x4]
800061bc:	e0 12 ff fc 	andl	r2,0xfffc
800061c0:	0e 32       	cp.w	r2,r7
800061c2:	5f 39       	srlo	r9
800061c4:	e4 07 01 08 	sub	r8,r2,r7
800061c8:	58 f8       	cp.w	r8,15
800061ca:	5f aa       	srle	r10
800061cc:	f5 e9 10 09 	or	r9,r10,r9
800061d0:	e0 80 00 9a 	breq	80006304 <_malloc_r+0x418>
800061d4:	e0 68 0d 5c 	mov	r8,3420
800061d8:	70 01       	ld.w	r1,r8[0x0]
800061da:	e0 68 09 44 	mov	r8,2372
800061de:	2f 01       	sub	r1,-16
800061e0:	70 08       	ld.w	r8,r8[0x0]
800061e2:	0e 01       	add	r1,r7
800061e4:	5b f8       	cp.w	r8,-1
800061e6:	c0 40       	breq	800061ee <_malloc_r+0x302>
800061e8:	28 11       	sub	r1,-127
800061ea:	e0 11 ff 80 	andl	r1,0xff80
800061ee:	02 9b       	mov	r11,r1
800061f0:	0a 9c       	mov	r12,r5
800061f2:	e0 a0 02 a5 	rcall	8000673c <_sbrk_r>
800061f6:	18 96       	mov	r6,r12
800061f8:	5b fc       	cp.w	r12,-1
800061fa:	c7 50       	breq	800062e4 <_malloc_r+0x3f8>
800061fc:	e6 02 00 08 	add	r8,r3,r2
80006200:	10 3c       	cp.w	r12,r8
80006202:	c0 32       	brcc	80006208 <_malloc_r+0x31c>
80006204:	08 33       	cp.w	r3,r4
80006206:	c6 f1       	brne	800062e4 <_malloc_r+0x3f8>
80006208:	e0 6a 0d 60 	mov	r10,3424
8000620c:	74 09       	ld.w	r9,r10[0x0]
8000620e:	e2 09 00 09 	add	r9,r1,r9
80006212:	95 09       	st.w	r10[0x0],r9
80006214:	10 36       	cp.w	r6,r8
80006216:	c0 a1       	brne	8000622a <_malloc_r+0x33e>
80006218:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000621c:	c0 71       	brne	8000622a <_malloc_r+0x33e>
8000621e:	e2 02 00 02 	add	r2,r1,r2
80006222:	68 28       	ld.w	r8,r4[0x8]
80006224:	a1 a2       	sbr	r2,0x0
80006226:	91 12       	st.w	r8[0x4],r2
80006228:	c4 f8       	rjmp	800062c6 <_malloc_r+0x3da>
8000622a:	e0 6a 09 44 	mov	r10,2372
8000622e:	74 0b       	ld.w	r11,r10[0x0]
80006230:	5b fb       	cp.w	r11,-1
80006232:	c0 31       	brne	80006238 <_malloc_r+0x34c>
80006234:	95 06       	st.w	r10[0x0],r6
80006236:	c0 78       	rjmp	80006244 <_malloc_r+0x358>
80006238:	ec 09 00 09 	add	r9,r6,r9
8000623c:	e0 6a 0d 60 	mov	r10,3424
80006240:	10 19       	sub	r9,r8
80006242:	95 09       	st.w	r10[0x0],r9
80006244:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006248:	f0 09 11 08 	rsub	r9,r8,8
8000624c:	58 08       	cp.w	r8,0
8000624e:	f2 08 17 10 	movne	r8,r9
80006252:	ed d8 e1 06 	addne	r6,r6,r8
80006256:	28 08       	sub	r8,-128
80006258:	ec 01 00 01 	add	r1,r6,r1
8000625c:	0a 9c       	mov	r12,r5
8000625e:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006262:	f0 01 01 01 	sub	r1,r8,r1
80006266:	02 9b       	mov	r11,r1
80006268:	e0 a0 02 6a 	rcall	8000673c <_sbrk_r>
8000626c:	e0 68 0d 60 	mov	r8,3424
80006270:	5b fc       	cp.w	r12,-1
80006272:	ec 0c 17 00 	moveq	r12,r6
80006276:	f9 b1 00 00 	moveq	r1,0
8000627a:	70 09       	ld.w	r9,r8[0x0]
8000627c:	0c 1c       	sub	r12,r6
8000627e:	89 26       	st.w	r4[0x8],r6
80006280:	02 0c       	add	r12,r1
80006282:	12 01       	add	r1,r9
80006284:	a1 ac       	sbr	r12,0x0
80006286:	91 01       	st.w	r8[0x0],r1
80006288:	8d 1c       	st.w	r6[0x4],r12
8000628a:	08 33       	cp.w	r3,r4
8000628c:	c1 d0       	breq	800062c6 <_malloc_r+0x3da>
8000628e:	58 f2       	cp.w	r2,15
80006290:	e0 8b 00 05 	brhi	8000629a <_malloc_r+0x3ae>
80006294:	30 18       	mov	r8,1
80006296:	8d 18       	st.w	r6[0x4],r8
80006298:	c2 68       	rjmp	800062e4 <_malloc_r+0x3f8>
8000629a:	30 59       	mov	r9,5
8000629c:	20 c2       	sub	r2,12
8000629e:	e0 12 ff f8 	andl	r2,0xfff8
800062a2:	e6 02 00 08 	add	r8,r3,r2
800062a6:	91 29       	st.w	r8[0x8],r9
800062a8:	91 19       	st.w	r8[0x4],r9
800062aa:	66 18       	ld.w	r8,r3[0x4]
800062ac:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800062b0:	e5 e8 10 08 	or	r8,r2,r8
800062b4:	87 18       	st.w	r3[0x4],r8
800062b6:	58 f2       	cp.w	r2,15
800062b8:	e0 88 00 07 	brls	800062c6 <_malloc_r+0x3da>
800062bc:	e6 cb ff f8 	sub	r11,r3,-8
800062c0:	0a 9c       	mov	r12,r5
800062c2:	e0 a0 1c 77 	rcall	80009bb0 <_free_r>
800062c6:	e0 69 0d 58 	mov	r9,3416
800062ca:	72 0a       	ld.w	r10,r9[0x0]
800062cc:	e0 68 0d 60 	mov	r8,3424
800062d0:	70 08       	ld.w	r8,r8[0x0]
800062d2:	14 38       	cp.w	r8,r10
800062d4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800062d8:	e0 69 0d 54 	mov	r9,3412
800062dc:	72 0a       	ld.w	r10,r9[0x0]
800062de:	14 38       	cp.w	r8,r10
800062e0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800062e4:	68 28       	ld.w	r8,r4[0x8]
800062e6:	70 18       	ld.w	r8,r8[0x4]
800062e8:	e0 18 ff fc 	andl	r8,0xfffc
800062ec:	0e 38       	cp.w	r8,r7
800062ee:	5f 39       	srlo	r9
800062f0:	0e 18       	sub	r8,r7
800062f2:	58 f8       	cp.w	r8,15
800062f4:	5f aa       	srle	r10
800062f6:	f5 e9 10 09 	or	r9,r10,r9
800062fa:	c0 50       	breq	80006304 <_malloc_r+0x418>
800062fc:	0a 9c       	mov	r12,r5
800062fe:	fe b0 f3 69 	rcall	800049d0 <__malloc_unlock>
80006302:	d8 3a       	popm	r0-r7,pc,r12=0
80006304:	68 26       	ld.w	r6,r4[0x8]
80006306:	a1 a8       	sbr	r8,0x0
80006308:	0e 99       	mov	r9,r7
8000630a:	a1 a9       	sbr	r9,0x0
8000630c:	8d 19       	st.w	r6[0x4],r9
8000630e:	ec 07 00 07 	add	r7,r6,r7
80006312:	0a 9c       	mov	r12,r5
80006314:	89 27       	st.w	r4[0x8],r7
80006316:	8f 18       	st.w	r7[0x4],r8
80006318:	fe b0 f3 5c 	rcall	800049d0 <__malloc_unlock>
8000631c:	ec cc ff f8 	sub	r12,r6,-8
80006320:	d8 32       	popm	r0-r7,pc
80006322:	d7 03       	nop

80006324 <memcpy>:
80006324:	58 8a       	cp.w	r10,8
80006326:	c2 f5       	brlt	80006384 <memcpy+0x60>
80006328:	f9 eb 10 09 	or	r9,r12,r11
8000632c:	e2 19 00 03 	andl	r9,0x3,COH
80006330:	e0 81 00 97 	brne	8000645e <memcpy+0x13a>
80006334:	e0 4a 00 20 	cp.w	r10,32
80006338:	c3 b4       	brge	800063ae <memcpy+0x8a>
8000633a:	f4 08 14 02 	asr	r8,r10,0x2
8000633e:	f0 09 11 08 	rsub	r9,r8,8
80006342:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80006346:	76 69       	ld.w	r9,r11[0x18]
80006348:	99 69       	st.w	r12[0x18],r9
8000634a:	76 59       	ld.w	r9,r11[0x14]
8000634c:	99 59       	st.w	r12[0x14],r9
8000634e:	76 49       	ld.w	r9,r11[0x10]
80006350:	99 49       	st.w	r12[0x10],r9
80006352:	76 39       	ld.w	r9,r11[0xc]
80006354:	99 39       	st.w	r12[0xc],r9
80006356:	76 29       	ld.w	r9,r11[0x8]
80006358:	99 29       	st.w	r12[0x8],r9
8000635a:	76 19       	ld.w	r9,r11[0x4]
8000635c:	99 19       	st.w	r12[0x4],r9
8000635e:	76 09       	ld.w	r9,r11[0x0]
80006360:	99 09       	st.w	r12[0x0],r9
80006362:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80006366:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000636a:	e0 1a 00 03 	andl	r10,0x3
8000636e:	f4 0a 11 04 	rsub	r10,r10,4
80006372:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006376:	17 a9       	ld.ub	r9,r11[0x2]
80006378:	b0 a9       	st.b	r8[0x2],r9
8000637a:	17 99       	ld.ub	r9,r11[0x1]
8000637c:	b0 99       	st.b	r8[0x1],r9
8000637e:	17 89       	ld.ub	r9,r11[0x0]
80006380:	b0 89       	st.b	r8[0x0],r9
80006382:	5e fc       	retal	r12
80006384:	f4 0a 11 09 	rsub	r10,r10,9
80006388:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000638c:	17 f9       	ld.ub	r9,r11[0x7]
8000638e:	b8 f9       	st.b	r12[0x7],r9
80006390:	17 e9       	ld.ub	r9,r11[0x6]
80006392:	b8 e9       	st.b	r12[0x6],r9
80006394:	17 d9       	ld.ub	r9,r11[0x5]
80006396:	b8 d9       	st.b	r12[0x5],r9
80006398:	17 c9       	ld.ub	r9,r11[0x4]
8000639a:	b8 c9       	st.b	r12[0x4],r9
8000639c:	17 b9       	ld.ub	r9,r11[0x3]
8000639e:	b8 b9       	st.b	r12[0x3],r9
800063a0:	17 a9       	ld.ub	r9,r11[0x2]
800063a2:	b8 a9       	st.b	r12[0x2],r9
800063a4:	17 99       	ld.ub	r9,r11[0x1]
800063a6:	b8 99       	st.b	r12[0x1],r9
800063a8:	17 89       	ld.ub	r9,r11[0x0]
800063aa:	b8 89       	st.b	r12[0x0],r9
800063ac:	5e fc       	retal	r12
800063ae:	eb cd 40 c0 	pushm	r6-r7,lr
800063b2:	18 99       	mov	r9,r12
800063b4:	22 0a       	sub	r10,32
800063b6:	b7 07       	ld.d	r6,r11++
800063b8:	b3 26       	st.d	r9++,r6
800063ba:	b7 07       	ld.d	r6,r11++
800063bc:	b3 26       	st.d	r9++,r6
800063be:	b7 07       	ld.d	r6,r11++
800063c0:	b3 26       	st.d	r9++,r6
800063c2:	b7 07       	ld.d	r6,r11++
800063c4:	b3 26       	st.d	r9++,r6
800063c6:	22 0a       	sub	r10,32
800063c8:	cf 74       	brge	800063b6 <memcpy+0x92>
800063ca:	2f 0a       	sub	r10,-16
800063cc:	c0 65       	brlt	800063d8 <memcpy+0xb4>
800063ce:	b7 07       	ld.d	r6,r11++
800063d0:	b3 26       	st.d	r9++,r6
800063d2:	b7 07       	ld.d	r6,r11++
800063d4:	b3 26       	st.d	r9++,r6
800063d6:	21 0a       	sub	r10,16
800063d8:	5c 3a       	neg	r10
800063da:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800063de:	d7 03       	nop
800063e0:	d7 03       	nop
800063e2:	f7 36 00 0e 	ld.ub	r6,r11[14]
800063e6:	f3 66 00 0e 	st.b	r9[14],r6
800063ea:	f7 36 00 0d 	ld.ub	r6,r11[13]
800063ee:	f3 66 00 0d 	st.b	r9[13],r6
800063f2:	f7 36 00 0c 	ld.ub	r6,r11[12]
800063f6:	f3 66 00 0c 	st.b	r9[12],r6
800063fa:	f7 36 00 0b 	ld.ub	r6,r11[11]
800063fe:	f3 66 00 0b 	st.b	r9[11],r6
80006402:	f7 36 00 0a 	ld.ub	r6,r11[10]
80006406:	f3 66 00 0a 	st.b	r9[10],r6
8000640a:	f7 36 00 09 	ld.ub	r6,r11[9]
8000640e:	f3 66 00 09 	st.b	r9[9],r6
80006412:	f7 36 00 08 	ld.ub	r6,r11[8]
80006416:	f3 66 00 08 	st.b	r9[8],r6
8000641a:	f7 36 00 07 	ld.ub	r6,r11[7]
8000641e:	f3 66 00 07 	st.b	r9[7],r6
80006422:	f7 36 00 06 	ld.ub	r6,r11[6]
80006426:	f3 66 00 06 	st.b	r9[6],r6
8000642a:	f7 36 00 05 	ld.ub	r6,r11[5]
8000642e:	f3 66 00 05 	st.b	r9[5],r6
80006432:	f7 36 00 04 	ld.ub	r6,r11[4]
80006436:	f3 66 00 04 	st.b	r9[4],r6
8000643a:	f7 36 00 03 	ld.ub	r6,r11[3]
8000643e:	f3 66 00 03 	st.b	r9[3],r6
80006442:	f7 36 00 02 	ld.ub	r6,r11[2]
80006446:	f3 66 00 02 	st.b	r9[2],r6
8000644a:	f7 36 00 01 	ld.ub	r6,r11[1]
8000644e:	f3 66 00 01 	st.b	r9[1],r6
80006452:	f7 36 00 00 	ld.ub	r6,r11[0]
80006456:	f3 66 00 00 	st.b	r9[0],r6
8000645a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000645e:	20 1a       	sub	r10,1
80006460:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006464:	f8 0a 0b 09 	st.b	r12[r10],r9
80006468:	cf b1       	brne	8000645e <memcpy+0x13a>
8000646a:	5e fc       	retal	r12

8000646c <memset>:
8000646c:	18 98       	mov	r8,r12
8000646e:	c0 38       	rjmp	80006474 <memset+0x8>
80006470:	10 cb       	st.b	r8++,r11
80006472:	20 1a       	sub	r10,1
80006474:	58 0a       	cp.w	r10,0
80006476:	cf d1       	brne	80006470 <memset+0x4>
80006478:	5e fc       	retal	r12
8000647a:	d7 03       	nop

8000647c <_realloc_r>:
8000647c:	d4 31       	pushm	r0-r7,lr
8000647e:	20 1d       	sub	sp,4
80006480:	16 94       	mov	r4,r11
80006482:	18 92       	mov	r2,r12
80006484:	14 9b       	mov	r11,r10
80006486:	58 04       	cp.w	r4,0
80006488:	c0 51       	brne	80006492 <_realloc_r+0x16>
8000648a:	fe b0 fd 31 	rcall	80005eec <_malloc_r>
8000648e:	18 95       	mov	r5,r12
80006490:	c5 39       	rjmp	80006736 <_realloc_r+0x2ba>
80006492:	50 0a       	stdsp	sp[0x0],r10
80006494:	fe b0 f2 98 	rcall	800049c4 <__malloc_lock>
80006498:	40 0b       	lddsp	r11,sp[0x0]
8000649a:	f6 c8 ff f5 	sub	r8,r11,-11
8000649e:	e8 c1 00 08 	sub	r1,r4,8
800064a2:	10 96       	mov	r6,r8
800064a4:	62 1c       	ld.w	r12,r1[0x4]
800064a6:	e0 16 ff f8 	andl	r6,0xfff8
800064aa:	59 68       	cp.w	r8,22
800064ac:	f9 b6 08 10 	movls	r6,16
800064b0:	16 36       	cp.w	r6,r11
800064b2:	5f 38       	srlo	r8
800064b4:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800064b8:	c0 50       	breq	800064c2 <_realloc_r+0x46>
800064ba:	30 c8       	mov	r8,12
800064bc:	30 05       	mov	r5,0
800064be:	85 38       	st.w	r2[0xc],r8
800064c0:	c3 b9       	rjmp	80006736 <_realloc_r+0x2ba>
800064c2:	18 90       	mov	r0,r12
800064c4:	e0 10 ff fc 	andl	r0,0xfffc
800064c8:	0c 30       	cp.w	r0,r6
800064ca:	e0 84 01 0b 	brge	800066e0 <_realloc_r+0x264>
800064ce:	e0 68 05 38 	mov	r8,1336
800064d2:	e2 00 00 09 	add	r9,r1,r0
800064d6:	70 25       	ld.w	r5,r8[0x8]
800064d8:	0a 39       	cp.w	r9,r5
800064da:	c0 90       	breq	800064ec <_realloc_r+0x70>
800064dc:	72 1a       	ld.w	r10,r9[0x4]
800064de:	a1 ca       	cbr	r10,0x0
800064e0:	f2 0a 00 0a 	add	r10,r9,r10
800064e4:	74 1a       	ld.w	r10,r10[0x4]
800064e6:	ed ba 00 00 	bld	r10,0x0
800064ea:	c2 20       	breq	8000652e <_realloc_r+0xb2>
800064ec:	72 1a       	ld.w	r10,r9[0x4]
800064ee:	e0 1a ff fc 	andl	r10,0xfffc
800064f2:	f4 00 00 03 	add	r3,r10,r0
800064f6:	0a 39       	cp.w	r9,r5
800064f8:	c1 31       	brne	8000651e <_realloc_r+0xa2>
800064fa:	ec c7 ff f0 	sub	r7,r6,-16
800064fe:	0e 33       	cp.w	r3,r7
80006500:	c1 95       	brlt	80006532 <_realloc_r+0xb6>
80006502:	e2 06 00 09 	add	r9,r1,r6
80006506:	0c 13       	sub	r3,r6
80006508:	a1 a3       	sbr	r3,0x0
8000650a:	93 13       	st.w	r9[0x4],r3
8000650c:	91 29       	st.w	r8[0x8],r9
8000650e:	04 9c       	mov	r12,r2
80006510:	62 18       	ld.w	r8,r1[0x4]
80006512:	08 95       	mov	r5,r4
80006514:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006518:	10 46       	or	r6,r8
8000651a:	83 16       	st.w	r1[0x4],r6
8000651c:	c0 b9       	rjmp	80006732 <_realloc_r+0x2b6>
8000651e:	0c 33       	cp.w	r3,r6
80006520:	c0 95       	brlt	80006532 <_realloc_r+0xb6>
80006522:	72 28       	ld.w	r8,r9[0x8]
80006524:	02 97       	mov	r7,r1
80006526:	72 39       	ld.w	r9,r9[0xc]
80006528:	93 28       	st.w	r9[0x8],r8
8000652a:	91 39       	st.w	r8[0xc],r9
8000652c:	cd c8       	rjmp	800066e4 <_realloc_r+0x268>
8000652e:	30 0a       	mov	r10,0
80006530:	14 99       	mov	r9,r10
80006532:	ed bc 00 00 	bld	r12,0x0
80006536:	e0 80 00 95 	breq	80006660 <_realloc_r+0x1e4>
8000653a:	62 07       	ld.w	r7,r1[0x0]
8000653c:	e2 07 01 07 	sub	r7,r1,r7
80006540:	6e 1c       	ld.w	r12,r7[0x4]
80006542:	e0 1c ff fc 	andl	r12,0xfffc
80006546:	58 09       	cp.w	r9,0
80006548:	c5 60       	breq	800065f4 <_realloc_r+0x178>
8000654a:	f8 00 00 03 	add	r3,r12,r0
8000654e:	0a 39       	cp.w	r9,r5
80006550:	c4 81       	brne	800065e0 <_realloc_r+0x164>
80006552:	14 03       	add	r3,r10
80006554:	ec c9 ff f0 	sub	r9,r6,-16
80006558:	12 33       	cp.w	r3,r9
8000655a:	c4 d5       	brlt	800065f4 <_realloc_r+0x178>
8000655c:	6e 3a       	ld.w	r10,r7[0xc]
8000655e:	6e 29       	ld.w	r9,r7[0x8]
80006560:	95 29       	st.w	r10[0x8],r9
80006562:	93 3a       	st.w	r9[0xc],r10
80006564:	ee c5 ff f8 	sub	r5,r7,-8
80006568:	e0 ca 00 04 	sub	r10,r0,4
8000656c:	e0 4a 00 24 	cp.w	r10,36
80006570:	e0 8b 00 25 	brhi	800065ba <_realloc_r+0x13e>
80006574:	0a 99       	mov	r9,r5
80006576:	59 3a       	cp.w	r10,19
80006578:	e0 88 00 1a 	brls	800065ac <_realloc_r+0x130>
8000657c:	09 09       	ld.w	r9,r4++
8000657e:	8b 09       	st.w	r5[0x0],r9
80006580:	09 09       	ld.w	r9,r4++
80006582:	8f 39       	st.w	r7[0xc],r9
80006584:	ee c9 ff f0 	sub	r9,r7,-16
80006588:	59 ba       	cp.w	r10,27
8000658a:	e0 88 00 11 	brls	800065ac <_realloc_r+0x130>
8000658e:	09 0b       	ld.w	r11,r4++
80006590:	93 0b       	st.w	r9[0x0],r11
80006592:	09 09       	ld.w	r9,r4++
80006594:	8f 59       	st.w	r7[0x14],r9
80006596:	ee c9 ff e8 	sub	r9,r7,-24
8000659a:	e0 4a 00 24 	cp.w	r10,36
8000659e:	c0 71       	brne	800065ac <_realloc_r+0x130>
800065a0:	09 0a       	ld.w	r10,r4++
800065a2:	93 0a       	st.w	r9[0x0],r10
800065a4:	ee c9 ff e0 	sub	r9,r7,-32
800065a8:	09 0a       	ld.w	r10,r4++
800065aa:	8f 7a       	st.w	r7[0x1c],r10
800065ac:	09 0a       	ld.w	r10,r4++
800065ae:	12 aa       	st.w	r9++,r10
800065b0:	68 0a       	ld.w	r10,r4[0x0]
800065b2:	93 0a       	st.w	r9[0x0],r10
800065b4:	68 1a       	ld.w	r10,r4[0x4]
800065b6:	93 1a       	st.w	r9[0x4],r10
800065b8:	c0 78       	rjmp	800065c6 <_realloc_r+0x14a>
800065ba:	50 08       	stdsp	sp[0x0],r8
800065bc:	08 9b       	mov	r11,r4
800065be:	0a 9c       	mov	r12,r5
800065c0:	e0 a0 1d 9b 	rcall	8000a0f6 <memmove>
800065c4:	40 08       	lddsp	r8,sp[0x0]
800065c6:	ee 06 00 09 	add	r9,r7,r6
800065ca:	0c 13       	sub	r3,r6
800065cc:	a1 a3       	sbr	r3,0x0
800065ce:	93 13       	st.w	r9[0x4],r3
800065d0:	91 29       	st.w	r8[0x8],r9
800065d2:	04 9c       	mov	r12,r2
800065d4:	6e 18       	ld.w	r8,r7[0x4]
800065d6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800065da:	10 46       	or	r6,r8
800065dc:	8f 16       	st.w	r7[0x4],r6
800065de:	ca a8       	rjmp	80006732 <_realloc_r+0x2b6>
800065e0:	14 03       	add	r3,r10
800065e2:	0c 33       	cp.w	r3,r6
800065e4:	c0 85       	brlt	800065f4 <_realloc_r+0x178>
800065e6:	72 28       	ld.w	r8,r9[0x8]
800065e8:	72 39       	ld.w	r9,r9[0xc]
800065ea:	93 28       	st.w	r9[0x8],r8
800065ec:	91 39       	st.w	r8[0xc],r9
800065ee:	6e 28       	ld.w	r8,r7[0x8]
800065f0:	6e 39       	ld.w	r9,r7[0xc]
800065f2:	c0 78       	rjmp	80006600 <_realloc_r+0x184>
800065f4:	f8 00 00 03 	add	r3,r12,r0
800065f8:	0c 33       	cp.w	r3,r6
800065fa:	c3 35       	brlt	80006660 <_realloc_r+0x1e4>
800065fc:	6e 39       	ld.w	r9,r7[0xc]
800065fe:	6e 28       	ld.w	r8,r7[0x8]
80006600:	93 28       	st.w	r9[0x8],r8
80006602:	91 39       	st.w	r8[0xc],r9
80006604:	e0 ca 00 04 	sub	r10,r0,4
80006608:	ee cc ff f8 	sub	r12,r7,-8
8000660c:	e0 4a 00 24 	cp.w	r10,36
80006610:	e0 8b 00 24 	brhi	80006658 <_realloc_r+0x1dc>
80006614:	59 3a       	cp.w	r10,19
80006616:	e0 88 00 1a 	brls	8000664a <_realloc_r+0x1ce>
8000661a:	09 08       	ld.w	r8,r4++
8000661c:	99 08       	st.w	r12[0x0],r8
8000661e:	09 08       	ld.w	r8,r4++
80006620:	8f 38       	st.w	r7[0xc],r8
80006622:	ee cc ff f0 	sub	r12,r7,-16
80006626:	59 ba       	cp.w	r10,27
80006628:	e0 88 00 11 	brls	8000664a <_realloc_r+0x1ce>
8000662c:	09 08       	ld.w	r8,r4++
8000662e:	99 08       	st.w	r12[0x0],r8
80006630:	09 08       	ld.w	r8,r4++
80006632:	8f 58       	st.w	r7[0x14],r8
80006634:	ee cc ff e8 	sub	r12,r7,-24
80006638:	e0 4a 00 24 	cp.w	r10,36
8000663c:	c0 71       	brne	8000664a <_realloc_r+0x1ce>
8000663e:	09 08       	ld.w	r8,r4++
80006640:	99 08       	st.w	r12[0x0],r8
80006642:	ee cc ff e0 	sub	r12,r7,-32
80006646:	09 08       	ld.w	r8,r4++
80006648:	8f 78       	st.w	r7[0x1c],r8
8000664a:	09 08       	ld.w	r8,r4++
8000664c:	18 a8       	st.w	r12++,r8
8000664e:	68 08       	ld.w	r8,r4[0x0]
80006650:	99 08       	st.w	r12[0x0],r8
80006652:	68 18       	ld.w	r8,r4[0x4]
80006654:	99 18       	st.w	r12[0x4],r8
80006656:	c4 78       	rjmp	800066e4 <_realloc_r+0x268>
80006658:	08 9b       	mov	r11,r4
8000665a:	e0 a0 1d 4e 	rcall	8000a0f6 <memmove>
8000665e:	c4 38       	rjmp	800066e4 <_realloc_r+0x268>
80006660:	04 9c       	mov	r12,r2
80006662:	fe b0 fc 45 	rcall	80005eec <_malloc_r>
80006666:	18 95       	mov	r5,r12
80006668:	c3 a0       	breq	800066dc <_realloc_r+0x260>
8000666a:	62 18       	ld.w	r8,r1[0x4]
8000666c:	f8 c9 00 08 	sub	r9,r12,8
80006670:	a1 c8       	cbr	r8,0x0
80006672:	e2 08 00 08 	add	r8,r1,r8
80006676:	10 39       	cp.w	r9,r8
80006678:	c0 71       	brne	80006686 <_realloc_r+0x20a>
8000667a:	72 13       	ld.w	r3,r9[0x4]
8000667c:	02 97       	mov	r7,r1
8000667e:	e0 13 ff fc 	andl	r3,0xfffc
80006682:	00 03       	add	r3,r0
80006684:	c3 08       	rjmp	800066e4 <_realloc_r+0x268>
80006686:	e0 ca 00 04 	sub	r10,r0,4
8000668a:	e0 4a 00 24 	cp.w	r10,36
8000668e:	e0 8b 00 20 	brhi	800066ce <_realloc_r+0x252>
80006692:	08 99       	mov	r9,r4
80006694:	18 98       	mov	r8,r12
80006696:	59 3a       	cp.w	r10,19
80006698:	e0 88 00 14 	brls	800066c0 <_realloc_r+0x244>
8000669c:	13 0b       	ld.w	r11,r9++
8000669e:	10 ab       	st.w	r8++,r11
800066a0:	13 0b       	ld.w	r11,r9++
800066a2:	10 ab       	st.w	r8++,r11
800066a4:	59 ba       	cp.w	r10,27
800066a6:	e0 88 00 0d 	brls	800066c0 <_realloc_r+0x244>
800066aa:	13 0b       	ld.w	r11,r9++
800066ac:	10 ab       	st.w	r8++,r11
800066ae:	13 0b       	ld.w	r11,r9++
800066b0:	10 ab       	st.w	r8++,r11
800066b2:	e0 4a 00 24 	cp.w	r10,36
800066b6:	c0 51       	brne	800066c0 <_realloc_r+0x244>
800066b8:	13 0a       	ld.w	r10,r9++
800066ba:	10 aa       	st.w	r8++,r10
800066bc:	13 0a       	ld.w	r10,r9++
800066be:	10 aa       	st.w	r8++,r10
800066c0:	13 0a       	ld.w	r10,r9++
800066c2:	10 aa       	st.w	r8++,r10
800066c4:	72 0a       	ld.w	r10,r9[0x0]
800066c6:	91 0a       	st.w	r8[0x0],r10
800066c8:	72 19       	ld.w	r9,r9[0x4]
800066ca:	91 19       	st.w	r8[0x4],r9
800066cc:	c0 48       	rjmp	800066d4 <_realloc_r+0x258>
800066ce:	08 9b       	mov	r11,r4
800066d0:	e0 a0 1d 13 	rcall	8000a0f6 <memmove>
800066d4:	08 9b       	mov	r11,r4
800066d6:	04 9c       	mov	r12,r2
800066d8:	e0 a0 1a 6c 	rcall	80009bb0 <_free_r>
800066dc:	04 9c       	mov	r12,r2
800066de:	c2 a8       	rjmp	80006732 <_realloc_r+0x2b6>
800066e0:	00 93       	mov	r3,r0
800066e2:	02 97       	mov	r7,r1
800066e4:	e6 06 01 09 	sub	r9,r3,r6
800066e8:	6e 18       	ld.w	r8,r7[0x4]
800066ea:	58 f9       	cp.w	r9,15
800066ec:	e0 88 00 16 	brls	80006718 <_realloc_r+0x29c>
800066f0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800066f4:	ed e8 10 08 	or	r8,r6,r8
800066f8:	8f 18       	st.w	r7[0x4],r8
800066fa:	12 98       	mov	r8,r9
800066fc:	a1 a8       	sbr	r8,0x0
800066fe:	ee 06 00 0b 	add	r11,r7,r6
80006702:	f6 09 00 09 	add	r9,r11,r9
80006706:	97 18       	st.w	r11[0x4],r8
80006708:	72 18       	ld.w	r8,r9[0x4]
8000670a:	a1 a8       	sbr	r8,0x0
8000670c:	2f 8b       	sub	r11,-8
8000670e:	93 18       	st.w	r9[0x4],r8
80006710:	04 9c       	mov	r12,r2
80006712:	e0 a0 1a 4f 	rcall	80009bb0 <_free_r>
80006716:	c0 b8       	rjmp	8000672c <_realloc_r+0x2b0>
80006718:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000671c:	e7 e8 10 08 	or	r8,r3,r8
80006720:	8f 18       	st.w	r7[0x4],r8
80006722:	ee 03 00 03 	add	r3,r7,r3
80006726:	66 18       	ld.w	r8,r3[0x4]
80006728:	a1 a8       	sbr	r8,0x0
8000672a:	87 18       	st.w	r3[0x4],r8
8000672c:	04 9c       	mov	r12,r2
8000672e:	ee c5 ff f8 	sub	r5,r7,-8
80006732:	fe b0 f1 4f 	rcall	800049d0 <__malloc_unlock>
80006736:	0a 9c       	mov	r12,r5
80006738:	2f fd       	sub	sp,-4
8000673a:	d8 32       	popm	r0-r7,pc

8000673c <_sbrk_r>:
8000673c:	d4 21       	pushm	r4-r7,lr
8000673e:	30 08       	mov	r8,0
80006740:	18 97       	mov	r7,r12
80006742:	e0 66 3f e8 	mov	r6,16360
80006746:	16 9c       	mov	r12,r11
80006748:	8d 08       	st.w	r6[0x0],r8
8000674a:	c9 1c       	rcall	8000686c <_sbrk>
8000674c:	5b fc       	cp.w	r12,-1
8000674e:	c0 51       	brne	80006758 <_sbrk_r+0x1c>
80006750:	6c 08       	ld.w	r8,r6[0x0]
80006752:	58 08       	cp.w	r8,0
80006754:	ef f8 1a 03 	st.wne	r7[0xc],r8
80006758:	d8 22       	popm	r4-r7,pc
8000675a:	d7 03       	nop

8000675c <sprintf>:
8000675c:	d4 01       	pushm	lr
8000675e:	21 7d       	sub	sp,92
80006760:	e0 68 ff ff 	mov	r8,65535
80006764:	ea 18 7f ff 	orh	r8,0x7fff
80006768:	50 58       	stdsp	sp[0x14],r8
8000676a:	50 28       	stdsp	sp[0x8],r8
8000676c:	e0 68 02 08 	mov	r8,520
80006770:	ba 68       	st.h	sp[0xc],r8
80006772:	3f f8       	mov	r8,-1
80006774:	ba 78       	st.h	sp[0xe],r8
80006776:	e0 68 0a 38 	mov	r8,2616
8000677a:	50 4c       	stdsp	sp[0x10],r12
8000677c:	16 9a       	mov	r10,r11
8000677e:	50 0c       	stdsp	sp[0x0],r12
80006780:	fa c9 ff a0 	sub	r9,sp,-96
80006784:	70 0c       	ld.w	r12,r8[0x0]
80006786:	1a 9b       	mov	r11,sp
80006788:	e0 a0 02 26 	rcall	80006bd4 <_vfprintf_r>
8000678c:	30 09       	mov	r9,0
8000678e:	40 08       	lddsp	r8,sp[0x0]
80006790:	b0 89       	st.b	r8[0x0],r9
80006792:	2e 9d       	sub	sp,-92
80006794:	d8 02       	popm	pc
80006796:	d7 03       	nop

80006798 <strlen>:
80006798:	30 09       	mov	r9,0
8000679a:	18 98       	mov	r8,r12
8000679c:	c0 28       	rjmp	800067a0 <strlen+0x8>
8000679e:	2f f8       	sub	r8,-1
800067a0:	11 8a       	ld.ub	r10,r8[0x0]
800067a2:	f2 0a 18 00 	cp.b	r10,r9
800067a6:	cf c1       	brne	8000679e <strlen+0x6>
800067a8:	f0 0c 01 0c 	sub	r12,r8,r12
800067ac:	5e fc       	retal	r12
800067ae:	d7 03       	nop

800067b0 <strncpy>:
800067b0:	30 08       	mov	r8,0
800067b2:	10 3a       	cp.w	r10,r8
800067b4:	5e 0c       	reteq	r12
800067b6:	f6 08 07 09 	ld.ub	r9,r11[r8]
800067ba:	f8 08 0b 09 	st.b	r12[r8],r9
800067be:	2f f8       	sub	r8,-1
800067c0:	58 09       	cp.w	r9,0
800067c2:	cf 81       	brne	800067b2 <strncpy+0x2>
800067c4:	10 3a       	cp.w	r10,r8
800067c6:	5e 0c       	reteq	r12
800067c8:	f8 08 0b 09 	st.b	r12[r8],r9
800067cc:	2f f8       	sub	r8,-1
800067ce:	cf bb       	rjmp	800067c4 <strncpy+0x14>

800067d0 <_close>:
800067d0:	30 28       	mov	r8,2
800067d2:	d6 73       	breakpoint
800067d4:	3f fc       	mov	r12,-1
800067d6:	35 8b       	mov	r11,88
800067d8:	58 0c       	cp.w	r12,0
800067da:	5e 4c       	retge	r12
800067dc:	e0 6a 3f e8 	mov	r10,16360
800067e0:	95 0b       	st.w	r10[0x0],r11
800067e2:	5e fc       	retal	r12

800067e4 <_lseek>:
800067e4:	30 58       	mov	r8,5
800067e6:	d6 73       	breakpoint
800067e8:	3f fc       	mov	r12,-1
800067ea:	35 8b       	mov	r11,88
800067ec:	58 0c       	cp.w	r12,0
800067ee:	5e 4c       	retge	r12
800067f0:	e0 6a 3f e8 	mov	r10,16360
800067f4:	95 0b       	st.w	r10[0x0],r11
800067f6:	5e fc       	retal	r12

800067f8 <isatty>:
800067f8:	30 b8       	mov	r8,11
800067fa:	d6 73       	breakpoint
800067fc:	3f fc       	mov	r12,-1
800067fe:	35 8b       	mov	r11,88
80006800:	58 0c       	cp.w	r12,0
80006802:	5e 4c       	retge	r12
80006804:	e0 6a 3f e8 	mov	r10,16360
80006808:	95 0b       	st.w	r10[0x0],r11
8000680a:	5e fc       	retal	r12

8000680c <_fstat_host>:
8000680c:	30 98       	mov	r8,9
8000680e:	d6 73       	breakpoint
80006810:	3f fc       	mov	r12,-1
80006812:	35 8b       	mov	r11,88
80006814:	58 0c       	cp.w	r12,0
80006816:	5e 4c       	retge	r12
80006818:	e0 6a 3f e8 	mov	r10,16360
8000681c:	95 0b       	st.w	r10[0x0],r11
8000681e:	5e fc       	retal	r12

80006820 <_fstat>:
80006820:	d4 21       	pushm	r4-r7,lr
80006822:	21 0d       	sub	sp,64
80006824:	16 97       	mov	r7,r11
80006826:	1a 9b       	mov	r11,sp
80006828:	cf 2f       	rcall	8000680c <_fstat_host>
8000682a:	c0 34       	brge	80006830 <_fstat+0x10>
8000682c:	3f fc       	mov	r12,-1
8000682e:	c1 c8       	rjmp	80006866 <_fstat+0x46>
80006830:	40 08       	lddsp	r8,sp[0x0]
80006832:	ae 08       	st.h	r7[0x0],r8
80006834:	40 18       	lddsp	r8,sp[0x4]
80006836:	ae 18       	st.h	r7[0x2],r8
80006838:	40 28       	lddsp	r8,sp[0x8]
8000683a:	8f 18       	st.w	r7[0x4],r8
8000683c:	40 38       	lddsp	r8,sp[0xc]
8000683e:	ae 48       	st.h	r7[0x8],r8
80006840:	40 48       	lddsp	r8,sp[0x10]
80006842:	ae 58       	st.h	r7[0xa],r8
80006844:	40 58       	lddsp	r8,sp[0x14]
80006846:	ae 68       	st.h	r7[0xc],r8
80006848:	40 68       	lddsp	r8,sp[0x18]
8000684a:	ae 78       	st.h	r7[0xe],r8
8000684c:	40 88       	lddsp	r8,sp[0x20]
8000684e:	8f 48       	st.w	r7[0x10],r8
80006850:	40 a8       	lddsp	r8,sp[0x28]
80006852:	8f b8       	st.w	r7[0x2c],r8
80006854:	40 c8       	lddsp	r8,sp[0x30]
80006856:	8f c8       	st.w	r7[0x30],r8
80006858:	40 d8       	lddsp	r8,sp[0x34]
8000685a:	8f 58       	st.w	r7[0x14],r8
8000685c:	40 e8       	lddsp	r8,sp[0x38]
8000685e:	30 0c       	mov	r12,0
80006860:	8f 78       	st.w	r7[0x1c],r8
80006862:	40 f8       	lddsp	r8,sp[0x3c]
80006864:	8f 98       	st.w	r7[0x24],r8
80006866:	2f 0d       	sub	sp,-64
80006868:	d8 22       	popm	r4-r7,pc
8000686a:	d7 03       	nop

8000686c <_sbrk>:
8000686c:	d4 01       	pushm	lr
8000686e:	e0 68 0d 88 	mov	r8,3464
80006872:	70 09       	ld.w	r9,r8[0x0]
80006874:	58 09       	cp.w	r9,0
80006876:	c0 41       	brne	8000687e <_sbrk+0x12>
80006878:	e0 69 3f f0 	mov	r9,16368
8000687c:	91 09       	st.w	r8[0x0],r9
8000687e:	e0 69 0d 88 	mov	r9,3464
80006882:	e0 7a 70 00 	mov	r10,94208
80006886:	72 08       	ld.w	r8,r9[0x0]
80006888:	f0 0c 00 0c 	add	r12,r8,r12
8000688c:	14 3c       	cp.w	r12,r10
8000688e:	e0 8b 00 04 	brhi	80006896 <_sbrk+0x2a>
80006892:	93 0c       	st.w	r9[0x0],r12
80006894:	c0 68       	rjmp	800068a0 <_sbrk+0x34>
80006896:	e0 a0 18 15 	rcall	800098c0 <__errno>
8000689a:	30 c8       	mov	r8,12
8000689c:	99 08       	st.w	r12[0x0],r8
8000689e:	3f f8       	mov	r8,-1
800068a0:	10 9c       	mov	r12,r8
800068a2:	d8 02       	popm	pc

800068a4 <get_arg>:
800068a4:	d4 31       	pushm	r0-r7,lr
800068a6:	20 8d       	sub	sp,32
800068a8:	fa c4 ff bc 	sub	r4,sp,-68
800068ac:	50 4b       	stdsp	sp[0x10],r11
800068ae:	68 2e       	ld.w	lr,r4[0x8]
800068b0:	50 58       	stdsp	sp[0x14],r8
800068b2:	12 96       	mov	r6,r9
800068b4:	7c 0b       	ld.w	r11,lr[0x0]
800068b6:	70 05       	ld.w	r5,r8[0x0]
800068b8:	50 6e       	stdsp	sp[0x18],lr
800068ba:	58 0b       	cp.w	r11,0
800068bc:	f4 0b 17 00 	moveq	r11,r10
800068c0:	68 03       	ld.w	r3,r4[0x0]
800068c2:	68 11       	ld.w	r1,r4[0x4]
800068c4:	40 49       	lddsp	r9,sp[0x10]
800068c6:	30 08       	mov	r8,0
800068c8:	c2 89       	rjmp	80006b18 <get_arg+0x274>
800068ca:	2f fb       	sub	r11,-1
800068cc:	32 5c       	mov	r12,37
800068ce:	17 8a       	ld.ub	r10,r11[0x0]
800068d0:	f8 0a 18 00 	cp.b	r10,r12
800068d4:	5f 1e       	srne	lr
800068d6:	f0 0a 18 00 	cp.b	r10,r8
800068da:	5f 1c       	srne	r12
800068dc:	fd ec 00 0c 	and	r12,lr,r12
800068e0:	f0 0c 18 00 	cp.b	r12,r8
800068e4:	cf 31       	brne	800068ca <get_arg+0x26>
800068e6:	58 0a       	cp.w	r10,0
800068e8:	e0 80 01 25 	breq	80006b32 <get_arg+0x28e>
800068ec:	30 0c       	mov	r12,0
800068ee:	3f fa       	mov	r10,-1
800068f0:	18 90       	mov	r0,r12
800068f2:	50 3a       	stdsp	sp[0xc],r10
800068f4:	18 94       	mov	r4,r12
800068f6:	18 92       	mov	r2,r12
800068f8:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
800068fc:	16 97       	mov	r7,r11
800068fe:	50 7c       	stdsp	sp[0x1c],r12
80006900:	fe cc a0 34 	sub	r12,pc,-24524
80006904:	0f 3a       	ld.ub	r10,r7++
80006906:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000690a:	40 7c       	lddsp	r12,sp[0x1c]
8000690c:	1c 0c       	add	r12,lr
8000690e:	fe ce a1 0a 	sub	lr,pc,-24310
80006912:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80006916:	20 1e       	sub	lr,1
80006918:	50 0e       	stdsp	sp[0x0],lr
8000691a:	fe ce a1 82 	sub	lr,pc,-24190
8000691e:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80006922:	50 7c       	stdsp	sp[0x1c],r12
80006924:	40 0c       	lddsp	r12,sp[0x0]
80006926:	58 7c       	cp.w	r12,7
80006928:	e0 8b 00 f1 	brhi	80006b0a <get_arg+0x266>
8000692c:	fe ce a3 34 	sub	lr,pc,-23756
80006930:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80006934:	36 8b       	mov	r11,104
80006936:	f6 0a 18 00 	cp.b	r10,r11
8000693a:	e0 80 00 e8 	breq	80006b0a <get_arg+0x266>
8000693e:	37 1b       	mov	r11,113
80006940:	f6 0a 18 00 	cp.b	r10,r11
80006944:	c0 70       	breq	80006952 <get_arg+0xae>
80006946:	34 cb       	mov	r11,76
80006948:	f6 0a 18 00 	cp.b	r10,r11
8000694c:	c0 51       	brne	80006956 <get_arg+0xb2>
8000694e:	a3 b4       	sbr	r4,0x3
80006950:	cd d8       	rjmp	80006b0a <get_arg+0x266>
80006952:	a5 b4       	sbr	r4,0x5
80006954:	cd b8       	rjmp	80006b0a <get_arg+0x266>
80006956:	08 9a       	mov	r10,r4
80006958:	0e 9b       	mov	r11,r7
8000695a:	a5 aa       	sbr	r10,0x4
8000695c:	17 3c       	ld.ub	r12,r11++
8000695e:	a5 b4       	sbr	r4,0x5
80006960:	36 ce       	mov	lr,108
80006962:	fc 0c 18 00 	cp.b	r12,lr
80006966:	e0 80 00 d3 	breq	80006b0c <get_arg+0x268>
8000696a:	14 94       	mov	r4,r10
8000696c:	cc f8       	rjmp	80006b0a <get_arg+0x266>
8000696e:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80006972:	36 7c       	mov	r12,103
80006974:	f8 0a 18 00 	cp.b	r10,r12
80006978:	e0 8b 00 27 	brhi	800069c6 <get_arg+0x122>
8000697c:	36 5b       	mov	r11,101
8000697e:	f6 0a 18 00 	cp.b	r10,r11
80006982:	c4 82       	brcc	80006a12 <get_arg+0x16e>
80006984:	34 fb       	mov	r11,79
80006986:	f6 0a 18 00 	cp.b	r10,r11
8000698a:	c4 80       	breq	80006a1a <get_arg+0x176>
8000698c:	e0 8b 00 0c 	brhi	800069a4 <get_arg+0x100>
80006990:	34 5b       	mov	r11,69
80006992:	f6 0a 18 00 	cp.b	r10,r11
80006996:	c3 e0       	breq	80006a12 <get_arg+0x16e>
80006998:	34 7b       	mov	r11,71
8000699a:	f6 0a 18 00 	cp.b	r10,r11
8000699e:	c3 a0       	breq	80006a12 <get_arg+0x16e>
800069a0:	34 4b       	mov	r11,68
800069a2:	c0 88       	rjmp	800069b2 <get_arg+0x10e>
800069a4:	35 8b       	mov	r11,88
800069a6:	f6 0a 18 00 	cp.b	r10,r11
800069aa:	c2 c0       	breq	80006a02 <get_arg+0x15e>
800069ac:	e0 8b 00 07 	brhi	800069ba <get_arg+0x116>
800069b0:	35 5b       	mov	r11,85
800069b2:	f6 0a 18 00 	cp.b	r10,r11
800069b6:	c3 51       	brne	80006a20 <get_arg+0x17c>
800069b8:	c3 18       	rjmp	80006a1a <get_arg+0x176>
800069ba:	36 3b       	mov	r11,99
800069bc:	f6 0a 18 00 	cp.b	r10,r11
800069c0:	c2 f0       	breq	80006a1e <get_arg+0x17a>
800069c2:	36 4b       	mov	r11,100
800069c4:	c0 e8       	rjmp	800069e0 <get_arg+0x13c>
800069c6:	37 0b       	mov	r11,112
800069c8:	f6 0a 18 00 	cp.b	r10,r11
800069cc:	c2 50       	breq	80006a16 <get_arg+0x172>
800069ce:	e0 8b 00 0d 	brhi	800069e8 <get_arg+0x144>
800069d2:	36 eb       	mov	r11,110
800069d4:	f6 0a 18 00 	cp.b	r10,r11
800069d8:	c1 f0       	breq	80006a16 <get_arg+0x172>
800069da:	e0 8b 00 14 	brhi	80006a02 <get_arg+0x15e>
800069de:	36 9b       	mov	r11,105
800069e0:	f6 0a 18 00 	cp.b	r10,r11
800069e4:	c1 e1       	brne	80006a20 <get_arg+0x17c>
800069e6:	c0 e8       	rjmp	80006a02 <get_arg+0x15e>
800069e8:	37 5b       	mov	r11,117
800069ea:	f6 0a 18 00 	cp.b	r10,r11
800069ee:	c0 a0       	breq	80006a02 <get_arg+0x15e>
800069f0:	37 8b       	mov	r11,120
800069f2:	f6 0a 18 00 	cp.b	r10,r11
800069f6:	c0 60       	breq	80006a02 <get_arg+0x15e>
800069f8:	37 3b       	mov	r11,115
800069fa:	f6 0a 18 00 	cp.b	r10,r11
800069fe:	c1 11       	brne	80006a20 <get_arg+0x17c>
80006a00:	c0 b8       	rjmp	80006a16 <get_arg+0x172>
80006a02:	ed b4 00 04 	bld	r4,0x4
80006a06:	c0 a0       	breq	80006a1a <get_arg+0x176>
80006a08:	ed b4 00 05 	bld	r4,0x5
80006a0c:	c0 91       	brne	80006a1e <get_arg+0x17a>
80006a0e:	30 20       	mov	r0,2
80006a10:	c0 88       	rjmp	80006a20 <get_arg+0x17c>
80006a12:	30 40       	mov	r0,4
80006a14:	c0 68       	rjmp	80006a20 <get_arg+0x17c>
80006a16:	30 30       	mov	r0,3
80006a18:	c0 48       	rjmp	80006a20 <get_arg+0x17c>
80006a1a:	30 10       	mov	r0,1
80006a1c:	c0 28       	rjmp	80006a20 <get_arg+0x17c>
80006a1e:	30 00       	mov	r0,0
80006a20:	40 3b       	lddsp	r11,sp[0xc]
80006a22:	5b fb       	cp.w	r11,-1
80006a24:	c0 40       	breq	80006a2c <get_arg+0x188>
80006a26:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80006a2a:	c7 08       	rjmp	80006b0a <get_arg+0x266>
80006a2c:	58 60       	cp.w	r0,6
80006a2e:	e0 8b 00 6e 	brhi	80006b0a <get_arg+0x266>
80006a32:	6c 0a       	ld.w	r10,r6[0x0]
80006a34:	ea cc ff ff 	sub	r12,r5,-1
80006a38:	fe ce a4 20 	sub	lr,pc,-23520
80006a3c:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80006a40:	f4 cb ff f8 	sub	r11,r10,-8
80006a44:	8d 0b       	st.w	r6[0x0],r11
80006a46:	f4 ea 00 00 	ld.d	r10,r10[0]
80006a4a:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80006a4e:	c0 f8       	rjmp	80006a6c <get_arg+0x1c8>
80006a50:	f4 cb ff fc 	sub	r11,r10,-4
80006a54:	8d 0b       	st.w	r6[0x0],r11
80006a56:	74 0a       	ld.w	r10,r10[0x0]
80006a58:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80006a5c:	c0 88       	rjmp	80006a6c <get_arg+0x1c8>
80006a5e:	f4 cb ff f8 	sub	r11,r10,-8
80006a62:	8d 0b       	st.w	r6[0x0],r11
80006a64:	f4 ea 00 00 	ld.d	r10,r10[0]
80006a68:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80006a6c:	0e 9b       	mov	r11,r7
80006a6e:	18 95       	mov	r5,r12
80006a70:	c4 e8       	rjmp	80006b0c <get_arg+0x268>
80006a72:	62 0a       	ld.w	r10,r1[0x0]
80006a74:	5b fa       	cp.w	r10,-1
80006a76:	c0 b1       	brne	80006a8c <get_arg+0x1e8>
80006a78:	50 19       	stdsp	sp[0x4],r9
80006a7a:	50 28       	stdsp	sp[0x8],r8
80006a7c:	e0 6a 00 80 	mov	r10,128
80006a80:	30 0b       	mov	r11,0
80006a82:	02 9c       	mov	r12,r1
80006a84:	fe b0 fc f4 	rcall	8000646c <memset>
80006a88:	40 28       	lddsp	r8,sp[0x8]
80006a8a:	40 19       	lddsp	r9,sp[0x4]
80006a8c:	e4 cc 00 01 	sub	r12,r2,1
80006a90:	0e 9b       	mov	r11,r7
80006a92:	50 3c       	stdsp	sp[0xc],r12
80006a94:	f2 0c 0c 49 	max	r9,r9,r12
80006a98:	c3 a8       	rjmp	80006b0c <get_arg+0x268>
80006a9a:	62 0a       	ld.w	r10,r1[0x0]
80006a9c:	5b fa       	cp.w	r10,-1
80006a9e:	c0 b1       	brne	80006ab4 <get_arg+0x210>
80006aa0:	50 19       	stdsp	sp[0x4],r9
80006aa2:	50 28       	stdsp	sp[0x8],r8
80006aa4:	e0 6a 00 80 	mov	r10,128
80006aa8:	30 0b       	mov	r11,0
80006aaa:	02 9c       	mov	r12,r1
80006aac:	fe b0 fc e0 	rcall	8000646c <memset>
80006ab0:	40 28       	lddsp	r8,sp[0x8]
80006ab2:	40 19       	lddsp	r9,sp[0x4]
80006ab4:	20 12       	sub	r2,1
80006ab6:	30 0a       	mov	r10,0
80006ab8:	0e 9b       	mov	r11,r7
80006aba:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80006abe:	f2 02 0c 49 	max	r9,r9,r2
80006ac2:	c2 58       	rjmp	80006b0c <get_arg+0x268>
80006ac4:	16 97       	mov	r7,r11
80006ac6:	6c 0a       	ld.w	r10,r6[0x0]
80006ac8:	f4 cb ff fc 	sub	r11,r10,-4
80006acc:	8d 0b       	st.w	r6[0x0],r11
80006ace:	74 0a       	ld.w	r10,r10[0x0]
80006ad0:	0e 9b       	mov	r11,r7
80006ad2:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80006ad6:	2f f5       	sub	r5,-1
80006ad8:	c1 a8       	rjmp	80006b0c <get_arg+0x268>
80006ada:	f4 c2 00 30 	sub	r2,r10,48
80006ade:	c0 68       	rjmp	80006aea <get_arg+0x246>
80006ae0:	e4 02 00 22 	add	r2,r2,r2<<0x2
80006ae4:	2f f7       	sub	r7,-1
80006ae6:	f4 02 00 12 	add	r2,r10,r2<<0x1
80006aea:	0f 8a       	ld.ub	r10,r7[0x0]
80006aec:	58 0a       	cp.w	r10,0
80006aee:	c0 e0       	breq	80006b0a <get_arg+0x266>
80006af0:	23 0a       	sub	r10,48
80006af2:	58 9a       	cp.w	r10,9
80006af4:	fe 98 ff f6 	brls	80006ae0 <get_arg+0x23c>
80006af8:	c0 98       	rjmp	80006b0a <get_arg+0x266>
80006afa:	2f f7       	sub	r7,-1
80006afc:	0f 8a       	ld.ub	r10,r7[0x0]
80006afe:	58 0a       	cp.w	r10,0
80006b00:	c0 50       	breq	80006b0a <get_arg+0x266>
80006b02:	23 0a       	sub	r10,48
80006b04:	58 9a       	cp.w	r10,9
80006b06:	fe 98 ff fa 	brls	80006afa <get_arg+0x256>
80006b0a:	0e 9b       	mov	r11,r7
80006b0c:	40 7c       	lddsp	r12,sp[0x1c]
80006b0e:	30 ba       	mov	r10,11
80006b10:	f4 0c 18 00 	cp.b	r12,r10
80006b14:	fe 91 fe f2 	brne	800068f8 <get_arg+0x54>
80006b18:	40 42       	lddsp	r2,sp[0x10]
80006b1a:	17 8c       	ld.ub	r12,r11[0x0]
80006b1c:	0a 32       	cp.w	r2,r5
80006b1e:	5f 4a       	srge	r10
80006b20:	f0 0c 18 00 	cp.b	r12,r8
80006b24:	5f 1c       	srne	r12
80006b26:	f9 ea 00 0a 	and	r10,r12,r10
80006b2a:	f0 0a 18 00 	cp.b	r10,r8
80006b2e:	fe 91 fe cf 	brne	800068cc <get_arg+0x28>
80006b32:	30 08       	mov	r8,0
80006b34:	40 4e       	lddsp	lr,sp[0x10]
80006b36:	17 8a       	ld.ub	r10,r11[0x0]
80006b38:	e2 05 00 21 	add	r1,r1,r5<<0x2
80006b3c:	f0 0a 18 00 	cp.b	r10,r8
80006b40:	fc 09 17 10 	movne	r9,lr
80006b44:	e6 05 00 38 	add	r8,r3,r5<<0x3
80006b48:	06 9e       	mov	lr,r3
80006b4a:	c2 a8       	rjmp	80006b9e <get_arg+0x2fa>
80006b4c:	62 0a       	ld.w	r10,r1[0x0]
80006b4e:	58 3a       	cp.w	r10,3
80006b50:	c1 e0       	breq	80006b8c <get_arg+0x2e8>
80006b52:	e0 89 00 07 	brgt	80006b60 <get_arg+0x2bc>
80006b56:	58 1a       	cp.w	r10,1
80006b58:	c1 a0       	breq	80006b8c <get_arg+0x2e8>
80006b5a:	58 2a       	cp.w	r10,2
80006b5c:	c1 81       	brne	80006b8c <get_arg+0x2e8>
80006b5e:	c0 58       	rjmp	80006b68 <get_arg+0x2c4>
80006b60:	58 5a       	cp.w	r10,5
80006b62:	c0 c0       	breq	80006b7a <get_arg+0x2d6>
80006b64:	c0 b5       	brlt	80006b7a <get_arg+0x2d6>
80006b66:	c1 38       	rjmp	80006b8c <get_arg+0x2e8>
80006b68:	6c 0a       	ld.w	r10,r6[0x0]
80006b6a:	f4 cc ff f8 	sub	r12,r10,-8
80006b6e:	8d 0c       	st.w	r6[0x0],r12
80006b70:	f4 e2 00 00 	ld.d	r2,r10[0]
80006b74:	f0 e3 00 00 	st.d	r8[0],r2
80006b78:	c1 08       	rjmp	80006b98 <get_arg+0x2f4>
80006b7a:	6c 0a       	ld.w	r10,r6[0x0]
80006b7c:	f4 cc ff f8 	sub	r12,r10,-8
80006b80:	8d 0c       	st.w	r6[0x0],r12
80006b82:	f4 e2 00 00 	ld.d	r2,r10[0]
80006b86:	f0 e3 00 00 	st.d	r8[0],r2
80006b8a:	c0 78       	rjmp	80006b98 <get_arg+0x2f4>
80006b8c:	6c 0a       	ld.w	r10,r6[0x0]
80006b8e:	f4 cc ff fc 	sub	r12,r10,-4
80006b92:	8d 0c       	st.w	r6[0x0],r12
80006b94:	74 0a       	ld.w	r10,r10[0x0]
80006b96:	91 0a       	st.w	r8[0x0],r10
80006b98:	2f f5       	sub	r5,-1
80006b9a:	2f 88       	sub	r8,-8
80006b9c:	2f c1       	sub	r1,-4
80006b9e:	12 35       	cp.w	r5,r9
80006ba0:	fe 9a ff d6 	brle	80006b4c <get_arg+0x2a8>
80006ba4:	1c 93       	mov	r3,lr
80006ba6:	40 52       	lddsp	r2,sp[0x14]
80006ba8:	40 6e       	lddsp	lr,sp[0x18]
80006baa:	85 05       	st.w	r2[0x0],r5
80006bac:	9d 0b       	st.w	lr[0x0],r11
80006bae:	40 4b       	lddsp	r11,sp[0x10]
80006bb0:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80006bb4:	2f 8d       	sub	sp,-32
80006bb6:	d8 32       	popm	r0-r7,pc

80006bb8 <__sprint_r>:
80006bb8:	d4 21       	pushm	r4-r7,lr
80006bba:	14 97       	mov	r7,r10
80006bbc:	74 28       	ld.w	r8,r10[0x8]
80006bbe:	58 08       	cp.w	r8,0
80006bc0:	c0 41       	brne	80006bc8 <__sprint_r+0x10>
80006bc2:	95 18       	st.w	r10[0x4],r8
80006bc4:	10 9c       	mov	r12,r8
80006bc6:	d8 22       	popm	r4-r7,pc
80006bc8:	e0 a0 18 ba 	rcall	80009d3c <__sfvwrite_r>
80006bcc:	30 08       	mov	r8,0
80006bce:	8f 18       	st.w	r7[0x4],r8
80006bd0:	8f 28       	st.w	r7[0x8],r8
80006bd2:	d8 22       	popm	r4-r7,pc

80006bd4 <_vfprintf_r>:
80006bd4:	d4 31       	pushm	r0-r7,lr
80006bd6:	fa cd 06 bc 	sub	sp,sp,1724
80006bda:	51 09       	stdsp	sp[0x40],r9
80006bdc:	16 91       	mov	r1,r11
80006bde:	14 97       	mov	r7,r10
80006be0:	18 95       	mov	r5,r12
80006be2:	e0 a0 1a 1d 	rcall	8000a01c <_localeconv_r>
80006be6:	78 0c       	ld.w	r12,r12[0x0]
80006be8:	50 cc       	stdsp	sp[0x30],r12
80006bea:	58 05       	cp.w	r5,0
80006bec:	c0 70       	breq	80006bfa <_vfprintf_r+0x26>
80006bee:	6a 68       	ld.w	r8,r5[0x18]
80006bf0:	58 08       	cp.w	r8,0
80006bf2:	c0 41       	brne	80006bfa <_vfprintf_r+0x26>
80006bf4:	0a 9c       	mov	r12,r5
80006bf6:	e0 a0 17 43 	rcall	80009a7c <__sinit>
80006bfa:	fe c8 a2 1e 	sub	r8,pc,-24034
80006bfe:	10 31       	cp.w	r1,r8
80006c00:	c0 31       	brne	80006c06 <_vfprintf_r+0x32>
80006c02:	6a 01       	ld.w	r1,r5[0x0]
80006c04:	c0 c8       	rjmp	80006c1c <_vfprintf_r+0x48>
80006c06:	fe c8 a2 0a 	sub	r8,pc,-24054
80006c0a:	10 31       	cp.w	r1,r8
80006c0c:	c0 31       	brne	80006c12 <_vfprintf_r+0x3e>
80006c0e:	6a 11       	ld.w	r1,r5[0x4]
80006c10:	c0 68       	rjmp	80006c1c <_vfprintf_r+0x48>
80006c12:	fe c8 a1 f6 	sub	r8,pc,-24074
80006c16:	10 31       	cp.w	r1,r8
80006c18:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80006c1c:	82 68       	ld.sh	r8,r1[0xc]
80006c1e:	ed b8 00 03 	bld	r8,0x3
80006c22:	c0 41       	brne	80006c2a <_vfprintf_r+0x56>
80006c24:	62 48       	ld.w	r8,r1[0x10]
80006c26:	58 08       	cp.w	r8,0
80006c28:	c0 71       	brne	80006c36 <_vfprintf_r+0x62>
80006c2a:	02 9b       	mov	r11,r1
80006c2c:	0a 9c       	mov	r12,r5
80006c2e:	e0 a0 0f 5d 	rcall	80008ae8 <__swsetup_r>
80006c32:	e0 81 0f 54 	brne	80008ada <_vfprintf_r+0x1f06>
80006c36:	82 68       	ld.sh	r8,r1[0xc]
80006c38:	10 99       	mov	r9,r8
80006c3a:	e2 19 00 1a 	andl	r9,0x1a,COH
80006c3e:	58 a9       	cp.w	r9,10
80006c40:	c3 c1       	brne	80006cb8 <_vfprintf_r+0xe4>
80006c42:	82 79       	ld.sh	r9,r1[0xe]
80006c44:	30 0a       	mov	r10,0
80006c46:	f4 09 19 00 	cp.h	r9,r10
80006c4a:	c3 75       	brlt	80006cb8 <_vfprintf_r+0xe4>
80006c4c:	a1 d8       	cbr	r8,0x1
80006c4e:	fb 58 05 d0 	st.h	sp[1488],r8
80006c52:	62 88       	ld.w	r8,r1[0x20]
80006c54:	fb 48 05 e4 	st.w	sp[1508],r8
80006c58:	62 a8       	ld.w	r8,r1[0x28]
80006c5a:	fb 48 05 ec 	st.w	sp[1516],r8
80006c5e:	fa c8 ff bc 	sub	r8,sp,-68
80006c62:	fb 48 05 d4 	st.w	sp[1492],r8
80006c66:	fb 48 05 c4 	st.w	sp[1476],r8
80006c6a:	e0 68 04 00 	mov	r8,1024
80006c6e:	fb 48 05 d8 	st.w	sp[1496],r8
80006c72:	fb 48 05 cc 	st.w	sp[1484],r8
80006c76:	30 08       	mov	r8,0
80006c78:	fb 59 05 d2 	st.h	sp[1490],r9
80006c7c:	0e 9a       	mov	r10,r7
80006c7e:	41 09       	lddsp	r9,sp[0x40]
80006c80:	fa c7 fa 3c 	sub	r7,sp,-1476
80006c84:	fb 48 05 dc 	st.w	sp[1500],r8
80006c88:	0a 9c       	mov	r12,r5
80006c8a:	0e 9b       	mov	r11,r7
80006c8c:	ca 4f       	rcall	80006bd4 <_vfprintf_r>
80006c8e:	50 bc       	stdsp	sp[0x2c],r12
80006c90:	c0 95       	brlt	80006ca2 <_vfprintf_r+0xce>
80006c92:	0e 9b       	mov	r11,r7
80006c94:	0a 9c       	mov	r12,r5
80006c96:	e0 a0 16 1b 	rcall	800098cc <_fflush_r>
80006c9a:	40 be       	lddsp	lr,sp[0x2c]
80006c9c:	f9 be 01 ff 	movne	lr,-1
80006ca0:	50 be       	stdsp	sp[0x2c],lr
80006ca2:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80006ca6:	ed b8 00 06 	bld	r8,0x6
80006caa:	e0 81 0f 1a 	brne	80008ade <_vfprintf_r+0x1f0a>
80006cae:	82 68       	ld.sh	r8,r1[0xc]
80006cb0:	a7 a8       	sbr	r8,0x6
80006cb2:	a2 68       	st.h	r1[0xc],r8
80006cb4:	e0 8f 0f 15 	bral	80008ade <_vfprintf_r+0x1f0a>
80006cb8:	30 08       	mov	r8,0
80006cba:	fb 48 06 b4 	st.w	sp[1716],r8
80006cbe:	fb 48 06 90 	st.w	sp[1680],r8
80006cc2:	fb 48 06 8c 	st.w	sp[1676],r8
80006cc6:	fb 48 06 b0 	st.w	sp[1712],r8
80006cca:	30 08       	mov	r8,0
80006ccc:	30 09       	mov	r9,0
80006cce:	50 a7       	stdsp	sp[0x28],r7
80006cd0:	50 78       	stdsp	sp[0x1c],r8
80006cd2:	fa c3 f9 e0 	sub	r3,sp,-1568
80006cd6:	3f f8       	mov	r8,-1
80006cd8:	50 59       	stdsp	sp[0x14],r9
80006cda:	fb 43 06 88 	st.w	sp[1672],r3
80006cde:	fb 48 05 44 	st.w	sp[1348],r8
80006ce2:	12 9c       	mov	r12,r9
80006ce4:	50 69       	stdsp	sp[0x18],r9
80006ce6:	50 d9       	stdsp	sp[0x34],r9
80006ce8:	50 e9       	stdsp	sp[0x38],r9
80006cea:	50 b9       	stdsp	sp[0x2c],r9
80006cec:	12 97       	mov	r7,r9
80006cee:	0a 94       	mov	r4,r5
80006cf0:	40 a2       	lddsp	r2,sp[0x28]
80006cf2:	32 5a       	mov	r10,37
80006cf4:	30 08       	mov	r8,0
80006cf6:	c0 28       	rjmp	80006cfa <_vfprintf_r+0x126>
80006cf8:	2f f2       	sub	r2,-1
80006cfa:	05 89       	ld.ub	r9,r2[0x0]
80006cfc:	f0 09 18 00 	cp.b	r9,r8
80006d00:	5f 1b       	srne	r11
80006d02:	f4 09 18 00 	cp.b	r9,r10
80006d06:	5f 19       	srne	r9
80006d08:	f3 eb 00 0b 	and	r11,r9,r11
80006d0c:	f0 0b 18 00 	cp.b	r11,r8
80006d10:	cf 41       	brne	80006cf8 <_vfprintf_r+0x124>
80006d12:	40 ab       	lddsp	r11,sp[0x28]
80006d14:	e4 0b 01 06 	sub	r6,r2,r11
80006d18:	c1 e0       	breq	80006d54 <_vfprintf_r+0x180>
80006d1a:	fa f8 06 90 	ld.w	r8,sp[1680]
80006d1e:	0c 08       	add	r8,r6
80006d20:	87 0b       	st.w	r3[0x0],r11
80006d22:	fb 48 06 90 	st.w	sp[1680],r8
80006d26:	87 16       	st.w	r3[0x4],r6
80006d28:	fa f8 06 8c 	ld.w	r8,sp[1676]
80006d2c:	2f f8       	sub	r8,-1
80006d2e:	fb 48 06 8c 	st.w	sp[1676],r8
80006d32:	58 78       	cp.w	r8,7
80006d34:	e0 89 00 04 	brgt	80006d3c <_vfprintf_r+0x168>
80006d38:	2f 83       	sub	r3,-8
80006d3a:	c0 a8       	rjmp	80006d4e <_vfprintf_r+0x17a>
80006d3c:	fa ca f9 78 	sub	r10,sp,-1672
80006d40:	02 9b       	mov	r11,r1
80006d42:	08 9c       	mov	r12,r4
80006d44:	c3 af       	rcall	80006bb8 <__sprint_r>
80006d46:	e0 81 0e c6 	brne	80008ad2 <_vfprintf_r+0x1efe>
80006d4a:	fa c3 f9 e0 	sub	r3,sp,-1568
80006d4e:	40 ba       	lddsp	r10,sp[0x2c]
80006d50:	0c 0a       	add	r10,r6
80006d52:	50 ba       	stdsp	sp[0x2c],r10
80006d54:	05 89       	ld.ub	r9,r2[0x0]
80006d56:	30 08       	mov	r8,0
80006d58:	f0 09 18 00 	cp.b	r9,r8
80006d5c:	e0 80 0e aa 	breq	80008ab0 <_vfprintf_r+0x1edc>
80006d60:	30 09       	mov	r9,0
80006d62:	fb 68 06 bb 	st.b	sp[1723],r8
80006d66:	0e 96       	mov	r6,r7
80006d68:	e4 c8 ff ff 	sub	r8,r2,-1
80006d6c:	3f fe       	mov	lr,-1
80006d6e:	50 93       	stdsp	sp[0x24],r3
80006d70:	50 41       	stdsp	sp[0x10],r1
80006d72:	0e 93       	mov	r3,r7
80006d74:	04 91       	mov	r1,r2
80006d76:	50 89       	stdsp	sp[0x20],r9
80006d78:	50 a8       	stdsp	sp[0x28],r8
80006d7a:	50 2e       	stdsp	sp[0x8],lr
80006d7c:	50 39       	stdsp	sp[0xc],r9
80006d7e:	12 95       	mov	r5,r9
80006d80:	12 90       	mov	r0,r9
80006d82:	10 97       	mov	r7,r8
80006d84:	08 92       	mov	r2,r4
80006d86:	c0 78       	rjmp	80006d94 <_vfprintf_r+0x1c0>
80006d88:	3f fc       	mov	r12,-1
80006d8a:	08 97       	mov	r7,r4
80006d8c:	50 2c       	stdsp	sp[0x8],r12
80006d8e:	c0 38       	rjmp	80006d94 <_vfprintf_r+0x1c0>
80006d90:	30 0b       	mov	r11,0
80006d92:	50 3b       	stdsp	sp[0xc],r11
80006d94:	0f 38       	ld.ub	r8,r7++
80006d96:	c0 28       	rjmp	80006d9a <_vfprintf_r+0x1c6>
80006d98:	12 90       	mov	r0,r9
80006d9a:	f0 c9 00 20 	sub	r9,r8,32
80006d9e:	e0 49 00 58 	cp.w	r9,88
80006da2:	e0 8b 0a 30 	brhi	80008202 <_vfprintf_r+0x162e>
80006da6:	fe ca a7 72 	sub	r10,pc,-22670
80006daa:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80006dae:	50 a7       	stdsp	sp[0x28],r7
80006db0:	50 80       	stdsp	sp[0x20],r0
80006db2:	0c 97       	mov	r7,r6
80006db4:	04 94       	mov	r4,r2
80006db6:	06 96       	mov	r6,r3
80006db8:	02 92       	mov	r2,r1
80006dba:	fe c9 a5 4a 	sub	r9,pc,-23222
80006dbe:	40 93       	lddsp	r3,sp[0x24]
80006dc0:	10 90       	mov	r0,r8
80006dc2:	40 41       	lddsp	r1,sp[0x10]
80006dc4:	50 d9       	stdsp	sp[0x34],r9
80006dc6:	e0 8f 08 8e 	bral	80007ee2 <_vfprintf_r+0x130e>
80006dca:	30 08       	mov	r8,0
80006dcc:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80006dd0:	f0 09 18 00 	cp.b	r9,r8
80006dd4:	ce 01       	brne	80006d94 <_vfprintf_r+0x1c0>
80006dd6:	32 08       	mov	r8,32
80006dd8:	c6 e8       	rjmp	80006eb4 <_vfprintf_r+0x2e0>
80006dda:	a1 a5       	sbr	r5,0x0
80006ddc:	cd cb       	rjmp	80006d94 <_vfprintf_r+0x1c0>
80006dde:	0f 89       	ld.ub	r9,r7[0x0]
80006de0:	f2 c8 00 30 	sub	r8,r9,48
80006de4:	58 98       	cp.w	r8,9
80006de6:	e0 8b 00 1d 	brhi	80006e20 <_vfprintf_r+0x24c>
80006dea:	ee c8 ff ff 	sub	r8,r7,-1
80006dee:	30 0b       	mov	r11,0
80006df0:	23 09       	sub	r9,48
80006df2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80006df6:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80006dfa:	11 39       	ld.ub	r9,r8++
80006dfc:	f2 ca 00 30 	sub	r10,r9,48
80006e00:	58 9a       	cp.w	r10,9
80006e02:	fe 98 ff f7 	brls	80006df0 <_vfprintf_r+0x21c>
80006e06:	e0 49 00 24 	cp.w	r9,36
80006e0a:	cc 31       	brne	80006d90 <_vfprintf_r+0x1bc>
80006e0c:	e0 4b 00 20 	cp.w	r11,32
80006e10:	e0 89 0e 60 	brgt	80008ad0 <_vfprintf_r+0x1efc>
80006e14:	20 1b       	sub	r11,1
80006e16:	fa f9 06 b4 	ld.w	r9,sp[1716]
80006e1a:	12 3b       	cp.w	r11,r9
80006e1c:	c0 95       	brlt	80006e2e <_vfprintf_r+0x25a>
80006e1e:	c1 08       	rjmp	80006e3e <_vfprintf_r+0x26a>
80006e20:	fa f9 06 b4 	ld.w	r9,sp[1716]
80006e24:	ec ca ff ff 	sub	r10,r6,-1
80006e28:	12 36       	cp.w	r6,r9
80006e2a:	c1 f5       	brlt	80006e68 <_vfprintf_r+0x294>
80006e2c:	c2 68       	rjmp	80006e78 <_vfprintf_r+0x2a4>
80006e2e:	fa ce f9 44 	sub	lr,sp,-1724
80006e32:	10 97       	mov	r7,r8
80006e34:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80006e38:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80006e3c:	c3 58       	rjmp	80006ea6 <_vfprintf_r+0x2d2>
80006e3e:	10 97       	mov	r7,r8
80006e40:	fa c8 f9 50 	sub	r8,sp,-1712
80006e44:	1a d8       	st.w	--sp,r8
80006e46:	fa c8 fa b8 	sub	r8,sp,-1352
80006e4a:	1a d8       	st.w	--sp,r8
80006e4c:	fa c8 fb b4 	sub	r8,sp,-1100
80006e50:	02 9a       	mov	r10,r1
80006e52:	1a d8       	st.w	--sp,r8
80006e54:	04 9c       	mov	r12,r2
80006e56:	fa c8 f9 40 	sub	r8,sp,-1728
80006e5a:	fa c9 ff b4 	sub	r9,sp,-76
80006e5e:	fe b0 fd 23 	rcall	800068a4 <get_arg>
80006e62:	2f dd       	sub	sp,-12
80006e64:	78 00       	ld.w	r0,r12[0x0]
80006e66:	c2 08       	rjmp	80006ea6 <_vfprintf_r+0x2d2>
80006e68:	fa cc f9 44 	sub	r12,sp,-1724
80006e6c:	14 96       	mov	r6,r10
80006e6e:	f8 03 00 38 	add	r8,r12,r3<<0x3
80006e72:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80006e76:	c1 88       	rjmp	80006ea6 <_vfprintf_r+0x2d2>
80006e78:	41 08       	lddsp	r8,sp[0x40]
80006e7a:	59 f9       	cp.w	r9,31
80006e7c:	e0 89 00 11 	brgt	80006e9e <_vfprintf_r+0x2ca>
80006e80:	f0 cb ff fc 	sub	r11,r8,-4
80006e84:	51 0b       	stdsp	sp[0x40],r11
80006e86:	70 00       	ld.w	r0,r8[0x0]
80006e88:	fa cb f9 44 	sub	r11,sp,-1724
80006e8c:	f6 09 00 38 	add	r8,r11,r9<<0x3
80006e90:	f1 40 fd 88 	st.w	r8[-632],r0
80006e94:	2f f9       	sub	r9,-1
80006e96:	14 96       	mov	r6,r10
80006e98:	fb 49 06 b4 	st.w	sp[1716],r9
80006e9c:	c0 58       	rjmp	80006ea6 <_vfprintf_r+0x2d2>
80006e9e:	70 00       	ld.w	r0,r8[0x0]
80006ea0:	14 96       	mov	r6,r10
80006ea2:	2f c8       	sub	r8,-4
80006ea4:	51 08       	stdsp	sp[0x40],r8
80006ea6:	58 00       	cp.w	r0,0
80006ea8:	fe 94 ff 76 	brge	80006d94 <_vfprintf_r+0x1c0>
80006eac:	5c 30       	neg	r0
80006eae:	a3 a5       	sbr	r5,0x2
80006eb0:	c7 2b       	rjmp	80006d94 <_vfprintf_r+0x1c0>
80006eb2:	32 b8       	mov	r8,43
80006eb4:	fb 68 06 bb 	st.b	sp[1723],r8
80006eb8:	c6 eb       	rjmp	80006d94 <_vfprintf_r+0x1c0>
80006eba:	0f 38       	ld.ub	r8,r7++
80006ebc:	e0 48 00 2a 	cp.w	r8,42
80006ec0:	c0 30       	breq	80006ec6 <_vfprintf_r+0x2f2>
80006ec2:	30 09       	mov	r9,0
80006ec4:	c7 98       	rjmp	80006fb6 <_vfprintf_r+0x3e2>
80006ec6:	0f 88       	ld.ub	r8,r7[0x0]
80006ec8:	f0 c9 00 30 	sub	r9,r8,48
80006ecc:	58 99       	cp.w	r9,9
80006ece:	e0 8b 00 1f 	brhi	80006f0c <_vfprintf_r+0x338>
80006ed2:	ee c4 ff ff 	sub	r4,r7,-1
80006ed6:	30 0b       	mov	r11,0
80006ed8:	23 08       	sub	r8,48
80006eda:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80006ede:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80006ee2:	09 38       	ld.ub	r8,r4++
80006ee4:	f0 c9 00 30 	sub	r9,r8,48
80006ee8:	58 99       	cp.w	r9,9
80006eea:	fe 98 ff f7 	brls	80006ed8 <_vfprintf_r+0x304>
80006eee:	e0 48 00 24 	cp.w	r8,36
80006ef2:	fe 91 ff 4f 	brne	80006d90 <_vfprintf_r+0x1bc>
80006ef6:	e0 4b 00 20 	cp.w	r11,32
80006efa:	e0 89 0d eb 	brgt	80008ad0 <_vfprintf_r+0x1efc>
80006efe:	20 1b       	sub	r11,1
80006f00:	fa f8 06 b4 	ld.w	r8,sp[1716]
80006f04:	10 3b       	cp.w	r11,r8
80006f06:	c0 a5       	brlt	80006f1a <_vfprintf_r+0x346>
80006f08:	c1 18       	rjmp	80006f2a <_vfprintf_r+0x356>
80006f0a:	d7 03       	nop
80006f0c:	fa fa 06 b4 	ld.w	r10,sp[1716]
80006f10:	ec c9 ff ff 	sub	r9,r6,-1
80006f14:	14 36       	cp.w	r6,r10
80006f16:	c1 f5       	brlt	80006f54 <_vfprintf_r+0x380>
80006f18:	c2 88       	rjmp	80006f68 <_vfprintf_r+0x394>
80006f1a:	fa ca f9 44 	sub	r10,sp,-1724
80006f1e:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80006f22:	f6 fb fd 88 	ld.w	r11,r11[-632]
80006f26:	50 2b       	stdsp	sp[0x8],r11
80006f28:	c3 c8       	rjmp	80006fa0 <_vfprintf_r+0x3cc>
80006f2a:	fa c8 f9 50 	sub	r8,sp,-1712
80006f2e:	1a d8       	st.w	--sp,r8
80006f30:	fa c8 fa b8 	sub	r8,sp,-1352
80006f34:	1a d8       	st.w	--sp,r8
80006f36:	fa c8 fb b4 	sub	r8,sp,-1100
80006f3a:	02 9a       	mov	r10,r1
80006f3c:	1a d8       	st.w	--sp,r8
80006f3e:	04 9c       	mov	r12,r2
80006f40:	fa c8 f9 40 	sub	r8,sp,-1728
80006f44:	fa c9 ff b4 	sub	r9,sp,-76
80006f48:	fe b0 fc ae 	rcall	800068a4 <get_arg>
80006f4c:	2f dd       	sub	sp,-12
80006f4e:	78 0c       	ld.w	r12,r12[0x0]
80006f50:	50 2c       	stdsp	sp[0x8],r12
80006f52:	c2 78       	rjmp	80006fa0 <_vfprintf_r+0x3cc>
80006f54:	12 96       	mov	r6,r9
80006f56:	0e 94       	mov	r4,r7
80006f58:	fa c9 f9 44 	sub	r9,sp,-1724
80006f5c:	f2 03 00 38 	add	r8,r9,r3<<0x3
80006f60:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80006f64:	50 28       	stdsp	sp[0x8],r8
80006f66:	c1 d8       	rjmp	80006fa0 <_vfprintf_r+0x3cc>
80006f68:	41 08       	lddsp	r8,sp[0x40]
80006f6a:	59 fa       	cp.w	r10,31
80006f6c:	e0 89 00 14 	brgt	80006f94 <_vfprintf_r+0x3c0>
80006f70:	f0 cb ff fc 	sub	r11,r8,-4
80006f74:	70 08       	ld.w	r8,r8[0x0]
80006f76:	51 0b       	stdsp	sp[0x40],r11
80006f78:	50 28       	stdsp	sp[0x8],r8
80006f7a:	fa c6 f9 44 	sub	r6,sp,-1724
80006f7e:	40 2e       	lddsp	lr,sp[0x8]
80006f80:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80006f84:	f1 4e fd 88 	st.w	r8[-632],lr
80006f88:	2f fa       	sub	r10,-1
80006f8a:	0e 94       	mov	r4,r7
80006f8c:	fb 4a 06 b4 	st.w	sp[1716],r10
80006f90:	12 96       	mov	r6,r9
80006f92:	c0 78       	rjmp	80006fa0 <_vfprintf_r+0x3cc>
80006f94:	70 0c       	ld.w	r12,r8[0x0]
80006f96:	0e 94       	mov	r4,r7
80006f98:	2f c8       	sub	r8,-4
80006f9a:	50 2c       	stdsp	sp[0x8],r12
80006f9c:	12 96       	mov	r6,r9
80006f9e:	51 08       	stdsp	sp[0x40],r8
80006fa0:	40 2b       	lddsp	r11,sp[0x8]
80006fa2:	58 0b       	cp.w	r11,0
80006fa4:	fe 95 fe f2 	brlt	80006d88 <_vfprintf_r+0x1b4>
80006fa8:	08 97       	mov	r7,r4
80006faa:	cf 5a       	rjmp	80006d94 <_vfprintf_r+0x1c0>
80006fac:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006fb0:	0f 38       	ld.ub	r8,r7++
80006fb2:	f4 09 00 19 	add	r9,r10,r9<<0x1
80006fb6:	f0 ca 00 30 	sub	r10,r8,48
80006fba:	58 9a       	cp.w	r10,9
80006fbc:	fe 98 ff f8 	brls	80006fac <_vfprintf_r+0x3d8>
80006fc0:	3f fa       	mov	r10,-1
80006fc2:	f2 0a 0c 49 	max	r9,r9,r10
80006fc6:	50 29       	stdsp	sp[0x8],r9
80006fc8:	ce 9a       	rjmp	80006d9a <_vfprintf_r+0x1c6>
80006fca:	a7 b5       	sbr	r5,0x7
80006fcc:	ce 4a       	rjmp	80006d94 <_vfprintf_r+0x1c0>
80006fce:	30 09       	mov	r9,0
80006fd0:	23 08       	sub	r8,48
80006fd2:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006fd6:	f0 09 00 19 	add	r9,r8,r9<<0x1
80006fda:	0f 38       	ld.ub	r8,r7++
80006fdc:	f0 ca 00 30 	sub	r10,r8,48
80006fe0:	58 9a       	cp.w	r10,9
80006fe2:	fe 98 ff f7 	brls	80006fd0 <_vfprintf_r+0x3fc>
80006fe6:	e0 48 00 24 	cp.w	r8,36
80006fea:	fe 91 fe d7 	brne	80006d98 <_vfprintf_r+0x1c4>
80006fee:	e0 49 00 20 	cp.w	r9,32
80006ff2:	e0 89 0d 6f 	brgt	80008ad0 <_vfprintf_r+0x1efc>
80006ff6:	f2 c3 00 01 	sub	r3,r9,1
80006ffa:	30 19       	mov	r9,1
80006ffc:	50 39       	stdsp	sp[0xc],r9
80006ffe:	cc ba       	rjmp	80006d94 <_vfprintf_r+0x1c0>
80007000:	a3 b5       	sbr	r5,0x3
80007002:	cc 9a       	rjmp	80006d94 <_vfprintf_r+0x1c0>
80007004:	a7 a5       	sbr	r5,0x6
80007006:	cc 7a       	rjmp	80006d94 <_vfprintf_r+0x1c0>
80007008:	0a 98       	mov	r8,r5
8000700a:	a5 b5       	sbr	r5,0x5
8000700c:	a5 a8       	sbr	r8,0x4
8000700e:	0f 89       	ld.ub	r9,r7[0x0]
80007010:	36 ce       	mov	lr,108
80007012:	fc 09 18 00 	cp.b	r9,lr
80007016:	f7 b7 00 ff 	subeq	r7,-1
8000701a:	f0 05 17 10 	movne	r5,r8
8000701e:	cb ba       	rjmp	80006d94 <_vfprintf_r+0x1c0>
80007020:	a5 b5       	sbr	r5,0x5
80007022:	cb 9a       	rjmp	80006d94 <_vfprintf_r+0x1c0>
80007024:	50 a7       	stdsp	sp[0x28],r7
80007026:	50 80       	stdsp	sp[0x20],r0
80007028:	0c 97       	mov	r7,r6
8000702a:	10 90       	mov	r0,r8
8000702c:	06 96       	mov	r6,r3
8000702e:	04 94       	mov	r4,r2
80007030:	40 93       	lddsp	r3,sp[0x24]
80007032:	02 92       	mov	r2,r1
80007034:	0e 99       	mov	r9,r7
80007036:	40 41       	lddsp	r1,sp[0x10]
80007038:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000703c:	40 3c       	lddsp	r12,sp[0xc]
8000703e:	58 0c       	cp.w	r12,0
80007040:	c1 d0       	breq	8000707a <_vfprintf_r+0x4a6>
80007042:	10 36       	cp.w	r6,r8
80007044:	c0 64       	brge	80007050 <_vfprintf_r+0x47c>
80007046:	fa cb f9 44 	sub	r11,sp,-1724
8000704a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000704e:	c1 d8       	rjmp	80007088 <_vfprintf_r+0x4b4>
80007050:	fa c8 f9 50 	sub	r8,sp,-1712
80007054:	1a d8       	st.w	--sp,r8
80007056:	fa c8 fa b8 	sub	r8,sp,-1352
8000705a:	1a d8       	st.w	--sp,r8
8000705c:	fa c8 fb b4 	sub	r8,sp,-1100
80007060:	1a d8       	st.w	--sp,r8
80007062:	fa c8 f9 40 	sub	r8,sp,-1728
80007066:	fa c9 ff b4 	sub	r9,sp,-76
8000706a:	04 9a       	mov	r10,r2
8000706c:	0c 9b       	mov	r11,r6
8000706e:	08 9c       	mov	r12,r4
80007070:	fe b0 fc 1a 	rcall	800068a4 <get_arg>
80007074:	2f dd       	sub	sp,-12
80007076:	19 b8       	ld.ub	r8,r12[0x3]
80007078:	c2 28       	rjmp	800070bc <_vfprintf_r+0x4e8>
8000707a:	2f f7       	sub	r7,-1
8000707c:	10 39       	cp.w	r9,r8
8000707e:	c0 84       	brge	8000708e <_vfprintf_r+0x4ba>
80007080:	fa ca f9 44 	sub	r10,sp,-1724
80007084:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007088:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000708c:	c1 88       	rjmp	800070bc <_vfprintf_r+0x4e8>
8000708e:	41 09       	lddsp	r9,sp[0x40]
80007090:	59 f8       	cp.w	r8,31
80007092:	e0 89 00 12 	brgt	800070b6 <_vfprintf_r+0x4e2>
80007096:	f2 ca ff fc 	sub	r10,r9,-4
8000709a:	51 0a       	stdsp	sp[0x40],r10
8000709c:	72 09       	ld.w	r9,r9[0x0]
8000709e:	fa c6 f9 44 	sub	r6,sp,-1724
800070a2:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800070a6:	2f f8       	sub	r8,-1
800070a8:	f5 49 fd 88 	st.w	r10[-632],r9
800070ac:	fb 48 06 b4 	st.w	sp[1716],r8
800070b0:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800070b4:	c0 48       	rjmp	800070bc <_vfprintf_r+0x4e8>
800070b6:	13 b8       	ld.ub	r8,r9[0x3]
800070b8:	2f c9       	sub	r9,-4
800070ba:	51 09       	stdsp	sp[0x40],r9
800070bc:	fb 68 06 60 	st.b	sp[1632],r8
800070c0:	30 0e       	mov	lr,0
800070c2:	30 08       	mov	r8,0
800070c4:	30 12       	mov	r2,1
800070c6:	fb 68 06 bb 	st.b	sp[1723],r8
800070ca:	50 2e       	stdsp	sp[0x8],lr
800070cc:	e0 8f 08 ad 	bral	80008226 <_vfprintf_r+0x1652>
800070d0:	50 a7       	stdsp	sp[0x28],r7
800070d2:	50 80       	stdsp	sp[0x20],r0
800070d4:	0c 97       	mov	r7,r6
800070d6:	04 94       	mov	r4,r2
800070d8:	06 96       	mov	r6,r3
800070da:	02 92       	mov	r2,r1
800070dc:	40 93       	lddsp	r3,sp[0x24]
800070de:	10 90       	mov	r0,r8
800070e0:	40 41       	lddsp	r1,sp[0x10]
800070e2:	a5 a5       	sbr	r5,0x4
800070e4:	c0 a8       	rjmp	800070f8 <_vfprintf_r+0x524>
800070e6:	50 a7       	stdsp	sp[0x28],r7
800070e8:	50 80       	stdsp	sp[0x20],r0
800070ea:	0c 97       	mov	r7,r6
800070ec:	04 94       	mov	r4,r2
800070ee:	06 96       	mov	r6,r3
800070f0:	02 92       	mov	r2,r1
800070f2:	40 93       	lddsp	r3,sp[0x24]
800070f4:	10 90       	mov	r0,r8
800070f6:	40 41       	lddsp	r1,sp[0x10]
800070f8:	ed b5 00 05 	bld	r5,0x5
800070fc:	c5 11       	brne	8000719e <_vfprintf_r+0x5ca>
800070fe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007102:	40 3c       	lddsp	r12,sp[0xc]
80007104:	58 0c       	cp.w	r12,0
80007106:	c1 e0       	breq	80007142 <_vfprintf_r+0x56e>
80007108:	10 36       	cp.w	r6,r8
8000710a:	c0 64       	brge	80007116 <_vfprintf_r+0x542>
8000710c:	fa cb f9 44 	sub	r11,sp,-1724
80007110:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007114:	c2 08       	rjmp	80007154 <_vfprintf_r+0x580>
80007116:	fa c8 f9 50 	sub	r8,sp,-1712
8000711a:	1a d8       	st.w	--sp,r8
8000711c:	fa c8 fa b8 	sub	r8,sp,-1352
80007120:	0c 9b       	mov	r11,r6
80007122:	1a d8       	st.w	--sp,r8
80007124:	fa c8 fb b4 	sub	r8,sp,-1100
80007128:	1a d8       	st.w	--sp,r8
8000712a:	fa c9 ff b4 	sub	r9,sp,-76
8000712e:	fa c8 f9 40 	sub	r8,sp,-1728
80007132:	04 9a       	mov	r10,r2
80007134:	08 9c       	mov	r12,r4
80007136:	fe b0 fb b7 	rcall	800068a4 <get_arg>
8000713a:	2f dd       	sub	sp,-12
8000713c:	78 1b       	ld.w	r11,r12[0x4]
8000713e:	78 09       	ld.w	r9,r12[0x0]
80007140:	c2 b8       	rjmp	80007196 <_vfprintf_r+0x5c2>
80007142:	ee ca ff ff 	sub	r10,r7,-1
80007146:	10 37       	cp.w	r7,r8
80007148:	c0 b4       	brge	8000715e <_vfprintf_r+0x58a>
8000714a:	fa c9 f9 44 	sub	r9,sp,-1724
8000714e:	14 97       	mov	r7,r10
80007150:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007154:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007158:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000715c:	c1 d8       	rjmp	80007196 <_vfprintf_r+0x5c2>
8000715e:	41 09       	lddsp	r9,sp[0x40]
80007160:	59 f8       	cp.w	r8,31
80007162:	e0 89 00 14 	brgt	8000718a <_vfprintf_r+0x5b6>
80007166:	f2 cb ff f8 	sub	r11,r9,-8
8000716a:	51 0b       	stdsp	sp[0x40],r11
8000716c:	fa c6 f9 44 	sub	r6,sp,-1724
80007170:	72 1b       	ld.w	r11,r9[0x4]
80007172:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007176:	72 09       	ld.w	r9,r9[0x0]
80007178:	f9 4b fd 8c 	st.w	r12[-628],r11
8000717c:	f9 49 fd 88 	st.w	r12[-632],r9
80007180:	2f f8       	sub	r8,-1
80007182:	14 97       	mov	r7,r10
80007184:	fb 48 06 b4 	st.w	sp[1716],r8
80007188:	c0 78       	rjmp	80007196 <_vfprintf_r+0x5c2>
8000718a:	f2 c8 ff f8 	sub	r8,r9,-8
8000718e:	72 1b       	ld.w	r11,r9[0x4]
80007190:	14 97       	mov	r7,r10
80007192:	51 08       	stdsp	sp[0x40],r8
80007194:	72 09       	ld.w	r9,r9[0x0]
80007196:	16 98       	mov	r8,r11
80007198:	fa e9 00 00 	st.d	sp[0],r8
8000719c:	ca e8       	rjmp	800072f8 <_vfprintf_r+0x724>
8000719e:	ed b5 00 04 	bld	r5,0x4
800071a2:	c1 71       	brne	800071d0 <_vfprintf_r+0x5fc>
800071a4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800071a8:	40 3e       	lddsp	lr,sp[0xc]
800071aa:	58 0e       	cp.w	lr,0
800071ac:	c0 80       	breq	800071bc <_vfprintf_r+0x5e8>
800071ae:	10 36       	cp.w	r6,r8
800071b0:	c6 94       	brge	80007282 <_vfprintf_r+0x6ae>
800071b2:	fa cc f9 44 	sub	r12,sp,-1724
800071b6:	f8 06 00 36 	add	r6,r12,r6<<0x3
800071ba:	c8 28       	rjmp	800072be <_vfprintf_r+0x6ea>
800071bc:	ee ca ff ff 	sub	r10,r7,-1
800071c0:	10 37       	cp.w	r7,r8
800071c2:	e0 84 00 81 	brge	800072c4 <_vfprintf_r+0x6f0>
800071c6:	fa cb f9 44 	sub	r11,sp,-1724
800071ca:	f6 06 00 36 	add	r6,r11,r6<<0x3
800071ce:	c7 78       	rjmp	800072bc <_vfprintf_r+0x6e8>
800071d0:	ed b5 00 06 	bld	r5,0x6
800071d4:	c4 b1       	brne	8000726a <_vfprintf_r+0x696>
800071d6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800071da:	40 3c       	lddsp	r12,sp[0xc]
800071dc:	58 0c       	cp.w	r12,0
800071de:	c1 d0       	breq	80007218 <_vfprintf_r+0x644>
800071e0:	10 36       	cp.w	r6,r8
800071e2:	c0 64       	brge	800071ee <_vfprintf_r+0x61a>
800071e4:	fa cb f9 44 	sub	r11,sp,-1724
800071e8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800071ec:	c1 f8       	rjmp	8000722a <_vfprintf_r+0x656>
800071ee:	fa c8 f9 50 	sub	r8,sp,-1712
800071f2:	1a d8       	st.w	--sp,r8
800071f4:	fa c8 fa b8 	sub	r8,sp,-1352
800071f8:	1a d8       	st.w	--sp,r8
800071fa:	fa c8 fb b4 	sub	r8,sp,-1100
800071fe:	1a d8       	st.w	--sp,r8
80007200:	fa c8 f9 40 	sub	r8,sp,-1728
80007204:	fa c9 ff b4 	sub	r9,sp,-76
80007208:	04 9a       	mov	r10,r2
8000720a:	0c 9b       	mov	r11,r6
8000720c:	08 9c       	mov	r12,r4
8000720e:	fe b0 fb 4b 	rcall	800068a4 <get_arg>
80007212:	2f dd       	sub	sp,-12
80007214:	98 18       	ld.sh	r8,r12[0x2]
80007216:	c2 68       	rjmp	80007262 <_vfprintf_r+0x68e>
80007218:	ee ca ff ff 	sub	r10,r7,-1
8000721c:	10 37       	cp.w	r7,r8
8000721e:	c0 94       	brge	80007230 <_vfprintf_r+0x65c>
80007220:	fa c9 f9 44 	sub	r9,sp,-1724
80007224:	14 97       	mov	r7,r10
80007226:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000722a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000722e:	c1 a8       	rjmp	80007262 <_vfprintf_r+0x68e>
80007230:	41 09       	lddsp	r9,sp[0x40]
80007232:	59 f8       	cp.w	r8,31
80007234:	e0 89 00 13 	brgt	8000725a <_vfprintf_r+0x686>
80007238:	f2 cb ff fc 	sub	r11,r9,-4
8000723c:	51 0b       	stdsp	sp[0x40],r11
8000723e:	72 09       	ld.w	r9,r9[0x0]
80007240:	fa c6 f9 44 	sub	r6,sp,-1724
80007244:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007248:	2f f8       	sub	r8,-1
8000724a:	f7 49 fd 88 	st.w	r11[-632],r9
8000724e:	fb 48 06 b4 	st.w	sp[1716],r8
80007252:	14 97       	mov	r7,r10
80007254:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007258:	c0 58       	rjmp	80007262 <_vfprintf_r+0x68e>
8000725a:	92 18       	ld.sh	r8,r9[0x2]
8000725c:	14 97       	mov	r7,r10
8000725e:	2f c9       	sub	r9,-4
80007260:	51 09       	stdsp	sp[0x40],r9
80007262:	50 18       	stdsp	sp[0x4],r8
80007264:	bf 58       	asr	r8,0x1f
80007266:	50 08       	stdsp	sp[0x0],r8
80007268:	c4 88       	rjmp	800072f8 <_vfprintf_r+0x724>
8000726a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000726e:	40 3c       	lddsp	r12,sp[0xc]
80007270:	58 0c       	cp.w	r12,0
80007272:	c1 d0       	breq	800072ac <_vfprintf_r+0x6d8>
80007274:	10 36       	cp.w	r6,r8
80007276:	c0 64       	brge	80007282 <_vfprintf_r+0x6ae>
80007278:	fa cb f9 44 	sub	r11,sp,-1724
8000727c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007280:	c1 f8       	rjmp	800072be <_vfprintf_r+0x6ea>
80007282:	fa c8 f9 50 	sub	r8,sp,-1712
80007286:	1a d8       	st.w	--sp,r8
80007288:	fa c8 fa b8 	sub	r8,sp,-1352
8000728c:	0c 9b       	mov	r11,r6
8000728e:	1a d8       	st.w	--sp,r8
80007290:	fa c8 fb b4 	sub	r8,sp,-1100
80007294:	04 9a       	mov	r10,r2
80007296:	1a d8       	st.w	--sp,r8
80007298:	08 9c       	mov	r12,r4
8000729a:	fa c8 f9 40 	sub	r8,sp,-1728
8000729e:	fa c9 ff b4 	sub	r9,sp,-76
800072a2:	fe b0 fb 01 	rcall	800068a4 <get_arg>
800072a6:	2f dd       	sub	sp,-12
800072a8:	78 0b       	ld.w	r11,r12[0x0]
800072aa:	c2 48       	rjmp	800072f2 <_vfprintf_r+0x71e>
800072ac:	ee ca ff ff 	sub	r10,r7,-1
800072b0:	10 37       	cp.w	r7,r8
800072b2:	c0 94       	brge	800072c4 <_vfprintf_r+0x6f0>
800072b4:	fa c9 f9 44 	sub	r9,sp,-1724
800072b8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800072bc:	14 97       	mov	r7,r10
800072be:	ec fb fd 88 	ld.w	r11,r6[-632]
800072c2:	c1 88       	rjmp	800072f2 <_vfprintf_r+0x71e>
800072c4:	41 09       	lddsp	r9,sp[0x40]
800072c6:	59 f8       	cp.w	r8,31
800072c8:	e0 89 00 11 	brgt	800072ea <_vfprintf_r+0x716>
800072cc:	f2 cb ff fc 	sub	r11,r9,-4
800072d0:	51 0b       	stdsp	sp[0x40],r11
800072d2:	fa c6 f9 44 	sub	r6,sp,-1724
800072d6:	72 0b       	ld.w	r11,r9[0x0]
800072d8:	ec 08 00 39 	add	r9,r6,r8<<0x3
800072dc:	f3 4b fd 88 	st.w	r9[-632],r11
800072e0:	2f f8       	sub	r8,-1
800072e2:	14 97       	mov	r7,r10
800072e4:	fb 48 06 b4 	st.w	sp[1716],r8
800072e8:	c0 58       	rjmp	800072f2 <_vfprintf_r+0x71e>
800072ea:	72 0b       	ld.w	r11,r9[0x0]
800072ec:	14 97       	mov	r7,r10
800072ee:	2f c9       	sub	r9,-4
800072f0:	51 09       	stdsp	sp[0x40],r9
800072f2:	50 1b       	stdsp	sp[0x4],r11
800072f4:	bf 5b       	asr	r11,0x1f
800072f6:	50 0b       	stdsp	sp[0x0],r11
800072f8:	fa ea 00 00 	ld.d	r10,sp[0]
800072fc:	58 0a       	cp.w	r10,0
800072fe:	5c 2b       	cpc	r11
80007300:	c0 e4       	brge	8000731c <_vfprintf_r+0x748>
80007302:	30 08       	mov	r8,0
80007304:	fa ea 00 00 	ld.d	r10,sp[0]
80007308:	30 09       	mov	r9,0
8000730a:	f0 0a 01 0a 	sub	r10,r8,r10
8000730e:	f2 0b 01 4b 	sbc	r11,r9,r11
80007312:	32 d8       	mov	r8,45
80007314:	fa eb 00 00 	st.d	sp[0],r10
80007318:	fb 68 06 bb 	st.b	sp[1723],r8
8000731c:	30 18       	mov	r8,1
8000731e:	e0 8f 06 fa 	bral	80008112 <_vfprintf_r+0x153e>
80007322:	50 a7       	stdsp	sp[0x28],r7
80007324:	50 80       	stdsp	sp[0x20],r0
80007326:	0c 97       	mov	r7,r6
80007328:	04 94       	mov	r4,r2
8000732a:	06 96       	mov	r6,r3
8000732c:	02 92       	mov	r2,r1
8000732e:	40 93       	lddsp	r3,sp[0x24]
80007330:	10 90       	mov	r0,r8
80007332:	40 41       	lddsp	r1,sp[0x10]
80007334:	0e 99       	mov	r9,r7
80007336:	ed b5 00 03 	bld	r5,0x3
8000733a:	c4 11       	brne	800073bc <_vfprintf_r+0x7e8>
8000733c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007340:	40 3a       	lddsp	r10,sp[0xc]
80007342:	58 0a       	cp.w	r10,0
80007344:	c1 90       	breq	80007376 <_vfprintf_r+0x7a2>
80007346:	10 36       	cp.w	r6,r8
80007348:	c6 45       	brlt	80007410 <_vfprintf_r+0x83c>
8000734a:	fa c8 f9 50 	sub	r8,sp,-1712
8000734e:	1a d8       	st.w	--sp,r8
80007350:	fa c8 fa b8 	sub	r8,sp,-1352
80007354:	1a d8       	st.w	--sp,r8
80007356:	fa c8 fb b4 	sub	r8,sp,-1100
8000735a:	0c 9b       	mov	r11,r6
8000735c:	1a d8       	st.w	--sp,r8
8000735e:	04 9a       	mov	r10,r2
80007360:	fa c8 f9 40 	sub	r8,sp,-1728
80007364:	fa c9 ff b4 	sub	r9,sp,-76
80007368:	08 9c       	mov	r12,r4
8000736a:	fe b0 fa 9d 	rcall	800068a4 <get_arg>
8000736e:	2f dd       	sub	sp,-12
80007370:	78 16       	ld.w	r6,r12[0x4]
80007372:	50 76       	stdsp	sp[0x1c],r6
80007374:	c4 88       	rjmp	80007404 <_vfprintf_r+0x830>
80007376:	2f f7       	sub	r7,-1
80007378:	10 39       	cp.w	r9,r8
8000737a:	c0 c4       	brge	80007392 <_vfprintf_r+0x7be>
8000737c:	fa ce f9 44 	sub	lr,sp,-1724
80007380:	fc 06 00 36 	add	r6,lr,r6<<0x3
80007384:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007388:	50 7c       	stdsp	sp[0x1c],r12
8000738a:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000738e:	50 56       	stdsp	sp[0x14],r6
80007390:	c6 68       	rjmp	8000745c <_vfprintf_r+0x888>
80007392:	41 09       	lddsp	r9,sp[0x40]
80007394:	59 f8       	cp.w	r8,31
80007396:	e0 89 00 10 	brgt	800073b6 <_vfprintf_r+0x7e2>
8000739a:	f2 ca ff f8 	sub	r10,r9,-8
8000739e:	72 1b       	ld.w	r11,r9[0x4]
800073a0:	51 0a       	stdsp	sp[0x40],r10
800073a2:	72 09       	ld.w	r9,r9[0x0]
800073a4:	fa ca f9 44 	sub	r10,sp,-1724
800073a8:	50 7b       	stdsp	sp[0x1c],r11
800073aa:	50 59       	stdsp	sp[0x14],r9
800073ac:	f4 08 00 39 	add	r9,r10,r8<<0x3
800073b0:	40 5b       	lddsp	r11,sp[0x14]
800073b2:	40 7a       	lddsp	r10,sp[0x1c]
800073b4:	c4 78       	rjmp	80007442 <_vfprintf_r+0x86e>
800073b6:	72 18       	ld.w	r8,r9[0x4]
800073b8:	50 78       	stdsp	sp[0x1c],r8
800073ba:	c4 c8       	rjmp	80007452 <_vfprintf_r+0x87e>
800073bc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800073c0:	40 3e       	lddsp	lr,sp[0xc]
800073c2:	58 0e       	cp.w	lr,0
800073c4:	c2 30       	breq	8000740a <_vfprintf_r+0x836>
800073c6:	10 36       	cp.w	r6,r8
800073c8:	c0 94       	brge	800073da <_vfprintf_r+0x806>
800073ca:	fa cc f9 44 	sub	r12,sp,-1724
800073ce:	f8 06 00 36 	add	r6,r12,r6<<0x3
800073d2:	ec fb fd 8c 	ld.w	r11,r6[-628]
800073d6:	50 7b       	stdsp	sp[0x1c],r11
800073d8:	cd 9b       	rjmp	8000738a <_vfprintf_r+0x7b6>
800073da:	fa c8 f9 50 	sub	r8,sp,-1712
800073de:	1a d8       	st.w	--sp,r8
800073e0:	fa c8 fa b8 	sub	r8,sp,-1352
800073e4:	04 9a       	mov	r10,r2
800073e6:	1a d8       	st.w	--sp,r8
800073e8:	fa c8 fb b4 	sub	r8,sp,-1100
800073ec:	0c 9b       	mov	r11,r6
800073ee:	1a d8       	st.w	--sp,r8
800073f0:	08 9c       	mov	r12,r4
800073f2:	fa c8 f9 40 	sub	r8,sp,-1728
800073f6:	fa c9 ff b4 	sub	r9,sp,-76
800073fa:	fe b0 fa 55 	rcall	800068a4 <get_arg>
800073fe:	2f dd       	sub	sp,-12
80007400:	78 1a       	ld.w	r10,r12[0x4]
80007402:	50 7a       	stdsp	sp[0x1c],r10
80007404:	78 0c       	ld.w	r12,r12[0x0]
80007406:	50 5c       	stdsp	sp[0x14],r12
80007408:	c2 a8       	rjmp	8000745c <_vfprintf_r+0x888>
8000740a:	2f f7       	sub	r7,-1
8000740c:	10 39       	cp.w	r9,r8
8000740e:	c0 94       	brge	80007420 <_vfprintf_r+0x84c>
80007410:	fa c9 f9 44 	sub	r9,sp,-1724
80007414:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007418:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000741c:	50 78       	stdsp	sp[0x1c],r8
8000741e:	cb 6b       	rjmp	8000738a <_vfprintf_r+0x7b6>
80007420:	41 09       	lddsp	r9,sp[0x40]
80007422:	59 f8       	cp.w	r8,31
80007424:	e0 89 00 15 	brgt	8000744e <_vfprintf_r+0x87a>
80007428:	f2 ca ff f8 	sub	r10,r9,-8
8000742c:	72 16       	ld.w	r6,r9[0x4]
8000742e:	72 09       	ld.w	r9,r9[0x0]
80007430:	51 0a       	stdsp	sp[0x40],r10
80007432:	50 59       	stdsp	sp[0x14],r9
80007434:	fa ce f9 44 	sub	lr,sp,-1724
80007438:	50 76       	stdsp	sp[0x1c],r6
8000743a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000743e:	40 5b       	lddsp	r11,sp[0x14]
80007440:	0c 9a       	mov	r10,r6
80007442:	f2 eb fd 88 	st.d	r9[-632],r10
80007446:	2f f8       	sub	r8,-1
80007448:	fb 48 06 b4 	st.w	sp[1716],r8
8000744c:	c0 88       	rjmp	8000745c <_vfprintf_r+0x888>
8000744e:	72 1c       	ld.w	r12,r9[0x4]
80007450:	50 7c       	stdsp	sp[0x1c],r12
80007452:	f2 c8 ff f8 	sub	r8,r9,-8
80007456:	51 08       	stdsp	sp[0x40],r8
80007458:	72 09       	ld.w	r9,r9[0x0]
8000745a:	50 59       	stdsp	sp[0x14],r9
8000745c:	40 5b       	lddsp	r11,sp[0x14]
8000745e:	40 7a       	lddsp	r10,sp[0x1c]
80007460:	e0 a0 19 54 	rcall	8000a708 <__isinfd>
80007464:	18 96       	mov	r6,r12
80007466:	c1 70       	breq	80007494 <_vfprintf_r+0x8c0>
80007468:	30 08       	mov	r8,0
8000746a:	30 09       	mov	r9,0
8000746c:	40 5b       	lddsp	r11,sp[0x14]
8000746e:	40 7a       	lddsp	r10,sp[0x1c]
80007470:	e0 a0 1d a8 	rcall	8000afc0 <__avr32_f64_cmp_lt>
80007474:	c0 40       	breq	8000747c <_vfprintf_r+0x8a8>
80007476:	32 d8       	mov	r8,45
80007478:	fb 68 06 bb 	st.b	sp[1723],r8
8000747c:	fe c8 ab f8 	sub	r8,pc,-21512
80007480:	fe c6 ab f8 	sub	r6,pc,-21512
80007484:	a7 d5       	cbr	r5,0x7
80007486:	e0 40 00 47 	cp.w	r0,71
8000748a:	f0 06 17 a0 	movle	r6,r8
8000748e:	30 32       	mov	r2,3
80007490:	e0 8f 06 ce 	bral	8000822c <_vfprintf_r+0x1658>
80007494:	40 5b       	lddsp	r11,sp[0x14]
80007496:	40 7a       	lddsp	r10,sp[0x1c]
80007498:	e0 a0 19 4d 	rcall	8000a732 <__isnand>
8000749c:	c0 e0       	breq	800074b8 <_vfprintf_r+0x8e4>
8000749e:	50 26       	stdsp	sp[0x8],r6
800074a0:	fe c8 ac 14 	sub	r8,pc,-21484
800074a4:	fe c6 ac 14 	sub	r6,pc,-21484
800074a8:	a7 d5       	cbr	r5,0x7
800074aa:	e0 40 00 47 	cp.w	r0,71
800074ae:	f0 06 17 a0 	movle	r6,r8
800074b2:	30 32       	mov	r2,3
800074b4:	e0 8f 06 c2 	bral	80008238 <_vfprintf_r+0x1664>
800074b8:	40 2a       	lddsp	r10,sp[0x8]
800074ba:	5b fa       	cp.w	r10,-1
800074bc:	c0 41       	brne	800074c4 <_vfprintf_r+0x8f0>
800074be:	30 69       	mov	r9,6
800074c0:	50 29       	stdsp	sp[0x8],r9
800074c2:	c1 18       	rjmp	800074e4 <_vfprintf_r+0x910>
800074c4:	e0 40 00 47 	cp.w	r0,71
800074c8:	5f 09       	sreq	r9
800074ca:	e0 40 00 67 	cp.w	r0,103
800074ce:	5f 08       	sreq	r8
800074d0:	f3 e8 10 08 	or	r8,r9,r8
800074d4:	f8 08 18 00 	cp.b	r8,r12
800074d8:	c0 60       	breq	800074e4 <_vfprintf_r+0x910>
800074da:	40 28       	lddsp	r8,sp[0x8]
800074dc:	58 08       	cp.w	r8,0
800074de:	f9 b8 00 01 	moveq	r8,1
800074e2:	50 28       	stdsp	sp[0x8],r8
800074e4:	40 78       	lddsp	r8,sp[0x1c]
800074e6:	40 59       	lddsp	r9,sp[0x14]
800074e8:	fa e9 06 94 	st.d	sp[1684],r8
800074ec:	a9 a5       	sbr	r5,0x8
800074ee:	fa f8 06 94 	ld.w	r8,sp[1684]
800074f2:	58 08       	cp.w	r8,0
800074f4:	c0 65       	brlt	80007500 <_vfprintf_r+0x92c>
800074f6:	40 5e       	lddsp	lr,sp[0x14]
800074f8:	30 0c       	mov	r12,0
800074fa:	50 6e       	stdsp	sp[0x18],lr
800074fc:	50 9c       	stdsp	sp[0x24],r12
800074fe:	c0 78       	rjmp	8000750c <_vfprintf_r+0x938>
80007500:	40 5b       	lddsp	r11,sp[0x14]
80007502:	32 da       	mov	r10,45
80007504:	ee 1b 80 00 	eorh	r11,0x8000
80007508:	50 9a       	stdsp	sp[0x24],r10
8000750a:	50 6b       	stdsp	sp[0x18],r11
8000750c:	e0 40 00 46 	cp.w	r0,70
80007510:	5f 09       	sreq	r9
80007512:	e0 40 00 66 	cp.w	r0,102
80007516:	5f 08       	sreq	r8
80007518:	f3 e8 10 08 	or	r8,r9,r8
8000751c:	50 48       	stdsp	sp[0x10],r8
8000751e:	c0 40       	breq	80007526 <_vfprintf_r+0x952>
80007520:	40 22       	lddsp	r2,sp[0x8]
80007522:	30 39       	mov	r9,3
80007524:	c1 08       	rjmp	80007544 <_vfprintf_r+0x970>
80007526:	e0 40 00 45 	cp.w	r0,69
8000752a:	5f 09       	sreq	r9
8000752c:	e0 40 00 65 	cp.w	r0,101
80007530:	5f 08       	sreq	r8
80007532:	40 22       	lddsp	r2,sp[0x8]
80007534:	10 49       	or	r9,r8
80007536:	2f f2       	sub	r2,-1
80007538:	40 46       	lddsp	r6,sp[0x10]
8000753a:	ec 09 18 00 	cp.b	r9,r6
8000753e:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80007542:	30 29       	mov	r9,2
80007544:	fa c8 f9 5c 	sub	r8,sp,-1700
80007548:	1a d8       	st.w	--sp,r8
8000754a:	fa c8 f9 54 	sub	r8,sp,-1708
8000754e:	1a d8       	st.w	--sp,r8
80007550:	fa c8 f9 4c 	sub	r8,sp,-1716
80007554:	08 9c       	mov	r12,r4
80007556:	1a d8       	st.w	--sp,r8
80007558:	04 98       	mov	r8,r2
8000755a:	40 9b       	lddsp	r11,sp[0x24]
8000755c:	40 aa       	lddsp	r10,sp[0x28]
8000755e:	e0 a0 0b c3 	rcall	80008ce4 <_dtoa_r>
80007562:	e0 40 00 47 	cp.w	r0,71
80007566:	5f 19       	srne	r9
80007568:	e0 40 00 67 	cp.w	r0,103
8000756c:	5f 18       	srne	r8
8000756e:	18 96       	mov	r6,r12
80007570:	2f dd       	sub	sp,-12
80007572:	f3 e8 00 08 	and	r8,r9,r8
80007576:	c0 41       	brne	8000757e <_vfprintf_r+0x9aa>
80007578:	ed b5 00 00 	bld	r5,0x0
8000757c:	c3 01       	brne	800075dc <_vfprintf_r+0xa08>
8000757e:	ec 02 00 0e 	add	lr,r6,r2
80007582:	50 3e       	stdsp	sp[0xc],lr
80007584:	40 4c       	lddsp	r12,sp[0x10]
80007586:	58 0c       	cp.w	r12,0
80007588:	c1 50       	breq	800075b2 <_vfprintf_r+0x9de>
8000758a:	0d 89       	ld.ub	r9,r6[0x0]
8000758c:	33 08       	mov	r8,48
8000758e:	f0 09 18 00 	cp.b	r9,r8
80007592:	c0 b1       	brne	800075a8 <_vfprintf_r+0x9d4>
80007594:	30 08       	mov	r8,0
80007596:	30 09       	mov	r9,0
80007598:	40 6b       	lddsp	r11,sp[0x18]
8000759a:	40 7a       	lddsp	r10,sp[0x1c]
8000759c:	e0 a0 1c cb 	rcall	8000af32 <__avr32_f64_cmp_eq>
800075a0:	fb b2 00 01 	rsubeq	r2,1
800075a4:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
800075a8:	40 3b       	lddsp	r11,sp[0xc]
800075aa:	fa f8 06 ac 	ld.w	r8,sp[1708]
800075ae:	10 0b       	add	r11,r8
800075b0:	50 3b       	stdsp	sp[0xc],r11
800075b2:	40 6b       	lddsp	r11,sp[0x18]
800075b4:	30 08       	mov	r8,0
800075b6:	30 09       	mov	r9,0
800075b8:	40 7a       	lddsp	r10,sp[0x1c]
800075ba:	e0 a0 1c bc 	rcall	8000af32 <__avr32_f64_cmp_eq>
800075be:	c0 90       	breq	800075d0 <_vfprintf_r+0x9fc>
800075c0:	40 3a       	lddsp	r10,sp[0xc]
800075c2:	fb 4a 06 a4 	st.w	sp[1700],r10
800075c6:	c0 58       	rjmp	800075d0 <_vfprintf_r+0x9fc>
800075c8:	10 c9       	st.b	r8++,r9
800075ca:	fb 48 06 a4 	st.w	sp[1700],r8
800075ce:	c0 28       	rjmp	800075d2 <_vfprintf_r+0x9fe>
800075d0:	33 09       	mov	r9,48
800075d2:	fa f8 06 a4 	ld.w	r8,sp[1700]
800075d6:	40 3e       	lddsp	lr,sp[0xc]
800075d8:	1c 38       	cp.w	r8,lr
800075da:	cf 73       	brcs	800075c8 <_vfprintf_r+0x9f4>
800075dc:	e0 40 00 47 	cp.w	r0,71
800075e0:	5f 09       	sreq	r9
800075e2:	e0 40 00 67 	cp.w	r0,103
800075e6:	5f 08       	sreq	r8
800075e8:	f3 e8 10 08 	or	r8,r9,r8
800075ec:	fa f9 06 a4 	ld.w	r9,sp[1700]
800075f0:	0c 19       	sub	r9,r6
800075f2:	50 69       	stdsp	sp[0x18],r9
800075f4:	58 08       	cp.w	r8,0
800075f6:	c0 b0       	breq	8000760c <_vfprintf_r+0xa38>
800075f8:	fa f8 06 ac 	ld.w	r8,sp[1708]
800075fc:	5b d8       	cp.w	r8,-3
800075fe:	c0 55       	brlt	80007608 <_vfprintf_r+0xa34>
80007600:	40 2c       	lddsp	r12,sp[0x8]
80007602:	18 38       	cp.w	r8,r12
80007604:	e0 8a 00 6a 	brle	800076d8 <_vfprintf_r+0xb04>
80007608:	20 20       	sub	r0,2
8000760a:	c0 58       	rjmp	80007614 <_vfprintf_r+0xa40>
8000760c:	e0 40 00 65 	cp.w	r0,101
80007610:	e0 89 00 46 	brgt	8000769c <_vfprintf_r+0xac8>
80007614:	fa fb 06 ac 	ld.w	r11,sp[1708]
80007618:	fb 60 06 9c 	st.b	sp[1692],r0
8000761c:	20 1b       	sub	r11,1
8000761e:	fb 4b 06 ac 	st.w	sp[1708],r11
80007622:	c0 47       	brpl	8000762a <_vfprintf_r+0xa56>
80007624:	5c 3b       	neg	r11
80007626:	32 d8       	mov	r8,45
80007628:	c0 28       	rjmp	8000762c <_vfprintf_r+0xa58>
8000762a:	32 b8       	mov	r8,43
8000762c:	fb 68 06 9d 	st.b	sp[1693],r8
80007630:	58 9b       	cp.w	r11,9
80007632:	e0 8a 00 1d 	brle	8000766c <_vfprintf_r+0xa98>
80007636:	fa c9 fa 35 	sub	r9,sp,-1483
8000763a:	30 aa       	mov	r10,10
8000763c:	12 98       	mov	r8,r9
8000763e:	0e 9c       	mov	r12,r7
80007640:	0c 92       	mov	r2,r6
80007642:	f6 0a 0c 06 	divs	r6,r11,r10
80007646:	0e 9b       	mov	r11,r7
80007648:	2d 0b       	sub	r11,-48
8000764a:	10 fb       	st.b	--r8,r11
8000764c:	0c 9b       	mov	r11,r6
8000764e:	58 96       	cp.w	r6,9
80007650:	fe 99 ff f9 	brgt	80007642 <_vfprintf_r+0xa6e>
80007654:	2d 0b       	sub	r11,-48
80007656:	18 97       	mov	r7,r12
80007658:	04 96       	mov	r6,r2
8000765a:	10 fb       	st.b	--r8,r11
8000765c:	fa ca f9 62 	sub	r10,sp,-1694
80007660:	c0 38       	rjmp	80007666 <_vfprintf_r+0xa92>
80007662:	11 3b       	ld.ub	r11,r8++
80007664:	14 cb       	st.b	r10++,r11
80007666:	12 38       	cp.w	r8,r9
80007668:	cf d3       	brcs	80007662 <_vfprintf_r+0xa8e>
8000766a:	c0 98       	rjmp	8000767c <_vfprintf_r+0xaa8>
8000766c:	2d 0b       	sub	r11,-48
8000766e:	33 08       	mov	r8,48
80007670:	fb 6b 06 9f 	st.b	sp[1695],r11
80007674:	fb 68 06 9e 	st.b	sp[1694],r8
80007678:	fa ca f9 60 	sub	r10,sp,-1696
8000767c:	fa c8 f9 64 	sub	r8,sp,-1692
80007680:	f4 08 01 08 	sub	r8,r10,r8
80007684:	50 e8       	stdsp	sp[0x38],r8
80007686:	10 92       	mov	r2,r8
80007688:	40 6b       	lddsp	r11,sp[0x18]
8000768a:	16 02       	add	r2,r11
8000768c:	58 1b       	cp.w	r11,1
8000768e:	e0 89 00 05 	brgt	80007698 <_vfprintf_r+0xac4>
80007692:	ed b5 00 00 	bld	r5,0x0
80007696:	c3 51       	brne	80007700 <_vfprintf_r+0xb2c>
80007698:	2f f2       	sub	r2,-1
8000769a:	c3 38       	rjmp	80007700 <_vfprintf_r+0xb2c>
8000769c:	e0 40 00 66 	cp.w	r0,102
800076a0:	c1 c1       	brne	800076d8 <_vfprintf_r+0xb04>
800076a2:	fa f2 06 ac 	ld.w	r2,sp[1708]
800076a6:	58 02       	cp.w	r2,0
800076a8:	e0 8a 00 0c 	brle	800076c0 <_vfprintf_r+0xaec>
800076ac:	40 2a       	lddsp	r10,sp[0x8]
800076ae:	58 0a       	cp.w	r10,0
800076b0:	c0 41       	brne	800076b8 <_vfprintf_r+0xae4>
800076b2:	ed b5 00 00 	bld	r5,0x0
800076b6:	c2 51       	brne	80007700 <_vfprintf_r+0xb2c>
800076b8:	2f f2       	sub	r2,-1
800076ba:	40 29       	lddsp	r9,sp[0x8]
800076bc:	12 02       	add	r2,r9
800076be:	c0 b8       	rjmp	800076d4 <_vfprintf_r+0xb00>
800076c0:	40 28       	lddsp	r8,sp[0x8]
800076c2:	58 08       	cp.w	r8,0
800076c4:	c0 61       	brne	800076d0 <_vfprintf_r+0xafc>
800076c6:	ed b5 00 00 	bld	r5,0x0
800076ca:	c0 30       	breq	800076d0 <_vfprintf_r+0xafc>
800076cc:	30 12       	mov	r2,1
800076ce:	c1 98       	rjmp	80007700 <_vfprintf_r+0xb2c>
800076d0:	40 22       	lddsp	r2,sp[0x8]
800076d2:	2f e2       	sub	r2,-2
800076d4:	36 60       	mov	r0,102
800076d6:	c1 58       	rjmp	80007700 <_vfprintf_r+0xb2c>
800076d8:	fa f2 06 ac 	ld.w	r2,sp[1708]
800076dc:	40 6e       	lddsp	lr,sp[0x18]
800076de:	1c 32       	cp.w	r2,lr
800076e0:	c0 65       	brlt	800076ec <_vfprintf_r+0xb18>
800076e2:	ed b5 00 00 	bld	r5,0x0
800076e6:	f7 b2 00 ff 	subeq	r2,-1
800076ea:	c0 a8       	rjmp	800076fe <_vfprintf_r+0xb2a>
800076ec:	e4 08 11 02 	rsub	r8,r2,2
800076f0:	40 6c       	lddsp	r12,sp[0x18]
800076f2:	58 02       	cp.w	r2,0
800076f4:	f0 02 17 a0 	movle	r2,r8
800076f8:	f9 b2 09 01 	movgt	r2,1
800076fc:	18 02       	add	r2,r12
800076fe:	36 70       	mov	r0,103
80007700:	40 9b       	lddsp	r11,sp[0x24]
80007702:	58 0b       	cp.w	r11,0
80007704:	e0 80 05 94 	breq	8000822c <_vfprintf_r+0x1658>
80007708:	32 d8       	mov	r8,45
8000770a:	fb 68 06 bb 	st.b	sp[1723],r8
8000770e:	e0 8f 05 93 	bral	80008234 <_vfprintf_r+0x1660>
80007712:	50 a7       	stdsp	sp[0x28],r7
80007714:	04 94       	mov	r4,r2
80007716:	0c 97       	mov	r7,r6
80007718:	02 92       	mov	r2,r1
8000771a:	06 96       	mov	r6,r3
8000771c:	40 41       	lddsp	r1,sp[0x10]
8000771e:	40 93       	lddsp	r3,sp[0x24]
80007720:	0e 99       	mov	r9,r7
80007722:	ed b5 00 05 	bld	r5,0x5
80007726:	c4 81       	brne	800077b6 <_vfprintf_r+0xbe2>
80007728:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000772c:	40 3e       	lddsp	lr,sp[0xc]
8000772e:	58 0e       	cp.w	lr,0
80007730:	c1 d0       	breq	8000776a <_vfprintf_r+0xb96>
80007732:	10 36       	cp.w	r6,r8
80007734:	c0 64       	brge	80007740 <_vfprintf_r+0xb6c>
80007736:	fa cc f9 44 	sub	r12,sp,-1724
8000773a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000773e:	c1 d8       	rjmp	80007778 <_vfprintf_r+0xba4>
80007740:	fa c8 f9 50 	sub	r8,sp,-1712
80007744:	1a d8       	st.w	--sp,r8
80007746:	fa c8 fa b8 	sub	r8,sp,-1352
8000774a:	04 9a       	mov	r10,r2
8000774c:	1a d8       	st.w	--sp,r8
8000774e:	fa c8 fb b4 	sub	r8,sp,-1100
80007752:	0c 9b       	mov	r11,r6
80007754:	1a d8       	st.w	--sp,r8
80007756:	08 9c       	mov	r12,r4
80007758:	fa c8 f9 40 	sub	r8,sp,-1728
8000775c:	fa c9 ff b4 	sub	r9,sp,-76
80007760:	fe b0 f8 a2 	rcall	800068a4 <get_arg>
80007764:	2f dd       	sub	sp,-12
80007766:	78 0a       	ld.w	r10,r12[0x0]
80007768:	c2 08       	rjmp	800077a8 <_vfprintf_r+0xbd4>
8000776a:	2f f7       	sub	r7,-1
8000776c:	10 39       	cp.w	r9,r8
8000776e:	c0 84       	brge	8000777e <_vfprintf_r+0xbaa>
80007770:	fa cb f9 44 	sub	r11,sp,-1724
80007774:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007778:	ec fa fd 88 	ld.w	r10,r6[-632]
8000777c:	c1 68       	rjmp	800077a8 <_vfprintf_r+0xbd4>
8000777e:	41 09       	lddsp	r9,sp[0x40]
80007780:	59 f8       	cp.w	r8,31
80007782:	e0 89 00 10 	brgt	800077a2 <_vfprintf_r+0xbce>
80007786:	f2 ca ff fc 	sub	r10,r9,-4
8000778a:	51 0a       	stdsp	sp[0x40],r10
8000778c:	fa c6 f9 44 	sub	r6,sp,-1724
80007790:	72 0a       	ld.w	r10,r9[0x0]
80007792:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007796:	f3 4a fd 88 	st.w	r9[-632],r10
8000779a:	2f f8       	sub	r8,-1
8000779c:	fb 48 06 b4 	st.w	sp[1716],r8
800077a0:	c0 48       	rjmp	800077a8 <_vfprintf_r+0xbd4>
800077a2:	72 0a       	ld.w	r10,r9[0x0]
800077a4:	2f c9       	sub	r9,-4
800077a6:	51 09       	stdsp	sp[0x40],r9
800077a8:	40 be       	lddsp	lr,sp[0x2c]
800077aa:	1c 98       	mov	r8,lr
800077ac:	95 1e       	st.w	r10[0x4],lr
800077ae:	bf 58       	asr	r8,0x1f
800077b0:	95 08       	st.w	r10[0x0],r8
800077b2:	fe 9f fa 9f 	bral	80006cf0 <_vfprintf_r+0x11c>
800077b6:	ed b5 00 04 	bld	r5,0x4
800077ba:	c4 80       	breq	8000784a <_vfprintf_r+0xc76>
800077bc:	e2 15 00 40 	andl	r5,0x40,COH
800077c0:	c4 50       	breq	8000784a <_vfprintf_r+0xc76>
800077c2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800077c6:	40 3c       	lddsp	r12,sp[0xc]
800077c8:	58 0c       	cp.w	r12,0
800077ca:	c1 d0       	breq	80007804 <_vfprintf_r+0xc30>
800077cc:	10 36       	cp.w	r6,r8
800077ce:	c0 64       	brge	800077da <_vfprintf_r+0xc06>
800077d0:	fa cb f9 44 	sub	r11,sp,-1724
800077d4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800077d8:	c1 d8       	rjmp	80007812 <_vfprintf_r+0xc3e>
800077da:	fa c8 f9 50 	sub	r8,sp,-1712
800077de:	1a d8       	st.w	--sp,r8
800077e0:	fa c8 fa b8 	sub	r8,sp,-1352
800077e4:	04 9a       	mov	r10,r2
800077e6:	1a d8       	st.w	--sp,r8
800077e8:	fa c8 fb b4 	sub	r8,sp,-1100
800077ec:	0c 9b       	mov	r11,r6
800077ee:	1a d8       	st.w	--sp,r8
800077f0:	08 9c       	mov	r12,r4
800077f2:	fa c8 f9 40 	sub	r8,sp,-1728
800077f6:	fa c9 ff b4 	sub	r9,sp,-76
800077fa:	fe b0 f8 55 	rcall	800068a4 <get_arg>
800077fe:	2f dd       	sub	sp,-12
80007800:	78 0a       	ld.w	r10,r12[0x0]
80007802:	c2 08       	rjmp	80007842 <_vfprintf_r+0xc6e>
80007804:	2f f7       	sub	r7,-1
80007806:	10 39       	cp.w	r9,r8
80007808:	c0 84       	brge	80007818 <_vfprintf_r+0xc44>
8000780a:	fa ca f9 44 	sub	r10,sp,-1724
8000780e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007812:	ec fa fd 88 	ld.w	r10,r6[-632]
80007816:	c1 68       	rjmp	80007842 <_vfprintf_r+0xc6e>
80007818:	41 09       	lddsp	r9,sp[0x40]
8000781a:	59 f8       	cp.w	r8,31
8000781c:	e0 89 00 10 	brgt	8000783c <_vfprintf_r+0xc68>
80007820:	f2 ca ff fc 	sub	r10,r9,-4
80007824:	51 0a       	stdsp	sp[0x40],r10
80007826:	fa c6 f9 44 	sub	r6,sp,-1724
8000782a:	72 0a       	ld.w	r10,r9[0x0]
8000782c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007830:	f3 4a fd 88 	st.w	r9[-632],r10
80007834:	2f f8       	sub	r8,-1
80007836:	fb 48 06 b4 	st.w	sp[1716],r8
8000783a:	c0 48       	rjmp	80007842 <_vfprintf_r+0xc6e>
8000783c:	72 0a       	ld.w	r10,r9[0x0]
8000783e:	2f c9       	sub	r9,-4
80007840:	51 09       	stdsp	sp[0x40],r9
80007842:	40 be       	lddsp	lr,sp[0x2c]
80007844:	b4 0e       	st.h	r10[0x0],lr
80007846:	fe 9f fa 55 	bral	80006cf0 <_vfprintf_r+0x11c>
8000784a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000784e:	40 3c       	lddsp	r12,sp[0xc]
80007850:	58 0c       	cp.w	r12,0
80007852:	c1 d0       	breq	8000788c <_vfprintf_r+0xcb8>
80007854:	10 36       	cp.w	r6,r8
80007856:	c0 64       	brge	80007862 <_vfprintf_r+0xc8e>
80007858:	fa cb f9 44 	sub	r11,sp,-1724
8000785c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007860:	c1 d8       	rjmp	8000789a <_vfprintf_r+0xcc6>
80007862:	fa c8 f9 50 	sub	r8,sp,-1712
80007866:	1a d8       	st.w	--sp,r8
80007868:	fa c8 fa b8 	sub	r8,sp,-1352
8000786c:	04 9a       	mov	r10,r2
8000786e:	1a d8       	st.w	--sp,r8
80007870:	fa c8 fb b4 	sub	r8,sp,-1100
80007874:	0c 9b       	mov	r11,r6
80007876:	1a d8       	st.w	--sp,r8
80007878:	08 9c       	mov	r12,r4
8000787a:	fa c8 f9 40 	sub	r8,sp,-1728
8000787e:	fa c9 ff b4 	sub	r9,sp,-76
80007882:	fe b0 f8 11 	rcall	800068a4 <get_arg>
80007886:	2f dd       	sub	sp,-12
80007888:	78 0a       	ld.w	r10,r12[0x0]
8000788a:	c2 08       	rjmp	800078ca <_vfprintf_r+0xcf6>
8000788c:	2f f7       	sub	r7,-1
8000788e:	10 39       	cp.w	r9,r8
80007890:	c0 84       	brge	800078a0 <_vfprintf_r+0xccc>
80007892:	fa ca f9 44 	sub	r10,sp,-1724
80007896:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000789a:	ec fa fd 88 	ld.w	r10,r6[-632]
8000789e:	c1 68       	rjmp	800078ca <_vfprintf_r+0xcf6>
800078a0:	41 09       	lddsp	r9,sp[0x40]
800078a2:	59 f8       	cp.w	r8,31
800078a4:	e0 89 00 10 	brgt	800078c4 <_vfprintf_r+0xcf0>
800078a8:	f2 ca ff fc 	sub	r10,r9,-4
800078ac:	51 0a       	stdsp	sp[0x40],r10
800078ae:	fa c6 f9 44 	sub	r6,sp,-1724
800078b2:	72 0a       	ld.w	r10,r9[0x0]
800078b4:	ec 08 00 39 	add	r9,r6,r8<<0x3
800078b8:	f3 4a fd 88 	st.w	r9[-632],r10
800078bc:	2f f8       	sub	r8,-1
800078be:	fb 48 06 b4 	st.w	sp[1716],r8
800078c2:	c0 48       	rjmp	800078ca <_vfprintf_r+0xcf6>
800078c4:	72 0a       	ld.w	r10,r9[0x0]
800078c6:	2f c9       	sub	r9,-4
800078c8:	51 09       	stdsp	sp[0x40],r9
800078ca:	40 be       	lddsp	lr,sp[0x2c]
800078cc:	95 0e       	st.w	r10[0x0],lr
800078ce:	fe 9f fa 11 	bral	80006cf0 <_vfprintf_r+0x11c>
800078d2:	50 a7       	stdsp	sp[0x28],r7
800078d4:	50 80       	stdsp	sp[0x20],r0
800078d6:	0c 97       	mov	r7,r6
800078d8:	04 94       	mov	r4,r2
800078da:	06 96       	mov	r6,r3
800078dc:	02 92       	mov	r2,r1
800078de:	40 93       	lddsp	r3,sp[0x24]
800078e0:	10 90       	mov	r0,r8
800078e2:	40 41       	lddsp	r1,sp[0x10]
800078e4:	a5 a5       	sbr	r5,0x4
800078e6:	c0 a8       	rjmp	800078fa <_vfprintf_r+0xd26>
800078e8:	50 a7       	stdsp	sp[0x28],r7
800078ea:	50 80       	stdsp	sp[0x20],r0
800078ec:	0c 97       	mov	r7,r6
800078ee:	04 94       	mov	r4,r2
800078f0:	06 96       	mov	r6,r3
800078f2:	02 92       	mov	r2,r1
800078f4:	40 93       	lddsp	r3,sp[0x24]
800078f6:	10 90       	mov	r0,r8
800078f8:	40 41       	lddsp	r1,sp[0x10]
800078fa:	ed b5 00 05 	bld	r5,0x5
800078fe:	c5 d1       	brne	800079b8 <_vfprintf_r+0xde4>
80007900:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007904:	40 3c       	lddsp	r12,sp[0xc]
80007906:	58 0c       	cp.w	r12,0
80007908:	c2 60       	breq	80007954 <_vfprintf_r+0xd80>
8000790a:	10 36       	cp.w	r6,r8
8000790c:	c0 a4       	brge	80007920 <_vfprintf_r+0xd4c>
8000790e:	fa cb f9 44 	sub	r11,sp,-1724
80007912:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007916:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000791a:	fa e9 00 00 	st.d	sp[0],r8
8000791e:	c1 88       	rjmp	8000794e <_vfprintf_r+0xd7a>
80007920:	fa c8 f9 50 	sub	r8,sp,-1712
80007924:	1a d8       	st.w	--sp,r8
80007926:	fa c8 fa b8 	sub	r8,sp,-1352
8000792a:	04 9a       	mov	r10,r2
8000792c:	1a d8       	st.w	--sp,r8
8000792e:	0c 9b       	mov	r11,r6
80007930:	fa c8 fb b4 	sub	r8,sp,-1100
80007934:	08 9c       	mov	r12,r4
80007936:	1a d8       	st.w	--sp,r8
80007938:	fa c8 f9 40 	sub	r8,sp,-1728
8000793c:	fa c9 ff b4 	sub	r9,sp,-76
80007940:	fe b0 f7 b2 	rcall	800068a4 <get_arg>
80007944:	2f dd       	sub	sp,-12
80007946:	f8 ea 00 00 	ld.d	r10,r12[0]
8000794a:	fa eb 00 00 	st.d	sp[0],r10
8000794e:	30 08       	mov	r8,0
80007950:	e0 8f 03 de 	bral	8000810c <_vfprintf_r+0x1538>
80007954:	ee ca ff ff 	sub	r10,r7,-1
80007958:	10 37       	cp.w	r7,r8
8000795a:	c0 b4       	brge	80007970 <_vfprintf_r+0xd9c>
8000795c:	fa c9 f9 44 	sub	r9,sp,-1724
80007960:	14 97       	mov	r7,r10
80007962:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007966:	ec ea fd 88 	ld.d	r10,r6[-632]
8000796a:	fa eb 00 00 	st.d	sp[0],r10
8000796e:	c1 88       	rjmp	8000799e <_vfprintf_r+0xdca>
80007970:	41 09       	lddsp	r9,sp[0x40]
80007972:	59 f8       	cp.w	r8,31
80007974:	e0 89 00 18 	brgt	800079a4 <_vfprintf_r+0xdd0>
80007978:	f2 e6 00 00 	ld.d	r6,r9[0]
8000797c:	f2 cb ff f8 	sub	r11,r9,-8
80007980:	fa e7 00 00 	st.d	sp[0],r6
80007984:	51 0b       	stdsp	sp[0x40],r11
80007986:	fa c6 f9 44 	sub	r6,sp,-1724
8000798a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000798e:	fa e6 00 00 	ld.d	r6,sp[0]
80007992:	f2 e7 fd 88 	st.d	r9[-632],r6
80007996:	2f f8       	sub	r8,-1
80007998:	14 97       	mov	r7,r10
8000799a:	fb 48 06 b4 	st.w	sp[1716],r8
8000799e:	40 38       	lddsp	r8,sp[0xc]
800079a0:	e0 8f 03 b6 	bral	8000810c <_vfprintf_r+0x1538>
800079a4:	f2 e6 00 00 	ld.d	r6,r9[0]
800079a8:	40 38       	lddsp	r8,sp[0xc]
800079aa:	fa e7 00 00 	st.d	sp[0],r6
800079ae:	2f 89       	sub	r9,-8
800079b0:	14 97       	mov	r7,r10
800079b2:	51 09       	stdsp	sp[0x40],r9
800079b4:	e0 8f 03 ac 	bral	8000810c <_vfprintf_r+0x1538>
800079b8:	ed b5 00 04 	bld	r5,0x4
800079bc:	c1 61       	brne	800079e8 <_vfprintf_r+0xe14>
800079be:	fa f8 06 b4 	ld.w	r8,sp[1716]
800079c2:	40 3e       	lddsp	lr,sp[0xc]
800079c4:	58 0e       	cp.w	lr,0
800079c6:	c0 80       	breq	800079d6 <_vfprintf_r+0xe02>
800079c8:	10 36       	cp.w	r6,r8
800079ca:	c6 74       	brge	80007a98 <_vfprintf_r+0xec4>
800079cc:	fa cc f9 44 	sub	r12,sp,-1724
800079d0:	f8 06 00 36 	add	r6,r12,r6<<0x3
800079d4:	c8 08       	rjmp	80007ad4 <_vfprintf_r+0xf00>
800079d6:	ee ca ff ff 	sub	r10,r7,-1
800079da:	10 37       	cp.w	r7,r8
800079dc:	c7 f4       	brge	80007ada <_vfprintf_r+0xf06>
800079de:	fa cb f9 44 	sub	r11,sp,-1724
800079e2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800079e6:	c7 68       	rjmp	80007ad2 <_vfprintf_r+0xefe>
800079e8:	ed b5 00 06 	bld	r5,0x6
800079ec:	c4 a1       	brne	80007a80 <_vfprintf_r+0xeac>
800079ee:	fa f8 06 b4 	ld.w	r8,sp[1716]
800079f2:	40 3c       	lddsp	r12,sp[0xc]
800079f4:	58 0c       	cp.w	r12,0
800079f6:	c1 d0       	breq	80007a30 <_vfprintf_r+0xe5c>
800079f8:	10 36       	cp.w	r6,r8
800079fa:	c0 64       	brge	80007a06 <_vfprintf_r+0xe32>
800079fc:	fa cb f9 44 	sub	r11,sp,-1724
80007a00:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007a04:	c1 f8       	rjmp	80007a42 <_vfprintf_r+0xe6e>
80007a06:	fa c8 f9 50 	sub	r8,sp,-1712
80007a0a:	1a d8       	st.w	--sp,r8
80007a0c:	fa c8 fa b8 	sub	r8,sp,-1352
80007a10:	1a d8       	st.w	--sp,r8
80007a12:	fa c8 fb b4 	sub	r8,sp,-1100
80007a16:	1a d8       	st.w	--sp,r8
80007a18:	fa c8 f9 40 	sub	r8,sp,-1728
80007a1c:	fa c9 ff b4 	sub	r9,sp,-76
80007a20:	04 9a       	mov	r10,r2
80007a22:	0c 9b       	mov	r11,r6
80007a24:	08 9c       	mov	r12,r4
80007a26:	fe b0 f7 3f 	rcall	800068a4 <get_arg>
80007a2a:	2f dd       	sub	sp,-12
80007a2c:	98 18       	ld.sh	r8,r12[0x2]
80007a2e:	c2 68       	rjmp	80007a7a <_vfprintf_r+0xea6>
80007a30:	ee ca ff ff 	sub	r10,r7,-1
80007a34:	10 37       	cp.w	r7,r8
80007a36:	c0 94       	brge	80007a48 <_vfprintf_r+0xe74>
80007a38:	fa c9 f9 44 	sub	r9,sp,-1724
80007a3c:	14 97       	mov	r7,r10
80007a3e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007a42:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007a46:	c1 a8       	rjmp	80007a7a <_vfprintf_r+0xea6>
80007a48:	41 09       	lddsp	r9,sp[0x40]
80007a4a:	59 f8       	cp.w	r8,31
80007a4c:	e0 89 00 13 	brgt	80007a72 <_vfprintf_r+0xe9e>
80007a50:	f2 cb ff fc 	sub	r11,r9,-4
80007a54:	51 0b       	stdsp	sp[0x40],r11
80007a56:	72 09       	ld.w	r9,r9[0x0]
80007a58:	fa c6 f9 44 	sub	r6,sp,-1724
80007a5c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007a60:	2f f8       	sub	r8,-1
80007a62:	f7 49 fd 88 	st.w	r11[-632],r9
80007a66:	fb 48 06 b4 	st.w	sp[1716],r8
80007a6a:	14 97       	mov	r7,r10
80007a6c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007a70:	c0 58       	rjmp	80007a7a <_vfprintf_r+0xea6>
80007a72:	92 18       	ld.sh	r8,r9[0x2]
80007a74:	14 97       	mov	r7,r10
80007a76:	2f c9       	sub	r9,-4
80007a78:	51 09       	stdsp	sp[0x40],r9
80007a7a:	5c 78       	castu.h	r8
80007a7c:	50 18       	stdsp	sp[0x4],r8
80007a7e:	c4 68       	rjmp	80007b0a <_vfprintf_r+0xf36>
80007a80:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007a84:	40 3c       	lddsp	r12,sp[0xc]
80007a86:	58 0c       	cp.w	r12,0
80007a88:	c1 d0       	breq	80007ac2 <_vfprintf_r+0xeee>
80007a8a:	10 36       	cp.w	r6,r8
80007a8c:	c0 64       	brge	80007a98 <_vfprintf_r+0xec4>
80007a8e:	fa cb f9 44 	sub	r11,sp,-1724
80007a92:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007a96:	c1 f8       	rjmp	80007ad4 <_vfprintf_r+0xf00>
80007a98:	fa c8 f9 50 	sub	r8,sp,-1712
80007a9c:	1a d8       	st.w	--sp,r8
80007a9e:	fa c8 fa b8 	sub	r8,sp,-1352
80007aa2:	0c 9b       	mov	r11,r6
80007aa4:	1a d8       	st.w	--sp,r8
80007aa6:	fa c8 fb b4 	sub	r8,sp,-1100
80007aaa:	04 9a       	mov	r10,r2
80007aac:	1a d8       	st.w	--sp,r8
80007aae:	08 9c       	mov	r12,r4
80007ab0:	fa c8 f9 40 	sub	r8,sp,-1728
80007ab4:	fa c9 ff b4 	sub	r9,sp,-76
80007ab8:	fe b0 f6 f6 	rcall	800068a4 <get_arg>
80007abc:	2f dd       	sub	sp,-12
80007abe:	78 0b       	ld.w	r11,r12[0x0]
80007ac0:	c2 48       	rjmp	80007b08 <_vfprintf_r+0xf34>
80007ac2:	ee ca ff ff 	sub	r10,r7,-1
80007ac6:	10 37       	cp.w	r7,r8
80007ac8:	c0 94       	brge	80007ada <_vfprintf_r+0xf06>
80007aca:	fa c9 f9 44 	sub	r9,sp,-1724
80007ace:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007ad2:	14 97       	mov	r7,r10
80007ad4:	ec fb fd 88 	ld.w	r11,r6[-632]
80007ad8:	c1 88       	rjmp	80007b08 <_vfprintf_r+0xf34>
80007ada:	41 09       	lddsp	r9,sp[0x40]
80007adc:	59 f8       	cp.w	r8,31
80007ade:	e0 89 00 11 	brgt	80007b00 <_vfprintf_r+0xf2c>
80007ae2:	f2 cb ff fc 	sub	r11,r9,-4
80007ae6:	51 0b       	stdsp	sp[0x40],r11
80007ae8:	fa c6 f9 44 	sub	r6,sp,-1724
80007aec:	72 0b       	ld.w	r11,r9[0x0]
80007aee:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007af2:	f3 4b fd 88 	st.w	r9[-632],r11
80007af6:	2f f8       	sub	r8,-1
80007af8:	14 97       	mov	r7,r10
80007afa:	fb 48 06 b4 	st.w	sp[1716],r8
80007afe:	c0 58       	rjmp	80007b08 <_vfprintf_r+0xf34>
80007b00:	72 0b       	ld.w	r11,r9[0x0]
80007b02:	14 97       	mov	r7,r10
80007b04:	2f c9       	sub	r9,-4
80007b06:	51 09       	stdsp	sp[0x40],r9
80007b08:	50 1b       	stdsp	sp[0x4],r11
80007b0a:	30 0e       	mov	lr,0
80007b0c:	50 0e       	stdsp	sp[0x0],lr
80007b0e:	1c 98       	mov	r8,lr
80007b10:	e0 8f 02 fe 	bral	8000810c <_vfprintf_r+0x1538>
80007b14:	50 a7       	stdsp	sp[0x28],r7
80007b16:	50 80       	stdsp	sp[0x20],r0
80007b18:	0c 97       	mov	r7,r6
80007b1a:	04 94       	mov	r4,r2
80007b1c:	06 96       	mov	r6,r3
80007b1e:	02 92       	mov	r2,r1
80007b20:	40 93       	lddsp	r3,sp[0x24]
80007b22:	40 41       	lddsp	r1,sp[0x10]
80007b24:	0e 99       	mov	r9,r7
80007b26:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007b2a:	40 3c       	lddsp	r12,sp[0xc]
80007b2c:	58 0c       	cp.w	r12,0
80007b2e:	c1 d0       	breq	80007b68 <_vfprintf_r+0xf94>
80007b30:	10 36       	cp.w	r6,r8
80007b32:	c0 64       	brge	80007b3e <_vfprintf_r+0xf6a>
80007b34:	fa cb f9 44 	sub	r11,sp,-1724
80007b38:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007b3c:	c1 d8       	rjmp	80007b76 <_vfprintf_r+0xfa2>
80007b3e:	fa c8 f9 50 	sub	r8,sp,-1712
80007b42:	1a d8       	st.w	--sp,r8
80007b44:	fa c8 fa b8 	sub	r8,sp,-1352
80007b48:	1a d8       	st.w	--sp,r8
80007b4a:	fa c8 fb b4 	sub	r8,sp,-1100
80007b4e:	1a d8       	st.w	--sp,r8
80007b50:	fa c9 ff b4 	sub	r9,sp,-76
80007b54:	fa c8 f9 40 	sub	r8,sp,-1728
80007b58:	04 9a       	mov	r10,r2
80007b5a:	0c 9b       	mov	r11,r6
80007b5c:	08 9c       	mov	r12,r4
80007b5e:	fe b0 f6 a3 	rcall	800068a4 <get_arg>
80007b62:	2f dd       	sub	sp,-12
80007b64:	78 09       	ld.w	r9,r12[0x0]
80007b66:	c2 18       	rjmp	80007ba8 <_vfprintf_r+0xfd4>
80007b68:	2f f7       	sub	r7,-1
80007b6a:	10 39       	cp.w	r9,r8
80007b6c:	c0 84       	brge	80007b7c <_vfprintf_r+0xfa8>
80007b6e:	fa ca f9 44 	sub	r10,sp,-1724
80007b72:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007b76:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007b7a:	c1 78       	rjmp	80007ba8 <_vfprintf_r+0xfd4>
80007b7c:	41 09       	lddsp	r9,sp[0x40]
80007b7e:	59 f8       	cp.w	r8,31
80007b80:	e0 89 00 10 	brgt	80007ba0 <_vfprintf_r+0xfcc>
80007b84:	f2 ca ff fc 	sub	r10,r9,-4
80007b88:	51 0a       	stdsp	sp[0x40],r10
80007b8a:	fa c6 f9 44 	sub	r6,sp,-1724
80007b8e:	72 09       	ld.w	r9,r9[0x0]
80007b90:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007b94:	f5 49 fd 88 	st.w	r10[-632],r9
80007b98:	2f f8       	sub	r8,-1
80007b9a:	fb 48 06 b4 	st.w	sp[1716],r8
80007b9e:	c0 58       	rjmp	80007ba8 <_vfprintf_r+0xfd4>
80007ba0:	f2 c8 ff fc 	sub	r8,r9,-4
80007ba4:	51 08       	stdsp	sp[0x40],r8
80007ba6:	72 09       	ld.w	r9,r9[0x0]
80007ba8:	33 08       	mov	r8,48
80007baa:	fb 68 06 b8 	st.b	sp[1720],r8
80007bae:	37 88       	mov	r8,120
80007bb0:	30 0e       	mov	lr,0
80007bb2:	fb 68 06 b9 	st.b	sp[1721],r8
80007bb6:	fe cc b3 22 	sub	r12,pc,-19678
80007bba:	50 19       	stdsp	sp[0x4],r9
80007bbc:	a1 b5       	sbr	r5,0x1
80007bbe:	50 0e       	stdsp	sp[0x0],lr
80007bc0:	50 dc       	stdsp	sp[0x34],r12
80007bc2:	30 28       	mov	r8,2
80007bc4:	37 80       	mov	r0,120
80007bc6:	e0 8f 02 a3 	bral	8000810c <_vfprintf_r+0x1538>
80007bca:	50 a7       	stdsp	sp[0x28],r7
80007bcc:	50 80       	stdsp	sp[0x20],r0
80007bce:	10 90       	mov	r0,r8
80007bd0:	30 08       	mov	r8,0
80007bd2:	fb 68 06 bb 	st.b	sp[1723],r8
80007bd6:	0c 97       	mov	r7,r6
80007bd8:	04 94       	mov	r4,r2
80007bda:	06 96       	mov	r6,r3
80007bdc:	02 92       	mov	r2,r1
80007bde:	40 93       	lddsp	r3,sp[0x24]
80007be0:	40 41       	lddsp	r1,sp[0x10]
80007be2:	0e 99       	mov	r9,r7
80007be4:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007be8:	40 3b       	lddsp	r11,sp[0xc]
80007bea:	58 0b       	cp.w	r11,0
80007bec:	c1 d0       	breq	80007c26 <_vfprintf_r+0x1052>
80007bee:	10 36       	cp.w	r6,r8
80007bf0:	c0 64       	brge	80007bfc <_vfprintf_r+0x1028>
80007bf2:	fa ca f9 44 	sub	r10,sp,-1724
80007bf6:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007bfa:	c1 d8       	rjmp	80007c34 <_vfprintf_r+0x1060>
80007bfc:	fa c8 f9 50 	sub	r8,sp,-1712
80007c00:	1a d8       	st.w	--sp,r8
80007c02:	fa c8 fa b8 	sub	r8,sp,-1352
80007c06:	1a d8       	st.w	--sp,r8
80007c08:	fa c8 fb b4 	sub	r8,sp,-1100
80007c0c:	0c 9b       	mov	r11,r6
80007c0e:	1a d8       	st.w	--sp,r8
80007c10:	04 9a       	mov	r10,r2
80007c12:	fa c8 f9 40 	sub	r8,sp,-1728
80007c16:	fa c9 ff b4 	sub	r9,sp,-76
80007c1a:	08 9c       	mov	r12,r4
80007c1c:	fe b0 f6 44 	rcall	800068a4 <get_arg>
80007c20:	2f dd       	sub	sp,-12
80007c22:	78 06       	ld.w	r6,r12[0x0]
80007c24:	c2 08       	rjmp	80007c64 <_vfprintf_r+0x1090>
80007c26:	2f f7       	sub	r7,-1
80007c28:	10 39       	cp.w	r9,r8
80007c2a:	c0 84       	brge	80007c3a <_vfprintf_r+0x1066>
80007c2c:	fa c9 f9 44 	sub	r9,sp,-1724
80007c30:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007c34:	ec f6 fd 88 	ld.w	r6,r6[-632]
80007c38:	c1 68       	rjmp	80007c64 <_vfprintf_r+0x1090>
80007c3a:	41 09       	lddsp	r9,sp[0x40]
80007c3c:	59 f8       	cp.w	r8,31
80007c3e:	e0 89 00 10 	brgt	80007c5e <_vfprintf_r+0x108a>
80007c42:	f2 ca ff fc 	sub	r10,r9,-4
80007c46:	51 0a       	stdsp	sp[0x40],r10
80007c48:	72 06       	ld.w	r6,r9[0x0]
80007c4a:	fa ce f9 44 	sub	lr,sp,-1724
80007c4e:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007c52:	f3 46 fd 88 	st.w	r9[-632],r6
80007c56:	2f f8       	sub	r8,-1
80007c58:	fb 48 06 b4 	st.w	sp[1716],r8
80007c5c:	c0 48       	rjmp	80007c64 <_vfprintf_r+0x1090>
80007c5e:	72 06       	ld.w	r6,r9[0x0]
80007c60:	2f c9       	sub	r9,-4
80007c62:	51 09       	stdsp	sp[0x40],r9
80007c64:	40 2c       	lddsp	r12,sp[0x8]
80007c66:	58 0c       	cp.w	r12,0
80007c68:	c1 05       	brlt	80007c88 <_vfprintf_r+0x10b4>
80007c6a:	18 9a       	mov	r10,r12
80007c6c:	30 0b       	mov	r11,0
80007c6e:	0c 9c       	mov	r12,r6
80007c70:	e0 a0 12 38 	rcall	8000a0e0 <memchr>
80007c74:	e0 80 02 df 	breq	80008232 <_vfprintf_r+0x165e>
80007c78:	f8 06 01 02 	sub	r2,r12,r6
80007c7c:	40 2b       	lddsp	r11,sp[0x8]
80007c7e:	16 32       	cp.w	r2,r11
80007c80:	e0 89 02 d9 	brgt	80008232 <_vfprintf_r+0x165e>
80007c84:	e0 8f 02 d4 	bral	8000822c <_vfprintf_r+0x1658>
80007c88:	30 0a       	mov	r10,0
80007c8a:	0c 9c       	mov	r12,r6
80007c8c:	50 2a       	stdsp	sp[0x8],r10
80007c8e:	fe b0 f5 85 	rcall	80006798 <strlen>
80007c92:	18 92       	mov	r2,r12
80007c94:	e0 8f 02 d2 	bral	80008238 <_vfprintf_r+0x1664>
80007c98:	50 a7       	stdsp	sp[0x28],r7
80007c9a:	50 80       	stdsp	sp[0x20],r0
80007c9c:	0c 97       	mov	r7,r6
80007c9e:	04 94       	mov	r4,r2
80007ca0:	06 96       	mov	r6,r3
80007ca2:	02 92       	mov	r2,r1
80007ca4:	40 93       	lddsp	r3,sp[0x24]
80007ca6:	10 90       	mov	r0,r8
80007ca8:	40 41       	lddsp	r1,sp[0x10]
80007caa:	a5 a5       	sbr	r5,0x4
80007cac:	c0 a8       	rjmp	80007cc0 <_vfprintf_r+0x10ec>
80007cae:	50 a7       	stdsp	sp[0x28],r7
80007cb0:	50 80       	stdsp	sp[0x20],r0
80007cb2:	0c 97       	mov	r7,r6
80007cb4:	04 94       	mov	r4,r2
80007cb6:	06 96       	mov	r6,r3
80007cb8:	02 92       	mov	r2,r1
80007cba:	40 93       	lddsp	r3,sp[0x24]
80007cbc:	10 90       	mov	r0,r8
80007cbe:	40 41       	lddsp	r1,sp[0x10]
80007cc0:	ed b5 00 05 	bld	r5,0x5
80007cc4:	c5 61       	brne	80007d70 <_vfprintf_r+0x119c>
80007cc6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007cca:	40 39       	lddsp	r9,sp[0xc]
80007ccc:	58 09       	cp.w	r9,0
80007cce:	c2 10       	breq	80007d10 <_vfprintf_r+0x113c>
80007cd0:	10 36       	cp.w	r6,r8
80007cd2:	c0 74       	brge	80007ce0 <_vfprintf_r+0x110c>
80007cd4:	fa c8 f9 44 	sub	r8,sp,-1724
80007cd8:	f0 06 00 36 	add	r6,r8,r6<<0x3
80007cdc:	c2 38       	rjmp	80007d22 <_vfprintf_r+0x114e>
80007cde:	d7 03       	nop
80007ce0:	fa c8 f9 50 	sub	r8,sp,-1712
80007ce4:	1a d8       	st.w	--sp,r8
80007ce6:	fa c8 fa b8 	sub	r8,sp,-1352
80007cea:	1a d8       	st.w	--sp,r8
80007cec:	fa c8 fb b4 	sub	r8,sp,-1100
80007cf0:	1a d8       	st.w	--sp,r8
80007cf2:	fa c8 f9 40 	sub	r8,sp,-1728
80007cf6:	fa c9 ff b4 	sub	r9,sp,-76
80007cfa:	04 9a       	mov	r10,r2
80007cfc:	0c 9b       	mov	r11,r6
80007cfe:	08 9c       	mov	r12,r4
80007d00:	fe b0 f5 d2 	rcall	800068a4 <get_arg>
80007d04:	2f dd       	sub	sp,-12
80007d06:	f8 e8 00 00 	ld.d	r8,r12[0]
80007d0a:	fa e9 00 00 	st.d	sp[0],r8
80007d0e:	c2 e8       	rjmp	80007d6a <_vfprintf_r+0x1196>
80007d10:	ee ca ff ff 	sub	r10,r7,-1
80007d14:	10 37       	cp.w	r7,r8
80007d16:	c0 b4       	brge	80007d2c <_vfprintf_r+0x1158>
80007d18:	fa c8 f9 44 	sub	r8,sp,-1724
80007d1c:	14 97       	mov	r7,r10
80007d1e:	f0 06 00 36 	add	r6,r8,r6<<0x3
80007d22:	ec ea fd 88 	ld.d	r10,r6[-632]
80007d26:	fa eb 00 00 	st.d	sp[0],r10
80007d2a:	c2 08       	rjmp	80007d6a <_vfprintf_r+0x1196>
80007d2c:	41 09       	lddsp	r9,sp[0x40]
80007d2e:	59 f8       	cp.w	r8,31
80007d30:	e0 89 00 16 	brgt	80007d5c <_vfprintf_r+0x1188>
80007d34:	f2 e6 00 00 	ld.d	r6,r9[0]
80007d38:	f2 cb ff f8 	sub	r11,r9,-8
80007d3c:	fa e7 00 00 	st.d	sp[0],r6
80007d40:	51 0b       	stdsp	sp[0x40],r11
80007d42:	fa c6 f9 44 	sub	r6,sp,-1724
80007d46:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007d4a:	fa e6 00 00 	ld.d	r6,sp[0]
80007d4e:	f2 e7 fd 88 	st.d	r9[-632],r6
80007d52:	2f f8       	sub	r8,-1
80007d54:	14 97       	mov	r7,r10
80007d56:	fb 48 06 b4 	st.w	sp[1716],r8
80007d5a:	c0 88       	rjmp	80007d6a <_vfprintf_r+0x1196>
80007d5c:	f2 e6 00 00 	ld.d	r6,r9[0]
80007d60:	2f 89       	sub	r9,-8
80007d62:	fa e7 00 00 	st.d	sp[0],r6
80007d66:	51 09       	stdsp	sp[0x40],r9
80007d68:	14 97       	mov	r7,r10
80007d6a:	30 18       	mov	r8,1
80007d6c:	e0 8f 01 d0 	bral	8000810c <_vfprintf_r+0x1538>
80007d70:	ed b5 00 04 	bld	r5,0x4
80007d74:	c1 61       	brne	80007da0 <_vfprintf_r+0x11cc>
80007d76:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d7a:	40 3e       	lddsp	lr,sp[0xc]
80007d7c:	58 0e       	cp.w	lr,0
80007d7e:	c0 80       	breq	80007d8e <_vfprintf_r+0x11ba>
80007d80:	10 36       	cp.w	r6,r8
80007d82:	c6 74       	brge	80007e50 <_vfprintf_r+0x127c>
80007d84:	fa cc f9 44 	sub	r12,sp,-1724
80007d88:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007d8c:	c8 08       	rjmp	80007e8c <_vfprintf_r+0x12b8>
80007d8e:	ee ca ff ff 	sub	r10,r7,-1
80007d92:	10 37       	cp.w	r7,r8
80007d94:	c7 f4       	brge	80007e92 <_vfprintf_r+0x12be>
80007d96:	fa cb f9 44 	sub	r11,sp,-1724
80007d9a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007d9e:	c7 68       	rjmp	80007e8a <_vfprintf_r+0x12b6>
80007da0:	ed b5 00 06 	bld	r5,0x6
80007da4:	c4 a1       	brne	80007e38 <_vfprintf_r+0x1264>
80007da6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007daa:	40 3c       	lddsp	r12,sp[0xc]
80007dac:	58 0c       	cp.w	r12,0
80007dae:	c1 d0       	breq	80007de8 <_vfprintf_r+0x1214>
80007db0:	10 36       	cp.w	r6,r8
80007db2:	c0 64       	brge	80007dbe <_vfprintf_r+0x11ea>
80007db4:	fa cb f9 44 	sub	r11,sp,-1724
80007db8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007dbc:	c1 f8       	rjmp	80007dfa <_vfprintf_r+0x1226>
80007dbe:	fa c8 f9 50 	sub	r8,sp,-1712
80007dc2:	1a d8       	st.w	--sp,r8
80007dc4:	fa c8 fa b8 	sub	r8,sp,-1352
80007dc8:	1a d8       	st.w	--sp,r8
80007dca:	fa c8 fb b4 	sub	r8,sp,-1100
80007dce:	1a d8       	st.w	--sp,r8
80007dd0:	fa c8 f9 40 	sub	r8,sp,-1728
80007dd4:	fa c9 ff b4 	sub	r9,sp,-76
80007dd8:	04 9a       	mov	r10,r2
80007dda:	0c 9b       	mov	r11,r6
80007ddc:	08 9c       	mov	r12,r4
80007dde:	fe b0 f5 63 	rcall	800068a4 <get_arg>
80007de2:	2f dd       	sub	sp,-12
80007de4:	98 18       	ld.sh	r8,r12[0x2]
80007de6:	c2 68       	rjmp	80007e32 <_vfprintf_r+0x125e>
80007de8:	ee ca ff ff 	sub	r10,r7,-1
80007dec:	10 37       	cp.w	r7,r8
80007dee:	c0 94       	brge	80007e00 <_vfprintf_r+0x122c>
80007df0:	fa c9 f9 44 	sub	r9,sp,-1724
80007df4:	14 97       	mov	r7,r10
80007df6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007dfa:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007dfe:	c1 a8       	rjmp	80007e32 <_vfprintf_r+0x125e>
80007e00:	41 09       	lddsp	r9,sp[0x40]
80007e02:	59 f8       	cp.w	r8,31
80007e04:	e0 89 00 13 	brgt	80007e2a <_vfprintf_r+0x1256>
80007e08:	f2 cb ff fc 	sub	r11,r9,-4
80007e0c:	51 0b       	stdsp	sp[0x40],r11
80007e0e:	72 09       	ld.w	r9,r9[0x0]
80007e10:	fa c6 f9 44 	sub	r6,sp,-1724
80007e14:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007e18:	2f f8       	sub	r8,-1
80007e1a:	f7 49 fd 88 	st.w	r11[-632],r9
80007e1e:	fb 48 06 b4 	st.w	sp[1716],r8
80007e22:	14 97       	mov	r7,r10
80007e24:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007e28:	c0 58       	rjmp	80007e32 <_vfprintf_r+0x125e>
80007e2a:	92 18       	ld.sh	r8,r9[0x2]
80007e2c:	14 97       	mov	r7,r10
80007e2e:	2f c9       	sub	r9,-4
80007e30:	51 09       	stdsp	sp[0x40],r9
80007e32:	5c 78       	castu.h	r8
80007e34:	50 18       	stdsp	sp[0x4],r8
80007e36:	c4 68       	rjmp	80007ec2 <_vfprintf_r+0x12ee>
80007e38:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e3c:	40 3c       	lddsp	r12,sp[0xc]
80007e3e:	58 0c       	cp.w	r12,0
80007e40:	c1 d0       	breq	80007e7a <_vfprintf_r+0x12a6>
80007e42:	10 36       	cp.w	r6,r8
80007e44:	c0 64       	brge	80007e50 <_vfprintf_r+0x127c>
80007e46:	fa cb f9 44 	sub	r11,sp,-1724
80007e4a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007e4e:	c1 f8       	rjmp	80007e8c <_vfprintf_r+0x12b8>
80007e50:	fa c8 f9 50 	sub	r8,sp,-1712
80007e54:	1a d8       	st.w	--sp,r8
80007e56:	fa c8 fa b8 	sub	r8,sp,-1352
80007e5a:	0c 9b       	mov	r11,r6
80007e5c:	1a d8       	st.w	--sp,r8
80007e5e:	fa c8 fb b4 	sub	r8,sp,-1100
80007e62:	04 9a       	mov	r10,r2
80007e64:	1a d8       	st.w	--sp,r8
80007e66:	08 9c       	mov	r12,r4
80007e68:	fa c8 f9 40 	sub	r8,sp,-1728
80007e6c:	fa c9 ff b4 	sub	r9,sp,-76
80007e70:	fe b0 f5 1a 	rcall	800068a4 <get_arg>
80007e74:	2f dd       	sub	sp,-12
80007e76:	78 0b       	ld.w	r11,r12[0x0]
80007e78:	c2 48       	rjmp	80007ec0 <_vfprintf_r+0x12ec>
80007e7a:	ee ca ff ff 	sub	r10,r7,-1
80007e7e:	10 37       	cp.w	r7,r8
80007e80:	c0 94       	brge	80007e92 <_vfprintf_r+0x12be>
80007e82:	fa c9 f9 44 	sub	r9,sp,-1724
80007e86:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007e8a:	14 97       	mov	r7,r10
80007e8c:	ec fb fd 88 	ld.w	r11,r6[-632]
80007e90:	c1 88       	rjmp	80007ec0 <_vfprintf_r+0x12ec>
80007e92:	41 09       	lddsp	r9,sp[0x40]
80007e94:	59 f8       	cp.w	r8,31
80007e96:	e0 89 00 11 	brgt	80007eb8 <_vfprintf_r+0x12e4>
80007e9a:	f2 cb ff fc 	sub	r11,r9,-4
80007e9e:	51 0b       	stdsp	sp[0x40],r11
80007ea0:	fa c6 f9 44 	sub	r6,sp,-1724
80007ea4:	72 0b       	ld.w	r11,r9[0x0]
80007ea6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007eaa:	f3 4b fd 88 	st.w	r9[-632],r11
80007eae:	2f f8       	sub	r8,-1
80007eb0:	14 97       	mov	r7,r10
80007eb2:	fb 48 06 b4 	st.w	sp[1716],r8
80007eb6:	c0 58       	rjmp	80007ec0 <_vfprintf_r+0x12ec>
80007eb8:	72 0b       	ld.w	r11,r9[0x0]
80007eba:	14 97       	mov	r7,r10
80007ebc:	2f c9       	sub	r9,-4
80007ebe:	51 09       	stdsp	sp[0x40],r9
80007ec0:	50 1b       	stdsp	sp[0x4],r11
80007ec2:	30 0e       	mov	lr,0
80007ec4:	30 18       	mov	r8,1
80007ec6:	50 0e       	stdsp	sp[0x0],lr
80007ec8:	c2 29       	rjmp	8000810c <_vfprintf_r+0x1538>
80007eca:	50 a7       	stdsp	sp[0x28],r7
80007ecc:	50 80       	stdsp	sp[0x20],r0
80007ece:	0c 97       	mov	r7,r6
80007ed0:	04 94       	mov	r4,r2
80007ed2:	06 96       	mov	r6,r3
80007ed4:	02 92       	mov	r2,r1
80007ed6:	fe cc b6 42 	sub	r12,pc,-18878
80007eda:	40 93       	lddsp	r3,sp[0x24]
80007edc:	10 90       	mov	r0,r8
80007ede:	40 41       	lddsp	r1,sp[0x10]
80007ee0:	50 dc       	stdsp	sp[0x34],r12
80007ee2:	ed b5 00 05 	bld	r5,0x5
80007ee6:	c5 51       	brne	80007f90 <_vfprintf_r+0x13bc>
80007ee8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007eec:	40 3b       	lddsp	r11,sp[0xc]
80007eee:	58 0b       	cp.w	r11,0
80007ef0:	c2 20       	breq	80007f34 <_vfprintf_r+0x1360>
80007ef2:	10 36       	cp.w	r6,r8
80007ef4:	c0 a4       	brge	80007f08 <_vfprintf_r+0x1334>
80007ef6:	fa ca f9 44 	sub	r10,sp,-1724
80007efa:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007efe:	ec e8 fd 88 	ld.d	r8,r6[-632]
80007f02:	fa e9 00 00 	st.d	sp[0],r8
80007f06:	cf 28       	rjmp	800080ea <_vfprintf_r+0x1516>
80007f08:	fa c8 f9 50 	sub	r8,sp,-1712
80007f0c:	1a d8       	st.w	--sp,r8
80007f0e:	fa c8 fa b8 	sub	r8,sp,-1352
80007f12:	04 9a       	mov	r10,r2
80007f14:	1a d8       	st.w	--sp,r8
80007f16:	0c 9b       	mov	r11,r6
80007f18:	fa c8 fb b4 	sub	r8,sp,-1100
80007f1c:	08 9c       	mov	r12,r4
80007f1e:	1a d8       	st.w	--sp,r8
80007f20:	fa c8 f9 40 	sub	r8,sp,-1728
80007f24:	fa c9 ff b4 	sub	r9,sp,-76
80007f28:	fe b0 f4 be 	rcall	800068a4 <get_arg>
80007f2c:	2f dd       	sub	sp,-12
80007f2e:	f8 ea 00 00 	ld.d	r10,r12[0]
80007f32:	c0 c8       	rjmp	80007f4a <_vfprintf_r+0x1376>
80007f34:	ee ca ff ff 	sub	r10,r7,-1
80007f38:	10 37       	cp.w	r7,r8
80007f3a:	c0 b4       	brge	80007f50 <_vfprintf_r+0x137c>
80007f3c:	fa c9 f9 44 	sub	r9,sp,-1724
80007f40:	14 97       	mov	r7,r10
80007f42:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007f46:	ec ea fd 88 	ld.d	r10,r6[-632]
80007f4a:	fa eb 00 00 	st.d	sp[0],r10
80007f4e:	cc e8       	rjmp	800080ea <_vfprintf_r+0x1516>
80007f50:	41 09       	lddsp	r9,sp[0x40]
80007f52:	59 f8       	cp.w	r8,31
80007f54:	e0 89 00 16 	brgt	80007f80 <_vfprintf_r+0x13ac>
80007f58:	f2 e6 00 00 	ld.d	r6,r9[0]
80007f5c:	f2 cb ff f8 	sub	r11,r9,-8
80007f60:	fa e7 00 00 	st.d	sp[0],r6
80007f64:	51 0b       	stdsp	sp[0x40],r11
80007f66:	fa c6 f9 44 	sub	r6,sp,-1724
80007f6a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007f6e:	fa e6 00 00 	ld.d	r6,sp[0]
80007f72:	f2 e7 fd 88 	st.d	r9[-632],r6
80007f76:	2f f8       	sub	r8,-1
80007f78:	14 97       	mov	r7,r10
80007f7a:	fb 48 06 b4 	st.w	sp[1716],r8
80007f7e:	cb 68       	rjmp	800080ea <_vfprintf_r+0x1516>
80007f80:	f2 e6 00 00 	ld.d	r6,r9[0]
80007f84:	2f 89       	sub	r9,-8
80007f86:	fa e7 00 00 	st.d	sp[0],r6
80007f8a:	51 09       	stdsp	sp[0x40],r9
80007f8c:	14 97       	mov	r7,r10
80007f8e:	ca e8       	rjmp	800080ea <_vfprintf_r+0x1516>
80007f90:	ed b5 00 04 	bld	r5,0x4
80007f94:	c1 71       	brne	80007fc2 <_vfprintf_r+0x13ee>
80007f96:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f9a:	40 3e       	lddsp	lr,sp[0xc]
80007f9c:	58 0e       	cp.w	lr,0
80007f9e:	c0 80       	breq	80007fae <_vfprintf_r+0x13da>
80007fa0:	10 36       	cp.w	r6,r8
80007fa2:	c6 94       	brge	80008074 <_vfprintf_r+0x14a0>
80007fa4:	fa cc f9 44 	sub	r12,sp,-1724
80007fa8:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007fac:	c8 28       	rjmp	800080b0 <_vfprintf_r+0x14dc>
80007fae:	ee ca ff ff 	sub	r10,r7,-1
80007fb2:	10 37       	cp.w	r7,r8
80007fb4:	e0 84 00 81 	brge	800080b6 <_vfprintf_r+0x14e2>
80007fb8:	fa cb f9 44 	sub	r11,sp,-1724
80007fbc:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007fc0:	c7 78       	rjmp	800080ae <_vfprintf_r+0x14da>
80007fc2:	ed b5 00 06 	bld	r5,0x6
80007fc6:	c4 b1       	brne	8000805c <_vfprintf_r+0x1488>
80007fc8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007fcc:	40 3c       	lddsp	r12,sp[0xc]
80007fce:	58 0c       	cp.w	r12,0
80007fd0:	c1 d0       	breq	8000800a <_vfprintf_r+0x1436>
80007fd2:	10 36       	cp.w	r6,r8
80007fd4:	c0 64       	brge	80007fe0 <_vfprintf_r+0x140c>
80007fd6:	fa cb f9 44 	sub	r11,sp,-1724
80007fda:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007fde:	c1 f8       	rjmp	8000801c <_vfprintf_r+0x1448>
80007fe0:	fa c8 f9 50 	sub	r8,sp,-1712
80007fe4:	1a d8       	st.w	--sp,r8
80007fe6:	fa c8 fa b8 	sub	r8,sp,-1352
80007fea:	1a d8       	st.w	--sp,r8
80007fec:	fa c8 fb b4 	sub	r8,sp,-1100
80007ff0:	1a d8       	st.w	--sp,r8
80007ff2:	fa c8 f9 40 	sub	r8,sp,-1728
80007ff6:	fa c9 ff b4 	sub	r9,sp,-76
80007ffa:	04 9a       	mov	r10,r2
80007ffc:	0c 9b       	mov	r11,r6
80007ffe:	08 9c       	mov	r12,r4
80008000:	fe b0 f4 52 	rcall	800068a4 <get_arg>
80008004:	2f dd       	sub	sp,-12
80008006:	98 18       	ld.sh	r8,r12[0x2]
80008008:	c2 78       	rjmp	80008056 <_vfprintf_r+0x1482>
8000800a:	ee ca ff ff 	sub	r10,r7,-1
8000800e:	10 37       	cp.w	r7,r8
80008010:	c0 a4       	brge	80008024 <_vfprintf_r+0x1450>
80008012:	fa c9 f9 44 	sub	r9,sp,-1724
80008016:	14 97       	mov	r7,r10
80008018:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000801c:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008020:	c1 b8       	rjmp	80008056 <_vfprintf_r+0x1482>
80008022:	d7 03       	nop
80008024:	41 09       	lddsp	r9,sp[0x40]
80008026:	59 f8       	cp.w	r8,31
80008028:	e0 89 00 13 	brgt	8000804e <_vfprintf_r+0x147a>
8000802c:	f2 cb ff fc 	sub	r11,r9,-4
80008030:	51 0b       	stdsp	sp[0x40],r11
80008032:	72 09       	ld.w	r9,r9[0x0]
80008034:	fa c6 f9 44 	sub	r6,sp,-1724
80008038:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000803c:	2f f8       	sub	r8,-1
8000803e:	f7 49 fd 88 	st.w	r11[-632],r9
80008042:	fb 48 06 b4 	st.w	sp[1716],r8
80008046:	14 97       	mov	r7,r10
80008048:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000804c:	c0 58       	rjmp	80008056 <_vfprintf_r+0x1482>
8000804e:	92 18       	ld.sh	r8,r9[0x2]
80008050:	14 97       	mov	r7,r10
80008052:	2f c9       	sub	r9,-4
80008054:	51 09       	stdsp	sp[0x40],r9
80008056:	5c 78       	castu.h	r8
80008058:	50 18       	stdsp	sp[0x4],r8
8000805a:	c4 68       	rjmp	800080e6 <_vfprintf_r+0x1512>
8000805c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008060:	40 3c       	lddsp	r12,sp[0xc]
80008062:	58 0c       	cp.w	r12,0
80008064:	c1 d0       	breq	8000809e <_vfprintf_r+0x14ca>
80008066:	10 36       	cp.w	r6,r8
80008068:	c0 64       	brge	80008074 <_vfprintf_r+0x14a0>
8000806a:	fa cb f9 44 	sub	r11,sp,-1724
8000806e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008072:	c1 f8       	rjmp	800080b0 <_vfprintf_r+0x14dc>
80008074:	fa c8 f9 50 	sub	r8,sp,-1712
80008078:	1a d8       	st.w	--sp,r8
8000807a:	fa c8 fa b8 	sub	r8,sp,-1352
8000807e:	0c 9b       	mov	r11,r6
80008080:	1a d8       	st.w	--sp,r8
80008082:	fa c8 fb b4 	sub	r8,sp,-1100
80008086:	04 9a       	mov	r10,r2
80008088:	1a d8       	st.w	--sp,r8
8000808a:	08 9c       	mov	r12,r4
8000808c:	fa c8 f9 40 	sub	r8,sp,-1728
80008090:	fa c9 ff b4 	sub	r9,sp,-76
80008094:	fe b0 f4 08 	rcall	800068a4 <get_arg>
80008098:	2f dd       	sub	sp,-12
8000809a:	78 0b       	ld.w	r11,r12[0x0]
8000809c:	c2 48       	rjmp	800080e4 <_vfprintf_r+0x1510>
8000809e:	ee ca ff ff 	sub	r10,r7,-1
800080a2:	10 37       	cp.w	r7,r8
800080a4:	c0 94       	brge	800080b6 <_vfprintf_r+0x14e2>
800080a6:	fa c9 f9 44 	sub	r9,sp,-1724
800080aa:	f2 06 00 36 	add	r6,r9,r6<<0x3
800080ae:	14 97       	mov	r7,r10
800080b0:	ec fb fd 88 	ld.w	r11,r6[-632]
800080b4:	c1 88       	rjmp	800080e4 <_vfprintf_r+0x1510>
800080b6:	41 09       	lddsp	r9,sp[0x40]
800080b8:	59 f8       	cp.w	r8,31
800080ba:	e0 89 00 11 	brgt	800080dc <_vfprintf_r+0x1508>
800080be:	f2 cb ff fc 	sub	r11,r9,-4
800080c2:	51 0b       	stdsp	sp[0x40],r11
800080c4:	fa c6 f9 44 	sub	r6,sp,-1724
800080c8:	72 0b       	ld.w	r11,r9[0x0]
800080ca:	ec 08 00 39 	add	r9,r6,r8<<0x3
800080ce:	f3 4b fd 88 	st.w	r9[-632],r11
800080d2:	2f f8       	sub	r8,-1
800080d4:	14 97       	mov	r7,r10
800080d6:	fb 48 06 b4 	st.w	sp[1716],r8
800080da:	c0 58       	rjmp	800080e4 <_vfprintf_r+0x1510>
800080dc:	72 0b       	ld.w	r11,r9[0x0]
800080de:	14 97       	mov	r7,r10
800080e0:	2f c9       	sub	r9,-4
800080e2:	51 09       	stdsp	sp[0x40],r9
800080e4:	50 1b       	stdsp	sp[0x4],r11
800080e6:	30 0e       	mov	lr,0
800080e8:	50 0e       	stdsp	sp[0x0],lr
800080ea:	40 08       	lddsp	r8,sp[0x0]
800080ec:	40 1c       	lddsp	r12,sp[0x4]
800080ee:	18 48       	or	r8,r12
800080f0:	5f 19       	srne	r9
800080f2:	0a 98       	mov	r8,r5
800080f4:	eb e9 00 09 	and	r9,r5,r9
800080f8:	a1 b8       	sbr	r8,0x1
800080fa:	58 09       	cp.w	r9,0
800080fc:	c0 70       	breq	8000810a <_vfprintf_r+0x1536>
800080fe:	10 95       	mov	r5,r8
80008100:	fb 60 06 b9 	st.b	sp[1721],r0
80008104:	33 08       	mov	r8,48
80008106:	fb 68 06 b8 	st.b	sp[1720],r8
8000810a:	30 28       	mov	r8,2
8000810c:	30 09       	mov	r9,0
8000810e:	fb 69 06 bb 	st.b	sp[1723],r9
80008112:	0a 99       	mov	r9,r5
80008114:	a7 d9       	cbr	r9,0x7
80008116:	40 2b       	lddsp	r11,sp[0x8]
80008118:	40 16       	lddsp	r6,sp[0x4]
8000811a:	58 0b       	cp.w	r11,0
8000811c:	5f 1a       	srne	r10
8000811e:	f2 05 17 40 	movge	r5,r9
80008122:	fa c2 f9 78 	sub	r2,sp,-1672
80008126:	40 09       	lddsp	r9,sp[0x0]
80008128:	0c 49       	or	r9,r6
8000812a:	5f 19       	srne	r9
8000812c:	f5 e9 10 09 	or	r9,r10,r9
80008130:	c5 c0       	breq	800081e8 <_vfprintf_r+0x1614>
80008132:	30 19       	mov	r9,1
80008134:	f2 08 18 00 	cp.b	r8,r9
80008138:	c0 60       	breq	80008144 <_vfprintf_r+0x1570>
8000813a:	30 29       	mov	r9,2
8000813c:	f2 08 18 00 	cp.b	r8,r9
80008140:	c0 41       	brne	80008148 <_vfprintf_r+0x1574>
80008142:	c3 c8       	rjmp	800081ba <_vfprintf_r+0x15e6>
80008144:	04 96       	mov	r6,r2
80008146:	c3 08       	rjmp	800081a6 <_vfprintf_r+0x15d2>
80008148:	04 96       	mov	r6,r2
8000814a:	fa e8 00 00 	ld.d	r8,sp[0]
8000814e:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80008152:	2d 0a       	sub	r10,-48
80008154:	0c fa       	st.b	--r6,r10
80008156:	f0 0b 16 03 	lsr	r11,r8,0x3
8000815a:	f2 0c 16 03 	lsr	r12,r9,0x3
8000815e:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80008162:	18 99       	mov	r9,r12
80008164:	16 98       	mov	r8,r11
80008166:	58 08       	cp.w	r8,0
80008168:	5c 29       	cpc	r9
8000816a:	cf 21       	brne	8000814e <_vfprintf_r+0x157a>
8000816c:	fa e9 00 00 	st.d	sp[0],r8
80008170:	ed b5 00 00 	bld	r5,0x0
80008174:	c4 51       	brne	800081fe <_vfprintf_r+0x162a>
80008176:	33 09       	mov	r9,48
80008178:	f2 0a 18 00 	cp.b	r10,r9
8000817c:	c4 10       	breq	800081fe <_vfprintf_r+0x162a>
8000817e:	0c f9       	st.b	--r6,r9
80008180:	c3 f8       	rjmp	800081fe <_vfprintf_r+0x162a>
80008182:	fa ea 00 00 	ld.d	r10,sp[0]
80008186:	30 a8       	mov	r8,10
80008188:	30 09       	mov	r9,0
8000818a:	e0 a0 1a 0d 	rcall	8000b5a4 <__avr32_umod64>
8000818e:	30 a8       	mov	r8,10
80008190:	2d 0a       	sub	r10,-48
80008192:	30 09       	mov	r9,0
80008194:	ac 8a       	st.b	r6[0x0],r10
80008196:	fa ea 00 00 	ld.d	r10,sp[0]
8000819a:	e0 a0 18 d3 	rcall	8000b340 <__avr32_udiv64>
8000819e:	16 99       	mov	r9,r11
800081a0:	14 98       	mov	r8,r10
800081a2:	fa e9 00 00 	st.d	sp[0],r8
800081a6:	20 16       	sub	r6,1
800081a8:	fa ea 00 00 	ld.d	r10,sp[0]
800081ac:	58 9a       	cp.w	r10,9
800081ae:	5c 2b       	cpc	r11
800081b0:	fe 9b ff e9 	brhi	80008182 <_vfprintf_r+0x15ae>
800081b4:	1b f8       	ld.ub	r8,sp[0x7]
800081b6:	2d 08       	sub	r8,-48
800081b8:	c2 08       	rjmp	800081f8 <_vfprintf_r+0x1624>
800081ba:	04 96       	mov	r6,r2
800081bc:	fa e8 00 00 	ld.d	r8,sp[0]
800081c0:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800081c4:	40 de       	lddsp	lr,sp[0x34]
800081c6:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800081ca:	0c fa       	st.b	--r6,r10
800081cc:	f2 0b 16 04 	lsr	r11,r9,0x4
800081d0:	f0 0a 16 04 	lsr	r10,r8,0x4
800081d4:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800081d8:	16 99       	mov	r9,r11
800081da:	14 98       	mov	r8,r10
800081dc:	58 08       	cp.w	r8,0
800081de:	5c 29       	cpc	r9
800081e0:	cf 01       	brne	800081c0 <_vfprintf_r+0x15ec>
800081e2:	fa e9 00 00 	st.d	sp[0],r8
800081e6:	c0 c8       	rjmp	800081fe <_vfprintf_r+0x162a>
800081e8:	58 08       	cp.w	r8,0
800081ea:	c0 91       	brne	800081fc <_vfprintf_r+0x1628>
800081ec:	ed b5 00 00 	bld	r5,0x0
800081f0:	c0 61       	brne	800081fc <_vfprintf_r+0x1628>
800081f2:	fa c6 f9 79 	sub	r6,sp,-1671
800081f6:	33 08       	mov	r8,48
800081f8:	ac 88       	st.b	r6[0x0],r8
800081fa:	c0 28       	rjmp	800081fe <_vfprintf_r+0x162a>
800081fc:	04 96       	mov	r6,r2
800081fe:	0c 12       	sub	r2,r6
80008200:	c1 c8       	rjmp	80008238 <_vfprintf_r+0x1664>
80008202:	50 a7       	stdsp	sp[0x28],r7
80008204:	50 80       	stdsp	sp[0x20],r0
80008206:	40 93       	lddsp	r3,sp[0x24]
80008208:	0c 97       	mov	r7,r6
8000820a:	10 90       	mov	r0,r8
8000820c:	04 94       	mov	r4,r2
8000820e:	40 41       	lddsp	r1,sp[0x10]
80008210:	58 08       	cp.w	r8,0
80008212:	e0 80 04 4f 	breq	80008ab0 <_vfprintf_r+0x1edc>
80008216:	fb 68 06 60 	st.b	sp[1632],r8
8000821a:	30 0c       	mov	r12,0
8000821c:	30 08       	mov	r8,0
8000821e:	30 12       	mov	r2,1
80008220:	fb 68 06 bb 	st.b	sp[1723],r8
80008224:	50 2c       	stdsp	sp[0x8],r12
80008226:	fa c6 f9 a0 	sub	r6,sp,-1632
8000822a:	c0 78       	rjmp	80008238 <_vfprintf_r+0x1664>
8000822c:	30 0b       	mov	r11,0
8000822e:	50 2b       	stdsp	sp[0x8],r11
80008230:	c0 48       	rjmp	80008238 <_vfprintf_r+0x1664>
80008232:	40 22       	lddsp	r2,sp[0x8]
80008234:	30 0a       	mov	r10,0
80008236:	50 2a       	stdsp	sp[0x8],r10
80008238:	40 29       	lddsp	r9,sp[0x8]
8000823a:	e4 09 0c 49 	max	r9,r2,r9
8000823e:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008242:	50 39       	stdsp	sp[0xc],r9
80008244:	0a 9e       	mov	lr,r5
80008246:	30 09       	mov	r9,0
80008248:	e2 1e 00 02 	andl	lr,0x2,COH
8000824c:	f2 08 18 00 	cp.b	r8,r9
80008250:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80008254:	f7 b8 01 ff 	subne	r8,-1
80008258:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000825c:	0a 9b       	mov	r11,r5
8000825e:	58 0e       	cp.w	lr,0
80008260:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80008264:	f7 bc 01 fe 	subne	r12,-2
80008268:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000826c:	e2 1b 00 84 	andl	r11,0x84,COH
80008270:	50 fe       	stdsp	sp[0x3c],lr
80008272:	50 9b       	stdsp	sp[0x24],r11
80008274:	c4 71       	brne	80008302 <_vfprintf_r+0x172e>
80008276:	40 8a       	lddsp	r10,sp[0x20]
80008278:	40 39       	lddsp	r9,sp[0xc]
8000827a:	12 1a       	sub	r10,r9
8000827c:	50 4a       	stdsp	sp[0x10],r10
8000827e:	58 0a       	cp.w	r10,0
80008280:	e0 89 00 20 	brgt	800082c0 <_vfprintf_r+0x16ec>
80008284:	c3 f8       	rjmp	80008302 <_vfprintf_r+0x172e>
80008286:	2f 09       	sub	r9,-16
80008288:	2f f8       	sub	r8,-1
8000828a:	fe ce b9 de 	sub	lr,pc,-17954
8000828e:	31 0c       	mov	r12,16
80008290:	fb 49 06 90 	st.w	sp[1680],r9
80008294:	87 0e       	st.w	r3[0x0],lr
80008296:	87 1c       	st.w	r3[0x4],r12
80008298:	fb 48 06 8c 	st.w	sp[1676],r8
8000829c:	58 78       	cp.w	r8,7
8000829e:	e0 89 00 04 	brgt	800082a6 <_vfprintf_r+0x16d2>
800082a2:	2f 83       	sub	r3,-8
800082a4:	c0 b8       	rjmp	800082ba <_vfprintf_r+0x16e6>
800082a6:	fa ca f9 78 	sub	r10,sp,-1672
800082aa:	02 9b       	mov	r11,r1
800082ac:	08 9c       	mov	r12,r4
800082ae:	fe b0 f4 85 	rcall	80006bb8 <__sprint_r>
800082b2:	e0 81 04 10 	brne	80008ad2 <_vfprintf_r+0x1efe>
800082b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800082ba:	40 4b       	lddsp	r11,sp[0x10]
800082bc:	21 0b       	sub	r11,16
800082be:	50 4b       	stdsp	sp[0x10],r11
800082c0:	fa f9 06 90 	ld.w	r9,sp[1680]
800082c4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800082c8:	fe ca ba 1c 	sub	r10,pc,-17892
800082cc:	40 4e       	lddsp	lr,sp[0x10]
800082ce:	59 0e       	cp.w	lr,16
800082d0:	fe 99 ff db 	brgt	80008286 <_vfprintf_r+0x16b2>
800082d4:	1c 09       	add	r9,lr
800082d6:	2f f8       	sub	r8,-1
800082d8:	87 0a       	st.w	r3[0x0],r10
800082da:	fb 49 06 90 	st.w	sp[1680],r9
800082de:	87 1e       	st.w	r3[0x4],lr
800082e0:	fb 48 06 8c 	st.w	sp[1676],r8
800082e4:	58 78       	cp.w	r8,7
800082e6:	e0 89 00 04 	brgt	800082ee <_vfprintf_r+0x171a>
800082ea:	2f 83       	sub	r3,-8
800082ec:	c0 b8       	rjmp	80008302 <_vfprintf_r+0x172e>
800082ee:	fa ca f9 78 	sub	r10,sp,-1672
800082f2:	02 9b       	mov	r11,r1
800082f4:	08 9c       	mov	r12,r4
800082f6:	fe b0 f4 61 	rcall	80006bb8 <__sprint_r>
800082fa:	e0 81 03 ec 	brne	80008ad2 <_vfprintf_r+0x1efe>
800082fe:	fa c3 f9 e0 	sub	r3,sp,-1568
80008302:	30 09       	mov	r9,0
80008304:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008308:	f2 08 18 00 	cp.b	r8,r9
8000830c:	c1 f0       	breq	8000834a <_vfprintf_r+0x1776>
8000830e:	fa f8 06 90 	ld.w	r8,sp[1680]
80008312:	fa c9 f9 45 	sub	r9,sp,-1723
80008316:	2f f8       	sub	r8,-1
80008318:	87 09       	st.w	r3[0x0],r9
8000831a:	fb 48 06 90 	st.w	sp[1680],r8
8000831e:	30 19       	mov	r9,1
80008320:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008324:	87 19       	st.w	r3[0x4],r9
80008326:	2f f8       	sub	r8,-1
80008328:	fb 48 06 8c 	st.w	sp[1676],r8
8000832c:	58 78       	cp.w	r8,7
8000832e:	e0 89 00 04 	brgt	80008336 <_vfprintf_r+0x1762>
80008332:	2f 83       	sub	r3,-8
80008334:	c0 b8       	rjmp	8000834a <_vfprintf_r+0x1776>
80008336:	fa ca f9 78 	sub	r10,sp,-1672
8000833a:	02 9b       	mov	r11,r1
8000833c:	08 9c       	mov	r12,r4
8000833e:	fe b0 f4 3d 	rcall	80006bb8 <__sprint_r>
80008342:	e0 81 03 c8 	brne	80008ad2 <_vfprintf_r+0x1efe>
80008346:	fa c3 f9 e0 	sub	r3,sp,-1568
8000834a:	40 fc       	lddsp	r12,sp[0x3c]
8000834c:	58 0c       	cp.w	r12,0
8000834e:	c1 f0       	breq	8000838c <_vfprintf_r+0x17b8>
80008350:	fa f8 06 90 	ld.w	r8,sp[1680]
80008354:	fa c9 f9 48 	sub	r9,sp,-1720
80008358:	2f e8       	sub	r8,-2
8000835a:	87 09       	st.w	r3[0x0],r9
8000835c:	fb 48 06 90 	st.w	sp[1680],r8
80008360:	30 29       	mov	r9,2
80008362:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008366:	87 19       	st.w	r3[0x4],r9
80008368:	2f f8       	sub	r8,-1
8000836a:	fb 48 06 8c 	st.w	sp[1676],r8
8000836e:	58 78       	cp.w	r8,7
80008370:	e0 89 00 04 	brgt	80008378 <_vfprintf_r+0x17a4>
80008374:	2f 83       	sub	r3,-8
80008376:	c0 b8       	rjmp	8000838c <_vfprintf_r+0x17b8>
80008378:	fa ca f9 78 	sub	r10,sp,-1672
8000837c:	02 9b       	mov	r11,r1
8000837e:	08 9c       	mov	r12,r4
80008380:	fe b0 f4 1c 	rcall	80006bb8 <__sprint_r>
80008384:	e0 81 03 a7 	brne	80008ad2 <_vfprintf_r+0x1efe>
80008388:	fa c3 f9 e0 	sub	r3,sp,-1568
8000838c:	40 9b       	lddsp	r11,sp[0x24]
8000838e:	e0 4b 00 80 	cp.w	r11,128
80008392:	c4 71       	brne	80008420 <_vfprintf_r+0x184c>
80008394:	40 8a       	lddsp	r10,sp[0x20]
80008396:	40 39       	lddsp	r9,sp[0xc]
80008398:	12 1a       	sub	r10,r9
8000839a:	50 4a       	stdsp	sp[0x10],r10
8000839c:	58 0a       	cp.w	r10,0
8000839e:	e0 89 00 20 	brgt	800083de <_vfprintf_r+0x180a>
800083a2:	c3 f8       	rjmp	80008420 <_vfprintf_r+0x184c>
800083a4:	2f 09       	sub	r9,-16
800083a6:	2f f8       	sub	r8,-1
800083a8:	fe ce ba ec 	sub	lr,pc,-17684
800083ac:	31 0c       	mov	r12,16
800083ae:	fb 49 06 90 	st.w	sp[1680],r9
800083b2:	87 0e       	st.w	r3[0x0],lr
800083b4:	87 1c       	st.w	r3[0x4],r12
800083b6:	fb 48 06 8c 	st.w	sp[1676],r8
800083ba:	58 78       	cp.w	r8,7
800083bc:	e0 89 00 04 	brgt	800083c4 <_vfprintf_r+0x17f0>
800083c0:	2f 83       	sub	r3,-8
800083c2:	c0 b8       	rjmp	800083d8 <_vfprintf_r+0x1804>
800083c4:	fa ca f9 78 	sub	r10,sp,-1672
800083c8:	02 9b       	mov	r11,r1
800083ca:	08 9c       	mov	r12,r4
800083cc:	fe b0 f3 f6 	rcall	80006bb8 <__sprint_r>
800083d0:	e0 81 03 81 	brne	80008ad2 <_vfprintf_r+0x1efe>
800083d4:	fa c3 f9 e0 	sub	r3,sp,-1568
800083d8:	40 4b       	lddsp	r11,sp[0x10]
800083da:	21 0b       	sub	r11,16
800083dc:	50 4b       	stdsp	sp[0x10],r11
800083de:	fa f9 06 90 	ld.w	r9,sp[1680]
800083e2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800083e6:	fe ca bb 2a 	sub	r10,pc,-17622
800083ea:	40 4e       	lddsp	lr,sp[0x10]
800083ec:	59 0e       	cp.w	lr,16
800083ee:	fe 99 ff db 	brgt	800083a4 <_vfprintf_r+0x17d0>
800083f2:	1c 09       	add	r9,lr
800083f4:	2f f8       	sub	r8,-1
800083f6:	87 0a       	st.w	r3[0x0],r10
800083f8:	fb 49 06 90 	st.w	sp[1680],r9
800083fc:	87 1e       	st.w	r3[0x4],lr
800083fe:	fb 48 06 8c 	st.w	sp[1676],r8
80008402:	58 78       	cp.w	r8,7
80008404:	e0 89 00 04 	brgt	8000840c <_vfprintf_r+0x1838>
80008408:	2f 83       	sub	r3,-8
8000840a:	c0 b8       	rjmp	80008420 <_vfprintf_r+0x184c>
8000840c:	fa ca f9 78 	sub	r10,sp,-1672
80008410:	02 9b       	mov	r11,r1
80008412:	08 9c       	mov	r12,r4
80008414:	fe b0 f3 d2 	rcall	80006bb8 <__sprint_r>
80008418:	e0 81 03 5d 	brne	80008ad2 <_vfprintf_r+0x1efe>
8000841c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008420:	40 2c       	lddsp	r12,sp[0x8]
80008422:	04 1c       	sub	r12,r2
80008424:	50 2c       	stdsp	sp[0x8],r12
80008426:	58 0c       	cp.w	r12,0
80008428:	e0 89 00 20 	brgt	80008468 <_vfprintf_r+0x1894>
8000842c:	c3 f8       	rjmp	800084aa <_vfprintf_r+0x18d6>
8000842e:	2f 09       	sub	r9,-16
80008430:	2f f8       	sub	r8,-1
80008432:	fe cb bb 76 	sub	r11,pc,-17546
80008436:	31 0a       	mov	r10,16
80008438:	fb 49 06 90 	st.w	sp[1680],r9
8000843c:	87 0b       	st.w	r3[0x0],r11
8000843e:	87 1a       	st.w	r3[0x4],r10
80008440:	fb 48 06 8c 	st.w	sp[1676],r8
80008444:	58 78       	cp.w	r8,7
80008446:	e0 89 00 04 	brgt	8000844e <_vfprintf_r+0x187a>
8000844a:	2f 83       	sub	r3,-8
8000844c:	c0 b8       	rjmp	80008462 <_vfprintf_r+0x188e>
8000844e:	fa ca f9 78 	sub	r10,sp,-1672
80008452:	02 9b       	mov	r11,r1
80008454:	08 9c       	mov	r12,r4
80008456:	fe b0 f3 b1 	rcall	80006bb8 <__sprint_r>
8000845a:	e0 81 03 3c 	brne	80008ad2 <_vfprintf_r+0x1efe>
8000845e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008462:	40 29       	lddsp	r9,sp[0x8]
80008464:	21 09       	sub	r9,16
80008466:	50 29       	stdsp	sp[0x8],r9
80008468:	fa f9 06 90 	ld.w	r9,sp[1680]
8000846c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008470:	fe ca bb b4 	sub	r10,pc,-17484
80008474:	40 2e       	lddsp	lr,sp[0x8]
80008476:	59 0e       	cp.w	lr,16
80008478:	fe 99 ff db 	brgt	8000842e <_vfprintf_r+0x185a>
8000847c:	1c 09       	add	r9,lr
8000847e:	2f f8       	sub	r8,-1
80008480:	87 0a       	st.w	r3[0x0],r10
80008482:	fb 49 06 90 	st.w	sp[1680],r9
80008486:	87 1e       	st.w	r3[0x4],lr
80008488:	fb 48 06 8c 	st.w	sp[1676],r8
8000848c:	58 78       	cp.w	r8,7
8000848e:	e0 89 00 04 	brgt	80008496 <_vfprintf_r+0x18c2>
80008492:	2f 83       	sub	r3,-8
80008494:	c0 b8       	rjmp	800084aa <_vfprintf_r+0x18d6>
80008496:	fa ca f9 78 	sub	r10,sp,-1672
8000849a:	02 9b       	mov	r11,r1
8000849c:	08 9c       	mov	r12,r4
8000849e:	fe b0 f3 8d 	rcall	80006bb8 <__sprint_r>
800084a2:	e0 81 03 18 	brne	80008ad2 <_vfprintf_r+0x1efe>
800084a6:	fa c3 f9 e0 	sub	r3,sp,-1568
800084aa:	ed b5 00 08 	bld	r5,0x8
800084ae:	c0 b0       	breq	800084c4 <_vfprintf_r+0x18f0>
800084b0:	fa f8 06 90 	ld.w	r8,sp[1680]
800084b4:	87 12       	st.w	r3[0x4],r2
800084b6:	87 06       	st.w	r3[0x0],r6
800084b8:	f0 02 00 02 	add	r2,r8,r2
800084bc:	fb 42 06 90 	st.w	sp[1680],r2
800084c0:	e0 8f 01 d4 	bral	80008868 <_vfprintf_r+0x1c94>
800084c4:	e0 40 00 65 	cp.w	r0,101
800084c8:	e0 8a 01 d6 	brle	80008874 <_vfprintf_r+0x1ca0>
800084cc:	30 08       	mov	r8,0
800084ce:	30 09       	mov	r9,0
800084d0:	40 5b       	lddsp	r11,sp[0x14]
800084d2:	40 7a       	lddsp	r10,sp[0x1c]
800084d4:	e0 a0 15 2f 	rcall	8000af32 <__avr32_f64_cmp_eq>
800084d8:	c7 90       	breq	800085ca <_vfprintf_r+0x19f6>
800084da:	fa f8 06 90 	ld.w	r8,sp[1680]
800084de:	fe c9 bc 36 	sub	r9,pc,-17354
800084e2:	2f f8       	sub	r8,-1
800084e4:	87 09       	st.w	r3[0x0],r9
800084e6:	fb 48 06 90 	st.w	sp[1680],r8
800084ea:	30 19       	mov	r9,1
800084ec:	fa f8 06 8c 	ld.w	r8,sp[1676]
800084f0:	87 19       	st.w	r3[0x4],r9
800084f2:	2f f8       	sub	r8,-1
800084f4:	fb 48 06 8c 	st.w	sp[1676],r8
800084f8:	58 78       	cp.w	r8,7
800084fa:	e0 89 00 05 	brgt	80008504 <_vfprintf_r+0x1930>
800084fe:	2f 83       	sub	r3,-8
80008500:	c0 c8       	rjmp	80008518 <_vfprintf_r+0x1944>
80008502:	d7 03       	nop
80008504:	fa ca f9 78 	sub	r10,sp,-1672
80008508:	02 9b       	mov	r11,r1
8000850a:	08 9c       	mov	r12,r4
8000850c:	fe b0 f3 56 	rcall	80006bb8 <__sprint_r>
80008510:	e0 81 02 e1 	brne	80008ad2 <_vfprintf_r+0x1efe>
80008514:	fa c3 f9 e0 	sub	r3,sp,-1568
80008518:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000851c:	40 6c       	lddsp	r12,sp[0x18]
8000851e:	18 38       	cp.w	r8,r12
80008520:	c0 55       	brlt	8000852a <_vfprintf_r+0x1956>
80008522:	ed b5 00 00 	bld	r5,0x0
80008526:	e0 81 02 6b 	brne	800089fc <_vfprintf_r+0x1e28>
8000852a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000852e:	2f f8       	sub	r8,-1
80008530:	40 cb       	lddsp	r11,sp[0x30]
80008532:	fb 48 06 90 	st.w	sp[1680],r8
80008536:	30 19       	mov	r9,1
80008538:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000853c:	87 0b       	st.w	r3[0x0],r11
8000853e:	2f f8       	sub	r8,-1
80008540:	87 19       	st.w	r3[0x4],r9
80008542:	fb 48 06 8c 	st.w	sp[1676],r8
80008546:	58 78       	cp.w	r8,7
80008548:	e0 89 00 04 	brgt	80008550 <_vfprintf_r+0x197c>
8000854c:	2f 83       	sub	r3,-8
8000854e:	c0 b8       	rjmp	80008564 <_vfprintf_r+0x1990>
80008550:	fa ca f9 78 	sub	r10,sp,-1672
80008554:	02 9b       	mov	r11,r1
80008556:	08 9c       	mov	r12,r4
80008558:	fe b0 f3 30 	rcall	80006bb8 <__sprint_r>
8000855c:	e0 81 02 bb 	brne	80008ad2 <_vfprintf_r+0x1efe>
80008560:	fa c3 f9 e0 	sub	r3,sp,-1568
80008564:	40 66       	lddsp	r6,sp[0x18]
80008566:	20 16       	sub	r6,1
80008568:	58 06       	cp.w	r6,0
8000856a:	e0 89 00 1d 	brgt	800085a4 <_vfprintf_r+0x19d0>
8000856e:	e0 8f 02 47 	bral	800089fc <_vfprintf_r+0x1e28>
80008572:	2f 09       	sub	r9,-16
80008574:	2f f8       	sub	r8,-1
80008576:	fb 49 06 90 	st.w	sp[1680],r9
8000857a:	87 02       	st.w	r3[0x0],r2
8000857c:	87 10       	st.w	r3[0x4],r0
8000857e:	fb 48 06 8c 	st.w	sp[1676],r8
80008582:	58 78       	cp.w	r8,7
80008584:	e0 89 00 04 	brgt	8000858c <_vfprintf_r+0x19b8>
80008588:	2f 83       	sub	r3,-8
8000858a:	c0 b8       	rjmp	800085a0 <_vfprintf_r+0x19cc>
8000858c:	fa ca f9 78 	sub	r10,sp,-1672
80008590:	02 9b       	mov	r11,r1
80008592:	08 9c       	mov	r12,r4
80008594:	fe b0 f3 12 	rcall	80006bb8 <__sprint_r>
80008598:	e0 81 02 9d 	brne	80008ad2 <_vfprintf_r+0x1efe>
8000859c:	fa c3 f9 e0 	sub	r3,sp,-1568
800085a0:	21 06       	sub	r6,16
800085a2:	c0 48       	rjmp	800085aa <_vfprintf_r+0x19d6>
800085a4:	fe c2 bc e8 	sub	r2,pc,-17176
800085a8:	31 00       	mov	r0,16
800085aa:	fa f9 06 90 	ld.w	r9,sp[1680]
800085ae:	fa f8 06 8c 	ld.w	r8,sp[1676]
800085b2:	fe ca bc f6 	sub	r10,pc,-17162
800085b6:	59 06       	cp.w	r6,16
800085b8:	fe 99 ff dd 	brgt	80008572 <_vfprintf_r+0x199e>
800085bc:	0c 09       	add	r9,r6
800085be:	87 0a       	st.w	r3[0x0],r10
800085c0:	fb 49 06 90 	st.w	sp[1680],r9
800085c4:	2f f8       	sub	r8,-1
800085c6:	87 16       	st.w	r3[0x4],r6
800085c8:	c5 39       	rjmp	8000886e <_vfprintf_r+0x1c9a>
800085ca:	fa fa 06 ac 	ld.w	r10,sp[1708]
800085ce:	58 0a       	cp.w	r10,0
800085d0:	e0 89 00 92 	brgt	800086f4 <_vfprintf_r+0x1b20>
800085d4:	fa f8 06 90 	ld.w	r8,sp[1680]
800085d8:	fe c9 bd 30 	sub	r9,pc,-17104
800085dc:	2f f8       	sub	r8,-1
800085de:	87 09       	st.w	r3[0x0],r9
800085e0:	fb 48 06 90 	st.w	sp[1680],r8
800085e4:	30 19       	mov	r9,1
800085e6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800085ea:	87 19       	st.w	r3[0x4],r9
800085ec:	2f f8       	sub	r8,-1
800085ee:	fb 48 06 8c 	st.w	sp[1676],r8
800085f2:	58 78       	cp.w	r8,7
800085f4:	e0 89 00 04 	brgt	800085fc <_vfprintf_r+0x1a28>
800085f8:	2f 83       	sub	r3,-8
800085fa:	c0 b8       	rjmp	80008610 <_vfprintf_r+0x1a3c>
800085fc:	fa ca f9 78 	sub	r10,sp,-1672
80008600:	02 9b       	mov	r11,r1
80008602:	08 9c       	mov	r12,r4
80008604:	fe b0 f2 da 	rcall	80006bb8 <__sprint_r>
80008608:	e0 81 02 65 	brne	80008ad2 <_vfprintf_r+0x1efe>
8000860c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008610:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008614:	58 08       	cp.w	r8,0
80008616:	c0 81       	brne	80008626 <_vfprintf_r+0x1a52>
80008618:	40 6a       	lddsp	r10,sp[0x18]
8000861a:	58 0a       	cp.w	r10,0
8000861c:	c0 51       	brne	80008626 <_vfprintf_r+0x1a52>
8000861e:	ed b5 00 00 	bld	r5,0x0
80008622:	e0 81 01 ed 	brne	800089fc <_vfprintf_r+0x1e28>
80008626:	40 c9       	lddsp	r9,sp[0x30]
80008628:	fa f8 06 90 	ld.w	r8,sp[1680]
8000862c:	2f f8       	sub	r8,-1
8000862e:	87 09       	st.w	r3[0x0],r9
80008630:	fb 48 06 90 	st.w	sp[1680],r8
80008634:	30 19       	mov	r9,1
80008636:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000863a:	87 19       	st.w	r3[0x4],r9
8000863c:	2f f8       	sub	r8,-1
8000863e:	fb 48 06 8c 	st.w	sp[1676],r8
80008642:	58 78       	cp.w	r8,7
80008644:	e0 89 00 04 	brgt	8000864c <_vfprintf_r+0x1a78>
80008648:	2f 83       	sub	r3,-8
8000864a:	c0 b8       	rjmp	80008660 <_vfprintf_r+0x1a8c>
8000864c:	fa ca f9 78 	sub	r10,sp,-1672
80008650:	02 9b       	mov	r11,r1
80008652:	08 9c       	mov	r12,r4
80008654:	fe b0 f2 b2 	rcall	80006bb8 <__sprint_r>
80008658:	e0 81 02 3d 	brne	80008ad2 <_vfprintf_r+0x1efe>
8000865c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008660:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008664:	5c 32       	neg	r2
80008666:	58 02       	cp.w	r2,0
80008668:	e0 89 00 1d 	brgt	800086a2 <_vfprintf_r+0x1ace>
8000866c:	c3 d8       	rjmp	800086e6 <_vfprintf_r+0x1b12>
8000866e:	2f 09       	sub	r9,-16
80008670:	2f f8       	sub	r8,-1
80008672:	31 0e       	mov	lr,16
80008674:	fb 49 06 90 	st.w	sp[1680],r9
80008678:	87 00       	st.w	r3[0x0],r0
8000867a:	87 1e       	st.w	r3[0x4],lr
8000867c:	fb 48 06 8c 	st.w	sp[1676],r8
80008680:	58 78       	cp.w	r8,7
80008682:	e0 89 00 04 	brgt	8000868a <_vfprintf_r+0x1ab6>
80008686:	2f 83       	sub	r3,-8
80008688:	c0 b8       	rjmp	8000869e <_vfprintf_r+0x1aca>
8000868a:	fa ca f9 78 	sub	r10,sp,-1672
8000868e:	02 9b       	mov	r11,r1
80008690:	08 9c       	mov	r12,r4
80008692:	fe b0 f2 93 	rcall	80006bb8 <__sprint_r>
80008696:	e0 81 02 1e 	brne	80008ad2 <_vfprintf_r+0x1efe>
8000869a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000869e:	21 02       	sub	r2,16
800086a0:	c0 38       	rjmp	800086a6 <_vfprintf_r+0x1ad2>
800086a2:	fe c0 bd e6 	sub	r0,pc,-16922
800086a6:	fa f9 06 90 	ld.w	r9,sp[1680]
800086aa:	fa f8 06 8c 	ld.w	r8,sp[1676]
800086ae:	fe ca bd f2 	sub	r10,pc,-16910
800086b2:	59 02       	cp.w	r2,16
800086b4:	fe 99 ff dd 	brgt	8000866e <_vfprintf_r+0x1a9a>
800086b8:	04 09       	add	r9,r2
800086ba:	2f f8       	sub	r8,-1
800086bc:	87 0a       	st.w	r3[0x0],r10
800086be:	fb 49 06 90 	st.w	sp[1680],r9
800086c2:	87 12       	st.w	r3[0x4],r2
800086c4:	fb 48 06 8c 	st.w	sp[1676],r8
800086c8:	58 78       	cp.w	r8,7
800086ca:	e0 89 00 04 	brgt	800086d2 <_vfprintf_r+0x1afe>
800086ce:	2f 83       	sub	r3,-8
800086d0:	c0 b8       	rjmp	800086e6 <_vfprintf_r+0x1b12>
800086d2:	fa ca f9 78 	sub	r10,sp,-1672
800086d6:	02 9b       	mov	r11,r1
800086d8:	08 9c       	mov	r12,r4
800086da:	fe b0 f2 6f 	rcall	80006bb8 <__sprint_r>
800086de:	e0 81 01 fa 	brne	80008ad2 <_vfprintf_r+0x1efe>
800086e2:	fa c3 f9 e0 	sub	r3,sp,-1568
800086e6:	40 6c       	lddsp	r12,sp[0x18]
800086e8:	fa f8 06 90 	ld.w	r8,sp[1680]
800086ec:	87 06       	st.w	r3[0x0],r6
800086ee:	87 1c       	st.w	r3[0x4],r12
800086f0:	18 08       	add	r8,r12
800086f2:	cb 98       	rjmp	80008864 <_vfprintf_r+0x1c90>
800086f4:	fa f9 06 90 	ld.w	r9,sp[1680]
800086f8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800086fc:	40 6b       	lddsp	r11,sp[0x18]
800086fe:	16 3a       	cp.w	r10,r11
80008700:	c6 f5       	brlt	800087de <_vfprintf_r+0x1c0a>
80008702:	16 09       	add	r9,r11
80008704:	2f f8       	sub	r8,-1
80008706:	87 06       	st.w	r3[0x0],r6
80008708:	fb 49 06 90 	st.w	sp[1680],r9
8000870c:	87 1b       	st.w	r3[0x4],r11
8000870e:	fb 48 06 8c 	st.w	sp[1676],r8
80008712:	58 78       	cp.w	r8,7
80008714:	e0 89 00 04 	brgt	8000871c <_vfprintf_r+0x1b48>
80008718:	2f 83       	sub	r3,-8
8000871a:	c0 b8       	rjmp	80008730 <_vfprintf_r+0x1b5c>
8000871c:	fa ca f9 78 	sub	r10,sp,-1672
80008720:	02 9b       	mov	r11,r1
80008722:	08 9c       	mov	r12,r4
80008724:	fe b0 f2 4a 	rcall	80006bb8 <__sprint_r>
80008728:	e0 81 01 d5 	brne	80008ad2 <_vfprintf_r+0x1efe>
8000872c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008730:	fa f6 06 ac 	ld.w	r6,sp[1708]
80008734:	40 6a       	lddsp	r10,sp[0x18]
80008736:	14 16       	sub	r6,r10
80008738:	58 06       	cp.w	r6,0
8000873a:	e0 89 00 1c 	brgt	80008772 <_vfprintf_r+0x1b9e>
8000873e:	c3 d8       	rjmp	800087b8 <_vfprintf_r+0x1be4>
80008740:	2f 09       	sub	r9,-16
80008742:	2f f8       	sub	r8,-1
80008744:	fb 49 06 90 	st.w	sp[1680],r9
80008748:	87 02       	st.w	r3[0x0],r2
8000874a:	87 10       	st.w	r3[0x4],r0
8000874c:	fb 48 06 8c 	st.w	sp[1676],r8
80008750:	58 78       	cp.w	r8,7
80008752:	e0 89 00 04 	brgt	8000875a <_vfprintf_r+0x1b86>
80008756:	2f 83       	sub	r3,-8
80008758:	c0 b8       	rjmp	8000876e <_vfprintf_r+0x1b9a>
8000875a:	fa ca f9 78 	sub	r10,sp,-1672
8000875e:	02 9b       	mov	r11,r1
80008760:	08 9c       	mov	r12,r4
80008762:	fe b0 f2 2b 	rcall	80006bb8 <__sprint_r>
80008766:	e0 81 01 b6 	brne	80008ad2 <_vfprintf_r+0x1efe>
8000876a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000876e:	21 06       	sub	r6,16
80008770:	c0 48       	rjmp	80008778 <_vfprintf_r+0x1ba4>
80008772:	fe c2 be b6 	sub	r2,pc,-16714
80008776:	31 00       	mov	r0,16
80008778:	fa f9 06 90 	ld.w	r9,sp[1680]
8000877c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008780:	fe ca be c4 	sub	r10,pc,-16700
80008784:	59 06       	cp.w	r6,16
80008786:	fe 99 ff dd 	brgt	80008740 <_vfprintf_r+0x1b6c>
8000878a:	0c 09       	add	r9,r6
8000878c:	2f f8       	sub	r8,-1
8000878e:	87 0a       	st.w	r3[0x0],r10
80008790:	fb 49 06 90 	st.w	sp[1680],r9
80008794:	87 16       	st.w	r3[0x4],r6
80008796:	fb 48 06 8c 	st.w	sp[1676],r8
8000879a:	58 78       	cp.w	r8,7
8000879c:	e0 89 00 04 	brgt	800087a4 <_vfprintf_r+0x1bd0>
800087a0:	2f 83       	sub	r3,-8
800087a2:	c0 b8       	rjmp	800087b8 <_vfprintf_r+0x1be4>
800087a4:	fa ca f9 78 	sub	r10,sp,-1672
800087a8:	02 9b       	mov	r11,r1
800087aa:	08 9c       	mov	r12,r4
800087ac:	fe b0 f2 06 	rcall	80006bb8 <__sprint_r>
800087b0:	e0 81 01 91 	brne	80008ad2 <_vfprintf_r+0x1efe>
800087b4:	fa c3 f9 e0 	sub	r3,sp,-1568
800087b8:	ed b5 00 00 	bld	r5,0x0
800087bc:	e0 81 01 20 	brne	800089fc <_vfprintf_r+0x1e28>
800087c0:	40 c9       	lddsp	r9,sp[0x30]
800087c2:	fa f8 06 90 	ld.w	r8,sp[1680]
800087c6:	2f f8       	sub	r8,-1
800087c8:	87 09       	st.w	r3[0x0],r9
800087ca:	fb 48 06 90 	st.w	sp[1680],r8
800087ce:	30 19       	mov	r9,1
800087d0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800087d4:	87 19       	st.w	r3[0x4],r9
800087d6:	2f f8       	sub	r8,-1
800087d8:	fb 48 06 8c 	st.w	sp[1676],r8
800087dc:	c0 29       	rjmp	800089e0 <_vfprintf_r+0x1e0c>
800087de:	14 09       	add	r9,r10
800087e0:	2f f8       	sub	r8,-1
800087e2:	fb 49 06 90 	st.w	sp[1680],r9
800087e6:	87 06       	st.w	r3[0x0],r6
800087e8:	87 1a       	st.w	r3[0x4],r10
800087ea:	fb 48 06 8c 	st.w	sp[1676],r8
800087ee:	58 78       	cp.w	r8,7
800087f0:	e0 89 00 04 	brgt	800087f8 <_vfprintf_r+0x1c24>
800087f4:	2f 83       	sub	r3,-8
800087f6:	c0 b8       	rjmp	8000880c <_vfprintf_r+0x1c38>
800087f8:	fa ca f9 78 	sub	r10,sp,-1672
800087fc:	02 9b       	mov	r11,r1
800087fe:	08 9c       	mov	r12,r4
80008800:	fe b0 f1 dc 	rcall	80006bb8 <__sprint_r>
80008804:	e0 81 01 67 	brne	80008ad2 <_vfprintf_r+0x1efe>
80008808:	fa c3 f9 e0 	sub	r3,sp,-1568
8000880c:	40 c8       	lddsp	r8,sp[0x30]
8000880e:	87 08       	st.w	r3[0x0],r8
80008810:	fa f8 06 90 	ld.w	r8,sp[1680]
80008814:	2f f8       	sub	r8,-1
80008816:	30 19       	mov	r9,1
80008818:	fb 48 06 90 	st.w	sp[1680],r8
8000881c:	87 19       	st.w	r3[0x4],r9
8000881e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008822:	2f f8       	sub	r8,-1
80008824:	fb 48 06 8c 	st.w	sp[1676],r8
80008828:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000882c:	58 78       	cp.w	r8,7
8000882e:	e0 89 00 04 	brgt	80008836 <_vfprintf_r+0x1c62>
80008832:	2f 83       	sub	r3,-8
80008834:	c0 b8       	rjmp	8000884a <_vfprintf_r+0x1c76>
80008836:	fa ca f9 78 	sub	r10,sp,-1672
8000883a:	02 9b       	mov	r11,r1
8000883c:	08 9c       	mov	r12,r4
8000883e:	fe b0 f1 bd 	rcall	80006bb8 <__sprint_r>
80008842:	e0 81 01 48 	brne	80008ad2 <_vfprintf_r+0x1efe>
80008846:	fa c3 f9 e0 	sub	r3,sp,-1568
8000884a:	04 06       	add	r6,r2
8000884c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008850:	87 06       	st.w	r3[0x0],r6
80008852:	fa f9 06 90 	ld.w	r9,sp[1680]
80008856:	40 66       	lddsp	r6,sp[0x18]
80008858:	40 6e       	lddsp	lr,sp[0x18]
8000885a:	10 16       	sub	r6,r8
8000885c:	f2 08 01 08 	sub	r8,r9,r8
80008860:	87 16       	st.w	r3[0x4],r6
80008862:	1c 08       	add	r8,lr
80008864:	fb 48 06 90 	st.w	sp[1680],r8
80008868:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000886c:	2f f8       	sub	r8,-1
8000886e:	fb 48 06 8c 	st.w	sp[1676],r8
80008872:	cb 78       	rjmp	800089e0 <_vfprintf_r+0x1e0c>
80008874:	40 6c       	lddsp	r12,sp[0x18]
80008876:	58 1c       	cp.w	r12,1
80008878:	e0 89 00 06 	brgt	80008884 <_vfprintf_r+0x1cb0>
8000887c:	ed b5 00 00 	bld	r5,0x0
80008880:	e0 81 00 85 	brne	8000898a <_vfprintf_r+0x1db6>
80008884:	fa f8 06 90 	ld.w	r8,sp[1680]
80008888:	2f f8       	sub	r8,-1
8000888a:	30 19       	mov	r9,1
8000888c:	fb 48 06 90 	st.w	sp[1680],r8
80008890:	87 06       	st.w	r3[0x0],r6
80008892:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008896:	87 19       	st.w	r3[0x4],r9
80008898:	2f f8       	sub	r8,-1
8000889a:	fb 48 06 8c 	st.w	sp[1676],r8
8000889e:	58 78       	cp.w	r8,7
800088a0:	e0 89 00 04 	brgt	800088a8 <_vfprintf_r+0x1cd4>
800088a4:	2f 83       	sub	r3,-8
800088a6:	c0 b8       	rjmp	800088bc <_vfprintf_r+0x1ce8>
800088a8:	fa ca f9 78 	sub	r10,sp,-1672
800088ac:	02 9b       	mov	r11,r1
800088ae:	08 9c       	mov	r12,r4
800088b0:	fe b0 f1 84 	rcall	80006bb8 <__sprint_r>
800088b4:	e0 81 01 0f 	brne	80008ad2 <_vfprintf_r+0x1efe>
800088b8:	fa c3 f9 e0 	sub	r3,sp,-1568
800088bc:	fa f8 06 90 	ld.w	r8,sp[1680]
800088c0:	2f f8       	sub	r8,-1
800088c2:	40 cb       	lddsp	r11,sp[0x30]
800088c4:	fb 48 06 90 	st.w	sp[1680],r8
800088c8:	30 19       	mov	r9,1
800088ca:	fa f8 06 8c 	ld.w	r8,sp[1676]
800088ce:	87 0b       	st.w	r3[0x0],r11
800088d0:	2f f8       	sub	r8,-1
800088d2:	87 19       	st.w	r3[0x4],r9
800088d4:	fb 48 06 8c 	st.w	sp[1676],r8
800088d8:	58 78       	cp.w	r8,7
800088da:	e0 89 00 05 	brgt	800088e4 <_vfprintf_r+0x1d10>
800088de:	2f 83       	sub	r3,-8
800088e0:	c0 c8       	rjmp	800088f8 <_vfprintf_r+0x1d24>
800088e2:	d7 03       	nop
800088e4:	fa ca f9 78 	sub	r10,sp,-1672
800088e8:	02 9b       	mov	r11,r1
800088ea:	08 9c       	mov	r12,r4
800088ec:	fe b0 f1 66 	rcall	80006bb8 <__sprint_r>
800088f0:	e0 81 00 f1 	brne	80008ad2 <_vfprintf_r+0x1efe>
800088f4:	fa c3 f9 e0 	sub	r3,sp,-1568
800088f8:	30 08       	mov	r8,0
800088fa:	30 09       	mov	r9,0
800088fc:	40 5b       	lddsp	r11,sp[0x14]
800088fe:	40 7a       	lddsp	r10,sp[0x1c]
80008900:	e0 a0 13 19 	rcall	8000af32 <__avr32_f64_cmp_eq>
80008904:	40 68       	lddsp	r8,sp[0x18]
80008906:	20 18       	sub	r8,1
80008908:	58 0c       	cp.w	r12,0
8000890a:	c0 d1       	brne	80008924 <_vfprintf_r+0x1d50>
8000890c:	2f f6       	sub	r6,-1
8000890e:	87 18       	st.w	r3[0x4],r8
80008910:	87 06       	st.w	r3[0x0],r6
80008912:	fa f6 06 90 	ld.w	r6,sp[1680]
80008916:	10 06       	add	r6,r8
80008918:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000891c:	fb 46 06 90 	st.w	sp[1680],r6
80008920:	2f f8       	sub	r8,-1
80008922:	c3 18       	rjmp	80008984 <_vfprintf_r+0x1db0>
80008924:	10 96       	mov	r6,r8
80008926:	58 08       	cp.w	r8,0
80008928:	e0 89 00 1c 	brgt	80008960 <_vfprintf_r+0x1d8c>
8000892c:	c4 b8       	rjmp	800089c2 <_vfprintf_r+0x1dee>
8000892e:	2f 09       	sub	r9,-16
80008930:	2f f8       	sub	r8,-1
80008932:	fb 49 06 90 	st.w	sp[1680],r9
80008936:	87 02       	st.w	r3[0x0],r2
80008938:	87 10       	st.w	r3[0x4],r0
8000893a:	fb 48 06 8c 	st.w	sp[1676],r8
8000893e:	58 78       	cp.w	r8,7
80008940:	e0 89 00 04 	brgt	80008948 <_vfprintf_r+0x1d74>
80008944:	2f 83       	sub	r3,-8
80008946:	c0 b8       	rjmp	8000895c <_vfprintf_r+0x1d88>
80008948:	fa ca f9 78 	sub	r10,sp,-1672
8000894c:	02 9b       	mov	r11,r1
8000894e:	08 9c       	mov	r12,r4
80008950:	fe b0 f1 34 	rcall	80006bb8 <__sprint_r>
80008954:	e0 81 00 bf 	brne	80008ad2 <_vfprintf_r+0x1efe>
80008958:	fa c3 f9 e0 	sub	r3,sp,-1568
8000895c:	21 06       	sub	r6,16
8000895e:	c0 48       	rjmp	80008966 <_vfprintf_r+0x1d92>
80008960:	fe c2 c0 a4 	sub	r2,pc,-16220
80008964:	31 00       	mov	r0,16
80008966:	fa f9 06 90 	ld.w	r9,sp[1680]
8000896a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000896e:	fe ca c0 b2 	sub	r10,pc,-16206
80008972:	59 06       	cp.w	r6,16
80008974:	fe 99 ff dd 	brgt	8000892e <_vfprintf_r+0x1d5a>
80008978:	0c 09       	add	r9,r6
8000897a:	87 0a       	st.w	r3[0x0],r10
8000897c:	fb 49 06 90 	st.w	sp[1680],r9
80008980:	2f f8       	sub	r8,-1
80008982:	87 16       	st.w	r3[0x4],r6
80008984:	fb 48 06 8c 	st.w	sp[1676],r8
80008988:	c0 e8       	rjmp	800089a4 <_vfprintf_r+0x1dd0>
8000898a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000898e:	2f f8       	sub	r8,-1
80008990:	30 19       	mov	r9,1
80008992:	fb 48 06 90 	st.w	sp[1680],r8
80008996:	87 06       	st.w	r3[0x0],r6
80008998:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000899c:	87 19       	st.w	r3[0x4],r9
8000899e:	2f f8       	sub	r8,-1
800089a0:	fb 48 06 8c 	st.w	sp[1676],r8
800089a4:	58 78       	cp.w	r8,7
800089a6:	e0 89 00 04 	brgt	800089ae <_vfprintf_r+0x1dda>
800089aa:	2f 83       	sub	r3,-8
800089ac:	c0 b8       	rjmp	800089c2 <_vfprintf_r+0x1dee>
800089ae:	fa ca f9 78 	sub	r10,sp,-1672
800089b2:	02 9b       	mov	r11,r1
800089b4:	08 9c       	mov	r12,r4
800089b6:	fe b0 f1 01 	rcall	80006bb8 <__sprint_r>
800089ba:	e0 81 00 8c 	brne	80008ad2 <_vfprintf_r+0x1efe>
800089be:	fa c3 f9 e0 	sub	r3,sp,-1568
800089c2:	40 ea       	lddsp	r10,sp[0x38]
800089c4:	fa f8 06 90 	ld.w	r8,sp[1680]
800089c8:	14 08       	add	r8,r10
800089ca:	fa c9 f9 64 	sub	r9,sp,-1692
800089ce:	fb 48 06 90 	st.w	sp[1680],r8
800089d2:	87 1a       	st.w	r3[0x4],r10
800089d4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800089d8:	87 09       	st.w	r3[0x0],r9
800089da:	2f f8       	sub	r8,-1
800089dc:	fb 48 06 8c 	st.w	sp[1676],r8
800089e0:	58 78       	cp.w	r8,7
800089e2:	e0 89 00 04 	brgt	800089ea <_vfprintf_r+0x1e16>
800089e6:	2f 83       	sub	r3,-8
800089e8:	c0 a8       	rjmp	800089fc <_vfprintf_r+0x1e28>
800089ea:	fa ca f9 78 	sub	r10,sp,-1672
800089ee:	02 9b       	mov	r11,r1
800089f0:	08 9c       	mov	r12,r4
800089f2:	fe b0 f0 e3 	rcall	80006bb8 <__sprint_r>
800089f6:	c6 e1       	brne	80008ad2 <_vfprintf_r+0x1efe>
800089f8:	fa c3 f9 e0 	sub	r3,sp,-1568
800089fc:	e2 15 00 04 	andl	r5,0x4,COH
80008a00:	c3 f0       	breq	80008a7e <_vfprintf_r+0x1eaa>
80008a02:	40 86       	lddsp	r6,sp[0x20]
80008a04:	40 39       	lddsp	r9,sp[0xc]
80008a06:	12 16       	sub	r6,r9
80008a08:	58 06       	cp.w	r6,0
80008a0a:	e0 89 00 1a 	brgt	80008a3e <_vfprintf_r+0x1e6a>
80008a0e:	c3 88       	rjmp	80008a7e <_vfprintf_r+0x1eaa>
80008a10:	2f 09       	sub	r9,-16
80008a12:	2f f8       	sub	r8,-1
80008a14:	fb 49 06 90 	st.w	sp[1680],r9
80008a18:	87 05       	st.w	r3[0x0],r5
80008a1a:	87 12       	st.w	r3[0x4],r2
80008a1c:	fb 48 06 8c 	st.w	sp[1676],r8
80008a20:	58 78       	cp.w	r8,7
80008a22:	e0 89 00 04 	brgt	80008a2a <_vfprintf_r+0x1e56>
80008a26:	2f 83       	sub	r3,-8
80008a28:	c0 98       	rjmp	80008a3a <_vfprintf_r+0x1e66>
80008a2a:	00 9a       	mov	r10,r0
80008a2c:	02 9b       	mov	r11,r1
80008a2e:	08 9c       	mov	r12,r4
80008a30:	fe b0 f0 c4 	rcall	80006bb8 <__sprint_r>
80008a34:	c4 f1       	brne	80008ad2 <_vfprintf_r+0x1efe>
80008a36:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a3a:	21 06       	sub	r6,16
80008a3c:	c0 68       	rjmp	80008a48 <_vfprintf_r+0x1e74>
80008a3e:	fe c5 c1 92 	sub	r5,pc,-15982
80008a42:	31 02       	mov	r2,16
80008a44:	fa c0 f9 78 	sub	r0,sp,-1672
80008a48:	fa f9 06 90 	ld.w	r9,sp[1680]
80008a4c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a50:	fe ca c1 a4 	sub	r10,pc,-15964
80008a54:	59 06       	cp.w	r6,16
80008a56:	fe 99 ff dd 	brgt	80008a10 <_vfprintf_r+0x1e3c>
80008a5a:	0c 09       	add	r9,r6
80008a5c:	2f f8       	sub	r8,-1
80008a5e:	87 0a       	st.w	r3[0x0],r10
80008a60:	87 16       	st.w	r3[0x4],r6
80008a62:	fb 49 06 90 	st.w	sp[1680],r9
80008a66:	fb 48 06 8c 	st.w	sp[1676],r8
80008a6a:	58 78       	cp.w	r8,7
80008a6c:	e0 8a 00 09 	brle	80008a7e <_vfprintf_r+0x1eaa>
80008a70:	fa ca f9 78 	sub	r10,sp,-1672
80008a74:	02 9b       	mov	r11,r1
80008a76:	08 9c       	mov	r12,r4
80008a78:	fe b0 f0 a0 	rcall	80006bb8 <__sprint_r>
80008a7c:	c2 b1       	brne	80008ad2 <_vfprintf_r+0x1efe>
80008a7e:	40 bc       	lddsp	r12,sp[0x2c]
80008a80:	40 36       	lddsp	r6,sp[0xc]
80008a82:	40 8e       	lddsp	lr,sp[0x20]
80008a84:	ec 0e 0c 48 	max	r8,r6,lr
80008a88:	10 0c       	add	r12,r8
80008a8a:	50 bc       	stdsp	sp[0x2c],r12
80008a8c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008a90:	58 08       	cp.w	r8,0
80008a92:	c0 80       	breq	80008aa2 <_vfprintf_r+0x1ece>
80008a94:	fa ca f9 78 	sub	r10,sp,-1672
80008a98:	02 9b       	mov	r11,r1
80008a9a:	08 9c       	mov	r12,r4
80008a9c:	fe b0 f0 8e 	rcall	80006bb8 <__sprint_r>
80008aa0:	c1 91       	brne	80008ad2 <_vfprintf_r+0x1efe>
80008aa2:	30 0b       	mov	r11,0
80008aa4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008aa8:	fb 4b 06 8c 	st.w	sp[1676],r11
80008aac:	fe 9f f1 22 	bral	80006cf0 <_vfprintf_r+0x11c>
80008ab0:	08 95       	mov	r5,r4
80008ab2:	fa f8 06 90 	ld.w	r8,sp[1680]
80008ab6:	58 08       	cp.w	r8,0
80008ab8:	c0 80       	breq	80008ac8 <_vfprintf_r+0x1ef4>
80008aba:	08 9c       	mov	r12,r4
80008abc:	fa ca f9 78 	sub	r10,sp,-1672
80008ac0:	02 9b       	mov	r11,r1
80008ac2:	fe b0 f0 7b 	rcall	80006bb8 <__sprint_r>
80008ac6:	c0 61       	brne	80008ad2 <_vfprintf_r+0x1efe>
80008ac8:	30 08       	mov	r8,0
80008aca:	fb 48 06 8c 	st.w	sp[1676],r8
80008ace:	c0 28       	rjmp	80008ad2 <_vfprintf_r+0x1efe>
80008ad0:	40 41       	lddsp	r1,sp[0x10]
80008ad2:	82 68       	ld.sh	r8,r1[0xc]
80008ad4:	ed b8 00 06 	bld	r8,0x6
80008ad8:	c0 31       	brne	80008ade <_vfprintf_r+0x1f0a>
80008ada:	3f fa       	mov	r10,-1
80008adc:	50 ba       	stdsp	sp[0x2c],r10
80008ade:	40 bc       	lddsp	r12,sp[0x2c]
80008ae0:	fe 3d f9 44 	sub	sp,-1724
80008ae4:	d8 32       	popm	r0-r7,pc
80008ae6:	d7 03       	nop

80008ae8 <__swsetup_r>:
80008ae8:	d4 21       	pushm	r4-r7,lr
80008aea:	e0 68 0a 38 	mov	r8,2616
80008aee:	18 96       	mov	r6,r12
80008af0:	16 97       	mov	r7,r11
80008af2:	70 0c       	ld.w	r12,r8[0x0]
80008af4:	58 0c       	cp.w	r12,0
80008af6:	c0 60       	breq	80008b02 <__swsetup_r+0x1a>
80008af8:	78 68       	ld.w	r8,r12[0x18]
80008afa:	58 08       	cp.w	r8,0
80008afc:	c0 31       	brne	80008b02 <__swsetup_r+0x1a>
80008afe:	e0 a0 07 bf 	rcall	80009a7c <__sinit>
80008b02:	fe c8 c1 26 	sub	r8,pc,-16090
80008b06:	10 37       	cp.w	r7,r8
80008b08:	c0 61       	brne	80008b14 <__swsetup_r+0x2c>
80008b0a:	e0 68 0a 38 	mov	r8,2616
80008b0e:	70 08       	ld.w	r8,r8[0x0]
80008b10:	70 07       	ld.w	r7,r8[0x0]
80008b12:	c1 28       	rjmp	80008b36 <__swsetup_r+0x4e>
80008b14:	fe c8 c1 18 	sub	r8,pc,-16104
80008b18:	10 37       	cp.w	r7,r8
80008b1a:	c0 61       	brne	80008b26 <__swsetup_r+0x3e>
80008b1c:	e0 68 0a 38 	mov	r8,2616
80008b20:	70 08       	ld.w	r8,r8[0x0]
80008b22:	70 17       	ld.w	r7,r8[0x4]
80008b24:	c0 98       	rjmp	80008b36 <__swsetup_r+0x4e>
80008b26:	fe c8 c1 0a 	sub	r8,pc,-16118
80008b2a:	10 37       	cp.w	r7,r8
80008b2c:	c0 51       	brne	80008b36 <__swsetup_r+0x4e>
80008b2e:	e0 68 0a 38 	mov	r8,2616
80008b32:	70 08       	ld.w	r8,r8[0x0]
80008b34:	70 27       	ld.w	r7,r8[0x8]
80008b36:	8e 68       	ld.sh	r8,r7[0xc]
80008b38:	ed b8 00 03 	bld	r8,0x3
80008b3c:	c1 e0       	breq	80008b78 <__swsetup_r+0x90>
80008b3e:	ed b8 00 04 	bld	r8,0x4
80008b42:	c3 e1       	brne	80008bbe <__swsetup_r+0xd6>
80008b44:	ed b8 00 02 	bld	r8,0x2
80008b48:	c1 51       	brne	80008b72 <__swsetup_r+0x8a>
80008b4a:	6e db       	ld.w	r11,r7[0x34]
80008b4c:	58 0b       	cp.w	r11,0
80008b4e:	c0 a0       	breq	80008b62 <__swsetup_r+0x7a>
80008b50:	ee c8 ff bc 	sub	r8,r7,-68
80008b54:	10 3b       	cp.w	r11,r8
80008b56:	c0 40       	breq	80008b5e <__swsetup_r+0x76>
80008b58:	0c 9c       	mov	r12,r6
80008b5a:	e0 a0 08 2b 	rcall	80009bb0 <_free_r>
80008b5e:	30 08       	mov	r8,0
80008b60:	8f d8       	st.w	r7[0x34],r8
80008b62:	8e 68       	ld.sh	r8,r7[0xc]
80008b64:	e0 18 ff db 	andl	r8,0xffdb
80008b68:	ae 68       	st.h	r7[0xc],r8
80008b6a:	30 08       	mov	r8,0
80008b6c:	8f 18       	st.w	r7[0x4],r8
80008b6e:	6e 48       	ld.w	r8,r7[0x10]
80008b70:	8f 08       	st.w	r7[0x0],r8
80008b72:	8e 68       	ld.sh	r8,r7[0xc]
80008b74:	a3 b8       	sbr	r8,0x3
80008b76:	ae 68       	st.h	r7[0xc],r8
80008b78:	6e 48       	ld.w	r8,r7[0x10]
80008b7a:	58 08       	cp.w	r8,0
80008b7c:	c0 b1       	brne	80008b92 <__swsetup_r+0xaa>
80008b7e:	8e 68       	ld.sh	r8,r7[0xc]
80008b80:	e2 18 02 80 	andl	r8,0x280,COH
80008b84:	e0 48 02 00 	cp.w	r8,512
80008b88:	c0 50       	breq	80008b92 <__swsetup_r+0xaa>
80008b8a:	0c 9c       	mov	r12,r6
80008b8c:	0e 9b       	mov	r11,r7
80008b8e:	e0 a0 0a 4b 	rcall	8000a024 <__smakebuf_r>
80008b92:	8e 69       	ld.sh	r9,r7[0xc]
80008b94:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80008b98:	c0 70       	breq	80008ba6 <__swsetup_r+0xbe>
80008b9a:	30 08       	mov	r8,0
80008b9c:	8f 28       	st.w	r7[0x8],r8
80008b9e:	6e 58       	ld.w	r8,r7[0x14]
80008ba0:	5c 38       	neg	r8
80008ba2:	8f 68       	st.w	r7[0x18],r8
80008ba4:	c0 68       	rjmp	80008bb0 <__swsetup_r+0xc8>
80008ba6:	ed b9 00 01 	bld	r9,0x1
80008baa:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80008bae:	8f 28       	st.w	r7[0x8],r8
80008bb0:	6e 48       	ld.w	r8,r7[0x10]
80008bb2:	58 08       	cp.w	r8,0
80008bb4:	c0 61       	brne	80008bc0 <__swsetup_r+0xd8>
80008bb6:	8e 68       	ld.sh	r8,r7[0xc]
80008bb8:	ed b8 00 07 	bld	r8,0x7
80008bbc:	c0 21       	brne	80008bc0 <__swsetup_r+0xd8>
80008bbe:	dc 2a       	popm	r4-r7,pc,r12=-1
80008bc0:	d8 2a       	popm	r4-r7,pc,r12=0
80008bc2:	d7 03       	nop

80008bc4 <quorem>:
80008bc4:	d4 31       	pushm	r0-r7,lr
80008bc6:	20 2d       	sub	sp,8
80008bc8:	18 97       	mov	r7,r12
80008bca:	78 48       	ld.w	r8,r12[0x10]
80008bcc:	76 46       	ld.w	r6,r11[0x10]
80008bce:	0c 38       	cp.w	r8,r6
80008bd0:	c0 34       	brge	80008bd6 <quorem+0x12>
80008bd2:	30 0c       	mov	r12,0
80008bd4:	c8 58       	rjmp	80008cde <quorem+0x11a>
80008bd6:	ec c2 ff fc 	sub	r2,r6,-4
80008bda:	f6 c3 ff ec 	sub	r3,r11,-20
80008bde:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80008be2:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80008be6:	2f f9       	sub	r9,-1
80008be8:	20 16       	sub	r6,1
80008bea:	f8 09 0d 08 	divu	r8,r12,r9
80008bee:	f6 02 00 22 	add	r2,r11,r2<<0x2
80008bf2:	ee c4 ff ec 	sub	r4,r7,-20
80008bf6:	10 95       	mov	r5,r8
80008bf8:	58 08       	cp.w	r8,0
80008bfa:	c4 10       	breq	80008c7c <quorem+0xb8>
80008bfc:	30 09       	mov	r9,0
80008bfe:	06 9a       	mov	r10,r3
80008c00:	08 98       	mov	r8,r4
80008c02:	12 91       	mov	r1,r9
80008c04:	50 0b       	stdsp	sp[0x0],r11
80008c06:	70 0e       	ld.w	lr,r8[0x0]
80008c08:	b1 8e       	lsr	lr,0x10
80008c0a:	50 1e       	stdsp	sp[0x4],lr
80008c0c:	15 0e       	ld.w	lr,r10++
80008c0e:	fc 00 16 10 	lsr	r0,lr,0x10
80008c12:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80008c16:	ea 0e 03 41 	mac	r1,r5,lr
80008c1a:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80008c1e:	b1 81       	lsr	r1,0x10
80008c20:	40 1b       	lddsp	r11,sp[0x4]
80008c22:	ea 00 02 40 	mul	r0,r5,r0
80008c26:	e2 00 00 00 	add	r0,r1,r0
80008c2a:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80008c2e:	02 1b       	sub	r11,r1
80008c30:	50 1b       	stdsp	sp[0x4],r11
80008c32:	70 0b       	ld.w	r11,r8[0x0]
80008c34:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80008c38:	02 09       	add	r9,r1
80008c3a:	f2 0e 01 0e 	sub	lr,r9,lr
80008c3e:	b0 1e       	st.h	r8[0x2],lr
80008c40:	fc 09 14 10 	asr	r9,lr,0x10
80008c44:	40 1e       	lddsp	lr,sp[0x4]
80008c46:	fc 09 00 09 	add	r9,lr,r9
80008c4a:	b0 09       	st.h	r8[0x0],r9
80008c4c:	e0 01 16 10 	lsr	r1,r0,0x10
80008c50:	2f c8       	sub	r8,-4
80008c52:	b1 49       	asr	r9,0x10
80008c54:	04 3a       	cp.w	r10,r2
80008c56:	fe 98 ff d8 	brls	80008c06 <quorem+0x42>
80008c5a:	40 0b       	lddsp	r11,sp[0x0]
80008c5c:	58 0c       	cp.w	r12,0
80008c5e:	c0 f1       	brne	80008c7c <quorem+0xb8>
80008c60:	ec c8 ff fb 	sub	r8,r6,-5
80008c64:	ee 08 00 28 	add	r8,r7,r8<<0x2
80008c68:	c0 28       	rjmp	80008c6c <quorem+0xa8>
80008c6a:	20 16       	sub	r6,1
80008c6c:	20 48       	sub	r8,4
80008c6e:	08 38       	cp.w	r8,r4
80008c70:	e0 88 00 05 	brls	80008c7a <quorem+0xb6>
80008c74:	70 09       	ld.w	r9,r8[0x0]
80008c76:	58 09       	cp.w	r9,0
80008c78:	cf 90       	breq	80008c6a <quorem+0xa6>
80008c7a:	8f 46       	st.w	r7[0x10],r6
80008c7c:	0e 9c       	mov	r12,r7
80008c7e:	e0 a0 0a d2 	rcall	8000a222 <__mcmp>
80008c82:	c2 d5       	brlt	80008cdc <quorem+0x118>
80008c84:	2f f5       	sub	r5,-1
80008c86:	08 98       	mov	r8,r4
80008c88:	30 09       	mov	r9,0
80008c8a:	07 0b       	ld.w	r11,r3++
80008c8c:	f6 0a 16 10 	lsr	r10,r11,0x10
80008c90:	70 0c       	ld.w	r12,r8[0x0]
80008c92:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80008c96:	f8 0e 16 10 	lsr	lr,r12,0x10
80008c9a:	14 1e       	sub	lr,r10
80008c9c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80008ca0:	16 1a       	sub	r10,r11
80008ca2:	12 0a       	add	r10,r9
80008ca4:	b0 1a       	st.h	r8[0x2],r10
80008ca6:	b1 4a       	asr	r10,0x10
80008ca8:	fc 0a 00 09 	add	r9,lr,r10
80008cac:	b0 09       	st.h	r8[0x0],r9
80008cae:	2f c8       	sub	r8,-4
80008cb0:	b1 49       	asr	r9,0x10
80008cb2:	04 33       	cp.w	r3,r2
80008cb4:	fe 98 ff eb 	brls	80008c8a <quorem+0xc6>
80008cb8:	ec c8 ff fb 	sub	r8,r6,-5
80008cbc:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80008cc0:	58 09       	cp.w	r9,0
80008cc2:	c0 d1       	brne	80008cdc <quorem+0x118>
80008cc4:	ee 08 00 28 	add	r8,r7,r8<<0x2
80008cc8:	c0 28       	rjmp	80008ccc <quorem+0x108>
80008cca:	20 16       	sub	r6,1
80008ccc:	20 48       	sub	r8,4
80008cce:	08 38       	cp.w	r8,r4
80008cd0:	e0 88 00 05 	brls	80008cda <quorem+0x116>
80008cd4:	70 09       	ld.w	r9,r8[0x0]
80008cd6:	58 09       	cp.w	r9,0
80008cd8:	cf 90       	breq	80008cca <quorem+0x106>
80008cda:	8f 46       	st.w	r7[0x10],r6
80008cdc:	0a 9c       	mov	r12,r5
80008cde:	2f ed       	sub	sp,-8
80008ce0:	d8 32       	popm	r0-r7,pc
80008ce2:	d7 03       	nop

80008ce4 <_dtoa_r>:
80008ce4:	d4 31       	pushm	r0-r7,lr
80008ce6:	21 ad       	sub	sp,104
80008ce8:	fa c4 ff 74 	sub	r4,sp,-140
80008cec:	18 97       	mov	r7,r12
80008cee:	16 95       	mov	r5,r11
80008cf0:	68 2c       	ld.w	r12,r4[0x8]
80008cf2:	50 c9       	stdsp	sp[0x30],r9
80008cf4:	68 16       	ld.w	r6,r4[0x4]
80008cf6:	68 09       	ld.w	r9,r4[0x0]
80008cf8:	50 e8       	stdsp	sp[0x38],r8
80008cfa:	14 94       	mov	r4,r10
80008cfc:	51 2c       	stdsp	sp[0x48],r12
80008cfe:	fa e5 00 08 	st.d	sp[8],r4
80008d02:	51 59       	stdsp	sp[0x54],r9
80008d04:	6e 95       	ld.w	r5,r7[0x24]
80008d06:	58 05       	cp.w	r5,0
80008d08:	c0 91       	brne	80008d1a <_dtoa_r+0x36>
80008d0a:	31 0c       	mov	r12,16
80008d0c:	fe b0 e8 e8 	rcall	80005edc <malloc>
80008d10:	99 35       	st.w	r12[0xc],r5
80008d12:	8f 9c       	st.w	r7[0x24],r12
80008d14:	99 15       	st.w	r12[0x4],r5
80008d16:	99 25       	st.w	r12[0x8],r5
80008d18:	99 05       	st.w	r12[0x0],r5
80008d1a:	6e 99       	ld.w	r9,r7[0x24]
80008d1c:	72 08       	ld.w	r8,r9[0x0]
80008d1e:	58 08       	cp.w	r8,0
80008d20:	c0 f0       	breq	80008d3e <_dtoa_r+0x5a>
80008d22:	72 1a       	ld.w	r10,r9[0x4]
80008d24:	91 1a       	st.w	r8[0x4],r10
80008d26:	30 1a       	mov	r10,1
80008d28:	72 19       	ld.w	r9,r9[0x4]
80008d2a:	f4 09 09 49 	lsl	r9,r10,r9
80008d2e:	10 9b       	mov	r11,r8
80008d30:	91 29       	st.w	r8[0x8],r9
80008d32:	0e 9c       	mov	r12,r7
80008d34:	e0 a0 0a 90 	rcall	8000a254 <_Bfree>
80008d38:	6e 98       	ld.w	r8,r7[0x24]
80008d3a:	30 09       	mov	r9,0
80008d3c:	91 09       	st.w	r8[0x0],r9
80008d3e:	40 28       	lddsp	r8,sp[0x8]
80008d40:	10 94       	mov	r4,r8
80008d42:	58 08       	cp.w	r8,0
80008d44:	c0 64       	brge	80008d50 <_dtoa_r+0x6c>
80008d46:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80008d4a:	50 28       	stdsp	sp[0x8],r8
80008d4c:	30 18       	mov	r8,1
80008d4e:	c0 28       	rjmp	80008d52 <_dtoa_r+0x6e>
80008d50:	30 08       	mov	r8,0
80008d52:	8d 08       	st.w	r6[0x0],r8
80008d54:	fc 1c 7f f0 	movh	r12,0x7ff0
80008d58:	40 26       	lddsp	r6,sp[0x8]
80008d5a:	0c 98       	mov	r8,r6
80008d5c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80008d60:	18 38       	cp.w	r8,r12
80008d62:	c2 01       	brne	80008da2 <_dtoa_r+0xbe>
80008d64:	e0 68 27 0f 	mov	r8,9999
80008d68:	41 5b       	lddsp	r11,sp[0x54]
80008d6a:	97 08       	st.w	r11[0x0],r8
80008d6c:	40 3a       	lddsp	r10,sp[0xc]
80008d6e:	58 0a       	cp.w	r10,0
80008d70:	c0 71       	brne	80008d7e <_dtoa_r+0x9a>
80008d72:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80008d76:	c0 41       	brne	80008d7e <_dtoa_r+0x9a>
80008d78:	fe cc c3 ac 	sub	r12,pc,-15444
80008d7c:	c0 38       	rjmp	80008d82 <_dtoa_r+0x9e>
80008d7e:	fe cc c3 a6 	sub	r12,pc,-15450
80008d82:	41 29       	lddsp	r9,sp[0x48]
80008d84:	58 09       	cp.w	r9,0
80008d86:	e0 80 05 9a 	breq	800098ba <_dtoa_r+0xbd6>
80008d8a:	f8 c8 ff fd 	sub	r8,r12,-3
80008d8e:	f8 c9 ff f8 	sub	r9,r12,-8
80008d92:	11 8b       	ld.ub	r11,r8[0x0]
80008d94:	30 0a       	mov	r10,0
80008d96:	41 25       	lddsp	r5,sp[0x48]
80008d98:	f4 0b 18 00 	cp.b	r11,r10
80008d9c:	f2 08 17 10 	movne	r8,r9
80008da0:	c1 68       	rjmp	80008dcc <_dtoa_r+0xe8>
80008da2:	fa ea 00 08 	ld.d	r10,sp[8]
80008da6:	30 08       	mov	r8,0
80008da8:	fa eb 00 3c 	st.d	sp[60],r10
80008dac:	30 09       	mov	r9,0
80008dae:	e0 a0 10 c2 	rcall	8000af32 <__avr32_f64_cmp_eq>
80008db2:	c1 00       	breq	80008dd2 <_dtoa_r+0xee>
80008db4:	30 18       	mov	r8,1
80008db6:	41 5a       	lddsp	r10,sp[0x54]
80008db8:	95 08       	st.w	r10[0x0],r8
80008dba:	fe cc c5 12 	sub	r12,pc,-15086
80008dbe:	41 29       	lddsp	r9,sp[0x48]
80008dc0:	f8 08 00 08 	add	r8,r12,r8
80008dc4:	58 09       	cp.w	r9,0
80008dc6:	e0 80 05 7a 	breq	800098ba <_dtoa_r+0xbd6>
80008dca:	12 95       	mov	r5,r9
80008dcc:	8b 08       	st.w	r5[0x0],r8
80008dce:	e0 8f 05 76 	bral	800098ba <_dtoa_r+0xbd6>
80008dd2:	fa c8 ff 9c 	sub	r8,sp,-100
80008dd6:	fa c9 ff a0 	sub	r9,sp,-96
80008dda:	fa ea 00 3c 	ld.d	r10,sp[60]
80008dde:	0e 9c       	mov	r12,r7
80008de0:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80008de4:	e0 a0 0a 8a 	rcall	8000a2f8 <__d2b>
80008de8:	18 93       	mov	r3,r12
80008dea:	58 05       	cp.w	r5,0
80008dec:	c0 d0       	breq	80008e06 <_dtoa_r+0x122>
80008dee:	fa ea 00 3c 	ld.d	r10,sp[60]
80008df2:	30 04       	mov	r4,0
80008df4:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80008df8:	ea c5 03 ff 	sub	r5,r5,1023
80008dfc:	10 9b       	mov	r11,r8
80008dfe:	51 74       	stdsp	sp[0x5c],r4
80008e00:	ea 1b 3f f0 	orh	r11,0x3ff0
80008e04:	c2 58       	rjmp	80008e4e <_dtoa_r+0x16a>
80008e06:	41 88       	lddsp	r8,sp[0x60]
80008e08:	41 9c       	lddsp	r12,sp[0x64]
80008e0a:	10 0c       	add	r12,r8
80008e0c:	f8 c5 fb ce 	sub	r5,r12,-1074
80008e10:	e0 45 00 20 	cp.w	r5,32
80008e14:	e0 8a 00 0e 	brle	80008e30 <_dtoa_r+0x14c>
80008e18:	f8 cc fb ee 	sub	r12,r12,-1042
80008e1c:	40 3b       	lddsp	r11,sp[0xc]
80008e1e:	ea 08 11 40 	rsub	r8,r5,64
80008e22:	f6 0c 0a 4c 	lsr	r12,r11,r12
80008e26:	ec 08 09 46 	lsl	r6,r6,r8
80008e2a:	0c 4c       	or	r12,r6
80008e2c:	c0 78       	rjmp	80008e3a <_dtoa_r+0x156>
80008e2e:	d7 03       	nop
80008e30:	ea 0c 11 20 	rsub	r12,r5,32
80008e34:	40 3a       	lddsp	r10,sp[0xc]
80008e36:	f4 0c 09 4c 	lsl	r12,r10,r12
80008e3a:	e0 a0 10 08 	rcall	8000ae4a <__avr32_u32_to_f64>
80008e3e:	fc 18 fe 10 	movh	r8,0xfe10
80008e42:	30 19       	mov	r9,1
80008e44:	ea c5 04 33 	sub	r5,r5,1075
80008e48:	f0 0b 00 0b 	add	r11,r8,r11
80008e4c:	51 79       	stdsp	sp[0x5c],r9
80008e4e:	30 08       	mov	r8,0
80008e50:	fc 19 3f f8 	movh	r9,0x3ff8
80008e54:	e0 a0 0e 90 	rcall	8000ab74 <__avr32_f64_sub>
80008e58:	e0 68 43 61 	mov	r8,17249
80008e5c:	ea 18 63 6f 	orh	r8,0x636f
80008e60:	e0 69 87 a7 	mov	r9,34727
80008e64:	ea 19 3f d2 	orh	r9,0x3fd2
80008e68:	e0 a0 0d 9a 	rcall	8000a99c <__avr32_f64_mul>
80008e6c:	e0 68 c8 b3 	mov	r8,51379
80008e70:	ea 18 8b 60 	orh	r8,0x8b60
80008e74:	e0 69 8a 28 	mov	r9,35368
80008e78:	ea 19 3f c6 	orh	r9,0x3fc6
80008e7c:	e0 a0 0f 4a 	rcall	8000ad10 <__avr32_f64_add>
80008e80:	0a 9c       	mov	r12,r5
80008e82:	14 90       	mov	r0,r10
80008e84:	16 91       	mov	r1,r11
80008e86:	e0 a0 0f e6 	rcall	8000ae52 <__avr32_s32_to_f64>
80008e8a:	e0 68 79 fb 	mov	r8,31227
80008e8e:	ea 18 50 9f 	orh	r8,0x509f
80008e92:	e0 69 44 13 	mov	r9,17427
80008e96:	ea 19 3f d3 	orh	r9,0x3fd3
80008e9a:	e0 a0 0d 81 	rcall	8000a99c <__avr32_f64_mul>
80008e9e:	14 98       	mov	r8,r10
80008ea0:	16 99       	mov	r9,r11
80008ea2:	00 9a       	mov	r10,r0
80008ea4:	02 9b       	mov	r11,r1
80008ea6:	e0 a0 0f 35 	rcall	8000ad10 <__avr32_f64_add>
80008eaa:	14 90       	mov	r0,r10
80008eac:	16 91       	mov	r1,r11
80008eae:	e0 a0 0f bb 	rcall	8000ae24 <__avr32_f64_to_s32>
80008eb2:	30 08       	mov	r8,0
80008eb4:	18 96       	mov	r6,r12
80008eb6:	30 09       	mov	r9,0
80008eb8:	00 9a       	mov	r10,r0
80008eba:	02 9b       	mov	r11,r1
80008ebc:	e0 a0 10 82 	rcall	8000afc0 <__avr32_f64_cmp_lt>
80008ec0:	c0 c0       	breq	80008ed8 <_dtoa_r+0x1f4>
80008ec2:	0c 9c       	mov	r12,r6
80008ec4:	e0 a0 0f c7 	rcall	8000ae52 <__avr32_s32_to_f64>
80008ec8:	14 98       	mov	r8,r10
80008eca:	16 99       	mov	r9,r11
80008ecc:	00 9a       	mov	r10,r0
80008ece:	02 9b       	mov	r11,r1
80008ed0:	e0 a0 10 31 	rcall	8000af32 <__avr32_f64_cmp_eq>
80008ed4:	f7 b6 00 01 	subeq	r6,1
80008ed8:	59 66       	cp.w	r6,22
80008eda:	e0 88 00 05 	brls	80008ee4 <_dtoa_r+0x200>
80008ede:	30 18       	mov	r8,1
80008ee0:	51 48       	stdsp	sp[0x50],r8
80008ee2:	c1 38       	rjmp	80008f08 <_dtoa_r+0x224>
80008ee4:	fe c8 c4 58 	sub	r8,pc,-15272
80008ee8:	fa ea 00 3c 	ld.d	r10,sp[60]
80008eec:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80008ef0:	e0 a0 10 68 	rcall	8000afc0 <__avr32_f64_cmp_lt>
80008ef4:	f9 b4 00 00 	moveq	r4,0
80008ef8:	fb f4 0a 14 	st.weq	sp[0x50],r4
80008efc:	f7 b6 01 01 	subne	r6,1
80008f00:	f9 bc 01 00 	movne	r12,0
80008f04:	fb fc 1a 14 	st.wne	sp[0x50],r12
80008f08:	41 90       	lddsp	r0,sp[0x64]
80008f0a:	20 10       	sub	r0,1
80008f0c:	0a 10       	sub	r0,r5
80008f0e:	c0 46       	brmi	80008f16 <_dtoa_r+0x232>
80008f10:	50 40       	stdsp	sp[0x10],r0
80008f12:	30 00       	mov	r0,0
80008f14:	c0 48       	rjmp	80008f1c <_dtoa_r+0x238>
80008f16:	30 0b       	mov	r11,0
80008f18:	5c 30       	neg	r0
80008f1a:	50 4b       	stdsp	sp[0x10],r11
80008f1c:	ec 02 11 00 	rsub	r2,r6,0
80008f20:	58 06       	cp.w	r6,0
80008f22:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80008f26:	f5 d6 e4 0a 	addge	r10,r10,r6
80008f2a:	fb fa 4a 04 	st.wge	sp[0x10],r10
80008f2e:	fb f6 4a 11 	st.wge	sp[0x44],r6
80008f32:	f9 b2 04 00 	movge	r2,0
80008f36:	e1 d6 e5 10 	sublt	r0,r0,r6
80008f3a:	f9 b9 05 00 	movlt	r9,0
80008f3e:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80008f42:	40 c8       	lddsp	r8,sp[0x30]
80008f44:	58 98       	cp.w	r8,9
80008f46:	e0 8b 00 20 	brhi	80008f86 <_dtoa_r+0x2a2>
80008f4a:	58 58       	cp.w	r8,5
80008f4c:	f9 b4 0a 01 	movle	r4,1
80008f50:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80008f54:	f7 b5 09 04 	subgt	r5,4
80008f58:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80008f5c:	f9 b4 09 00 	movgt	r4,0
80008f60:	40 cc       	lddsp	r12,sp[0x30]
80008f62:	58 3c       	cp.w	r12,3
80008f64:	c2 d0       	breq	80008fbe <_dtoa_r+0x2da>
80008f66:	e0 89 00 05 	brgt	80008f70 <_dtoa_r+0x28c>
80008f6a:	58 2c       	cp.w	r12,2
80008f6c:	c1 01       	brne	80008f8c <_dtoa_r+0x2a8>
80008f6e:	c1 88       	rjmp	80008f9e <_dtoa_r+0x2ba>
80008f70:	40 cb       	lddsp	r11,sp[0x30]
80008f72:	58 4b       	cp.w	r11,4
80008f74:	c0 60       	breq	80008f80 <_dtoa_r+0x29c>
80008f76:	58 5b       	cp.w	r11,5
80008f78:	c0 a1       	brne	80008f8c <_dtoa_r+0x2a8>
80008f7a:	30 1a       	mov	r10,1
80008f7c:	50 da       	stdsp	sp[0x34],r10
80008f7e:	c2 28       	rjmp	80008fc2 <_dtoa_r+0x2de>
80008f80:	30 19       	mov	r9,1
80008f82:	50 d9       	stdsp	sp[0x34],r9
80008f84:	c0 f8       	rjmp	80008fa2 <_dtoa_r+0x2be>
80008f86:	30 08       	mov	r8,0
80008f88:	30 14       	mov	r4,1
80008f8a:	50 c8       	stdsp	sp[0x30],r8
80008f8c:	3f f5       	mov	r5,-1
80008f8e:	30 1c       	mov	r12,1
80008f90:	30 0b       	mov	r11,0
80008f92:	50 95       	stdsp	sp[0x24],r5
80008f94:	50 dc       	stdsp	sp[0x34],r12
80008f96:	0a 91       	mov	r1,r5
80008f98:	31 28       	mov	r8,18
80008f9a:	50 eb       	stdsp	sp[0x38],r11
80008f9c:	c2 08       	rjmp	80008fdc <_dtoa_r+0x2f8>
80008f9e:	30 0a       	mov	r10,0
80008fa0:	50 da       	stdsp	sp[0x34],r10
80008fa2:	40 e9       	lddsp	r9,sp[0x38]
80008fa4:	58 09       	cp.w	r9,0
80008fa6:	e0 89 00 07 	brgt	80008fb4 <_dtoa_r+0x2d0>
80008faa:	30 18       	mov	r8,1
80008fac:	50 98       	stdsp	sp[0x24],r8
80008fae:	10 91       	mov	r1,r8
80008fb0:	50 e8       	stdsp	sp[0x38],r8
80008fb2:	c1 58       	rjmp	80008fdc <_dtoa_r+0x2f8>
80008fb4:	40 e5       	lddsp	r5,sp[0x38]
80008fb6:	50 95       	stdsp	sp[0x24],r5
80008fb8:	0a 91       	mov	r1,r5
80008fba:	0a 98       	mov	r8,r5
80008fbc:	c1 08       	rjmp	80008fdc <_dtoa_r+0x2f8>
80008fbe:	30 0c       	mov	r12,0
80008fc0:	50 dc       	stdsp	sp[0x34],r12
80008fc2:	40 eb       	lddsp	r11,sp[0x38]
80008fc4:	ec 0b 00 0b 	add	r11,r6,r11
80008fc8:	50 9b       	stdsp	sp[0x24],r11
80008fca:	16 98       	mov	r8,r11
80008fcc:	2f f8       	sub	r8,-1
80008fce:	58 08       	cp.w	r8,0
80008fd0:	e0 89 00 05 	brgt	80008fda <_dtoa_r+0x2f6>
80008fd4:	10 91       	mov	r1,r8
80008fd6:	30 18       	mov	r8,1
80008fd8:	c0 28       	rjmp	80008fdc <_dtoa_r+0x2f8>
80008fda:	10 91       	mov	r1,r8
80008fdc:	30 09       	mov	r9,0
80008fde:	6e 9a       	ld.w	r10,r7[0x24]
80008fe0:	95 19       	st.w	r10[0x4],r9
80008fe2:	30 49       	mov	r9,4
80008fe4:	c0 68       	rjmp	80008ff0 <_dtoa_r+0x30c>
80008fe6:	d7 03       	nop
80008fe8:	6a 1a       	ld.w	r10,r5[0x4]
80008fea:	a1 79       	lsl	r9,0x1
80008fec:	2f fa       	sub	r10,-1
80008fee:	8b 1a       	st.w	r5[0x4],r10
80008ff0:	6e 95       	ld.w	r5,r7[0x24]
80008ff2:	f2 ca ff ec 	sub	r10,r9,-20
80008ff6:	10 3a       	cp.w	r10,r8
80008ff8:	fe 98 ff f8 	brls	80008fe8 <_dtoa_r+0x304>
80008ffc:	6a 1b       	ld.w	r11,r5[0x4]
80008ffe:	0e 9c       	mov	r12,r7
80009000:	e0 a0 09 44 	rcall	8000a288 <_Balloc>
80009004:	58 e1       	cp.w	r1,14
80009006:	5f 88       	srls	r8
80009008:	8b 0c       	st.w	r5[0x0],r12
8000900a:	f1 e4 00 04 	and	r4,r8,r4
8000900e:	6e 98       	ld.w	r8,r7[0x24]
80009010:	70 08       	ld.w	r8,r8[0x0]
80009012:	50 88       	stdsp	sp[0x20],r8
80009014:	e0 80 01 82 	breq	80009318 <_dtoa_r+0x634>
80009018:	58 06       	cp.w	r6,0
8000901a:	e0 8a 00 43 	brle	800090a0 <_dtoa_r+0x3bc>
8000901e:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009022:	fe c8 c5 96 	sub	r8,pc,-14954
80009026:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000902a:	fa e5 00 18 	st.d	sp[24],r4
8000902e:	ec 04 14 04 	asr	r4,r6,0x4
80009032:	ed b4 00 04 	bld	r4,0x4
80009036:	c0 30       	breq	8000903c <_dtoa_r+0x358>
80009038:	30 25       	mov	r5,2
8000903a:	c1 08       	rjmp	8000905a <_dtoa_r+0x376>
8000903c:	fe c8 c4 e8 	sub	r8,pc,-15128
80009040:	f0 e8 00 20 	ld.d	r8,r8[32]
80009044:	fa ea 00 3c 	ld.d	r10,sp[60]
80009048:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000904c:	e0 a0 0f ee 	rcall	8000b028 <__avr32_f64_div>
80009050:	30 35       	mov	r5,3
80009052:	14 98       	mov	r8,r10
80009054:	16 99       	mov	r9,r11
80009056:	fa e9 00 08 	st.d	sp[8],r8
8000905a:	fe cc c5 06 	sub	r12,pc,-15098
8000905e:	50 a3       	stdsp	sp[0x28],r3
80009060:	0c 93       	mov	r3,r6
80009062:	18 96       	mov	r6,r12
80009064:	c0 f8       	rjmp	80009082 <_dtoa_r+0x39e>
80009066:	fa ea 00 18 	ld.d	r10,sp[24]
8000906a:	ed b4 00 00 	bld	r4,0x0
8000906e:	c0 81       	brne	8000907e <_dtoa_r+0x39a>
80009070:	ec e8 00 00 	ld.d	r8,r6[0]
80009074:	2f f5       	sub	r5,-1
80009076:	e0 a0 0c 93 	rcall	8000a99c <__avr32_f64_mul>
8000907a:	fa eb 00 18 	st.d	sp[24],r10
8000907e:	a1 54       	asr	r4,0x1
80009080:	2f 86       	sub	r6,-8
80009082:	58 04       	cp.w	r4,0
80009084:	cf 11       	brne	80009066 <_dtoa_r+0x382>
80009086:	fa e8 00 18 	ld.d	r8,sp[24]
8000908a:	fa ea 00 08 	ld.d	r10,sp[8]
8000908e:	06 96       	mov	r6,r3
80009090:	e0 a0 0f cc 	rcall	8000b028 <__avr32_f64_div>
80009094:	40 a3       	lddsp	r3,sp[0x28]
80009096:	14 98       	mov	r8,r10
80009098:	16 99       	mov	r9,r11
8000909a:	fa e9 00 08 	st.d	sp[8],r8
8000909e:	c2 f8       	rjmp	800090fc <_dtoa_r+0x418>
800090a0:	ec 08 11 00 	rsub	r8,r6,0
800090a4:	c0 31       	brne	800090aa <_dtoa_r+0x3c6>
800090a6:	30 25       	mov	r5,2
800090a8:	c2 a8       	rjmp	800090fc <_dtoa_r+0x418>
800090aa:	fe cc c5 56 	sub	r12,pc,-15018
800090ae:	f0 04 14 04 	asr	r4,r8,0x4
800090b2:	50 1c       	stdsp	sp[0x4],r12
800090b4:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800090b8:	fe c9 c6 2c 	sub	r9,pc,-14804
800090bc:	fa ea 00 3c 	ld.d	r10,sp[60]
800090c0:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
800090c4:	e0 a0 0c 6c 	rcall	8000a99c <__avr32_f64_mul>
800090c8:	40 1c       	lddsp	r12,sp[0x4]
800090ca:	50 63       	stdsp	sp[0x18],r3
800090cc:	30 25       	mov	r5,2
800090ce:	0c 93       	mov	r3,r6
800090d0:	fa eb 00 08 	st.d	sp[8],r10
800090d4:	18 96       	mov	r6,r12
800090d6:	c0 f8       	rjmp	800090f4 <_dtoa_r+0x410>
800090d8:	fa ea 00 08 	ld.d	r10,sp[8]
800090dc:	ed b4 00 00 	bld	r4,0x0
800090e0:	c0 81       	brne	800090f0 <_dtoa_r+0x40c>
800090e2:	ec e8 00 00 	ld.d	r8,r6[0]
800090e6:	2f f5       	sub	r5,-1
800090e8:	e0 a0 0c 5a 	rcall	8000a99c <__avr32_f64_mul>
800090ec:	fa eb 00 08 	st.d	sp[8],r10
800090f0:	a1 54       	asr	r4,0x1
800090f2:	2f 86       	sub	r6,-8
800090f4:	58 04       	cp.w	r4,0
800090f6:	cf 11       	brne	800090d8 <_dtoa_r+0x3f4>
800090f8:	06 96       	mov	r6,r3
800090fa:	40 63       	lddsp	r3,sp[0x18]
800090fc:	41 4a       	lddsp	r10,sp[0x50]
800090fe:	58 0a       	cp.w	r10,0
80009100:	c2 a0       	breq	80009154 <_dtoa_r+0x470>
80009102:	fa e8 00 08 	ld.d	r8,sp[8]
80009106:	58 01       	cp.w	r1,0
80009108:	5f 94       	srgt	r4
8000910a:	fa e9 00 18 	st.d	sp[24],r8
8000910e:	30 08       	mov	r8,0
80009110:	fc 19 3f f0 	movh	r9,0x3ff0
80009114:	fa ea 00 18 	ld.d	r10,sp[24]
80009118:	e0 a0 0f 54 	rcall	8000afc0 <__avr32_f64_cmp_lt>
8000911c:	f9 bc 00 00 	moveq	r12,0
80009120:	f9 bc 01 01 	movne	r12,1
80009124:	e9 ec 00 0c 	and	r12,r4,r12
80009128:	c1 60       	breq	80009154 <_dtoa_r+0x470>
8000912a:	40 98       	lddsp	r8,sp[0x24]
8000912c:	58 08       	cp.w	r8,0
8000912e:	e0 8a 00 f1 	brle	80009310 <_dtoa_r+0x62c>
80009132:	30 08       	mov	r8,0
80009134:	fc 19 40 24 	movh	r9,0x4024
80009138:	ec c4 00 01 	sub	r4,r6,1
8000913c:	fa ea 00 18 	ld.d	r10,sp[24]
80009140:	2f f5       	sub	r5,-1
80009142:	50 64       	stdsp	sp[0x18],r4
80009144:	e0 a0 0c 2c 	rcall	8000a99c <__avr32_f64_mul>
80009148:	40 94       	lddsp	r4,sp[0x24]
8000914a:	14 98       	mov	r8,r10
8000914c:	16 99       	mov	r9,r11
8000914e:	fa e9 00 08 	st.d	sp[8],r8
80009152:	c0 38       	rjmp	80009158 <_dtoa_r+0x474>
80009154:	50 66       	stdsp	sp[0x18],r6
80009156:	02 94       	mov	r4,r1
80009158:	0a 9c       	mov	r12,r5
8000915a:	e0 a0 0e 7c 	rcall	8000ae52 <__avr32_s32_to_f64>
8000915e:	fa e8 00 08 	ld.d	r8,sp[8]
80009162:	e0 a0 0c 1d 	rcall	8000a99c <__avr32_f64_mul>
80009166:	30 08       	mov	r8,0
80009168:	fc 19 40 1c 	movh	r9,0x401c
8000916c:	e0 a0 0d d2 	rcall	8000ad10 <__avr32_f64_add>
80009170:	14 98       	mov	r8,r10
80009172:	16 99       	mov	r9,r11
80009174:	fa e9 00 28 	st.d	sp[40],r8
80009178:	fc 18 fc c0 	movh	r8,0xfcc0
8000917c:	40 a5       	lddsp	r5,sp[0x28]
8000917e:	10 05       	add	r5,r8
80009180:	50 a5       	stdsp	sp[0x28],r5
80009182:	58 04       	cp.w	r4,0
80009184:	c2 11       	brne	800091c6 <_dtoa_r+0x4e2>
80009186:	fa ea 00 08 	ld.d	r10,sp[8]
8000918a:	30 08       	mov	r8,0
8000918c:	fc 19 40 14 	movh	r9,0x4014
80009190:	e0 a0 0c f2 	rcall	8000ab74 <__avr32_f64_sub>
80009194:	40 bc       	lddsp	r12,sp[0x2c]
80009196:	fa eb 00 08 	st.d	sp[8],r10
8000919a:	14 98       	mov	r8,r10
8000919c:	16 99       	mov	r9,r11
8000919e:	18 9a       	mov	r10,r12
800091a0:	0a 9b       	mov	r11,r5
800091a2:	e0 a0 0f 0f 	rcall	8000afc0 <__avr32_f64_cmp_lt>
800091a6:	e0 81 02 54 	brne	8000964e <_dtoa_r+0x96a>
800091aa:	0a 98       	mov	r8,r5
800091ac:	40 b9       	lddsp	r9,sp[0x2c]
800091ae:	ee 18 80 00 	eorh	r8,0x8000
800091b2:	fa ea 00 08 	ld.d	r10,sp[8]
800091b6:	10 95       	mov	r5,r8
800091b8:	12 98       	mov	r8,r9
800091ba:	0a 99       	mov	r9,r5
800091bc:	e0 a0 0f 02 	rcall	8000afc0 <__avr32_f64_cmp_lt>
800091c0:	e0 81 02 3e 	brne	8000963c <_dtoa_r+0x958>
800091c4:	ca 68       	rjmp	80009310 <_dtoa_r+0x62c>
800091c6:	fe c9 c7 3a 	sub	r9,pc,-14534
800091ca:	e8 c8 00 01 	sub	r8,r4,1
800091ce:	40 d5       	lddsp	r5,sp[0x34]
800091d0:	58 05       	cp.w	r5,0
800091d2:	c4 f0       	breq	80009270 <_dtoa_r+0x58c>
800091d4:	30 0c       	mov	r12,0
800091d6:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
800091da:	51 3c       	stdsp	sp[0x4c],r12
800091dc:	30 0a       	mov	r10,0
800091de:	fc 1b 3f e0 	movh	r11,0x3fe0
800091e2:	e0 a0 0f 23 	rcall	8000b028 <__avr32_f64_div>
800091e6:	fa e8 00 28 	ld.d	r8,sp[40]
800091ea:	40 85       	lddsp	r5,sp[0x20]
800091ec:	e0 a0 0c c4 	rcall	8000ab74 <__avr32_f64_sub>
800091f0:	fa eb 00 28 	st.d	sp[40],r10
800091f4:	fa ea 00 08 	ld.d	r10,sp[8]
800091f8:	e0 a0 0e 16 	rcall	8000ae24 <__avr32_f64_to_s32>
800091fc:	51 6c       	stdsp	sp[0x58],r12
800091fe:	e0 a0 0e 2a 	rcall	8000ae52 <__avr32_s32_to_f64>
80009202:	14 98       	mov	r8,r10
80009204:	16 99       	mov	r9,r11
80009206:	fa ea 00 08 	ld.d	r10,sp[8]
8000920a:	e0 a0 0c b5 	rcall	8000ab74 <__avr32_f64_sub>
8000920e:	fa eb 00 08 	st.d	sp[8],r10
80009212:	41 68       	lddsp	r8,sp[0x58]
80009214:	2d 08       	sub	r8,-48
80009216:	0a c8       	st.b	r5++,r8
80009218:	41 39       	lddsp	r9,sp[0x4c]
8000921a:	2f f9       	sub	r9,-1
8000921c:	51 39       	stdsp	sp[0x4c],r9
8000921e:	fa e8 00 28 	ld.d	r8,sp[40]
80009222:	e0 a0 0e cf 	rcall	8000afc0 <__avr32_f64_cmp_lt>
80009226:	e0 81 03 39 	brne	80009898 <_dtoa_r+0xbb4>
8000922a:	fa e8 00 08 	ld.d	r8,sp[8]
8000922e:	30 0a       	mov	r10,0
80009230:	fc 1b 3f f0 	movh	r11,0x3ff0
80009234:	e0 a0 0c a0 	rcall	8000ab74 <__avr32_f64_sub>
80009238:	fa e8 00 28 	ld.d	r8,sp[40]
8000923c:	e0 a0 0e c2 	rcall	8000afc0 <__avr32_f64_cmp_lt>
80009240:	fa ea 00 28 	ld.d	r10,sp[40]
80009244:	30 08       	mov	r8,0
80009246:	fc 19 40 24 	movh	r9,0x4024
8000924a:	e0 81 00 da 	brne	800093fe <_dtoa_r+0x71a>
8000924e:	41 3c       	lddsp	r12,sp[0x4c]
80009250:	08 3c       	cp.w	r12,r4
80009252:	c5 f4       	brge	80009310 <_dtoa_r+0x62c>
80009254:	e0 a0 0b a4 	rcall	8000a99c <__avr32_f64_mul>
80009258:	30 08       	mov	r8,0
8000925a:	fa eb 00 28 	st.d	sp[40],r10
8000925e:	fc 19 40 24 	movh	r9,0x4024
80009262:	fa ea 00 08 	ld.d	r10,sp[8]
80009266:	e0 a0 0b 9b 	rcall	8000a99c <__avr32_f64_mul>
8000926a:	fa eb 00 08 	st.d	sp[8],r10
8000926e:	cc 3b       	rjmp	800091f4 <_dtoa_r+0x510>
80009270:	40 85       	lddsp	r5,sp[0x20]
80009272:	08 05       	add	r5,r4
80009274:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009278:	51 35       	stdsp	sp[0x4c],r5
8000927a:	fa e8 00 28 	ld.d	r8,sp[40]
8000927e:	40 85       	lddsp	r5,sp[0x20]
80009280:	e0 a0 0b 8e 	rcall	8000a99c <__avr32_f64_mul>
80009284:	fa eb 00 28 	st.d	sp[40],r10
80009288:	fa ea 00 08 	ld.d	r10,sp[8]
8000928c:	e0 a0 0d cc 	rcall	8000ae24 <__avr32_f64_to_s32>
80009290:	51 6c       	stdsp	sp[0x58],r12
80009292:	e0 a0 0d e0 	rcall	8000ae52 <__avr32_s32_to_f64>
80009296:	14 98       	mov	r8,r10
80009298:	16 99       	mov	r9,r11
8000929a:	fa ea 00 08 	ld.d	r10,sp[8]
8000929e:	e0 a0 0c 6b 	rcall	8000ab74 <__avr32_f64_sub>
800092a2:	fa eb 00 08 	st.d	sp[8],r10
800092a6:	41 68       	lddsp	r8,sp[0x58]
800092a8:	2d 08       	sub	r8,-48
800092aa:	0a c8       	st.b	r5++,r8
800092ac:	41 3c       	lddsp	r12,sp[0x4c]
800092ae:	18 35       	cp.w	r5,r12
800092b0:	c2 81       	brne	80009300 <_dtoa_r+0x61c>
800092b2:	30 08       	mov	r8,0
800092b4:	fc 19 3f e0 	movh	r9,0x3fe0
800092b8:	fa ea 00 28 	ld.d	r10,sp[40]
800092bc:	e0 a0 0d 2a 	rcall	8000ad10 <__avr32_f64_add>
800092c0:	40 85       	lddsp	r5,sp[0x20]
800092c2:	fa e8 00 08 	ld.d	r8,sp[8]
800092c6:	08 05       	add	r5,r4
800092c8:	e0 a0 0e 7c 	rcall	8000afc0 <__avr32_f64_cmp_lt>
800092cc:	e0 81 00 99 	brne	800093fe <_dtoa_r+0x71a>
800092d0:	fa e8 00 28 	ld.d	r8,sp[40]
800092d4:	30 0a       	mov	r10,0
800092d6:	fc 1b 3f e0 	movh	r11,0x3fe0
800092da:	e0 a0 0c 4d 	rcall	8000ab74 <__avr32_f64_sub>
800092de:	14 98       	mov	r8,r10
800092e0:	16 99       	mov	r9,r11
800092e2:	fa ea 00 08 	ld.d	r10,sp[8]
800092e6:	e0 a0 0e 6d 	rcall	8000afc0 <__avr32_f64_cmp_lt>
800092ea:	c1 30       	breq	80009310 <_dtoa_r+0x62c>
800092ec:	33 09       	mov	r9,48
800092ee:	0a 98       	mov	r8,r5
800092f0:	11 7a       	ld.ub	r10,--r8
800092f2:	f2 0a 18 00 	cp.b	r10,r9
800092f6:	e0 81 02 d1 	brne	80009898 <_dtoa_r+0xbb4>
800092fa:	10 95       	mov	r5,r8
800092fc:	cf 9b       	rjmp	800092ee <_dtoa_r+0x60a>
800092fe:	d7 03       	nop
80009300:	30 08       	mov	r8,0
80009302:	fc 19 40 24 	movh	r9,0x4024
80009306:	e0 a0 0b 4b 	rcall	8000a99c <__avr32_f64_mul>
8000930a:	fa eb 00 08 	st.d	sp[8],r10
8000930e:	cb db       	rjmp	80009288 <_dtoa_r+0x5a4>
80009310:	fa ea 00 3c 	ld.d	r10,sp[60]
80009314:	fa eb 00 08 	st.d	sp[8],r10
80009318:	58 e6       	cp.w	r6,14
8000931a:	5f ab       	srle	r11
8000931c:	41 8a       	lddsp	r10,sp[0x60]
8000931e:	30 08       	mov	r8,0
80009320:	f4 09 11 ff 	rsub	r9,r10,-1
80009324:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80009328:	f0 09 18 00 	cp.b	r9,r8
8000932c:	e0 80 00 82 	breq	80009430 <_dtoa_r+0x74c>
80009330:	40 ea       	lddsp	r10,sp[0x38]
80009332:	58 01       	cp.w	r1,0
80009334:	5f a9       	srle	r9
80009336:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000933a:	fe ca c8 ae 	sub	r10,pc,-14162
8000933e:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
80009342:	fa e5 00 10 	st.d	sp[16],r4
80009346:	f0 09 18 00 	cp.b	r9,r8
8000934a:	c1 40       	breq	80009372 <_dtoa_r+0x68e>
8000934c:	58 01       	cp.w	r1,0
8000934e:	e0 81 01 77 	brne	8000963c <_dtoa_r+0x958>
80009352:	30 08       	mov	r8,0
80009354:	fc 19 40 14 	movh	r9,0x4014
80009358:	08 9a       	mov	r10,r4
8000935a:	0a 9b       	mov	r11,r5
8000935c:	e0 a0 0b 20 	rcall	8000a99c <__avr32_f64_mul>
80009360:	fa e8 00 08 	ld.d	r8,sp[8]
80009364:	e0 a0 0d fa 	rcall	8000af58 <__avr32_f64_cmp_ge>
80009368:	e0 81 01 6a 	brne	8000963c <_dtoa_r+0x958>
8000936c:	02 92       	mov	r2,r1
8000936e:	e0 8f 01 72 	bral	80009652 <_dtoa_r+0x96e>
80009372:	40 85       	lddsp	r5,sp[0x20]
80009374:	30 14       	mov	r4,1
80009376:	fa e8 00 10 	ld.d	r8,sp[16]
8000937a:	fa ea 00 08 	ld.d	r10,sp[8]
8000937e:	e0 a0 0e 55 	rcall	8000b028 <__avr32_f64_div>
80009382:	e0 a0 0d 51 	rcall	8000ae24 <__avr32_f64_to_s32>
80009386:	18 92       	mov	r2,r12
80009388:	e0 a0 0d 65 	rcall	8000ae52 <__avr32_s32_to_f64>
8000938c:	fa e8 00 10 	ld.d	r8,sp[16]
80009390:	e0 a0 0b 06 	rcall	8000a99c <__avr32_f64_mul>
80009394:	14 98       	mov	r8,r10
80009396:	16 99       	mov	r9,r11
80009398:	fa ea 00 08 	ld.d	r10,sp[8]
8000939c:	e0 a0 0b ec 	rcall	8000ab74 <__avr32_f64_sub>
800093a0:	fa eb 00 08 	st.d	sp[8],r10
800093a4:	e4 c8 ff d0 	sub	r8,r2,-48
800093a8:	0a c8       	st.b	r5++,r8
800093aa:	fc 19 40 24 	movh	r9,0x4024
800093ae:	30 08       	mov	r8,0
800093b0:	02 34       	cp.w	r4,r1
800093b2:	c3 31       	brne	80009418 <_dtoa_r+0x734>
800093b4:	fa e8 00 08 	ld.d	r8,sp[8]
800093b8:	e0 a0 0c ac 	rcall	8000ad10 <__avr32_f64_add>
800093bc:	16 91       	mov	r1,r11
800093be:	14 90       	mov	r0,r10
800093c0:	14 98       	mov	r8,r10
800093c2:	02 99       	mov	r9,r1
800093c4:	fa ea 00 10 	ld.d	r10,sp[16]
800093c8:	e0 a0 0d fc 	rcall	8000afc0 <__avr32_f64_cmp_lt>
800093cc:	c1 a1       	brne	80009400 <_dtoa_r+0x71c>
800093ce:	fa e8 00 10 	ld.d	r8,sp[16]
800093d2:	00 9a       	mov	r10,r0
800093d4:	02 9b       	mov	r11,r1
800093d6:	e0 a0 0d ae 	rcall	8000af32 <__avr32_f64_cmp_eq>
800093da:	e0 80 02 5e 	breq	80009896 <_dtoa_r+0xbb2>
800093de:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
800093e2:	c0 f1       	brne	80009400 <_dtoa_r+0x71c>
800093e4:	e0 8f 02 59 	bral	80009896 <_dtoa_r+0xbb2>
800093e8:	40 8a       	lddsp	r10,sp[0x20]
800093ea:	14 38       	cp.w	r8,r10
800093ec:	c0 30       	breq	800093f2 <_dtoa_r+0x70e>
800093ee:	10 95       	mov	r5,r8
800093f0:	c0 98       	rjmp	80009402 <_dtoa_r+0x71e>
800093f2:	33 08       	mov	r8,48
800093f4:	40 89       	lddsp	r9,sp[0x20]
800093f6:	2f f6       	sub	r6,-1
800093f8:	b2 88       	st.b	r9[0x0],r8
800093fa:	40 88       	lddsp	r8,sp[0x20]
800093fc:	c0 88       	rjmp	8000940c <_dtoa_r+0x728>
800093fe:	40 66       	lddsp	r6,sp[0x18]
80009400:	33 99       	mov	r9,57
80009402:	0a 98       	mov	r8,r5
80009404:	11 7a       	ld.ub	r10,--r8
80009406:	f2 0a 18 00 	cp.b	r10,r9
8000940a:	ce f0       	breq	800093e8 <_dtoa_r+0x704>
8000940c:	50 66       	stdsp	sp[0x18],r6
8000940e:	11 89       	ld.ub	r9,r8[0x0]
80009410:	2f f9       	sub	r9,-1
80009412:	b0 89       	st.b	r8[0x0],r9
80009414:	e0 8f 02 42 	bral	80009898 <_dtoa_r+0xbb4>
80009418:	e0 a0 0a c2 	rcall	8000a99c <__avr32_f64_mul>
8000941c:	2f f4       	sub	r4,-1
8000941e:	fa eb 00 08 	st.d	sp[8],r10
80009422:	30 08       	mov	r8,0
80009424:	30 09       	mov	r9,0
80009426:	e0 a0 0d 86 	rcall	8000af32 <__avr32_f64_cmp_eq>
8000942a:	ca 60       	breq	80009376 <_dtoa_r+0x692>
8000942c:	e0 8f 02 35 	bral	80009896 <_dtoa_r+0xbb2>
80009430:	40 d8       	lddsp	r8,sp[0x34]
80009432:	58 08       	cp.w	r8,0
80009434:	c0 51       	brne	8000943e <_dtoa_r+0x75a>
80009436:	04 98       	mov	r8,r2
80009438:	00 95       	mov	r5,r0
8000943a:	40 d4       	lddsp	r4,sp[0x34]
8000943c:	c3 78       	rjmp	800094aa <_dtoa_r+0x7c6>
8000943e:	40 c5       	lddsp	r5,sp[0x30]
80009440:	58 15       	cp.w	r5,1
80009442:	e0 89 00 0f 	brgt	80009460 <_dtoa_r+0x77c>
80009446:	41 74       	lddsp	r4,sp[0x5c]
80009448:	58 04       	cp.w	r4,0
8000944a:	c0 40       	breq	80009452 <_dtoa_r+0x76e>
8000944c:	f4 c9 fb cd 	sub	r9,r10,-1075
80009450:	c0 48       	rjmp	80009458 <_dtoa_r+0x774>
80009452:	41 99       	lddsp	r9,sp[0x64]
80009454:	f2 09 11 36 	rsub	r9,r9,54
80009458:	04 98       	mov	r8,r2
8000945a:	00 95       	mov	r5,r0
8000945c:	c1 c8       	rjmp	80009494 <_dtoa_r+0x7b0>
8000945e:	d7 03       	nop
80009460:	e2 c8 00 01 	sub	r8,r1,1
80009464:	58 01       	cp.w	r1,0
80009466:	e0 05 17 40 	movge	r5,r0
8000946a:	e2 09 17 40 	movge	r9,r1
8000946e:	e1 d1 e5 15 	sublt	r5,r0,r1
80009472:	f9 b9 05 00 	movlt	r9,0
80009476:	10 32       	cp.w	r2,r8
80009478:	e5 d8 e4 18 	subge	r8,r2,r8
8000947c:	f1 d2 e5 18 	sublt	r8,r8,r2
80009480:	e5 d8 e5 02 	addlt	r2,r2,r8
80009484:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80009488:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000948c:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80009490:	f9 b8 05 00 	movlt	r8,0
80009494:	40 4b       	lddsp	r11,sp[0x10]
80009496:	12 0b       	add	r11,r9
80009498:	50 08       	stdsp	sp[0x0],r8
8000949a:	50 4b       	stdsp	sp[0x10],r11
8000949c:	12 00       	add	r0,r9
8000949e:	30 1b       	mov	r11,1
800094a0:	0e 9c       	mov	r12,r7
800094a2:	e0 a0 08 a7 	rcall	8000a5f0 <__i2b>
800094a6:	40 08       	lddsp	r8,sp[0x0]
800094a8:	18 94       	mov	r4,r12
800094aa:	40 4a       	lddsp	r10,sp[0x10]
800094ac:	58 05       	cp.w	r5,0
800094ae:	5f 99       	srgt	r9
800094b0:	58 0a       	cp.w	r10,0
800094b2:	5f 9a       	srgt	r10
800094b4:	f5 e9 00 09 	and	r9,r10,r9
800094b8:	c0 80       	breq	800094c8 <_dtoa_r+0x7e4>
800094ba:	40 4c       	lddsp	r12,sp[0x10]
800094bc:	f8 05 0d 49 	min	r9,r12,r5
800094c0:	12 1c       	sub	r12,r9
800094c2:	12 10       	sub	r0,r9
800094c4:	50 4c       	stdsp	sp[0x10],r12
800094c6:	12 15       	sub	r5,r9
800094c8:	58 02       	cp.w	r2,0
800094ca:	e0 8a 00 27 	brle	80009518 <_dtoa_r+0x834>
800094ce:	40 db       	lddsp	r11,sp[0x34]
800094d0:	58 0b       	cp.w	r11,0
800094d2:	c1 d0       	breq	8000950c <_dtoa_r+0x828>
800094d4:	58 08       	cp.w	r8,0
800094d6:	e0 8a 00 17 	brle	80009504 <_dtoa_r+0x820>
800094da:	10 9a       	mov	r10,r8
800094dc:	50 08       	stdsp	sp[0x0],r8
800094de:	08 9b       	mov	r11,r4
800094e0:	0e 9c       	mov	r12,r7
800094e2:	e0 a0 08 cd 	rcall	8000a67c <__pow5mult>
800094e6:	06 9a       	mov	r10,r3
800094e8:	18 9b       	mov	r11,r12
800094ea:	18 94       	mov	r4,r12
800094ec:	0e 9c       	mov	r12,r7
800094ee:	e0 a0 08 01 	rcall	8000a4f0 <__multiply>
800094f2:	18 99       	mov	r9,r12
800094f4:	06 9b       	mov	r11,r3
800094f6:	50 19       	stdsp	sp[0x4],r9
800094f8:	0e 9c       	mov	r12,r7
800094fa:	e0 a0 06 ad 	rcall	8000a254 <_Bfree>
800094fe:	40 19       	lddsp	r9,sp[0x4]
80009500:	40 08       	lddsp	r8,sp[0x0]
80009502:	12 93       	mov	r3,r9
80009504:	e4 08 01 0a 	sub	r10,r2,r8
80009508:	c0 80       	breq	80009518 <_dtoa_r+0x834>
8000950a:	c0 28       	rjmp	8000950e <_dtoa_r+0x82a>
8000950c:	04 9a       	mov	r10,r2
8000950e:	06 9b       	mov	r11,r3
80009510:	0e 9c       	mov	r12,r7
80009512:	e0 a0 08 b5 	rcall	8000a67c <__pow5mult>
80009516:	18 93       	mov	r3,r12
80009518:	30 1b       	mov	r11,1
8000951a:	0e 9c       	mov	r12,r7
8000951c:	e0 a0 08 6a 	rcall	8000a5f0 <__i2b>
80009520:	41 1a       	lddsp	r10,sp[0x44]
80009522:	18 92       	mov	r2,r12
80009524:	58 0a       	cp.w	r10,0
80009526:	e0 8a 00 07 	brle	80009534 <_dtoa_r+0x850>
8000952a:	18 9b       	mov	r11,r12
8000952c:	0e 9c       	mov	r12,r7
8000952e:	e0 a0 08 a7 	rcall	8000a67c <__pow5mult>
80009532:	18 92       	mov	r2,r12
80009534:	40 c9       	lddsp	r9,sp[0x30]
80009536:	58 19       	cp.w	r9,1
80009538:	e0 89 00 14 	brgt	80009560 <_dtoa_r+0x87c>
8000953c:	40 38       	lddsp	r8,sp[0xc]
8000953e:	58 08       	cp.w	r8,0
80009540:	c1 01       	brne	80009560 <_dtoa_r+0x87c>
80009542:	40 29       	lddsp	r9,sp[0x8]
80009544:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80009548:	c0 c1       	brne	80009560 <_dtoa_r+0x87c>
8000954a:	12 98       	mov	r8,r9
8000954c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009550:	c0 80       	breq	80009560 <_dtoa_r+0x87c>
80009552:	40 4c       	lddsp	r12,sp[0x10]
80009554:	30 1b       	mov	r11,1
80009556:	2f fc       	sub	r12,-1
80009558:	2f f0       	sub	r0,-1
8000955a:	50 4c       	stdsp	sp[0x10],r12
8000955c:	50 6b       	stdsp	sp[0x18],r11
8000955e:	c0 38       	rjmp	80009564 <_dtoa_r+0x880>
80009560:	30 0a       	mov	r10,0
80009562:	50 6a       	stdsp	sp[0x18],r10
80009564:	41 19       	lddsp	r9,sp[0x44]
80009566:	58 09       	cp.w	r9,0
80009568:	c0 31       	brne	8000956e <_dtoa_r+0x88a>
8000956a:	30 1c       	mov	r12,1
8000956c:	c0 98       	rjmp	8000957e <_dtoa_r+0x89a>
8000956e:	64 48       	ld.w	r8,r2[0x10]
80009570:	2f c8       	sub	r8,-4
80009572:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
80009576:	e0 a0 05 df 	rcall	8000a134 <__hi0bits>
8000957a:	f8 0c 11 20 	rsub	r12,r12,32
8000957e:	40 4b       	lddsp	r11,sp[0x10]
80009580:	f8 0b 00 08 	add	r8,r12,r11
80009584:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80009588:	c0 c0       	breq	800095a0 <_dtoa_r+0x8bc>
8000958a:	f0 08 11 20 	rsub	r8,r8,32
8000958e:	58 48       	cp.w	r8,4
80009590:	e0 8a 00 06 	brle	8000959c <_dtoa_r+0x8b8>
80009594:	20 48       	sub	r8,4
80009596:	10 0b       	add	r11,r8
80009598:	50 4b       	stdsp	sp[0x10],r11
8000959a:	c0 78       	rjmp	800095a8 <_dtoa_r+0x8c4>
8000959c:	58 48       	cp.w	r8,4
8000959e:	c0 70       	breq	800095ac <_dtoa_r+0x8c8>
800095a0:	40 4a       	lddsp	r10,sp[0x10]
800095a2:	2e 48       	sub	r8,-28
800095a4:	10 0a       	add	r10,r8
800095a6:	50 4a       	stdsp	sp[0x10],r10
800095a8:	10 00       	add	r0,r8
800095aa:	10 05       	add	r5,r8
800095ac:	58 00       	cp.w	r0,0
800095ae:	e0 8a 00 08 	brle	800095be <_dtoa_r+0x8da>
800095b2:	06 9b       	mov	r11,r3
800095b4:	00 9a       	mov	r10,r0
800095b6:	0e 9c       	mov	r12,r7
800095b8:	e0 a0 07 58 	rcall	8000a468 <__lshift>
800095bc:	18 93       	mov	r3,r12
800095be:	40 49       	lddsp	r9,sp[0x10]
800095c0:	58 09       	cp.w	r9,0
800095c2:	e0 8a 00 08 	brle	800095d2 <_dtoa_r+0x8ee>
800095c6:	04 9b       	mov	r11,r2
800095c8:	12 9a       	mov	r10,r9
800095ca:	0e 9c       	mov	r12,r7
800095cc:	e0 a0 07 4e 	rcall	8000a468 <__lshift>
800095d0:	18 92       	mov	r2,r12
800095d2:	41 48       	lddsp	r8,sp[0x50]
800095d4:	58 08       	cp.w	r8,0
800095d6:	c1 b0       	breq	8000960c <_dtoa_r+0x928>
800095d8:	04 9b       	mov	r11,r2
800095da:	06 9c       	mov	r12,r3
800095dc:	e0 a0 06 23 	rcall	8000a222 <__mcmp>
800095e0:	c1 64       	brge	8000960c <_dtoa_r+0x928>
800095e2:	06 9b       	mov	r11,r3
800095e4:	30 09       	mov	r9,0
800095e6:	30 aa       	mov	r10,10
800095e8:	0e 9c       	mov	r12,r7
800095ea:	e0 a0 08 0b 	rcall	8000a600 <__multadd>
800095ee:	20 16       	sub	r6,1
800095f0:	18 93       	mov	r3,r12
800095f2:	40 dc       	lddsp	r12,sp[0x34]
800095f4:	58 0c       	cp.w	r12,0
800095f6:	c0 31       	brne	800095fc <_dtoa_r+0x918>
800095f8:	40 91       	lddsp	r1,sp[0x24]
800095fa:	c0 98       	rjmp	8000960c <_dtoa_r+0x928>
800095fc:	08 9b       	mov	r11,r4
800095fe:	40 91       	lddsp	r1,sp[0x24]
80009600:	30 09       	mov	r9,0
80009602:	30 aa       	mov	r10,10
80009604:	0e 9c       	mov	r12,r7
80009606:	e0 a0 07 fd 	rcall	8000a600 <__multadd>
8000960a:	18 94       	mov	r4,r12
8000960c:	58 01       	cp.w	r1,0
8000960e:	5f a9       	srle	r9
80009610:	40 cb       	lddsp	r11,sp[0x30]
80009612:	58 2b       	cp.w	r11,2
80009614:	5f 98       	srgt	r8
80009616:	f3 e8 00 08 	and	r8,r9,r8
8000961a:	c2 50       	breq	80009664 <_dtoa_r+0x980>
8000961c:	58 01       	cp.w	r1,0
8000961e:	c1 11       	brne	80009640 <_dtoa_r+0x95c>
80009620:	04 9b       	mov	r11,r2
80009622:	02 99       	mov	r9,r1
80009624:	30 5a       	mov	r10,5
80009626:	0e 9c       	mov	r12,r7
80009628:	e0 a0 07 ec 	rcall	8000a600 <__multadd>
8000962c:	18 92       	mov	r2,r12
8000962e:	18 9b       	mov	r11,r12
80009630:	06 9c       	mov	r12,r3
80009632:	e0 a0 05 f8 	rcall	8000a222 <__mcmp>
80009636:	e0 89 00 0f 	brgt	80009654 <_dtoa_r+0x970>
8000963a:	c0 38       	rjmp	80009640 <_dtoa_r+0x95c>
8000963c:	30 02       	mov	r2,0
8000963e:	04 94       	mov	r4,r2
80009640:	40 ea       	lddsp	r10,sp[0x38]
80009642:	30 09       	mov	r9,0
80009644:	5c da       	com	r10
80009646:	40 85       	lddsp	r5,sp[0x20]
80009648:	50 6a       	stdsp	sp[0x18],r10
8000964a:	50 49       	stdsp	sp[0x10],r9
8000964c:	c0 f9       	rjmp	8000986a <_dtoa_r+0xb86>
8000964e:	08 92       	mov	r2,r4
80009650:	40 66       	lddsp	r6,sp[0x18]
80009652:	04 94       	mov	r4,r2
80009654:	2f f6       	sub	r6,-1
80009656:	50 66       	stdsp	sp[0x18],r6
80009658:	33 18       	mov	r8,49
8000965a:	40 85       	lddsp	r5,sp[0x20]
8000965c:	0a c8       	st.b	r5++,r8
8000965e:	30 08       	mov	r8,0
80009660:	50 48       	stdsp	sp[0x10],r8
80009662:	c0 49       	rjmp	8000986a <_dtoa_r+0xb86>
80009664:	40 dc       	lddsp	r12,sp[0x34]
80009666:	58 0c       	cp.w	r12,0
80009668:	e0 80 00 b5 	breq	800097d2 <_dtoa_r+0xaee>
8000966c:	58 05       	cp.w	r5,0
8000966e:	e0 8a 00 08 	brle	8000967e <_dtoa_r+0x99a>
80009672:	08 9b       	mov	r11,r4
80009674:	0a 9a       	mov	r10,r5
80009676:	0e 9c       	mov	r12,r7
80009678:	e0 a0 06 f8 	rcall	8000a468 <__lshift>
8000967c:	18 94       	mov	r4,r12
8000967e:	40 6b       	lddsp	r11,sp[0x18]
80009680:	58 0b       	cp.w	r11,0
80009682:	c0 31       	brne	80009688 <_dtoa_r+0x9a4>
80009684:	08 9c       	mov	r12,r4
80009686:	c1 38       	rjmp	800096ac <_dtoa_r+0x9c8>
80009688:	68 1b       	ld.w	r11,r4[0x4]
8000968a:	0e 9c       	mov	r12,r7
8000968c:	e0 a0 05 fe 	rcall	8000a288 <_Balloc>
80009690:	68 4a       	ld.w	r10,r4[0x10]
80009692:	18 95       	mov	r5,r12
80009694:	e8 cb ff f4 	sub	r11,r4,-12
80009698:	2f ea       	sub	r10,-2
8000969a:	2f 4c       	sub	r12,-12
8000969c:	a3 6a       	lsl	r10,0x2
8000969e:	fe b0 e6 43 	rcall	80006324 <memcpy>
800096a2:	0a 9b       	mov	r11,r5
800096a4:	30 1a       	mov	r10,1
800096a6:	0e 9c       	mov	r12,r7
800096a8:	e0 a0 06 e0 	rcall	8000a468 <__lshift>
800096ac:	50 44       	stdsp	sp[0x10],r4
800096ae:	40 3a       	lddsp	r10,sp[0xc]
800096b0:	30 19       	mov	r9,1
800096b2:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
800096b6:	18 94       	mov	r4,r12
800096b8:	50 da       	stdsp	sp[0x34],r10
800096ba:	40 85       	lddsp	r5,sp[0x20]
800096bc:	50 99       	stdsp	sp[0x24],r9
800096be:	50 26       	stdsp	sp[0x8],r6
800096c0:	50 e1       	stdsp	sp[0x38],r1
800096c2:	04 9b       	mov	r11,r2
800096c4:	06 9c       	mov	r12,r3
800096c6:	fe b0 fa 7f 	rcall	80008bc4 <quorem>
800096ca:	40 4b       	lddsp	r11,sp[0x10]
800096cc:	f8 c0 ff d0 	sub	r0,r12,-48
800096d0:	06 9c       	mov	r12,r3
800096d2:	e0 a0 05 a8 	rcall	8000a222 <__mcmp>
800096d6:	08 9a       	mov	r10,r4
800096d8:	50 6c       	stdsp	sp[0x18],r12
800096da:	04 9b       	mov	r11,r2
800096dc:	0e 9c       	mov	r12,r7
800096de:	e0 a0 06 5d 	rcall	8000a398 <__mdiff>
800096e2:	18 91       	mov	r1,r12
800096e4:	78 38       	ld.w	r8,r12[0xc]
800096e6:	58 08       	cp.w	r8,0
800096e8:	c0 30       	breq	800096ee <_dtoa_r+0xa0a>
800096ea:	30 16       	mov	r6,1
800096ec:	c0 68       	rjmp	800096f8 <_dtoa_r+0xa14>
800096ee:	18 9b       	mov	r11,r12
800096f0:	06 9c       	mov	r12,r3
800096f2:	e0 a0 05 98 	rcall	8000a222 <__mcmp>
800096f6:	18 96       	mov	r6,r12
800096f8:	0e 9c       	mov	r12,r7
800096fa:	02 9b       	mov	r11,r1
800096fc:	e0 a0 05 ac 	rcall	8000a254 <_Bfree>
80009700:	40 cc       	lddsp	r12,sp[0x30]
80009702:	ed ec 10 08 	or	r8,r6,r12
80009706:	c0 d1       	brne	80009720 <_dtoa_r+0xa3c>
80009708:	40 db       	lddsp	r11,sp[0x34]
8000970a:	58 0b       	cp.w	r11,0
8000970c:	c0 a1       	brne	80009720 <_dtoa_r+0xa3c>
8000970e:	40 26       	lddsp	r6,sp[0x8]
80009710:	e0 40 00 39 	cp.w	r0,57
80009714:	c3 00       	breq	80009774 <_dtoa_r+0xa90>
80009716:	40 6a       	lddsp	r10,sp[0x18]
80009718:	58 0a       	cp.w	r10,0
8000971a:	e0 89 00 24 	brgt	80009762 <_dtoa_r+0xa7e>
8000971e:	c2 f8       	rjmp	8000977c <_dtoa_r+0xa98>
80009720:	40 69       	lddsp	r9,sp[0x18]
80009722:	58 09       	cp.w	r9,0
80009724:	c0 85       	brlt	80009734 <_dtoa_r+0xa50>
80009726:	12 98       	mov	r8,r9
80009728:	40 cc       	lddsp	r12,sp[0x30]
8000972a:	18 48       	or	r8,r12
8000972c:	c1 d1       	brne	80009766 <_dtoa_r+0xa82>
8000972e:	40 db       	lddsp	r11,sp[0x34]
80009730:	58 0b       	cp.w	r11,0
80009732:	c1 a1       	brne	80009766 <_dtoa_r+0xa82>
80009734:	0c 99       	mov	r9,r6
80009736:	40 26       	lddsp	r6,sp[0x8]
80009738:	58 09       	cp.w	r9,0
8000973a:	e0 8a 00 21 	brle	8000977c <_dtoa_r+0xa98>
8000973e:	06 9b       	mov	r11,r3
80009740:	30 1a       	mov	r10,1
80009742:	0e 9c       	mov	r12,r7
80009744:	e0 a0 06 92 	rcall	8000a468 <__lshift>
80009748:	04 9b       	mov	r11,r2
8000974a:	18 93       	mov	r3,r12
8000974c:	e0 a0 05 6b 	rcall	8000a222 <__mcmp>
80009750:	e0 89 00 06 	brgt	8000975c <_dtoa_r+0xa78>
80009754:	c1 41       	brne	8000977c <_dtoa_r+0xa98>
80009756:	ed b0 00 00 	bld	r0,0x0
8000975a:	c1 11       	brne	8000977c <_dtoa_r+0xa98>
8000975c:	e0 40 00 39 	cp.w	r0,57
80009760:	c0 a0       	breq	80009774 <_dtoa_r+0xa90>
80009762:	2f f0       	sub	r0,-1
80009764:	c0 c8       	rjmp	8000977c <_dtoa_r+0xa98>
80009766:	58 06       	cp.w	r6,0
80009768:	e0 8a 00 0c 	brle	80009780 <_dtoa_r+0xa9c>
8000976c:	40 26       	lddsp	r6,sp[0x8]
8000976e:	e0 40 00 39 	cp.w	r0,57
80009772:	c0 41       	brne	8000977a <_dtoa_r+0xa96>
80009774:	33 98       	mov	r8,57
80009776:	0a c8       	st.b	r5++,r8
80009778:	c6 78       	rjmp	80009846 <_dtoa_r+0xb62>
8000977a:	2f f0       	sub	r0,-1
8000977c:	0a c0       	st.b	r5++,r0
8000977e:	c7 58       	rjmp	80009868 <_dtoa_r+0xb84>
80009780:	0a c0       	st.b	r5++,r0
80009782:	40 9a       	lddsp	r10,sp[0x24]
80009784:	40 e9       	lddsp	r9,sp[0x38]
80009786:	12 3a       	cp.w	r10,r9
80009788:	c4 30       	breq	8000980e <_dtoa_r+0xb2a>
8000978a:	06 9b       	mov	r11,r3
8000978c:	30 09       	mov	r9,0
8000978e:	30 aa       	mov	r10,10
80009790:	0e 9c       	mov	r12,r7
80009792:	e0 a0 07 37 	rcall	8000a600 <__multadd>
80009796:	40 48       	lddsp	r8,sp[0x10]
80009798:	18 93       	mov	r3,r12
8000979a:	08 38       	cp.w	r8,r4
8000979c:	c0 91       	brne	800097ae <_dtoa_r+0xaca>
8000979e:	10 9b       	mov	r11,r8
800097a0:	30 09       	mov	r9,0
800097a2:	30 aa       	mov	r10,10
800097a4:	0e 9c       	mov	r12,r7
800097a6:	e0 a0 07 2d 	rcall	8000a600 <__multadd>
800097aa:	50 4c       	stdsp	sp[0x10],r12
800097ac:	c0 e8       	rjmp	800097c8 <_dtoa_r+0xae4>
800097ae:	40 4b       	lddsp	r11,sp[0x10]
800097b0:	30 09       	mov	r9,0
800097b2:	30 aa       	mov	r10,10
800097b4:	0e 9c       	mov	r12,r7
800097b6:	e0 a0 07 25 	rcall	8000a600 <__multadd>
800097ba:	08 9b       	mov	r11,r4
800097bc:	50 4c       	stdsp	sp[0x10],r12
800097be:	30 09       	mov	r9,0
800097c0:	30 aa       	mov	r10,10
800097c2:	0e 9c       	mov	r12,r7
800097c4:	e0 a0 07 1e 	rcall	8000a600 <__multadd>
800097c8:	18 94       	mov	r4,r12
800097ca:	40 9c       	lddsp	r12,sp[0x24]
800097cc:	2f fc       	sub	r12,-1
800097ce:	50 9c       	stdsp	sp[0x24],r12
800097d0:	c7 9b       	rjmp	800096c2 <_dtoa_r+0x9de>
800097d2:	30 18       	mov	r8,1
800097d4:	06 90       	mov	r0,r3
800097d6:	40 85       	lddsp	r5,sp[0x20]
800097d8:	08 93       	mov	r3,r4
800097da:	0c 94       	mov	r4,r6
800097dc:	10 96       	mov	r6,r8
800097de:	04 9b       	mov	r11,r2
800097e0:	00 9c       	mov	r12,r0
800097e2:	fe b0 f9 f1 	rcall	80008bc4 <quorem>
800097e6:	2d 0c       	sub	r12,-48
800097e8:	0a cc       	st.b	r5++,r12
800097ea:	02 36       	cp.w	r6,r1
800097ec:	c0 a4       	brge	80009800 <_dtoa_r+0xb1c>
800097ee:	00 9b       	mov	r11,r0
800097f0:	30 09       	mov	r9,0
800097f2:	30 aa       	mov	r10,10
800097f4:	0e 9c       	mov	r12,r7
800097f6:	2f f6       	sub	r6,-1
800097f8:	e0 a0 07 04 	rcall	8000a600 <__multadd>
800097fc:	18 90       	mov	r0,r12
800097fe:	cf 0b       	rjmp	800097de <_dtoa_r+0xafa>
80009800:	08 96       	mov	r6,r4
80009802:	30 0b       	mov	r11,0
80009804:	06 94       	mov	r4,r3
80009806:	50 4b       	stdsp	sp[0x10],r11
80009808:	00 93       	mov	r3,r0
8000980a:	18 90       	mov	r0,r12
8000980c:	c0 28       	rjmp	80009810 <_dtoa_r+0xb2c>
8000980e:	40 26       	lddsp	r6,sp[0x8]
80009810:	06 9b       	mov	r11,r3
80009812:	30 1a       	mov	r10,1
80009814:	0e 9c       	mov	r12,r7
80009816:	e0 a0 06 29 	rcall	8000a468 <__lshift>
8000981a:	04 9b       	mov	r11,r2
8000981c:	18 93       	mov	r3,r12
8000981e:	e0 a0 05 02 	rcall	8000a222 <__mcmp>
80009822:	e0 89 00 12 	brgt	80009846 <_dtoa_r+0xb62>
80009826:	c1 b1       	brne	8000985c <_dtoa_r+0xb78>
80009828:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000982c:	c0 d1       	brne	80009846 <_dtoa_r+0xb62>
8000982e:	c1 78       	rjmp	8000985c <_dtoa_r+0xb78>
80009830:	40 89       	lddsp	r9,sp[0x20]
80009832:	12 38       	cp.w	r8,r9
80009834:	c0 30       	breq	8000983a <_dtoa_r+0xb56>
80009836:	10 95       	mov	r5,r8
80009838:	c0 88       	rjmp	80009848 <_dtoa_r+0xb64>
8000983a:	2f f6       	sub	r6,-1
8000983c:	50 66       	stdsp	sp[0x18],r6
8000983e:	33 18       	mov	r8,49
80009840:	40 8c       	lddsp	r12,sp[0x20]
80009842:	b8 88       	st.b	r12[0x0],r8
80009844:	c1 38       	rjmp	8000986a <_dtoa_r+0xb86>
80009846:	33 9a       	mov	r10,57
80009848:	0a 98       	mov	r8,r5
8000984a:	11 79       	ld.ub	r9,--r8
8000984c:	f4 09 18 00 	cp.b	r9,r10
80009850:	cf 00       	breq	80009830 <_dtoa_r+0xb4c>
80009852:	2f f9       	sub	r9,-1
80009854:	b0 89       	st.b	r8[0x0],r9
80009856:	c0 98       	rjmp	80009868 <_dtoa_r+0xb84>
80009858:	10 95       	mov	r5,r8
8000985a:	c0 28       	rjmp	8000985e <_dtoa_r+0xb7a>
8000985c:	33 09       	mov	r9,48
8000985e:	0a 98       	mov	r8,r5
80009860:	11 7a       	ld.ub	r10,--r8
80009862:	f2 0a 18 00 	cp.b	r10,r9
80009866:	cf 90       	breq	80009858 <_dtoa_r+0xb74>
80009868:	50 66       	stdsp	sp[0x18],r6
8000986a:	04 9b       	mov	r11,r2
8000986c:	0e 9c       	mov	r12,r7
8000986e:	e0 a0 04 f3 	rcall	8000a254 <_Bfree>
80009872:	58 04       	cp.w	r4,0
80009874:	c1 20       	breq	80009898 <_dtoa_r+0xbb4>
80009876:	40 4b       	lddsp	r11,sp[0x10]
80009878:	08 3b       	cp.w	r11,r4
8000987a:	5f 19       	srne	r9
8000987c:	58 0b       	cp.w	r11,0
8000987e:	5f 18       	srne	r8
80009880:	f3 e8 00 08 	and	r8,r9,r8
80009884:	c0 40       	breq	8000988c <_dtoa_r+0xba8>
80009886:	0e 9c       	mov	r12,r7
80009888:	e0 a0 04 e6 	rcall	8000a254 <_Bfree>
8000988c:	08 9b       	mov	r11,r4
8000988e:	0e 9c       	mov	r12,r7
80009890:	e0 a0 04 e2 	rcall	8000a254 <_Bfree>
80009894:	c0 28       	rjmp	80009898 <_dtoa_r+0xbb4>
80009896:	50 66       	stdsp	sp[0x18],r6
80009898:	0e 9c       	mov	r12,r7
8000989a:	06 9b       	mov	r11,r3
8000989c:	e0 a0 04 dc 	rcall	8000a254 <_Bfree>
800098a0:	30 08       	mov	r8,0
800098a2:	aa 88       	st.b	r5[0x0],r8
800098a4:	40 68       	lddsp	r8,sp[0x18]
800098a6:	41 5a       	lddsp	r10,sp[0x54]
800098a8:	2f f8       	sub	r8,-1
800098aa:	41 29       	lddsp	r9,sp[0x48]
800098ac:	95 08       	st.w	r10[0x0],r8
800098ae:	40 8c       	lddsp	r12,sp[0x20]
800098b0:	58 09       	cp.w	r9,0
800098b2:	fb f8 10 12 	ld.wne	r8,sp[0x48]
800098b6:	f1 f5 1a 00 	st.wne	r8[0x0],r5
800098ba:	2e 6d       	sub	sp,-104
800098bc:	d8 32       	popm	r0-r7,pc
800098be:	d7 03       	nop

800098c0 <__errno>:
800098c0:	e0 68 0a 38 	mov	r8,2616
800098c4:	70 0c       	ld.w	r12,r8[0x0]
800098c6:	2f 4c       	sub	r12,-12
800098c8:	5e fc       	retal	r12
800098ca:	d7 03       	nop

800098cc <_fflush_r>:
800098cc:	d4 21       	pushm	r4-r7,lr
800098ce:	16 97       	mov	r7,r11
800098d0:	18 96       	mov	r6,r12
800098d2:	76 48       	ld.w	r8,r11[0x10]
800098d4:	58 08       	cp.w	r8,0
800098d6:	c7 f0       	breq	800099d4 <_fflush_r+0x108>
800098d8:	58 0c       	cp.w	r12,0
800098da:	c0 50       	breq	800098e4 <_fflush_r+0x18>
800098dc:	78 68       	ld.w	r8,r12[0x18]
800098de:	58 08       	cp.w	r8,0
800098e0:	c0 21       	brne	800098e4 <_fflush_r+0x18>
800098e2:	cc dc       	rcall	80009a7c <__sinit>
800098e4:	fe c8 cf 08 	sub	r8,pc,-12536
800098e8:	10 37       	cp.w	r7,r8
800098ea:	c0 31       	brne	800098f0 <_fflush_r+0x24>
800098ec:	6c 07       	ld.w	r7,r6[0x0]
800098ee:	c0 c8       	rjmp	80009906 <_fflush_r+0x3a>
800098f0:	fe c8 ce f4 	sub	r8,pc,-12556
800098f4:	10 37       	cp.w	r7,r8
800098f6:	c0 31       	brne	800098fc <_fflush_r+0x30>
800098f8:	6c 17       	ld.w	r7,r6[0x4]
800098fa:	c0 68       	rjmp	80009906 <_fflush_r+0x3a>
800098fc:	fe c8 ce e0 	sub	r8,pc,-12576
80009900:	10 37       	cp.w	r7,r8
80009902:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80009906:	8e 6a       	ld.sh	r10,r7[0xc]
80009908:	14 98       	mov	r8,r10
8000990a:	ed ba 00 03 	bld	r10,0x3
8000990e:	c4 20       	breq	80009992 <_fflush_r+0xc6>
80009910:	ab ba       	sbr	r10,0xb
80009912:	ae 6a       	st.h	r7[0xc],r10
80009914:	6e 18       	ld.w	r8,r7[0x4]
80009916:	58 08       	cp.w	r8,0
80009918:	e0 89 00 06 	brgt	80009924 <_fflush_r+0x58>
8000991c:	6f 08       	ld.w	r8,r7[0x40]
8000991e:	58 08       	cp.w	r8,0
80009920:	e0 8a 00 5a 	brle	800099d4 <_fflush_r+0x108>
80009924:	6e b8       	ld.w	r8,r7[0x2c]
80009926:	58 08       	cp.w	r8,0
80009928:	c5 60       	breq	800099d4 <_fflush_r+0x108>
8000992a:	e2 1a 10 00 	andl	r10,0x1000,COH
8000992e:	c0 30       	breq	80009934 <_fflush_r+0x68>
80009930:	6f 55       	ld.w	r5,r7[0x54]
80009932:	c0 f8       	rjmp	80009950 <_fflush_r+0x84>
80009934:	30 19       	mov	r9,1
80009936:	6e 8b       	ld.w	r11,r7[0x20]
80009938:	0c 9c       	mov	r12,r6
8000993a:	5d 18       	icall	r8
8000993c:	18 95       	mov	r5,r12
8000993e:	5b fc       	cp.w	r12,-1
80009940:	c0 81       	brne	80009950 <_fflush_r+0x84>
80009942:	6c 38       	ld.w	r8,r6[0xc]
80009944:	59 d8       	cp.w	r8,29
80009946:	c4 70       	breq	800099d4 <_fflush_r+0x108>
80009948:	8e 68       	ld.sh	r8,r7[0xc]
8000994a:	a7 a8       	sbr	r8,0x6
8000994c:	ae 68       	st.h	r7[0xc],r8
8000994e:	d8 22       	popm	r4-r7,pc
80009950:	8e 68       	ld.sh	r8,r7[0xc]
80009952:	ed b8 00 02 	bld	r8,0x2
80009956:	c0 91       	brne	80009968 <_fflush_r+0x9c>
80009958:	6e 18       	ld.w	r8,r7[0x4]
8000995a:	10 15       	sub	r5,r8
8000995c:	6e d8       	ld.w	r8,r7[0x34]
8000995e:	58 08       	cp.w	r8,0
80009960:	ef f8 10 10 	ld.wne	r8,r7[0x40]
80009964:	eb d8 e1 15 	subne	r5,r5,r8
80009968:	6e b8       	ld.w	r8,r7[0x2c]
8000996a:	0c 9c       	mov	r12,r6
8000996c:	30 09       	mov	r9,0
8000996e:	0a 9a       	mov	r10,r5
80009970:	6e 8b       	ld.w	r11,r7[0x20]
80009972:	5d 18       	icall	r8
80009974:	8e 68       	ld.sh	r8,r7[0xc]
80009976:	0a 3c       	cp.w	r12,r5
80009978:	c2 61       	brne	800099c4 <_fflush_r+0xf8>
8000997a:	ab d8       	cbr	r8,0xb
8000997c:	30 0c       	mov	r12,0
8000997e:	6e 49       	ld.w	r9,r7[0x10]
80009980:	ae 68       	st.h	r7[0xc],r8
80009982:	8f 1c       	st.w	r7[0x4],r12
80009984:	8f 09       	st.w	r7[0x0],r9
80009986:	ed b8 00 0c 	bld	r8,0xc
8000998a:	c2 51       	brne	800099d4 <_fflush_r+0x108>
8000998c:	ef 45 00 54 	st.w	r7[84],r5
80009990:	d8 22       	popm	r4-r7,pc
80009992:	6e 45       	ld.w	r5,r7[0x10]
80009994:	58 05       	cp.w	r5,0
80009996:	c1 f0       	breq	800099d4 <_fflush_r+0x108>
80009998:	6e 04       	ld.w	r4,r7[0x0]
8000999a:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000999e:	8f 05       	st.w	r7[0x0],r5
800099a0:	f9 b8 01 00 	movne	r8,0
800099a4:	ef f8 00 05 	ld.weq	r8,r7[0x14]
800099a8:	0a 14       	sub	r4,r5
800099aa:	8f 28       	st.w	r7[0x8],r8
800099ac:	c1 18       	rjmp	800099ce <_fflush_r+0x102>
800099ae:	08 99       	mov	r9,r4
800099b0:	0a 9a       	mov	r10,r5
800099b2:	6e a8       	ld.w	r8,r7[0x28]
800099b4:	6e 8b       	ld.w	r11,r7[0x20]
800099b6:	0c 9c       	mov	r12,r6
800099b8:	5d 18       	icall	r8
800099ba:	18 14       	sub	r4,r12
800099bc:	58 0c       	cp.w	r12,0
800099be:	e0 89 00 07 	brgt	800099cc <_fflush_r+0x100>
800099c2:	8e 68       	ld.sh	r8,r7[0xc]
800099c4:	a7 a8       	sbr	r8,0x6
800099c6:	3f fc       	mov	r12,-1
800099c8:	ae 68       	st.h	r7[0xc],r8
800099ca:	d8 22       	popm	r4-r7,pc
800099cc:	18 05       	add	r5,r12
800099ce:	58 04       	cp.w	r4,0
800099d0:	fe 99 ff ef 	brgt	800099ae <_fflush_r+0xe2>
800099d4:	d8 2a       	popm	r4-r7,pc,r12=0
800099d6:	d7 03       	nop

800099d8 <__sfp_lock_acquire>:
800099d8:	5e fc       	retal	r12

800099da <__sfp_lock_release>:
800099da:	5e fc       	retal	r12

800099dc <_cleanup_r>:
800099dc:	d4 01       	pushm	lr
800099de:	fe cb f0 c6 	sub	r11,pc,-3898
800099e2:	e0 a0 02 f7 	rcall	80009fd0 <_fwalk>
800099e6:	d8 02       	popm	pc

800099e8 <__sfmoreglue>:
800099e8:	d4 21       	pushm	r4-r7,lr
800099ea:	16 95       	mov	r5,r11
800099ec:	f6 06 10 5c 	mul	r6,r11,92
800099f0:	ec cb ff f4 	sub	r11,r6,-12
800099f4:	fe b0 e2 7c 	rcall	80005eec <_malloc_r>
800099f8:	18 97       	mov	r7,r12
800099fa:	c0 90       	breq	80009a0c <__sfmoreglue+0x24>
800099fc:	99 15       	st.w	r12[0x4],r5
800099fe:	30 0b       	mov	r11,0
80009a00:	2f 4c       	sub	r12,-12
80009a02:	0c 9a       	mov	r10,r6
80009a04:	8f 2c       	st.w	r7[0x8],r12
80009a06:	8f 0b       	st.w	r7[0x0],r11
80009a08:	fe b0 e5 32 	rcall	8000646c <memset>
80009a0c:	0e 9c       	mov	r12,r7
80009a0e:	d8 22       	popm	r4-r7,pc

80009a10 <__sfp>:
80009a10:	d4 21       	pushm	r4-r7,lr
80009a12:	fe c8 cf d2 	sub	r8,pc,-12334
80009a16:	18 96       	mov	r6,r12
80009a18:	70 07       	ld.w	r7,r8[0x0]
80009a1a:	6e 68       	ld.w	r8,r7[0x18]
80009a1c:	58 08       	cp.w	r8,0
80009a1e:	c0 31       	brne	80009a24 <__sfp+0x14>
80009a20:	0e 9c       	mov	r12,r7
80009a22:	c2 dc       	rcall	80009a7c <__sinit>
80009a24:	ee c7 ff 28 	sub	r7,r7,-216
80009a28:	30 05       	mov	r5,0
80009a2a:	6e 2c       	ld.w	r12,r7[0x8]
80009a2c:	6e 18       	ld.w	r8,r7[0x4]
80009a2e:	c0 68       	rjmp	80009a3a <__sfp+0x2a>
80009a30:	98 69       	ld.sh	r9,r12[0xc]
80009a32:	ea 09 19 00 	cp.h	r9,r5
80009a36:	c1 10       	breq	80009a58 <__sfp+0x48>
80009a38:	2a 4c       	sub	r12,-92
80009a3a:	20 18       	sub	r8,1
80009a3c:	cf a7       	brpl	80009a30 <__sfp+0x20>
80009a3e:	6e 08       	ld.w	r8,r7[0x0]
80009a40:	58 08       	cp.w	r8,0
80009a42:	c0 61       	brne	80009a4e <__sfp+0x3e>
80009a44:	30 4b       	mov	r11,4
80009a46:	0c 9c       	mov	r12,r6
80009a48:	cd 0f       	rcall	800099e8 <__sfmoreglue>
80009a4a:	8f 0c       	st.w	r7[0x0],r12
80009a4c:	c0 30       	breq	80009a52 <__sfp+0x42>
80009a4e:	6e 07       	ld.w	r7,r7[0x0]
80009a50:	ce db       	rjmp	80009a2a <__sfp+0x1a>
80009a52:	30 c8       	mov	r8,12
80009a54:	8d 38       	st.w	r6[0xc],r8
80009a56:	d8 22       	popm	r4-r7,pc
80009a58:	30 08       	mov	r8,0
80009a5a:	f9 48 00 4c 	st.w	r12[76],r8
80009a5e:	99 08       	st.w	r12[0x0],r8
80009a60:	99 28       	st.w	r12[0x8],r8
80009a62:	99 18       	st.w	r12[0x4],r8
80009a64:	99 48       	st.w	r12[0x10],r8
80009a66:	99 58       	st.w	r12[0x14],r8
80009a68:	99 68       	st.w	r12[0x18],r8
80009a6a:	99 d8       	st.w	r12[0x34],r8
80009a6c:	99 e8       	st.w	r12[0x38],r8
80009a6e:	f9 48 00 48 	st.w	r12[72],r8
80009a72:	3f f8       	mov	r8,-1
80009a74:	b8 78       	st.h	r12[0xe],r8
80009a76:	30 18       	mov	r8,1
80009a78:	b8 68       	st.h	r12[0xc],r8
80009a7a:	d8 22       	popm	r4-r7,pc

80009a7c <__sinit>:
80009a7c:	d4 21       	pushm	r4-r7,lr
80009a7e:	18 96       	mov	r6,r12
80009a80:	78 67       	ld.w	r7,r12[0x18]
80009a82:	58 07       	cp.w	r7,0
80009a84:	c4 91       	brne	80009b16 <__sinit+0x9a>
80009a86:	fe c8 00 aa 	sub	r8,pc,170
80009a8a:	30 15       	mov	r5,1
80009a8c:	99 a8       	st.w	r12[0x28],r8
80009a8e:	f9 47 00 d8 	st.w	r12[216],r7
80009a92:	f9 47 00 dc 	st.w	r12[220],r7
80009a96:	f9 47 00 e0 	st.w	r12[224],r7
80009a9a:	99 65       	st.w	r12[0x18],r5
80009a9c:	cb af       	rcall	80009a10 <__sfp>
80009a9e:	8d 0c       	st.w	r6[0x0],r12
80009aa0:	0c 9c       	mov	r12,r6
80009aa2:	cb 7f       	rcall	80009a10 <__sfp>
80009aa4:	8d 1c       	st.w	r6[0x4],r12
80009aa6:	0c 9c       	mov	r12,r6
80009aa8:	cb 4f       	rcall	80009a10 <__sfp>
80009aaa:	6c 09       	ld.w	r9,r6[0x0]
80009aac:	30 48       	mov	r8,4
80009aae:	93 07       	st.w	r9[0x0],r7
80009ab0:	b2 68       	st.h	r9[0xc],r8
80009ab2:	93 17       	st.w	r9[0x4],r7
80009ab4:	93 27       	st.w	r9[0x8],r7
80009ab6:	6c 18       	ld.w	r8,r6[0x4]
80009ab8:	b2 77       	st.h	r9[0xe],r7
80009aba:	93 47       	st.w	r9[0x10],r7
80009abc:	93 57       	st.w	r9[0x14],r7
80009abe:	93 67       	st.w	r9[0x18],r7
80009ac0:	93 89       	st.w	r9[0x20],r9
80009ac2:	91 07       	st.w	r8[0x0],r7
80009ac4:	91 17       	st.w	r8[0x4],r7
80009ac6:	91 27       	st.w	r8[0x8],r7
80009ac8:	fe ce f3 24 	sub	lr,pc,-3292
80009acc:	fe cb f3 54 	sub	r11,pc,-3244
80009ad0:	93 9e       	st.w	r9[0x24],lr
80009ad2:	93 ab       	st.w	r9[0x28],r11
80009ad4:	fe ca f3 7c 	sub	r10,pc,-3204
80009ad8:	fe c4 f3 88 	sub	r4,pc,-3192
80009adc:	93 ba       	st.w	r9[0x2c],r10
80009ade:	93 c4       	st.w	r9[0x30],r4
80009ae0:	30 99       	mov	r9,9
80009ae2:	b0 69       	st.h	r8[0xc],r9
80009ae4:	b0 75       	st.h	r8[0xe],r5
80009ae6:	91 c4       	st.w	r8[0x30],r4
80009ae8:	91 47       	st.w	r8[0x10],r7
80009aea:	91 57       	st.w	r8[0x14],r7
80009aec:	91 67       	st.w	r8[0x18],r7
80009aee:	91 88       	st.w	r8[0x20],r8
80009af0:	91 9e       	st.w	r8[0x24],lr
80009af2:	91 ab       	st.w	r8[0x28],r11
80009af4:	91 ba       	st.w	r8[0x2c],r10
80009af6:	8d 2c       	st.w	r6[0x8],r12
80009af8:	31 28       	mov	r8,18
80009afa:	99 07       	st.w	r12[0x0],r7
80009afc:	b8 68       	st.h	r12[0xc],r8
80009afe:	99 17       	st.w	r12[0x4],r7
80009b00:	99 27       	st.w	r12[0x8],r7
80009b02:	30 28       	mov	r8,2
80009b04:	b8 78       	st.h	r12[0xe],r8
80009b06:	99 c4       	st.w	r12[0x30],r4
80009b08:	99 67       	st.w	r12[0x18],r7
80009b0a:	99 9e       	st.w	r12[0x24],lr
80009b0c:	99 ab       	st.w	r12[0x28],r11
80009b0e:	99 ba       	st.w	r12[0x2c],r10
80009b10:	99 47       	st.w	r12[0x10],r7
80009b12:	99 57       	st.w	r12[0x14],r7
80009b14:	99 8c       	st.w	r12[0x20],r12
80009b16:	d8 22       	popm	r4-r7,pc

80009b18 <_malloc_trim_r>:
80009b18:	d4 21       	pushm	r4-r7,lr
80009b1a:	16 95       	mov	r5,r11
80009b1c:	18 97       	mov	r7,r12
80009b1e:	fe b0 d7 53 	rcall	800049c4 <__malloc_lock>
80009b22:	e0 64 05 38 	mov	r4,1336
80009b26:	68 28       	ld.w	r8,r4[0x8]
80009b28:	70 16       	ld.w	r6,r8[0x4]
80009b2a:	e0 16 ff fc 	andl	r6,0xfffc
80009b2e:	ec c8 ff 91 	sub	r8,r6,-111
80009b32:	f0 05 01 05 	sub	r5,r8,r5
80009b36:	e0 15 ff 80 	andl	r5,0xff80
80009b3a:	ea c5 00 80 	sub	r5,r5,128
80009b3e:	e0 45 00 7f 	cp.w	r5,127
80009b42:	e0 8a 00 25 	brle	80009b8c <_malloc_trim_r+0x74>
80009b46:	30 0b       	mov	r11,0
80009b48:	0e 9c       	mov	r12,r7
80009b4a:	fe b0 e5 f9 	rcall	8000673c <_sbrk_r>
80009b4e:	68 28       	ld.w	r8,r4[0x8]
80009b50:	0c 08       	add	r8,r6
80009b52:	10 3c       	cp.w	r12,r8
80009b54:	c1 c1       	brne	80009b8c <_malloc_trim_r+0x74>
80009b56:	ea 0b 11 00 	rsub	r11,r5,0
80009b5a:	0e 9c       	mov	r12,r7
80009b5c:	fe b0 e5 f0 	rcall	8000673c <_sbrk_r>
80009b60:	5b fc       	cp.w	r12,-1
80009b62:	c1 91       	brne	80009b94 <_malloc_trim_r+0x7c>
80009b64:	30 0b       	mov	r11,0
80009b66:	0e 9c       	mov	r12,r7
80009b68:	fe b0 e5 ea 	rcall	8000673c <_sbrk_r>
80009b6c:	68 28       	ld.w	r8,r4[0x8]
80009b6e:	f8 08 01 09 	sub	r9,r12,r8
80009b72:	58 f9       	cp.w	r9,15
80009b74:	e0 8a 00 0c 	brle	80009b8c <_malloc_trim_r+0x74>
80009b78:	a1 a9       	sbr	r9,0x0
80009b7a:	91 19       	st.w	r8[0x4],r9
80009b7c:	e0 68 09 44 	mov	r8,2372
80009b80:	70 09       	ld.w	r9,r8[0x0]
80009b82:	e0 68 0d 60 	mov	r8,3424
80009b86:	f8 09 01 09 	sub	r9,r12,r9
80009b8a:	91 09       	st.w	r8[0x0],r9
80009b8c:	0e 9c       	mov	r12,r7
80009b8e:	fe b0 d7 21 	rcall	800049d0 <__malloc_unlock>
80009b92:	d8 2a       	popm	r4-r7,pc,r12=0
80009b94:	68 28       	ld.w	r8,r4[0x8]
80009b96:	0a 16       	sub	r6,r5
80009b98:	a1 a6       	sbr	r6,0x0
80009b9a:	91 16       	st.w	r8[0x4],r6
80009b9c:	e0 68 0d 60 	mov	r8,3424
80009ba0:	70 09       	ld.w	r9,r8[0x0]
80009ba2:	0a 19       	sub	r9,r5
80009ba4:	0e 9c       	mov	r12,r7
80009ba6:	91 09       	st.w	r8[0x0],r9
80009ba8:	fe b0 d7 14 	rcall	800049d0 <__malloc_unlock>
80009bac:	da 2a       	popm	r4-r7,pc,r12=1
80009bae:	d7 03       	nop

80009bb0 <_free_r>:
80009bb0:	d4 21       	pushm	r4-r7,lr
80009bb2:	16 96       	mov	r6,r11
80009bb4:	18 97       	mov	r7,r12
80009bb6:	58 0b       	cp.w	r11,0
80009bb8:	e0 80 00 c0 	breq	80009d38 <_free_r+0x188>
80009bbc:	fe b0 d7 04 	rcall	800049c4 <__malloc_lock>
80009bc0:	20 86       	sub	r6,8
80009bc2:	e0 6a 05 38 	mov	r10,1336
80009bc6:	6c 18       	ld.w	r8,r6[0x4]
80009bc8:	74 2e       	ld.w	lr,r10[0x8]
80009bca:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80009bce:	a1 c8       	cbr	r8,0x0
80009bd0:	ec 08 00 09 	add	r9,r6,r8
80009bd4:	72 1b       	ld.w	r11,r9[0x4]
80009bd6:	e0 1b ff fc 	andl	r11,0xfffc
80009bda:	1c 39       	cp.w	r9,lr
80009bdc:	c1 e1       	brne	80009c18 <_free_r+0x68>
80009bde:	f6 08 00 08 	add	r8,r11,r8
80009be2:	58 0c       	cp.w	r12,0
80009be4:	c0 81       	brne	80009bf4 <_free_r+0x44>
80009be6:	6c 09       	ld.w	r9,r6[0x0]
80009be8:	12 16       	sub	r6,r9
80009bea:	12 08       	add	r8,r9
80009bec:	6c 3b       	ld.w	r11,r6[0xc]
80009bee:	6c 29       	ld.w	r9,r6[0x8]
80009bf0:	97 29       	st.w	r11[0x8],r9
80009bf2:	93 3b       	st.w	r9[0xc],r11
80009bf4:	10 99       	mov	r9,r8
80009bf6:	95 26       	st.w	r10[0x8],r6
80009bf8:	a1 a9       	sbr	r9,0x0
80009bfa:	8d 19       	st.w	r6[0x4],r9
80009bfc:	e0 69 09 40 	mov	r9,2368
80009c00:	72 09       	ld.w	r9,r9[0x0]
80009c02:	12 38       	cp.w	r8,r9
80009c04:	c0 63       	brcs	80009c10 <_free_r+0x60>
80009c06:	e0 68 0d 5c 	mov	r8,3420
80009c0a:	0e 9c       	mov	r12,r7
80009c0c:	70 0b       	ld.w	r11,r8[0x0]
80009c0e:	c8 5f       	rcall	80009b18 <_malloc_trim_r>
80009c10:	0e 9c       	mov	r12,r7
80009c12:	fe b0 d6 df 	rcall	800049d0 <__malloc_unlock>
80009c16:	d8 22       	popm	r4-r7,pc
80009c18:	93 1b       	st.w	r9[0x4],r11
80009c1a:	58 0c       	cp.w	r12,0
80009c1c:	c0 30       	breq	80009c22 <_free_r+0x72>
80009c1e:	30 0c       	mov	r12,0
80009c20:	c1 08       	rjmp	80009c40 <_free_r+0x90>
80009c22:	6c 0e       	ld.w	lr,r6[0x0]
80009c24:	f4 c5 ff f8 	sub	r5,r10,-8
80009c28:	1c 16       	sub	r6,lr
80009c2a:	1c 08       	add	r8,lr
80009c2c:	6c 2e       	ld.w	lr,r6[0x8]
80009c2e:	0a 3e       	cp.w	lr,r5
80009c30:	f9 bc 00 01 	moveq	r12,1
80009c34:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80009c38:	eb fe 1a 02 	st.wne	r5[0x8],lr
80009c3c:	fd f5 1a 03 	st.wne	lr[0xc],r5
80009c40:	f2 0b 00 0e 	add	lr,r9,r11
80009c44:	7c 1e       	ld.w	lr,lr[0x4]
80009c46:	ed be 00 00 	bld	lr,0x0
80009c4a:	c1 40       	breq	80009c72 <_free_r+0xc2>
80009c4c:	16 08       	add	r8,r11
80009c4e:	58 0c       	cp.w	r12,0
80009c50:	c0 d1       	brne	80009c6a <_free_r+0xba>
80009c52:	e0 6e 05 38 	mov	lr,1336
80009c56:	72 2b       	ld.w	r11,r9[0x8]
80009c58:	2f 8e       	sub	lr,-8
80009c5a:	1c 3b       	cp.w	r11,lr
80009c5c:	c0 71       	brne	80009c6a <_free_r+0xba>
80009c5e:	97 36       	st.w	r11[0xc],r6
80009c60:	97 26       	st.w	r11[0x8],r6
80009c62:	8d 2b       	st.w	r6[0x8],r11
80009c64:	8d 3b       	st.w	r6[0xc],r11
80009c66:	30 1c       	mov	r12,1
80009c68:	c0 58       	rjmp	80009c72 <_free_r+0xc2>
80009c6a:	72 2b       	ld.w	r11,r9[0x8]
80009c6c:	72 39       	ld.w	r9,r9[0xc]
80009c6e:	93 2b       	st.w	r9[0x8],r11
80009c70:	97 39       	st.w	r11[0xc],r9
80009c72:	10 99       	mov	r9,r8
80009c74:	ec 08 09 08 	st.w	r6[r8],r8
80009c78:	a1 a9       	sbr	r9,0x0
80009c7a:	8d 19       	st.w	r6[0x4],r9
80009c7c:	58 0c       	cp.w	r12,0
80009c7e:	c5 a1       	brne	80009d32 <_free_r+0x182>
80009c80:	e0 48 01 ff 	cp.w	r8,511
80009c84:	e0 8b 00 13 	brhi	80009caa <_free_r+0xfa>
80009c88:	a3 98       	lsr	r8,0x3
80009c8a:	f4 08 00 39 	add	r9,r10,r8<<0x3
80009c8e:	72 2b       	ld.w	r11,r9[0x8]
80009c90:	8d 39       	st.w	r6[0xc],r9
80009c92:	8d 2b       	st.w	r6[0x8],r11
80009c94:	97 36       	st.w	r11[0xc],r6
80009c96:	93 26       	st.w	r9[0x8],r6
80009c98:	a3 48       	asr	r8,0x2
80009c9a:	74 19       	ld.w	r9,r10[0x4]
80009c9c:	30 1b       	mov	r11,1
80009c9e:	f6 08 09 48 	lsl	r8,r11,r8
80009ca2:	f3 e8 10 08 	or	r8,r9,r8
80009ca6:	95 18       	st.w	r10[0x4],r8
80009ca8:	c4 58       	rjmp	80009d32 <_free_r+0x182>
80009caa:	f0 0b 16 09 	lsr	r11,r8,0x9
80009cae:	58 4b       	cp.w	r11,4
80009cb0:	e0 8b 00 06 	brhi	80009cbc <_free_r+0x10c>
80009cb4:	f0 0b 16 06 	lsr	r11,r8,0x6
80009cb8:	2c 8b       	sub	r11,-56
80009cba:	c2 08       	rjmp	80009cfa <_free_r+0x14a>
80009cbc:	59 4b       	cp.w	r11,20
80009cbe:	e0 8b 00 04 	brhi	80009cc6 <_free_r+0x116>
80009cc2:	2a 5b       	sub	r11,-91
80009cc4:	c1 b8       	rjmp	80009cfa <_free_r+0x14a>
80009cc6:	e0 4b 00 54 	cp.w	r11,84
80009cca:	e0 8b 00 06 	brhi	80009cd6 <_free_r+0x126>
80009cce:	f0 0b 16 0c 	lsr	r11,r8,0xc
80009cd2:	29 2b       	sub	r11,-110
80009cd4:	c1 38       	rjmp	80009cfa <_free_r+0x14a>
80009cd6:	e0 4b 01 54 	cp.w	r11,340
80009cda:	e0 8b 00 06 	brhi	80009ce6 <_free_r+0x136>
80009cde:	f0 0b 16 0f 	lsr	r11,r8,0xf
80009ce2:	28 9b       	sub	r11,-119
80009ce4:	c0 b8       	rjmp	80009cfa <_free_r+0x14a>
80009ce6:	e0 4b 05 54 	cp.w	r11,1364
80009cea:	e0 88 00 05 	brls	80009cf4 <_free_r+0x144>
80009cee:	37 eb       	mov	r11,126
80009cf0:	c0 58       	rjmp	80009cfa <_free_r+0x14a>
80009cf2:	d7 03       	nop
80009cf4:	f0 0b 16 12 	lsr	r11,r8,0x12
80009cf8:	28 4b       	sub	r11,-124
80009cfa:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
80009cfe:	78 29       	ld.w	r9,r12[0x8]
80009d00:	18 39       	cp.w	r9,r12
80009d02:	c0 e1       	brne	80009d1e <_free_r+0x16e>
80009d04:	74 18       	ld.w	r8,r10[0x4]
80009d06:	a3 4b       	asr	r11,0x2
80009d08:	30 1c       	mov	r12,1
80009d0a:	f8 0b 09 4b 	lsl	r11,r12,r11
80009d0e:	f1 eb 10 0b 	or	r11,r8,r11
80009d12:	12 98       	mov	r8,r9
80009d14:	95 1b       	st.w	r10[0x4],r11
80009d16:	c0 a8       	rjmp	80009d2a <_free_r+0x17a>
80009d18:	72 29       	ld.w	r9,r9[0x8]
80009d1a:	18 39       	cp.w	r9,r12
80009d1c:	c0 60       	breq	80009d28 <_free_r+0x178>
80009d1e:	72 1a       	ld.w	r10,r9[0x4]
80009d20:	e0 1a ff fc 	andl	r10,0xfffc
80009d24:	14 38       	cp.w	r8,r10
80009d26:	cf 93       	brcs	80009d18 <_free_r+0x168>
80009d28:	72 38       	ld.w	r8,r9[0xc]
80009d2a:	8d 38       	st.w	r6[0xc],r8
80009d2c:	8d 29       	st.w	r6[0x8],r9
80009d2e:	93 36       	st.w	r9[0xc],r6
80009d30:	91 26       	st.w	r8[0x8],r6
80009d32:	0e 9c       	mov	r12,r7
80009d34:	fe b0 d6 4e 	rcall	800049d0 <__malloc_unlock>
80009d38:	d8 22       	popm	r4-r7,pc
80009d3a:	d7 03       	nop

80009d3c <__sfvwrite_r>:
80009d3c:	d4 31       	pushm	r0-r7,lr
80009d3e:	20 3d       	sub	sp,12
80009d40:	14 94       	mov	r4,r10
80009d42:	18 95       	mov	r5,r12
80009d44:	16 97       	mov	r7,r11
80009d46:	74 28       	ld.w	r8,r10[0x8]
80009d48:	58 08       	cp.w	r8,0
80009d4a:	e0 80 01 40 	breq	80009fca <__sfvwrite_r+0x28e>
80009d4e:	96 68       	ld.sh	r8,r11[0xc]
80009d50:	ed b8 00 03 	bld	r8,0x3
80009d54:	c0 41       	brne	80009d5c <__sfvwrite_r+0x20>
80009d56:	76 48       	ld.w	r8,r11[0x10]
80009d58:	58 08       	cp.w	r8,0
80009d5a:	c0 c1       	brne	80009d72 <__sfvwrite_r+0x36>
80009d5c:	0e 9b       	mov	r11,r7
80009d5e:	0a 9c       	mov	r12,r5
80009d60:	fe b0 f6 c4 	rcall	80008ae8 <__swsetup_r>
80009d64:	c0 70       	breq	80009d72 <__sfvwrite_r+0x36>
80009d66:	8e 68       	ld.sh	r8,r7[0xc]
80009d68:	a7 a8       	sbr	r8,0x6
80009d6a:	ae 68       	st.h	r7[0xc],r8
80009d6c:	30 98       	mov	r8,9
80009d6e:	8b 38       	st.w	r5[0xc],r8
80009d70:	c2 b9       	rjmp	80009fc6 <__sfvwrite_r+0x28a>
80009d72:	8e 63       	ld.sh	r3,r7[0xc]
80009d74:	68 00       	ld.w	r0,r4[0x0]
80009d76:	06 96       	mov	r6,r3
80009d78:	e2 16 00 02 	andl	r6,0x2,COH
80009d7c:	c2 10       	breq	80009dbe <__sfvwrite_r+0x82>
80009d7e:	30 03       	mov	r3,0
80009d80:	e0 62 04 00 	mov	r2,1024
80009d84:	06 96       	mov	r6,r3
80009d86:	c0 48       	rjmp	80009d8e <__sfvwrite_r+0x52>
80009d88:	60 03       	ld.w	r3,r0[0x0]
80009d8a:	60 16       	ld.w	r6,r0[0x4]
80009d8c:	2f 80       	sub	r0,-8
80009d8e:	58 06       	cp.w	r6,0
80009d90:	cf c0       	breq	80009d88 <__sfvwrite_r+0x4c>
80009d92:	e0 46 04 00 	cp.w	r6,1024
80009d96:	ec 09 17 80 	movls	r9,r6
80009d9a:	e4 09 17 b0 	movhi	r9,r2
80009d9e:	06 9a       	mov	r10,r3
80009da0:	6e a8       	ld.w	r8,r7[0x28]
80009da2:	6e 8b       	ld.w	r11,r7[0x20]
80009da4:	0a 9c       	mov	r12,r5
80009da6:	5d 18       	icall	r8
80009da8:	18 16       	sub	r6,r12
80009daa:	58 0c       	cp.w	r12,0
80009dac:	e0 8a 01 0a 	brle	80009fc0 <__sfvwrite_r+0x284>
80009db0:	68 28       	ld.w	r8,r4[0x8]
80009db2:	18 18       	sub	r8,r12
80009db4:	89 28       	st.w	r4[0x8],r8
80009db6:	e0 80 01 0a 	breq	80009fca <__sfvwrite_r+0x28e>
80009dba:	18 03       	add	r3,r12
80009dbc:	ce 9b       	rjmp	80009d8e <__sfvwrite_r+0x52>
80009dbe:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
80009dc2:	c0 70       	breq	80009dd0 <__sfvwrite_r+0x94>
80009dc4:	50 06       	stdsp	sp[0x0],r6
80009dc6:	0c 93       	mov	r3,r6
80009dc8:	0c 91       	mov	r1,r6
80009dca:	50 15       	stdsp	sp[0x4],r5
80009dcc:	08 92       	mov	r2,r4
80009dce:	c9 c8       	rjmp	80009f06 <__sfvwrite_r+0x1ca>
80009dd0:	06 96       	mov	r6,r3
80009dd2:	08 91       	mov	r1,r4
80009dd4:	c0 48       	rjmp	80009ddc <__sfvwrite_r+0xa0>
80009dd6:	60 03       	ld.w	r3,r0[0x0]
80009dd8:	60 16       	ld.w	r6,r0[0x4]
80009dda:	2f 80       	sub	r0,-8
80009ddc:	58 06       	cp.w	r6,0
80009dde:	cf c0       	breq	80009dd6 <__sfvwrite_r+0x9a>
80009de0:	8e 68       	ld.sh	r8,r7[0xc]
80009de2:	6e 24       	ld.w	r4,r7[0x8]
80009de4:	10 99       	mov	r9,r8
80009de6:	e2 19 02 00 	andl	r9,0x200,COH
80009dea:	c5 50       	breq	80009e94 <__sfvwrite_r+0x158>
80009dec:	08 36       	cp.w	r6,r4
80009dee:	c4 43       	brcs	80009e76 <__sfvwrite_r+0x13a>
80009df0:	10 99       	mov	r9,r8
80009df2:	e2 19 04 80 	andl	r9,0x480,COH
80009df6:	c4 00       	breq	80009e76 <__sfvwrite_r+0x13a>
80009df8:	6e 4b       	ld.w	r11,r7[0x10]
80009dfa:	6e 09       	ld.w	r9,r7[0x0]
80009dfc:	16 19       	sub	r9,r11
80009dfe:	50 09       	stdsp	sp[0x0],r9
80009e00:	6e 59       	ld.w	r9,r7[0x14]
80009e02:	10 9c       	mov	r12,r8
80009e04:	f2 09 00 1a 	add	r10,r9,r9<<0x1
80009e08:	30 28       	mov	r8,2
80009e0a:	f4 08 0c 08 	divs	r8,r10,r8
80009e0e:	fa e9 00 04 	st.d	sp[4],r8
80009e12:	10 94       	mov	r4,r8
80009e14:	40 09       	lddsp	r9,sp[0x0]
80009e16:	e2 1c 04 00 	andl	r12,0x400,COH
80009e1a:	2f f9       	sub	r9,-1
80009e1c:	0c 09       	add	r9,r6
80009e1e:	12 38       	cp.w	r8,r9
80009e20:	f2 04 17 30 	movlo	r4,r9
80009e24:	58 0c       	cp.w	r12,0
80009e26:	c1 10       	breq	80009e48 <__sfvwrite_r+0x10c>
80009e28:	08 9b       	mov	r11,r4
80009e2a:	0a 9c       	mov	r12,r5
80009e2c:	fe b0 e0 60 	rcall	80005eec <_malloc_r>
80009e30:	18 92       	mov	r2,r12
80009e32:	c1 40       	breq	80009e5a <__sfvwrite_r+0x11e>
80009e34:	40 0a       	lddsp	r10,sp[0x0]
80009e36:	6e 4b       	ld.w	r11,r7[0x10]
80009e38:	fe b0 e2 76 	rcall	80006324 <memcpy>
80009e3c:	8e 68       	ld.sh	r8,r7[0xc]
80009e3e:	e0 18 fb 7f 	andl	r8,0xfb7f
80009e42:	a7 b8       	sbr	r8,0x7
80009e44:	ae 68       	st.h	r7[0xc],r8
80009e46:	c0 d8       	rjmp	80009e60 <__sfvwrite_r+0x124>
80009e48:	08 9a       	mov	r10,r4
80009e4a:	0a 9c       	mov	r12,r5
80009e4c:	fe b0 e3 18 	rcall	8000647c <_realloc_r>
80009e50:	18 92       	mov	r2,r12
80009e52:	c0 71       	brne	80009e60 <__sfvwrite_r+0x124>
80009e54:	6e 4b       	ld.w	r11,r7[0x10]
80009e56:	0a 9c       	mov	r12,r5
80009e58:	ca ce       	rcall	80009bb0 <_free_r>
80009e5a:	30 c8       	mov	r8,12
80009e5c:	8b 38       	st.w	r5[0xc],r8
80009e5e:	cb 18       	rjmp	80009fc0 <__sfvwrite_r+0x284>
80009e60:	40 0a       	lddsp	r10,sp[0x0]
80009e62:	40 09       	lddsp	r9,sp[0x0]
80009e64:	e8 0a 01 0a 	sub	r10,r4,r10
80009e68:	e4 09 00 08 	add	r8,r2,r9
80009e6c:	8f 54       	st.w	r7[0x14],r4
80009e6e:	8f 2a       	st.w	r7[0x8],r10
80009e70:	8f 08       	st.w	r7[0x0],r8
80009e72:	8f 42       	st.w	r7[0x10],r2
80009e74:	0c 94       	mov	r4,r6
80009e76:	08 36       	cp.w	r6,r4
80009e78:	ec 04 17 30 	movlo	r4,r6
80009e7c:	06 9b       	mov	r11,r3
80009e7e:	08 9a       	mov	r10,r4
80009e80:	6e 0c       	ld.w	r12,r7[0x0]
80009e82:	c3 ad       	rcall	8000a0f6 <memmove>
80009e84:	6e 08       	ld.w	r8,r7[0x0]
80009e86:	08 08       	add	r8,r4
80009e88:	8f 08       	st.w	r7[0x0],r8
80009e8a:	6e 28       	ld.w	r8,r7[0x8]
80009e8c:	08 18       	sub	r8,r4
80009e8e:	0c 94       	mov	r4,r6
80009e90:	8f 28       	st.w	r7[0x8],r8
80009e92:	c2 e8       	rjmp	80009eee <__sfvwrite_r+0x1b2>
80009e94:	08 36       	cp.w	r6,r4
80009e96:	5f ba       	srhi	r10
80009e98:	6e 0c       	ld.w	r12,r7[0x0]
80009e9a:	6e 48       	ld.w	r8,r7[0x10]
80009e9c:	10 3c       	cp.w	r12,r8
80009e9e:	5f b8       	srhi	r8
80009ea0:	f5 e8 00 08 	and	r8,r10,r8
80009ea4:	f2 08 18 00 	cp.b	r8,r9
80009ea8:	c0 d0       	breq	80009ec2 <__sfvwrite_r+0x186>
80009eaa:	06 9b       	mov	r11,r3
80009eac:	08 9a       	mov	r10,r4
80009eae:	c2 4d       	rcall	8000a0f6 <memmove>
80009eb0:	6e 08       	ld.w	r8,r7[0x0]
80009eb2:	08 08       	add	r8,r4
80009eb4:	0e 9b       	mov	r11,r7
80009eb6:	8f 08       	st.w	r7[0x0],r8
80009eb8:	0a 9c       	mov	r12,r5
80009eba:	fe b0 fd 09 	rcall	800098cc <_fflush_r>
80009ebe:	c1 80       	breq	80009eee <__sfvwrite_r+0x1b2>
80009ec0:	c8 08       	rjmp	80009fc0 <__sfvwrite_r+0x284>
80009ec2:	6e 59       	ld.w	r9,r7[0x14]
80009ec4:	12 36       	cp.w	r6,r9
80009ec6:	c0 a3       	brcs	80009eda <__sfvwrite_r+0x19e>
80009ec8:	6e a8       	ld.w	r8,r7[0x28]
80009eca:	06 9a       	mov	r10,r3
80009ecc:	6e 8b       	ld.w	r11,r7[0x20]
80009ece:	0a 9c       	mov	r12,r5
80009ed0:	5d 18       	icall	r8
80009ed2:	18 94       	mov	r4,r12
80009ed4:	e0 89 00 0d 	brgt	80009eee <__sfvwrite_r+0x1b2>
80009ed8:	c7 48       	rjmp	80009fc0 <__sfvwrite_r+0x284>
80009eda:	0c 9a       	mov	r10,r6
80009edc:	06 9b       	mov	r11,r3
80009ede:	c0 cd       	rcall	8000a0f6 <memmove>
80009ee0:	6e 08       	ld.w	r8,r7[0x0]
80009ee2:	0c 08       	add	r8,r6
80009ee4:	0c 94       	mov	r4,r6
80009ee6:	8f 08       	st.w	r7[0x0],r8
80009ee8:	6e 28       	ld.w	r8,r7[0x8]
80009eea:	0c 18       	sub	r8,r6
80009eec:	8f 28       	st.w	r7[0x8],r8
80009eee:	62 28       	ld.w	r8,r1[0x8]
80009ef0:	08 18       	sub	r8,r4
80009ef2:	83 28       	st.w	r1[0x8],r8
80009ef4:	c6 b0       	breq	80009fca <__sfvwrite_r+0x28e>
80009ef6:	08 16       	sub	r6,r4
80009ef8:	08 03       	add	r3,r4
80009efa:	c7 1b       	rjmp	80009ddc <__sfvwrite_r+0xa0>
80009efc:	60 03       	ld.w	r3,r0[0x0]
80009efe:	60 11       	ld.w	r1,r0[0x4]
80009f00:	30 08       	mov	r8,0
80009f02:	2f 80       	sub	r0,-8
80009f04:	50 08       	stdsp	sp[0x0],r8
80009f06:	58 01       	cp.w	r1,0
80009f08:	cf a0       	breq	80009efc <__sfvwrite_r+0x1c0>
80009f0a:	40 0a       	lddsp	r10,sp[0x0]
80009f0c:	58 0a       	cp.w	r10,0
80009f0e:	c1 41       	brne	80009f36 <__sfvwrite_r+0x1fa>
80009f10:	e2 c6 ff ff 	sub	r6,r1,-1
80009f14:	02 9a       	mov	r10,r1
80009f16:	30 ab       	mov	r11,10
80009f18:	06 9c       	mov	r12,r3
80009f1a:	ce 3c       	rcall	8000a0e0 <memchr>
80009f1c:	f8 c8 ff ff 	sub	r8,r12,-1
80009f20:	58 0c       	cp.w	r12,0
80009f22:	f1 d3 e1 16 	subne	r6,r8,r3
80009f26:	f9 b9 01 01 	movne	r9,1
80009f2a:	fb f9 1a 00 	st.wne	sp[0x0],r9
80009f2e:	f9 b8 00 01 	moveq	r8,1
80009f32:	fb f8 0a 00 	st.weq	sp[0x0],r8
80009f36:	02 36       	cp.w	r6,r1
80009f38:	ec 04 17 80 	movls	r4,r6
80009f3c:	e2 04 17 b0 	movhi	r4,r1
80009f40:	6e 59       	ld.w	r9,r7[0x14]
80009f42:	6e 25       	ld.w	r5,r7[0x8]
80009f44:	f2 05 00 05 	add	r5,r9,r5
80009f48:	0a 34       	cp.w	r4,r5
80009f4a:	5f 9a       	srgt	r10
80009f4c:	6e 0c       	ld.w	r12,r7[0x0]
80009f4e:	6e 48       	ld.w	r8,r7[0x10]
80009f50:	10 3c       	cp.w	r12,r8
80009f52:	5f b8       	srhi	r8
80009f54:	f5 e8 00 08 	and	r8,r10,r8
80009f58:	30 0a       	mov	r10,0
80009f5a:	f4 08 18 00 	cp.b	r8,r10
80009f5e:	c0 d0       	breq	80009f78 <__sfvwrite_r+0x23c>
80009f60:	06 9b       	mov	r11,r3
80009f62:	0a 9a       	mov	r10,r5
80009f64:	cc 9c       	rcall	8000a0f6 <memmove>
80009f66:	6e 08       	ld.w	r8,r7[0x0]
80009f68:	0a 08       	add	r8,r5
80009f6a:	0e 9b       	mov	r11,r7
80009f6c:	8f 08       	st.w	r7[0x0],r8
80009f6e:	40 1c       	lddsp	r12,sp[0x4]
80009f70:	fe b0 fc ae 	rcall	800098cc <_fflush_r>
80009f74:	c1 70       	breq	80009fa2 <__sfvwrite_r+0x266>
80009f76:	c2 58       	rjmp	80009fc0 <__sfvwrite_r+0x284>
80009f78:	12 34       	cp.w	r4,r9
80009f7a:	c0 a5       	brlt	80009f8e <__sfvwrite_r+0x252>
80009f7c:	6e a8       	ld.w	r8,r7[0x28]
80009f7e:	06 9a       	mov	r10,r3
80009f80:	6e 8b       	ld.w	r11,r7[0x20]
80009f82:	40 1c       	lddsp	r12,sp[0x4]
80009f84:	5d 18       	icall	r8
80009f86:	18 95       	mov	r5,r12
80009f88:	e0 89 00 0d 	brgt	80009fa2 <__sfvwrite_r+0x266>
80009f8c:	c1 a8       	rjmp	80009fc0 <__sfvwrite_r+0x284>
80009f8e:	08 9a       	mov	r10,r4
80009f90:	06 9b       	mov	r11,r3
80009f92:	cb 2c       	rcall	8000a0f6 <memmove>
80009f94:	6e 08       	ld.w	r8,r7[0x0]
80009f96:	08 08       	add	r8,r4
80009f98:	08 95       	mov	r5,r4
80009f9a:	8f 08       	st.w	r7[0x0],r8
80009f9c:	6e 28       	ld.w	r8,r7[0x8]
80009f9e:	08 18       	sub	r8,r4
80009fa0:	8f 28       	st.w	r7[0x8],r8
80009fa2:	0a 16       	sub	r6,r5
80009fa4:	c0 71       	brne	80009fb2 <__sfvwrite_r+0x276>
80009fa6:	0e 9b       	mov	r11,r7
80009fa8:	40 1c       	lddsp	r12,sp[0x4]
80009faa:	fe b0 fc 91 	rcall	800098cc <_fflush_r>
80009fae:	c0 91       	brne	80009fc0 <__sfvwrite_r+0x284>
80009fb0:	50 06       	stdsp	sp[0x0],r6
80009fb2:	64 28       	ld.w	r8,r2[0x8]
80009fb4:	0a 18       	sub	r8,r5
80009fb6:	85 28       	st.w	r2[0x8],r8
80009fb8:	c0 90       	breq	80009fca <__sfvwrite_r+0x28e>
80009fba:	0a 11       	sub	r1,r5
80009fbc:	0a 03       	add	r3,r5
80009fbe:	ca 4b       	rjmp	80009f06 <__sfvwrite_r+0x1ca>
80009fc0:	8e 68       	ld.sh	r8,r7[0xc]
80009fc2:	a7 a8       	sbr	r8,0x6
80009fc4:	ae 68       	st.h	r7[0xc],r8
80009fc6:	3f fc       	mov	r12,-1
80009fc8:	c0 28       	rjmp	80009fcc <__sfvwrite_r+0x290>
80009fca:	30 0c       	mov	r12,0
80009fcc:	2f dd       	sub	sp,-12
80009fce:	d8 32       	popm	r0-r7,pc

80009fd0 <_fwalk>:
80009fd0:	d4 31       	pushm	r0-r7,lr
80009fd2:	30 05       	mov	r5,0
80009fd4:	16 91       	mov	r1,r11
80009fd6:	f8 c7 ff 28 	sub	r7,r12,-216
80009fda:	0a 92       	mov	r2,r5
80009fdc:	fe b0 fc fe 	rcall	800099d8 <__sfp_lock_acquire>
80009fe0:	3f f3       	mov	r3,-1
80009fe2:	c1 68       	rjmp	8000a00e <_fwalk+0x3e>
80009fe4:	6e 26       	ld.w	r6,r7[0x8]
80009fe6:	6e 14       	ld.w	r4,r7[0x4]
80009fe8:	2f 46       	sub	r6,-12
80009fea:	c0 c8       	rjmp	8000a002 <_fwalk+0x32>
80009fec:	8c 08       	ld.sh	r8,r6[0x0]
80009fee:	e4 08 19 00 	cp.h	r8,r2
80009ff2:	c0 70       	breq	8000a000 <_fwalk+0x30>
80009ff4:	8c 18       	ld.sh	r8,r6[0x2]
80009ff6:	e6 08 19 00 	cp.h	r8,r3
80009ffa:	c0 30       	breq	8000a000 <_fwalk+0x30>
80009ffc:	5d 11       	icall	r1
80009ffe:	18 45       	or	r5,r12
8000a000:	2a 46       	sub	r6,-92
8000a002:	20 14       	sub	r4,1
8000a004:	ec cc 00 0c 	sub	r12,r6,12
8000a008:	58 04       	cp.w	r4,0
8000a00a:	cf 14       	brge	80009fec <_fwalk+0x1c>
8000a00c:	6e 07       	ld.w	r7,r7[0x0]
8000a00e:	58 07       	cp.w	r7,0
8000a010:	ce a1       	brne	80009fe4 <_fwalk+0x14>
8000a012:	fe b0 fc e4 	rcall	800099da <__sfp_lock_release>
8000a016:	0a 9c       	mov	r12,r5
8000a018:	d8 32       	popm	r0-r7,pc
8000a01a:	d7 03       	nop

8000a01c <_localeconv_r>:
8000a01c:	fe cc d5 d8 	sub	r12,pc,-10792
8000a020:	5e fc       	retal	r12
8000a022:	d7 03       	nop

8000a024 <__smakebuf_r>:
8000a024:	d4 21       	pushm	r4-r7,lr
8000a026:	20 fd       	sub	sp,60
8000a028:	96 68       	ld.sh	r8,r11[0xc]
8000a02a:	16 97       	mov	r7,r11
8000a02c:	18 96       	mov	r6,r12
8000a02e:	e2 18 00 02 	andl	r8,0x2,COH
8000a032:	c3 d1       	brne	8000a0ac <__smakebuf_r+0x88>
8000a034:	96 7b       	ld.sh	r11,r11[0xe]
8000a036:	f0 0b 19 00 	cp.h	r11,r8
8000a03a:	c0 55       	brlt	8000a044 <__smakebuf_r+0x20>
8000a03c:	1a 9a       	mov	r10,sp
8000a03e:	e0 a0 04 75 	rcall	8000a928 <_fstat_r>
8000a042:	c0 f4       	brge	8000a060 <__smakebuf_r+0x3c>
8000a044:	8e 65       	ld.sh	r5,r7[0xc]
8000a046:	0a 98       	mov	r8,r5
8000a048:	ab b8       	sbr	r8,0xb
8000a04a:	e2 15 00 80 	andl	r5,0x80,COH
8000a04e:	ae 68       	st.h	r7[0xc],r8
8000a050:	30 04       	mov	r4,0
8000a052:	e0 68 04 00 	mov	r8,1024
8000a056:	f9 b5 01 40 	movne	r5,64
8000a05a:	f0 05 17 00 	moveq	r5,r8
8000a05e:	c1 c8       	rjmp	8000a096 <__smakebuf_r+0x72>
8000a060:	40 18       	lddsp	r8,sp[0x4]
8000a062:	e2 18 f0 00 	andl	r8,0xf000,COH
8000a066:	e0 48 20 00 	cp.w	r8,8192
8000a06a:	5f 04       	sreq	r4
8000a06c:	e0 48 80 00 	cp.w	r8,32768
8000a070:	c0 e1       	brne	8000a08c <__smakebuf_r+0x68>
8000a072:	6e b9       	ld.w	r9,r7[0x2c]
8000a074:	fe c8 f9 1c 	sub	r8,pc,-1764
8000a078:	10 39       	cp.w	r9,r8
8000a07a:	c0 91       	brne	8000a08c <__smakebuf_r+0x68>
8000a07c:	8e 68       	ld.sh	r8,r7[0xc]
8000a07e:	e0 65 04 00 	mov	r5,1024
8000a082:	ab a8       	sbr	r8,0xa
8000a084:	ef 45 00 50 	st.w	r7[80],r5
8000a088:	ae 68       	st.h	r7[0xc],r8
8000a08a:	c0 68       	rjmp	8000a096 <__smakebuf_r+0x72>
8000a08c:	8e 68       	ld.sh	r8,r7[0xc]
8000a08e:	e0 65 04 00 	mov	r5,1024
8000a092:	ab b8       	sbr	r8,0xb
8000a094:	ae 68       	st.h	r7[0xc],r8
8000a096:	0a 9b       	mov	r11,r5
8000a098:	0c 9c       	mov	r12,r6
8000a09a:	fe b0 df 29 	rcall	80005eec <_malloc_r>
8000a09e:	8e 68       	ld.sh	r8,r7[0xc]
8000a0a0:	c0 d1       	brne	8000a0ba <__smakebuf_r+0x96>
8000a0a2:	ed b8 00 09 	bld	r8,0x9
8000a0a6:	c1 b0       	breq	8000a0dc <__smakebuf_r+0xb8>
8000a0a8:	a1 b8       	sbr	r8,0x1
8000a0aa:	ae 68       	st.h	r7[0xc],r8
8000a0ac:	ee c8 ff b9 	sub	r8,r7,-71
8000a0b0:	8f 48       	st.w	r7[0x10],r8
8000a0b2:	8f 08       	st.w	r7[0x0],r8
8000a0b4:	30 18       	mov	r8,1
8000a0b6:	8f 58       	st.w	r7[0x14],r8
8000a0b8:	c1 28       	rjmp	8000a0dc <__smakebuf_r+0xb8>
8000a0ba:	a7 b8       	sbr	r8,0x7
8000a0bc:	8f 4c       	st.w	r7[0x10],r12
8000a0be:	ae 68       	st.h	r7[0xc],r8
8000a0c0:	8f 55       	st.w	r7[0x14],r5
8000a0c2:	fe c8 06 e6 	sub	r8,pc,1766
8000a0c6:	8f 0c       	st.w	r7[0x0],r12
8000a0c8:	8d a8       	st.w	r6[0x28],r8
8000a0ca:	58 04       	cp.w	r4,0
8000a0cc:	c0 80       	breq	8000a0dc <__smakebuf_r+0xb8>
8000a0ce:	8e 7c       	ld.sh	r12,r7[0xe]
8000a0d0:	fe b0 e3 94 	rcall	800067f8 <isatty>
8000a0d4:	c0 40       	breq	8000a0dc <__smakebuf_r+0xb8>
8000a0d6:	8e 68       	ld.sh	r8,r7[0xc]
8000a0d8:	a1 a8       	sbr	r8,0x0
8000a0da:	ae 68       	st.h	r7[0xc],r8
8000a0dc:	2f 1d       	sub	sp,-60
8000a0de:	d8 22       	popm	r4-r7,pc

8000a0e0 <memchr>:
8000a0e0:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000a0e4:	c0 68       	rjmp	8000a0f0 <memchr+0x10>
8000a0e6:	20 1a       	sub	r10,1
8000a0e8:	19 88       	ld.ub	r8,r12[0x0]
8000a0ea:	16 38       	cp.w	r8,r11
8000a0ec:	5e 0c       	reteq	r12
8000a0ee:	2f fc       	sub	r12,-1
8000a0f0:	58 0a       	cp.w	r10,0
8000a0f2:	cf a1       	brne	8000a0e6 <memchr+0x6>
8000a0f4:	5e fa       	retal	r10

8000a0f6 <memmove>:
8000a0f6:	d4 01       	pushm	lr
8000a0f8:	18 3b       	cp.w	r11,r12
8000a0fa:	c1 92       	brcc	8000a12c <memmove+0x36>
8000a0fc:	f6 0a 00 09 	add	r9,r11,r10
8000a100:	12 3c       	cp.w	r12,r9
8000a102:	c1 52       	brcc	8000a12c <memmove+0x36>
8000a104:	f8 0a 00 0b 	add	r11,r12,r10
8000a108:	30 08       	mov	r8,0
8000a10a:	c0 68       	rjmp	8000a116 <memmove+0x20>
8000a10c:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000a110:	20 1a       	sub	r10,1
8000a112:	f6 08 0b 0e 	st.b	r11[r8],lr
8000a116:	20 18       	sub	r8,1
8000a118:	58 0a       	cp.w	r10,0
8000a11a:	cf 91       	brne	8000a10c <memmove+0x16>
8000a11c:	d8 02       	popm	pc
8000a11e:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a122:	20 1a       	sub	r10,1
8000a124:	f8 08 0b 09 	st.b	r12[r8],r9
8000a128:	2f f8       	sub	r8,-1
8000a12a:	c0 28       	rjmp	8000a12e <memmove+0x38>
8000a12c:	30 08       	mov	r8,0
8000a12e:	58 0a       	cp.w	r10,0
8000a130:	cf 71       	brne	8000a11e <memmove+0x28>
8000a132:	d8 02       	popm	pc

8000a134 <__hi0bits>:
8000a134:	18 98       	mov	r8,r12
8000a136:	e0 1c 00 00 	andl	r12,0x0
8000a13a:	f0 09 15 10 	lsl	r9,r8,0x10
8000a13e:	58 0c       	cp.w	r12,0
8000a140:	f2 08 17 00 	moveq	r8,r9
8000a144:	f9 bc 00 10 	moveq	r12,16
8000a148:	f9 bc 01 00 	movne	r12,0
8000a14c:	10 9a       	mov	r10,r8
8000a14e:	f0 09 15 08 	lsl	r9,r8,0x8
8000a152:	e6 1a ff 00 	andh	r10,0xff00,COH
8000a156:	f7 bc 00 f8 	subeq	r12,-8
8000a15a:	f2 08 17 00 	moveq	r8,r9
8000a15e:	10 9a       	mov	r10,r8
8000a160:	f0 09 15 04 	lsl	r9,r8,0x4
8000a164:	e6 1a f0 00 	andh	r10,0xf000,COH
8000a168:	f7 bc 00 fc 	subeq	r12,-4
8000a16c:	f2 08 17 00 	moveq	r8,r9
8000a170:	10 9a       	mov	r10,r8
8000a172:	f0 09 15 02 	lsl	r9,r8,0x2
8000a176:	e6 1a c0 00 	andh	r10,0xc000,COH
8000a17a:	f7 bc 00 fe 	subeq	r12,-2
8000a17e:	f2 08 17 00 	moveq	r8,r9
8000a182:	58 08       	cp.w	r8,0
8000a184:	5e 5c       	retlt	r12
8000a186:	ed b8 00 1e 	bld	r8,0x1e
8000a18a:	f9 bc 01 20 	movne	r12,32
8000a18e:	f7 bc 00 ff 	subeq	r12,-1
8000a192:	5e fc       	retal	r12

8000a194 <__lo0bits>:
8000a194:	18 99       	mov	r9,r12
8000a196:	78 08       	ld.w	r8,r12[0x0]
8000a198:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000a19c:	c1 50       	breq	8000a1c6 <__lo0bits+0x32>
8000a19e:	ed b8 00 00 	bld	r8,0x0
8000a1a2:	c0 21       	brne	8000a1a6 <__lo0bits+0x12>
8000a1a4:	5e fd       	retal	0
8000a1a6:	10 9b       	mov	r11,r8
8000a1a8:	f0 0a 16 01 	lsr	r10,r8,0x1
8000a1ac:	e2 1b 00 02 	andl	r11,0x2,COH
8000a1b0:	a3 88       	lsr	r8,0x2
8000a1b2:	58 0b       	cp.w	r11,0
8000a1b4:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000a1b8:	f9 bc 01 01 	movne	r12,1
8000a1bc:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000a1c0:	f9 bc 00 02 	moveq	r12,2
8000a1c4:	5e fc       	retal	r12
8000a1c6:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000a1ca:	f0 0b 16 10 	lsr	r11,r8,0x10
8000a1ce:	58 0a       	cp.w	r10,0
8000a1d0:	f6 08 17 00 	moveq	r8,r11
8000a1d4:	f9 bc 00 10 	moveq	r12,16
8000a1d8:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000a1dc:	f0 0a 16 08 	lsr	r10,r8,0x8
8000a1e0:	58 0b       	cp.w	r11,0
8000a1e2:	f7 bc 00 f8 	subeq	r12,-8
8000a1e6:	f4 08 17 00 	moveq	r8,r10
8000a1ea:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000a1ee:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a1f2:	58 0b       	cp.w	r11,0
8000a1f4:	f7 bc 00 fc 	subeq	r12,-4
8000a1f8:	f4 08 17 00 	moveq	r8,r10
8000a1fc:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000a200:	f0 0a 16 02 	lsr	r10,r8,0x2
8000a204:	58 0b       	cp.w	r11,0
8000a206:	f7 bc 00 fe 	subeq	r12,-2
8000a20a:	f4 08 17 00 	moveq	r8,r10
8000a20e:	ed b8 00 00 	bld	r8,0x0
8000a212:	c0 60       	breq	8000a21e <__lo0bits+0x8a>
8000a214:	a1 98       	lsr	r8,0x1
8000a216:	c0 31       	brne	8000a21c <__lo0bits+0x88>
8000a218:	32 0c       	mov	r12,32
8000a21a:	5e fc       	retal	r12
8000a21c:	2f fc       	sub	r12,-1
8000a21e:	93 08       	st.w	r9[0x0],r8
8000a220:	5e fc       	retal	r12

8000a222 <__mcmp>:
8000a222:	d4 01       	pushm	lr
8000a224:	18 98       	mov	r8,r12
8000a226:	76 49       	ld.w	r9,r11[0x10]
8000a228:	78 4c       	ld.w	r12,r12[0x10]
8000a22a:	12 1c       	sub	r12,r9
8000a22c:	c1 31       	brne	8000a252 <__mcmp+0x30>
8000a22e:	2f b9       	sub	r9,-5
8000a230:	a3 69       	lsl	r9,0x2
8000a232:	12 0b       	add	r11,r9
8000a234:	f0 09 00 09 	add	r9,r8,r9
8000a238:	2e c8       	sub	r8,-20
8000a23a:	13 4e       	ld.w	lr,--r9
8000a23c:	17 4a       	ld.w	r10,--r11
8000a23e:	14 3e       	cp.w	lr,r10
8000a240:	c0 60       	breq	8000a24c <__mcmp+0x2a>
8000a242:	f9 bc 03 ff 	movlo	r12,-1
8000a246:	f9 bc 02 01 	movhs	r12,1
8000a24a:	d8 02       	popm	pc
8000a24c:	10 39       	cp.w	r9,r8
8000a24e:	fe 9b ff f6 	brhi	8000a23a <__mcmp+0x18>
8000a252:	d8 02       	popm	pc

8000a254 <_Bfree>:
8000a254:	d4 21       	pushm	r4-r7,lr
8000a256:	18 97       	mov	r7,r12
8000a258:	16 95       	mov	r5,r11
8000a25a:	78 96       	ld.w	r6,r12[0x24]
8000a25c:	58 06       	cp.w	r6,0
8000a25e:	c0 91       	brne	8000a270 <_Bfree+0x1c>
8000a260:	31 0c       	mov	r12,16
8000a262:	fe b0 de 3d 	rcall	80005edc <malloc>
8000a266:	99 36       	st.w	r12[0xc],r6
8000a268:	8f 9c       	st.w	r7[0x24],r12
8000a26a:	99 16       	st.w	r12[0x4],r6
8000a26c:	99 26       	st.w	r12[0x8],r6
8000a26e:	99 06       	st.w	r12[0x0],r6
8000a270:	58 05       	cp.w	r5,0
8000a272:	c0 90       	breq	8000a284 <_Bfree+0x30>
8000a274:	6a 19       	ld.w	r9,r5[0x4]
8000a276:	6e 98       	ld.w	r8,r7[0x24]
8000a278:	70 38       	ld.w	r8,r8[0xc]
8000a27a:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000a27e:	8b 0a       	st.w	r5[0x0],r10
8000a280:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000a284:	d8 22       	popm	r4-r7,pc
8000a286:	d7 03       	nop

8000a288 <_Balloc>:
8000a288:	d4 21       	pushm	r4-r7,lr
8000a28a:	18 97       	mov	r7,r12
8000a28c:	16 96       	mov	r6,r11
8000a28e:	78 95       	ld.w	r5,r12[0x24]
8000a290:	58 05       	cp.w	r5,0
8000a292:	c0 91       	brne	8000a2a4 <_Balloc+0x1c>
8000a294:	31 0c       	mov	r12,16
8000a296:	fe b0 de 23 	rcall	80005edc <malloc>
8000a29a:	99 35       	st.w	r12[0xc],r5
8000a29c:	8f 9c       	st.w	r7[0x24],r12
8000a29e:	99 15       	st.w	r12[0x4],r5
8000a2a0:	99 25       	st.w	r12[0x8],r5
8000a2a2:	99 05       	st.w	r12[0x0],r5
8000a2a4:	6e 95       	ld.w	r5,r7[0x24]
8000a2a6:	6a 38       	ld.w	r8,r5[0xc]
8000a2a8:	58 08       	cp.w	r8,0
8000a2aa:	c0 b1       	brne	8000a2c0 <_Balloc+0x38>
8000a2ac:	31 0a       	mov	r10,16
8000a2ae:	30 4b       	mov	r11,4
8000a2b0:	0e 9c       	mov	r12,r7
8000a2b2:	e0 a0 02 9b 	rcall	8000a7e8 <_calloc_r>
8000a2b6:	8b 3c       	st.w	r5[0xc],r12
8000a2b8:	6e 98       	ld.w	r8,r7[0x24]
8000a2ba:	70 3c       	ld.w	r12,r8[0xc]
8000a2bc:	58 0c       	cp.w	r12,0
8000a2be:	c1 b0       	breq	8000a2f4 <_Balloc+0x6c>
8000a2c0:	6e 98       	ld.w	r8,r7[0x24]
8000a2c2:	70 38       	ld.w	r8,r8[0xc]
8000a2c4:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000a2c8:	70 0c       	ld.w	r12,r8[0x0]
8000a2ca:	58 0c       	cp.w	r12,0
8000a2cc:	c0 40       	breq	8000a2d4 <_Balloc+0x4c>
8000a2ce:	78 09       	ld.w	r9,r12[0x0]
8000a2d0:	91 09       	st.w	r8[0x0],r9
8000a2d2:	c0 e8       	rjmp	8000a2ee <_Balloc+0x66>
8000a2d4:	0e 9c       	mov	r12,r7
8000a2d6:	30 17       	mov	r7,1
8000a2d8:	0e 9b       	mov	r11,r7
8000a2da:	ee 06 09 47 	lsl	r7,r7,r6
8000a2de:	ee ca ff fb 	sub	r10,r7,-5
8000a2e2:	a3 6a       	lsl	r10,0x2
8000a2e4:	e0 a0 02 82 	rcall	8000a7e8 <_calloc_r>
8000a2e8:	c0 60       	breq	8000a2f4 <_Balloc+0x6c>
8000a2ea:	99 16       	st.w	r12[0x4],r6
8000a2ec:	99 27       	st.w	r12[0x8],r7
8000a2ee:	30 08       	mov	r8,0
8000a2f0:	99 38       	st.w	r12[0xc],r8
8000a2f2:	99 48       	st.w	r12[0x10],r8
8000a2f4:	d8 22       	popm	r4-r7,pc
8000a2f6:	d7 03       	nop

8000a2f8 <__d2b>:
8000a2f8:	d4 31       	pushm	r0-r7,lr
8000a2fa:	20 2d       	sub	sp,8
8000a2fc:	16 93       	mov	r3,r11
8000a2fe:	12 96       	mov	r6,r9
8000a300:	10 95       	mov	r5,r8
8000a302:	14 92       	mov	r2,r10
8000a304:	30 1b       	mov	r11,1
8000a306:	cc 1f       	rcall	8000a288 <_Balloc>
8000a308:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000a30c:	50 09       	stdsp	sp[0x0],r9
8000a30e:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000a312:	b5 a9       	sbr	r9,0x14
8000a314:	f0 01 16 14 	lsr	r1,r8,0x14
8000a318:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a31c:	18 94       	mov	r4,r12
8000a31e:	58 02       	cp.w	r2,0
8000a320:	c1 d0       	breq	8000a35a <__d2b+0x62>
8000a322:	fa cc ff f8 	sub	r12,sp,-8
8000a326:	18 d2       	st.w	--r12,r2
8000a328:	c3 6f       	rcall	8000a194 <__lo0bits>
8000a32a:	40 18       	lddsp	r8,sp[0x4]
8000a32c:	c0 d0       	breq	8000a346 <__d2b+0x4e>
8000a32e:	40 09       	lddsp	r9,sp[0x0]
8000a330:	f8 0a 11 20 	rsub	r10,r12,32
8000a334:	f2 0a 09 4a 	lsl	r10,r9,r10
8000a338:	f5 e8 10 08 	or	r8,r10,r8
8000a33c:	89 58       	st.w	r4[0x14],r8
8000a33e:	f2 0c 0a 49 	lsr	r9,r9,r12
8000a342:	50 09       	stdsp	sp[0x0],r9
8000a344:	c0 28       	rjmp	8000a348 <__d2b+0x50>
8000a346:	89 58       	st.w	r4[0x14],r8
8000a348:	40 08       	lddsp	r8,sp[0x0]
8000a34a:	58 08       	cp.w	r8,0
8000a34c:	f9 b3 01 02 	movne	r3,2
8000a350:	f9 b3 00 01 	moveq	r3,1
8000a354:	89 68       	st.w	r4[0x18],r8
8000a356:	89 43       	st.w	r4[0x10],r3
8000a358:	c0 88       	rjmp	8000a368 <__d2b+0x70>
8000a35a:	1a 9c       	mov	r12,sp
8000a35c:	c1 cf       	rcall	8000a194 <__lo0bits>
8000a35e:	30 13       	mov	r3,1
8000a360:	40 08       	lddsp	r8,sp[0x0]
8000a362:	2e 0c       	sub	r12,-32
8000a364:	89 43       	st.w	r4[0x10],r3
8000a366:	89 58       	st.w	r4[0x14],r8
8000a368:	58 01       	cp.w	r1,0
8000a36a:	c0 90       	breq	8000a37c <__d2b+0x84>
8000a36c:	e2 c1 04 33 	sub	r1,r1,1075
8000a370:	18 01       	add	r1,r12
8000a372:	8d 01       	st.w	r6[0x0],r1
8000a374:	f8 0c 11 35 	rsub	r12,r12,53
8000a378:	8b 0c       	st.w	r5[0x0],r12
8000a37a:	c0 c8       	rjmp	8000a392 <__d2b+0x9a>
8000a37c:	e6 c8 ff fc 	sub	r8,r3,-4
8000a380:	f8 cc 04 32 	sub	r12,r12,1074
8000a384:	a5 73       	lsl	r3,0x5
8000a386:	8d 0c       	st.w	r6[0x0],r12
8000a388:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000a38c:	cd 4e       	rcall	8000a134 <__hi0bits>
8000a38e:	18 13       	sub	r3,r12
8000a390:	8b 03       	st.w	r5[0x0],r3
8000a392:	08 9c       	mov	r12,r4
8000a394:	2f ed       	sub	sp,-8
8000a396:	d8 32       	popm	r0-r7,pc

8000a398 <__mdiff>:
8000a398:	d4 31       	pushm	r0-r7,lr
8000a39a:	74 48       	ld.w	r8,r10[0x10]
8000a39c:	76 45       	ld.w	r5,r11[0x10]
8000a39e:	16 97       	mov	r7,r11
8000a3a0:	14 96       	mov	r6,r10
8000a3a2:	10 15       	sub	r5,r8
8000a3a4:	c1 31       	brne	8000a3ca <__mdiff+0x32>
8000a3a6:	2f b8       	sub	r8,-5
8000a3a8:	ee ce ff ec 	sub	lr,r7,-20
8000a3ac:	a3 68       	lsl	r8,0x2
8000a3ae:	f4 08 00 0b 	add	r11,r10,r8
8000a3b2:	ee 08 00 08 	add	r8,r7,r8
8000a3b6:	11 4a       	ld.w	r10,--r8
8000a3b8:	17 49       	ld.w	r9,--r11
8000a3ba:	12 3a       	cp.w	r10,r9
8000a3bc:	c0 30       	breq	8000a3c2 <__mdiff+0x2a>
8000a3be:	c0 e2       	brcc	8000a3da <__mdiff+0x42>
8000a3c0:	c0 78       	rjmp	8000a3ce <__mdiff+0x36>
8000a3c2:	1c 38       	cp.w	r8,lr
8000a3c4:	fe 9b ff f9 	brhi	8000a3b6 <__mdiff+0x1e>
8000a3c8:	c4 98       	rjmp	8000a45a <__mdiff+0xc2>
8000a3ca:	58 05       	cp.w	r5,0
8000a3cc:	c0 64       	brge	8000a3d8 <__mdiff+0x40>
8000a3ce:	0e 98       	mov	r8,r7
8000a3d0:	30 15       	mov	r5,1
8000a3d2:	0c 97       	mov	r7,r6
8000a3d4:	10 96       	mov	r6,r8
8000a3d6:	c0 28       	rjmp	8000a3da <__mdiff+0x42>
8000a3d8:	30 05       	mov	r5,0
8000a3da:	6e 1b       	ld.w	r11,r7[0x4]
8000a3dc:	c5 6f       	rcall	8000a288 <_Balloc>
8000a3de:	6e 49       	ld.w	r9,r7[0x10]
8000a3e0:	6c 44       	ld.w	r4,r6[0x10]
8000a3e2:	99 35       	st.w	r12[0xc],r5
8000a3e4:	2f b4       	sub	r4,-5
8000a3e6:	f2 c5 ff fb 	sub	r5,r9,-5
8000a3ea:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000a3ee:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000a3f2:	2e c6       	sub	r6,-20
8000a3f4:	2e c7       	sub	r7,-20
8000a3f6:	f8 c8 ff ec 	sub	r8,r12,-20
8000a3fa:	30 0a       	mov	r10,0
8000a3fc:	0f 0e       	ld.w	lr,r7++
8000a3fe:	0d 0b       	ld.w	r11,r6++
8000a400:	fc 02 16 10 	lsr	r2,lr,0x10
8000a404:	f6 03 16 10 	lsr	r3,r11,0x10
8000a408:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a40c:	e4 03 01 03 	sub	r3,r2,r3
8000a410:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a414:	fc 0b 01 0b 	sub	r11,lr,r11
8000a418:	f6 0a 00 0a 	add	r10,r11,r10
8000a41c:	b0 1a       	st.h	r8[0x2],r10
8000a41e:	b1 4a       	asr	r10,0x10
8000a420:	e6 0a 00 0a 	add	r10,r3,r10
8000a424:	b0 0a       	st.h	r8[0x0],r10
8000a426:	2f c8       	sub	r8,-4
8000a428:	b1 4a       	asr	r10,0x10
8000a42a:	08 36       	cp.w	r6,r4
8000a42c:	ce 83       	brcs	8000a3fc <__mdiff+0x64>
8000a42e:	c0 d8       	rjmp	8000a448 <__mdiff+0xb0>
8000a430:	0f 0b       	ld.w	r11,r7++
8000a432:	f6 0e 16 10 	lsr	lr,r11,0x10
8000a436:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a43a:	16 0a       	add	r10,r11
8000a43c:	b0 1a       	st.h	r8[0x2],r10
8000a43e:	b1 4a       	asr	r10,0x10
8000a440:	1c 0a       	add	r10,lr
8000a442:	b0 0a       	st.h	r8[0x0],r10
8000a444:	2f c8       	sub	r8,-4
8000a446:	b1 4a       	asr	r10,0x10
8000a448:	0a 37       	cp.w	r7,r5
8000a44a:	cf 33       	brcs	8000a430 <__mdiff+0x98>
8000a44c:	c0 28       	rjmp	8000a450 <__mdiff+0xb8>
8000a44e:	20 19       	sub	r9,1
8000a450:	11 4a       	ld.w	r10,--r8
8000a452:	58 0a       	cp.w	r10,0
8000a454:	cf d0       	breq	8000a44e <__mdiff+0xb6>
8000a456:	99 49       	st.w	r12[0x10],r9
8000a458:	d8 32       	popm	r0-r7,pc
8000a45a:	30 0b       	mov	r11,0
8000a45c:	c1 6f       	rcall	8000a288 <_Balloc>
8000a45e:	30 18       	mov	r8,1
8000a460:	99 48       	st.w	r12[0x10],r8
8000a462:	30 08       	mov	r8,0
8000a464:	99 58       	st.w	r12[0x14],r8
8000a466:	d8 32       	popm	r0-r7,pc

8000a468 <__lshift>:
8000a468:	d4 31       	pushm	r0-r7,lr
8000a46a:	16 97       	mov	r7,r11
8000a46c:	76 46       	ld.w	r6,r11[0x10]
8000a46e:	f4 02 14 05 	asr	r2,r10,0x5
8000a472:	2f f6       	sub	r6,-1
8000a474:	14 93       	mov	r3,r10
8000a476:	18 94       	mov	r4,r12
8000a478:	04 06       	add	r6,r2
8000a47a:	76 1b       	ld.w	r11,r11[0x4]
8000a47c:	6e 28       	ld.w	r8,r7[0x8]
8000a47e:	c0 38       	rjmp	8000a484 <__lshift+0x1c>
8000a480:	2f fb       	sub	r11,-1
8000a482:	a1 78       	lsl	r8,0x1
8000a484:	10 36       	cp.w	r6,r8
8000a486:	fe 99 ff fd 	brgt	8000a480 <__lshift+0x18>
8000a48a:	08 9c       	mov	r12,r4
8000a48c:	cf ee       	rcall	8000a288 <_Balloc>
8000a48e:	30 09       	mov	r9,0
8000a490:	18 95       	mov	r5,r12
8000a492:	f8 c8 ff ec 	sub	r8,r12,-20
8000a496:	12 9a       	mov	r10,r9
8000a498:	c0 38       	rjmp	8000a49e <__lshift+0x36>
8000a49a:	10 aa       	st.w	r8++,r10
8000a49c:	2f f9       	sub	r9,-1
8000a49e:	04 39       	cp.w	r9,r2
8000a4a0:	cf d5       	brlt	8000a49a <__lshift+0x32>
8000a4a2:	6e 4b       	ld.w	r11,r7[0x10]
8000a4a4:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000a4a8:	2f bb       	sub	r11,-5
8000a4aa:	ee c9 ff ec 	sub	r9,r7,-20
8000a4ae:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000a4b2:	58 03       	cp.w	r3,0
8000a4b4:	c1 30       	breq	8000a4da <__lshift+0x72>
8000a4b6:	e6 0c 11 20 	rsub	r12,r3,32
8000a4ba:	30 0a       	mov	r10,0
8000a4bc:	72 02       	ld.w	r2,r9[0x0]
8000a4be:	e4 03 09 42 	lsl	r2,r2,r3
8000a4c2:	04 4a       	or	r10,r2
8000a4c4:	10 aa       	st.w	r8++,r10
8000a4c6:	13 0a       	ld.w	r10,r9++
8000a4c8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000a4cc:	16 39       	cp.w	r9,r11
8000a4ce:	cf 73       	brcs	8000a4bc <__lshift+0x54>
8000a4d0:	91 0a       	st.w	r8[0x0],r10
8000a4d2:	58 0a       	cp.w	r10,0
8000a4d4:	c0 70       	breq	8000a4e2 <__lshift+0x7a>
8000a4d6:	2f f6       	sub	r6,-1
8000a4d8:	c0 58       	rjmp	8000a4e2 <__lshift+0x7a>
8000a4da:	13 0a       	ld.w	r10,r9++
8000a4dc:	10 aa       	st.w	r8++,r10
8000a4de:	16 39       	cp.w	r9,r11
8000a4e0:	cf d3       	brcs	8000a4da <__lshift+0x72>
8000a4e2:	08 9c       	mov	r12,r4
8000a4e4:	20 16       	sub	r6,1
8000a4e6:	0e 9b       	mov	r11,r7
8000a4e8:	8b 46       	st.w	r5[0x10],r6
8000a4ea:	cb 5e       	rcall	8000a254 <_Bfree>
8000a4ec:	0a 9c       	mov	r12,r5
8000a4ee:	d8 32       	popm	r0-r7,pc

8000a4f0 <__multiply>:
8000a4f0:	d4 31       	pushm	r0-r7,lr
8000a4f2:	20 2d       	sub	sp,8
8000a4f4:	76 49       	ld.w	r9,r11[0x10]
8000a4f6:	74 48       	ld.w	r8,r10[0x10]
8000a4f8:	16 96       	mov	r6,r11
8000a4fa:	14 95       	mov	r5,r10
8000a4fc:	10 39       	cp.w	r9,r8
8000a4fe:	ec 08 17 50 	movlt	r8,r6
8000a502:	ea 06 17 50 	movlt	r6,r5
8000a506:	f0 05 17 50 	movlt	r5,r8
8000a50a:	6c 28       	ld.w	r8,r6[0x8]
8000a50c:	76 43       	ld.w	r3,r11[0x10]
8000a50e:	74 42       	ld.w	r2,r10[0x10]
8000a510:	76 1b       	ld.w	r11,r11[0x4]
8000a512:	e4 03 00 07 	add	r7,r2,r3
8000a516:	10 37       	cp.w	r7,r8
8000a518:	f7 bb 09 ff 	subgt	r11,-1
8000a51c:	cb 6e       	rcall	8000a288 <_Balloc>
8000a51e:	ee c4 ff fb 	sub	r4,r7,-5
8000a522:	f8 c9 ff ec 	sub	r9,r12,-20
8000a526:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000a52a:	30 0a       	mov	r10,0
8000a52c:	12 98       	mov	r8,r9
8000a52e:	c0 28       	rjmp	8000a532 <__multiply+0x42>
8000a530:	10 aa       	st.w	r8++,r10
8000a532:	08 38       	cp.w	r8,r4
8000a534:	cf e3       	brcs	8000a530 <__multiply+0x40>
8000a536:	2f b3       	sub	r3,-5
8000a538:	2f b2       	sub	r2,-5
8000a53a:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000a53e:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000a542:	ec cb ff ec 	sub	r11,r6,-20
8000a546:	50 12       	stdsp	sp[0x4],r2
8000a548:	ea ca ff ec 	sub	r10,r5,-20
8000a54c:	c4 48       	rjmp	8000a5d4 <__multiply+0xe4>
8000a54e:	94 95       	ld.uh	r5,r10[0x2]
8000a550:	58 05       	cp.w	r5,0
8000a552:	c2 00       	breq	8000a592 <__multiply+0xa2>
8000a554:	12 98       	mov	r8,r9
8000a556:	16 96       	mov	r6,r11
8000a558:	30 0e       	mov	lr,0
8000a55a:	50 09       	stdsp	sp[0x0],r9
8000a55c:	0d 02       	ld.w	r2,r6++
8000a55e:	e4 00 16 10 	lsr	r0,r2,0x10
8000a562:	70 01       	ld.w	r1,r8[0x0]
8000a564:	70 09       	ld.w	r9,r8[0x0]
8000a566:	b1 81       	lsr	r1,0x10
8000a568:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000a56c:	e0 05 03 41 	mac	r1,r0,r5
8000a570:	ab 32       	mul	r2,r5
8000a572:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000a576:	00 02       	add	r2,r0
8000a578:	e4 0e 00 0e 	add	lr,r2,lr
8000a57c:	b0 1e       	st.h	r8[0x2],lr
8000a57e:	b1 8e       	lsr	lr,0x10
8000a580:	1c 01       	add	r1,lr
8000a582:	b0 01       	st.h	r8[0x0],r1
8000a584:	e2 0e 16 10 	lsr	lr,r1,0x10
8000a588:	2f c8       	sub	r8,-4
8000a58a:	06 36       	cp.w	r6,r3
8000a58c:	ce 83       	brcs	8000a55c <__multiply+0x6c>
8000a58e:	40 09       	lddsp	r9,sp[0x0]
8000a590:	91 0e       	st.w	r8[0x0],lr
8000a592:	94 86       	ld.uh	r6,r10[0x0]
8000a594:	58 06       	cp.w	r6,0
8000a596:	c1 d0       	breq	8000a5d0 <__multiply+0xe0>
8000a598:	72 02       	ld.w	r2,r9[0x0]
8000a59a:	12 98       	mov	r8,r9
8000a59c:	16 9e       	mov	lr,r11
8000a59e:	30 05       	mov	r5,0
8000a5a0:	b0 12       	st.h	r8[0x2],r2
8000a5a2:	1d 01       	ld.w	r1,lr++
8000a5a4:	90 82       	ld.uh	r2,r8[0x0]
8000a5a6:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000a5aa:	ad 30       	mul	r0,r6
8000a5ac:	e0 02 00 02 	add	r2,r0,r2
8000a5b0:	e4 05 00 05 	add	r5,r2,r5
8000a5b4:	b0 05       	st.h	r8[0x0],r5
8000a5b6:	b1 85       	lsr	r5,0x10
8000a5b8:	b1 81       	lsr	r1,0x10
8000a5ba:	2f c8       	sub	r8,-4
8000a5bc:	ad 31       	mul	r1,r6
8000a5be:	90 92       	ld.uh	r2,r8[0x2]
8000a5c0:	e2 02 00 02 	add	r2,r1,r2
8000a5c4:	0a 02       	add	r2,r5
8000a5c6:	e4 05 16 10 	lsr	r5,r2,0x10
8000a5ca:	06 3e       	cp.w	lr,r3
8000a5cc:	ce a3       	brcs	8000a5a0 <__multiply+0xb0>
8000a5ce:	91 02       	st.w	r8[0x0],r2
8000a5d0:	2f ca       	sub	r10,-4
8000a5d2:	2f c9       	sub	r9,-4
8000a5d4:	40 18       	lddsp	r8,sp[0x4]
8000a5d6:	10 3a       	cp.w	r10,r8
8000a5d8:	cb b3       	brcs	8000a54e <__multiply+0x5e>
8000a5da:	c0 28       	rjmp	8000a5de <__multiply+0xee>
8000a5dc:	20 17       	sub	r7,1
8000a5de:	58 07       	cp.w	r7,0
8000a5e0:	e0 8a 00 05 	brle	8000a5ea <__multiply+0xfa>
8000a5e4:	09 48       	ld.w	r8,--r4
8000a5e6:	58 08       	cp.w	r8,0
8000a5e8:	cf a0       	breq	8000a5dc <__multiply+0xec>
8000a5ea:	99 47       	st.w	r12[0x10],r7
8000a5ec:	2f ed       	sub	sp,-8
8000a5ee:	d8 32       	popm	r0-r7,pc

8000a5f0 <__i2b>:
8000a5f0:	d4 21       	pushm	r4-r7,lr
8000a5f2:	16 97       	mov	r7,r11
8000a5f4:	30 1b       	mov	r11,1
8000a5f6:	c4 9e       	rcall	8000a288 <_Balloc>
8000a5f8:	30 19       	mov	r9,1
8000a5fa:	99 57       	st.w	r12[0x14],r7
8000a5fc:	99 49       	st.w	r12[0x10],r9
8000a5fe:	d8 22       	popm	r4-r7,pc

8000a600 <__multadd>:
8000a600:	d4 31       	pushm	r0-r7,lr
8000a602:	30 08       	mov	r8,0
8000a604:	12 95       	mov	r5,r9
8000a606:	16 97       	mov	r7,r11
8000a608:	18 96       	mov	r6,r12
8000a60a:	76 44       	ld.w	r4,r11[0x10]
8000a60c:	f6 c9 ff ec 	sub	r9,r11,-20
8000a610:	72 0b       	ld.w	r11,r9[0x0]
8000a612:	f6 0c 16 10 	lsr	r12,r11,0x10
8000a616:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a61a:	f4 0c 02 4c 	mul	r12,r10,r12
8000a61e:	f4 0b 03 45 	mac	r5,r10,r11
8000a622:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000a626:	b1 85       	lsr	r5,0x10
8000a628:	18 05       	add	r5,r12
8000a62a:	ea 0c 15 10 	lsl	r12,r5,0x10
8000a62e:	f8 0b 00 0b 	add	r11,r12,r11
8000a632:	12 ab       	st.w	r9++,r11
8000a634:	2f f8       	sub	r8,-1
8000a636:	b1 85       	lsr	r5,0x10
8000a638:	08 38       	cp.w	r8,r4
8000a63a:	ce b5       	brlt	8000a610 <__multadd+0x10>
8000a63c:	58 05       	cp.w	r5,0
8000a63e:	c1 c0       	breq	8000a676 <__multadd+0x76>
8000a640:	6e 28       	ld.w	r8,r7[0x8]
8000a642:	10 34       	cp.w	r4,r8
8000a644:	c1 35       	brlt	8000a66a <__multadd+0x6a>
8000a646:	6e 1b       	ld.w	r11,r7[0x4]
8000a648:	0c 9c       	mov	r12,r6
8000a64a:	2f fb       	sub	r11,-1
8000a64c:	c1 ee       	rcall	8000a288 <_Balloc>
8000a64e:	6e 4a       	ld.w	r10,r7[0x10]
8000a650:	ee cb ff f4 	sub	r11,r7,-12
8000a654:	18 93       	mov	r3,r12
8000a656:	2f ea       	sub	r10,-2
8000a658:	2f 4c       	sub	r12,-12
8000a65a:	a3 6a       	lsl	r10,0x2
8000a65c:	fe b0 de 64 	rcall	80006324 <memcpy>
8000a660:	0e 9b       	mov	r11,r7
8000a662:	0c 9c       	mov	r12,r6
8000a664:	fe b0 fd f8 	rcall	8000a254 <_Bfree>
8000a668:	06 97       	mov	r7,r3
8000a66a:	e8 c8 ff ff 	sub	r8,r4,-1
8000a66e:	2f b4       	sub	r4,-5
8000a670:	8f 48       	st.w	r7[0x10],r8
8000a672:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000a676:	0e 9c       	mov	r12,r7
8000a678:	d8 32       	popm	r0-r7,pc
8000a67a:	d7 03       	nop

8000a67c <__pow5mult>:
8000a67c:	d4 31       	pushm	r0-r7,lr
8000a67e:	14 96       	mov	r6,r10
8000a680:	18 97       	mov	r7,r12
8000a682:	16 94       	mov	r4,r11
8000a684:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000a688:	c0 90       	breq	8000a69a <__pow5mult+0x1e>
8000a68a:	20 18       	sub	r8,1
8000a68c:	fe c9 dc 0c 	sub	r9,pc,-9204
8000a690:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000a694:	30 09       	mov	r9,0
8000a696:	cb 5f       	rcall	8000a600 <__multadd>
8000a698:	18 94       	mov	r4,r12
8000a69a:	a3 46       	asr	r6,0x2
8000a69c:	c3 40       	breq	8000a704 <__pow5mult+0x88>
8000a69e:	6e 95       	ld.w	r5,r7[0x24]
8000a6a0:	58 05       	cp.w	r5,0
8000a6a2:	c0 91       	brne	8000a6b4 <__pow5mult+0x38>
8000a6a4:	31 0c       	mov	r12,16
8000a6a6:	fe b0 dc 1b 	rcall	80005edc <malloc>
8000a6aa:	99 35       	st.w	r12[0xc],r5
8000a6ac:	8f 9c       	st.w	r7[0x24],r12
8000a6ae:	99 15       	st.w	r12[0x4],r5
8000a6b0:	99 25       	st.w	r12[0x8],r5
8000a6b2:	99 05       	st.w	r12[0x0],r5
8000a6b4:	6e 93       	ld.w	r3,r7[0x24]
8000a6b6:	66 25       	ld.w	r5,r3[0x8]
8000a6b8:	58 05       	cp.w	r5,0
8000a6ba:	c0 c1       	brne	8000a6d2 <__pow5mult+0x56>
8000a6bc:	e0 6b 02 71 	mov	r11,625
8000a6c0:	0e 9c       	mov	r12,r7
8000a6c2:	c9 7f       	rcall	8000a5f0 <__i2b>
8000a6c4:	87 2c       	st.w	r3[0x8],r12
8000a6c6:	30 08       	mov	r8,0
8000a6c8:	18 95       	mov	r5,r12
8000a6ca:	99 08       	st.w	r12[0x0],r8
8000a6cc:	c0 38       	rjmp	8000a6d2 <__pow5mult+0x56>
8000a6ce:	06 9c       	mov	r12,r3
8000a6d0:	18 95       	mov	r5,r12
8000a6d2:	ed b6 00 00 	bld	r6,0x0
8000a6d6:	c0 b1       	brne	8000a6ec <__pow5mult+0x70>
8000a6d8:	08 9b       	mov	r11,r4
8000a6da:	0a 9a       	mov	r10,r5
8000a6dc:	0e 9c       	mov	r12,r7
8000a6de:	c0 9f       	rcall	8000a4f0 <__multiply>
8000a6e0:	08 9b       	mov	r11,r4
8000a6e2:	18 93       	mov	r3,r12
8000a6e4:	0e 9c       	mov	r12,r7
8000a6e6:	06 94       	mov	r4,r3
8000a6e8:	fe b0 fd b6 	rcall	8000a254 <_Bfree>
8000a6ec:	a1 56       	asr	r6,0x1
8000a6ee:	c0 b0       	breq	8000a704 <__pow5mult+0x88>
8000a6f0:	6a 03       	ld.w	r3,r5[0x0]
8000a6f2:	58 03       	cp.w	r3,0
8000a6f4:	ce d1       	brne	8000a6ce <__pow5mult+0x52>
8000a6f6:	0a 9a       	mov	r10,r5
8000a6f8:	0a 9b       	mov	r11,r5
8000a6fa:	0e 9c       	mov	r12,r7
8000a6fc:	cf ae       	rcall	8000a4f0 <__multiply>
8000a6fe:	8b 0c       	st.w	r5[0x0],r12
8000a700:	99 03       	st.w	r12[0x0],r3
8000a702:	ce 7b       	rjmp	8000a6d0 <__pow5mult+0x54>
8000a704:	08 9c       	mov	r12,r4
8000a706:	d8 32       	popm	r0-r7,pc

8000a708 <__isinfd>:
8000a708:	14 98       	mov	r8,r10
8000a70a:	fc 19 7f f0 	movh	r9,0x7ff0
8000a70e:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000a712:	f0 0b 11 00 	rsub	r11,r8,0
8000a716:	f7 e8 10 08 	or	r8,r11,r8
8000a71a:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000a71e:	f2 08 01 08 	sub	r8,r9,r8
8000a722:	f0 0c 11 00 	rsub	r12,r8,0
8000a726:	f9 e8 10 08 	or	r8,r12,r8
8000a72a:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000a72e:	2f fc       	sub	r12,-1
8000a730:	5e fc       	retal	r12

8000a732 <__isnand>:
8000a732:	14 98       	mov	r8,r10
8000a734:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000a738:	f0 0c 11 00 	rsub	r12,r8,0
8000a73c:	10 4c       	or	r12,r8
8000a73e:	fc 18 7f f0 	movh	r8,0x7ff0
8000a742:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000a746:	f0 0c 01 0c 	sub	r12,r8,r12
8000a74a:	bf 9c       	lsr	r12,0x1f
8000a74c:	5e fc       	retal	r12
8000a74e:	d7 03       	nop

8000a750 <__sclose>:
8000a750:	d4 01       	pushm	lr
8000a752:	96 7b       	ld.sh	r11,r11[0xe]
8000a754:	c7 6c       	rcall	8000a840 <_close_r>
8000a756:	d8 02       	popm	pc

8000a758 <__sseek>:
8000a758:	d4 21       	pushm	r4-r7,lr
8000a75a:	16 97       	mov	r7,r11
8000a75c:	96 7b       	ld.sh	r11,r11[0xe]
8000a75e:	cf 7c       	rcall	8000a94c <_lseek_r>
8000a760:	8e 68       	ld.sh	r8,r7[0xc]
8000a762:	10 99       	mov	r9,r8
8000a764:	ad c8       	cbr	r8,0xc
8000a766:	ad a9       	sbr	r9,0xc
8000a768:	5b fc       	cp.w	r12,-1
8000a76a:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000a76e:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000a772:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000a776:	d8 22       	popm	r4-r7,pc

8000a778 <__swrite>:
8000a778:	d4 21       	pushm	r4-r7,lr
8000a77a:	96 68       	ld.sh	r8,r11[0xc]
8000a77c:	16 97       	mov	r7,r11
8000a77e:	14 95       	mov	r5,r10
8000a780:	12 94       	mov	r4,r9
8000a782:	e2 18 01 00 	andl	r8,0x100,COH
8000a786:	18 96       	mov	r6,r12
8000a788:	c0 50       	breq	8000a792 <__swrite+0x1a>
8000a78a:	30 29       	mov	r9,2
8000a78c:	30 0a       	mov	r10,0
8000a78e:	96 7b       	ld.sh	r11,r11[0xe]
8000a790:	cd ec       	rcall	8000a94c <_lseek_r>
8000a792:	8e 68       	ld.sh	r8,r7[0xc]
8000a794:	ad c8       	cbr	r8,0xc
8000a796:	08 99       	mov	r9,r4
8000a798:	0a 9a       	mov	r10,r5
8000a79a:	8e 7b       	ld.sh	r11,r7[0xe]
8000a79c:	0c 9c       	mov	r12,r6
8000a79e:	ae 68       	st.h	r7[0xc],r8
8000a7a0:	c1 0c       	rcall	8000a7c0 <_write_r>
8000a7a2:	d8 22       	popm	r4-r7,pc

8000a7a4 <__sread>:
8000a7a4:	d4 21       	pushm	r4-r7,lr
8000a7a6:	16 97       	mov	r7,r11
8000a7a8:	96 7b       	ld.sh	r11,r11[0xe]
8000a7aa:	ce 5c       	rcall	8000a974 <_read_r>
8000a7ac:	c0 65       	brlt	8000a7b8 <__sread+0x14>
8000a7ae:	6f 58       	ld.w	r8,r7[0x54]
8000a7b0:	18 08       	add	r8,r12
8000a7b2:	ef 48 00 54 	st.w	r7[84],r8
8000a7b6:	d8 22       	popm	r4-r7,pc
8000a7b8:	8e 68       	ld.sh	r8,r7[0xc]
8000a7ba:	ad c8       	cbr	r8,0xc
8000a7bc:	ae 68       	st.h	r7[0xc],r8
8000a7be:	d8 22       	popm	r4-r7,pc

8000a7c0 <_write_r>:
8000a7c0:	d4 21       	pushm	r4-r7,lr
8000a7c2:	16 98       	mov	r8,r11
8000a7c4:	18 97       	mov	r7,r12
8000a7c6:	10 9c       	mov	r12,r8
8000a7c8:	30 08       	mov	r8,0
8000a7ca:	14 9b       	mov	r11,r10
8000a7cc:	e0 66 3f e8 	mov	r6,16360
8000a7d0:	12 9a       	mov	r10,r9
8000a7d2:	8d 08       	st.w	r6[0x0],r8
8000a7d4:	fe b0 d1 24 	rcall	80004a1c <_write>
8000a7d8:	5b fc       	cp.w	r12,-1
8000a7da:	c0 51       	brne	8000a7e4 <_write_r+0x24>
8000a7dc:	6c 08       	ld.w	r8,r6[0x0]
8000a7de:	58 08       	cp.w	r8,0
8000a7e0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a7e4:	d8 22       	popm	r4-r7,pc
8000a7e6:	d7 03       	nop

8000a7e8 <_calloc_r>:
8000a7e8:	d4 21       	pushm	r4-r7,lr
8000a7ea:	f4 0b 02 4b 	mul	r11,r10,r11
8000a7ee:	fe b0 db 7f 	rcall	80005eec <_malloc_r>
8000a7f2:	18 97       	mov	r7,r12
8000a7f4:	c2 30       	breq	8000a83a <_calloc_r+0x52>
8000a7f6:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000a7fa:	e0 1a ff fc 	andl	r10,0xfffc
8000a7fe:	20 4a       	sub	r10,4
8000a800:	e0 4a 00 24 	cp.w	r10,36
8000a804:	e0 8b 00 18 	brhi	8000a834 <_calloc_r+0x4c>
8000a808:	18 98       	mov	r8,r12
8000a80a:	59 3a       	cp.w	r10,19
8000a80c:	e0 88 00 0f 	brls	8000a82a <_calloc_r+0x42>
8000a810:	30 09       	mov	r9,0
8000a812:	10 a9       	st.w	r8++,r9
8000a814:	10 a9       	st.w	r8++,r9
8000a816:	59 ba       	cp.w	r10,27
8000a818:	e0 88 00 09 	brls	8000a82a <_calloc_r+0x42>
8000a81c:	10 a9       	st.w	r8++,r9
8000a81e:	10 a9       	st.w	r8++,r9
8000a820:	e0 4a 00 24 	cp.w	r10,36
8000a824:	c0 31       	brne	8000a82a <_calloc_r+0x42>
8000a826:	10 a9       	st.w	r8++,r9
8000a828:	10 a9       	st.w	r8++,r9
8000a82a:	30 09       	mov	r9,0
8000a82c:	10 a9       	st.w	r8++,r9
8000a82e:	91 19       	st.w	r8[0x4],r9
8000a830:	91 09       	st.w	r8[0x0],r9
8000a832:	c0 48       	rjmp	8000a83a <_calloc_r+0x52>
8000a834:	30 0b       	mov	r11,0
8000a836:	fe b0 de 1b 	rcall	8000646c <memset>
8000a83a:	0e 9c       	mov	r12,r7
8000a83c:	d8 22       	popm	r4-r7,pc
8000a83e:	d7 03       	nop

8000a840 <_close_r>:
8000a840:	d4 21       	pushm	r4-r7,lr
8000a842:	30 08       	mov	r8,0
8000a844:	18 97       	mov	r7,r12
8000a846:	e0 66 3f e8 	mov	r6,16360
8000a84a:	16 9c       	mov	r12,r11
8000a84c:	8d 08       	st.w	r6[0x0],r8
8000a84e:	fe b0 df c1 	rcall	800067d0 <_close>
8000a852:	5b fc       	cp.w	r12,-1
8000a854:	c0 51       	brne	8000a85e <_close_r+0x1e>
8000a856:	6c 08       	ld.w	r8,r6[0x0]
8000a858:	58 08       	cp.w	r8,0
8000a85a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a85e:	d8 22       	popm	r4-r7,pc

8000a860 <_fclose_r>:
8000a860:	d4 21       	pushm	r4-r7,lr
8000a862:	18 96       	mov	r6,r12
8000a864:	16 97       	mov	r7,r11
8000a866:	58 0b       	cp.w	r11,0
8000a868:	c0 31       	brne	8000a86e <_fclose_r+0xe>
8000a86a:	16 95       	mov	r5,r11
8000a86c:	c5 38       	rjmp	8000a912 <_fclose_r+0xb2>
8000a86e:	fe b0 f8 b5 	rcall	800099d8 <__sfp_lock_acquire>
8000a872:	58 06       	cp.w	r6,0
8000a874:	c0 70       	breq	8000a882 <_fclose_r+0x22>
8000a876:	6c 68       	ld.w	r8,r6[0x18]
8000a878:	58 08       	cp.w	r8,0
8000a87a:	c0 41       	brne	8000a882 <_fclose_r+0x22>
8000a87c:	0c 9c       	mov	r12,r6
8000a87e:	fe b0 f8 ff 	rcall	80009a7c <__sinit>
8000a882:	fe c8 de a6 	sub	r8,pc,-8538
8000a886:	10 37       	cp.w	r7,r8
8000a888:	c0 31       	brne	8000a88e <_fclose_r+0x2e>
8000a88a:	6c 07       	ld.w	r7,r6[0x0]
8000a88c:	c0 c8       	rjmp	8000a8a4 <_fclose_r+0x44>
8000a88e:	fe c8 de 92 	sub	r8,pc,-8558
8000a892:	10 37       	cp.w	r7,r8
8000a894:	c0 31       	brne	8000a89a <_fclose_r+0x3a>
8000a896:	6c 17       	ld.w	r7,r6[0x4]
8000a898:	c0 68       	rjmp	8000a8a4 <_fclose_r+0x44>
8000a89a:	fe c8 de 7e 	sub	r8,pc,-8578
8000a89e:	10 37       	cp.w	r7,r8
8000a8a0:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a8a4:	8e 69       	ld.sh	r9,r7[0xc]
8000a8a6:	30 08       	mov	r8,0
8000a8a8:	f0 09 19 00 	cp.h	r9,r8
8000a8ac:	c0 51       	brne	8000a8b6 <_fclose_r+0x56>
8000a8ae:	fe b0 f8 96 	rcall	800099da <__sfp_lock_release>
8000a8b2:	30 05       	mov	r5,0
8000a8b4:	c2 f8       	rjmp	8000a912 <_fclose_r+0xb2>
8000a8b6:	0e 9b       	mov	r11,r7
8000a8b8:	0c 9c       	mov	r12,r6
8000a8ba:	fe b0 f8 09 	rcall	800098cc <_fflush_r>
8000a8be:	6e c8       	ld.w	r8,r7[0x30]
8000a8c0:	18 95       	mov	r5,r12
8000a8c2:	58 08       	cp.w	r8,0
8000a8c4:	c0 60       	breq	8000a8d0 <_fclose_r+0x70>
8000a8c6:	6e 8b       	ld.w	r11,r7[0x20]
8000a8c8:	0c 9c       	mov	r12,r6
8000a8ca:	5d 18       	icall	r8
8000a8cc:	f9 b5 05 ff 	movlt	r5,-1
8000a8d0:	8e 68       	ld.sh	r8,r7[0xc]
8000a8d2:	ed b8 00 07 	bld	r8,0x7
8000a8d6:	c0 51       	brne	8000a8e0 <_fclose_r+0x80>
8000a8d8:	6e 4b       	ld.w	r11,r7[0x10]
8000a8da:	0c 9c       	mov	r12,r6
8000a8dc:	fe b0 f9 6a 	rcall	80009bb0 <_free_r>
8000a8e0:	6e db       	ld.w	r11,r7[0x34]
8000a8e2:	58 0b       	cp.w	r11,0
8000a8e4:	c0 a0       	breq	8000a8f8 <_fclose_r+0x98>
8000a8e6:	ee c8 ff bc 	sub	r8,r7,-68
8000a8ea:	10 3b       	cp.w	r11,r8
8000a8ec:	c0 40       	breq	8000a8f4 <_fclose_r+0x94>
8000a8ee:	0c 9c       	mov	r12,r6
8000a8f0:	fe b0 f9 60 	rcall	80009bb0 <_free_r>
8000a8f4:	30 08       	mov	r8,0
8000a8f6:	8f d8       	st.w	r7[0x34],r8
8000a8f8:	6f 2b       	ld.w	r11,r7[0x48]
8000a8fa:	58 0b       	cp.w	r11,0
8000a8fc:	c0 70       	breq	8000a90a <_fclose_r+0xaa>
8000a8fe:	0c 9c       	mov	r12,r6
8000a900:	fe b0 f9 58 	rcall	80009bb0 <_free_r>
8000a904:	30 08       	mov	r8,0
8000a906:	ef 48 00 48 	st.w	r7[72],r8
8000a90a:	30 08       	mov	r8,0
8000a90c:	ae 68       	st.h	r7[0xc],r8
8000a90e:	fe b0 f8 66 	rcall	800099da <__sfp_lock_release>
8000a912:	0a 9c       	mov	r12,r5
8000a914:	d8 22       	popm	r4-r7,pc
8000a916:	d7 03       	nop

8000a918 <fclose>:
8000a918:	d4 01       	pushm	lr
8000a91a:	e0 68 0a 38 	mov	r8,2616
8000a91e:	18 9b       	mov	r11,r12
8000a920:	70 0c       	ld.w	r12,r8[0x0]
8000a922:	c9 ff       	rcall	8000a860 <_fclose_r>
8000a924:	d8 02       	popm	pc
8000a926:	d7 03       	nop

8000a928 <_fstat_r>:
8000a928:	d4 21       	pushm	r4-r7,lr
8000a92a:	16 98       	mov	r8,r11
8000a92c:	18 97       	mov	r7,r12
8000a92e:	10 9c       	mov	r12,r8
8000a930:	30 08       	mov	r8,0
8000a932:	e0 66 3f e8 	mov	r6,16360
8000a936:	14 9b       	mov	r11,r10
8000a938:	8d 08       	st.w	r6[0x0],r8
8000a93a:	fe b0 df 73 	rcall	80006820 <_fstat>
8000a93e:	5b fc       	cp.w	r12,-1
8000a940:	c0 51       	brne	8000a94a <_fstat_r+0x22>
8000a942:	6c 08       	ld.w	r8,r6[0x0]
8000a944:	58 08       	cp.w	r8,0
8000a946:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a94a:	d8 22       	popm	r4-r7,pc

8000a94c <_lseek_r>:
8000a94c:	d4 21       	pushm	r4-r7,lr
8000a94e:	16 98       	mov	r8,r11
8000a950:	18 97       	mov	r7,r12
8000a952:	10 9c       	mov	r12,r8
8000a954:	30 08       	mov	r8,0
8000a956:	14 9b       	mov	r11,r10
8000a958:	e0 66 3f e8 	mov	r6,16360
8000a95c:	12 9a       	mov	r10,r9
8000a95e:	8d 08       	st.w	r6[0x0],r8
8000a960:	fe b0 df 42 	rcall	800067e4 <_lseek>
8000a964:	5b fc       	cp.w	r12,-1
8000a966:	c0 51       	brne	8000a970 <_lseek_r+0x24>
8000a968:	6c 08       	ld.w	r8,r6[0x0]
8000a96a:	58 08       	cp.w	r8,0
8000a96c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a970:	d8 22       	popm	r4-r7,pc
8000a972:	d7 03       	nop

8000a974 <_read_r>:
8000a974:	d4 21       	pushm	r4-r7,lr
8000a976:	16 98       	mov	r8,r11
8000a978:	18 97       	mov	r7,r12
8000a97a:	10 9c       	mov	r12,r8
8000a97c:	30 08       	mov	r8,0
8000a97e:	14 9b       	mov	r11,r10
8000a980:	e0 66 3f e8 	mov	r6,16360
8000a984:	12 9a       	mov	r10,r9
8000a986:	8d 08       	st.w	r6[0x0],r8
8000a988:	fe b0 d0 2a 	rcall	800049dc <_read>
8000a98c:	5b fc       	cp.w	r12,-1
8000a98e:	c0 51       	brne	8000a998 <_read_r+0x24>
8000a990:	6c 08       	ld.w	r8,r6[0x0]
8000a992:	58 08       	cp.w	r8,0
8000a994:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a998:	d8 22       	popm	r4-r7,pc
8000a99a:	d7 03       	nop

8000a99c <__avr32_f64_mul>:
8000a99c:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000a9a0:	e0 80 00 dc 	breq	8000ab58 <__avr32_f64_mul_op1_zero>
8000a9a4:	d4 21       	pushm	r4-r7,lr
8000a9a6:	f7 e9 20 0e 	eor	lr,r11,r9
8000a9aa:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000a9ae:	30 15       	mov	r5,1
8000a9b0:	c4 30       	breq	8000aa36 <__avr32_f64_mul_op1_subnormal>
8000a9b2:	ab 6b       	lsl	r11,0xa
8000a9b4:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000a9b8:	ab 6a       	lsl	r10,0xa
8000a9ba:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000a9be:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000a9c2:	c5 c0       	breq	8000aa7a <__avr32_f64_mul_op2_subnormal>
8000a9c4:	a1 78       	lsl	r8,0x1
8000a9c6:	5c f9       	rol	r9
8000a9c8:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000a9cc:	e0 47 07 ff 	cp.w	r7,2047
8000a9d0:	c7 70       	breq	8000aabe <__avr32_f64_mul_op_nan_or_inf>
8000a9d2:	e0 46 07 ff 	cp.w	r6,2047
8000a9d6:	c7 40       	breq	8000aabe <__avr32_f64_mul_op_nan_or_inf>
8000a9d8:	ee 06 00 0c 	add	r12,r7,r6
8000a9dc:	e0 2c 03 fe 	sub	r12,1022
8000a9e0:	f6 08 06 44 	mulu.d	r4,r11,r8
8000a9e4:	f4 09 07 44 	macu.d	r4,r10,r9
8000a9e8:	f4 08 06 46 	mulu.d	r6,r10,r8
8000a9ec:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000a9f0:	08 07       	add	r7,r4
8000a9f2:	f4 05 00 4a 	adc	r10,r10,r5
8000a9f6:	5c 0b       	acr	r11
8000a9f8:	ed bb 00 14 	bld	r11,0x14
8000a9fc:	c0 50       	breq	8000aa06 <__avr32_f64_mul+0x6a>
8000a9fe:	a1 77       	lsl	r7,0x1
8000aa00:	5c fa       	rol	r10
8000aa02:	5c fb       	rol	r11
8000aa04:	20 1c       	sub	r12,1
8000aa06:	58 0c       	cp.w	r12,0
8000aa08:	e0 8a 00 6f 	brle	8000aae6 <__avr32_f64_mul_res_subnormal>
8000aa0c:	e0 4c 07 ff 	cp.w	r12,2047
8000aa10:	e0 84 00 9c 	brge	8000ab48 <__avr32_f64_mul_res_inf>
8000aa14:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000aa18:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000aa1c:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000aa20:	ee 17 80 00 	eorh	r7,0x8000
8000aa24:	f1 b7 04 20 	satu	r7,0x1
8000aa28:	0e 0a       	add	r10,r7
8000aa2a:	5c 0b       	acr	r11
8000aa2c:	ed be 00 1f 	bld	lr,0x1f
8000aa30:	ef bb 00 1f 	bst	r11,0x1f
8000aa34:	d8 22       	popm	r4-r7,pc

8000aa36 <__avr32_f64_mul_op1_subnormal>:
8000aa36:	e4 1b 00 0f 	andh	r11,0xf
8000aa3a:	f4 0c 12 00 	clz	r12,r10
8000aa3e:	f6 06 12 00 	clz	r6,r11
8000aa42:	f7 bc 03 e1 	sublo	r12,-31
8000aa46:	f8 06 17 30 	movlo	r6,r12
8000aa4a:	f7 b6 02 01 	subhs	r6,1
8000aa4e:	e0 46 00 20 	cp.w	r6,32
8000aa52:	c0 d4       	brge	8000aa6c <__avr32_f64_mul_op1_subnormal+0x36>
8000aa54:	ec 0c 11 20 	rsub	r12,r6,32
8000aa58:	f6 06 09 4b 	lsl	r11,r11,r6
8000aa5c:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000aa60:	18 4b       	or	r11,r12
8000aa62:	f4 06 09 4a 	lsl	r10,r10,r6
8000aa66:	20 b6       	sub	r6,11
8000aa68:	0c 17       	sub	r7,r6
8000aa6a:	ca ab       	rjmp	8000a9be <__avr32_f64_mul+0x22>
8000aa6c:	f4 06 09 4b 	lsl	r11,r10,r6
8000aa70:	c6 40       	breq	8000ab38 <__avr32_f64_mul_res_zero>
8000aa72:	30 0a       	mov	r10,0
8000aa74:	20 b6       	sub	r6,11
8000aa76:	0c 17       	sub	r7,r6
8000aa78:	ca 3b       	rjmp	8000a9be <__avr32_f64_mul+0x22>

8000aa7a <__avr32_f64_mul_op2_subnormal>:
8000aa7a:	e4 19 00 0f 	andh	r9,0xf
8000aa7e:	f0 0c 12 00 	clz	r12,r8
8000aa82:	f2 05 12 00 	clz	r5,r9
8000aa86:	f7 bc 03 ea 	sublo	r12,-22
8000aa8a:	f8 05 17 30 	movlo	r5,r12
8000aa8e:	f7 b5 02 0a 	subhs	r5,10
8000aa92:	e0 45 00 20 	cp.w	r5,32
8000aa96:	c0 d4       	brge	8000aab0 <__avr32_f64_mul_op2_subnormal+0x36>
8000aa98:	ea 0c 11 20 	rsub	r12,r5,32
8000aa9c:	f2 05 09 49 	lsl	r9,r9,r5
8000aaa0:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000aaa4:	18 49       	or	r9,r12
8000aaa6:	f0 05 09 48 	lsl	r8,r8,r5
8000aaaa:	20 25       	sub	r5,2
8000aaac:	0a 16       	sub	r6,r5
8000aaae:	c8 fb       	rjmp	8000a9cc <__avr32_f64_mul+0x30>
8000aab0:	f0 05 09 49 	lsl	r9,r8,r5
8000aab4:	c4 20       	breq	8000ab38 <__avr32_f64_mul_res_zero>
8000aab6:	30 08       	mov	r8,0
8000aab8:	20 25       	sub	r5,2
8000aaba:	0a 16       	sub	r6,r5
8000aabc:	c8 8b       	rjmp	8000a9cc <__avr32_f64_mul+0x30>

8000aabe <__avr32_f64_mul_op_nan_or_inf>:
8000aabe:	e4 19 00 0f 	andh	r9,0xf
8000aac2:	e4 1b 00 0f 	andh	r11,0xf
8000aac6:	14 4b       	or	r11,r10
8000aac8:	10 49       	or	r9,r8
8000aaca:	e0 47 07 ff 	cp.w	r7,2047
8000aace:	c0 91       	brne	8000aae0 <__avr32_f64_mul_op1_not_naninf>
8000aad0:	58 0b       	cp.w	r11,0
8000aad2:	c3 81       	brne	8000ab42 <__avr32_f64_mul_res_nan>
8000aad4:	e0 46 07 ff 	cp.w	r6,2047
8000aad8:	c3 81       	brne	8000ab48 <__avr32_f64_mul_res_inf>
8000aada:	58 09       	cp.w	r9,0
8000aadc:	c3 60       	breq	8000ab48 <__avr32_f64_mul_res_inf>
8000aade:	c3 28       	rjmp	8000ab42 <__avr32_f64_mul_res_nan>

8000aae0 <__avr32_f64_mul_op1_not_naninf>:
8000aae0:	58 09       	cp.w	r9,0
8000aae2:	c3 30       	breq	8000ab48 <__avr32_f64_mul_res_inf>
8000aae4:	c2 f8       	rjmp	8000ab42 <__avr32_f64_mul_res_nan>

8000aae6 <__avr32_f64_mul_res_subnormal>:
8000aae6:	5c 3c       	neg	r12
8000aae8:	2f fc       	sub	r12,-1
8000aaea:	f1 bc 04 c0 	satu	r12,0x6
8000aaee:	e0 4c 00 20 	cp.w	r12,32
8000aaf2:	c1 14       	brge	8000ab14 <__avr32_f64_mul_res_subnormal+0x2e>
8000aaf4:	f8 08 11 20 	rsub	r8,r12,32
8000aaf8:	0e 46       	or	r6,r7
8000aafa:	ee 0c 0a 47 	lsr	r7,r7,r12
8000aafe:	f4 08 09 49 	lsl	r9,r10,r8
8000ab02:	12 47       	or	r7,r9
8000ab04:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ab08:	f6 08 09 49 	lsl	r9,r11,r8
8000ab0c:	12 4a       	or	r10,r9
8000ab0e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000ab12:	c8 3b       	rjmp	8000aa18 <__avr32_f64_mul+0x7c>
8000ab14:	f8 08 11 20 	rsub	r8,r12,32
8000ab18:	f9 b9 00 00 	moveq	r9,0
8000ab1c:	c0 30       	breq	8000ab22 <__avr32_f64_mul_res_subnormal+0x3c>
8000ab1e:	f6 08 09 49 	lsl	r9,r11,r8
8000ab22:	0e 46       	or	r6,r7
8000ab24:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000ab28:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ab2c:	f3 ea 10 07 	or	r7,r9,r10
8000ab30:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000ab34:	30 0b       	mov	r11,0
8000ab36:	c7 1b       	rjmp	8000aa18 <__avr32_f64_mul+0x7c>

8000ab38 <__avr32_f64_mul_res_zero>:
8000ab38:	1c 9b       	mov	r11,lr
8000ab3a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000ab3e:	30 0a       	mov	r10,0
8000ab40:	d8 22       	popm	r4-r7,pc

8000ab42 <__avr32_f64_mul_res_nan>:
8000ab42:	3f fb       	mov	r11,-1
8000ab44:	3f fa       	mov	r10,-1
8000ab46:	d8 22       	popm	r4-r7,pc

8000ab48 <__avr32_f64_mul_res_inf>:
8000ab48:	f0 6b 00 00 	mov	r11,-1048576
8000ab4c:	ed be 00 1f 	bld	lr,0x1f
8000ab50:	ef bb 00 1f 	bst	r11,0x1f
8000ab54:	30 0a       	mov	r10,0
8000ab56:	d8 22       	popm	r4-r7,pc

8000ab58 <__avr32_f64_mul_op1_zero>:
8000ab58:	f7 e9 20 0b 	eor	r11,r11,r9
8000ab5c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000ab60:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000ab64:	e0 4c 07 ff 	cp.w	r12,2047
8000ab68:	5e 1c       	retne	r12
8000ab6a:	3f fa       	mov	r10,-1
8000ab6c:	3f fb       	mov	r11,-1
8000ab6e:	5e fc       	retal	r12

8000ab70 <__avr32_f64_sub_from_add>:
8000ab70:	ee 19 80 00 	eorh	r9,0x8000

8000ab74 <__avr32_f64_sub>:
8000ab74:	f7 e9 20 0c 	eor	r12,r11,r9
8000ab78:	e0 86 00 ca 	brmi	8000ad0c <__avr32_f64_add_from_sub>
8000ab7c:	eb cd 40 e0 	pushm	r5-r7,lr
8000ab80:	16 9c       	mov	r12,r11
8000ab82:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ab86:	bf db       	cbr	r11,0x1f
8000ab88:	bf d9       	cbr	r9,0x1f
8000ab8a:	10 3a       	cp.w	r10,r8
8000ab8c:	f2 0b 13 00 	cpc	r11,r9
8000ab90:	c0 92       	brcc	8000aba2 <__avr32_f64_sub+0x2e>
8000ab92:	16 97       	mov	r7,r11
8000ab94:	12 9b       	mov	r11,r9
8000ab96:	0e 99       	mov	r9,r7
8000ab98:	14 97       	mov	r7,r10
8000ab9a:	10 9a       	mov	r10,r8
8000ab9c:	0e 98       	mov	r8,r7
8000ab9e:	ee 1c 80 00 	eorh	r12,0x8000
8000aba2:	f6 07 16 14 	lsr	r7,r11,0x14
8000aba6:	ab 7b       	lsl	r11,0xb
8000aba8:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000abac:	ab 7a       	lsl	r10,0xb
8000abae:	bf bb       	sbr	r11,0x1f
8000abb0:	f2 06 16 14 	lsr	r6,r9,0x14
8000abb4:	c4 40       	breq	8000ac3c <__avr32_f64_sub_opL_subnormal>
8000abb6:	ab 79       	lsl	r9,0xb
8000abb8:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000abbc:	ab 78       	lsl	r8,0xb
8000abbe:	bf b9       	sbr	r9,0x1f

8000abc0 <__avr32_f64_sub_opL_subnormal_done>:
8000abc0:	e0 47 07 ff 	cp.w	r7,2047
8000abc4:	c4 f0       	breq	8000ac62 <__avr32_f64_sub_opH_nan_or_inf>
8000abc6:	0e 26       	rsub	r6,r7
8000abc8:	c1 20       	breq	8000abec <__avr32_f64_sub_shift_done>
8000abca:	ec 05 11 20 	rsub	r5,r6,32
8000abce:	e0 46 00 20 	cp.w	r6,32
8000abd2:	c7 c2       	brcc	8000acca <__avr32_f64_sub_longshift>
8000abd4:	f0 05 09 4e 	lsl	lr,r8,r5
8000abd8:	f2 05 09 45 	lsl	r5,r9,r5
8000abdc:	f0 06 0a 48 	lsr	r8,r8,r6
8000abe0:	f2 06 0a 49 	lsr	r9,r9,r6
8000abe4:	0a 48       	or	r8,r5
8000abe6:	58 0e       	cp.w	lr,0
8000abe8:	5f 1e       	srne	lr
8000abea:	1c 48       	or	r8,lr

8000abec <__avr32_f64_sub_shift_done>:
8000abec:	10 1a       	sub	r10,r8
8000abee:	f6 09 01 4b 	sbc	r11,r11,r9
8000abf2:	f6 06 12 00 	clz	r6,r11
8000abf6:	c0 e0       	breq	8000ac12 <__avr32_f64_sub_longnormalize_done>
8000abf8:	c7 83       	brcs	8000ace8 <__avr32_f64_sub_longnormalize>
8000abfa:	ec 0e 11 20 	rsub	lr,r6,32
8000abfe:	f6 06 09 4b 	lsl	r11,r11,r6
8000ac02:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000ac06:	1c 4b       	or	r11,lr
8000ac08:	f4 06 09 4a 	lsl	r10,r10,r6
8000ac0c:	0c 17       	sub	r7,r6
8000ac0e:	e0 8a 00 39 	brle	8000ac80 <__avr32_f64_sub_subnormal_result>

8000ac12 <__avr32_f64_sub_longnormalize_done>:
8000ac12:	f4 09 15 15 	lsl	r9,r10,0x15
8000ac16:	ab 9a       	lsr	r10,0xb
8000ac18:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000ac1c:	ab 9b       	lsr	r11,0xb
8000ac1e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000ac22:	18 4b       	or	r11,r12

8000ac24 <__avr32_f64_sub_round>:
8000ac24:	fc 17 80 00 	movh	r7,0x8000
8000ac28:	ed ba 00 00 	bld	r10,0x0
8000ac2c:	f7 b7 01 ff 	subne	r7,-1
8000ac30:	0e 39       	cp.w	r9,r7
8000ac32:	5f 29       	srhs	r9
8000ac34:	12 0a       	add	r10,r9
8000ac36:	5c 0b       	acr	r11
8000ac38:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ac3c <__avr32_f64_sub_opL_subnormal>:
8000ac3c:	ab 79       	lsl	r9,0xb
8000ac3e:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000ac42:	ab 78       	lsl	r8,0xb
8000ac44:	f3 e8 10 0e 	or	lr,r9,r8
8000ac48:	f9 b6 01 01 	movne	r6,1
8000ac4c:	ee 0e 11 00 	rsub	lr,r7,0
8000ac50:	f9 b7 00 01 	moveq	r7,1
8000ac54:	ef bb 00 1f 	bst	r11,0x1f
8000ac58:	f7 ea 10 0e 	or	lr,r11,r10
8000ac5c:	f9 b7 00 00 	moveq	r7,0
8000ac60:	cb 0b       	rjmp	8000abc0 <__avr32_f64_sub_opL_subnormal_done>

8000ac62 <__avr32_f64_sub_opH_nan_or_inf>:
8000ac62:	bf db       	cbr	r11,0x1f
8000ac64:	f7 ea 10 0e 	or	lr,r11,r10
8000ac68:	c0 81       	brne	8000ac78 <__avr32_f64_sub_return_nan>
8000ac6a:	e0 46 07 ff 	cp.w	r6,2047
8000ac6e:	c0 50       	breq	8000ac78 <__avr32_f64_sub_return_nan>
8000ac70:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000ac74:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ac78 <__avr32_f64_sub_return_nan>:
8000ac78:	3f fa       	mov	r10,-1
8000ac7a:	3f fb       	mov	r11,-1
8000ac7c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ac80 <__avr32_f64_sub_subnormal_result>:
8000ac80:	5c 37       	neg	r7
8000ac82:	2f f7       	sub	r7,-1
8000ac84:	f1 b7 04 c0 	satu	r7,0x6
8000ac88:	e0 47 00 20 	cp.w	r7,32
8000ac8c:	c1 14       	brge	8000acae <__avr32_f64_sub_subnormal_result+0x2e>
8000ac8e:	ee 08 11 20 	rsub	r8,r7,32
8000ac92:	f4 08 09 49 	lsl	r9,r10,r8
8000ac96:	5f 16       	srne	r6
8000ac98:	f4 07 0a 4a 	lsr	r10,r10,r7
8000ac9c:	0c 4a       	or	r10,r6
8000ac9e:	f6 08 09 49 	lsl	r9,r11,r8
8000aca2:	f5 e9 10 0a 	or	r10,r10,r9
8000aca6:	f4 07 0a 4b 	lsr	r11,r10,r7
8000acaa:	30 07       	mov	r7,0
8000acac:	cb 3b       	rjmp	8000ac12 <__avr32_f64_sub_longnormalize_done>
8000acae:	ee 08 11 40 	rsub	r8,r7,64
8000acb2:	f6 08 09 49 	lsl	r9,r11,r8
8000acb6:	14 49       	or	r9,r10
8000acb8:	5f 16       	srne	r6
8000acba:	f6 07 0a 4a 	lsr	r10,r11,r7
8000acbe:	0c 4a       	or	r10,r6
8000acc0:	30 0b       	mov	r11,0
8000acc2:	30 07       	mov	r7,0
8000acc4:	ca 7b       	rjmp	8000ac12 <__avr32_f64_sub_longnormalize_done>
8000acc6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000acca <__avr32_f64_sub_longshift>:
8000acca:	f1 b6 04 c0 	satu	r6,0x6
8000acce:	f0 0e 17 00 	moveq	lr,r8
8000acd2:	c0 40       	breq	8000acda <__avr32_f64_sub_longshift+0x10>
8000acd4:	f2 05 09 4e 	lsl	lr,r9,r5
8000acd8:	10 4e       	or	lr,r8
8000acda:	f2 06 0a 48 	lsr	r8,r9,r6
8000acde:	30 09       	mov	r9,0
8000ace0:	58 0e       	cp.w	lr,0
8000ace2:	5f 1e       	srne	lr
8000ace4:	1c 48       	or	r8,lr
8000ace6:	c8 3b       	rjmp	8000abec <__avr32_f64_sub_shift_done>

8000ace8 <__avr32_f64_sub_longnormalize>:
8000ace8:	f4 06 12 00 	clz	r6,r10
8000acec:	f9 b7 03 00 	movlo	r7,0
8000acf0:	f9 b6 03 00 	movlo	r6,0
8000acf4:	f9 bc 03 00 	movlo	r12,0
8000acf8:	f7 b6 02 e0 	subhs	r6,-32
8000acfc:	f4 06 09 4b 	lsl	r11,r10,r6
8000ad00:	30 0a       	mov	r10,0
8000ad02:	0c 17       	sub	r7,r6
8000ad04:	fe 9a ff be 	brle	8000ac80 <__avr32_f64_sub_subnormal_result>
8000ad08:	c8 5b       	rjmp	8000ac12 <__avr32_f64_sub_longnormalize_done>
8000ad0a:	d7 03       	nop

8000ad0c <__avr32_f64_add_from_sub>:
8000ad0c:	ee 19 80 00 	eorh	r9,0x8000

8000ad10 <__avr32_f64_add>:
8000ad10:	f7 e9 20 0c 	eor	r12,r11,r9
8000ad14:	fe 96 ff 2e 	brmi	8000ab70 <__avr32_f64_sub_from_add>
8000ad18:	eb cd 40 e0 	pushm	r5-r7,lr
8000ad1c:	16 9c       	mov	r12,r11
8000ad1e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ad22:	bf db       	cbr	r11,0x1f
8000ad24:	bf d9       	cbr	r9,0x1f
8000ad26:	12 3b       	cp.w	r11,r9
8000ad28:	c0 72       	brcc	8000ad36 <__avr32_f64_add+0x26>
8000ad2a:	16 97       	mov	r7,r11
8000ad2c:	12 9b       	mov	r11,r9
8000ad2e:	0e 99       	mov	r9,r7
8000ad30:	14 97       	mov	r7,r10
8000ad32:	10 9a       	mov	r10,r8
8000ad34:	0e 98       	mov	r8,r7
8000ad36:	30 0e       	mov	lr,0
8000ad38:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ad3c:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000ad40:	b5 ab       	sbr	r11,0x14
8000ad42:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ad46:	c6 20       	breq	8000ae0a <__avr32_f64_add_op2_subnormal>
8000ad48:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000ad4c:	b5 a9       	sbr	r9,0x14
8000ad4e:	e0 47 07 ff 	cp.w	r7,2047
8000ad52:	c2 80       	breq	8000ada2 <__avr32_f64_add_opH_nan_or_inf>
8000ad54:	0e 26       	rsub	r6,r7
8000ad56:	c1 20       	breq	8000ad7a <__avr32_f64_add_shift_done>
8000ad58:	e0 46 00 36 	cp.w	r6,54
8000ad5c:	c1 52       	brcc	8000ad86 <__avr32_f64_add_res_of_done>
8000ad5e:	ec 05 11 20 	rsub	r5,r6,32
8000ad62:	e0 46 00 20 	cp.w	r6,32
8000ad66:	c3 52       	brcc	8000add0 <__avr32_f64_add_longshift>
8000ad68:	f0 05 09 4e 	lsl	lr,r8,r5
8000ad6c:	f2 05 09 45 	lsl	r5,r9,r5
8000ad70:	f0 06 0a 48 	lsr	r8,r8,r6
8000ad74:	f2 06 0a 49 	lsr	r9,r9,r6
8000ad78:	0a 48       	or	r8,r5

8000ad7a <__avr32_f64_add_shift_done>:
8000ad7a:	10 0a       	add	r10,r8
8000ad7c:	f6 09 00 4b 	adc	r11,r11,r9
8000ad80:	ed bb 00 15 	bld	r11,0x15
8000ad84:	c3 40       	breq	8000adec <__avr32_f64_add_res_of>

8000ad86 <__avr32_f64_add_res_of_done>:
8000ad86:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000ad8a:	18 4b       	or	r11,r12

8000ad8c <__avr32_f64_add_round>:
8000ad8c:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000ad90:	18 4e       	or	lr,r12
8000ad92:	ee 1e 80 00 	eorh	lr,0x8000
8000ad96:	f1 be 04 20 	satu	lr,0x1
8000ad9a:	1c 0a       	add	r10,lr
8000ad9c:	5c 0b       	acr	r11
8000ad9e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ada2 <__avr32_f64_add_opH_nan_or_inf>:
8000ada2:	b5 cb       	cbr	r11,0x14
8000ada4:	f7 ea 10 0e 	or	lr,r11,r10
8000ada8:	c1 01       	brne	8000adc8 <__avr32_f64_add_return_nan>
8000adaa:	e0 46 07 ff 	cp.w	r6,2047
8000adae:	c0 30       	breq	8000adb4 <__avr32_f64_add_opL_nan_or_inf>
8000adb0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000adb4 <__avr32_f64_add_opL_nan_or_inf>:
8000adb4:	b5 c9       	cbr	r9,0x14
8000adb6:	f3 e8 10 0e 	or	lr,r9,r8
8000adba:	c0 71       	brne	8000adc8 <__avr32_f64_add_return_nan>
8000adbc:	30 0a       	mov	r10,0
8000adbe:	fc 1b 7f f0 	movh	r11,0x7ff0
8000adc2:	18 4b       	or	r11,r12
8000adc4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000adc8 <__avr32_f64_add_return_nan>:
8000adc8:	3f fa       	mov	r10,-1
8000adca:	3f fb       	mov	r11,-1
8000adcc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000add0 <__avr32_f64_add_longshift>:
8000add0:	f1 b6 04 c0 	satu	r6,0x6
8000add4:	f0 0e 17 00 	moveq	lr,r8
8000add8:	c0 60       	breq	8000ade4 <__avr32_f64_add_longshift+0x14>
8000adda:	f2 05 09 4e 	lsl	lr,r9,r5
8000adde:	58 08       	cp.w	r8,0
8000ade0:	5f 18       	srne	r8
8000ade2:	10 4e       	or	lr,r8
8000ade4:	f2 06 0a 48 	lsr	r8,r9,r6
8000ade8:	30 09       	mov	r9,0
8000adea:	cc 8b       	rjmp	8000ad7a <__avr32_f64_add_shift_done>

8000adec <__avr32_f64_add_res_of>:
8000adec:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000adf0:	a1 9b       	lsr	r11,0x1
8000adf2:	5d 0a       	ror	r10
8000adf4:	5d 0e       	ror	lr
8000adf6:	2f f7       	sub	r7,-1
8000adf8:	e0 47 07 ff 	cp.w	r7,2047
8000adfc:	f9 ba 00 00 	moveq	r10,0
8000ae00:	f9 bb 00 00 	moveq	r11,0
8000ae04:	f9 be 00 00 	moveq	lr,0
8000ae08:	cb fb       	rjmp	8000ad86 <__avr32_f64_add_res_of_done>

8000ae0a <__avr32_f64_add_op2_subnormal>:
8000ae0a:	30 16       	mov	r6,1
8000ae0c:	58 07       	cp.w	r7,0
8000ae0e:	ca 01       	brne	8000ad4e <__avr32_f64_add+0x3e>
8000ae10:	b5 cb       	cbr	r11,0x14
8000ae12:	10 0a       	add	r10,r8
8000ae14:	f6 09 00 4b 	adc	r11,r11,r9
8000ae18:	18 4b       	or	r11,r12
8000ae1a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000ae1e:	d7 03       	nop

8000ae20 <__avr32_f64_to_u32>:
8000ae20:	58 0b       	cp.w	r11,0
8000ae22:	5e 6d       	retmi	0

8000ae24 <__avr32_f64_to_s32>:
8000ae24:	f6 0c 15 01 	lsl	r12,r11,0x1
8000ae28:	b5 9c       	lsr	r12,0x15
8000ae2a:	e0 2c 03 ff 	sub	r12,1023
8000ae2e:	5e 3d       	retlo	0
8000ae30:	f8 0c 11 1f 	rsub	r12,r12,31
8000ae34:	16 99       	mov	r9,r11
8000ae36:	ab 7b       	lsl	r11,0xb
8000ae38:	bf bb       	sbr	r11,0x1f
8000ae3a:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000ae3e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000ae42:	a1 79       	lsl	r9,0x1
8000ae44:	5e 2b       	reths	r11
8000ae46:	5c 3b       	neg	r11
8000ae48:	5e fb       	retal	r11

8000ae4a <__avr32_u32_to_f64>:
8000ae4a:	f8 cb 00 00 	sub	r11,r12,0
8000ae4e:	30 0c       	mov	r12,0
8000ae50:	c0 38       	rjmp	8000ae56 <__avr32_s32_to_f64+0x4>

8000ae52 <__avr32_s32_to_f64>:
8000ae52:	18 9b       	mov	r11,r12
8000ae54:	5c 4b       	abs	r11
8000ae56:	30 0a       	mov	r10,0
8000ae58:	5e 0b       	reteq	r11
8000ae5a:	d4 01       	pushm	lr
8000ae5c:	e0 69 04 1e 	mov	r9,1054
8000ae60:	f6 08 12 00 	clz	r8,r11
8000ae64:	c1 70       	breq	8000ae92 <__avr32_s32_to_f64+0x40>
8000ae66:	c0 c3       	brcs	8000ae7e <__avr32_s32_to_f64+0x2c>
8000ae68:	f0 0e 11 20 	rsub	lr,r8,32
8000ae6c:	f6 08 09 4b 	lsl	r11,r11,r8
8000ae70:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000ae74:	1c 4b       	or	r11,lr
8000ae76:	f4 08 09 4a 	lsl	r10,r10,r8
8000ae7a:	10 19       	sub	r9,r8
8000ae7c:	c0 b8       	rjmp	8000ae92 <__avr32_s32_to_f64+0x40>
8000ae7e:	f4 08 12 00 	clz	r8,r10
8000ae82:	f9 b8 03 00 	movlo	r8,0
8000ae86:	f7 b8 02 e0 	subhs	r8,-32
8000ae8a:	f4 08 09 4b 	lsl	r11,r10,r8
8000ae8e:	30 0a       	mov	r10,0
8000ae90:	10 19       	sub	r9,r8
8000ae92:	58 09       	cp.w	r9,0
8000ae94:	e0 89 00 30 	brgt	8000aef4 <__avr32_s32_to_f64+0xa2>
8000ae98:	5c 39       	neg	r9
8000ae9a:	2f f9       	sub	r9,-1
8000ae9c:	e0 49 00 36 	cp.w	r9,54
8000aea0:	c0 43       	brcs	8000aea8 <__avr32_s32_to_f64+0x56>
8000aea2:	30 0b       	mov	r11,0
8000aea4:	30 0a       	mov	r10,0
8000aea6:	c2 68       	rjmp	8000aef2 <__avr32_s32_to_f64+0xa0>
8000aea8:	2f 69       	sub	r9,-10
8000aeaa:	f2 08 11 20 	rsub	r8,r9,32
8000aeae:	e0 49 00 20 	cp.w	r9,32
8000aeb2:	c0 b2       	brcc	8000aec8 <__avr32_s32_to_f64+0x76>
8000aeb4:	f4 08 09 4e 	lsl	lr,r10,r8
8000aeb8:	f6 08 09 48 	lsl	r8,r11,r8
8000aebc:	f4 09 0a 4a 	lsr	r10,r10,r9
8000aec0:	f6 09 0a 4b 	lsr	r11,r11,r9
8000aec4:	10 4b       	or	r11,r8
8000aec6:	c0 88       	rjmp	8000aed6 <__avr32_s32_to_f64+0x84>
8000aec8:	f6 08 09 4e 	lsl	lr,r11,r8
8000aecc:	14 4e       	or	lr,r10
8000aece:	16 9a       	mov	r10,r11
8000aed0:	30 0b       	mov	r11,0
8000aed2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000aed6:	ed ba 00 00 	bld	r10,0x0
8000aeda:	c0 92       	brcc	8000aeec <__avr32_s32_to_f64+0x9a>
8000aedc:	1c 7e       	tst	lr,lr
8000aede:	c0 41       	brne	8000aee6 <__avr32_s32_to_f64+0x94>
8000aee0:	ed ba 00 01 	bld	r10,0x1
8000aee4:	c0 42       	brcc	8000aeec <__avr32_s32_to_f64+0x9a>
8000aee6:	2f fa       	sub	r10,-1
8000aee8:	f7 bb 02 ff 	subhs	r11,-1
8000aeec:	5c fc       	rol	r12
8000aeee:	5d 0b       	ror	r11
8000aef0:	5d 0a       	ror	r10
8000aef2:	d8 02       	popm	pc
8000aef4:	e0 68 03 ff 	mov	r8,1023
8000aef8:	ed ba 00 0b 	bld	r10,0xb
8000aefc:	f7 b8 00 ff 	subeq	r8,-1
8000af00:	10 0a       	add	r10,r8
8000af02:	5c 0b       	acr	r11
8000af04:	f7 b9 03 fe 	sublo	r9,-2
8000af08:	e0 49 07 ff 	cp.w	r9,2047
8000af0c:	c0 55       	brlt	8000af16 <__avr32_s32_to_f64+0xc4>
8000af0e:	30 0a       	mov	r10,0
8000af10:	fc 1b ff e0 	movh	r11,0xffe0
8000af14:	c0 c8       	rjmp	8000af2c <__floatsidf_return_op1>
8000af16:	ed bb 00 1f 	bld	r11,0x1f
8000af1a:	f7 b9 01 01 	subne	r9,1
8000af1e:	ab 9a       	lsr	r10,0xb
8000af20:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000af24:	a1 7b       	lsl	r11,0x1
8000af26:	ab 9b       	lsr	r11,0xb
8000af28:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000af2c <__floatsidf_return_op1>:
8000af2c:	a1 7c       	lsl	r12,0x1
8000af2e:	5d 0b       	ror	r11
8000af30:	d8 02       	popm	pc

8000af32 <__avr32_f64_cmp_eq>:
8000af32:	10 3a       	cp.w	r10,r8
8000af34:	f2 0b 13 00 	cpc	r11,r9
8000af38:	c0 80       	breq	8000af48 <__avr32_f64_cmp_eq+0x16>
8000af3a:	a1 7b       	lsl	r11,0x1
8000af3c:	a1 79       	lsl	r9,0x1
8000af3e:	14 4b       	or	r11,r10
8000af40:	12 4b       	or	r11,r9
8000af42:	10 4b       	or	r11,r8
8000af44:	5e 0f       	reteq	1
8000af46:	5e fd       	retal	0
8000af48:	a1 7b       	lsl	r11,0x1
8000af4a:	fc 1c ff e0 	movh	r12,0xffe0
8000af4e:	58 0a       	cp.w	r10,0
8000af50:	f8 0b 13 00 	cpc	r11,r12
8000af54:	5e 8f       	retls	1
8000af56:	5e fd       	retal	0

8000af58 <__avr32_f64_cmp_ge>:
8000af58:	1a de       	st.w	--sp,lr
8000af5a:	1a d7       	st.w	--sp,r7
8000af5c:	a1 7b       	lsl	r11,0x1
8000af5e:	5f 3c       	srlo	r12
8000af60:	a1 79       	lsl	r9,0x1
8000af62:	5f 37       	srlo	r7
8000af64:	5c fc       	rol	r12
8000af66:	fc 1e ff e0 	movh	lr,0xffe0
8000af6a:	58 0a       	cp.w	r10,0
8000af6c:	fc 0b 13 00 	cpc	r11,lr
8000af70:	e0 8b 00 1d 	brhi	8000afaa <__avr32_f64_cmp_ge+0x52>
8000af74:	58 08       	cp.w	r8,0
8000af76:	fc 09 13 00 	cpc	r9,lr
8000af7a:	e0 8b 00 18 	brhi	8000afaa <__avr32_f64_cmp_ge+0x52>
8000af7e:	58 0b       	cp.w	r11,0
8000af80:	f5 ba 00 00 	subfeq	r10,0
8000af84:	c1 50       	breq	8000afae <__avr32_f64_cmp_ge+0x56>
8000af86:	1b 07       	ld.w	r7,sp++
8000af88:	1b 0e       	ld.w	lr,sp++
8000af8a:	58 3c       	cp.w	r12,3
8000af8c:	c0 a0       	breq	8000afa0 <__avr32_f64_cmp_ge+0x48>
8000af8e:	58 1c       	cp.w	r12,1
8000af90:	c0 33       	brcs	8000af96 <__avr32_f64_cmp_ge+0x3e>
8000af92:	5e 0f       	reteq	1
8000af94:	5e 1d       	retne	0
8000af96:	10 3a       	cp.w	r10,r8
8000af98:	f2 0b 13 00 	cpc	r11,r9
8000af9c:	5e 2f       	reths	1
8000af9e:	5e 3d       	retlo	0
8000afa0:	14 38       	cp.w	r8,r10
8000afa2:	f6 09 13 00 	cpc	r9,r11
8000afa6:	5e 2f       	reths	1
8000afa8:	5e 3d       	retlo	0
8000afaa:	1b 07       	ld.w	r7,sp++
8000afac:	d8 0a       	popm	pc,r12=0
8000afae:	58 17       	cp.w	r7,1
8000afb0:	5f 0c       	sreq	r12
8000afb2:	58 09       	cp.w	r9,0
8000afb4:	f5 b8 00 00 	subfeq	r8,0
8000afb8:	1b 07       	ld.w	r7,sp++
8000afba:	1b 0e       	ld.w	lr,sp++
8000afbc:	5e 0f       	reteq	1
8000afbe:	5e fc       	retal	r12

8000afc0 <__avr32_f64_cmp_lt>:
8000afc0:	1a de       	st.w	--sp,lr
8000afc2:	1a d7       	st.w	--sp,r7
8000afc4:	a1 7b       	lsl	r11,0x1
8000afc6:	5f 3c       	srlo	r12
8000afc8:	a1 79       	lsl	r9,0x1
8000afca:	5f 37       	srlo	r7
8000afcc:	5c fc       	rol	r12
8000afce:	fc 1e ff e0 	movh	lr,0xffe0
8000afd2:	58 0a       	cp.w	r10,0
8000afd4:	fc 0b 13 00 	cpc	r11,lr
8000afd8:	e0 8b 00 1d 	brhi	8000b012 <__avr32_f64_cmp_lt+0x52>
8000afdc:	58 08       	cp.w	r8,0
8000afde:	fc 09 13 00 	cpc	r9,lr
8000afe2:	e0 8b 00 18 	brhi	8000b012 <__avr32_f64_cmp_lt+0x52>
8000afe6:	58 0b       	cp.w	r11,0
8000afe8:	f5 ba 00 00 	subfeq	r10,0
8000afec:	c1 50       	breq	8000b016 <__avr32_f64_cmp_lt+0x56>
8000afee:	1b 07       	ld.w	r7,sp++
8000aff0:	1b 0e       	ld.w	lr,sp++
8000aff2:	58 3c       	cp.w	r12,3
8000aff4:	c0 a0       	breq	8000b008 <__avr32_f64_cmp_lt+0x48>
8000aff6:	58 1c       	cp.w	r12,1
8000aff8:	c0 33       	brcs	8000affe <__avr32_f64_cmp_lt+0x3e>
8000affa:	5e 0d       	reteq	0
8000affc:	5e 1f       	retne	1
8000affe:	10 3a       	cp.w	r10,r8
8000b000:	f2 0b 13 00 	cpc	r11,r9
8000b004:	5e 2d       	reths	0
8000b006:	5e 3f       	retlo	1
8000b008:	14 38       	cp.w	r8,r10
8000b00a:	f6 09 13 00 	cpc	r9,r11
8000b00e:	5e 2d       	reths	0
8000b010:	5e 3f       	retlo	1
8000b012:	1b 07       	ld.w	r7,sp++
8000b014:	d8 0a       	popm	pc,r12=0
8000b016:	58 17       	cp.w	r7,1
8000b018:	5f 1c       	srne	r12
8000b01a:	58 09       	cp.w	r9,0
8000b01c:	f5 b8 00 00 	subfeq	r8,0
8000b020:	1b 07       	ld.w	r7,sp++
8000b022:	1b 0e       	ld.w	lr,sp++
8000b024:	5e 0d       	reteq	0
8000b026:	5e fc       	retal	r12

8000b028 <__avr32_f64_div>:
8000b028:	eb cd 40 ff 	pushm	r0-r7,lr
8000b02c:	f7 e9 20 0e 	eor	lr,r11,r9
8000b030:	f6 07 16 14 	lsr	r7,r11,0x14
8000b034:	a9 7b       	lsl	r11,0x9
8000b036:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000b03a:	a9 7a       	lsl	r10,0x9
8000b03c:	bd bb       	sbr	r11,0x1d
8000b03e:	e4 1b 3f ff 	andh	r11,0x3fff
8000b042:	ab d7       	cbr	r7,0xb
8000b044:	e0 80 00 cc 	breq	8000b1dc <__avr32_f64_div_round_subnormal+0x54>
8000b048:	e0 47 07 ff 	cp.w	r7,2047
8000b04c:	e0 84 00 b5 	brge	8000b1b6 <__avr32_f64_div_round_subnormal+0x2e>
8000b050:	f2 06 16 14 	lsr	r6,r9,0x14
8000b054:	a9 79       	lsl	r9,0x9
8000b056:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000b05a:	a9 78       	lsl	r8,0x9
8000b05c:	bd b9       	sbr	r9,0x1d
8000b05e:	e4 19 3f ff 	andh	r9,0x3fff
8000b062:	ab d6       	cbr	r6,0xb
8000b064:	e0 80 00 e2 	breq	8000b228 <__avr32_f64_div_round_subnormal+0xa0>
8000b068:	e0 46 07 ff 	cp.w	r6,2047
8000b06c:	e0 84 00 b2 	brge	8000b1d0 <__avr32_f64_div_round_subnormal+0x48>
8000b070:	0c 17       	sub	r7,r6
8000b072:	fe 37 fc 01 	sub	r7,-1023
8000b076:	fc 1c 80 00 	movh	r12,0x8000
8000b07a:	f8 03 16 01 	lsr	r3,r12,0x1
8000b07e:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000b082:	5c d4       	com	r4
8000b084:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000b088:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b08c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b090:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b094:	ea 03 15 02 	lsl	r3,r5,0x2
8000b098:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b09c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b0a0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b0a4:	ea 03 15 02 	lsl	r3,r5,0x2
8000b0a8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b0ac:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b0b0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b0b4:	ea 03 15 02 	lsl	r3,r5,0x2
8000b0b8:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b0bc:	e4 09 07 40 	macu.d	r0,r2,r9
8000b0c0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b0c4:	02 04       	add	r4,r1
8000b0c6:	5c 05       	acr	r5
8000b0c8:	a3 65       	lsl	r5,0x2
8000b0ca:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b0ce:	a3 64       	lsl	r4,0x2
8000b0d0:	5c 34       	neg	r4
8000b0d2:	f8 05 01 45 	sbc	r5,r12,r5
8000b0d6:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b0da:	e4 05 07 40 	macu.d	r0,r2,r5
8000b0de:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b0e2:	02 04       	add	r4,r1
8000b0e4:	5c 05       	acr	r5
8000b0e6:	ea 03 15 02 	lsl	r3,r5,0x2
8000b0ea:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b0ee:	e8 02 15 02 	lsl	r2,r4,0x2
8000b0f2:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b0f6:	e4 09 07 40 	macu.d	r0,r2,r9
8000b0fa:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b0fe:	02 04       	add	r4,r1
8000b100:	5c 05       	acr	r5
8000b102:	a3 65       	lsl	r5,0x2
8000b104:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b108:	a3 64       	lsl	r4,0x2
8000b10a:	5c 34       	neg	r4
8000b10c:	f8 05 01 45 	sbc	r5,r12,r5
8000b110:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b114:	e4 05 07 40 	macu.d	r0,r2,r5
8000b118:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b11c:	02 04       	add	r4,r1
8000b11e:	5c 05       	acr	r5
8000b120:	ea 03 15 02 	lsl	r3,r5,0x2
8000b124:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b128:	e8 02 15 02 	lsl	r2,r4,0x2
8000b12c:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000b130:	e4 0b 07 40 	macu.d	r0,r2,r11
8000b134:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000b138:	02 02       	add	r2,r1
8000b13a:	5c 03       	acr	r3
8000b13c:	ed b3 00 1c 	bld	r3,0x1c
8000b140:	c0 90       	breq	8000b152 <__avr32_f64_div+0x12a>
8000b142:	a1 72       	lsl	r2,0x1
8000b144:	5c f3       	rol	r3
8000b146:	20 17       	sub	r7,1
8000b148:	a3 9a       	lsr	r10,0x3
8000b14a:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000b14e:	a3 9b       	lsr	r11,0x3
8000b150:	c0 58       	rjmp	8000b15a <__avr32_f64_div+0x132>
8000b152:	a5 8a       	lsr	r10,0x4
8000b154:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000b158:	a5 8b       	lsr	r11,0x4
8000b15a:	58 07       	cp.w	r7,0
8000b15c:	e0 8a 00 8b 	brle	8000b272 <__avr32_f64_div_res_subnormal>
8000b160:	e0 12 ff 00 	andl	r2,0xff00
8000b164:	e8 12 00 80 	orl	r2,0x80
8000b168:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b16c:	e4 09 07 40 	macu.d	r0,r2,r9
8000b170:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b174:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b178:	00 05       	add	r5,r0
8000b17a:	f0 01 00 48 	adc	r8,r8,r1
8000b17e:	5c 09       	acr	r9
8000b180:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b184:	58 04       	cp.w	r4,0
8000b186:	5c 25       	cpc	r5

8000b188 <__avr32_f64_div_round_subnormal>:
8000b188:	f4 08 13 00 	cpc	r8,r10
8000b18c:	f6 09 13 00 	cpc	r9,r11
8000b190:	5f 36       	srlo	r6
8000b192:	f8 06 17 00 	moveq	r6,r12
8000b196:	e4 0a 16 08 	lsr	r10,r2,0x8
8000b19a:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000b19e:	e6 0b 16 08 	lsr	r11,r3,0x8
8000b1a2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b1a6:	ed be 00 1f 	bld	lr,0x1f
8000b1aa:	ef bb 00 1f 	bst	r11,0x1f
8000b1ae:	0c 0a       	add	r10,r6
8000b1b0:	5c 0b       	acr	r11
8000b1b2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b1b6:	e4 1b 00 0f 	andh	r11,0xf
8000b1ba:	14 4b       	or	r11,r10
8000b1bc:	e0 81 00 a7 	brne	8000b30a <__avr32_f64_div_res_subnormal+0x98>
8000b1c0:	f2 06 16 14 	lsr	r6,r9,0x14
8000b1c4:	ab d6       	cbr	r6,0xb
8000b1c6:	e0 46 07 ff 	cp.w	r6,2047
8000b1ca:	e0 81 00 a4 	brne	8000b312 <__avr32_f64_div_res_subnormal+0xa0>
8000b1ce:	c9 e8       	rjmp	8000b30a <__avr32_f64_div_res_subnormal+0x98>
8000b1d0:	e4 19 00 0f 	andh	r9,0xf
8000b1d4:	10 49       	or	r9,r8
8000b1d6:	e0 81 00 9a 	brne	8000b30a <__avr32_f64_div_res_subnormal+0x98>
8000b1da:	c9 28       	rjmp	8000b2fe <__avr32_f64_div_res_subnormal+0x8c>
8000b1dc:	a3 7b       	lsl	r11,0x3
8000b1de:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000b1e2:	a3 7a       	lsl	r10,0x3
8000b1e4:	f5 eb 10 04 	or	r4,r10,r11
8000b1e8:	e0 80 00 a0 	breq	8000b328 <__avr32_f64_div_op1_zero>
8000b1ec:	f6 04 12 00 	clz	r4,r11
8000b1f0:	c1 70       	breq	8000b21e <__avr32_f64_div_round_subnormal+0x96>
8000b1f2:	c0 c3       	brcs	8000b20a <__avr32_f64_div_round_subnormal+0x82>
8000b1f4:	e8 05 11 20 	rsub	r5,r4,32
8000b1f8:	f6 04 09 4b 	lsl	r11,r11,r4
8000b1fc:	f4 05 0a 45 	lsr	r5,r10,r5
8000b200:	0a 4b       	or	r11,r5
8000b202:	f4 04 09 4a 	lsl	r10,r10,r4
8000b206:	08 17       	sub	r7,r4
8000b208:	c0 b8       	rjmp	8000b21e <__avr32_f64_div_round_subnormal+0x96>
8000b20a:	f4 04 12 00 	clz	r4,r10
8000b20e:	f9 b4 03 00 	movlo	r4,0
8000b212:	f7 b4 02 e0 	subhs	r4,-32
8000b216:	f4 04 09 4b 	lsl	r11,r10,r4
8000b21a:	30 0a       	mov	r10,0
8000b21c:	08 17       	sub	r7,r4
8000b21e:	a3 8a       	lsr	r10,0x2
8000b220:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000b224:	a3 8b       	lsr	r11,0x2
8000b226:	c1 1b       	rjmp	8000b048 <__avr32_f64_div+0x20>
8000b228:	a3 79       	lsl	r9,0x3
8000b22a:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000b22e:	a3 78       	lsl	r8,0x3
8000b230:	f3 e8 10 04 	or	r4,r9,r8
8000b234:	c6 f0       	breq	8000b312 <__avr32_f64_div_res_subnormal+0xa0>
8000b236:	f2 04 12 00 	clz	r4,r9
8000b23a:	c1 70       	breq	8000b268 <__avr32_f64_div_round_subnormal+0xe0>
8000b23c:	c0 c3       	brcs	8000b254 <__avr32_f64_div_round_subnormal+0xcc>
8000b23e:	e8 05 11 20 	rsub	r5,r4,32
8000b242:	f2 04 09 49 	lsl	r9,r9,r4
8000b246:	f0 05 0a 45 	lsr	r5,r8,r5
8000b24a:	0a 49       	or	r9,r5
8000b24c:	f0 04 09 48 	lsl	r8,r8,r4
8000b250:	08 16       	sub	r6,r4
8000b252:	c0 b8       	rjmp	8000b268 <__avr32_f64_div_round_subnormal+0xe0>
8000b254:	f0 04 12 00 	clz	r4,r8
8000b258:	f9 b4 03 00 	movlo	r4,0
8000b25c:	f7 b4 02 e0 	subhs	r4,-32
8000b260:	f0 04 09 49 	lsl	r9,r8,r4
8000b264:	30 08       	mov	r8,0
8000b266:	08 16       	sub	r6,r4
8000b268:	a3 88       	lsr	r8,0x2
8000b26a:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000b26e:	a3 89       	lsr	r9,0x2
8000b270:	cf ca       	rjmp	8000b068 <__avr32_f64_div+0x40>

8000b272 <__avr32_f64_div_res_subnormal>:
8000b272:	5c 37       	neg	r7
8000b274:	2f f7       	sub	r7,-1
8000b276:	f1 b7 04 c0 	satu	r7,0x6
8000b27a:	e0 47 00 20 	cp.w	r7,32
8000b27e:	c1 54       	brge	8000b2a8 <__avr32_f64_div_res_subnormal+0x36>
8000b280:	ee 06 11 20 	rsub	r6,r7,32
8000b284:	e4 07 0a 42 	lsr	r2,r2,r7
8000b288:	e6 06 09 4c 	lsl	r12,r3,r6
8000b28c:	18 42       	or	r2,r12
8000b28e:	e6 07 0a 43 	lsr	r3,r3,r7
8000b292:	f4 06 09 41 	lsl	r1,r10,r6
8000b296:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b29a:	f6 06 09 4c 	lsl	r12,r11,r6
8000b29e:	18 4a       	or	r10,r12
8000b2a0:	f6 07 0a 4b 	lsr	r11,r11,r7
8000b2a4:	30 00       	mov	r0,0
8000b2a6:	c1 58       	rjmp	8000b2d0 <__avr32_f64_div_res_subnormal+0x5e>
8000b2a8:	ee 06 11 20 	rsub	r6,r7,32
8000b2ac:	f9 b0 00 00 	moveq	r0,0
8000b2b0:	f9 bc 00 00 	moveq	r12,0
8000b2b4:	c0 50       	breq	8000b2be <__avr32_f64_div_res_subnormal+0x4c>
8000b2b6:	f4 06 09 40 	lsl	r0,r10,r6
8000b2ba:	f6 06 09 4c 	lsl	r12,r11,r6
8000b2be:	e6 07 0a 42 	lsr	r2,r3,r7
8000b2c2:	30 03       	mov	r3,0
8000b2c4:	f4 07 0a 41 	lsr	r1,r10,r7
8000b2c8:	18 41       	or	r1,r12
8000b2ca:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b2ce:	30 0b       	mov	r11,0
8000b2d0:	e0 12 ff 00 	andl	r2,0xff00
8000b2d4:	e8 12 00 80 	orl	r2,0x80
8000b2d8:	e6 08 06 46 	mulu.d	r6,r3,r8
8000b2dc:	e4 09 07 46 	macu.d	r6,r2,r9
8000b2e0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b2e4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b2e8:	0c 05       	add	r5,r6
8000b2ea:	f0 07 00 48 	adc	r8,r8,r7
8000b2ee:	5c 09       	acr	r9
8000b2f0:	30 07       	mov	r7,0
8000b2f2:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b2f6:	00 34       	cp.w	r4,r0
8000b2f8:	e2 05 13 00 	cpc	r5,r1
8000b2fc:	c4 6b       	rjmp	8000b188 <__avr32_f64_div_round_subnormal>
8000b2fe:	1c 9b       	mov	r11,lr
8000b300:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b304:	30 0a       	mov	r10,0
8000b306:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b30a:	3f fb       	mov	r11,-1
8000b30c:	30 0a       	mov	r10,0
8000b30e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b312:	f5 eb 10 04 	or	r4,r10,r11
8000b316:	c0 90       	breq	8000b328 <__avr32_f64_div_op1_zero>
8000b318:	1c 9b       	mov	r11,lr
8000b31a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b31e:	ea 1b 7f f0 	orh	r11,0x7ff0
8000b322:	30 0a       	mov	r10,0
8000b324:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000b328 <__avr32_f64_div_op1_zero>:
8000b328:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000b32c:	ce f0       	breq	8000b30a <__avr32_f64_div_res_subnormal+0x98>
8000b32e:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000b332:	e0 44 07 ff 	cp.w	r4,2047
8000b336:	ce 41       	brne	8000b2fe <__avr32_f64_div_res_subnormal+0x8c>
8000b338:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000b33c:	ce 10       	breq	8000b2fe <__avr32_f64_div_res_subnormal+0x8c>
8000b33e:	ce 6b       	rjmp	8000b30a <__avr32_f64_div_res_subnormal+0x98>

8000b340 <__avr32_udiv64>:
8000b340:	d4 31       	pushm	r0-r7,lr
8000b342:	1a 97       	mov	r7,sp
8000b344:	20 3d       	sub	sp,12
8000b346:	10 9c       	mov	r12,r8
8000b348:	12 9e       	mov	lr,r9
8000b34a:	14 93       	mov	r3,r10
8000b34c:	58 09       	cp.w	r9,0
8000b34e:	e0 81 00 bd 	brne	8000b4c8 <__avr32_udiv64+0x188>
8000b352:	16 38       	cp.w	r8,r11
8000b354:	e0 88 00 40 	brls	8000b3d4 <__avr32_udiv64+0x94>
8000b358:	f0 08 12 00 	clz	r8,r8
8000b35c:	c0 d0       	breq	8000b376 <__avr32_udiv64+0x36>
8000b35e:	f6 08 09 4b 	lsl	r11,r11,r8
8000b362:	f0 09 11 20 	rsub	r9,r8,32
8000b366:	f8 08 09 4c 	lsl	r12,r12,r8
8000b36a:	f4 09 0a 49 	lsr	r9,r10,r9
8000b36e:	f4 08 09 43 	lsl	r3,r10,r8
8000b372:	f3 eb 10 0b 	or	r11,r9,r11
8000b376:	f8 0e 16 10 	lsr	lr,r12,0x10
8000b37a:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000b37e:	f6 0e 0d 00 	divu	r0,r11,lr
8000b382:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b386:	00 99       	mov	r9,r0
8000b388:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b38c:	e0 0a 02 48 	mul	r8,r0,r10
8000b390:	10 3b       	cp.w	r11,r8
8000b392:	c0 a2       	brcc	8000b3a6 <__avr32_udiv64+0x66>
8000b394:	20 19       	sub	r9,1
8000b396:	18 0b       	add	r11,r12
8000b398:	18 3b       	cp.w	r11,r12
8000b39a:	c0 63       	brcs	8000b3a6 <__avr32_udiv64+0x66>
8000b39c:	10 3b       	cp.w	r11,r8
8000b39e:	f7 b9 03 01 	sublo	r9,1
8000b3a2:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b3a6:	f6 08 01 01 	sub	r1,r11,r8
8000b3aa:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000b3ae:	e2 0e 0d 00 	divu	r0,r1,lr
8000b3b2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000b3b6:	00 98       	mov	r8,r0
8000b3b8:	e0 0a 02 4a 	mul	r10,r0,r10
8000b3bc:	14 33       	cp.w	r3,r10
8000b3be:	c0 82       	brcc	8000b3ce <__avr32_udiv64+0x8e>
8000b3c0:	20 18       	sub	r8,1
8000b3c2:	18 03       	add	r3,r12
8000b3c4:	18 33       	cp.w	r3,r12
8000b3c6:	c0 43       	brcs	8000b3ce <__avr32_udiv64+0x8e>
8000b3c8:	14 33       	cp.w	r3,r10
8000b3ca:	f7 b8 03 01 	sublo	r8,1
8000b3ce:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000b3d2:	cd f8       	rjmp	8000b590 <__avr32_udiv64+0x250>
8000b3d4:	58 08       	cp.w	r8,0
8000b3d6:	c0 51       	brne	8000b3e0 <__avr32_udiv64+0xa0>
8000b3d8:	30 19       	mov	r9,1
8000b3da:	f2 08 0d 08 	divu	r8,r9,r8
8000b3de:	10 9c       	mov	r12,r8
8000b3e0:	f8 06 12 00 	clz	r6,r12
8000b3e4:	c0 41       	brne	8000b3ec <__avr32_udiv64+0xac>
8000b3e6:	18 1b       	sub	r11,r12
8000b3e8:	30 19       	mov	r9,1
8000b3ea:	c4 08       	rjmp	8000b46a <__avr32_udiv64+0x12a>
8000b3ec:	ec 01 11 20 	rsub	r1,r6,32
8000b3f0:	f4 01 0a 49 	lsr	r9,r10,r1
8000b3f4:	f8 06 09 4c 	lsl	r12,r12,r6
8000b3f8:	f6 06 09 48 	lsl	r8,r11,r6
8000b3fc:	f6 01 0a 41 	lsr	r1,r11,r1
8000b400:	f3 e8 10 08 	or	r8,r9,r8
8000b404:	f8 03 16 10 	lsr	r3,r12,0x10
8000b408:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000b40c:	e2 03 0d 00 	divu	r0,r1,r3
8000b410:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b414:	00 9e       	mov	lr,r0
8000b416:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b41a:	e0 05 02 49 	mul	r9,r0,r5
8000b41e:	12 3b       	cp.w	r11,r9
8000b420:	c0 a2       	brcc	8000b434 <__avr32_udiv64+0xf4>
8000b422:	20 1e       	sub	lr,1
8000b424:	18 0b       	add	r11,r12
8000b426:	18 3b       	cp.w	r11,r12
8000b428:	c0 63       	brcs	8000b434 <__avr32_udiv64+0xf4>
8000b42a:	12 3b       	cp.w	r11,r9
8000b42c:	f7 be 03 01 	sublo	lr,1
8000b430:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b434:	12 1b       	sub	r11,r9
8000b436:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000b43a:	f6 03 0d 02 	divu	r2,r11,r3
8000b43e:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000b442:	04 99       	mov	r9,r2
8000b444:	e4 05 02 4b 	mul	r11,r2,r5
8000b448:	16 38       	cp.w	r8,r11
8000b44a:	c0 a2       	brcc	8000b45e <__avr32_udiv64+0x11e>
8000b44c:	20 19       	sub	r9,1
8000b44e:	18 08       	add	r8,r12
8000b450:	18 38       	cp.w	r8,r12
8000b452:	c0 63       	brcs	8000b45e <__avr32_udiv64+0x11e>
8000b454:	16 38       	cp.w	r8,r11
8000b456:	f7 b9 03 01 	sublo	r9,1
8000b45a:	f1 dc e3 08 	addcs	r8,r8,r12
8000b45e:	f4 06 09 43 	lsl	r3,r10,r6
8000b462:	f0 0b 01 0b 	sub	r11,r8,r11
8000b466:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000b46a:	f8 06 16 10 	lsr	r6,r12,0x10
8000b46e:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000b472:	f6 06 0d 00 	divu	r0,r11,r6
8000b476:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b47a:	00 9a       	mov	r10,r0
8000b47c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b480:	e0 0e 02 48 	mul	r8,r0,lr
8000b484:	10 3b       	cp.w	r11,r8
8000b486:	c0 a2       	brcc	8000b49a <__avr32_udiv64+0x15a>
8000b488:	20 1a       	sub	r10,1
8000b48a:	18 0b       	add	r11,r12
8000b48c:	18 3b       	cp.w	r11,r12
8000b48e:	c0 63       	brcs	8000b49a <__avr32_udiv64+0x15a>
8000b490:	10 3b       	cp.w	r11,r8
8000b492:	f7 ba 03 01 	sublo	r10,1
8000b496:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b49a:	f6 08 01 01 	sub	r1,r11,r8
8000b49e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000b4a2:	e2 06 0d 00 	divu	r0,r1,r6
8000b4a6:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000b4aa:	00 98       	mov	r8,r0
8000b4ac:	e0 0e 02 4b 	mul	r11,r0,lr
8000b4b0:	16 33       	cp.w	r3,r11
8000b4b2:	c0 82       	brcc	8000b4c2 <__avr32_udiv64+0x182>
8000b4b4:	20 18       	sub	r8,1
8000b4b6:	18 03       	add	r3,r12
8000b4b8:	18 33       	cp.w	r3,r12
8000b4ba:	c0 43       	brcs	8000b4c2 <__avr32_udiv64+0x182>
8000b4bc:	16 33       	cp.w	r3,r11
8000b4be:	f7 b8 03 01 	sublo	r8,1
8000b4c2:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000b4c6:	c6 98       	rjmp	8000b598 <__avr32_udiv64+0x258>
8000b4c8:	16 39       	cp.w	r9,r11
8000b4ca:	e0 8b 00 65 	brhi	8000b594 <__avr32_udiv64+0x254>
8000b4ce:	f2 09 12 00 	clz	r9,r9
8000b4d2:	c0 b1       	brne	8000b4e8 <__avr32_udiv64+0x1a8>
8000b4d4:	10 3a       	cp.w	r10,r8
8000b4d6:	5f 2a       	srhs	r10
8000b4d8:	1c 3b       	cp.w	r11,lr
8000b4da:	5f b8       	srhi	r8
8000b4dc:	10 4a       	or	r10,r8
8000b4de:	f2 0a 18 00 	cp.b	r10,r9
8000b4e2:	c5 90       	breq	8000b594 <__avr32_udiv64+0x254>
8000b4e4:	30 18       	mov	r8,1
8000b4e6:	c5 98       	rjmp	8000b598 <__avr32_udiv64+0x258>
8000b4e8:	f0 09 09 46 	lsl	r6,r8,r9
8000b4ec:	f2 03 11 20 	rsub	r3,r9,32
8000b4f0:	fc 09 09 4e 	lsl	lr,lr,r9
8000b4f4:	f0 03 0a 48 	lsr	r8,r8,r3
8000b4f8:	f6 09 09 4c 	lsl	r12,r11,r9
8000b4fc:	f4 03 0a 42 	lsr	r2,r10,r3
8000b500:	ef 46 ff f4 	st.w	r7[-12],r6
8000b504:	f6 03 0a 43 	lsr	r3,r11,r3
8000b508:	18 42       	or	r2,r12
8000b50a:	f1 ee 10 0c 	or	r12,r8,lr
8000b50e:	f8 01 16 10 	lsr	r1,r12,0x10
8000b512:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000b516:	e6 01 0d 04 	divu	r4,r3,r1
8000b51a:	e4 03 16 10 	lsr	r3,r2,0x10
8000b51e:	08 9e       	mov	lr,r4
8000b520:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000b524:	e8 06 02 48 	mul	r8,r4,r6
8000b528:	10 33       	cp.w	r3,r8
8000b52a:	c0 a2       	brcc	8000b53e <__avr32_udiv64+0x1fe>
8000b52c:	20 1e       	sub	lr,1
8000b52e:	18 03       	add	r3,r12
8000b530:	18 33       	cp.w	r3,r12
8000b532:	c0 63       	brcs	8000b53e <__avr32_udiv64+0x1fe>
8000b534:	10 33       	cp.w	r3,r8
8000b536:	f7 be 03 01 	sublo	lr,1
8000b53a:	e7 dc e3 03 	addcs	r3,r3,r12
8000b53e:	10 13       	sub	r3,r8
8000b540:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000b544:	e6 01 0d 00 	divu	r0,r3,r1
8000b548:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b54c:	00 98       	mov	r8,r0
8000b54e:	e0 06 02 46 	mul	r6,r0,r6
8000b552:	0c 3b       	cp.w	r11,r6
8000b554:	c0 a2       	brcc	8000b568 <__avr32_udiv64+0x228>
8000b556:	20 18       	sub	r8,1
8000b558:	18 0b       	add	r11,r12
8000b55a:	18 3b       	cp.w	r11,r12
8000b55c:	c0 63       	brcs	8000b568 <__avr32_udiv64+0x228>
8000b55e:	0c 3b       	cp.w	r11,r6
8000b560:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b564:	f7 b8 03 01 	sublo	r8,1
8000b568:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000b56c:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000b570:	0c 1b       	sub	r11,r6
8000b572:	f0 04 06 42 	mulu.d	r2,r8,r4
8000b576:	06 95       	mov	r5,r3
8000b578:	16 35       	cp.w	r5,r11
8000b57a:	e0 8b 00 0a 	brhi	8000b58e <__avr32_udiv64+0x24e>
8000b57e:	5f 0b       	sreq	r11
8000b580:	f4 09 09 49 	lsl	r9,r10,r9
8000b584:	12 32       	cp.w	r2,r9
8000b586:	5f b9       	srhi	r9
8000b588:	f7 e9 00 09 	and	r9,r11,r9
8000b58c:	c0 60       	breq	8000b598 <__avr32_udiv64+0x258>
8000b58e:	20 18       	sub	r8,1
8000b590:	30 09       	mov	r9,0
8000b592:	c0 38       	rjmp	8000b598 <__avr32_udiv64+0x258>
8000b594:	30 09       	mov	r9,0
8000b596:	12 98       	mov	r8,r9
8000b598:	10 9a       	mov	r10,r8
8000b59a:	12 93       	mov	r3,r9
8000b59c:	10 92       	mov	r2,r8
8000b59e:	12 9b       	mov	r11,r9
8000b5a0:	2f dd       	sub	sp,-12
8000b5a2:	d8 32       	popm	r0-r7,pc

8000b5a4 <__avr32_umod64>:
8000b5a4:	d4 31       	pushm	r0-r7,lr
8000b5a6:	1a 97       	mov	r7,sp
8000b5a8:	20 3d       	sub	sp,12
8000b5aa:	10 9c       	mov	r12,r8
8000b5ac:	12 95       	mov	r5,r9
8000b5ae:	14 9e       	mov	lr,r10
8000b5b0:	16 91       	mov	r1,r11
8000b5b2:	16 96       	mov	r6,r11
8000b5b4:	58 09       	cp.w	r9,0
8000b5b6:	e0 81 00 81 	brne	8000b6b8 <__avr32_umod64+0x114>
8000b5ba:	16 38       	cp.w	r8,r11
8000b5bc:	e0 88 00 12 	brls	8000b5e0 <__avr32_umod64+0x3c>
8000b5c0:	f0 08 12 00 	clz	r8,r8
8000b5c4:	c4 e0       	breq	8000b660 <__avr32_umod64+0xbc>
8000b5c6:	f6 08 09 46 	lsl	r6,r11,r8
8000b5ca:	f8 08 09 4c 	lsl	r12,r12,r8
8000b5ce:	f0 0b 11 20 	rsub	r11,r8,32
8000b5d2:	f4 08 09 4e 	lsl	lr,r10,r8
8000b5d6:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000b5da:	f7 e6 10 06 	or	r6,r11,r6
8000b5de:	c4 18       	rjmp	8000b660 <__avr32_umod64+0xbc>
8000b5e0:	58 08       	cp.w	r8,0
8000b5e2:	c0 51       	brne	8000b5ec <__avr32_umod64+0x48>
8000b5e4:	30 19       	mov	r9,1
8000b5e6:	f2 08 0d 08 	divu	r8,r9,r8
8000b5ea:	10 9c       	mov	r12,r8
8000b5ec:	f8 08 12 00 	clz	r8,r12
8000b5f0:	c0 31       	brne	8000b5f6 <__avr32_umod64+0x52>
8000b5f2:	18 16       	sub	r6,r12
8000b5f4:	c3 68       	rjmp	8000b660 <__avr32_umod64+0xbc>
8000b5f6:	f0 03 11 20 	rsub	r3,r8,32
8000b5fa:	f4 03 0a 4b 	lsr	r11,r10,r3
8000b5fe:	f8 08 09 4c 	lsl	r12,r12,r8
8000b602:	ec 08 09 49 	lsl	r9,r6,r8
8000b606:	ec 03 0a 43 	lsr	r3,r6,r3
8000b60a:	f7 e9 10 09 	or	r9,r11,r9
8000b60e:	f8 05 16 10 	lsr	r5,r12,0x10
8000b612:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000b616:	e6 05 0d 02 	divu	r2,r3,r5
8000b61a:	f2 0e 16 10 	lsr	lr,r9,0x10
8000b61e:	ec 02 02 4b 	mul	r11,r6,r2
8000b622:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000b626:	16 3e       	cp.w	lr,r11
8000b628:	c0 72       	brcc	8000b636 <__avr32_umod64+0x92>
8000b62a:	18 0e       	add	lr,r12
8000b62c:	18 3e       	cp.w	lr,r12
8000b62e:	c0 43       	brcs	8000b636 <__avr32_umod64+0x92>
8000b630:	16 3e       	cp.w	lr,r11
8000b632:	fd dc e3 0e 	addcs	lr,lr,r12
8000b636:	fc 0b 01 03 	sub	r3,lr,r11
8000b63a:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000b63e:	e6 05 0d 02 	divu	r2,r3,r5
8000b642:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000b646:	a5 36       	mul	r6,r2
8000b648:	0c 39       	cp.w	r9,r6
8000b64a:	c0 72       	brcc	8000b658 <__avr32_umod64+0xb4>
8000b64c:	18 09       	add	r9,r12
8000b64e:	18 39       	cp.w	r9,r12
8000b650:	c0 43       	brcs	8000b658 <__avr32_umod64+0xb4>
8000b652:	0c 39       	cp.w	r9,r6
8000b654:	f3 dc e3 09 	addcs	r9,r9,r12
8000b658:	f2 06 01 06 	sub	r6,r9,r6
8000b65c:	f4 08 09 4e 	lsl	lr,r10,r8
8000b660:	f8 0a 16 10 	lsr	r10,r12,0x10
8000b664:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000b668:	ec 0a 0d 02 	divu	r2,r6,r10
8000b66c:	fc 09 16 10 	lsr	r9,lr,0x10
8000b670:	ea 02 02 4b 	mul	r11,r5,r2
8000b674:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000b678:	16 39       	cp.w	r9,r11
8000b67a:	c0 72       	brcc	8000b688 <__avr32_umod64+0xe4>
8000b67c:	18 09       	add	r9,r12
8000b67e:	18 39       	cp.w	r9,r12
8000b680:	c0 43       	brcs	8000b688 <__avr32_umod64+0xe4>
8000b682:	16 39       	cp.w	r9,r11
8000b684:	f3 dc e3 09 	addcs	r9,r9,r12
8000b688:	f2 0b 01 0b 	sub	r11,r9,r11
8000b68c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b690:	f6 0a 0d 0a 	divu	r10,r11,r10
8000b694:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000b698:	ea 0a 02 4a 	mul	r10,r5,r10
8000b69c:	14 3e       	cp.w	lr,r10
8000b69e:	c0 72       	brcc	8000b6ac <__avr32_umod64+0x108>
8000b6a0:	18 0e       	add	lr,r12
8000b6a2:	18 3e       	cp.w	lr,r12
8000b6a4:	c0 43       	brcs	8000b6ac <__avr32_umod64+0x108>
8000b6a6:	14 3e       	cp.w	lr,r10
8000b6a8:	fd dc e3 0e 	addcs	lr,lr,r12
8000b6ac:	fc 0a 01 0a 	sub	r10,lr,r10
8000b6b0:	30 0b       	mov	r11,0
8000b6b2:	f4 08 0a 4a 	lsr	r10,r10,r8
8000b6b6:	c7 b8       	rjmp	8000b7ac <__avr32_umod64+0x208>
8000b6b8:	16 39       	cp.w	r9,r11
8000b6ba:	e0 8b 00 79 	brhi	8000b7ac <__avr32_umod64+0x208>
8000b6be:	f2 09 12 00 	clz	r9,r9
8000b6c2:	c1 21       	brne	8000b6e6 <__avr32_umod64+0x142>
8000b6c4:	10 3a       	cp.w	r10,r8
8000b6c6:	5f 2b       	srhs	r11
8000b6c8:	0a 31       	cp.w	r1,r5
8000b6ca:	5f ba       	srhi	r10
8000b6cc:	f7 ea 10 0a 	or	r10,r11,r10
8000b6d0:	f2 0a 18 00 	cp.b	r10,r9
8000b6d4:	c0 60       	breq	8000b6e0 <__avr32_umod64+0x13c>
8000b6d6:	fc 08 01 0c 	sub	r12,lr,r8
8000b6da:	e2 05 01 46 	sbc	r6,r1,r5
8000b6de:	18 9e       	mov	lr,r12
8000b6e0:	0c 9b       	mov	r11,r6
8000b6e2:	1c 9a       	mov	r10,lr
8000b6e4:	c6 48       	rjmp	8000b7ac <__avr32_umod64+0x208>
8000b6e6:	ea 09 09 4c 	lsl	r12,r5,r9
8000b6ea:	f2 06 11 20 	rsub	r6,r9,32
8000b6ee:	f6 09 09 4b 	lsl	r11,r11,r9
8000b6f2:	f0 09 09 42 	lsl	r2,r8,r9
8000b6f6:	ef 46 ff f4 	st.w	r7[-12],r6
8000b6fa:	f0 06 0a 48 	lsr	r8,r8,r6
8000b6fe:	18 48       	or	r8,r12
8000b700:	e2 06 0a 4c 	lsr	r12,r1,r6
8000b704:	f4 09 09 43 	lsl	r3,r10,r9
8000b708:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000b70c:	f4 06 0a 4a 	lsr	r10,r10,r6
8000b710:	16 4a       	or	r10,r11
8000b712:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b716:	f8 0b 0d 04 	divu	r4,r12,r11
8000b71a:	f4 0c 16 10 	lsr	r12,r10,0x10
8000b71e:	08 91       	mov	r1,r4
8000b720:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000b724:	e8 0e 02 46 	mul	r6,r4,lr
8000b728:	0c 3c       	cp.w	r12,r6
8000b72a:	c0 a2       	brcc	8000b73e <__avr32_umod64+0x19a>
8000b72c:	20 11       	sub	r1,1
8000b72e:	10 0c       	add	r12,r8
8000b730:	10 3c       	cp.w	r12,r8
8000b732:	c0 63       	brcs	8000b73e <__avr32_umod64+0x19a>
8000b734:	0c 3c       	cp.w	r12,r6
8000b736:	f7 b1 03 01 	sublo	r1,1
8000b73a:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000b73e:	0c 1c       	sub	r12,r6
8000b740:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000b744:	f8 0b 0d 04 	divu	r4,r12,r11
8000b748:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000b74c:	08 96       	mov	r6,r4
8000b74e:	e8 0e 02 4e 	mul	lr,r4,lr
8000b752:	1c 3b       	cp.w	r11,lr
8000b754:	c0 a2       	brcc	8000b768 <__avr32_umod64+0x1c4>
8000b756:	20 16       	sub	r6,1
8000b758:	10 0b       	add	r11,r8
8000b75a:	10 3b       	cp.w	r11,r8
8000b75c:	c0 63       	brcs	8000b768 <__avr32_umod64+0x1c4>
8000b75e:	1c 3b       	cp.w	r11,lr
8000b760:	f7 b6 03 01 	sublo	r6,1
8000b764:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000b768:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000b76c:	1c 1b       	sub	r11,lr
8000b76e:	e2 02 06 40 	mulu.d	r0,r1,r2
8000b772:	00 9e       	mov	lr,r0
8000b774:	02 9c       	mov	r12,r1
8000b776:	16 3c       	cp.w	r12,r11
8000b778:	e0 8b 00 08 	brhi	8000b788 <__avr32_umod64+0x1e4>
8000b77c:	5f 06       	sreq	r6
8000b77e:	06 30       	cp.w	r0,r3
8000b780:	5f ba       	srhi	r10
8000b782:	ed ea 00 0a 	and	r10,r6,r10
8000b786:	c0 60       	breq	8000b792 <__avr32_umod64+0x1ee>
8000b788:	fc 02 01 04 	sub	r4,lr,r2
8000b78c:	f8 08 01 4c 	sbc	r12,r12,r8
8000b790:	08 9e       	mov	lr,r4
8000b792:	e6 0e 01 0a 	sub	r10,r3,lr
8000b796:	f6 0c 01 4c 	sbc	r12,r11,r12
8000b79a:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000b79e:	f8 09 0a 4b 	lsr	r11,r12,r9
8000b7a2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b7a6:	f8 01 09 4c 	lsl	r12,r12,r1
8000b7aa:	18 4a       	or	r10,r12
8000b7ac:	2f dd       	sub	sp,-12
8000b7ae:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000b800 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000b800:	c0 08       	rjmp	8000b800 <_evba>
	...

8000b804 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000b804:	c0 08       	rjmp	8000b804 <_handle_TLB_Multiple_Hit>
	...

8000b808 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000b808:	c0 08       	rjmp	8000b808 <_handle_Bus_Error_Data_Fetch>
	...

8000b80c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000b80c:	c0 08       	rjmp	8000b80c <_handle_Bus_Error_Instruction_Fetch>
	...

8000b810 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000b810:	c0 08       	rjmp	8000b810 <_handle_NMI>
	...

8000b814 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000b814:	c0 08       	rjmp	8000b814 <_handle_Instruction_Address>
	...

8000b818 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000b818:	c0 08       	rjmp	8000b818 <_handle_ITLB_Protection>
	...

8000b81c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000b81c:	c0 08       	rjmp	8000b81c <_handle_Breakpoint>
	...

8000b820 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000b820:	c0 08       	rjmp	8000b820 <_handle_Illegal_Opcode>
	...

8000b824 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000b824:	c0 08       	rjmp	8000b824 <_handle_Unimplemented_Instruction>
	...

8000b828 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000b828:	c0 08       	rjmp	8000b828 <_handle_Privilege_Violation>
	...

8000b82c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000b82c:	c0 08       	rjmp	8000b82c <_handle_Floating_Point>
	...

8000b830 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000b830:	c0 08       	rjmp	8000b830 <_handle_Coprocessor_Absent>
	...

8000b834 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000b834:	c0 08       	rjmp	8000b834 <_handle_Data_Address_Read>
	...

8000b838 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000b838:	c0 08       	rjmp	8000b838 <_handle_Data_Address_Write>
	...

8000b83c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000b83c:	c0 08       	rjmp	8000b83c <_handle_DTLB_Protection_Read>
	...

8000b840 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000b840:	c0 08       	rjmp	8000b840 <_handle_DTLB_Protection_Write>
	...

8000b844 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000b844:	c0 08       	rjmp	8000b844 <_handle_DTLB_Modified>
	...

8000b850 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000b850:	c0 08       	rjmp	8000b850 <_handle_ITLB_Miss>
	...

8000b860 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000b860:	c0 08       	rjmp	8000b860 <_handle_DTLB_Miss_Read>
	...

8000b870 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000b870:	c0 08       	rjmp	8000b870 <_handle_DTLB_Miss_Write>
	...

8000b900 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000b900:	fe cf 70 84 	sub	pc,pc,28804

8000b904 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000b904:	30 0c       	mov	r12,0
8000b906:	fe b0 c4 2f 	rcall	80004164 <_get_interrupt_handler>
8000b90a:	58 0c       	cp.w	r12,0
8000b90c:	f8 0f 17 10 	movne	pc,r12
8000b910:	d6 03       	rete

8000b912 <_int1>:
8000b912:	30 1c       	mov	r12,1
8000b914:	fe b0 c4 28 	rcall	80004164 <_get_interrupt_handler>
8000b918:	58 0c       	cp.w	r12,0
8000b91a:	f8 0f 17 10 	movne	pc,r12
8000b91e:	d6 03       	rete

8000b920 <_int2>:
8000b920:	30 2c       	mov	r12,2
8000b922:	fe b0 c4 21 	rcall	80004164 <_get_interrupt_handler>
8000b926:	58 0c       	cp.w	r12,0
8000b928:	f8 0f 17 10 	movne	pc,r12
8000b92c:	d6 03       	rete

8000b92e <_int3>:
8000b92e:	30 3c       	mov	r12,3
8000b930:	fe b0 c4 1a 	rcall	80004164 <_get_interrupt_handler>
8000b934:	58 0c       	cp.w	r12,0
8000b936:	f8 0f 17 10 	movne	pc,r12
8000b93a:	d6 03       	rete

8000b93c <ipr_val>:
8000b93c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000b94c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b95c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b96c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b97c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b98c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b99c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b9ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b9bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b9cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b9dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b9ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b9fc:	d7 03 d7 03                                         ....
