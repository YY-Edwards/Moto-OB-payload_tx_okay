
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000da40  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000fc00  8000fc00  00010000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00009670  8000fe00  8000fe00  00010200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a34  00000008  80019470  00019c08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a3c  80019ea4  0001a63c  2**0
                  ALLOC
  8 .bss          00003bf0  00000a40  00000a40  00000000  2**2
                  ALLOC
  9 .heap         000129d0  00004630  00004630  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  0001a63c  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001620  00000000  00000000  0001a670  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 00002ade  00000000  00000000  0001bc90  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0002ea31  00000000  00000000  0001e76e  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00007853  00000000  00000000  0004d19f  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000df8b  00000000  00000000  000549f2  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00003cdc  00000000  00000000  00062980  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00008011  00000000  00000000  0006665c  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    000120ab  00000000  00000000  0006e66d  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 20 .debug_ranges 00001718  00000000  00000000  00080718  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	9f c8       	st.w	pc[0x30],r8

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf 80 40 	sub	pc,pc,-32704

Disassembly of section .text:

8000200c <DeviceManagement_brdcst_func>:
8000200c:	19 a9       	ld.ub	r9,r12[0x2]
8000200e:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002010:	f0 09 18 00 	cp.b	r9,r8
80002014:	c0 61       	brne	80002020 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002016:	48 68       	lddpc	r8,8000202c <DeviceManagement_brdcst_func+0x20>
80002018:	70 09       	ld.w	r9,r8[0x0]
8000201a:	a1 b9       	sbr	r9,0x1
8000201c:	91 09       	st.w	r8[0x0],r9
8000201e:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002020:	48 38       	lddpc	r8,8000202c <DeviceManagement_brdcst_func+0x20>
80002022:	70 09       	ld.w	r9,r8[0x0]
80002024:	a1 d9       	cbr	r9,0x1
80002026:	91 09       	st.w	r8[0x0],r9
80002028:	5e fc       	retal	r12
8000202a:	00 00       	add	r0,r0
8000202c:	00 00       	add	r0,r0
8000202e:	12 cc       	st.b	r9++,r12

80002030 <mic_brdcst_func>:
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	//log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
	//log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
			
	
}
80002030:	5e fc       	retal	r12

80002032 <TransmitControl_brdcst_func>:
	//log("\n\r  State: %x \n\r ", ptr->State );
	//log("\n\r  State_change_reason: %x \n\r ", ptr->State_change_reason );
	//
	
	
}
80002032:	5e fc       	retal	r12

80002034 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002034:	48 38       	lddpc	r8,80002040 <vApplicationIdleHook+0xc>
80002036:	70 09       	ld.w	r9,r8[0x0]
80002038:	2f f9       	sub	r9,-1
8000203a:	91 09       	st.w	r8[0x0],r9
	
}
8000203c:	5e fc       	retal	r12
8000203e:	00 00       	add	r0,r0
80002040:	00 00       	add	r0,r0
80002042:	0a 58       	eor	r8,r5

80002044 <app_init>:
														
		
};

void app_init(void)
{	
80002044:	d4 01       	pushm	lr
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002046:	48 cb       	lddpc	r11,80002074 <app_init+0x30>
80002048:	48 cc       	lddpc	r12,80002078 <app_init+0x34>
8000204a:	f0 1f 00 0d 	mcall	8000207c <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204e:	48 dc       	lddpc	r12,80002080 <app_init+0x3c>
80002050:	f0 1f 00 0d 	mcall	80002084 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002054:	30 09       	mov	r9,0
80002056:	1a d9       	st.w	--sp,r9
80002058:	1a d9       	st.w	--sp,r9
8000205a:	1a d9       	st.w	--sp,r9
8000205c:	30 18       	mov	r8,1
8000205e:	e0 6a 01 80 	mov	r10,384
80002062:	48 ab       	lddpc	r11,80002088 <app_init+0x44>
80002064:	48 ac       	lddpc	r12,8000208c <app_init+0x48>
80002066:	f0 1f 00 0b 	mcall	80002090 <app_init+0x4c>
8000206a:	48 b8       	lddpc	r8,80002094 <app_init+0x50>
8000206c:	91 0c       	st.w	r8[0x0],r12
8000206e:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
80002070:	d8 02       	popm	pc
80002072:	00 00       	add	r0,r0
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 8c       	sub	r12,-120
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	28 b8       	sub	r8,-117
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	39 78       	mov	r8,-105
80002080:	00 00       	add	r0,r0
80002082:	00 08       	add	r8,r0
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	4e 00       	lddpc	r0,80002204 <ButtonConfig_brdcst_func+0x6c>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	fe 00       	*unknown*
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	27 cc       	sub	r12,124
80002090:	80 00       	ld.sh	r0,r0[0x0]
80002092:	96 fc       	ld.uh	r12,r11[0xe]
80002094:	00 00       	add	r0,r0
80002096:	0a 50       	eor	r0,r5

80002098 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002098:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000209a:	48 3c       	lddpc	r12,800020a4 <FD_brdcst_func+0xc>
8000209c:	f0 1f 00 03 	mcall	800020a8 <FD_brdcst_func+0x10>
	
}
800020a0:	d8 02       	popm	pc
800020a2:	00 00       	add	r0,r0
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	fe 08       	*unknown*
800020a8:	80 00       	ld.sh	r0,r0[0x0]
800020aa:	9a c0       	ld.uh	r0,sp[0x8]

800020ac <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ac:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ae:	48 3c       	lddpc	r12,800020b8 <FD_reply_func+0xc>
800020b0:	f0 1f 00 03 	mcall	800020bc <FD_reply_func+0x10>
	
	
}
800020b4:	d8 02       	popm	pc
800020b6:	00 00       	add	r0,r0
800020b8:	80 00       	ld.sh	r0,r0[0x0]
800020ba:	fe 28 80 00 	sub	r8,-98304
800020be:	9a c0       	ld.uh	r0,sp[0x8]

800020c0 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020c0:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020c2:	48 3c       	lddpc	r12,800020cc <FD_request_func+0xc>
800020c4:	f0 1f 00 03 	mcall	800020d0 <FD_request_func+0x10>
	
	
}
800020c8:	d8 02       	popm	pc
800020ca:	00 00       	add	r0,r0
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	fe 44 80 00 	cp.w	r4,-98304
800020d2:	9a c0       	ld.uh	r0,sp[0x8]

800020d4 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d4:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020d6:	48 3c       	lddpc	r12,800020e0 <EnOB_brdcst_func+0xc>
800020d8:	f0 1f 00 03 	mcall	800020e4 <EnOB_brdcst_func+0x10>
}
800020dc:	d8 02       	popm	pc
800020de:	00 00       	add	r0,r0
800020e0:	80 00       	ld.sh	r0,r0[0x0]
800020e2:	fe 60 80 00 	mov	r0,-98304
800020e6:	9a c0       	ld.uh	r0,sp[0x8]

800020e8 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020e8:	eb cd 40 80 	pushm	r7,lr
800020ec:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020ee:	19 a9       	ld.ub	r9,r12[0x2]
800020f0:	30 08       	mov	r8,0
800020f2:	f0 09 18 00 	cp.b	r9,r8
800020f6:	c1 91       	brne	80002128 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
800020f8:	19 b8       	ld.ub	r8,r12[0x3]
800020fa:	30 19       	mov	r9,1
800020fc:	f2 08 18 00 	cp.b	r8,r9
80002100:	c0 61       	brne	8000210c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002102:	49 0c       	lddpc	r12,80002140 <EnOB_reply_func+0x58>
80002104:	f0 1f 00 10 	mcall	80002144 <EnOB_reply_func+0x5c>
80002108:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000210c:	58 08       	cp.w	r8,0
8000210e:	c0 61       	brne	8000211a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002110:	48 ec       	lddpc	r12,80002148 <EnOB_reply_func+0x60>
80002112:	f0 1f 00 0d 	mcall	80002144 <EnOB_reply_func+0x5c>
80002116:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000211a:	1a d8       	st.w	--sp,r8
8000211c:	48 cc       	lddpc	r12,8000214c <EnOB_reply_func+0x64>
8000211e:	f0 1f 00 0a 	mcall	80002144 <EnOB_reply_func+0x5c>
80002122:	2f fd       	sub	sp,-4
80002124:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002128:	48 ac       	lddpc	r12,80002150 <EnOB_reply_func+0x68>
8000212a:	f0 1f 00 07 	mcall	80002144 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000212e:	0f a8       	ld.ub	r8,r7[0x2]
80002130:	1a d8       	st.w	--sp,r8
80002132:	48 9c       	lddpc	r12,80002154 <EnOB_reply_func+0x6c>
80002134:	f0 1f 00 04 	mcall	80002144 <EnOB_reply_func+0x5c>
80002138:	2f fd       	sub	sp,-4
8000213a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000213e:	00 00       	add	r0,r0
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	fe 78 80 00 	mov	r8,-32768
80002146:	9a c0       	ld.uh	r0,sp[0x8]
80002148:	80 00       	ld.sh	r0,r0[0x0]
8000214a:	fe 90 80 00 	breq	7fff214a <_estack+0x7ffda14a>
8000214e:	fe a4       	*unknown*
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	fe bc       	*unknown*
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	fe d8 eb cd 	satsub.w	r8,pc,-5171

80002158 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002158:	eb cd 40 80 	pushm	r7,lr
8000215c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000215e:	19 a9       	ld.ub	r9,r12[0x2]
80002160:	31 18       	mov	r8,17
80002162:	f0 09 18 00 	cp.b	r9,r8
80002166:	c0 61       	brne	80002172 <SingleDetection_brdcst_func+0x1a>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002168:	48 8c       	lddpc	r12,80002188 <SingleDetection_brdcst_func+0x30>
8000216a:	f0 1f 00 09 	mcall	8000218c <SingleDetection_brdcst_func+0x34>
8000216e:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error");
80002172:	48 8c       	lddpc	r12,80002190 <SingleDetection_brdcst_func+0x38>
80002174:	f0 1f 00 06 	mcall	8000218c <SingleDetection_brdcst_func+0x34>
		log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
80002178:	0f a8       	ld.ub	r8,r7[0x2]
8000217a:	1a d8       	st.w	--sp,r8
8000217c:	48 6c       	lddpc	r12,80002194 <SingleDetection_brdcst_func+0x3c>
8000217e:	f0 1f 00 04 	mcall	8000218c <SingleDetection_brdcst_func+0x34>
80002182:	2f fd       	sub	sp,-4
80002184:	e3 cd 80 80 	ldm	sp++,r7,pc
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	fe f0 80 00 	ld.w	r0,pc[-32768]
8000218e:	9a c0       	ld.uh	r0,sp[0x8]
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	ff 04 80 00 	ld.sh	r4,pc[-32768]
80002196:	ff 14 d4 31 	ld.uh	r4,pc[-11215]

80002198 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
8000219a:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
8000219e:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021a0:	4a bc       	lddpc	r12,8000224c <ButtonConfig_brdcst_func+0xb4>
800021a2:	f0 1f 00 2c 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021a6:	0f 88       	ld.ub	r8,r7[0x0]
800021a8:	1a d8       	st.w	--sp,r8
800021aa:	4a bc       	lddpc	r12,80002254 <ButtonConfig_brdcst_func+0xbc>
800021ac:	f0 1f 00 29 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021b0:	1a d5       	st.w	--sp,r5
800021b2:	4a ac       	lddpc	r12,80002258 <ButtonConfig_brdcst_func+0xc0>
800021b4:	f0 1f 00 27 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021b8:	0f a8       	ld.ub	r8,r7[0x2]
800021ba:	1a d8       	st.w	--sp,r8
800021bc:	4a 8c       	lddpc	r12,8000225c <ButtonConfig_brdcst_func+0xc4>
800021be:	f0 1f 00 25 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021c2:	2f dd       	sub	sp,-12
800021c4:	58 05       	cp.w	r5,0
800021c6:	c4 10       	breq	80002248 <ButtonConfig_brdcst_func+0xb0>
800021c8:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021ca:	4a 64       	lddpc	r4,80002260 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021cc:	4a 63       	lddpc	r3,80002264 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021ce:	4a 72       	lddpc	r2,80002268 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021d0:	4a 71       	lddpc	r1,8000226c <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021d2:	4a 80       	lddpc	r0,80002270 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021d4:	0f b9       	ld.ub	r9,r7[0x3]
800021d6:	0f c8       	ld.ub	r8,r7[0x4]
800021d8:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021dc:	1a d8       	st.w	--sp,r8
800021de:	1a d6       	st.w	--sp,r6
800021e0:	08 9c       	mov	r12,r4
800021e2:	f0 1f 00 1c 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021e6:	0f d9       	ld.ub	r9,r7[0x5]
800021e8:	0f e8       	ld.ub	r8,r7[0x6]
800021ea:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021ee:	1a d8       	st.w	--sp,r8
800021f0:	1a d6       	st.w	--sp,r6
800021f2:	06 9c       	mov	r12,r3
800021f4:	f0 1f 00 17 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021f8:	0f f9       	ld.ub	r9,r7[0x7]
800021fa:	ef 38 00 08 	ld.ub	r8,r7[8]
800021fe:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002202:	1a d8       	st.w	--sp,r8
80002204:	1a d6       	st.w	--sp,r6
80002206:	04 9c       	mov	r12,r2
80002208:	f0 1f 00 12 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000220c:	ef 39 00 09 	ld.ub	r9,r7[9]
80002210:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002214:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002218:	1a d8       	st.w	--sp,r8
8000221a:	1a d6       	st.w	--sp,r6
8000221c:	02 9c       	mov	r12,r1
8000221e:	f0 1f 00 0d 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002222:	2f 8d       	sub	sp,-32
80002224:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002228:	ef 38 00 0c 	ld.ub	r8,r7[12]
8000222c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002230:	1a d8       	st.w	--sp,r8
80002232:	1a d6       	st.w	--sp,r6
80002234:	00 9c       	mov	r12,r0
80002236:	f0 1f 00 07 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
8000223a:	2f f6       	sub	r6,-1
8000223c:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000223e:	2f ed       	sub	sp,-8
80002240:	ec 05 18 00 	cp.b	r5,r6
80002244:	fe 9b ff c8 	brhi	800021d4 <ButtonConfig_brdcst_func+0x3c>
80002248:	d8 32       	popm	r0-r7,pc
8000224a:	00 00       	add	r0,r0
8000224c:	80 00       	ld.sh	r0,r0[0x0]
8000224e:	ff 2c 80 00 	ld.sb	r12,pc[-32768]
80002252:	9a c0       	ld.uh	r0,sp[0x8]
80002254:	80 00       	ld.sh	r0,r0[0x0]
80002256:	ff 4c 80 00 	st.w	pc[-32768],r12
8000225a:	ff 60 80 00 	st.b	pc[-32768],r0
8000225e:	ff 78 80 00 	stcond	pc[-32768],r8
80002262:	ff 98       	*unknown*
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	ff c0       	*unknown*
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	ff e8 80 01 	sthh.w	r1[r0],pc:b,r8:b
8000226e:	00 0c       	add	r12,r0
80002270:	80 01       	ld.sh	r1,r0[0x0]
80002272:	00 34       	cp.w	r4,r0

80002274 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002274:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
80002278:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
8000227a:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
8000227c:	19 c7       	ld.ub	r7,r12[0x4]
8000227e:	19 d8       	ld.ub	r8,r12[0x5]
80002280:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002284:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
80002286:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
80002288:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
8000228c:	49 0c       	lddpc	r12,800022cc <Phyuserinput_brdcst_func+0x58>
8000228e:	f0 1f 00 11 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
80002292:	1a d6       	st.w	--sp,r6
80002294:	49 0c       	lddpc	r12,800022d4 <Phyuserinput_brdcst_func+0x60>
80002296:	f0 1f 00 0f 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
8000229a:	1a d5       	st.w	--sp,r5
8000229c:	48 fc       	lddpc	r12,800022d8 <Phyuserinput_brdcst_func+0x64>
8000229e:	f0 1f 00 0d 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
800022a2:	5c 77       	castu.h	r7
800022a4:	1a d7       	st.w	--sp,r7
800022a6:	48 ec       	lddpc	r12,800022dc <Phyuserinput_brdcst_func+0x68>
800022a8:	f0 1f 00 0a 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
800022ac:	1a d4       	st.w	--sp,r4
800022ae:	48 dc       	lddpc	r12,800022e0 <Phyuserinput_brdcst_func+0x6c>
800022b0:	f0 1f 00 08 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
800022b4:	1a d3       	st.w	--sp,r3
800022b6:	48 cc       	lddpc	r12,800022e4 <Phyuserinput_brdcst_func+0x70>
800022b8:	f0 1f 00 06 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
800022bc:	1a d2       	st.w	--sp,r2
800022be:	48 bc       	lddpc	r12,800022e8 <Phyuserinput_brdcst_func+0x74>
800022c0:	f0 1f 00 04 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
800022c4:	2f ad       	sub	sp,-24
	
	
	
	
	
}
800022c6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800022ca:	00 00       	add	r0,r0
800022cc:	80 01       	ld.sh	r1,r0[0x0]
800022ce:	00 58       	eor	r8,r0
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	9a c0       	ld.uh	r0,sp[0x8]
800022d4:	80 01       	ld.sh	r1,r0[0x0]
800022d6:	00 7c       	tst	r12,r0
800022d8:	80 01       	ld.sh	r1,r0[0x0]
800022da:	00 94       	mov	r4,r0
800022dc:	80 01       	ld.sh	r1,r0[0x0]
800022de:	00 a8       	st.w	r0++,r8
800022e0:	80 01       	ld.sh	r1,r0[0x0]
800022e2:	00 bc       	st.h	r0++,r12
800022e4:	80 01       	ld.sh	r1,r0[0x0]
800022e6:	00 d0       	st.w	--r0,r0
800022e8:	80 01       	ld.sh	r1,r0[0x0]
800022ea:	00 f0       	st.b	--r0,r0

800022ec <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022ec:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022f0:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022f4:	0f 89       	ld.ub	r9,r7[0x0]
800022f6:	30 08       	mov	r8,0
800022f8:	f0 09 18 00 	cp.b	r9,r8
800022fc:	c0 c1       	brne	80002314 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022fe:	48 9c       	lddpc	r12,80002320 <ButtonConfig_reply_func+0x34>
80002300:	f0 1f 00 09 	mcall	80002324 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002304:	0f 98       	ld.ub	r8,r7[0x1]
80002306:	1a d8       	st.w	--sp,r8
80002308:	48 8c       	lddpc	r12,80002328 <ButtonConfig_reply_func+0x3c>
8000230a:	f0 1f 00 07 	mcall	80002324 <ButtonConfig_reply_func+0x38>
8000230e:	2f fd       	sub	sp,-4
80002310:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002314:	48 6c       	lddpc	r12,8000232c <ButtonConfig_reply_func+0x40>
80002316:	f0 1f 00 04 	mcall	80002324 <ButtonConfig_reply_func+0x38>
8000231a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000231e:	00 00       	add	r0,r0
80002320:	80 01       	ld.sh	r1,r0[0x0]
80002322:	01 10       	ld.sh	r0,r0++
80002324:	80 00       	ld.sh	r0,r0[0x0]
80002326:	9a c0       	ld.uh	r0,sp[0x8]
80002328:	80 00       	ld.sh	r0,r0[0x0]
8000232a:	ff 4c 80 01 	st.w	pc[-32767],r12
8000232e:	01 28       	ld.uh	r8,r0++

80002330 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002330:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002332:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
80002336:	0d 88       	ld.ub	r8,r6[0x0]
80002338:	32 49       	mov	r9,36
8000233a:	f2 08 18 00 	cp.b	r8,r9
8000233e:	c2 91       	brne	80002390 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002340:	49 7c       	lddpc	r12,8000239c <DataSession_brdcst_func+0x6c>
80002342:	f0 1f 00 18 	mcall	800023a0 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002346:	0d a5       	ld.ub	r5,r6[0x2]
80002348:	0d b8       	ld.ub	r8,r6[0x3]
8000234a:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000234e:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002350:	0d 98       	ld.ub	r8,r6[0x1]
80002352:	1a d8       	st.w	--sp,r8
80002354:	49 4c       	lddpc	r12,800023a4 <DataSession_brdcst_func+0x74>
80002356:	f0 1f 00 13 	mcall	800023a0 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000235a:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000235e:	1a d8       	st.w	--sp,r8
80002360:	49 2c       	lddpc	r12,800023a8 <DataSession_brdcst_func+0x78>
80002362:	f0 1f 00 10 	mcall	800023a0 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
80002366:	2f ed       	sub	sp,-8
80002368:	58 05       	cp.w	r5,0
8000236a:	c1 80       	breq	8000239a <DataSession_brdcst_func+0x6a>
8000236c:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000236e:	49 04       	lddpc	r4,800023ac <DataSession_brdcst_func+0x7c>
80002370:	ec 07 00 08 	add	r8,r6,r7
80002374:	11 c8       	ld.ub	r8,r8[0x4]
80002376:	1a d8       	st.w	--sp,r8
80002378:	1a d7       	st.w	--sp,r7
8000237a:	08 9c       	mov	r12,r4
8000237c:	f0 1f 00 09 	mcall	800023a0 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002380:	2f f7       	sub	r7,-1
80002382:	5c 57       	castu.b	r7
80002384:	2f ed       	sub	sp,-8
80002386:	ee 05 19 00 	cp.h	r5,r7
8000238a:	fe 9b ff f3 	brhi	80002370 <DataSession_brdcst_func+0x40>
8000238e:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002390:	1a d8       	st.w	--sp,r8
80002392:	48 8c       	lddpc	r12,800023b0 <DataSession_brdcst_func+0x80>
80002394:	f0 1f 00 03 	mcall	800023a0 <DataSession_brdcst_func+0x70>
80002398:	2f fd       	sub	sp,-4
8000239a:	d8 22       	popm	r4-r7,pc
8000239c:	80 01       	ld.sh	r1,r0[0x0]
8000239e:	01 44       	ld.w	r4,--r0
800023a0:	80 00       	ld.sh	r0,r0[0x0]
800023a2:	9a c0       	ld.uh	r0,sp[0x8]
800023a4:	80 01       	ld.sh	r1,r0[0x0]
800023a6:	01 58       	ld.sh	r8,--r0
800023a8:	80 01       	ld.sh	r1,r0[0x0]
800023aa:	01 70       	ld.ub	r0,--r0
800023ac:	80 01       	ld.sh	r1,r0[0x0]
800023ae:	01 8c       	ld.ub	r12,r0[0x0]
800023b0:	80 01       	ld.sh	r1,r0[0x0]
800023b2:	01 a4       	ld.ub	r4,r0[0x2]

800023b4 <DataSession_reply_func>:
	
}


void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800023b4:	eb cd 40 80 	pushm	r7,lr
800023b8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023ba:	19 a8       	ld.ub	r8,r12[0x2]
800023bc:	58 08       	cp.w	r8,0
800023be:	c0 61       	brne	800023ca <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
800023c0:	48 dc       	lddpc	r12,800023f4 <DataSession_reply_func+0x40>
800023c2:	f0 1f 00 0e 	mcall	800023f8 <DataSession_reply_func+0x44>
800023c6:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
800023ca:	1a d8       	st.w	--sp,r8
800023cc:	48 cc       	lddpc	r12,800023fc <DataSession_reply_func+0x48>
800023ce:	f0 1f 00 0b 	mcall	800023f8 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
800023d2:	48 cc       	lddpc	r12,80002400 <DataSession_reply_func+0x4c>
800023d4:	f0 1f 00 09 	mcall	800023f8 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
800023d8:	0f b8       	ld.ub	r8,r7[0x3]
800023da:	1a d8       	st.w	--sp,r8
800023dc:	48 ac       	lddpc	r12,80002404 <DataSession_reply_func+0x50>
800023de:	f0 1f 00 07 	mcall	800023f8 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
800023e2:	0f c8       	ld.ub	r8,r7[0x4]
800023e4:	1a d8       	st.w	--sp,r8
800023e6:	48 9c       	lddpc	r12,80002408 <DataSession_reply_func+0x54>
800023e8:	f0 1f 00 04 	mcall	800023f8 <DataSession_reply_func+0x44>
800023ec:	2f dd       	sub	sp,-12
800023ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800023f2:	00 00       	add	r0,r0
800023f4:	80 01       	ld.sh	r1,r0[0x0]
800023f6:	01 b8       	ld.ub	r8,r0[0x3]
800023f8:	80 00       	ld.sh	r0,r0[0x0]
800023fa:	9a c0       	ld.uh	r0,sp[0x8]
800023fc:	80 01       	ld.sh	r1,r0[0x0]
800023fe:	01 cc       	ld.ub	r12,r0[0x4]
80002400:	80 01       	ld.sh	r1,r0[0x0]
80002402:	01 e0       	ld.ub	r0,r0[0x6]
80002404:	80 01       	ld.sh	r1,r0[0x0]
80002406:	01 f4       	ld.ub	r4,r0[0x7]
80002408:	80 01       	ld.sh	r1,r0[0x0]
8000240a:	02 04       	add	r4,r1

8000240c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000240c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002410:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002414:	0f 89       	ld.ub	r9,r7[0x0]
80002416:	30 08       	mov	r8,0
80002418:	f0 09 18 00 	cp.b	r9,r8
8000241c:	c2 21       	brne	80002460 <TransmitControl_reply_func+0x54>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000241e:	49 4c       	lddpc	r12,8000246c <TransmitControl_reply_func+0x60>
80002420:	f0 1f 00 14 	mcall	80002470 <TransmitControl_reply_func+0x64>
		log("\n\r Function: %x \n\r", ptr->Function);
80002424:	0f 98       	ld.ub	r8,r7[0x1]
80002426:	1a d8       	st.w	--sp,r8
80002428:	49 3c       	lddpc	r12,80002474 <TransmitControl_reply_func+0x68>
8000242a:	f0 1f 00 12 	mcall	80002470 <TransmitControl_reply_func+0x64>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000242e:	0f a8       	ld.ub	r8,r7[0x2]
80002430:	1a d8       	st.w	--sp,r8
80002432:	49 2c       	lddpc	r12,80002478 <TransmitControl_reply_func+0x6c>
80002434:	f0 1f 00 0f 	mcall	80002470 <TransmitControl_reply_func+0x64>
		log("\n\r State: %x \n\r", ptr->State);
80002438:	0f b8       	ld.ub	r8,r7[0x3]
8000243a:	1a d8       	st.w	--sp,r8
8000243c:	49 0c       	lddpc	r12,8000247c <TransmitControl_reply_func+0x70>
8000243e:	f0 1f 00 0d 	mcall	80002470 <TransmitControl_reply_func+0x64>
		
		if (ptr->Function == KEY_UP)
80002442:	0f 98       	ld.ub	r8,r7[0x1]
80002444:	2f dd       	sub	sp,-12
80002446:	30 19       	mov	r9,1
80002448:	f2 08 18 00 	cp.b	r8,r9
8000244c:	c0 d0       	breq	80002466 <TransmitControl_reply_func+0x5a>
		{
			//is_unmute = 1;
		}
		else if (ptr->Function ==DE_KEY)
8000244e:	30 29       	mov	r9,2
80002450:	f2 08 18 00 	cp.b	r8,r9
80002454:	c0 91       	brne	80002466 <TransmitControl_reply_func+0x5a>
		{
			is_unmute = 0;
80002456:	30 09       	mov	r9,0
80002458:	48 a8       	lddpc	r8,80002480 <TransmitControl_reply_func+0x74>
8000245a:	b0 89       	st.b	r8[0x0],r9
8000245c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002460:	48 9c       	lddpc	r12,80002484 <TransmitControl_reply_func+0x78>
80002462:	f0 1f 00 04 	mcall	80002470 <TransmitControl_reply_func+0x64>
80002466:	e3 cd 80 80 	ldm	sp++,r7,pc
8000246a:	00 00       	add	r0,r0
8000246c:	80 01       	ld.sh	r1,r0[0x0]
8000246e:	02 14       	sub	r4,r1
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	9a c0       	ld.uh	r0,sp[0x8]
80002474:	80 01       	ld.sh	r1,r0[0x0]
80002476:	02 30       	cp.w	r0,r1
80002478:	80 01       	ld.sh	r1,r0[0x0]
8000247a:	02 44       	or	r4,r1
8000247c:	80 01       	ld.sh	r1,r0[0x0]
8000247e:	02 60       	and	r0,r1
80002480:	00 00       	add	r0,r0
80002482:	0a 4d       	or	sp,r5
80002484:	80 01       	ld.sh	r1,r0[0x0]
80002486:	02 70       	tst	r0,r1

80002488 <AudioRoutingControl_brdcst_func>:
	}
}


void AudioRoutingControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002488:	eb cd 40 f8 	pushm	r3-r7,lr
8000248c:	18 96       	mov	r6,r12
	
	U16 num_routings = 0;
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
8000248e:	19 a5       	ld.ub	r5,r12[0x2]
80002490:	19 b8       	ld.ub	r8,r12[0x3]
80002492:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002496:	5c 85       	casts.h	r5
	log("\n\r num_routings: %d \n\r", num_routings);
80002498:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000249c:	1a d8       	st.w	--sp,r8
8000249e:	49 6c       	lddpc	r12,800024f4 <AudioRoutingControl_brdcst_func+0x6c>
800024a0:	f0 1f 00 16 	mcall	800024f8 <AudioRoutingControl_brdcst_func+0x70>
	
	for(j = 0; j< num_routings ; j++ )
800024a4:	2f fd       	sub	sp,-4
800024a6:	58 05       	cp.w	r5,0
800024a8:	c0 31       	brne	800024ae <AudioRoutingControl_brdcst_func+0x26>
800024aa:	30 07       	mov	r7,0
800024ac:	c1 98       	rjmp	800024de <AudioRoutingControl_brdcst_func+0x56>
800024ae:	30 07       	mov	r7,0
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
800024b0:	49 34       	lddpc	r4,800024fc <AudioRoutingControl_brdcst_func+0x74>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
800024b2:	49 43       	lddpc	r3,80002500 <AudioRoutingControl_brdcst_func+0x78>
	
	for(j = 0; j< num_routings ; j++ )
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
800024b4:	ec 07 00 18 	add	r8,r6,r7<<0x1
800024b8:	11 c8       	ld.ub	r8,r8[0x4]
800024ba:	1a d8       	st.w	--sp,r8
800024bc:	08 9c       	mov	r12,r4
800024be:	f0 1f 00 0f 	mcall	800024f8 <AudioRoutingControl_brdcst_func+0x70>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
800024c2:	ec 07 00 18 	add	r8,r6,r7<<0x1
800024c6:	11 d8       	ld.ub	r8,r8[0x5]
800024c8:	1a d8       	st.w	--sp,r8
800024ca:	06 9c       	mov	r12,r3
800024cc:	f0 1f 00 0b 	mcall	800024f8 <AudioRoutingControl_brdcst_func+0x70>
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
	log("\n\r num_routings: %d \n\r", num_routings);
	
	for(j = 0; j< num_routings ; j++ )
800024d0:	2f f7       	sub	r7,-1
800024d2:	5c 57       	castu.b	r7
800024d4:	2f ed       	sub	sp,-8
800024d6:	ee 05 19 00 	cp.h	r5,r7
800024da:	fe 9b ff ed 	brhi	800024b4 <AudioRoutingControl_brdcst_func+0x2c>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
		
		
	}
	
	log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
800024de:	ec 07 00 17 	add	r7,r6,r7<<0x1
800024e2:	0f c8       	ld.ub	r8,r7[0x4]
800024e4:	1a d8       	st.w	--sp,r8
800024e6:	48 8c       	lddpc	r12,80002504 <AudioRoutingControl_brdcst_func+0x7c>
800024e8:	f0 1f 00 04 	mcall	800024f8 <AudioRoutingControl_brdcst_func+0x70>
800024ec:	2f fd       	sub	sp,-4
	
	
	
}
800024ee:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800024f2:	00 00       	add	r0,r0
800024f4:	80 01       	ld.sh	r1,r0[0x0]
800024f6:	02 88       	andn	r8,r1
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	9a c0       	ld.uh	r0,sp[0x8]
800024fc:	80 01       	ld.sh	r1,r0[0x0]
800024fe:	02 a0       	st.w	r1++,r0
80002500:	80 01       	ld.sh	r1,r0[0x0]
80002502:	02 b8       	st.h	r1++,r8
80002504:	80 01       	ld.sh	r1,r0[0x0]
80002506:	02 d0       	st.w	--r1,r0

80002508 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002508:	eb cd 40 80 	pushm	r7,lr
8000250c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000250e:	19 a9       	ld.ub	r9,r12[0x2]
80002510:	30 08       	mov	r8,0
80002512:	f0 09 18 00 	cp.b	r9,r8
80002516:	c0 61       	brne	80002522 <AudioRoutingControl_reply_func+0x1a>
	{
		log("AudioRouting OK");
80002518:	48 8c       	lddpc	r12,80002538 <AudioRoutingControl_reply_func+0x30>
8000251a:	f0 1f 00 09 	mcall	8000253c <AudioRoutingControl_reply_func+0x34>
8000251e:	e3 cd 80 80 	ldm	sp++,r7,pc
		//is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002522:	48 8c       	lddpc	r12,80002540 <AudioRoutingControl_reply_func+0x38>
80002524:	f0 1f 00 06 	mcall	8000253c <AudioRoutingControl_reply_func+0x34>
		log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
80002528:	0f a8       	ld.ub	r8,r7[0x2]
8000252a:	1a d8       	st.w	--sp,r8
8000252c:	48 6c       	lddpc	r12,80002544 <AudioRoutingControl_reply_func+0x3c>
8000252e:	f0 1f 00 04 	mcall	8000253c <AudioRoutingControl_reply_func+0x34>
80002532:	2f fd       	sub	sp,-4
80002534:	e3 cd 80 80 	ldm	sp++,r7,pc
80002538:	80 01       	ld.sh	r1,r0[0x0]
8000253a:	02 ec       	st.h	--r1,r12
8000253c:	80 00       	ld.sh	r0,r0[0x0]
8000253e:	9a c0       	ld.uh	r0,sp[0x8]
80002540:	80 01       	ld.sh	r1,r0[0x0]
80002542:	02 fc       	st.b	--r1,r12
80002544:	80 01       	ld.sh	r1,r0[0x0]
80002546:	03 10       	ld.sh	r0,r1++

80002548 <Volume_brdcst_func>:
	
	
}

void Volume_brdcst_func(xcmp_fragment_t * xcmp)
{
80002548:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	VolumeControl_brdcst_t *ptr = (VolumeControl_brdcst_t* )xcmp->u8;
8000254c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002550:	0f 89       	ld.ub	r9,r7[0x0]
80002552:	0f 98       	ld.ub	r8,r7[0x1]
80002554:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002558:	1a d8       	st.w	--sp,r8
8000255a:	48 6c       	lddpc	r12,80002570 <Volume_brdcst_func+0x28>
8000255c:	f0 1f 00 06 	mcall	80002574 <Volume_brdcst_func+0x2c>
	
	log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
80002560:	0f b8       	ld.ub	r8,r7[0x3]
80002562:	1a d8       	st.w	--sp,r8
80002564:	48 5c       	lddpc	r12,80002578 <Volume_brdcst_func+0x30>
80002566:	f0 1f 00 04 	mcall	80002574 <Volume_brdcst_func+0x2c>
8000256a:	2f ed       	sub	sp,-8
	
	
}
8000256c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002570:	80 01       	ld.sh	r1,r0[0x0]
80002572:	03 30       	ld.ub	r0,r1++
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	9a c0       	ld.uh	r0,sp[0x8]
80002578:	80 01       	ld.sh	r1,r0[0x0]
8000257a:	03 4c       	ld.w	r12,--r1

8000257c <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
8000257c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002580:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002584:	0f 89       	ld.ub	r9,r7[0x0]
80002586:	30 08       	mov	r8,0
80002588:	f0 09 18 00 	cp.b	r9,r8
8000258c:	c1 b1       	brne	800025c2 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
8000258e:	0f b8       	ld.ub	r8,r7[0x3]
80002590:	31 09       	mov	r9,16
80002592:	f2 08 18 00 	cp.b	r8,r9
80002596:	c0 f1       	brne	800025b4 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002598:	48 dc       	lddpc	r12,800025cc <Volume_reply_func+0x50>
8000259a:	f0 1f 00 0e 	mcall	800025d0 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
8000259e:	0f 99       	ld.ub	r9,r7[0x1]
800025a0:	0f a8       	ld.ub	r8,r7[0x2]
800025a2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025a6:	1a d8       	st.w	--sp,r8
800025a8:	48 bc       	lddpc	r12,800025d4 <Volume_reply_func+0x58>
800025aa:	f0 1f 00 0a 	mcall	800025d0 <Volume_reply_func+0x54>
800025ae:	2f fd       	sub	sp,-4
800025b0:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025b4:	1a d8       	st.w	--sp,r8
800025b6:	48 9c       	lddpc	r12,800025d8 <Volume_reply_func+0x5c>
800025b8:	f0 1f 00 06 	mcall	800025d0 <Volume_reply_func+0x54>
800025bc:	2f fd       	sub	sp,-4
800025be:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025c2:	48 7c       	lddpc	r12,800025dc <Volume_reply_func+0x60>
800025c4:	f0 1f 00 03 	mcall	800025d0 <Volume_reply_func+0x54>
800025c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800025cc:	80 01       	ld.sh	r1,r0[0x0]
800025ce:	03 68       	ld.uh	r8,--r1
800025d0:	80 00       	ld.sh	r0,r0[0x0]
800025d2:	9a c0       	ld.uh	r0,sp[0x8]
800025d4:	80 01       	ld.sh	r1,r0[0x0]
800025d6:	03 30       	ld.ub	r0,r1++
800025d8:	80 01       	ld.sh	r1,r0[0x0]
800025da:	03 7c       	ld.ub	r12,--r1
800025dc:	80 01       	ld.sh	r1,r0[0x0]
800025de:	03 94       	ld.ub	r4,r1[0x1]

800025e0 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025e0:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025e2:	19 d9       	ld.ub	r9,r12[0x5]
800025e4:	30 08       	mov	r8,0
800025e6:	f0 09 18 00 	cp.b	r9,r8
800025ea:	c0 91       	brne	800025fc <spk_brdcst_func+0x1c>
	{
		is_unmute =0;
800025ec:	48 89       	lddpc	r9,8000260c <spk_brdcst_func+0x2c>
800025ee:	b2 88       	st.b	r9[0x0],r8
		Silent_flag = 0;
800025f0:	48 89       	lddpc	r9,80002610 <spk_brdcst_func+0x30>
800025f2:	b2 88       	st.b	r9[0x0],r8
		log("spk_s_close ");
800025f4:	48 8c       	lddpc	r12,80002614 <spk_brdcst_func+0x34>
800025f6:	f0 1f 00 09 	mcall	80002618 <spk_brdcst_func+0x38>
800025fa:	d8 02       	popm	pc
		
		
	}
	else
	{
		Silent_flag = 1;
800025fc:	30 19       	mov	r9,1
800025fe:	48 58       	lddpc	r8,80002610 <spk_brdcst_func+0x30>
80002600:	b0 89       	st.b	r8[0x0],r9
		//is_unmute = 1;
		log("spk_s_open ");
80002602:	48 7c       	lddpc	r12,8000261c <spk_brdcst_func+0x3c>
80002604:	f0 1f 00 05 	mcall	80002618 <spk_brdcst_func+0x38>
80002608:	d8 02       	popm	pc
8000260a:	00 00       	add	r0,r0
8000260c:	00 00       	add	r0,r0
8000260e:	0a 4d       	or	sp,r5
80002610:	00 00       	add	r0,r0
80002612:	0a 54       	eor	r4,r5
80002614:	80 01       	ld.sh	r1,r0[0x0]
80002616:	03 ac       	ld.ub	r12,r1[0x2]
80002618:	80 00       	ld.sh	r0,r0[0x0]
8000261a:	9a c0       	ld.uh	r0,sp[0x8]
8000261c:	80 01       	ld.sh	r1,r0[0x0]
8000261e:	03 bc       	ld.ub	r12,r1[0x3]

80002620 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002620:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002622:	19 a9       	ld.ub	r9,r12[0x2]
80002624:	30 08       	mov	r8,0
80002626:	f0 09 18 00 	cp.b	r9,r8
8000262a:	c0 f1       	brne	80002648 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000262c:	19 e9       	ld.ub	r9,r12[0x6]
8000262e:	f0 09 18 00 	cp.b	r9,r8
80002632:	c0 40       	breq	8000263a <spk_reply_func+0x1a>
		{
			is_unmute = 1;
80002634:	30 19       	mov	r9,1
80002636:	48 78       	lddpc	r8,80002650 <spk_reply_func+0x30>
80002638:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000263a:	19 e8       	ld.ub	r8,r12[0x6]
8000263c:	1a d8       	st.w	--sp,r8
8000263e:	48 6c       	lddpc	r12,80002654 <spk_reply_func+0x34>
80002640:	f0 1f 00 06 	mcall	80002658 <spk_reply_func+0x38>
80002644:	2f fd       	sub	sp,-4
80002646:	d8 02       	popm	pc
		
	}
	else
	{
		log("spk error");
80002648:	48 5c       	lddpc	r12,8000265c <spk_reply_func+0x3c>
8000264a:	f0 1f 00 04 	mcall	80002658 <spk_reply_func+0x38>
8000264e:	d8 02       	popm	pc
80002650:	00 00       	add	r0,r0
80002652:	0a 4d       	or	sp,r5
80002654:	80 01       	ld.sh	r1,r0[0x0]
80002656:	03 c8       	ld.ub	r8,r1[0x4]
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	9a c0       	ld.uh	r0,sp[0x8]
8000265c:	80 01       	ld.sh	r1,r0[0x0]
8000265e:	03 d8       	ld.ub	r8,r1[0x5]

80002660 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002660:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002664:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002668:	49 ac       	lddpc	r12,800026d0 <mic_reply_func+0x70>
8000266a:	f0 1f 00 1b 	mcall	800026d4 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000266e:	0f 89       	ld.ub	r9,r7[0x0]
80002670:	30 08       	mov	r8,0
80002672:	f0 09 18 00 	cp.b	r9,r8
80002676:	c2 71       	brne	800026c4 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002678:	0f 98       	ld.ub	r8,r7[0x1]
8000267a:	30 29       	mov	r9,2
8000267c:	f2 08 18 00 	cp.b	r8,r9
80002680:	c1 b1       	brne	800026b6 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002682:	49 6c       	lddpc	r12,800026d8 <mic_reply_func+0x78>
80002684:	f0 1f 00 14 	mcall	800026d4 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002688:	0f a8       	ld.ub	r8,r7[0x2]
8000268a:	1a d8       	st.w	--sp,r8
8000268c:	49 4c       	lddpc	r12,800026dc <mic_reply_func+0x7c>
8000268e:	f0 1f 00 12 	mcall	800026d4 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002692:	0f b8       	ld.ub	r8,r7[0x3]
80002694:	1a d8       	st.w	--sp,r8
80002696:	49 3c       	lddpc	r12,800026e0 <mic_reply_func+0x80>
80002698:	f0 1f 00 0f 	mcall	800026d4 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000269c:	0f c8       	ld.ub	r8,r7[0x4]
8000269e:	1a d8       	st.w	--sp,r8
800026a0:	49 1c       	lddpc	r12,800026e4 <mic_reply_func+0x84>
800026a2:	f0 1f 00 0d 	mcall	800026d4 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800026a6:	0f d8       	ld.ub	r8,r7[0x5]
800026a8:	1a d8       	st.w	--sp,r8
800026aa:	49 0c       	lddpc	r12,800026e8 <mic_reply_func+0x88>
800026ac:	f0 1f 00 0a 	mcall	800026d4 <mic_reply_func+0x74>
800026b0:	2f cd       	sub	sp,-16
800026b2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026b6:	1a d8       	st.w	--sp,r8
800026b8:	48 dc       	lddpc	r12,800026ec <mic_reply_func+0x8c>
800026ba:	f0 1f 00 07 	mcall	800026d4 <mic_reply_func+0x74>
800026be:	2f fd       	sub	sp,-4
800026c0:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026c4:	48 bc       	lddpc	r12,800026f0 <mic_reply_func+0x90>
800026c6:	f0 1f 00 04 	mcall	800026d4 <mic_reply_func+0x74>
800026ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800026ce:	00 00       	add	r0,r0
800026d0:	80 01       	ld.sh	r1,r0[0x0]
800026d2:	03 e4       	ld.ub	r4,r1[0x6]
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	9a c0       	ld.uh	r0,sp[0x8]
800026d8:	80 01       	ld.sh	r1,r0[0x0]
800026da:	03 f4       	ld.ub	r4,r1[0x7]
800026dc:	80 01       	ld.sh	r1,r0[0x0]
800026de:	04 08       	add	r8,r2
800026e0:	80 01       	ld.sh	r1,r0[0x0]
800026e2:	04 1c       	sub	r12,r2
800026e4:	80 01       	ld.sh	r1,r0[0x0]
800026e6:	04 38       	cp.w	r8,r2
800026e8:	80 01       	ld.sh	r1,r0[0x0]
800026ea:	04 50       	eor	r0,r2
800026ec:	80 01       	ld.sh	r1,r0[0x0]
800026ee:	04 68       	and	r8,r2
800026f0:	80 01       	ld.sh	r1,r0[0x0]
800026f2:	04 80       	andn	r0,r2

800026f4 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026f4:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026f8:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800026fc:	48 bc       	lddpc	r12,80002728 <dcm_brdcst_func+0x34>
800026fe:	f0 1f 00 0c 	mcall	8000272c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002702:	0f 88       	ld.ub	r8,r7[0x0]
80002704:	1a d8       	st.w	--sp,r8
80002706:	48 bc       	lddpc	r12,80002730 <dcm_brdcst_func+0x3c>
80002708:	f0 1f 00 09 	mcall	8000272c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000270c:	0f a8       	ld.ub	r8,r7[0x2]
8000270e:	1a d8       	st.w	--sp,r8
80002710:	48 9c       	lddpc	r12,80002734 <dcm_brdcst_func+0x40>
80002712:	f0 1f 00 07 	mcall	8000272c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002716:	0f 98       	ld.ub	r8,r7[0x1]
80002718:	1a d8       	st.w	--sp,r8
8000271a:	48 8c       	lddpc	r12,80002738 <dcm_brdcst_func+0x44>
8000271c:	f0 1f 00 04 	mcall	8000272c <dcm_brdcst_func+0x38>
80002720:	2f dd       	sub	sp,-12
	
	
}
80002722:	e3 cd 80 80 	ldm	sp++,r7,pc
80002726:	00 00       	add	r0,r0
80002728:	80 01       	ld.sh	r1,r0[0x0]
8000272a:	04 90       	mov	r0,r2
8000272c:	80 00       	ld.sh	r0,r0[0x0]
8000272e:	9a c0       	ld.uh	r0,sp[0x8]
80002730:	80 01       	ld.sh	r1,r0[0x0]
80002732:	04 a4       	st.w	r2++,r4
80002734:	80 01       	ld.sh	r1,r0[0x0]
80002736:	04 b8       	st.h	r2++,r8
80002738:	80 01       	ld.sh	r1,r0[0x0]
8000273a:	04 d0       	st.w	--r2,r0

8000273c <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
8000273c:	eb cd 40 80 	pushm	r7,lr
80002740:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002742:	19 a9       	ld.ub	r9,r12[0x2]
80002744:	30 08       	mov	r8,0
80002746:	f0 09 18 00 	cp.b	r9,r8
8000274a:	c1 b1       	brne	80002780 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000274c:	19 b8       	ld.ub	r8,r12[0x3]
8000274e:	30 19       	mov	r9,1
80002750:	f2 08 18 00 	cp.b	r8,r9
80002754:	c0 51       	brne	8000275e <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002756:	48 ec       	lddpc	r12,8000278c <dcm_reply_func+0x50>
80002758:	f0 1f 00 0e 	mcall	80002790 <dcm_reply_func+0x54>
8000275c:	c0 a8       	rjmp	80002770 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000275e:	58 08       	cp.w	r8,0
80002760:	c0 51       	brne	8000276a <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002762:	48 dc       	lddpc	r12,80002794 <dcm_reply_func+0x58>
80002764:	f0 1f 00 0b 	mcall	80002790 <dcm_reply_func+0x54>
80002768:	c0 48       	rjmp	80002770 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000276a:	48 cc       	lddpc	r12,80002798 <dcm_reply_func+0x5c>
8000276c:	f0 1f 00 09 	mcall	80002790 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002770:	0f d8       	ld.ub	r8,r7[0x5]
80002772:	1a d8       	st.w	--sp,r8
80002774:	48 ac       	lddpc	r12,8000279c <dcm_reply_func+0x60>
80002776:	f0 1f 00 07 	mcall	80002790 <dcm_reply_func+0x54>
8000277a:	2f fd       	sub	sp,-4
8000277c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002780:	48 8c       	lddpc	r12,800027a0 <dcm_reply_func+0x64>
80002782:	f0 1f 00 04 	mcall	80002790 <dcm_reply_func+0x54>
80002786:	e3 cd 80 80 	ldm	sp++,r7,pc
8000278a:	00 00       	add	r0,r0
8000278c:	80 01       	ld.sh	r1,r0[0x0]
8000278e:	04 ec       	st.h	--r2,r12
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	9a c0       	ld.uh	r0,sp[0x8]
80002794:	80 01       	ld.sh	r1,r0[0x0]
80002796:	05 00       	ld.w	r0,r2++
80002798:	80 01       	ld.sh	r1,r0[0x0]
8000279a:	05 14       	ld.sh	r4,r2++
8000279c:	80 01       	ld.sh	r1,r0[0x0]
8000279e:	05 28       	ld.uh	r8,r2++
800027a0:	80 01       	ld.sh	r1,r0[0x0]
800027a2:	05 34       	ld.ub	r4,r2++

800027a4 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800027a4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800027a6:	19 a9       	ld.ub	r9,r12[0x2]
800027a8:	30 08       	mov	r8,0
800027aa:	f0 09 18 00 	cp.b	r9,r8
800027ae:	c0 51       	brne	800027b8 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
800027b0:	48 4c       	lddpc	r12,800027c0 <ToneControl_reply_func+0x1c>
800027b2:	f0 1f 00 05 	mcall	800027c4 <ToneControl_reply_func+0x20>
800027b6:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027b8:	48 4c       	lddpc	r12,800027c8 <ToneControl_reply_func+0x24>
800027ba:	f0 1f 00 03 	mcall	800027c4 <ToneControl_reply_func+0x20>
800027be:	d8 02       	popm	pc
800027c0:	80 01       	ld.sh	r1,r0[0x0]
800027c2:	05 40       	ld.w	r0,--r2
800027c4:	80 00       	ld.sh	r0,r0[0x0]
800027c6:	9a c0       	ld.uh	r0,sp[0x8]
800027c8:	80 01       	ld.sh	r1,r0[0x0]
800027ca:	05 48       	ld.w	r8,--r2

800027cc <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
800027cc:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
800027ce:	f0 1f 00 22 	mcall	80002854 <app_cfg+0x88>
800027d2:	4a 28       	lddpc	r8,80002858 <app_cfg+0x8c>
800027d4:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		//if((++coun) % 200 ==0)
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800027d6:	4a 27       	lddpc	r7,8000285c <app_cfg+0x90>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
800027d8:	4a 26       	lddpc	r6,80002860 <app_cfg+0x94>
						//
						//
					//}
				//
				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				log("\n\r un: %d \n\r", is_unmute);
800027da:	4a 35       	lddpc	r5,80002864 <app_cfg+0x98>
800027dc:	4a 34       	lddpc	r4,80002868 <app_cfg+0x9c>
				//log("\n\r S_flag: %d \n\r", Silent_flag);
				//log("\n\r Tend_flag: %d \n\r", Terminator_Flag);
			
				log("\n\r AMBE_flag: %d \n\r", AMBE_flag);
800027de:	4a 43       	lddpc	r3,8000286c <app_cfg+0xa0>
800027e0:	4a 42       	lddpc	r2,80002870 <app_cfg+0xa4>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800027e2:	30 41       	mov	r1,4
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800027e4:	30 20       	mov	r0,2
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		//if((++coun) % 200 ==0)
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800027e6:	6e 08       	ld.w	r8,r7[0x0]
800027e8:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027ec:	58 38       	cp.w	r8,3
800027ee:	c2 d1       	brne	80002848 <app_cfg+0x7c>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
800027f0:	6c 08       	ld.w	r8,r6[0x0]
800027f2:	58 08       	cp.w	r8,0
800027f4:	c0 61       	brne	80002800 <app_cfg+0x34>
				{
					//xcmp_data_session();
					//xcmp_audio_route_mic();
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					xcmp_enter_device_control_mode();//3
800027f6:	f0 1f 00 20 	mcall	80002874 <app_cfg+0xa8>
					//xcmp_unmute_speaker();
					
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027fa:	30 18       	mov	r8,1
800027fc:	8d 08       	st.w	r6[0x0],r8
800027fe:	c1 58       	rjmp	80002828 <app_cfg+0x5c>
				}
				else if(isAudioRouting == 1)
80002800:	58 18       	cp.w	r8,1
80002802:	c0 51       	brne	8000280c <app_cfg+0x40>
				{
					//xcmp_function_mic();
					//xcmp_data_session();
				   // xcmp_transmit_control();
					//xcmp_volume_control();
					xcmp_enter_enhanced_OB_mode();
80002804:	f0 1f 00 1d 	mcall	80002878 <app_cfg+0xac>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
80002808:	8d 00       	st.w	r6[0x0],r0
8000280a:	c0 f8       	rjmp	80002828 <app_cfg+0x5c>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
8000280c:	58 28       	cp.w	r8,2
8000280e:	c0 61       	brne	8000281a <app_cfg+0x4e>
				{
					
					//xcmp_volume_control();
					//xcmp_data_session();
					xcmp_audio_route_AMBE();
80002810:	f0 1f 00 1b 	mcall	8000287c <app_cfg+0xb0>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
80002814:	30 38       	mov	r8,3
80002816:	8d 08       	st.w	r6[0x0],r8
80002818:	c0 88       	rjmp	80002828 <app_cfg+0x5c>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
8000281a:	58 38       	cp.w	r8,3
8000281c:	ed f1 0a 00 	st.weq	r6[0x0],r1
					
				}
				else
				{
					isAudioRouting++;
80002820:	f7 b8 01 ff 	subne	r8,-1
80002824:	ed f8 1a 00 	st.wne	r6[0x0],r8
						//
						//
					//}
				//
				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				log("\n\r un: %d \n\r", is_unmute);
80002828:	09 88       	ld.ub	r8,r4[0x0]
8000282a:	1a d8       	st.w	--sp,r8
8000282c:	0a 9c       	mov	r12,r5
8000282e:	f0 1f 00 15 	mcall	80002880 <app_cfg+0xb4>
				//log("\n\r S_flag: %d \n\r", Silent_flag);
				//log("\n\r Tend_flag: %d \n\r", Terminator_Flag);
			
				log("\n\r AMBE_flag: %d \n\r", AMBE_flag);
80002832:	05 88       	ld.ub	r8,r2[0x0]
80002834:	1a d8       	st.w	--sp,r8
80002836:	06 9c       	mov	r12,r3
80002838:	f0 1f 00 12 	mcall	80002880 <app_cfg+0xb4>
				//log("\n\r VF_SN: %x \n\r",  VF_SN);
				//log("\n\r time: %d \n\r", tc_tick);
				
				if(isAudioRouting  == 6)
8000283c:	2f ed       	sub	sp,-8
8000283e:	6c 08       	ld.w	r8,r6[0x0]
80002840:	58 68       	cp.w	r8,6
80002842:	c0 31       	brne	80002848 <app_cfg+0x7c>
					
					//xcmp_audio_route_speaker();
					//xcmp_enter_device_control_mode();//3
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					xcmp_exit_device_control_mode();
80002844:	f0 1f 00 10 	mcall	80002884 <app_cfg+0xb8>
			//log("testtime:%d", now->second);
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//2000ms
80002848:	e0 6b 0f a0 	mov	r11,4000
8000284c:	48 3c       	lddpc	r12,80002858 <app_cfg+0x8c>
8000284e:	f0 1f 00 0f 	mcall	80002888 <app_cfg+0xbc>
	}
80002852:	cc ab       	rjmp	800027e6 <app_cfg+0x1a>
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	94 34       	ld.sh	r4,r10[0x6]
80002858:	00 00       	add	r0,r0
8000285a:	0a 48       	or	r8,r5
8000285c:	00 00       	add	r0,r0
8000285e:	12 cc       	st.b	r9++,r12
80002860:	00 00       	add	r0,r0
80002862:	0a 40       	or	r0,r5
80002864:	80 01       	ld.sh	r1,r0[0x0]
80002866:	05 54       	ld.sh	r4,--r2
80002868:	00 00       	add	r0,r0
8000286a:	0a 4d       	or	sp,r5
8000286c:	80 01       	ld.sh	r1,r0[0x0]
8000286e:	05 64       	ld.uh	r4,--r2
80002870:	00 00       	add	r0,r0
80002872:	0a 44       	or	r4,r5
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	4e 84       	lddpc	r4,80002a14 <SD_ReadByte+0x4>
80002878:	80 00       	ld.sh	r0,r0[0x0]
8000287a:	4e fc       	lddpc	r12,80002a34 <SD_ReadByte+0x24>
8000287c:	80 00       	ld.sh	r0,r0[0x0]
8000287e:	4e b0       	lddpc	r0,80002a28 <SD_ReadByte+0x18>
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	9a c0       	ld.uh	r0,sp[0x8]
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	4e 54       	lddpc	r4,80002a18 <SD_ReadByte+0x8>
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	95 9c       	st.w	r10[0x24],r12

8000288c <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
8000288c:	eb cd 40 80 	pushm	r7,lr
80002890:	18 97       	mov	r7,r12
  log("R");
80002892:	48 6c       	lddpc	r12,800028a8 <app_payload_tx_proc+0x1c>
80002894:	f0 1f 00 06 	mcall	800028ac <app_payload_tx_proc+0x20>
  //fl_write("voice.dat", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
  
  //vTaskDelay(100);
  
  //payload_fragment_t * ptr = (payload_fragment_t *)payload;
  set_payload_idle(payload);
80002898:	48 68       	lddpc	r8,800028b0 <app_payload_tx_proc+0x24>
8000289a:	70 0c       	ld.w	r12,r8[0x0]
8000289c:	0e 9b       	mov	r11,r7
8000289e:	f0 1f 00 06 	mcall	800028b4 <app_payload_tx_proc+0x28>

//

}
800028a2:	e3 cd 80 80 	ldm	sp++,r7,pc
800028a6:	00 00       	add	r0,r0
800028a8:	80 01       	ld.sh	r1,r0[0x0]
800028aa:	05 78       	ld.ub	r8,--r2
800028ac:	80 00       	ld.sh	r0,r0[0x0]
800028ae:	9a c0       	ld.uh	r0,sp[0x8]
800028b0:	00 00       	add	r0,r0
800028b2:	0f a8       	ld.ub	r8,r7[0x2]
800028b4:	80 00       	ld.sh	r0,r0[0x0]
800028b6:	3a 50       	mov	r0,-91

800028b8 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
800028b8:	eb cd 40 80 	pushm	r7,lr
800028bc:	18 97       	mov	r7,r12
	log("\n\r w: \n\r");
800028be:	49 0c       	lddpc	r12,800028fc <app_payload_rx_proc+0x44>
800028c0:	f0 1f 00 10 	mcall	80002900 <app_payload_rx_proc+0x48>
	if (AMBE_flag)
800028c4:	49 08       	lddpc	r8,80002904 <app_payload_rx_proc+0x4c>
800028c6:	11 89       	ld.ub	r9,r8[0x0]
800028c8:	30 08       	mov	r8,0
800028ca:	f0 09 18 00 	cp.b	r9,r8
800028ce:	c0 90       	breq	800028e0 <app_payload_rx_proc+0x28>
	{
		fl_write("AMBEvo.bit", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
800028d0:	e0 69 02 00 	mov	r9,512
800028d4:	0e 9a       	mov	r10,r7
800028d6:	3f fb       	mov	r11,-1
800028d8:	48 cc       	lddpc	r12,80002908 <app_payload_rx_proc+0x50>
800028da:	f0 1f 00 0d 	mcall	8000290c <app_payload_rx_proc+0x54>
800028de:	c0 88       	rjmp	800028ee <app_payload_rx_proc+0x36>
	}
	else
	{
		fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
800028e0:	e0 69 02 00 	mov	r9,512
800028e4:	0e 9a       	mov	r10,r7
800028e6:	3f fb       	mov	r11,-1
800028e8:	48 ac       	lddpc	r12,80002910 <app_payload_rx_proc+0x58>
800028ea:	f0 1f 00 09 	mcall	8000290c <app_payload_rx_proc+0x54>
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
800028ee:	48 a8       	lddpc	r8,80002914 <app_payload_rx_proc+0x5c>
800028f0:	70 0c       	ld.w	r12,r8[0x0]
800028f2:	0e 9b       	mov	r11,r7
800028f4:	f0 1f 00 09 	mcall	80002918 <app_payload_rx_proc+0x60>

}
800028f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800028fc:	80 01       	ld.sh	r1,r0[0x0]
800028fe:	05 7c       	ld.ub	r12,--r2
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	9a c0       	ld.uh	r0,sp[0x8]
80002904:	00 00       	add	r0,r0
80002906:	0a 44       	or	r4,r5
80002908:	80 01       	ld.sh	r1,r0[0x0]
8000290a:	05 88       	ld.ub	r8,r2[0x0]
8000290c:	80 00       	ld.sh	r0,r0[0x0]
8000290e:	35 38       	mov	r8,83
80002910:	80 01       	ld.sh	r1,r0[0x0]
80002912:	05 94       	ld.ub	r4,r2[0x1]
80002914:	00 00       	add	r0,r0
80002916:	0f a8       	ld.ub	r8,r7[0x2]
80002918:	80 00       	ld.sh	r0,r0[0x0]
8000291a:	3a 50       	mov	r0,-91

8000291c <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
8000291c:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
8000291e:	19 e8       	ld.ub	r8,r12[0x6]
80002920:	30 19       	mov	r9,1
80002922:	f2 08 18 00 	cp.b	r8,r9
80002926:	c0 61       	brne	80002932 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002928:	48 98       	lddpc	r8,8000294c <DeviceInitializationStatus_brdcst_func+0x30>
8000292a:	70 09       	ld.w	r9,r8[0x0]
8000292c:	a1 a9       	sbr	r9,0x0
8000292e:	91 09       	st.w	r8[0x0],r9
80002930:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002932:	30 29       	mov	r9,2
80002934:	f2 08 18 00 	cp.b	r8,r9
80002938:	c0 80       	breq	80002948 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
8000293a:	48 58       	lddpc	r8,8000294c <DeviceInitializationStatus_brdcst_func+0x30>
8000293c:	70 09       	ld.w	r9,r8[0x0]
8000293e:	e0 19 ff fc 	andl	r9,0xfffc
80002942:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002944:	f0 1f 00 03 	mcall	80002950 <DeviceInitializationStatus_brdcst_func+0x34>
80002948:	d8 02       	popm	pc
8000294a:	00 00       	add	r0,r0
8000294c:	00 00       	add	r0,r0
8000294e:	12 cc       	st.b	r9++,r12
80002950:	80 00       	ld.sh	r0,r0[0x0]
80002952:	4f 20       	lddpc	r0,80002b18 <SD_SendCmd+0x4>

80002954 <SD_SPI_SetSpeed>:
	
}


void SD_SPI_SetSpeed(uint16_t SPI_BaudRatePrescaler)
{
80002954:	d4 01       	pushm	lr
 

	spi->csr0 = (spi->csr0 & (uint16_t)0x00FF) |SPI_BaudRatePrescaler;
80002956:	48 78       	lddpc	r8,80002970 <SD_SPI_SetSpeed+0x1c>
80002958:	70 09       	ld.w	r9,r8[0x0]
8000295a:	72 ca       	ld.w	r10,r9[0x30]
8000295c:	5c 7c       	castu.h	r12
8000295e:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002962:	f9 ea 10 0a 	or	r10,r12,r10
80002966:	93 ca       	st.w	r9[0x30],r10


 
    spi_enable(spi); /*!< SD_SPI enable */
80002968:	70 0c       	ld.w	r12,r8[0x0]
8000296a:	f0 1f 00 03 	mcall	80002974 <SD_SPI_SetSpeed+0x20>
	
 
}
8000296e:	d8 02       	popm	pc
80002970:	00 00       	add	r0,r0
80002972:	12 d0       	st.w	--r9,r0
80002974:	80 00       	ld.sh	r0,r0[0x0]
80002976:	5c 84       	casts.h	r4

80002978 <SD_SPI_SetSpeedHi>:

	
}

void SD_SPI_SetSpeedHi(void)
{
80002978:	d4 01       	pushm	lr

	SD_SPI_SetSpeed(0x0100);//baudDiv=1
8000297a:	e0 6c 01 00 	mov	r12,256
8000297e:	f0 1f 00 02 	mcall	80002984 <SD_SPI_SetSpeedHi+0xc>

}
80002982:	d8 02       	popm	pc
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	29 54       	sub	r4,-107

80002988 <SD_SPI_SetSpeedLow>:
	
 
}

void SD_SPI_SetSpeedLow(void)
{
80002988:	d4 01       	pushm	lr


	SD_SPI_SetSpeed(0xFF00);//baudDiv=255
8000298a:	e0 6c ff 00 	mov	r12,65280
8000298e:	f0 1f 00 02 	mcall	80002994 <SD_SPI_SetSpeedLow+0xc>


	
}
80002992:	d8 02       	popm	pc
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	29 54       	sub	r4,-107

80002998 <SD_LowLevel_Init>:
  * @   SD
  * @   
  * @ 
***------------------------------------------------------*/
void SD_LowLevel_Init(void)
{
80002998:	eb cd 40 c0 	pushm	r6-r7,lr
8000299c:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
8000299e:	49 58       	lddpc	r8,800029f0 <SD_LowLevel_Init+0x58>
800029a0:	1a 96       	mov	r6,sp
800029a2:	f0 ea 00 00 	ld.d	r10,r8[0]
800029a6:	fa eb 00 00 	st.d	sp[0],r10
800029aa:	f0 e8 00 08 	ld.d	r8,r8[8]
800029ae:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(SD_SPI_GPIO_MAP, sizeof(SD_SPI_GPIO_MAP) / sizeof(SD_SPI_GPIO_MAP[0]));
800029b2:	30 4b       	mov	r11,4
800029b4:	49 0c       	lddpc	r12,800029f4 <SD_LowLevel_Init+0x5c>
800029b6:	f0 1f 00 11 	mcall	800029f8 <SD_LowLevel_Init+0x60>

	spi = &AVR32_SPI;
800029ba:	49 17       	lddpc	r7,800029fc <SD_LowLevel_Init+0x64>
800029bc:	fe 7c 24 00 	mov	r12,-56320
800029c0:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
800029c2:	1a 9b       	mov	r11,sp
800029c4:	f0 1f 00 0f 	mcall	80002a00 <SD_LowLevel_Init+0x68>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
800029c8:	30 09       	mov	r9,0
800029ca:	12 9a       	mov	r10,r9
800029cc:	12 9b       	mov	r11,r9
800029ce:	6e 0c       	ld.w	r12,r7[0x0]
800029d0:	f0 1f 00 0d 	mcall	80002a04 <SD_LowLevel_Init+0x6c>

	// Enable SPI.
	spi_enable(spi);
800029d4:	6e 0c       	ld.w	r12,r7[0x0]
800029d6:	f0 1f 00 0d 	mcall	80002a08 <SD_LowLevel_Init+0x70>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, SPI_Clock_PBA) != SPI_OK)
800029da:	e0 6a 36 00 	mov	r10,13824
800029de:	ea 1a 01 6e 	orh	r10,0x16e
800029e2:	1a 9b       	mov	r11,sp
800029e4:	6e 0c       	ld.w	r12,r7[0x0]
800029e6:	f0 1f 00 0a 	mcall	80002a0c <SD_LowLevel_Init+0x74>
	return;
	}


	
}
800029ea:	2f cd       	sub	sp,-16
800029ec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800029f0:	80 01       	ld.sh	r1,r0[0x0]
800029f2:	05 b4       	ld.ub	r4,r2[0x3]
800029f4:	80 01       	ld.sh	r1,r0[0x0]
800029f6:	05 c4       	ld.ub	r4,r2[0x4]
800029f8:	80 00       	ld.sh	r0,r0[0x0]
800029fa:	9f 60       	st.w	pc[0x18],r0
800029fc:	00 00       	add	r0,r0
800029fe:	12 d0       	st.w	--r9,r0
80002a00:	80 00       	ld.sh	r0,r0[0x0]
80002a02:	5a ec       	cp.w	r12,-18
80002a04:	80 00       	ld.sh	r0,r0[0x0]
80002a06:	5b 24       	cp.w	r4,-14
80002a08:	80 00       	ld.sh	r0,r0[0x0]
80002a0a:	5c 84       	casts.h	r4
80002a0c:	80 00       	ld.sh	r0,r0[0x0]
80002a0e:	5b c2       	cp.w	r2,-4

80002a10 <SD_ReadByte>:
  * @   SD
  * @    
  * @  The received byte
***------------------------------------------------------*/  
uint8_t SD_ReadByte(void)
{
80002a10:	eb cd 40 c0 	pushm	r6-r7,lr
  unsigned short *Data ;

  //
  spi_selectChip(spi, SD_SPI_PCS_0);
80002a14:	48 b7       	lddpc	r7,80002a40 <SD_ReadByte+0x30>
80002a16:	30 0b       	mov	r11,0
80002a18:	6e 0c       	ld.w	r12,r7[0x0]
80002a1a:	f0 1f 00 0b 	mcall	80002a44 <SD_ReadByte+0x34>
  
  /*!< Send the byte */

  spi_write(spi,  SD_DUMMY_BYTE);
80002a1e:	e0 6b 00 ff 	mov	r11,255
80002a22:	6e 0c       	ld.w	r12,r7[0x0]
80002a24:	f0 1f 00 09 	mcall	80002a48 <SD_ReadByte+0x38>
  
  /*!< Return the byte read from the SPI bus */ 

   spi_read(spi, Data);
80002a28:	30 06       	mov	r6,0
80002a2a:	0c 9b       	mov	r11,r6
80002a2c:	6e 0c       	ld.w	r12,r7[0x0]
80002a2e:	f0 1f 00 08 	mcall	80002a4c <SD_ReadByte+0x3c>

  /*!< Return the shifted data */
  
  spi_unselectChip(spi, SD_SPI_PCS_0);
80002a32:	0c 9b       	mov	r11,r6
80002a34:	6e 0c       	ld.w	r12,r7[0x0]
80002a36:	f0 1f 00 07 	mcall	80002a50 <SD_ReadByte+0x40>
  
  return (uint8_t)(*Data);//
}
80002a3a:	0d 9c       	ld.ub	r12,r6[0x1]
80002a3c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a40:	00 00       	add	r0,r0
80002a42:	12 d0       	st.w	--r9,r0
80002a44:	80 00       	ld.sh	r0,r0[0x0]
80002a46:	5b 50       	cp.w	r0,-11
80002a48:	80 00       	ld.sh	r0,r0[0x0]
80002a4a:	5c 8a       	casts.h	r10
80002a4c:	80 00       	ld.sh	r0,r0[0x0]
80002a4e:	5c a6       	swap.h	r6
80002a50:	80 00       	ld.sh	r0,r0[0x0]
80002a52:	5b 9c       	cp.w	r12,-7

80002a54 <SD_GetResponse>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetResponse(uint8_t Response)
{
80002a54:	eb cd 40 c0 	pushm	r6-r7,lr
80002a58:	18 96       	mov	r6,r12
80002a5a:	e0 67 8f ff 	mov	r7,36863
  uint32_t Count = 0x8FFF;

  /*!< Check if response is got or a timeout is happen */
  while ((SD_ReadByte() != Response) && Count)
80002a5e:	c0 28       	rjmp	80002a62 <SD_GetResponse+0xe>
  {
    Count--;
80002a60:	20 17       	sub	r7,1
SD_Error SD_GetResponse(uint8_t Response)
{
  uint32_t Count = 0x8FFF;

  /*!< Check if response is got or a timeout is happen */
  while ((SD_ReadByte() != Response) && Count)
80002a62:	f0 1f 00 09 	mcall	80002a84 <SD_GetResponse+0x30>
80002a66:	ec 0c 18 00 	cp.b	r12,r6
80002a6a:	c0 40       	breq	80002a72 <SD_GetResponse+0x1e>
80002a6c:	58 07       	cp.w	r7,0
80002a6e:	cf 91       	brne	80002a60 <SD_GetResponse+0xc>
80002a70:	c0 58       	rjmp	80002a7a <SD_GetResponse+0x26>
  {
    Count--;
  }
  if (Count == 0)
80002a72:	58 07       	cp.w	r7,0
80002a74:	c0 30       	breq	80002a7a <SD_GetResponse+0x26>
80002a76:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80002a7a:	e0 6c 00 ff 	mov	r12,255
  else
  {
    /*!< Right response got */
    return SD_RESPONSE_NO_ERROR;
  }
}
80002a7e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a82:	00 00       	add	r0,r0
80002a84:	80 00       	ld.sh	r0,r0[0x0]
80002a86:	2a 10       	sub	r0,-95

80002a88 <SD_GetDataResponse>:
  *         - status 101: Data rejected due to a crc error
  *         - status 110: Data rejected due to a Write error.
  *         - status 111: Data rejected due to other error.
  */
uint8_t SD_GetDataResponse(void)
{
80002a88:	eb cd 40 f8 	pushm	r3-r7,lr
80002a8c:	30 06       	mov	r6,0
  {
    /*!< Read resonse */
    response = SD_ReadByte();
    /*!< Mask unused bits */
    response &= 0x1F;
    switch (response)
80002a8e:	30 b5       	mov	r5,11
80002a90:	30 d4       	mov	r4,13
80002a92:	30 53       	mov	r3,5
  uint8_t response, rvalue;

  while (i <= 64)
  {
    /*!< Read resonse */
    response = SD_ReadByte();
80002a94:	f0 1f 00 0c 	mcall	80002ac4 <SD_GetDataResponse+0x3c>
    /*!< Mask unused bits */
    response &= 0x1F;
80002a98:	ef dc c0 05 	bfextu	r7,r12,0x0,0x5
    switch (response)
80002a9c:	ea 07 18 00 	cp.b	r7,r5
80002aa0:	c0 e0       	breq	80002abc <SD_GetDataResponse+0x34>
80002aa2:	e8 07 18 00 	cp.b	r7,r4
80002aa6:	c0 b0       	breq	80002abc <SD_GetDataResponse+0x34>
80002aa8:	e6 07 18 00 	cp.b	r7,r3
80002aac:	c0 50       	breq	80002ab6 <SD_GetDataResponse+0x2e>
    }
    /*!< Exit loop in case of data ok */
    if (rvalue == SD_DATA_OK)
      break;
    /*!< Increment loop counter */
    i++;
80002aae:	2f f6       	sub	r6,-1
uint8_t SD_GetDataResponse(void)
{
  uint32_t i = 0;
  uint8_t response, rvalue;

  while (i <= 64)
80002ab0:	e0 46 00 41 	cp.w	r6,65
80002ab4:	cf 01       	brne	80002a94 <SD_GetDataResponse+0xc>
    /*!< Increment loop counter */
    i++;
  }

  /*!< Wait null data */
  while (SD_ReadByte() == 0);
80002ab6:	f0 1f 00 04 	mcall	80002ac4 <SD_GetDataResponse+0x3c>
80002aba:	cf e0       	breq	80002ab6 <SD_GetDataResponse+0x2e>

  /*!< Return response */
  return response;
}
80002abc:	0e 9c       	mov	r12,r7
80002abe:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002ac2:	00 00       	add	r0,r0
80002ac4:	80 00       	ld.sh	r0,r0[0x0]
80002ac6:	2a 10       	sub	r0,-95

80002ac8 <SD_WriteByte>:
  * @brief  Write a byte on the SD.
  * @param  Data: byte to send.
  * @retval None
  */
uint8_t SD_WriteByte(uint8_t Data)
{
80002ac8:	eb cd 40 c0 	pushm	r6-r7,lr
80002acc:	20 1d       	sub	sp,4
80002ace:	ba 8c       	st.b	sp[0x0],r12
  uint8_t temp;
  
  //
  spi_selectChip(spi, SD_SPI_PCS_0);
80002ad0:	48 c7       	lddpc	r7,80002b00 <SD_WriteByte+0x38>
80002ad2:	30 0b       	mov	r11,0
80002ad4:	6e 0c       	ld.w	r12,r7[0x0]
80002ad6:	f0 1f 00 0c 	mcall	80002b04 <SD_WriteByte+0x3c>
  
  /*!< Send the byte */
  spi_write(spi,  (U16)Data);
80002ada:	1b 8b       	ld.ub	r11,sp[0x0]
80002adc:	6e 0c       	ld.w	r12,r7[0x0]
80002ade:	f0 1f 00 0b 	mcall	80002b08 <SD_WriteByte+0x40>
  

  /*!< Wait to receive a byte*/

  temp = spi_read(spi, (U16*)&Data);
80002ae2:	1a 9b       	mov	r11,sp
80002ae4:	6e 0c       	ld.w	r12,r7[0x0]
80002ae6:	f0 1f 00 0a 	mcall	80002b0c <SD_WriteByte+0x44>
80002aea:	18 96       	mov	r6,r12
  
  spi_unselectChip(spi, SD_SPI_PCS_0);
80002aec:	30 0b       	mov	r11,0
80002aee:	6e 0c       	ld.w	r12,r7[0x0]
80002af0:	f0 1f 00 08 	mcall	80002b10 <SD_WriteByte+0x48>
  
  /*!< Return the byte read from the SPI bus */ 
  return  temp;
    
}
80002af4:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80002af8:	2f fd       	sub	sp,-4
80002afa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002afe:	00 00       	add	r0,r0
80002b00:	00 00       	add	r0,r0
80002b02:	12 d0       	st.w	--r9,r0
80002b04:	80 00       	ld.sh	r0,r0[0x0]
80002b06:	5b 50       	cp.w	r0,-11
80002b08:	80 00       	ld.sh	r0,r0[0x0]
80002b0a:	5c 8a       	casts.h	r10
80002b0c:	80 00       	ld.sh	r0,r0[0x0]
80002b0e:	5c a6       	swap.h	r6
80002b10:	80 00       	ld.sh	r0,r0[0x0]
80002b12:	5b 9c       	cp.w	r12,-7

80002b14 <SD_SendCmd>:
  * @param  Arg: 
  * @param  Crc: CRC
  * @retval None
  */
void SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
{
80002b14:	eb cd 40 c0 	pushm	r6-r7,lr
80002b18:	20 2d       	sub	sp,8
  uint32_t i = 0x00;
  
  uint8_t Frame[6];

  Frame[0] = (Cmd | 0x40); /*!< Construct byte 1 */
80002b1a:	a7 ac       	sbr	r12,0x6
80002b1c:	ba 8c       	st.b	sp[0x0],r12
  
  Frame[1] = (uint8_t)(Arg >> 24); /*!< Construct byte 2 */
80002b1e:	f6 08 16 18 	lsr	r8,r11,0x18
80002b22:	ba 98       	st.b	sp[0x1],r8
  
  Frame[2] = (uint8_t)(Arg >> 16); /*!< Construct byte 3 */
80002b24:	f6 08 16 10 	lsr	r8,r11,0x10
80002b28:	ba a8       	st.b	sp[0x2],r8
  
  Frame[3] = (uint8_t)(Arg >> 8); /*!< Construct byte 4 */
80002b2a:	f6 08 16 08 	lsr	r8,r11,0x8
80002b2e:	ba b8       	st.b	sp[0x3],r8
  
  Frame[4] = (uint8_t)(Arg); /*!< Construct byte 5 */
80002b30:	ba cb       	st.b	sp[0x4],r11
  
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
80002b32:	ba da       	st.b	sp[0x5],r10
80002b34:	1a 97       	mov	r7,sp
  * @param  Cmd: .
  * @param  Arg: 
  * @param  Crc: CRC
  * @retval None
  */
void SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
80002b36:	fa c6 ff fa 	sub	r6,sp,-6
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
  
  for (i = 0; i < 6; i++)
  {

	SD_WriteByte(Frame[i]); /*!< Send the Cmd bytes */
80002b3a:	0f 3c       	ld.ub	r12,r7++
80002b3c:	f0 1f 00 04 	mcall	80002b4c <SD_SendCmd+0x38>
  
  Frame[4] = (uint8_t)(Arg); /*!< Construct byte 5 */
  
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
  
  for (i = 0; i < 6; i++)
80002b40:	0c 37       	cp.w	r7,r6
80002b42:	cf c1       	brne	80002b3a <SD_SendCmd+0x26>
  {

	SD_WriteByte(Frame[i]); /*!< Send the Cmd bytes */

  }
}
80002b44:	2f ed       	sub	sp,-8
80002b46:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b4a:	00 00       	add	r0,r0
80002b4c:	80 00       	ld.sh	r0,r0[0x0]
80002b4e:	2a c8       	sub	r8,-84

80002b50 <SD_GoIdleState>:
  * @   SD
  * @    
  * @  
***------------------------------------------------------*/
SD_Error SD_GoIdleState(void)
{
80002b50:	d4 31       	pushm	r0-r7,lr
  uint8_t r1;
  SD_Error Status = SD_RESPONSE_NO_ERROR;
  uint16_t n2,n;

  /* CS */
  SD_CS_LOW();
80002b52:	31 8c       	mov	r12,24
80002b54:	f0 1f 00 6a 	mcall	80002cfc <SD_GoIdleState+0x1ac>
  
  /* CM0SDSPI */
  SD_SendCmd(SD_CMD_GO_IDLE_STATE, 0, 0x95);
80002b58:	e0 6a 00 95 	mov	r10,149
80002b5c:	30 0b       	mov	r11,0
80002b5e:	16 9c       	mov	r12,r11
80002b60:	f0 1f 00 68 	mcall	80002d00 <SD_GoIdleState+0x1b0>
  
  /* 0x01 */
  if (SD_GetResponse  (SD_IN_IDLE_STATE))
80002b64:	30 1c       	mov	r12,1
80002b66:	f0 1f 00 68 	mcall	80002d04 <SD_GoIdleState+0x1b4>
80002b6a:	e0 81 00 a8 	brne	80002cba <SD_GoIdleState+0x16a>
    return SD_RESPONSE_FAILURE;
  }

  
  /*CMD8*/
  SD_SendCmd(8, 0x1AA, 0x87);
80002b6e:	e0 6a 00 87 	mov	r10,135
80002b72:	e0 6b 01 aa 	mov	r11,426
80002b76:	30 8c       	mov	r12,8
80002b78:	f0 1f 00 62 	mcall	80002d00 <SD_GoIdleState+0x1b0>
80002b7c:	e0 67 00 c8 	mov	r7,200

  /*  */
  TimeOut = 200;
  while (((r1 = SD_ReadByte()) == 0xFF) && TimeOut)
80002b80:	3f f6       	mov	r6,-1
80002b82:	c0 38       	rjmp	80002b88 <SD_GoIdleState+0x38>
  {
    TimeOut--;
80002b84:	20 17       	sub	r7,1
80002b86:	5c 87       	casts.h	r7
  /*CMD8*/
  SD_SendCmd(8, 0x1AA, 0x87);

  /*  */
  TimeOut = 200;
  while (((r1 = SD_ReadByte()) == 0xFF) && TimeOut)
80002b88:	f0 1f 00 60 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002b8c:	ec 0c 18 00 	cp.b	r12,r6
80002b90:	c0 41       	brne	80002b98 <SD_GoIdleState+0x48>
80002b92:	58 07       	cp.w	r7,0
80002b94:	cf 81       	brne	80002b84 <SD_GoIdleState+0x34>
80002b96:	c2 68       	rjmp	80002be2 <SD_GoIdleState+0x92>
  {
    TimeOut--;
  }

  if(r1 == 0x05) 
80002b98:	30 58       	mov	r8,5
80002b9a:	f0 0c 18 00 	cp.b	r12,r8
80002b9e:	c2 21       	brne	80002be2 <SD_GoIdleState+0x92>
80002ba0:	c9 48       	rjmp	80002cc8 <SD_GoIdleState+0x178>
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002ba2:	08 9c       	mov	r12,r4
80002ba4:	f0 1f 00 5a 	mcall	80002d0c <SD_GoIdleState+0x1bc>
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002ba8:	06 9c       	mov	r12,r3
80002baa:	f0 1f 00 5a 	mcall	80002d10 <SD_GoIdleState+0x1c0>
      
      /* CS */
      SD_CS_LOW();
80002bae:	08 9c       	mov	r12,r4
80002bb0:	f0 1f 00 53 	mcall	80002cfc <SD_GoIdleState+0x1ac>
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002bb4:	06 9a       	mov	r10,r3
80002bb6:	0a 9b       	mov	r11,r5
80002bb8:	02 9c       	mov	r12,r1
80002bba:	f0 1f 00 52 	mcall	80002d00 <SD_GoIdleState+0x1b0>
      /* error Response0x00 */
      TimeOut++;
80002bbe:	2f f6       	sub	r6,-1
80002bc0:	5c 86       	casts.h	r6
    
      if(TimeOut == 0x00F0)
80002bc2:	e4 06 19 00 	cp.h	r6,r2
80002bc6:	c0 60       	breq	80002bd2 <SD_GoIdleState+0x82>
      {
        break;
      }
  	
  	Status = SD_GetResponse(SD_RESPONSE_NO_ERROR);	
80002bc8:	0a 9c       	mov	r12,r5
80002bca:	f0 1f 00 4f 	mcall	80002d04 <SD_GoIdleState+0x1b4>
80002bce:	18 97       	mov	r7,r12
    }
    while (Status);
80002bd0:	ce 91       	brne	80002ba2 <SD_GoIdleState+0x52>
    
    /* CS */
    SD_CS_HIGH();
80002bd2:	31 8c       	mov	r12,24
80002bd4:	f0 1f 00 4e 	mcall	80002d0c <SD_GoIdleState+0x1bc>
    
    /*dummy byte 0xFF */
    SD_WriteByte(SD_DUMMY_BYTE);    
80002bd8:	e0 6c 00 ff 	mov	r12,255
80002bdc:	f0 1f 00 4d 	mcall	80002d10 <SD_GoIdleState+0x1c0>
80002be0:	c6 f8       	rjmp	80002cbe <SD_GoIdleState+0x16e>
    r1 = 1;

    /* SD5 */
    for(n=0; n<5; n++)
    {
      SD_ReadByte();
80002be2:	f0 1f 00 4a 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002be6:	f0 1f 00 49 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002bea:	f0 1f 00 48 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002bee:	f0 1f 00 47 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002bf2:	f0 1f 00 46 	mcall	80002d08 <SD_GoIdleState+0x1b8>
    }
  
    /* CS */
    SD_CS_HIGH();
80002bf6:	31 8c       	mov	r12,24
80002bf8:	f0 1f 00 45 	mcall	80002d0c <SD_GoIdleState+0x1bc>
    SD_WriteByte(SD_DUMMY_BYTE);
80002bfc:	e0 6c 00 ff 	mov	r12,255
80002c00:	f0 1f 00 44 	mcall	80002d10 <SD_GoIdleState+0x1c0>
    /* CS */
    SD_CS_LOW();
80002c04:	31 8c       	mov	r12,24
80002c06:	f0 1f 00 3e 	mcall	80002cfc <SD_GoIdleState+0x1ac>
    SD_WriteByte(SD_DUMMY_BYTE);
80002c0a:	e0 6c 00 ff 	mov	r12,255
80002c0e:	f0 1f 00 41 	mcall	80002d10 <SD_GoIdleState+0x1c0>
    SD_WriteByte(SD_DUMMY_BYTE);
80002c12:	e0 6c 00 ff 	mov	r12,255
80002c16:	f0 1f 00 3f 	mcall	80002d10 <SD_GoIdleState+0x1c0>
80002c1a:	e0 64 00 ff 	mov	r4,255
    n=0xff;
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
80002c1e:	08 91       	mov	r1,r4
80002c20:	30 02       	mov	r2,0
      for(n2=0; n2<0x08;n2++)
      {
       r1= SD_ReadByte();
       if(r1 !=1)
80002c22:	30 15       	mov	r5,1
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
      for(n2=0; n2<0x08;n2++)
80002c24:	30 83       	mov	r3,8

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
  
      for(n2=0; n2<0xff;n2++)
80002c26:	e0 66 00 ff 	mov	r6,255
    n=0xff;
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
80002c2a:	02 9a       	mov	r10,r1
80002c2c:	04 9b       	mov	r11,r2
80002c2e:	33 7c       	mov	r12,55
80002c30:	f0 1f 00 34 	mcall	80002d00 <SD_GoIdleState+0x1b0>
80002c34:	04 97       	mov	r7,r2
      for(n2=0; n2<0x08;n2++)
      {
       r1= SD_ReadByte();
80002c36:	f0 1f 00 35 	mcall	80002d08 <SD_GoIdleState+0x1b8>
       if(r1 !=1)
80002c3a:	f8 05 18 00 	cp.b	r5,r12
80002c3e:	f9 b4 01 00 	movne	r4,0
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
      for(n2=0; n2<0x08;n2++)
80002c42:	2f f7       	sub	r7,-1
80002c44:	5c 87       	casts.h	r7
80002c46:	e6 07 19 00 	cp.h	r7,r3
80002c4a:	cf 61       	brne	80002c36 <SD_GoIdleState+0xe6>
80002c4c:	08 90       	mov	r0,r4
80002c4e:	5c 80       	casts.h	r0
		   n=0;
	   }

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
80002c50:	04 9a       	mov	r10,r2
80002c52:	fc 1b 40 00 	movh	r11,0x4000
80002c56:	32 9c       	mov	r12,41
80002c58:	f0 1f 00 2a 	mcall	80002d00 <SD_GoIdleState+0x1b0>
80002c5c:	04 97       	mov	r7,r2
  
      for(n2=0; n2<0xff;n2++)
      {
       r1= SD_ReadByte();
80002c5e:	f0 1f 00 2b 	mcall	80002d08 <SD_GoIdleState+0x1b8>
       if(r1 ==0)break;
80002c62:	c3 00       	breq	80002cc2 <SD_GoIdleState+0x172>

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
  
      for(n2=0; n2<0xff;n2++)
80002c64:	2f f7       	sub	r7,-1
80002c66:	5c 87       	casts.h	r7
80002c68:	ec 07 19 00 	cp.h	r7,r6
80002c6c:	cf 91       	brne	80002c5e <SD_GoIdleState+0x10e>
      {
       r1= SD_ReadByte();
       if(r1 ==0)break;
      }
      n--;
80002c6e:	e0 c4 00 01 	sub	r4,r0,1
80002c72:	5c 84       	casts.h	r4
    }while((r1!=0)&&(n>0));
80002c74:	30 08       	mov	r8,0
80002c76:	f0 0c 18 00 	cp.b	r12,r8
80002c7a:	5f 1a       	srne	r10
80002c7c:	30 09       	mov	r9,0
80002c7e:	f2 04 19 00 	cp.h	r4,r9
80002c82:	5f 19       	srne	r9
80002c84:	f5 e9 00 09 	and	r9,r10,r9
80002c88:	f0 09 18 00 	cp.b	r9,r8
80002c8c:	cc f1       	brne	80002c2a <SD_GoIdleState+0xda>

    if(n==0)
80002c8e:	58 04       	cp.w	r4,0
80002c90:	c1 50       	breq	80002cba <SD_GoIdleState+0x16a>
      //printf("\r\n SDHC\n");
    }
    else
    {
	  /* CMD58 */
      SD_SendCmd(58, 0, 0);
80002c92:	30 0a       	mov	r10,0
80002c94:	14 9b       	mov	r11,r10
80002c96:	33 ac       	mov	r12,58
80002c98:	f0 1f 00 1a 	mcall	80002d00 <SD_GoIdleState+0x1b0>
      for(n=0;n<5;n++)
      {
      r1 = SD_ReadByte();
80002c9c:	f0 1f 00 1b 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002ca0:	f0 1f 00 1a 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002ca4:	f0 1f 00 19 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002ca8:	f0 1f 00 18 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002cac:	f0 1f 00 17 	mcall	80002d08 <SD_GoIdleState+0x1b8>
      }
	  flag_SDHC = 1;
80002cb0:	30 19       	mov	r9,1
80002cb2:	49 98       	lddpc	r8,80002d14 <SD_GoIdleState+0x1c4>
80002cb4:	b0 89       	st.b	r8[0x0],r9
80002cb6:	30 07       	mov	r7,0
80002cb8:	c0 38       	rjmp	80002cbe <SD_GoIdleState+0x16e>
80002cba:	e0 67 00 ff 	mov	r7,255
    //printf("\n\r SD cards inint Done.");
  }  
  */
    
  return Status;
}
80002cbe:	0e 9c       	mov	r12,r7
80002cc0:	d8 32       	popm	r0-r7,pc
      for(n2=0; n2<0xff;n2++)
      {
       r1= SD_ReadByte();
       if(r1 ==0)break;
      }
      n--;
80002cc2:	20 14       	sub	r4,1
80002cc4:	5c 84       	casts.h	r4
80002cc6:	ce 4b       	rjmp	80002c8e <SD_GoIdleState+0x13e>
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002cc8:	31 8c       	mov	r12,24
80002cca:	f0 1f 00 11 	mcall	80002d0c <SD_GoIdleState+0x1bc>
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002cce:	e0 6c 00 ff 	mov	r12,255
80002cd2:	f0 1f 00 10 	mcall	80002d10 <SD_GoIdleState+0x1c0>
      
      /* CS */
      SD_CS_LOW();
80002cd6:	31 8c       	mov	r12,24
80002cd8:	f0 1f 00 09 	mcall	80002cfc <SD_GoIdleState+0x1ac>
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002cdc:	e0 6a 00 ff 	mov	r10,255
80002ce0:	30 0b       	mov	r11,0
80002ce2:	30 1c       	mov	r12,1
80002ce4:	f0 1f 00 07 	mcall	80002d00 <SD_GoIdleState+0x1b0>
80002ce8:	30 16       	mov	r6,1
      if(TimeOut == 0x00F0)
      {
        break;
      }
  	
  	Status = SD_GetResponse(SD_RESPONSE_NO_ERROR);	
80002cea:	30 05       	mov	r5,0
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002cec:	31 84       	mov	r4,24
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002cee:	e0 63 00 ff 	mov	r3,255
      
      /* CS */
      SD_CS_LOW();
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002cf2:	0c 91       	mov	r1,r6
      /* error Response0x00 */
      TimeOut++;
    
      if(TimeOut == 0x00F0)
80002cf4:	e0 62 00 f0 	mov	r2,240
80002cf8:	c6 8b       	rjmp	80002bc8 <SD_GoIdleState+0x78>
80002cfa:	00 00       	add	r0,r0
80002cfc:	80 00       	ld.sh	r0,r0[0x0]
80002cfe:	9f ac       	st.w	pc[0x28],r12
80002d00:	80 00       	ld.sh	r0,r0[0x0]
80002d02:	2b 14       	sub	r4,-79
80002d04:	80 00       	ld.sh	r0,r0[0x0]
80002d06:	2a 54       	sub	r4,-91
80002d08:	80 00       	ld.sh	r0,r0[0x0]
80002d0a:	2a 10       	sub	r0,-95
80002d0c:	80 00       	ld.sh	r0,r0[0x0]
80002d0e:	9f 90       	st.w	pc[0x24],r0
80002d10:	80 00       	ld.sh	r0,r0[0x0]
80002d12:	2a c8       	sub	r8,-84
80002d14:	00 00       	add	r0,r0
80002d16:	0a 68       	and	r8,r5

80002d18 <SD_GetCIDRegister>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCIDRegister(SD_CID* SD_cid)
{
80002d18:	eb cd 40 e0 	pushm	r5-r7,lr
80002d1c:	20 4d       	sub	sp,16
80002d1e:	18 97       	mov	r7,r12
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  uint8_t CID_Tab[16];
  
  /*!< SD chip select low */
  SD_CS_LOW();
80002d20:	31 8c       	mov	r12,24
80002d22:	f0 1f 00 44 	mcall	80002e30 <SD_GetCIDRegister+0x118>
  
  /*!< Send CMD10 (CID register) */
  SD_SendCmd(SD_CMD_SEND_CID, 0, 0xFF);
80002d26:	e0 6a 00 ff 	mov	r10,255
80002d2a:	30 0b       	mov	r11,0
80002d2c:	30 ac       	mov	r12,10
80002d2e:	f0 1f 00 42 	mcall	80002e34 <SD_GetCIDRegister+0x11c>
  
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002d32:	30 0c       	mov	r12,0
80002d34:	f0 1f 00 41 	mcall	80002e38 <SD_GetCIDRegister+0x120>
80002d38:	c0 40       	breq	80002d40 <SD_GetCIDRegister+0x28>
80002d3a:	e0 66 00 ff 	mov	r6,255
80002d3e:	c1 78       	rjmp	80002d6c <SD_GetCIDRegister+0x54>
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
80002d40:	e0 6c 00 fe 	mov	r12,254
80002d44:	f0 1f 00 3d 	mcall	80002e38 <SD_GetCIDRegister+0x120>
80002d48:	c0 91       	brne	80002d5a <SD_GetCIDRegister+0x42>
80002d4a:	1a 96       	mov	r6,sp
  * @param  SD_cid: pointer on an CID register structure
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCIDRegister(SD_CID* SD_cid)
80002d4c:	fa c5 ff f0 	sub	r5,sp,-16
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Store CID register value on CID_Tab */
      for (i = 0; i < 16; i++)
      {
        CID_Tab[i] = SD_ReadByte();
80002d50:	f0 1f 00 3b 	mcall	80002e3c <SD_GetCIDRegister+0x124>
80002d54:	0c cc       	st.b	r6++,r12
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Store CID register value on CID_Tab */
      for (i = 0; i < 16; i++)
80002d56:	0a 36       	cp.w	r6,r5
80002d58:	cf c1       	brne	80002d50 <SD_GetCIDRegister+0x38>
      {
        CID_Tab[i] = SD_ReadByte();
      }
    }
    /*!< Get CRC bytes (not really needed by us, but required by SD) */
    SD_WriteByte(SD_DUMMY_BYTE);
80002d5a:	e0 6c 00 ff 	mov	r12,255
80002d5e:	f0 1f 00 39 	mcall	80002e40 <SD_GetCIDRegister+0x128>
    SD_WriteByte(SD_DUMMY_BYTE);
80002d62:	e0 6c 00 ff 	mov	r12,255
80002d66:	f0 1f 00 37 	mcall	80002e40 <SD_GetCIDRegister+0x128>
80002d6a:	30 06       	mov	r6,0
    /*!< Set response value to success */
    rvalue = SD_RESPONSE_NO_ERROR;
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002d6c:	31 8c       	mov	r12,24
80002d6e:	f0 1f 00 36 	mcall	80002e44 <SD_GetCIDRegister+0x12c>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002d72:	e0 6c 00 ff 	mov	r12,255
80002d76:	f0 1f 00 33 	mcall	80002e40 <SD_GetCIDRegister+0x128>

  /*!< Byte 0 */
  SD_cid->ManufacturerID = CID_Tab[0];
80002d7a:	1b 88       	ld.ub	r8,sp[0x0]
80002d7c:	ae 88       	st.b	r7[0x0],r8

  /*!< Byte 1 */
  SD_cid->OEM_AppliID = CID_Tab[1] << 8;
80002d7e:	fb 28 00 01 	ld.sb	r8,sp[1]
80002d82:	a9 68       	lsl	r8,0x8
80002d84:	ae 18       	st.h	r7[0x2],r8

  /*!< Byte 2 */
  SD_cid->OEM_AppliID |= CID_Tab[2];
80002d86:	8e 19       	ld.sh	r9,r7[0x2]
80002d88:	1b a8       	ld.ub	r8,sp[0x2]
80002d8a:	f3 e8 10 08 	or	r8,r9,r8
80002d8e:	ae 18       	st.h	r7[0x2],r8

  /*!< Byte 3 */
  SD_cid->ProdName1 = CID_Tab[3] << 24;
80002d90:	1b b8       	ld.ub	r8,sp[0x3]
80002d92:	b9 68       	lsl	r8,0x18
80002d94:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 4 */
  SD_cid->ProdName1 |= CID_Tab[4] << 16;
80002d96:	6e 18       	ld.w	r8,r7[0x4]
80002d98:	1b c9       	ld.ub	r9,sp[0x4]
80002d9a:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80002d9e:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 5 */
  SD_cid->ProdName1 |= CID_Tab[5] << 8;
80002da0:	6e 18       	ld.w	r8,r7[0x4]
80002da2:	1b d9       	ld.ub	r9,sp[0x5]
80002da4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002da8:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 6 */
  SD_cid->ProdName1 |= CID_Tab[6];
80002daa:	6e 18       	ld.w	r8,r7[0x4]
80002dac:	1b e9       	ld.ub	r9,sp[0x6]
80002dae:	f3 e8 10 08 	or	r8,r9,r8
80002db2:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 7 */
  SD_cid->ProdName2 = CID_Tab[7];
80002db4:	1b f8       	ld.ub	r8,sp[0x7]
80002db6:	ef 68 00 08 	st.b	r7[8],r8

  /*!< Byte 8 */
  SD_cid->ProdRev = CID_Tab[8];
80002dba:	fb 38 00 08 	ld.ub	r8,sp[8]
80002dbe:	ef 68 00 09 	st.b	r7[9],r8

  /*!< Byte 9 */
  SD_cid->ProdSN = CID_Tab[9] << 24;
80002dc2:	fb 38 00 09 	ld.ub	r8,sp[9]
80002dc6:	b9 68       	lsl	r8,0x18
80002dc8:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 10 */
  SD_cid->ProdSN |= CID_Tab[10] << 16;
80002dca:	6e 38       	ld.w	r8,r7[0xc]
80002dcc:	fb 39 00 0a 	ld.ub	r9,sp[10]
80002dd0:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80002dd4:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 11 */
  SD_cid->ProdSN |= CID_Tab[11] << 8;
80002dd6:	6e 38       	ld.w	r8,r7[0xc]
80002dd8:	fb 39 00 0b 	ld.ub	r9,sp[11]
80002ddc:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002de0:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 12 */
  SD_cid->ProdSN |= CID_Tab[12];
80002de2:	6e 38       	ld.w	r8,r7[0xc]
80002de4:	fb 39 00 0c 	ld.ub	r9,sp[12]
80002de8:	f3 e8 10 08 	or	r8,r9,r8
80002dec:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 13 */
  SD_cid->Reserved1 |= (CID_Tab[13] & 0xF0) >> 4;
80002dee:	ef 39 00 10 	ld.ub	r9,r7[16]
80002df2:	fb 38 00 0d 	ld.ub	r8,sp[13]
80002df6:	f3 e8 12 49 	or	r9,r9,r8>>0x4
80002dfa:	ef 69 00 10 	st.b	r7[16],r9
  SD_cid->ManufactDate = (CID_Tab[13] & 0x0F) << 8;
80002dfe:	a9 68       	lsl	r8,0x8
80002e00:	e2 18 0f 00 	andl	r8,0xf00,COH
80002e04:	ef 58 00 12 	st.h	r7[18],r8

  /*!< Byte 14 */
  SD_cid->ManufactDate |= CID_Tab[14];
80002e08:	ef 09 00 12 	ld.sh	r9,r7[18]
80002e0c:	fb 38 00 0e 	ld.ub	r8,sp[14]
80002e10:	f3 e8 10 08 	or	r8,r9,r8
80002e14:	ef 58 00 12 	st.h	r7[18],r8

  /*!< Byte 15 */
  SD_cid->CID_CRC = (CID_Tab[15] & 0xFE) >> 1;
80002e18:	fb 38 00 0f 	ld.ub	r8,sp[15]
80002e1c:	a1 98       	lsr	r8,0x1
80002e1e:	ef 68 00 14 	st.b	r7[20],r8
  SD_cid->Reserved2 = 1;
80002e22:	30 18       	mov	r8,1
80002e24:	ef 68 00 15 	st.b	r7[21],r8

  /*!< Return the reponse */
  return rvalue;
}
80002e28:	0c 9c       	mov	r12,r6
80002e2a:	2f cd       	sub	sp,-16
80002e2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002e30:	80 00       	ld.sh	r0,r0[0x0]
80002e32:	9f ac       	st.w	pc[0x28],r12
80002e34:	80 00       	ld.sh	r0,r0[0x0]
80002e36:	2b 14       	sub	r4,-79
80002e38:	80 00       	ld.sh	r0,r0[0x0]
80002e3a:	2a 54       	sub	r4,-91
80002e3c:	80 00       	ld.sh	r0,r0[0x0]
80002e3e:	2a 10       	sub	r0,-95
80002e40:	80 00       	ld.sh	r0,r0[0x0]
80002e42:	2a c8       	sub	r8,-84
80002e44:	80 00       	ld.sh	r0,r0[0x0]
80002e46:	9f 90       	st.w	pc[0x24],r0

80002e48 <SD_WriteMultiBlocks>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_WriteMultiBlocks(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
{
80002e48:	d4 31       	pushm	r0-r7,lr
80002e4a:	18 95       	mov	r5,r12
80002e4c:	16 93       	mov	r3,r11
80002e4e:	14 96       	mov	r6,r10
80002e50:	12 94       	mov	r4,r9
  uint32_t i = 0, Offset = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
80002e52:	31 8c       	mov	r12,24
80002e54:	f0 1f 00 27 	mcall	80002ef0 <SD_WriteMultiBlocks+0xa8>
80002e58:	e0 67 00 ff 	mov	r7,255
  /*!< Data transfer */
  while (NumberOfBlocks--)
  {
    if(flag_SDHC == 1)
80002e5c:	4a 60       	lddpc	r0,80002ef4 <SD_WriteMultiBlocks+0xac>
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, (WriteAddr + Offset)/512, 0xFF);
    }
    else
    {
        /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr + Offset, 0xFF);
80002e5e:	0e 92       	mov	r2,r7
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002e60:	5c 76       	castu.h	r6
    Offset += 512;
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
    SD_ReadByte();
    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002e62:	30 51       	mov	r1,5
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002e64:	c3 a8       	rjmp	80002ed8 <SD_WriteMultiBlocks+0x90>
  {
    if(flag_SDHC == 1)
80002e66:	01 88       	ld.ub	r8,r0[0x0]
80002e68:	30 19       	mov	r9,1
80002e6a:	f2 08 18 00 	cp.b	r8,r9
80002e6e:	c0 81       	brne	80002e7e <SD_WriteMultiBlocks+0x36>
    {
        /* Send CMD24 (MSD_WRITE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, (WriteAddr + Offset)/512, 0xFF);
80002e70:	04 9a       	mov	r10,r2
80002e72:	e6 0b 16 09 	lsr	r11,r3,0x9
80002e76:	31 8c       	mov	r12,24
80002e78:	f0 1f 00 20 	mcall	80002ef8 <SD_WriteMultiBlocks+0xb0>
80002e7c:	c0 68       	rjmp	80002e88 <SD_WriteMultiBlocks+0x40>
    }
    else
    {
        /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr + Offset, 0xFF);
80002e7e:	04 9a       	mov	r10,r2
80002e80:	06 9b       	mov	r11,r3
80002e82:	31 8c       	mov	r12,24
80002e84:	f0 1f 00 1d 	mcall	80002ef8 <SD_WriteMultiBlocks+0xb0>
    }
    /*!< Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002e88:	30 0c       	mov	r12,0
80002e8a:	f0 1f 00 1d 	mcall	80002efc <SD_WriteMultiBlocks+0xb4>
80002e8e:	c0 40       	breq	80002e96 <SD_WriteMultiBlocks+0x4e>
80002e90:	e0 67 00 ff 	mov	r7,255
80002e94:	c2 b8       	rjmp	80002eea <SD_WriteMultiBlocks+0xa2>
    {
      return SD_RESPONSE_FAILURE;
    }
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
80002e96:	04 9c       	mov	r12,r2
80002e98:	f0 1f 00 1a 	mcall	80002f00 <SD_WriteMultiBlocks+0xb8>
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
80002e9c:	e0 6c 00 fe 	mov	r12,254
80002ea0:	f0 1f 00 18 	mcall	80002f00 <SD_WriteMultiBlocks+0xb8>
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002ea4:	58 06       	cp.w	r6,0
80002ea6:	c0 a0       	breq	80002eba <SD_WriteMultiBlocks+0x72>
80002ea8:	30 07       	mov	r7,0
    {
      /*!< Send the pointed byte */
      SD_WriteByte(*pBuffer);
80002eaa:	ea 07 07 0c 	ld.ub	r12,r5[r7]
80002eae:	f0 1f 00 15 	mcall	80002f00 <SD_WriteMultiBlocks+0xb8>
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002eb2:	2f f7       	sub	r7,-1
80002eb4:	0c 37       	cp.w	r7,r6
80002eb6:	cf a3       	brcs	80002eaa <SD_WriteMultiBlocks+0x62>
80002eb8:	0c 05       	add	r5,r6
      pBuffer++;
    }
    /*!< Set next write address */
    Offset += 512;
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
80002eba:	f0 1f 00 13 	mcall	80002f04 <SD_WriteMultiBlocks+0xbc>
    SD_ReadByte();
80002ebe:	f0 1f 00 12 	mcall	80002f04 <SD_WriteMultiBlocks+0xbc>
    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002ec2:	f0 1f 00 12 	mcall	80002f08 <SD_WriteMultiBlocks+0xc0>
80002ec6:	f8 01 18 00 	cp.b	r1,r12
80002eca:	f9 b7 00 00 	moveq	r7,0
80002ece:	e4 07 17 10 	movne	r7,r2
80002ed2:	20 14       	sub	r4,1
80002ed4:	e6 c3 fe 00 	sub	r3,r3,-512
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002ed8:	58 04       	cp.w	r4,0
80002eda:	cc 61       	brne	80002e66 <SD_WriteMultiBlocks+0x1e>
      /*!< Set response value to failure */
      rvalue = SD_RESPONSE_FAILURE;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002edc:	31 8c       	mov	r12,24
80002ede:	f0 1f 00 0c 	mcall	80002f0c <SD_WriteMultiBlocks+0xc4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002ee2:	e0 6c 00 ff 	mov	r12,255
80002ee6:	f0 1f 00 07 	mcall	80002f00 <SD_WriteMultiBlocks+0xb8>
  /*!< Returns the reponse */
  return rvalue;
}
80002eea:	0e 9c       	mov	r12,r7
80002eec:	d8 32       	popm	r0-r7,pc
80002eee:	00 00       	add	r0,r0
80002ef0:	80 00       	ld.sh	r0,r0[0x0]
80002ef2:	9f ac       	st.w	pc[0x28],r12
80002ef4:	00 00       	add	r0,r0
80002ef6:	0a 68       	and	r8,r5
80002ef8:	80 00       	ld.sh	r0,r0[0x0]
80002efa:	2b 14       	sub	r4,-79
80002efc:	80 00       	ld.sh	r0,r0[0x0]
80002efe:	2a 54       	sub	r4,-91
80002f00:	80 00       	ld.sh	r0,r0[0x0]
80002f02:	2a c8       	sub	r8,-84
80002f04:	80 00       	ld.sh	r0,r0[0x0]
80002f06:	2a 10       	sub	r0,-95
80002f08:	80 00       	ld.sh	r0,r0[0x0]
80002f0a:	2a 88       	sub	r8,-88
80002f0c:	80 00       	ld.sh	r0,r0[0x0]
80002f0e:	9f 90       	st.w	pc[0x24],r0

80002f10 <SD_WriteBlock>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_WriteBlock(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize)
{
80002f10:	eb cd 40 e0 	pushm	r5-r7,lr
80002f14:	18 95       	mov	r5,r12
80002f16:	16 97       	mov	r7,r11
80002f18:	14 96       	mov	r6,r10
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
80002f1a:	31 8c       	mov	r12,24
80002f1c:	f0 1f 00 1f 	mcall	80002f98 <SD_WriteBlock+0x88>

  if(flag_SDHC == 1)
80002f20:	49 f8       	lddpc	r8,80002f9c <SD_WriteBlock+0x8c>
80002f22:	11 89       	ld.ub	r9,r8[0x0]
80002f24:	30 18       	mov	r8,1
80002f26:	f0 09 18 00 	cp.b	r9,r8
80002f2a:	c0 21       	brne	80002f2e <SD_WriteBlock+0x1e>
  {
  	WriteAddr = WriteAddr/512;
80002f2c:	a9 97       	lsr	r7,0x9
  }
  /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write multiple block */
  SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr, 0xFF);
80002f2e:	e0 6a 00 ff 	mov	r10,255
80002f32:	0e 9b       	mov	r11,r7
80002f34:	31 8c       	mov	r12,24
80002f36:	f0 1f 00 1b 	mcall	80002fa0 <SD_WriteBlock+0x90>
  
  /*!< Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002f3a:	30 0c       	mov	r12,0
80002f3c:	f0 1f 00 1a 	mcall	80002fa4 <SD_WriteBlock+0x94>
80002f40:	c1 f1       	brne	80002f7e <SD_WriteBlock+0x6e>
  {
    /*!< Send a dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
80002f42:	e0 6c 00 ff 	mov	r12,255
80002f46:	f0 1f 00 19 	mcall	80002fa8 <SD_WriteBlock+0x98>

    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(0xFE);
80002f4a:	e0 6c 00 fe 	mov	r12,254
80002f4e:	f0 1f 00 17 	mcall	80002fa8 <SD_WriteBlock+0x98>

    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002f52:	5c 76       	castu.h	r6
80002f54:	c0 90       	breq	80002f66 <SD_WriteBlock+0x56>
80002f56:	30 07       	mov	r7,0
    {
      /*!< Send the pointed byte */
      SD_WriteByte(*pBuffer);
80002f58:	ea 07 07 0c 	ld.ub	r12,r5[r7]
80002f5c:	f0 1f 00 13 	mcall	80002fa8 <SD_WriteBlock+0x98>

    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(0xFE);

    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002f60:	2f f7       	sub	r7,-1
80002f62:	0c 37       	cp.w	r7,r6
80002f64:	cf a3       	brcs	80002f58 <SD_WriteBlock+0x48>
      SD_WriteByte(*pBuffer);
      /*!< Point to the next location where the byte read will be saved */
      pBuffer++;
    }
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
80002f66:	f0 1f 00 12 	mcall	80002fac <SD_WriteBlock+0x9c>
    SD_ReadByte();
80002f6a:	f0 1f 00 11 	mcall	80002fac <SD_WriteBlock+0x9c>

    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002f6e:	f0 1f 00 11 	mcall	80002fb0 <SD_WriteBlock+0xa0>
80002f72:	30 58       	mov	r8,5
80002f74:	f0 0c 18 00 	cp.b	r12,r8
80002f78:	c0 31       	brne	80002f7e <SD_WriteBlock+0x6e>
80002f7a:	30 07       	mov	r7,0
80002f7c:	c0 38       	rjmp	80002f82 <SD_WriteBlock+0x72>
80002f7e:	e0 67 00 ff 	mov	r7,255
    {
      rvalue = SD_RESPONSE_NO_ERROR;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002f82:	31 8c       	mov	r12,24
80002f84:	f0 1f 00 0c 	mcall	80002fb4 <SD_WriteBlock+0xa4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002f88:	e0 6c 00 ff 	mov	r12,255
80002f8c:	f0 1f 00 07 	mcall	80002fa8 <SD_WriteBlock+0x98>

  /*!< Returns the reponse */
  return rvalue;
}
80002f90:	0e 9c       	mov	r12,r7
80002f92:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002f96:	00 00       	add	r0,r0
80002f98:	80 00       	ld.sh	r0,r0[0x0]
80002f9a:	9f ac       	st.w	pc[0x28],r12
80002f9c:	00 00       	add	r0,r0
80002f9e:	0a 68       	and	r8,r5
80002fa0:	80 00       	ld.sh	r0,r0[0x0]
80002fa2:	2b 14       	sub	r4,-79
80002fa4:	80 00       	ld.sh	r0,r0[0x0]
80002fa6:	2a 54       	sub	r4,-91
80002fa8:	80 00       	ld.sh	r0,r0[0x0]
80002faa:	2a c8       	sub	r8,-84
80002fac:	80 00       	ld.sh	r0,r0[0x0]
80002fae:	2a 10       	sub	r0,-95
80002fb0:	80 00       	ld.sh	r0,r0[0x0]
80002fb2:	2a 88       	sub	r8,-88
80002fb4:	80 00       	ld.sh	r0,r0[0x0]
80002fb6:	9f 90       	st.w	pc[0x24],r0

80002fb8 <SD_ReadMultiBlocks>:
  * @retval The SD Response:
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_ReadMultiBlocks(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
{
80002fb8:	d4 31       	pushm	r0-r7,lr
80002fba:	20 1d       	sub	sp,4
80002fbc:	18 95       	mov	r5,r12
80002fbe:	50 0b       	stdsp	sp[0x0],r11
80002fc0:	14 96       	mov	r6,r10
80002fc2:	12 94       	mov	r4,r9
  uint32_t i = 0, Offset = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
80002fc4:	31 8c       	mov	r12,24
80002fc6:	f0 1f 00 27 	mcall	80003060 <SD_ReadMultiBlocks+0xa8>
80002fca:	e0 67 00 ff 	mov	r7,255
80002fce:	30 02       	mov	r2,0
  /*!< Data transfer */
  while (NumberOfBlocks--)
  {
    if(flag_SDHC == 1)
80002fd0:	4a 53       	lddpc	r3,80003064 <SD_ReadMultiBlocks+0xac>
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK,(ReadAddr + Offset)/512, 0xFF);
    }
    else
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK, ReadAddr + Offset, 0xFF);
80002fd2:	0e 90       	mov	r0,r7
    }
    /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002fd4:	04 91       	mov	r1,r2
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
80002fd6:	5c 76       	castu.h	r6
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002fd8:	c3 78       	rjmp	80003046 <SD_ReadMultiBlocks+0x8e>
  {
    if(flag_SDHC == 1)
80002fda:	07 88       	ld.ub	r8,r3[0x0]
80002fdc:	30 19       	mov	r9,1
80002fde:	f2 08 18 00 	cp.b	r8,r9
80002fe2:	c0 a1       	brne	80002ff6 <SD_ReadMultiBlocks+0x3e>
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK,(ReadAddr + Offset)/512, 0xFF);
80002fe4:	40 08       	lddsp	r8,sp[0x0]
80002fe6:	e4 08 00 0b 	add	r11,r2,r8
80002fea:	00 9a       	mov	r10,r0
80002fec:	a9 9b       	lsr	r11,0x9
80002fee:	31 1c       	mov	r12,17
80002ff0:	f0 1f 00 1e 	mcall	80003068 <SD_ReadMultiBlocks+0xb0>
80002ff4:	c0 88       	rjmp	80003004 <SD_ReadMultiBlocks+0x4c>
    }
    else
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK, ReadAddr + Offset, 0xFF);
80002ff6:	00 9a       	mov	r10,r0
80002ff8:	40 09       	lddsp	r9,sp[0x0]
80002ffa:	e4 09 00 0b 	add	r11,r2,r9
80002ffe:	31 1c       	mov	r12,17
80003000:	f0 1f 00 1a 	mcall	80003068 <SD_ReadMultiBlocks+0xb0>
    }
    /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80003004:	02 9c       	mov	r12,r1
80003006:	f0 1f 00 1a 	mcall	8000306c <SD_ReadMultiBlocks+0xb4>
8000300a:	c0 40       	breq	80003012 <SD_ReadMultiBlocks+0x5a>
8000300c:	e0 67 00 ff 	mov	r7,255
80003010:	c2 48       	rjmp	80003058 <SD_ReadMultiBlocks+0xa0>
    {
      return  SD_RESPONSE_FAILURE;
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
80003012:	e0 6c 00 fe 	mov	r12,254
80003016:	f0 1f 00 16 	mcall	8000306c <SD_ReadMultiBlocks+0xb4>
8000301a:	c0 30       	breq	80003020 <SD_ReadMultiBlocks+0x68>
8000301c:	00 97       	mov	r7,r0
8000301e:	c1 38       	rjmp	80003044 <SD_ReadMultiBlocks+0x8c>
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
80003020:	58 06       	cp.w	r6,0
80003022:	c0 a0       	breq	80003036 <SD_ReadMultiBlocks+0x7e>
80003024:	02 97       	mov	r7,r1
      {
        /*!< Read the pointed data */
        *pBuffer = SD_ReadByte();
80003026:	f0 1f 00 13 	mcall	80003070 <SD_ReadMultiBlocks+0xb8>
8000302a:	ea 07 0b 0c 	st.b	r5[r7],r12
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
8000302e:	2f f7       	sub	r7,-1
80003030:	0c 37       	cp.w	r7,r6
80003032:	cf a3       	brcs	80003026 <SD_ReadMultiBlocks+0x6e>
80003034:	0c 05       	add	r5,r6
        *pBuffer = SD_ReadByte();
        /*!< Point to the next location where the byte read will be saved */
        pBuffer++;
      }
      /*!< Set next read address*/
      Offset += 512;
80003036:	e4 c2 fe 00 	sub	r2,r2,-512
      /*!< get CRC bytes (not really needed by us, but required by SD) */
      SD_ReadByte();
8000303a:	f0 1f 00 0e 	mcall	80003070 <SD_ReadMultiBlocks+0xb8>
      SD_ReadByte();
8000303e:	f0 1f 00 0d 	mcall	80003070 <SD_ReadMultiBlocks+0xb8>
80003042:	02 97       	mov	r7,r1
80003044:	20 14       	sub	r4,1
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80003046:	58 04       	cp.w	r4,0
80003048:	cc 91       	brne	80002fda <SD_ReadMultiBlocks+0x22>
      /*!< Set response value to failure */
      rvalue = SD_RESPONSE_FAILURE;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
8000304a:	31 8c       	mov	r12,24
8000304c:	f0 1f 00 0a 	mcall	80003074 <SD_ReadMultiBlocks+0xbc>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80003050:	e0 6c 00 ff 	mov	r12,255
80003054:	f0 1f 00 09 	mcall	80003078 <SD_ReadMultiBlocks+0xc0>
  /*!< Returns the reponse */
  return rvalue;
}
80003058:	0e 9c       	mov	r12,r7
8000305a:	2f fd       	sub	sp,-4
8000305c:	d8 32       	popm	r0-r7,pc
8000305e:	00 00       	add	r0,r0
80003060:	80 00       	ld.sh	r0,r0[0x0]
80003062:	9f ac       	st.w	pc[0x28],r12
80003064:	00 00       	add	r0,r0
80003066:	0a 68       	and	r8,r5
80003068:	80 00       	ld.sh	r0,r0[0x0]
8000306a:	2b 14       	sub	r4,-79
8000306c:	80 00       	ld.sh	r0,r0[0x0]
8000306e:	2a 54       	sub	r4,-91
80003070:	80 00       	ld.sh	r0,r0[0x0]
80003072:	2a 10       	sub	r0,-95
80003074:	80 00       	ld.sh	r0,r0[0x0]
80003076:	9f 90       	st.w	pc[0x24],r0
80003078:	80 00       	ld.sh	r0,r0[0x0]
8000307a:	2a c8       	sub	r8,-84

8000307c <SD_ReadBlock>:
  * @retval The SD Response:
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_ReadBlock(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize)
{
8000307c:	eb cd 40 e0 	pushm	r5-r7,lr
80003080:	18 95       	mov	r5,r12
80003082:	16 97       	mov	r7,r11
80003084:	14 96       	mov	r6,r10
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
80003086:	31 8c       	mov	r12,24
80003088:	f0 1f 00 1a 	mcall	800030f0 <SD_ReadBlock+0x74>
  
if(flag_SDHC == 1)
8000308c:	49 a8       	lddpc	r8,800030f4 <SD_ReadBlock+0x78>
8000308e:	11 89       	ld.ub	r9,r8[0x0]
80003090:	30 18       	mov	r8,1
80003092:	f0 09 18 00 	cp.b	r9,r8
80003096:	c0 21       	brne	8000309a <SD_ReadBlock+0x1e>
{
	ReadAddr = ReadAddr/512;
80003098:	a9 97       	lsr	r7,0x9
}
  /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
  SD_SendCmd(SD_CMD_READ_SINGLE_BLOCK, ReadAddr, 0xFF);
8000309a:	e0 6a 00 ff 	mov	r10,255
8000309e:	0e 9b       	mov	r11,r7
800030a0:	31 1c       	mov	r12,17
800030a2:	f0 1f 00 16 	mcall	800030f8 <SD_ReadBlock+0x7c>
  
  /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
800030a6:	30 0c       	mov	r12,0
800030a8:	f0 1f 00 15 	mcall	800030fc <SD_ReadBlock+0x80>
800030ac:	c1 61       	brne	800030d8 <SD_ReadBlock+0x5c>
  {
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
800030ae:	e0 6c 00 fe 	mov	r12,254
800030b2:	f0 1f 00 13 	mcall	800030fc <SD_ReadBlock+0x80>
800030b6:	c1 11       	brne	800030d8 <SD_ReadBlock+0x5c>
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
800030b8:	5c 76       	castu.h	r6
800030ba:	c0 90       	breq	800030cc <SD_ReadBlock+0x50>
800030bc:	30 07       	mov	r7,0
      {
        /*!< Save the received data */
        *pBuffer = SD_ReadByte();
800030be:	f0 1f 00 11 	mcall	80003100 <SD_ReadBlock+0x84>
800030c2:	ea 07 0b 0c 	st.b	r5[r7],r12
  {
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
800030c6:	2f f7       	sub	r7,-1
800030c8:	0c 37       	cp.w	r7,r6
800030ca:	cf a3       	brcs	800030be <SD_ReadBlock+0x42>
       
        /*!< Point to the next location where the byte read will be saved */
        pBuffer++;
      }
      /*!< Get CRC bytes (not really needed by us, but required by SD) */
      SD_ReadByte();
800030cc:	f0 1f 00 0d 	mcall	80003100 <SD_ReadBlock+0x84>
      SD_ReadByte();
800030d0:	f0 1f 00 0c 	mcall	80003100 <SD_ReadBlock+0x84>
800030d4:	30 07       	mov	r7,0
800030d6:	c0 38       	rjmp	800030dc <SD_ReadBlock+0x60>
800030d8:	e0 67 00 ff 	mov	r7,255
      /*!< Set response value to success */
      rvalue = SD_RESPONSE_NO_ERROR;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
800030dc:	31 8c       	mov	r12,24
800030de:	f0 1f 00 0a 	mcall	80003104 <SD_ReadBlock+0x88>
  
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
800030e2:	e0 6c 00 ff 	mov	r12,255
800030e6:	f0 1f 00 09 	mcall	80003108 <SD_ReadBlock+0x8c>
  
  /*!< Returns the reponse */
  return rvalue;
}
800030ea:	0e 9c       	mov	r12,r7
800030ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800030f0:	80 00       	ld.sh	r0,r0[0x0]
800030f2:	9f ac       	st.w	pc[0x28],r12
800030f4:	00 00       	add	r0,r0
800030f6:	0a 68       	and	r8,r5
800030f8:	80 00       	ld.sh	r0,r0[0x0]
800030fa:	2b 14       	sub	r4,-79
800030fc:	80 00       	ld.sh	r0,r0[0x0]
800030fe:	2a 54       	sub	r4,-91
80003100:	80 00       	ld.sh	r0,r0[0x0]
80003102:	2a 10       	sub	r0,-95
80003104:	80 00       	ld.sh	r0,r0[0x0]
80003106:	9f 90       	st.w	pc[0x24],r0
80003108:	80 00       	ld.sh	r0,r0[0x0]
8000310a:	2a c8       	sub	r8,-84

8000310c <SD_Init>:
  * @   SD
  * @   
  * @ 
***------------------------------------------------------*/
SD_Error SD_Init(void)
{
8000310c:	eb cd 40 f8 	pushm	r3-r7,lr
  uint32_t TimeOut, i = 0;
  SD_Error Status = SD_RESPONSE_NO_ERROR;

  /* SD_SPI,SPI */
  SD_LowLevel_Init(); 
80003110:	f0 1f 00 11 	mcall	80003154 <SD_Init+0x48>

  /*SD_SPI*/
  SD_SPI_SetSpeedLow();
80003114:	f0 1f 00 11 	mcall	80003158 <SD_Init+0x4c>
80003118:	30 05       	mov	r5,0
  TimeOut = 0;
  do
  {
	  
    /* SDCS*/
    SD_CS_HIGH();
8000311a:	31 84       	mov	r4,24
8000311c:	0a 93       	mov	r3,r5

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
    {
      SD_WriteByte(SD_DUMMY_BYTE);
8000311e:	e0 66 00 ff 	mov	r6,255
  TimeOut = 0;
  do
  {
	  
    /* SDCS*/
    SD_CS_HIGH();
80003122:	08 9c       	mov	r12,r4
80003124:	f0 1f 00 0e 	mcall	8000315c <SD_Init+0x50>
80003128:	06 97       	mov	r7,r3

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
    {
      SD_WriteByte(SD_DUMMY_BYTE);
8000312a:	0c 9c       	mov	r12,r6
8000312c:	f0 1f 00 0d 	mcall	80003160 <SD_Init+0x54>
    /* SDCS*/
    SD_CS_HIGH();

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
80003130:	2f f7       	sub	r7,-1
80003132:	58 a7       	cp.w	r7,10
80003134:	cf b1       	brne	8000312a <SD_Init+0x1e>
    {
      SD_WriteByte(SD_DUMMY_BYTE);
    }    
    
	Status = SD_GoIdleState();
80003136:	f0 1f 00 0c 	mcall	80003164 <SD_Init+0x58>
8000313a:	18 97       	mov	r7,r12

    if(TimeOut > 6)
8000313c:	58 75       	cp.w	r5,7
8000313e:	c0 50       	breq	80003148 <SD_Init+0x3c>
    {
      break;
    }
    TimeOut++;
  }while(Status);
80003140:	58 0c       	cp.w	r12,0
80003142:	c0 30       	breq	80003148 <SD_Init+0x3c>

    if(TimeOut > 6)
    {
      break;
    }
    TimeOut++;
80003144:	2f f5       	sub	r5,-1
80003146:	ce eb       	rjmp	80003122 <SD_Init+0x16>
  }while(Status);


   /*SD_SPI*/
  SD_SPI_SetSpeedHi();
80003148:	f0 1f 00 08 	mcall	80003168 <SD_Init+0x5c>
  return (Status);
}
8000314c:	0e 9c       	mov	r12,r7
8000314e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003152:	00 00       	add	r0,r0
80003154:	80 00       	ld.sh	r0,r0[0x0]
80003156:	29 98       	sub	r8,-103
80003158:	80 00       	ld.sh	r0,r0[0x0]
8000315a:	29 88       	sub	r8,-104
8000315c:	80 00       	ld.sh	r0,r0[0x0]
8000315e:	9f 90       	st.w	pc[0x24],r0
80003160:	80 00       	ld.sh	r0,r0[0x0]
80003162:	2a c8       	sub	r8,-84
80003164:	80 00       	ld.sh	r0,r0[0x0]
80003166:	2b 50       	sub	r0,-75
80003168:	80 00       	ld.sh	r0,r0[0x0]
8000316a:	29 78       	sub	r8,-105

8000316c <SD_GetCSDRegister>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCSDRegister(SD_CSD* SD_csd)
{
8000316c:	eb cd 40 e0 	pushm	r5-r7,lr
80003170:	20 9d       	sub	sp,36
80003172:	18 97       	mov	r7,r12
  uint8_t CSD_Tab[16];
  uint32_t CardCapacity;
  static uint32_t times = 0;

  /*!< SD chip select low */
  SD_CS_LOW();
80003174:	31 8c       	mov	r12,24
80003176:	f0 1f 00 a6 	mcall	8000340c <SD_GetCSDRegister+0x2a0>
  /*!< Send CMD9 (CSD register) or CMD10(CSD register) */
  SD_SendCmd(SD_CMD_SEND_CSD, 0, 0xFF);
8000317a:	e0 6a 00 ff 	mov	r10,255
8000317e:	30 0b       	mov	r11,0
80003180:	30 9c       	mov	r12,9
80003182:	f0 1f 00 a4 	mcall	80003410 <SD_GetCSDRegister+0x2a4>
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80003186:	30 0c       	mov	r12,0
80003188:	f0 1f 00 a3 	mcall	80003414 <SD_GetCSDRegister+0x2a8>
8000318c:	c0 40       	breq	80003194 <SD_GetCSDRegister+0x28>
8000318e:	e0 6c 00 ff 	mov	r12,255
80003192:	c3 99       	rjmp	80003404 <SD_GetCSDRegister+0x298>
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
80003194:	e0 6c 00 fe 	mov	r12,254
80003198:	f0 1f 00 9f 	mcall	80003414 <SD_GetCSDRegister+0x2a8>
8000319c:	c0 a1       	brne	800031b0 <SD_GetCSDRegister+0x44>
8000319e:	fa c6 ff ec 	sub	r6,sp,-20
  * @param  SD_csd: pointer on an SCD register structure
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCSDRegister(SD_CSD* SD_csd)
800031a2:	fa c5 ff dc 	sub	r5,sp,-36
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      for (i = 0; i < 16; i++)
      {
        /*!< Store CSD register value on CSD_Tab */
        CSD_Tab[i] = SD_ReadByte();
800031a6:	f0 1f 00 9d 	mcall	80003418 <SD_GetCSDRegister+0x2ac>
800031aa:	0c cc       	st.b	r6++,r12
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      for (i = 0; i < 16; i++)
800031ac:	0a 36       	cp.w	r6,r5
800031ae:	cf c1       	brne	800031a6 <SD_GetCSDRegister+0x3a>
          //printf("\n\r CSD_Tab[%d] 0x%X", i, CSD_Tab[i]);
        }
      }
    }
    /*!< Get CRC bytes (not really needed by us, but required by SD) */
    SD_WriteByte(SD_DUMMY_BYTE);
800031b0:	e0 6c 00 ff 	mov	r12,255
800031b4:	f0 1f 00 9a 	mcall	8000341c <SD_GetCSDRegister+0x2b0>
    SD_WriteByte(SD_DUMMY_BYTE);
800031b8:	e0 6c 00 ff 	mov	r12,255
800031bc:	f0 1f 00 98 	mcall	8000341c <SD_GetCSDRegister+0x2b0>
  else
  {
     return rvalue;
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
800031c0:	31 8c       	mov	r12,24
800031c2:	f0 1f 00 98 	mcall	80003420 <SD_GetCSDRegister+0x2b4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
800031c6:	e0 6c 00 ff 	mov	r12,255
800031ca:	f0 1f 00 95 	mcall	8000341c <SD_GetCSDRegister+0x2b0>

  /*!< Byte 0 */
  SD_csd->CSDStruct = (CSD_Tab[0] & 0xC0) >> 6;
800031ce:	fb 38 00 14 	ld.ub	r8,sp[20]
800031d2:	f0 09 16 06 	lsr	r9,r8,0x6
800031d6:	ae 89       	st.b	r7[0x0],r9
  SD_csd->SysSpecVersion = (CSD_Tab[0] & 0x3C) >> 2;
800031d8:	f3 d8 c0 44 	bfextu	r9,r8,0x2,0x4
800031dc:	ae 99       	st.b	r7[0x1],r9
  SD_csd->Reserved1 = CSD_Tab[0] & 0x03;
800031de:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800031e2:	ae a8       	st.b	r7[0x2],r8

  if(0 == times)
800031e4:	fe f8 02 40 	ld.w	r8,pc[576]
800031e8:	70 08       	ld.w	r8,r8[0x0]
800031ea:	58 08       	cp.w	r8,0
800031ec:	c0 f1       	brne	8000320a <SD_GetCSDRegister+0x9e>
  {
    if(SD_csd->CSDStruct == 1)
800031ee:	0f 89       	ld.ub	r9,r7[0x0]
800031f0:	30 18       	mov	r8,1
800031f2:	f0 09 18 00 	cp.b	r9,r8
800031f6:	c0 61       	brne	80003202 <SD_GetCSDRegister+0x96>
    {
      //printf("\n\r SDHC CSD Version 2.0 Acess AS SD High Capacity.");
      flag_SDHC = 1;
800031f8:	10 99       	mov	r9,r8
800031fa:	fe f8 02 2e 	ld.w	r8,pc[558]
800031fe:	b0 89       	st.b	r8[0x0],r9
80003200:	c0 58       	rjmp	8000320a <SD_GetCSDRegister+0x9e>
    }
	else
	{
      //printf("\n\r SDSC CSD Version 1.0 Acess AS SD Standard Capacity.");	
      flag_SDHC = 0;
80003202:	30 09       	mov	r9,0
80003204:	fe f8 02 24 	ld.w	r8,pc[548]
80003208:	b0 89       	st.b	r8[0x0],r9
	}
  }

  /*!< Byte 1 */
  SD_csd->TAAC = CSD_Tab[1];
8000320a:	fb 38 00 15 	ld.ub	r8,sp[21]
8000320e:	ae b8       	st.b	r7[0x3],r8

  /*!< Byte 2 */
  SD_csd->NSAC = CSD_Tab[2];
80003210:	fb 38 00 16 	ld.ub	r8,sp[22]
80003214:	ae c8       	st.b	r7[0x4],r8

  /*!< Byte 3 */
  SD_csd->MaxBusClkFrec = CSD_Tab[3];
80003216:	fb 38 00 17 	ld.ub	r8,sp[23]
8000321a:	ae d8       	st.b	r7[0x5],r8

  /*!< Byte 4 */
  SD_csd->CardComdClasses = CSD_Tab[4] << 4;
8000321c:	fb 38 00 18 	ld.ub	r8,sp[24]
80003220:	a5 68       	lsl	r8,0x4
80003222:	ae 38       	st.h	r7[0x6],r8

  /*!< Byte 5 */
  SD_csd->CardComdClasses |= (CSD_Tab[5] & 0xF0) >> 4;
80003224:	8e 39       	ld.sh	r9,r7[0x6]
80003226:	fb 38 00 19 	ld.ub	r8,sp[25]
8000322a:	f3 e8 12 49 	or	r9,r9,r8>>0x4
8000322e:	ae 39       	st.h	r7[0x6],r9
  SD_csd->RdBlockLen = CSD_Tab[5] & 0x0F;
80003230:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80003234:	ef 68 00 08 	st.b	r7[8],r8

  /*!< Byte 6 */
  SD_csd->PartBlockRead = (CSD_Tab[6] & 0x80) >> 7;
80003238:	fb 38 00 1a 	ld.ub	r8,sp[26]
8000323c:	f0 09 16 07 	lsr	r9,r8,0x7
80003240:	ef 69 00 09 	st.b	r7[9],r9
  SD_csd->WrBlockMisalign = (CSD_Tab[6] & 0x40) >> 6;
80003244:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
80003248:	ef 69 00 0a 	st.b	r7[10],r9
  SD_csd->RdBlockMisalign = (CSD_Tab[6] & 0x20) >> 5;
8000324c:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
80003250:	ef 69 00 0b 	st.b	r7[11],r9
  SD_csd->DSRImpl = (CSD_Tab[6] & 0x10) >> 4;
80003254:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
80003258:	ef 69 00 0c 	st.b	r7[12],r9
  SD_csd->Reserved2 = 0; /*!< Reserved */
8000325c:	30 09       	mov	r9,0
8000325e:	ef 69 00 0d 	st.b	r7[13],r9

  if(flag_SDHC == 0)
80003262:	4f 2a       	lddpc	r10,80003428 <SD_GetCSDRegister+0x2bc>
80003264:	15 8a       	ld.ub	r10,r10[0x0]
80003266:	f2 0a 18 00 	cp.b	r10,r9
8000326a:	c1 21       	brne	8000328e <SD_GetCSDRegister+0x122>
  {
    SD_csd->DeviceSize = (CSD_Tab[6] & 0x03) << 10;
8000326c:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80003270:	ab 68       	lsl	r8,0xa
80003272:	8f 48       	st.w	r7[0x10],r8
  
    /*!< Byte 7 */
    SD_csd->DeviceSize |= (CSD_Tab[7]) << 2;
80003274:	6e 48       	ld.w	r8,r7[0x10]
80003276:	fb 39 00 1b 	ld.ub	r9,sp[27]
8000327a:	f1 e9 10 28 	or	r8,r8,r9<<0x2
8000327e:	8f 48       	st.w	r7[0x10],r8
  
    /*!< Byte 8 */
    SD_csd->DeviceSize |= (CSD_Tab[8] & 0xC0) >> 6;
80003280:	6e 48       	ld.w	r8,r7[0x10]
80003282:	fb 39 00 1c 	ld.ub	r9,sp[28]
80003286:	f1 e9 12 68 	or	r8,r8,r9>>0x6
8000328a:	8f 48       	st.w	r7[0x10],r8
8000328c:	c1 38       	rjmp	800032b2 <SD_GetCSDRegister+0x146>
  }
  else
  {
    SD_csd->DeviceSize = (CSD_Tab[7] & 0x3F) << 16;
8000328e:	fb 38 00 1b 	ld.ub	r8,sp[27]
80003292:	f1 d8 c0 06 	bfextu	r8,r8,0x0,0x6
80003296:	b1 68       	lsl	r8,0x10
80003298:	8f 48       	st.w	r7[0x10],r8
    /* Byte 7 */
    SD_csd->DeviceSize += (CSD_Tab[8]) << 8;
8000329a:	6e 49       	ld.w	r9,r7[0x10]
8000329c:	fb 38 00 1c 	ld.ub	r8,sp[28]
800032a0:	a9 68       	lsl	r8,0x8
800032a2:	12 08       	add	r8,r9
800032a4:	8f 48       	st.w	r7[0x10],r8
    /* Byte 8 */
    SD_csd->DeviceSize += CSD_Tab[9] ;
800032a6:	6e 48       	ld.w	r8,r7[0x10]
800032a8:	fb 39 00 1d 	ld.ub	r9,sp[29]
800032ac:	f2 08 00 08 	add	r8,r9,r8
800032b0:	8f 48       	st.w	r7[0x10],r8
  }    

  SD_csd->MaxRdCurrentVDDMin = (CSD_Tab[8] & 0x38) >> 3;
800032b2:	fb 38 00 1c 	ld.ub	r8,sp[28]
800032b6:	f3 d8 c0 63 	bfextu	r9,r8,0x3,0x3
800032ba:	ef 69 00 14 	st.b	r7[20],r9
  SD_csd->MaxRdCurrentVDDMax = (CSD_Tab[8] & 0x07);
800032be:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800032c2:	ef 68 00 15 	st.b	r7[21],r8

  /*!< Byte 9 */
  SD_csd->MaxWrCurrentVDDMin = (CSD_Tab[9] & 0xE0) >> 5;
800032c6:	fb 38 00 1d 	ld.ub	r8,sp[29]
800032ca:	f0 09 16 05 	lsr	r9,r8,0x5
800032ce:	ef 69 00 16 	st.b	r7[22],r9
  SD_csd->MaxWrCurrentVDDMax = (CSD_Tab[9] & 0x1C) >> 2;
800032d2:	f3 d8 c0 43 	bfextu	r9,r8,0x2,0x3
800032d6:	ef 69 00 17 	st.b	r7[23],r9
  SD_csd->DeviceSizeMul = (CSD_Tab[9] & 0x03) << 1;
800032da:	a1 78       	lsl	r8,0x1
800032dc:	e2 18 00 06 	andl	r8,0x6,COH
800032e0:	ef 68 00 18 	st.b	r7[24],r8
  /*!< Byte 10 */
  SD_csd->DeviceSizeMul |= (CSD_Tab[10] & 0x80) >> 7;
800032e4:	ef 39 00 18 	ld.ub	r9,r7[24]
800032e8:	fb 38 00 1e 	ld.ub	r8,sp[30]
800032ec:	f3 e8 12 79 	or	r9,r9,r8>>0x7
800032f0:	ef 69 00 18 	st.b	r7[24],r9
    
  SD_csd->EraseGrSize = (CSD_Tab[10] & 0x40) >> 6;
800032f4:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
800032f8:	ef 69 00 19 	st.b	r7[25],r9
  SD_csd->EraseGrMul = (CSD_Tab[10] & 0x3F) << 1;
800032fc:	a1 78       	lsl	r8,0x1
800032fe:	e2 18 00 7e 	andl	r8,0x7e,COH
80003302:	ef 68 00 1a 	st.b	r7[26],r8

  /*!< Byte 11 */
  SD_csd->EraseGrMul |= (CSD_Tab[11] & 0x80) >> 7;
80003306:	ef 39 00 1a 	ld.ub	r9,r7[26]
8000330a:	fb 38 00 1f 	ld.ub	r8,sp[31]
8000330e:	f3 e8 12 79 	or	r9,r9,r8>>0x7
80003312:	ef 69 00 1a 	st.b	r7[26],r9
  SD_csd->WrProtectGrSize = (CSD_Tab[11] & 0x7F);
80003316:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
8000331a:	ef 68 00 1b 	st.b	r7[27],r8

  /*!< Byte 12 */
  SD_csd->WrProtectGrEnable = (CSD_Tab[12] & 0x80) >> 7;
8000331e:	fb 38 00 20 	ld.ub	r8,sp[32]
80003322:	f0 09 16 07 	lsr	r9,r8,0x7
80003326:	ef 69 00 1c 	st.b	r7[28],r9
  SD_csd->ManDeflECC = (CSD_Tab[12] & 0x60) >> 5;
8000332a:	f3 d8 c0 a2 	bfextu	r9,r8,0x5,0x2
8000332e:	ef 69 00 1d 	st.b	r7[29],r9
  SD_csd->WrSpeedFact = (CSD_Tab[12] & 0x1C) >> 2;
80003332:	f3 d8 c0 43 	bfextu	r9,r8,0x2,0x3
80003336:	ef 69 00 1e 	st.b	r7[30],r9
  SD_csd->MaxWrBlockLen = (CSD_Tab[12] & 0x03) << 2;
8000333a:	a3 68       	lsl	r8,0x2
8000333c:	e2 18 00 0c 	andl	r8,0xc,COH
80003340:	ef 68 00 1f 	st.b	r7[31],r8

  /*!< Byte 13 */
  SD_csd->MaxWrBlockLen |= (CSD_Tab[13] & 0xC0) >> 6;
80003344:	ef 39 00 1f 	ld.ub	r9,r7[31]
80003348:	fb 38 00 21 	ld.ub	r8,sp[33]
8000334c:	f3 e8 12 69 	or	r9,r9,r8>>0x6
80003350:	ef 69 00 1f 	st.b	r7[31],r9
  SD_csd->WriteBlockPaPartial = (CSD_Tab[13] & 0x20) >> 5;
80003354:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
80003358:	ef 69 00 20 	st.b	r7[32],r9
  SD_csd->Reserved3 = 0;
8000335c:	30 09       	mov	r9,0
8000335e:	ef 69 00 21 	st.b	r7[33],r9
  SD_csd->ContentProtectAppli = (CSD_Tab[13] & 0x01);
80003362:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003366:	ef 68 00 22 	st.b	r7[34],r8

  /*!< Byte 14 */
  SD_csd->FileFormatGrouop = (CSD_Tab[14] & 0x80) >> 7;
8000336a:	fb 38 00 22 	ld.ub	r8,sp[34]
8000336e:	f0 09 16 07 	lsr	r9,r8,0x7
80003372:	ef 69 00 23 	st.b	r7[35],r9
  SD_csd->CopyFlag = (CSD_Tab[14] & 0x40) >> 6;
80003376:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
8000337a:	ef 69 00 24 	st.b	r7[36],r9
  SD_csd->PermWrProtect = (CSD_Tab[14] & 0x20) >> 5;
8000337e:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
80003382:	ef 69 00 25 	st.b	r7[37],r9
  SD_csd->TempWrProtect = (CSD_Tab[14] & 0x10) >> 4;
80003386:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
8000338a:	ef 69 00 26 	st.b	r7[38],r9
  SD_csd->FileFormat = (CSD_Tab[14] & 0x0C) >> 2;
8000338e:	f3 d8 c0 42 	bfextu	r9,r8,0x2,0x2
80003392:	ef 69 00 27 	st.b	r7[39],r9
  SD_csd->ECC = (CSD_Tab[14] & 0x03);
80003396:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000339a:	ef 68 00 28 	st.b	r7[40],r8

  /*!< Byte 15 */
  SD_csd->CSD_CRC = (CSD_Tab[15] & 0xFE) >> 1;
8000339e:	fb 38 00 23 	ld.ub	r8,sp[35]
800033a2:	a1 98       	lsr	r8,0x1
800033a4:	ef 68 00 29 	st.b	r7[41],r8
  SD_csd->Reserved4 = 1;
800033a8:	30 18       	mov	r8,1
800033aa:	ef 68 00 2a 	st.b	r7[42],r8

  if(times < 3)
800033ae:	49 e8       	lddpc	r8,80003424 <SD_GetCSDRegister+0x2b8>
800033b0:	70 08       	ld.w	r8,r8[0x0]
800033b2:	58 28       	cp.w	r8,2
800033b4:	e0 88 00 04 	brls	800033bc <SD_GetCSDRegister+0x250>
800033b8:	30 0c       	mov	r12,0
800033ba:	c2 58       	rjmp	80003404 <SD_GetCSDRegister+0x298>
  {
    if(flag_SDHC ==1)
800033bc:	49 b9       	lddpc	r9,80003428 <SD_GetCSDRegister+0x2bc>
800033be:	13 8a       	ld.ub	r10,r9[0x0]
800033c0:	30 19       	mov	r9,1
800033c2:	f2 0a 18 00 	cp.b	r10,r9
800033c6:	c0 51       	brne	800033d0 <SD_GetCSDRegister+0x264>
    {
	  /* SDHC memory capacity = (C_SIZE+1) * 512K byte */
      //SD_csd->DeviceSizeMul = 8 ;
      
      CardCapacity = (SD_csd->DeviceSize + 1)*512;
800033c8:	6e 49       	ld.w	r9,r7[0x10]
800033ca:	2f f9       	sub	r9,-1
800033cc:	a9 79       	lsl	r9,0x9
800033ce:	c0 c8       	rjmp	800033e6 <SD_GetCSDRegister+0x27a>
      
    }

    else
    {
      CardCapacity = (SD_csd->DeviceSize + 1);
800033d0:	6e 4a       	ld.w	r10,r7[0x10]
800033d2:	2f fa       	sub	r10,-1
      CardCapacity *= (1 << (SD_csd->DeviceSizeMul + 2));
800033d4:	ef 39 00 18 	ld.ub	r9,r7[24]
800033d8:	2f e9       	sub	r9,-2
800033da:	f4 09 09 4a 	lsl	r10,r10,r9
      CardCapacity *= (1<<SD_csd->RdBlockLen);
800033de:	ef 39 00 08 	ld.ub	r9,r7[8]
800033e2:	f4 09 09 49 	lsl	r9,r10,r9
      //printf("\n\r SD CardBlockSize %d CardCapacity %d M.", (1<<SD_csd->RdBlockLen), 
            //CardCapacity / 1024 / 1024);
    }
    
  if(times == 0)
800033e6:	58 08       	cp.w	r8,0
800033e8:	c0 91       	brne	800033fa <SD_GetCSDRegister+0x28e>
    {
	    uint8_t str[20];
        sprintf((char *)&str[0], " SD Card Size %dM. ", CardCapacity / 1024 / 1024);
800033ea:	b5 89       	lsr	r9,0x14
800033ec:	1a d9       	st.w	--sp,r9
800033ee:	49 0b       	lddpc	r11,8000342c <SD_GetCSDRegister+0x2c0>
800033f0:	fa cc ff fc 	sub	r12,sp,-4
800033f4:	f0 1f 00 0f 	mcall	80003430 <SD_GetCSDRegister+0x2c4>
800033f8:	2f fd       	sub	sp,-4
//	    LCD_DisplayStringLine(LCD_LINE_0, str);
    }
	times++;
800033fa:	48 b8       	lddpc	r8,80003424 <SD_GetCSDRegister+0x2b8>
800033fc:	70 09       	ld.w	r9,r8[0x0]
800033fe:	2f f9       	sub	r9,-1
80003400:	91 09       	st.w	r8[0x0],r9
80003402:	30 0c       	mov	r12,0
  }
  /*!< Return the reponse */
  return rvalue;
}
80003404:	2f 7d       	sub	sp,-36
80003406:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000340a:	00 00       	add	r0,r0
8000340c:	80 00       	ld.sh	r0,r0[0x0]
8000340e:	9f ac       	st.w	pc[0x28],r12
80003410:	80 00       	ld.sh	r0,r0[0x0]
80003412:	2b 14       	sub	r4,-79
80003414:	80 00       	ld.sh	r0,r0[0x0]
80003416:	2a 54       	sub	r4,-91
80003418:	80 00       	ld.sh	r0,r0[0x0]
8000341a:	2a 10       	sub	r0,-95
8000341c:	80 00       	ld.sh	r0,r0[0x0]
8000341e:	2a c8       	sub	r8,-84
80003420:	80 00       	ld.sh	r0,r0[0x0]
80003422:	9f 90       	st.w	pc[0x24],r0
80003424:	00 00       	add	r0,r0
80003426:	0a 64       	and	r4,r5
80003428:	00 00       	add	r0,r0
8000342a:	0a 68       	and	r8,r5
8000342c:	80 01       	ld.sh	r1,r0[0x0]
8000342e:	05 a0       	ld.ub	r0,r2[0x2]
80003430:	80 00       	ld.sh	r0,r0[0x0]
80003432:	a8 bc       	st.b	r4[0x3],r12

80003434 <SD_GetCardInfo>:
  * @   
  * @   
  * @ 
***------------------------------------------------------*/
SD_Error SD_GetCardInfo(SD_CardInfo *cardinfo)
{
80003434:	eb cd 40 c0 	pushm	r6-r7,lr
80003438:	18 97       	mov	r7,r12
  static uint32_t i = 0;
  SD_Error status = SD_RESPONSE_FAILURE;

  status = SD_GetCSDRegister(&(cardinfo->SD_csd));
8000343a:	18 96       	mov	r6,r12
8000343c:	f0 1f 00 12 	mcall	80003484 <SD_GetCardInfo+0x50>
  if(SD_RESPONSE_FAILURE == status)
80003440:	e0 4c 00 ff 	cp.w	r12,255
80003444:	c0 41       	brne	8000344c <SD_GetCardInfo+0x18>
  {
    status = SD_GetCSDRegister(&(cardinfo->SD_csd));
80003446:	0e 9c       	mov	r12,r7
80003448:	f0 1f 00 0f 	mcall	80003484 <SD_GetCardInfo+0x50>
  }
  status = SD_GetCIDRegister(&(cardinfo->SD_cid));
8000344c:	ee cc ff d4 	sub	r12,r7,-44
80003450:	f0 1f 00 0e 	mcall	80003488 <SD_GetCardInfo+0x54>
  
  if (flag_SDHC = 1)
80003454:	30 19       	mov	r9,1
80003456:	48 e8       	lddpc	r8,8000348c <SD_GetCardInfo+0x58>
80003458:	b0 89       	st.b	r8[0x0],r9
  {
	  
	  /* SDHC memory capacity = (C_SIZE+1) * 512K byte */
	  
	  cardinfo->CardCapacity = (cardinfo->SD_csd.DeviceSize + 1) ; 
8000345a:	6e 48       	ld.w	r8,r7[0x10]
8000345c:	2f f8       	sub	r8,-1
8000345e:	ef 48 00 44 	st.w	r7[68],r8
	  cardinfo->CardBlockSize = 1 << (cardinfo->SD_csd.RdBlockLen);
80003462:	ef 39 00 08 	ld.ub	r9,r7[8]
80003466:	30 1a       	mov	r10,1
80003468:	f4 09 09 49 	lsl	r9,r10,r9
8000346c:	ef 49 00 48 	st.w	r7[72],r9
	  cardinfo->CardCapacity *= cardinfo->CardBlockSize; 
80003470:	f2 08 02 48 	mul	r8,r9,r8
80003474:	ef 48 00 44 	st.w	r7[68],r8
  {
  
    //printf("\n\r SD CardBlockSize %d CardCapacity %d M", cardinfo->CardBlockSize, 
            //cardinfo->CardCapacity / 1024 / 1024);
  }
  i++; 
80003478:	48 68       	lddpc	r8,80003490 <SD_GetCardInfo+0x5c>
8000347a:	70 09       	ld.w	r9,r8[0x0]
8000347c:	14 09       	add	r9,r10
8000347e:	91 09       	st.w	r8[0x0],r9
  
  /*!< Returns the reponse */
  return status;
}
80003480:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003484:	80 00       	ld.sh	r0,r0[0x0]
80003486:	31 6c       	mov	r12,22
80003488:	80 00       	ld.sh	r0,r0[0x0]
8000348a:	2d 18       	sub	r8,-47
8000348c:	00 00       	add	r0,r0
8000348e:	0a 68       	and	r8,r5
80003490:	00 00       	add	r0,r0
80003492:	0a 60       	and	r0,r5

80003494 <SD_GetSectorCount>:
	}while(t<0XFFFFFF);//
	return SD_RESPONSE_FAILURE ;
}

uint32_t SD_GetSectorCount(void)
{
80003494:	d4 01       	pushm	lr
80003496:	21 3d       	sub	sp,76
	
	
	uint32_t  static temp;
	
	
	SD_GetCardInfo(&sdinfo);
80003498:	1a 9c       	mov	r12,sp
8000349a:	f0 1f 00 05 	mcall	800034ac <SD_GetSectorCount+0x18>
	
	temp = sdinfo.CardCapacity;
	
	temp = temp*(1024/512);//:1sector=512byte
8000349e:	41 1c       	lddsp	r12,sp[0x44]
800034a0:	a1 7c       	lsl	r12,0x1
800034a2:	48 48       	lddpc	r8,800034b0 <SD_GetSectorCount+0x1c>
800034a4:	91 0c       	st.w	r8[0x0],r12
	
	return (temp);
	
	

}
800034a6:	2e dd       	sub	sp,-76
800034a8:	d8 02       	popm	pc
800034aa:	00 00       	add	r0,r0
800034ac:	80 00       	ld.sh	r0,r0[0x0]
800034ae:	34 34       	mov	r4,67
800034b0:	00 00       	add	r0,r0
800034b2:	0a 5c       	eor	r12,r5

800034b4 <MAL_WriteDisk>:
* Output         :
* Return         : SD_ErrorStarus: SD Card Error code.
******************************************************************************************/

MAL_ErrorStarus MAL_WriteDisk(void *writebuff, uint32_t sector, uint32_t blockByteSize, uint8_t count)
{
800034b4:	d4 01       	pushm	lr
	
	
	if(count == 1)
800034b6:	30 18       	mov	r8,1
800034b8:	f0 09 18 00 	cp.b	r9,r8
800034bc:	c0 71       	brne	800034ca <MAL_WriteDisk+0x16>
	{
		
		if(SD_WriteBlock(writebuff, (sector*BLOCK_BYTE_SIZE), blockByteSize)==SD_RESPONSE_NO_ERROR)//1
800034be:	5c 7a       	castu.h	r10
800034c0:	a9 7b       	lsl	r11,0x9
800034c2:	f0 1f 00 07 	mcall	800034dc <MAL_WriteDisk+0x28>
800034c6:	c0 91       	brne	800034d8 <MAL_WriteDisk+0x24>
800034c8:	c0 68       	rjmp	800034d4 <MAL_WriteDisk+0x20>
		
	}
	else
	{
		
		if(SD_WriteMultiBlocks(writebuff, (sector*BLOCK_BYTE_SIZE), blockByteSize, count)==SD_RESPONSE_NO_ERROR)
800034ca:	5c 7a       	castu.h	r10
800034cc:	a9 7b       	lsl	r11,0x9
800034ce:	f0 1f 00 05 	mcall	800034e0 <MAL_WriteDisk+0x2c>
800034d2:	c0 31       	brne	800034d8 <MAL_WriteDisk+0x24>
800034d4:	30 4c       	mov	r12,4
800034d6:	d8 02       	popm	pc
800034d8:	30 3c       	mov	r12,3
	
	return WRITE_DATA_ERR;
	
	
	
}
800034da:	d8 02       	popm	pc
800034dc:	80 00       	ld.sh	r0,r0[0x0]
800034de:	2f 10       	sub	r0,-15
800034e0:	80 00       	ld.sh	r0,r0[0x0]
800034e2:	2e 48       	sub	r8,-28

800034e4 <MAL_ReadDisk>:
* Output         :
* Return         : SD_ErrorStarus: SD Card Error code.
******************************************************************************************/

MAL_ErrorStarus MAL_ReadDisk(void *readbuff, uint32_t sector, uint32_t blockByteSize, uint8_t count)
{
800034e4:	d4 01       	pushm	lr
	
	
	if(count == 1)
800034e6:	30 18       	mov	r8,1
800034e8:	f0 09 18 00 	cp.b	r9,r8
800034ec:	c0 71       	brne	800034fa <MAL_ReadDisk+0x16>
	{
		
		if(SD_ReadBlock(readbuff, (sector*BLOCK_BYTE_SIZE), blockByteSize)==SD_RESPONSE_NO_ERROR)//1
800034ee:	5c 7a       	castu.h	r10
800034f0:	a9 7b       	lsl	r11,0x9
800034f2:	f0 1f 00 07 	mcall	8000350c <MAL_ReadDisk+0x28>
800034f6:	c0 91       	brne	80003508 <MAL_ReadDisk+0x24>
800034f8:	c0 68       	rjmp	80003504 <MAL_ReadDisk+0x20>
		
	}
	else
	{
		
		if(SD_ReadMultiBlocks(readbuff, (sector*BLOCK_BYTE_SIZE), blockByteSize, count)==SD_RESPONSE_NO_ERROR)
800034fa:	5c 7a       	castu.h	r10
800034fc:	a9 7b       	lsl	r11,0x9
800034fe:	f0 1f 00 05 	mcall	80003510 <MAL_ReadDisk+0x2c>
80003502:	c0 31       	brne	80003508 <MAL_ReadDisk+0x24>
80003504:	30 8c       	mov	r12,8
80003506:	d8 02       	popm	pc
80003508:	30 7c       	mov	r12,7
	
	return READ_DATA_ERR;
	
		
	
}
8000350a:	d8 02       	popm	pc
8000350c:	80 00       	ld.sh	r0,r0[0x0]
8000350e:	30 7c       	mov	r12,7
80003510:	80 00       	ld.sh	r0,r0[0x0]
80003512:	2f b8       	sub	r8,-5

80003514 <MAL_InitConfig>:
* Output         : None
* Return         : SDConfigStatus:SD Card initiation code
*******************************************************************************/

uint16_t MAL_InitConfig(void)
{
80003514:	d4 01       	pushm	lr
80003516:	21 3d       	sub	sp,76
	uint16_t status = SDConfig_OK;
        
    SD_CardInfo cardinfo;

      if(!(SD_Init()))
80003518:	f0 1f 00 06 	mcall	80003530 <MAL_InitConfig+0x1c>
8000351c:	c0 30       	breq	80003522 <MAL_InitConfig+0xe>
8000351e:	30 1c       	mov	r12,1
80003520:	c0 58       	rjmp	8000352a <MAL_InitConfig+0x16>
      {
        
			if(SD_GetCardInfo(&cardinfo)==0) /*SD */
80003522:	1a 9c       	mov	r12,sp
80003524:	f0 1f 00 04 	mcall	80003534 <MAL_InitConfig+0x20>
80003528:	5f 1c       	srne	r12
			return status;//
      
      }    

        return SDConfig_FALL;
}
8000352a:	2e dd       	sub	sp,-76
8000352c:	d8 02       	popm	pc
8000352e:	00 00       	add	r0,r0
80003530:	80 00       	ld.sh	r0,r0[0x0]
80003532:	31 0c       	mov	r12,16
80003534:	80 00       	ld.sh	r0,r0[0x0]
80003536:	34 34       	mov	r4,67

80003538 <fl_write>:
	}
}


void fl_write(void * path, S32 offset, void * buffer, U32 length)
{
80003538:	eb cd 40 f8 	pushm	r3-r7,lr
8000353c:	20 2d       	sub	sp,8
8000353e:	18 95       	mov	r5,r12
80003540:	16 94       	mov	r4,r11
80003542:	14 93       	mov	r3,r10
80003544:	12 96       	mov	r6,r9
	
	fl_write_t * fl_write_ptr = pvPortMalloc(sizeof(fl_write_t));
80003546:	34 cc       	mov	r12,76
80003548:	f0 1f 00 16 	mcall	800035a0 <fl_write+0x68>
8000354c:	18 97       	mov	r7,r12
	
	sprintf(fl_write_ptr->path, "%s", path);
8000354e:	0a 9b       	mov	r11,r5
80003550:	f0 1f 00 15 	mcall	800035a4 <fl_write+0x6c>
	fl_write_ptr->offset = offset;
80003554:	ef 44 00 40 	st.w	r7[64],r4
	fl_write_ptr->length = length;	
80003558:	ef 46 00 44 	st.w	r7[68],r6
	
	fl_write_ptr->buffer = pvPortMalloc(length);
8000355c:	0c 9c       	mov	r12,r6
8000355e:	f0 1f 00 11 	mcall	800035a0 <fl_write+0x68>
80003562:	ef 4c 00 48 	st.w	r7[72],r12
	memcpy(fl_write_ptr->buffer, buffer, length);
80003566:	0c 9a       	mov	r10,r6
80003568:	06 9b       	mov	r11,r3
8000356a:	f0 1f 00 10 	mcall	800035a8 <fl_write+0x70>
	
	fl_oper_t fl_oper;
	
	fl_oper.opcode = FL_WRITE;
8000356e:	e0 68 40 00 	mov	r8,16384
80003572:	ba 08       	st.h	sp[0x0],r8
	fl_oper.payload = fl_write_ptr;
80003574:	50 17       	stdsp	sp[0x4],r7
	
	if(pdTRUE != xQueueSend( fl_oper_queue, &fl_oper, 0 ))
80003576:	48 e8       	lddpc	r8,800035ac <fl_write+0x74>
80003578:	70 0c       	ld.w	r12,r8[0x0]
8000357a:	30 09       	mov	r9,0
8000357c:	12 9a       	mov	r10,r9
8000357e:	1a 9b       	mov	r11,sp
80003580:	f0 1f 00 0c 	mcall	800035b0 <fl_write+0x78>
80003584:	58 1c       	cp.w	r12,1
80003586:	c0 a0       	breq	8000359a <fl_write+0x62>
	{
		vPortFree(fl_write_ptr->buffer);
80003588:	6f 2c       	ld.w	r12,r7[0x48]
8000358a:	f0 1f 00 0b 	mcall	800035b4 <fl_write+0x7c>
		vPortFree(fl_write_ptr);
8000358e:	0e 9c       	mov	r12,r7
80003590:	f0 1f 00 09 	mcall	800035b4 <fl_write+0x7c>
		log("\n\r fsmm \n\r");//man...SPI_PBA
80003594:	48 9c       	lddpc	r12,800035b8 <fl_write+0x80>
80003596:	f0 1f 00 0a 	mcall	800035bc <fl_write+0x84>
	}
	
}
8000359a:	2f ed       	sub	sp,-8
8000359c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800035a0:	80 00       	ld.sh	r0,r0[0x0]
800035a2:	8b 7c       	st.w	r5[0x1c],r12
800035a4:	80 00       	ld.sh	r0,r0[0x0]
800035a6:	a8 f8       	st.b	r4[0x7],r8
800035a8:	80 00       	ld.sh	r0,r0[0x0]
800035aa:	a4 86       	st.b	r2[0x0],r6
800035ac:	00 00       	add	r0,r0
800035ae:	0d 40       	ld.w	r0,--r6
800035b0:	80 00       	ld.sh	r0,r0[0x0]
800035b2:	8e d0       	ld.uh	r0,r7[0xa]
800035b4:	80 00       	ld.sh	r0,r0[0x0]
800035b6:	8b 54       	st.w	r5[0x14],r4
800035b8:	80 01       	ld.sh	r1,r0[0x0]
800035ba:	05 e8       	ld.ub	r8,r2[0x6]
800035bc:	80 00       	ld.sh	r0,r0[0x0]
800035be:	9a c0       	ld.uh	r0,sp[0x8]

800035c0 <fl_write_func>:
	f_mount(NULL, "/", 1);		
	return fs_ok;
}

fs_err_t fl_write_func(void * path, S32 offset, void * buffer, U32 length)
{	
800035c0:	d4 31       	pushm	r0-r7,lr
800035c2:	20 1d       	sub	sp,4
800035c4:	18 97       	mov	r7,r12
800035c6:	16 96       	mov	r6,r11
800035c8:	14 94       	mov	r4,r10
800035ca:	12 95       	mov	r5,r9
	if(f_mount(&fs, "/", 1) != FR_OK)
800035cc:	30 1a       	mov	r10,1
800035ce:	4c 7b       	lddpc	r11,800036e8 <fl_write_func+0x128>
800035d0:	4c 7c       	lddpc	r12,800036ec <fl_write_func+0x12c>
800035d2:	f0 1f 00 48 	mcall	800036f0 <fl_write_func+0x130>
800035d6:	e0 81 00 86 	brne	800036e2 <fl_write_func+0x122>
	{
		return amount_err;
	}
	
	FRESULT res	= f_open (&fl, path, FA_WRITE | FA_OPEN_ALWAYS);
800035da:	0e 91       	mov	r1,r7
800035dc:	31 2a       	mov	r10,18
800035de:	0e 9b       	mov	r11,r7
800035e0:	4c 5c       	lddpc	r12,800036f4 <fl_write_func+0x134>
800035e2:	f0 1f 00 46 	mcall	800036f8 <fl_write_func+0x138>
	if(FR_NO_PATH == res)
800035e6:	58 5c       	cp.w	r12,5
800035e8:	c5 91       	brne	8000369a <fl_write_func+0xda>
	{
		if ( f_opendir(&dirs, "/") != FR_OK)
800035ea:	4c 0b       	lddpc	r11,800036e8 <fl_write_func+0x128>
800035ec:	4c 4c       	lddpc	r12,800036fc <fl_write_func+0x13c>
800035ee:	f0 1f 00 45 	mcall	80003700 <fl_write_func+0x140>
800035f2:	c0 80       	breq	80003602 <fl_write_func+0x42>
		{
			f_mount(NULL, "/", 1);
800035f4:	30 1a       	mov	r10,1
800035f6:	4b db       	lddpc	r11,800036e8 <fl_write_func+0x128>
800035f8:	30 0c       	mov	r12,0
800035fa:	f0 1f 00 3e 	mcall	800036f0 <fl_write_func+0x130>
800035fe:	30 6c       	mov	r12,6
			return fs_err;
80003600:	c7 28       	rjmp	800036e4 <fl_write_func+0x124>
		}
		
		static char filename[MAX_PATH_LENGTH], path_bk[MAX_PATH_LENGTH];		
		memcpy(path_bk, path, strlen(path));
80003602:	0e 9c       	mov	r12,r7
80003604:	f0 1f 00 40 	mcall	80003704 <fl_write_func+0x144>
80003608:	4c 03       	lddpc	r3,80003708 <fl_write_func+0x148>
8000360a:	18 9a       	mov	r10,r12
8000360c:	0e 9b       	mov	r11,r7
8000360e:	06 9c       	mov	r12,r3
80003610:	f0 1f 00 3f 	mcall	8000370c <fl_write_func+0x14c>
				
		char * dir = strtok(path_bk,"/");
80003614:	4b 57       	lddpc	r7,800036e8 <fl_write_func+0x128>
80003616:	0e 9b       	mov	r11,r7
80003618:	06 9c       	mov	r12,r3
8000361a:	f0 1f 00 3e 	mcall	80003710 <fl_write_func+0x150>
		sprintf(filename,"//%s", dir);		
8000361e:	1a dc       	st.w	--sp,r12
80003620:	4b db       	lddpc	r11,80003714 <fl_write_func+0x154>
80003622:	4b ec       	lddpc	r12,80003718 <fl_write_func+0x158>
80003624:	f0 1f 00 3e 	mcall	8000371c <fl_write_func+0x15c>
		dir = strtok(NULL,"/");
80003628:	0e 9b       	mov	r11,r7
8000362a:	30 0c       	mov	r12,0
8000362c:	f0 1f 00 39 	mcall	80003710 <fl_write_func+0x150>
80003630:	18 97       	mov	r7,r12
		while(TRUE)
		{
			if(NULL != dir)
80003632:	2f fd       	sub	sp,-4
80003634:	58 0c       	cp.w	r12,0
80003636:	c2 50       	breq	80003680 <fl_write_func+0xc0>
			{				
				res = f_mkdir(filename);
80003638:	4b 83       	lddpc	r3,80003718 <fl_write_func+0x158>
				if((res == FR_OK) || (res == FR_EXIST))
8000363a:	30 02       	mov	r2,0
				{					
					sprintf(filename,"%s//%s", filename, dir);
8000363c:	4b 90       	lddpc	r0,80003720 <fl_write_func+0x160>
		dir = strtok(NULL,"/");
		while(TRUE)
		{
			if(NULL != dir)
			{				
				res = f_mkdir(filename);
8000363e:	06 9c       	mov	r12,r3
80003640:	f0 1f 00 39 	mcall	80003724 <fl_write_func+0x164>
				if((res == FR_OK) || (res == FR_EXIST))
80003644:	5f 09       	sreq	r9
80003646:	58 8c       	cp.w	r12,8
80003648:	5f 08       	sreq	r8
8000364a:	f3 e8 10 08 	or	r8,r9,r8
8000364e:	e4 08 18 00 	cp.b	r8,r2
80003652:	c1 00       	breq	80003672 <fl_write_func+0xb2>
				{					
					sprintf(filename,"%s//%s", filename, dir);
80003654:	1a d7       	st.w	--sp,r7
80003656:	1a d3       	st.w	--sp,r3
80003658:	00 9b       	mov	r11,r0
8000365a:	06 9c       	mov	r12,r3
8000365c:	f0 1f 00 30 	mcall	8000371c <fl_write_func+0x15c>
					dir = strtok(NULL,"/");					
80003660:	4a 2b       	lddpc	r11,800036e8 <fl_write_func+0x128>
80003662:	30 0c       	mov	r12,0
80003664:	f0 1f 00 2b 	mcall	80003710 <fl_write_func+0x150>
80003668:	18 97       	mov	r7,r12
		char * dir = strtok(path_bk,"/");
		sprintf(filename,"//%s", dir);		
		dir = strtok(NULL,"/");
		while(TRUE)
		{
			if(NULL != dir)
8000366a:	2f ed       	sub	sp,-8
8000366c:	58 0c       	cp.w	r12,0
8000366e:	ce 81       	brne	8000363e <fl_write_func+0x7e>
80003670:	c0 88       	rjmp	80003680 <fl_write_func+0xc0>
					sprintf(filename,"%s//%s", filename, dir);
					dir = strtok(NULL,"/");					
				}
				else
				{
					f_mount(NULL, "/", 1);	
80003672:	30 1a       	mov	r10,1
80003674:	49 db       	lddpc	r11,800036e8 <fl_write_func+0x128>
80003676:	30 0c       	mov	r12,0
80003678:	f0 1f 00 1e 	mcall	800036f0 <fl_write_func+0x130>
8000367c:	30 4c       	mov	r12,4
					return new_dir_err;
8000367e:	c3 38       	rjmp	800036e4 <fl_write_func+0x124>
				}
				
			}
			else
			{
				res	= f_open (&fl, path, FA_WRITE | FA_OPEN_ALWAYS);
80003680:	31 2a       	mov	r10,18
80003682:	02 9b       	mov	r11,r1
80003684:	49 cc       	lddpc	r12,800036f4 <fl_write_func+0x134>
80003686:	f0 1f 00 1d 	mcall	800036f8 <fl_write_func+0x138>
				if(res != FR_OK)
8000368a:	c1 10       	breq	800036ac <fl_write_func+0xec>
				{					
					f_mount(NULL, "/", 1);	
8000368c:	30 1a       	mov	r10,1
8000368e:	49 7b       	lddpc	r11,800036e8 <fl_write_func+0x128>
80003690:	30 0c       	mov	r12,0
80003692:	f0 1f 00 18 	mcall	800036f0 <fl_write_func+0x130>
80003696:	30 3c       	mov	r12,3
					return open_fl_err;
80003698:	c2 68       	rjmp	800036e4 <fl_write_func+0x124>
				}
				break;
			}
		}
	}
	else if(res != FR_OK)
8000369a:	58 0c       	cp.w	r12,0
8000369c:	c0 80       	breq	800036ac <fl_write_func+0xec>
	{
		f_mount(NULL, "/", 1);
8000369e:	30 1a       	mov	r10,1
800036a0:	49 2b       	lddpc	r11,800036e8 <fl_write_func+0x128>
800036a2:	30 0c       	mov	r12,0
800036a4:	f0 1f 00 13 	mcall	800036f0 <fl_write_func+0x130>
800036a8:	30 3c       	mov	r12,3
		return open_fl_err;
800036aa:	c1 d8       	rjmp	800036e4 <fl_write_func+0x124>
	}
	
	if(offset == FILE_END)
800036ac:	5b f6       	cp.w	r6,-1
800036ae:	c0 61       	brne	800036ba <fl_write_func+0xfa>
	{
		f_lseek(&fl, fl.fsize);
800036b0:	49 1c       	lddpc	r12,800036f4 <fl_write_func+0x134>
800036b2:	78 3b       	ld.w	r11,r12[0xc]
800036b4:	f0 1f 00 1d 	mcall	80003728 <fl_write_func+0x168>
800036b8:	c0 58       	rjmp	800036c2 <fl_write_func+0x102>
	}
	else
	{
		f_lseek(&fl, offset);
800036ba:	0c 9b       	mov	r11,r6
800036bc:	48 ec       	lddpc	r12,800036f4 <fl_write_func+0x134>
800036be:	f0 1f 00 1b 	mcall	80003728 <fl_write_func+0x168>
	}
	
	UINT w;
	f_write (&fl, buffer, length, &w );
800036c2:	48 d7       	lddpc	r7,800036f4 <fl_write_func+0x134>
800036c4:	1a 99       	mov	r9,sp
800036c6:	0a 9a       	mov	r10,r5
800036c8:	08 9b       	mov	r11,r4
800036ca:	0e 9c       	mov	r12,r7
800036cc:	f0 1f 00 18 	mcall	8000372c <fl_write_func+0x16c>

	f_close (&fl);
800036d0:	0e 9c       	mov	r12,r7
800036d2:	f0 1f 00 18 	mcall	80003730 <fl_write_func+0x170>
		
	f_mount(NULL, "/", 1);	
800036d6:	30 1a       	mov	r10,1
800036d8:	48 4b       	lddpc	r11,800036e8 <fl_write_func+0x128>
800036da:	30 0c       	mov	r12,0
800036dc:	f0 1f 00 05 	mcall	800036f0 <fl_write_func+0x130>
800036e0:	c0 28       	rjmp	800036e4 <fl_write_func+0x124>
}
800036e2:	30 2c       	mov	r12,2
800036e4:	2f fd       	sub	sp,-4
800036e6:	d8 32       	popm	r0-r7,pc
800036e8:	80 01       	ld.sh	r1,r0[0x0]
800036ea:	05 e4       	ld.ub	r4,r2[0x6]
800036ec:	00 00       	add	r0,r0
800036ee:	0a 70       	tst	r0,r5
800036f0:	80 00       	ld.sh	r0,r0[0x0]
800036f2:	70 ec       	ld.w	r12,r8[0x38]
800036f4:	00 00       	add	r0,r0
800036f6:	0d 48       	ld.w	r8,--r6
800036f8:	80 00       	ld.sh	r0,r0[0x0]
800036fa:	80 b8       	ld.uh	r8,r0[0x6]
800036fc:	00 00       	add	r0,r0
800036fe:	0c e0       	st.h	--r6,r0
80003700:	80 00       	ld.sh	r0,r0[0x0]
80003702:	7e 7c       	ld.w	r12,pc[0x1c]
80003704:	80 00       	ld.sh	r0,r0[0x0]
80003706:	a9 0a       	ld.d	r10,r4
80003708:	00 00       	add	r0,r0
8000370a:	0d 00       	ld.w	r0,r6++
8000370c:	80 00       	ld.sh	r0,r0[0x0]
8000370e:	a4 86       	st.b	r2[0x0],r6
80003710:	80 00       	ld.sh	r0,r0[0x0]
80003712:	a9 40       	asr	r0,0x8
80003714:	80 01       	ld.sh	r1,r0[0x0]
80003716:	05 f4       	ld.ub	r4,r2[0x7]
80003718:	00 00       	add	r0,r0
8000371a:	0c a0       	st.w	r6++,r0
8000371c:	80 00       	ld.sh	r0,r0[0x0]
8000371e:	a8 bc       	st.b	r4[0x3],r12
80003720:	80 01       	ld.sh	r1,r0[0x0]
80003722:	05 fc       	ld.ub	r12,r2[0x7]
80003724:	80 00       	ld.sh	r0,r0[0x0]
80003726:	7f 00       	ld.w	r0,pc[0x40]
80003728:	80 00       	ld.sh	r0,r0[0x0]
8000372a:	83 58       	st.w	r1[0x14],r8
8000372c:	80 00       	ld.sh	r0,r0[0x0]
8000372e:	86 0c       	ld.sh	r12,r3[0x0]
80003730:	80 00       	ld.sh	r0,r0[0x0]
80003732:	72 38       	ld.w	r8,r9[0xc]

80003734 <fl_oper_process>:


static void fl_oper_process(void * pvParameters)
{
80003734:	eb cd 40 f8 	pushm	r3-r7,lr
	fl_oper_t * fl_oper = pvPortMalloc(sizeof(fl_oper_t));
80003738:	30 8c       	mov	r12,8
8000373a:	f0 1f 00 17 	mcall	80003794 <fl_oper_process+0x60>
8000373e:	18 97       	mov	r7,r12
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( fl_oper_queue, fl_oper, portMAX_DELAY ))
80003740:	49 66       	lddpc	r6,80003798 <fl_oper_process+0x64>
80003742:	30 05       	mov	r5,0
80003744:	3f f4       	mov	r4,-1
		{  
			switch(fl_oper->opcode)
80003746:	e0 63 40 00 	mov	r3,16384
static void fl_oper_process(void * pvParameters)
{
	fl_oper_t * fl_oper = pvPortMalloc(sizeof(fl_oper_t));
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( fl_oper_queue, fl_oper, portMAX_DELAY ))
8000374a:	6c 0c       	ld.w	r12,r6[0x0]
8000374c:	0a 99       	mov	r9,r5
8000374e:	08 9a       	mov	r10,r4
80003750:	0e 9b       	mov	r11,r7
80003752:	f0 1f 00 13 	mcall	8000379c <fl_oper_process+0x68>
80003756:	58 1c       	cp.w	r12,1
80003758:	cf 91       	brne	8000374a <fl_oper_process+0x16>
		{  
			switch(fl_oper->opcode)
8000375a:	8e 08       	ld.sh	r8,r7[0x0]
8000375c:	e6 08 19 00 	cp.h	r8,r3
80003760:	c1 31       	brne	80003786 <fl_oper_process+0x52>
			{
			case FL_WRITE:
			
				if(NULL != fl_oper->payload)
80003762:	6e 1c       	ld.w	r12,r7[0x4]
80003764:	58 0c       	cp.w	r12,0
80003766:	cf 20       	breq	8000374a <fl_oper_process+0x16>
				{
					if(NULL != ((fl_write_t *)(fl_oper->payload))->buffer)
80003768:	79 2a       	ld.w	r10,r12[0x48]
8000376a:	58 0a       	cp.w	r10,0
8000376c:	c0 90       	breq	8000377e <fl_oper_process+0x4a>
					{
						fl_write_func(((fl_write_t *)(fl_oper->payload))->path
8000376e:	79 19       	ld.w	r9,r12[0x44]
80003770:	79 0b       	ld.w	r11,r12[0x40]
80003772:	f0 1f 00 0c 	mcall	800037a0 <fl_oper_process+0x6c>
							, ((fl_write_t *)(fl_oper->payload))->offset
							, ((fl_write_t *)(fl_oper->payload))->buffer
							, ((fl_write_t *)(fl_oper->payload))->length);
						
						vPortFree(((fl_write_t *)(fl_oper->payload))->buffer);
80003776:	6e 18       	ld.w	r8,r7[0x4]
80003778:	71 2c       	ld.w	r12,r8[0x48]
8000377a:	f0 1f 00 0b 	mcall	800037a4 <fl_oper_process+0x70>
					}
					vPortFree(fl_oper->payload);					
8000377e:	6e 1c       	ld.w	r12,r7[0x4]
80003780:	f0 1f 00 09 	mcall	800037a4 <fl_oper_process+0x70>
80003784:	ce 3b       	rjmp	8000374a <fl_oper_process+0x16>
				}
				break;
								
			default:
				if(NULL != fl_oper->payload)
80003786:	6e 1c       	ld.w	r12,r7[0x4]
80003788:	58 0c       	cp.w	r12,0
8000378a:	ce 00       	breq	8000374a <fl_oper_process+0x16>
				{
					vPortFree(fl_oper->payload);
8000378c:	f0 1f 00 06 	mcall	800037a4 <fl_oper_process+0x70>
80003790:	cd db       	rjmp	8000374a <fl_oper_process+0x16>
80003792:	00 00       	add	r0,r0
80003794:	80 00       	ld.sh	r0,r0[0x0]
80003796:	8b 7c       	st.w	r5[0x1c],r12
80003798:	00 00       	add	r0,r0
8000379a:	0d 40       	ld.w	r0,--r6
8000379c:	80 00       	ld.sh	r0,r0[0x0]
8000379e:	8c c4       	ld.uh	r4,r6[0x8]
800037a0:	80 00       	ld.sh	r0,r0[0x0]
800037a2:	35 c0       	mov	r0,92
800037a4:	80 00       	ld.sh	r0,r0[0x0]
800037a6:	8b 54       	st.w	r5[0x14],r4

800037a8 <disk_init>:
APP_RES_OKDISK_OPERATION_ERRORSDFILE_OPERATION_ERROR
*/
//

fs_err_t disk_init(void)
{
800037a8:	d4 01       	pushm	lr
800037aa:	20 3d       	sub	sp,12
	char str[MAX_DISK_LABEL_SIZE];
	
	/*initialize disk*/
	if(MAL_InitConfig())
800037ac:	f0 1f 00 41 	mcall	800038b0 <disk_init+0x108>
800037b0:	5c 8c       	casts.h	r12
800037b2:	c0 30       	breq	800037b8 <disk_init+0x10>
800037b4:	30 1c       	mov	r12,1
800037b6:	c7 a8       	rjmp	800038aa <disk_init+0x102>
	{
		return disk_err;
	}	
		
	if(f_mount(&fs, "/", 1) != FR_OK)
800037b8:	30 1a       	mov	r10,1
800037ba:	4b fb       	lddpc	r11,800038b4 <disk_init+0x10c>
800037bc:	4b fc       	lddpc	r12,800038b8 <disk_init+0x110>
800037be:	f0 1f 00 40 	mcall	800038bc <disk_init+0x114>
800037c2:	c0 30       	breq	800037c8 <disk_init+0x20>
800037c4:	30 2c       	mov	r12,2
800037c6:	c7 28       	rjmp	800038aa <disk_init+0x102>
	{
		return amount_err;
	}
	
	FRESULT res = f_getfree("/", &clust, &pfs);
800037c8:	4b ea       	lddpc	r10,800038c0 <disk_init+0x118>
800037ca:	4b fb       	lddpc	r11,800038c4 <disk_init+0x11c>
800037cc:	4b ac       	lddpc	r12,800038b4 <disk_init+0x10c>
800037ce:	f0 1f 00 3f 	mcall	800038c8 <disk_init+0x120>
	if(res == FR_NO_FILESYSTEM) 
800037d2:	58 dc       	cp.w	r12,13
800037d4:	c1 41       	brne	800037fc <disk_init+0x54>
	{
		/* Create a file system on the drive */
		res = f_mkfs (0, 0, 4096);
800037d6:	e0 6a 10 00 	mov	r10,4096
800037da:	30 0b       	mov	r11,0
800037dc:	16 9c       	mov	r12,r11
800037de:	f0 1f 00 3c 	mcall	800038cc <disk_init+0x124>
		if( f_getfree("/", &clust, &pfs) != FR_OK)
800037e2:	4b 8a       	lddpc	r10,800038c0 <disk_init+0x118>
800037e4:	4b 8b       	lddpc	r11,800038c4 <disk_init+0x11c>
800037e6:	4b 4c       	lddpc	r12,800038b4 <disk_init+0x10c>
800037e8:	f0 1f 00 38 	mcall	800038c8 <disk_init+0x120>
800037ec:	c1 10       	breq	8000380e <disk_init+0x66>
		{
			f_mount(NULL, "/", 1);	
800037ee:	30 1a       	mov	r10,1
800037f0:	4b 1b       	lddpc	r11,800038b4 <disk_init+0x10c>
800037f2:	30 0c       	mov	r12,0
800037f4:	f0 1f 00 32 	mcall	800038bc <disk_init+0x114>
800037f8:	30 5c       	mov	r12,5
			return no_fs;
800037fa:	c5 88       	rjmp	800038aa <disk_init+0x102>
		}
	}
	else if(res != FR_OK)
800037fc:	58 0c       	cp.w	r12,0
800037fe:	c0 80       	breq	8000380e <disk_init+0x66>
	{
		f_mount(NULL, "/", 1);
80003800:	30 1a       	mov	r10,1
80003802:	4a db       	lddpc	r11,800038b4 <disk_init+0x10c>
80003804:	30 0c       	mov	r12,0
80003806:	f0 1f 00 2e 	mcall	800038bc <disk_init+0x114>
8000380a:	30 6c       	mov	r12,6
		return fs_err;
8000380c:	c4 f8       	rjmp	800038aa <disk_init+0x102>
	}
	
	
	//pdisk->freecap = ((clust*(pfs->csize)/1024/1024)*512);
	
	memset(str,0,MAX_DISK_LABEL_SIZE);
8000380e:	1a 9b       	mov	r11,sp
80003810:	30 08       	mov	r8,0
80003812:	30 09       	mov	r9,0
80003814:	fa e9 00 00 	st.d	sp[0],r8
80003818:	30 0a       	mov	r10,0
8000381a:	50 2a       	stdsp	sp[0x8],r10
	if(f_getlabel("/", str, 0) != FR_OK)
8000381c:	4a 6c       	lddpc	r12,800038b4 <disk_init+0x10c>
8000381e:	f0 1f 00 2d 	mcall	800038d0 <disk_init+0x128>
80003822:	c0 80       	breq	80003832 <disk_init+0x8a>
	{
		f_mount(NULL, "/", 1);
80003824:	30 1a       	mov	r10,1
80003826:	4a 4b       	lddpc	r11,800038b4 <disk_init+0x10c>
80003828:	30 0c       	mov	r12,0
8000382a:	f0 1f 00 25 	mcall	800038bc <disk_init+0x114>
8000382e:	30 6c       	mov	r12,6
		return fs_err;
80003830:	c3 d8       	rjmp	800038aa <disk_init+0x102>
	}
		
	if(memcmp(DiskLabel, str, sizeof(DiskLabel) - 1) != 0)
80003832:	30 7a       	mov	r10,7
80003834:	1a 9b       	mov	r11,sp
80003836:	4a 8c       	lddpc	r12,800038d4 <disk_init+0x12c>
80003838:	f0 1f 00 28 	mcall	800038d8 <disk_init+0x130>
8000383c:	c0 c0       	breq	80003854 <disk_init+0xac>
	{
		if(f_setlabel("MOTOREC") != FR_OK)
8000383e:	4a 8c       	lddpc	r12,800038dc <disk_init+0x134>
80003840:	f0 1f 00 28 	mcall	800038e0 <disk_init+0x138>
80003844:	c0 80       	breq	80003854 <disk_init+0xac>
		{
			f_mount(NULL, "/", 1);
80003846:	30 1a       	mov	r10,1
80003848:	49 bb       	lddpc	r11,800038b4 <disk_init+0x10c>
8000384a:	30 0c       	mov	r12,0
8000384c:	f0 1f 00 1c 	mcall	800038bc <disk_init+0x114>
80003850:	30 6c       	mov	r12,6
			return fs_err;
80003852:	c2 c8       	rjmp	800038aa <disk_init+0x102>
		}
	}
			
	if ( f_opendir(&dirs, "/") == FR_OK)
80003854:	49 8b       	lddpc	r11,800038b4 <disk_init+0x10c>
80003856:	4a 4c       	lddpc	r12,800038e4 <disk_init+0x13c>
80003858:	f0 1f 00 24 	mcall	800038e8 <disk_init+0x140>
8000385c:	c2 11       	brne	8000389e <disk_init+0xf6>
	{
		if(f_open(&fl, "sys.ini", FA_CREATE_ALWAYS | FA_WRITE) == FR_OK )
8000385e:	30 aa       	mov	r10,10
80003860:	4a 3b       	lddpc	r11,800038ec <disk_init+0x144>
80003862:	4a 4c       	lddpc	r12,800038f0 <disk_init+0x148>
80003864:	f0 1f 00 24 	mcall	800038f4 <disk_init+0x14c>
80003868:	c1 41       	brne	80003890 <disk_init+0xe8>
		{
			f_close(&fl);
8000386a:	4a 2c       	lddpc	r12,800038f0 <disk_init+0x148>
8000386c:	f0 1f 00 23 	mcall	800038f8 <disk_init+0x150>
		{
			f_mount(NULL, "/", 1);
			return fs_err;
		}
				
		f_mkdir("/REC");			
80003870:	4a 3c       	lddpc	r12,800038fc <disk_init+0x154>
80003872:	f0 1f 00 24 	mcall	80003900 <disk_init+0x158>
		f_mkdir("/REC/ZONE01");			
80003876:	4a 4c       	lddpc	r12,80003904 <disk_init+0x15c>
80003878:	f0 1f 00 22 	mcall	80003900 <disk_init+0x158>
		f_mkdir("/REC/ZONE01/CH01");		
8000387c:	4a 3c       	lddpc	r12,80003908 <disk_init+0x160>
8000387e:	f0 1f 00 21 	mcall	80003900 <disk_init+0x158>
	{
		f_mount(NULL, "/", 1);
		return fs_err;
	}
	
	f_mount(NULL, "/", 1);		
80003882:	30 1a       	mov	r10,1
80003884:	48 cb       	lddpc	r11,800038b4 <disk_init+0x10c>
80003886:	30 0c       	mov	r12,0
80003888:	f0 1f 00 0d 	mcall	800038bc <disk_init+0x114>
8000388c:	30 0c       	mov	r12,0
	return fs_ok;
8000388e:	c0 e8       	rjmp	800038aa <disk_init+0x102>
		{
			f_close(&fl);
		}
		else 
		{
			f_mount(NULL, "/", 1);
80003890:	30 1a       	mov	r10,1
80003892:	48 9b       	lddpc	r11,800038b4 <disk_init+0x10c>
80003894:	30 0c       	mov	r12,0
80003896:	f0 1f 00 0a 	mcall	800038bc <disk_init+0x114>
8000389a:	30 6c       	mov	r12,6
			return fs_err;
8000389c:	c0 78       	rjmp	800038aa <disk_init+0x102>
		f_mkdir("/REC/ZONE01");			
		f_mkdir("/REC/ZONE01/CH01");		
	}
	else 
	{
		f_mount(NULL, "/", 1);
8000389e:	30 1a       	mov	r10,1
800038a0:	48 5b       	lddpc	r11,800038b4 <disk_init+0x10c>
800038a2:	30 0c       	mov	r12,0
800038a4:	f0 1f 00 06 	mcall	800038bc <disk_init+0x114>
800038a8:	30 6c       	mov	r12,6
		return fs_err;
	}
	
	f_mount(NULL, "/", 1);		
	return fs_ok;
}
800038aa:	2f dd       	sub	sp,-12
800038ac:	d8 02       	popm	pc
800038ae:	00 00       	add	r0,r0
800038b0:	80 00       	ld.sh	r0,r0[0x0]
800038b2:	35 14       	mov	r4,81
800038b4:	80 01       	ld.sh	r1,r0[0x0]
800038b6:	05 e4       	ld.ub	r4,r2[0x6]
800038b8:	00 00       	add	r0,r0
800038ba:	0a 70       	tst	r0,r5
800038bc:	80 00       	ld.sh	r0,r0[0x0]
800038be:	70 ec       	ld.w	r12,r8[0x38]
800038c0:	00 00       	add	r0,r0
800038c2:	0d 44       	ld.w	r4,--r6
800038c4:	00 00       	add	r0,r0
800038c6:	0a 6c       	and	r12,r5
800038c8:	80 00       	ld.sh	r0,r0[0x0]
800038ca:	82 6c       	ld.sh	r12,r1[0xc]
800038cc:	80 00       	ld.sh	r0,r0[0x0]
800038ce:	65 b0       	ld.w	r0,r2[0x6c]
800038d0:	80 00       	ld.sh	r0,r0[0x0]
800038d2:	77 e8       	ld.w	r8,r11[0x78]
800038d4:	00 00       	add	r0,r0
800038d6:	04 f4       	st.b	--r2,r4
800038d8:	80 00       	ld.sh	r0,r0[0x0]
800038da:	a4 60       	st.h	r2[0xc],r0
800038dc:	80 01       	ld.sh	r1,r0[0x0]
800038de:	06 04       	add	r4,r3
800038e0:	80 00       	ld.sh	r0,r0[0x0]
800038e2:	79 34       	ld.w	r4,r12[0x4c]
800038e4:	00 00       	add	r0,r0
800038e6:	0c e0       	st.h	--r6,r0
800038e8:	80 00       	ld.sh	r0,r0[0x0]
800038ea:	7e 7c       	ld.w	r12,pc[0x1c]
800038ec:	80 01       	ld.sh	r1,r0[0x0]
800038ee:	06 0c       	add	r12,r3
800038f0:	00 00       	add	r0,r0
800038f2:	0d 48       	ld.w	r8,--r6
800038f4:	80 00       	ld.sh	r0,r0[0x0]
800038f6:	80 b8       	ld.uh	r8,r0[0x6]
800038f8:	80 00       	ld.sh	r0,r0[0x0]
800038fa:	72 38       	ld.w	r8,r9[0xc]
800038fc:	80 01       	ld.sh	r1,r0[0x0]
800038fe:	06 14       	sub	r4,r3
80003900:	80 00       	ld.sh	r0,r0[0x0]
80003902:	7f 00       	ld.w	r0,pc[0x40]
80003904:	80 01       	ld.sh	r1,r0[0x0]
80003906:	06 1c       	sub	r12,r3
80003908:	80 01       	ld.sh	r1,r0[0x0]
8000390a:	06 28       	rsub	r8,r3

8000390c <fs_init>:
	}
	
}

fs_err_t fs_init(void)
{
8000390c:	eb cd 40 80 	pushm	r7,lr
	fs_err_t res = disk_init();
80003910:	f0 1f 00 0d 	mcall	80003944 <fs_init+0x38>
80003914:	18 97       	mov	r7,r12
	if( fs_ok ==  res)
80003916:	c1 31       	brne	8000393c <fs_init+0x30>
	{
		fl_oper_queue = xQueueCreate(20, sizeof(fl_oper_t)); //20*512bytes = 10k
80003918:	30 8b       	mov	r11,8
8000391a:	31 4c       	mov	r12,20
8000391c:	f0 1f 00 0b 	mcall	80003948 <fs_init+0x3c>
80003920:	48 b8       	lddpc	r8,8000394c <fs_init+0x40>
80003922:	91 0c       	st.w	r8[0x0],r12
		
		/*create a task for files operation*/
		xTaskCreate(
80003924:	30 09       	mov	r9,0
80003926:	1a d9       	st.w	--sp,r9
80003928:	1a d9       	st.w	--sp,r9
8000392a:	1a d9       	st.w	--sp,r9
8000392c:	30 28       	mov	r8,2
8000392e:	e0 6a 02 00 	mov	r10,512
80003932:	48 8b       	lddpc	r11,80003950 <fs_init+0x44>
80003934:	48 8c       	lddpc	r12,80003954 <fs_init+0x48>
80003936:	f0 1f 00 09 	mcall	80003958 <fs_init+0x4c>
		,  NULL
		,  2//1
		,  NULL
		);		
		
		return fs_ok;		
8000393a:	2f dd       	sub	sp,-12
	}
	else
	{
		return res;
	}
}
8000393c:	0e 9c       	mov	r12,r7
8000393e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003942:	00 00       	add	r0,r0
80003944:	80 00       	ld.sh	r0,r0[0x0]
80003946:	37 a8       	mov	r8,122
80003948:	80 00       	ld.sh	r0,r0[0x0]
8000394a:	90 28       	ld.sh	r8,r8[0x4]
8000394c:	00 00       	add	r0,r0
8000394e:	0d 40       	ld.w	r0,--r6
80003950:	80 01       	ld.sh	r1,r0[0x0]
80003952:	06 3c       	cp.w	r12,r3
80003954:	80 00       	ld.sh	r0,r0[0x0]
80003956:	37 34       	mov	r4,115
80003958:	80 00       	ld.sh	r0,r0[0x0]
8000395a:	96 fc       	ld.uh	r12,r11[0xe]

8000395c <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
8000395c:	20 1c       	sub	r12,1
8000395e:	5c 5c       	castu.b	r12
80003960:	31 18       	mov	r8,17
80003962:	f0 0c 18 00 	cp.b	r12,r8
80003966:	e0 88 00 03 	brls	8000396c <CalculateBurst+0x10>
8000396a:	5e fd       	retal	0
8000396c:	48 28       	lddpc	r8,80003974 <CalculateBurst+0x18>
8000396e:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80003972:	5e fc       	retal	r12
80003974:	80 01       	ld.sh	r1,r0[0x0]
80003976:	06 54       	eor	r4,r3

80003978 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80003978:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
8000397a:	48 98       	lddpc	r8,8000399c <payload_init+0x24>
8000397c:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
8000397e:	48 98       	lddpc	r8,800039a0 <payload_init+0x28>
80003980:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80003982:	30 09       	mov	r9,0
80003984:	1a d9       	st.w	--sp,r9
80003986:	1a d9       	st.w	--sp,r9
80003988:	1a d9       	st.w	--sp,r9
8000398a:	30 28       	mov	r8,2
8000398c:	e0 6a 04 00 	mov	r10,1024
80003990:	48 5b       	lddpc	r11,800039a4 <payload_init+0x2c>
80003992:	48 6c       	lddpc	r12,800039a8 <payload_init+0x30>
80003994:	f0 1f 00 06 	mcall	800039ac <payload_init+0x34>
80003998:	2f dd       	sub	sp,-12
	
	
	
	
	
}
8000399a:	d8 02       	popm	pc
8000399c:	00 00       	add	r0,r0
8000399e:	0f 70       	ld.ub	r0,--r7
800039a0:	00 00       	add	r0,r0
800039a2:	0f 74       	ld.ub	r4,--r7
800039a4:	80 01       	ld.sh	r1,r0[0x0]
800039a6:	06 9c       	mov	r12,r3
800039a8:	80 00       	ld.sh	r0,r0[0x0]
800039aa:	39 b0       	mov	r0,-101
800039ac:	80 00       	ld.sh	r0,r0[0x0]
800039ae:	96 fc       	ld.uh	r12,r11[0xe]

800039b0 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
800039b0:	eb cd 40 f8 	pushm	r3-r7,lr
800039b4:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
800039b6:	48 e8       	lddpc	r8,800039ec <payload_rx_process+0x3c>
800039b8:	70 08       	ld.w	r8,r8[0x0]
800039ba:	58 08       	cp.w	r8,0
800039bc:	c0 71       	brne	800039ca <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
800039be:	30 4b       	mov	r11,4
800039c0:	30 5c       	mov	r12,5
800039c2:	f0 1f 00 0c 	mcall	800039f0 <payload_rx_process+0x40>
800039c6:	48 a8       	lddpc	r8,800039ec <payload_rx_process+0x3c>
800039c8:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
800039ca:	48 96       	lddpc	r6,800039ec <payload_rx_process+0x3c>
800039cc:	30 05       	mov	r5,0
800039ce:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
800039d0:	48 93       	lddpc	r3,800039f4 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
800039d2:	6c 0c       	ld.w	r12,r6[0x0]
800039d4:	0a 99       	mov	r9,r5
800039d6:	08 9a       	mov	r10,r4
800039d8:	1a 9b       	mov	r11,sp
800039da:	f0 1f 00 08 	mcall	800039f8 <payload_rx_process+0x48>
800039de:	58 1c       	cp.w	r12,1
800039e0:	cf 91       	brne	800039d2 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
800039e2:	66 08       	ld.w	r8,r3[0x0]
800039e4:	40 0c       	lddsp	r12,sp[0x0]
800039e6:	5d 18       	icall	r8
800039e8:	cf 5b       	rjmp	800039d2 <payload_rx_process+0x22>
800039ea:	00 00       	add	r0,r0
800039ec:	00 00       	add	r0,r0
800039ee:	0f 8c       	ld.ub	r12,r7[0x0]
800039f0:	80 00       	ld.sh	r0,r0[0x0]
800039f2:	90 28       	ld.sh	r8,r8[0x4]
800039f4:	00 00       	add	r0,r0
800039f6:	0f 70       	ld.ub	r0,--r7
800039f8:	80 00       	ld.sh	r0,r0[0x0]
800039fa:	8c c4       	ld.uh	r4,r6[0x8]

800039fc <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
800039fc:	d4 01       	pushm	lr
800039fe:	20 2d       	sub	sp,8
80003a00:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003a02:	30 09       	mov	r9,0
80003a04:	fa ca ff f8 	sub	r10,sp,-8
80003a08:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80003a0a:	1a 9b       	mov	r11,sp
80003a0c:	f0 1f 00 02 	mcall	80003a14 <set_idle_store_isr+0x18>
}
80003a10:	2f ed       	sub	sp,-8
80003a12:	d8 02       	popm	pc
80003a14:	80 00       	ld.sh	r0,r0[0x0]
80003a16:	8e 80       	ld.uh	r0,r7[0x0]

80003a18 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80003a18:	d4 01       	pushm	lr
80003a1a:	20 2d       	sub	sp,8
80003a1c:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80003a1e:	58 0c       	cp.w	r12,0
80003a20:	c1 10       	breq	80003a42 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003a22:	30 08       	mov	r8,0
80003a24:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80003a26:	98 88       	ld.uh	r8,r12[0x0]
80003a28:	e2 18 f0 00 	andl	r8,0xf000,COH
80003a2c:	e0 48 40 00 	cp.w	r8,16384
80003a30:	c0 91       	brne	80003a42 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80003a32:	48 68       	lddpc	r8,80003a48 <phy_rx+0x30>
80003a34:	70 0c       	ld.w	r12,r8[0x0]
80003a36:	30 09       	mov	r9,0
80003a38:	fa ca ff fc 	sub	r10,sp,-4
80003a3c:	1a 9b       	mov	r11,sp
80003a3e:	f0 1f 00 04 	mcall	80003a4c <phy_rx+0x34>
		}	

    }
		
 
}
80003a42:	2f ed       	sub	sp,-8
80003a44:	d8 02       	popm	pc
80003a46:	00 00       	add	r0,r0
80003a48:	00 00       	add	r0,r0
80003a4a:	0f cc       	ld.ub	r12,r7[0x4]
80003a4c:	80 00       	ld.sh	r0,r0[0x0]
80003a4e:	8e 80       	ld.uh	r0,r7[0x0]

80003a50 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80003a50:	eb cd 40 80 	pushm	r7,lr
80003a54:	20 1d       	sub	sp,4
80003a56:	fa c7 ff fc 	sub	r7,sp,-4
80003a5a:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80003a5c:	30 09       	mov	r9,0
80003a5e:	12 9a       	mov	r10,r9
80003a60:	1a 9b       	mov	r11,sp
80003a62:	f0 1f 00 03 	mcall	80003a6c <set_idle_store+0x1c>
}
80003a66:	2f fd       	sub	sp,-4
80003a68:	e3 cd 80 80 	ldm	sp++,r7,pc
80003a6c:	80 00       	ld.sh	r0,r0[0x0]
80003a6e:	8e d0       	ld.uh	r0,r7[0xa]

80003a70 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80003a70:	d4 01       	pushm	lr
80003a72:	20 1d       	sub	sp,4
80003a74:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80003a76:	98 88       	ld.uh	r8,r12[0x0]
80003a78:	e2 18 f0 00 	andl	r8,0xf000,COH
80003a7c:	e0 48 40 00 	cp.w	r8,16384
80003a80:	c0 d1       	brne	80003a9a <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80003a82:	49 08       	lddpc	r8,80003ac0 <phy_tx+0x50>
80003a84:	70 08       	ld.w	r8,r8[0x0]
80003a86:	58 08       	cp.w	r8,0
80003a88:	c1 a0       	breq	80003abc <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80003a8a:	48 e8       	lddpc	r8,80003ac0 <phy_tx+0x50>
80003a8c:	70 0c       	ld.w	r12,r8[0x0]
80003a8e:	30 09       	mov	r9,0
80003a90:	12 9a       	mov	r10,r9
80003a92:	1a 9b       	mov	r11,sp
80003a94:	f0 1f 00 0c 	mcall	80003ac4 <phy_tx+0x54>
80003a98:	c1 28       	rjmp	80003abc <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80003a9a:	e0 48 10 00 	cp.w	r8,4096
80003a9e:	5f 0a       	sreq	r10
80003aa0:	e0 48 20 00 	cp.w	r8,8192
80003aa4:	5f 09       	sreq	r9
80003aa6:	f5 e9 10 09 	or	r9,r10,r9
80003aaa:	c0 71       	brne	80003ab8 <phy_tx+0x48>
80003aac:	e0 48 50 00 	cp.w	r8,20480
80003ab0:	c0 40       	breq	80003ab8 <phy_tx+0x48>
80003ab2:	e0 48 60 00 	cp.w	r8,24576
80003ab6:	c0 31       	brne	80003abc <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80003ab8:	48 48       	lddpc	r8,80003ac8 <phy_tx+0x58>
80003aba:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80003abc:	2f fd       	sub	sp,-4
80003abe:	d8 02       	popm	pc
80003ac0:	00 00       	add	r0,r0
80003ac2:	0f e0       	ld.ub	r0,r7[0x6]
80003ac4:	80 00       	ld.sh	r0,r0[0x0]
80003ac6:	8e d0       	ld.uh	r0,r7[0xa]
80003ac8:	00 00       	add	r0,r0
80003aca:	0f c4       	ld.ub	r4,r7[0x4]

80003acc <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80003acc:	d4 01       	pushm	lr
80003ace:	20 2d       	sub	sp,8
	void * ptr = NULL;
80003ad0:	30 08       	mov	r8,0
80003ad2:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003ad4:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80003ad6:	1a 9a       	mov	r10,sp
80003ad8:	fa cb ff fc 	sub	r11,sp,-4
80003adc:	f0 1f 00 05 	mcall	80003af0 <get_idle_store_isr+0x24>
80003ae0:	58 1c       	cp.w	r12,1
80003ae2:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003ae6:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80003aea:	2f ed       	sub	sp,-8
80003aec:	d8 02       	popm	pc
80003aee:	00 00       	add	r0,r0
80003af0:	80 00       	ld.sh	r0,r0[0x0]
80003af2:	8b d4       	st.w	r5[0x34],r4

80003af4 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80003af4:	eb cd 40 c0 	pushm	r6-r7,lr
80003af8:	20 1d       	sub	sp,4
80003afa:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80003afc:	fe f8 05 54 	ld.w	r8,pc[1364]
80003b00:	70 08       	ld.w	r8,r8[0x0]
80003b02:	58 08       	cp.w	r8,0
80003b04:	c7 40       	breq	80003bec <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80003b06:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003b08:	30 08       	mov	r8,0
80003b0a:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80003b0c:	fe f8 05 48 	ld.w	r8,pc[1352]
80003b10:	70 08       	ld.w	r8,r8[0x0]
80003b12:	58 18       	cp.w	r8,1
80003b14:	c2 90       	breq	80003b66 <phy_tx_func+0x72>
80003b16:	c0 43       	brcs	80003b1e <phy_tx_func+0x2a>
80003b18:	58 28       	cp.w	r8,2
80003b1a:	c6 91       	brne	80003bec <phy_tx_func+0xf8>
80003b1c:	c6 18       	rjmp	80003bde <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80003b1e:	fe f8 05 32 	ld.w	r8,pc[1330]
80003b22:	70 0c       	ld.w	r12,r8[0x0]
80003b24:	1a 9a       	mov	r10,sp
80003b26:	fe fb 05 32 	ld.w	r11,pc[1330]
80003b2a:	f0 1f 01 4d 	mcall	8000405c <phy_tx_func+0x568>
80003b2e:	58 1c       	cp.w	r12,1
80003b30:	c1 51       	brne	80003b5a <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80003b32:	fe f8 05 26 	ld.w	r8,pc[1318]
80003b36:	70 08       	ld.w	r8,r8[0x0]
80003b38:	11 9a       	ld.ub	r10,r8[0x1]
80003b3a:	fe f9 05 26 	ld.w	r9,pc[1318]
80003b3e:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80003b40:	90 88       	ld.uh	r8,r8[0x0]
80003b42:	ea 18 ab cd 	orh	r8,0xabcd
80003b46:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80003b48:	30 19       	mov	r9,1
80003b4a:	fe f8 05 1a 	ld.w	r8,pc[1306]
80003b4e:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80003b50:	30 19       	mov	r9,1
80003b52:	fe f8 05 02 	ld.w	r8,pc[1282]
80003b56:	91 09       	st.w	r8[0x0],r9
80003b58:	c4 a8       	rjmp	80003bec <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80003b5a:	e0 68 5a 5a 	mov	r8,23130
80003b5e:	ea 18 ab cd 	orh	r8,0xabcd
80003b62:	8f 18       	st.w	r7[0x4],r8
80003b64:	c4 48       	rjmp	80003bec <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003b66:	fe f9 04 fe 	ld.w	r9,pc[1278]
80003b6a:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80003b6c:	fe fa 04 ec 	ld.w	r10,pc[1260]
80003b70:	74 0a       	ld.w	r10,r10[0x0]
80003b72:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80003b76:	b1 6a       	lsl	r10,0x10
80003b78:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003b7a:	2f f8       	sub	r8,-1
80003b7c:	5c 58       	castu.b	r8
80003b7e:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003b80:	fe fa 04 e0 	ld.w	r10,pc[1248]
80003b84:	94 09       	ld.sh	r9,r10[0x0]
80003b86:	20 29       	sub	r9,2
80003b88:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003b8a:	30 0a       	mov	r10,0
80003b8c:	f4 09 19 00 	cp.h	r9,r10
80003b90:	e0 89 00 0b 	brgt	80003ba6 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80003b94:	78 18       	ld.w	r8,r12[0x4]
80003b96:	e8 18 00 ba 	orl	r8,0xba
80003b9a:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80003b9c:	30 09       	mov	r9,0
80003b9e:	fe f8 04 b6 	ld.w	r8,pc[1206]
80003ba2:	91 09       	st.w	r8[0x0],r9
80003ba4:	c2 48       	rjmp	80003bec <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80003ba6:	fe f9 04 b2 	ld.w	r9,pc[1202]
80003baa:	72 09       	ld.w	r9,r9[0x0]
80003bac:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80003bb0:	78 1a       	ld.w	r10,r12[0x4]
80003bb2:	f5 e9 10 09 	or	r9,r10,r9
80003bb6:	99 19       	st.w	r12[0x4],r9
80003bb8:	2f f8       	sub	r8,-1
80003bba:	fe f9 04 aa 	ld.w	r9,pc[1194]
80003bbe:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003bc0:	fe f9 04 a0 	ld.w	r9,pc[1184]
80003bc4:	92 08       	ld.sh	r8,r9[0x0]
80003bc6:	20 28       	sub	r8,2
80003bc8:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003bca:	30 09       	mov	r9,0
80003bcc:	f2 08 19 00 	cp.h	r8,r9
80003bd0:	e0 89 00 0e 	brgt	80003bec <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80003bd4:	30 29       	mov	r9,2
80003bd6:	fe f8 04 7e 	ld.w	r8,pc[1150]
80003bda:	91 09       	st.w	r8[0x0],r9
80003bdc:	c0 88       	rjmp	80003bec <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80003bde:	fc 18 00 ba 	movh	r8,0xba
80003be2:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003be4:	30 09       	mov	r9,0
80003be6:	fe f8 04 6e 	ld.w	r8,pc[1134]
80003bea:	91 09       	st.w	r8[0x0],r9
	static U32 i = 0;
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if (AMBE_flag)
80003bec:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003bf0:	11 89       	ld.ub	r9,r8[0x0]
80003bf2:	30 08       	mov	r8,0
80003bf4:	f0 09 18 00 	cp.b	r9,r8
80003bf8:	e0 80 00 c6 	breq	80003d84 <phy_tx_func+0x290>
	{

	  //AMBE_flag
		switch(payload_tx_state)
80003bfc:	fe f8 04 70 	ld.w	r8,pc[1136]
80003c00:	11 88       	ld.ub	r8,r8[0x0]
80003c02:	30 19       	mov	r9,1
80003c04:	f2 08 18 00 	cp.b	r8,r9
80003c08:	c3 e0       	breq	80003c84 <phy_tx_func+0x190>
80003c0a:	c0 73       	brcs	80003c18 <phy_tx_func+0x124>
80003c0c:	30 29       	mov	r9,2
80003c0e:	f2 08 18 00 	cp.b	r8,r9
80003c12:	e0 81 02 1b 	brne	80004048 <phy_tx_func+0x554>
80003c16:	c9 28       	rjmp	80003d3a <phy_tx_func+0x246>
		{
			case 0:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80003c18:	fe f8 04 58 	ld.w	r8,pc[1112]
80003c1c:	70 08       	ld.w	r8,r8[0x0]
80003c1e:	58 08       	cp.w	r8,0
80003c20:	c0 b0       	breq	80003c36 <phy_tx_func+0x142>
80003c22:	fe f8 04 4e 	ld.w	r8,pc[1102]
80003c26:	70 08       	ld.w	r8,r8[0x0]
80003c28:	58 98       	cp.w	r8,9
80003c2a:	c0 60       	breq	80003c36 <phy_tx_func+0x142>
80003c2c:	fe f8 04 44 	ld.w	r8,pc[1092]
80003c30:	70 08       	ld.w	r8,r8[0x0]
80003c32:	58 18       	cp.w	r8,1
80003c34:	c0 a1       	brne	80003c48 <phy_tx_func+0x154>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003c36:	e0 68 5a 5a 	mov	r8,23130
80003c3a:	ea 18 ab cd 	orh	r8,0xabcd
80003c3e:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003c40:	30 08       	mov	r8,0
80003c42:	8f 38       	st.w	r7[0xc],r8
80003c44:	e0 8f 02 02 	bral	80004048 <phy_tx_func+0x554>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80003c48:	fe f8 04 28 	ld.w	r8,pc[1064]
80003c4c:	70 08       	ld.w	r8,r8[0x0]
80003c4e:	58 28       	cp.w	r8,2
80003c50:	c0 91       	brne	80003c62 <phy_tx_func+0x16e>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80003c52:	fe f8 04 22 	ld.w	r8,pc[1058]
80003c56:	70 09       	ld.w	r9,r8[0x0]
80003c58:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80003c5a:	70 18       	ld.w	r8,r8[0x4]
80003c5c:	8f 38       	st.w	r7[0xc],r8
80003c5e:	e0 8f 01 f5 	bral	80004048 <phy_tx_func+0x554>
				}
				else
				{
					payload_tx_state = 1;
80003c62:	30 19       	mov	r9,1
80003c64:	fe f8 04 08 	ld.w	r8,pc[1032]
80003c68:	b0 89       	st.b	r8[0x0],r9
					
					//0xABCDCOOE
					payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80003c6a:	e0 68 c0 0e 	mov	r8,49166
80003c6e:	ea 18 ab cd 	orh	r8,0xabcd
80003c72:	8f 28       	st.w	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[2] = VBSP_data[0];
80003c74:	fe f8 04 04 	ld.w	r8,pc[1028]
80003c78:	90 09       	ld.sh	r9,r8[0x0]
80003c7a:	ae 69       	st.h	r7[0xc],r9
					//0xF00x
					payload_tx_channel->word[3] = VBSP_data[1];
80003c7c:	90 18       	ld.sh	r8,r8[0x2]
80003c7e:	ae 78       	st.h	r7[0xe],r8
80003c80:	e0 8f 01 e4 	bral	80004048 <phy_tx_func+0x554>
				break;
			
			case 1:
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80003c84:	fe 78 88 f2 	mov	r8,-30478
80003c88:	ae 48       	st.h	r7[0x8],r8
			
				switch (m_RxBurstType)//
80003c8a:	fe f8 03 e6 	ld.w	r8,pc[998]
80003c8e:	70 08       	ld.w	r8,r8[0x0]
80003c90:	58 38       	cp.w	r8,3
80003c92:	c0 60       	breq	80003c9e <phy_tx_func+0x1aa>
80003c94:	c4 73       	brcs	80003d22 <phy_tx_func+0x22e>
80003c96:	58 88       	cp.w	r8,8
80003c98:	e0 8b 00 45 	brhi	80003d22 <phy_tx_func+0x22e>
80003c9c:	c2 a8       	rjmp	80003cf0 <phy_tx_func+0x1fc>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80003c9e:	fe f8 03 de 	ld.w	r8,pc[990]
80003ca2:	11 89       	ld.ub	r9,r8[0x0]
80003ca4:	30 18       	mov	r8,1
80003ca6:	f0 09 18 00 	cp.b	r9,r8
80003caa:	c0 a1       	brne	80003cbe <phy_tx_func+0x1ca>
							{	
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80003cac:	fe f8 03 d4 	ld.w	r8,pc[980]
80003cb0:	90 09       	ld.sh	r9,r8[0x0]
80003cb2:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80003cb4:	90 19       	ld.sh	r9,r8[0x2]
80003cb6:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80003cb8:	90 28       	ld.sh	r8,r8[0x4]
80003cba:	ae 78       	st.h	r7[0xe],r8
80003cbc:	c1 48       	rjmp	80003ce4 <phy_tx_func+0x1f0>
								//logFromISR("\n\r MMQ \n\r");
							}
							else//VF_SN==2/3
							{
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80003cbe:	fe f9 03 c6 	ld.w	r9,pc[966]
80003cc2:	92 0b       	ld.sh	r11,r9[0x0]
80003cc4:	fe f8 03 bc 	ld.w	r8,pc[956]
80003cc8:	90 0a       	ld.sh	r10,r8[0x0]
80003cca:	f7 ea 20 0a 	eor	r10,r11,r10
80003cce:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80003cd0:	92 1b       	ld.sh	r11,r9[0x2]
80003cd2:	90 1a       	ld.sh	r10,r8[0x2]
80003cd4:	f7 ea 20 0a 	eor	r10,r11,r10
80003cd8:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80003cda:	92 29       	ld.sh	r9,r9[0x4]
80003cdc:	90 28       	ld.sh	r8,r8[0x4]
80003cde:	f3 e8 20 08 	eor	r8,r9,r8
80003ce2:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
						
							}
					
							payload_tx_state = 2;
80003ce4:	30 29       	mov	r9,2
80003ce6:	fe f8 03 86 	ld.w	r8,pc[902]
80003cea:	b0 89       	st.b	r8[0x0],r9
80003cec:	e0 8f 01 ae 	bral	80004048 <phy_tx_func+0x554>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80003cf0:	fe f9 03 94 	ld.w	r9,pc[916]
80003cf4:	92 0b       	ld.sh	r11,r9[0x0]
80003cf6:	fe f8 03 8a 	ld.w	r8,pc[906]
80003cfa:	90 0a       	ld.sh	r10,r8[0x0]
80003cfc:	f7 ea 20 0a 	eor	r10,r11,r10
80003d00:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80003d02:	92 1b       	ld.sh	r11,r9[0x2]
80003d04:	90 1a       	ld.sh	r10,r8[0x2]
80003d06:	f7 ea 20 0a 	eor	r10,r11,r10
80003d0a:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80003d0c:	92 29       	ld.sh	r9,r9[0x4]
80003d0e:	90 28       	ld.sh	r8,r8[0x4]
80003d10:	f3 e8 20 08 	eor	r8,r9,r8
80003d14:	ae 78       	st.h	r7[0xe],r8
						
							payload_tx_state = 2;
80003d16:	30 29       	mov	r9,2
80003d18:	fe f8 03 54 	ld.w	r8,pc[852]
80003d1c:	b0 89       	st.b	r8[0x0],r9
80003d1e:	e0 8f 01 95 	bral	80004048 <phy_tx_func+0x554>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003d22:	e0 68 5a 5a 	mov	r8,23130
80003d26:	ea 18 ab cd 	orh	r8,0xabcd
80003d2a:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003d2c:	30 08       	mov	r8,0
80003d2e:	8f 38       	st.w	r7[0xc],r8
							payload_tx_state = 0;
80003d30:	fe f9 03 3c 	ld.w	r9,pc[828]
80003d34:	b2 88       	st.b	r9[0x0],r8
80003d36:	e0 8f 01 89 	bral	80004048 <phy_tx_func+0x554>
			
			case 2:
					//Encrypted AMBE data(XOR)
					//payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
				
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
80003d3a:	fe f8 03 36 	ld.w	r8,pc[822]
80003d3e:	70 08       	ld.w	r8,r8[0x0]
80003d40:	58 38       	cp.w	r8,3
80003d42:	c0 d1       	brne	80003d5c <phy_tx_func+0x268>
80003d44:	fe f8 03 38 	ld.w	r8,pc[824]
80003d48:	11 89       	ld.ub	r9,r8[0x0]
80003d4a:	30 18       	mov	r8,1
80003d4c:	f0 09 18 00 	cp.b	r9,r8
80003d50:	c0 61       	brne	80003d5c <phy_tx_func+0x268>
					{
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3])) ;
80003d52:	fe f8 03 2e 	ld.w	r8,pc[814]
80003d56:	90 38       	ld.sh	r8,r8[0x6]
80003d58:	ae 48       	st.h	r7[0x8],r8
80003d5a:	c0 a8       	rjmp	80003d6e <phy_tx_func+0x27a>
					}
					else{
					
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3]) ^ (AMBEBurst_rawdata[3])) ;
80003d5c:	fe f8 03 28 	ld.w	r8,pc[808]
80003d60:	90 39       	ld.sh	r9,r8[0x6]
80003d62:	fe f8 03 1e 	ld.w	r8,pc[798]
80003d66:	90 38       	ld.sh	r8,r8[0x6]
80003d68:	f3 e8 20 08 	eor	r8,r9,r8
80003d6c:	ae 48       	st.h	r7[0x8],r8
					
					}
					payload_tx_channel->word[1]	= 0x00BA ; 
80003d6e:	e0 68 00 ba 	mov	r8,186
80003d72:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80003d74:	30 08       	mov	r8,0
80003d76:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80003d78:	ae 78       	st.h	r7[0xe],r8
				
					payload_tx_state = 0;
80003d7a:	fe f9 02 f2 	ld.w	r9,pc[754]
80003d7e:	b2 88       	st.b	r9[0x0],r8
80003d80:	e0 8f 01 64 	bral	80004048 <phy_tx_func+0x554>

#if 1
else//Send-PCM-data40bytes/2.5ms.
{
	
	index = (index >=30240) ? 0 : index;
80003d84:	fe f8 03 04 	ld.w	r8,pc[772]
80003d88:	70 08       	ld.w	r8,r8[0x0]
80003d8a:	e0 48 76 20 	cp.w	r8,30240
80003d8e:	f9 b8 02 00 	movhs	r8,0
80003d92:	fe f9 02 f6 	ld.w	r9,pc[758]
80003d96:	93 08       	st.w	r9[0x0],r8
	
	if(is_unmute == 1)counter++;
80003d98:	fe f8 02 f4 	ld.w	r8,pc[756]
80003d9c:	11 89       	ld.ub	r9,r8[0x0]
80003d9e:	30 18       	mov	r8,1
80003da0:	f0 09 18 00 	cp.b	r9,r8
80003da4:	c0 61       	brne	80003db0 <phy_tx_func+0x2bc>
80003da6:	fe f8 02 ea 	ld.w	r8,pc[746]
80003daa:	70 09       	ld.w	r9,r8[0x0]
80003dac:	2f f9       	sub	r9,-1
80003dae:	91 09       	st.w	r8[0x0],r9
	
	switch(payload_tx_state)
80003db0:	fe f8 02 bc 	ld.w	r8,pc[700]
80003db4:	11 88       	ld.ub	r8,r8[0x0]
80003db6:	30 19       	mov	r9,1
80003db8:	f2 08 18 00 	cp.b	r8,r9
80003dbc:	c3 60       	breq	80003e28 <phy_tx_func+0x334>
80003dbe:	c0 73       	brcs	80003dcc <phy_tx_func+0x2d8>
80003dc0:	30 29       	mov	r9,2
80003dc2:	f2 08 18 00 	cp.b	r8,r9
80003dc6:	e0 81 01 3e 	brne	80004042 <phy_tx_func+0x54e>
80003dca:	c7 c8       	rjmp	80003ec2 <phy_tx_func+0x3ce>
	{
		case 0:
		
			payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003dcc:	e0 68 5a 5a 	mov	r8,23130
80003dd0:	ea 18 ab cd 	orh	r8,0xabcd
80003dd4:	8f 28       	st.w	r7[0x8],r8
			payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003dd6:	30 08       	mov	r8,0
80003dd8:	8f 38       	st.w	r7[0xc],r8
		
			if(((counter % 20 )== 0) && (counter != 0) &&(is_unmute == 1))//20*125us = 2.5ms.
80003dda:	fe f8 02 b6 	ld.w	r8,pc[694]
80003dde:	70 08       	ld.w	r8,r8[0x0]
80003de0:	e0 6b cc cd 	mov	r11,52429
80003de4:	ea 1b cc cc 	orh	r11,0xcccc
80003de8:	f0 0b 06 4a 	mulu.d	r10,r8,r11
80003dec:	f6 09 16 04 	lsr	r9,r11,0x4
80003df0:	f2 09 00 29 	add	r9,r9,r9<<0x2
80003df4:	f0 09 01 29 	sub	r9,r8,r9<<0x2
80003df8:	c1 21       	brne	80003e1c <phy_tx_func+0x328>
80003dfa:	58 08       	cp.w	r8,0
80003dfc:	c1 00       	breq	80003e1c <phy_tx_func+0x328>
80003dfe:	fe f8 02 8e 	ld.w	r8,pc[654]
80003e02:	11 89       	ld.ub	r9,r8[0x0]
80003e04:	30 18       	mov	r8,1
80003e06:	f0 09 18 00 	cp.b	r9,r8
80003e0a:	c0 91       	brne	80003e1c <phy_tx_func+0x328>
			{
				payload_tx_state = 1;
80003e0c:	10 99       	mov	r9,r8
80003e0e:	fe f8 02 5e 	ld.w	r8,pc[606]
80003e12:	b0 89       	st.b	r8[0x0],r9
				//payload_tx_state = 0;
				frame_number = 0;
80003e14:	30 09       	mov	r9,0
80003e16:	fe f8 02 7e 	ld.w	r8,pc[638]
80003e1a:	b0 89       	st.b	r8[0x0],r9
	
			}
		
			send_num++;
80003e1c:	fe f8 02 7c 	ld.w	r8,pc[636]
80003e20:	70 09       	ld.w	r9,r8[0x0]
80003e22:	2f f9       	sub	r9,-1
80003e24:	91 09       	st.w	r8[0x0],r9
80003e26:	c1 19       	rjmp	80004048 <phy_tx_func+0x554>
			break;
		
		case 1:
		
	
			payload_tx_channel->word[0] = 0xABCD; 
80003e28:	fe 78 ab cd 	mov	r8,-21555
80003e2c:	ae 48       	st.h	r7[0x8],r8
		
			if(frame_number == 0)
80003e2e:	fe f8 02 66 	ld.w	r8,pc[614]
80003e32:	11 89       	ld.ub	r9,r8[0x0]
80003e34:	30 08       	mov	r8,0
80003e36:	f0 09 18 00 	cp.b	r9,r8
80003e3a:	c1 b1       	brne	80003e70 <phy_tx_func+0x37c>
			{
				if (Silent_flag == 1)
80003e3c:	fe f8 02 60 	ld.w	r8,pc[608]
80003e40:	11 89       	ld.ub	r9,r8[0x0]
80003e42:	30 18       	mov	r8,1
80003e44:	f0 09 18 00 	cp.b	r9,r8
80003e48:	c0 91       	brne	80003e5a <phy_tx_func+0x366>
				{
					//44betes-4bytes= 40bytes
					expexted_length = 0x2C;//One Descriptor Indicator
80003e4a:	32 c9       	mov	r9,44
80003e4c:	fe f8 02 54 	ld.w	r8,pc[596]
80003e50:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102C;//44betes-4bytes= 40bytes
80003e52:	e0 68 10 2c 	mov	r8,4140
80003e56:	ae 58       	st.h	r7[0xa],r8
80003e58:	c0 88       	rjmp	80003e68 <phy_tx_func+0x374>
				}
				
				else
				{
					//first frame
					expexted_length = 0x2A;
80003e5a:	32 a9       	mov	r9,42
80003e5c:	fe f8 02 44 	ld.w	r8,pc[580]
80003e60:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102A;//42-2= 40 bytes;	
80003e62:	e0 68 10 2a 	mov	r8,4138
80003e66:	ae 58       	st.h	r7[0xa],r8
				}
				
					last_frame = TRUE;
80003e68:	30 19       	mov	r9,1
80003e6a:	fe f8 02 3a 	ld.w	r8,pc[570]
80003e6e:	b0 89       	st.b	r8[0x0],r9
			//
			//
			//}
			//else//
			
			if (Silent_flag == 1)//
80003e70:	fe f8 02 2c 	ld.w	r8,pc[556]
80003e74:	11 89       	ld.ub	r9,r8[0x0]
80003e76:	30 18       	mov	r8,1
80003e78:	f0 09 18 00 	cp.b	r9,r8
80003e7c:	c0 61       	brne	80003e88 <phy_tx_func+0x394>
			{
			
				payload_tx_channel->word[2] = 0x0001;//Array Descriptor Length
80003e7e:	30 18       	mov	r8,1
80003e80:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  0x0004;//Silent Descriptor Indicator
80003e82:	30 48       	mov	r8,4
80003e84:	ae 78       	st.h	r7[0xe],r8
80003e86:	c1 38       	rjmp	80003eac <phy_tx_func+0x3b8>

			}
			else
			{
			
				payload_tx_channel->word[2] = 0x0000;
80003e88:	30 08       	mov	r8,0
80003e8a:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003e8c:	4f f8       	lddpc	r8,80004088 <phy_tx_func+0x594>
80003e8e:	70 09       	ld.w	r9,r8[0x0]
80003e90:	fe fa 02 18 	ld.w	r10,pc[536]
80003e94:	f4 09 00 0b 	add	r11,r10,r9
80003e98:	17 9b       	ld.ub	r11,r11[0x1]
80003e9a:	f4 09 07 09 	ld.ub	r9,r10[r9]
80003e9e:	a9 69       	lsl	r9,0x8
80003ea0:	f6 09 00 09 	add	r9,r11,r9
80003ea4:	ae 79       	st.h	r7[0xe],r9
				index+=2;
80003ea6:	70 09       	ld.w	r9,r8[0x0]
80003ea8:	2f e9       	sub	r9,-2
80003eaa:	91 09       	st.w	r8[0x0],r9
			
			}
		
			expexted_length -= 4;
80003eac:	4f d8       	lddpc	r8,800040a0 <phy_tx_func+0x5ac>
80003eae:	90 09       	ld.sh	r9,r8[0x0]
80003eb0:	20 49       	sub	r9,4
80003eb2:	b0 09       	st.h	r8[0x0],r9
		
			//frame_number++;
			payload_tx_state = 2;
80003eb4:	30 29       	mov	r9,2
80003eb6:	4e e8       	lddpc	r8,8000406c <phy_tx_func+0x578>
80003eb8:	b0 89       	st.b	r8[0x0],r9
		
			i = 0;
80003eba:	30 09       	mov	r9,0
80003ebc:	4f c8       	lddpc	r8,800040ac <phy_tx_func+0x5b8>
80003ebe:	91 09       	st.w	r8[0x0],r9
80003ec0:	cc 48       	rjmp	80004048 <phy_tx_func+0x554>
		
			break;
		
		case 2:
		
			if(expexted_length <= 0)
80003ec2:	4f 88       	lddpc	r8,800040a0 <phy_tx_func+0x5ac>
80003ec4:	90 09       	ld.sh	r9,r8[0x0]
80003ec6:	30 08       	mov	r8,0
80003ec8:	f0 09 19 00 	cp.h	r9,r8
80003ecc:	e0 89 00 12 	brgt	80003ef0 <phy_tx_func+0x3fc>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80003ed0:	4f 58       	lddpc	r8,800040a4 <phy_tx_func+0x5b0>
80003ed2:	11 89       	ld.ub	r9,r8[0x0]
80003ed4:	30 08       	mov	r8,0
80003ed6:	f0 09 18 00 	cp.b	r9,r8
80003eda:	5f 09       	sreq	r9
80003edc:	4e 48       	lddpc	r8,8000406c <phy_tx_func+0x578>
80003ede:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[0] = 0x00BA;
80003ee0:	e0 68 00 ba 	mov	r8,186
80003ee4:	ae 48       	st.h	r7[0x8],r8
				payload_tx_channel->word[1] = 0x0000;
80003ee6:	30 08       	mov	r8,0
80003ee8:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
80003eea:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80003eec:	ae 78       	st.h	r7[0xe],r8
80003eee:	ca d8       	rjmp	80004048 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
80003ef0:	4e b8       	lddpc	r8,8000409c <phy_tx_func+0x5a8>
80003ef2:	11 89       	ld.ub	r9,r8[0x0]
80003ef4:	30 18       	mov	r8,1
80003ef6:	f0 09 18 00 	cp.b	r9,r8
80003efa:	c0 41       	brne	80003f02 <phy_tx_func+0x40e>
			{
				payload_tx_channel->word[0] =  0x0000;
80003efc:	30 08       	mov	r8,0
80003efe:	ae 48       	st.h	r7[0x8],r8
80003f00:	c1 08       	rjmp	80003f20 <phy_tx_func+0x42c>
			}
			else
			{
				//payload_tx_channel->word[0] = AudioData[index++] + (AudioData[index++] << 8);
				payload_tx_channel->word[0] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003f02:	4e 28       	lddpc	r8,80004088 <phy_tx_func+0x594>
80003f04:	70 09       	ld.w	r9,r8[0x0]
80003f06:	4e 9a       	lddpc	r10,800040a8 <phy_tx_func+0x5b4>
80003f08:	f4 09 00 0b 	add	r11,r10,r9
80003f0c:	17 9b       	ld.ub	r11,r11[0x1]
80003f0e:	f4 09 07 09 	ld.ub	r9,r10[r9]
80003f12:	a9 69       	lsl	r9,0x8
80003f14:	f6 09 00 09 	add	r9,r11,r9
80003f18:	ae 49       	st.h	r7[0x8],r9
				index+=2;
80003f1a:	70 09       	ld.w	r9,r8[0x0]
80003f1c:	2f e9       	sub	r9,-2
80003f1e:	91 09       	st.w	r8[0x0],r9
			
			}

			expexted_length -= 2;
80003f20:	4e 09       	lddpc	r9,800040a0 <phy_tx_func+0x5ac>
80003f22:	92 08       	ld.sh	r8,r9[0x0]
80003f24:	20 28       	sub	r8,2
80003f26:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80003f28:	30 09       	mov	r9,0
80003f2a:	f2 08 19 00 	cp.h	r8,r9
80003f2e:	e0 89 00 11 	brgt	80003f50 <phy_tx_func+0x45c>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80003f32:	4d d8       	lddpc	r8,800040a4 <phy_tx_func+0x5b0>
80003f34:	11 89       	ld.ub	r9,r8[0x0]
80003f36:	30 08       	mov	r8,0
80003f38:	f0 09 18 00 	cp.b	r9,r8
80003f3c:	5f 09       	sreq	r9
80003f3e:	4c c8       	lddpc	r8,8000406c <phy_tx_func+0x578>
80003f40:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[1] = 0x00BA;
80003f42:	e0 68 00 ba 	mov	r8,186
80003f46:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
80003f48:	30 08       	mov	r8,0
80003f4a:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80003f4c:	ae 78       	st.h	r7[0xe],r8
80003f4e:	c7 d8       	rjmp	80004048 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
80003f50:	4d 38       	lddpc	r8,8000409c <phy_tx_func+0x5a8>
80003f52:	11 89       	ld.ub	r9,r8[0x0]
80003f54:	30 18       	mov	r8,1
80003f56:	f0 09 18 00 	cp.b	r9,r8
80003f5a:	c0 41       	brne	80003f62 <phy_tx_func+0x46e>
			{
				payload_tx_channel->word[1] =  0x0000;
80003f5c:	30 08       	mov	r8,0
80003f5e:	ae 58       	st.h	r7[0xa],r8
80003f60:	c1 08       	rjmp	80003f80 <phy_tx_func+0x48c>
			}
			else
			{
			
				payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003f62:	4c a8       	lddpc	r8,80004088 <phy_tx_func+0x594>
80003f64:	70 09       	ld.w	r9,r8[0x0]
80003f66:	4d 1a       	lddpc	r10,800040a8 <phy_tx_func+0x5b4>
80003f68:	f4 09 00 0b 	add	r11,r10,r9
80003f6c:	17 9b       	ld.ub	r11,r11[0x1]
80003f6e:	f4 09 07 09 	ld.ub	r9,r10[r9]
80003f72:	a9 69       	lsl	r9,0x8
80003f74:	f6 09 00 09 	add	r9,r11,r9
80003f78:	ae 59       	st.h	r7[0xa],r9
				index+=2;
80003f7a:	70 09       	ld.w	r9,r8[0x0]
80003f7c:	2f e9       	sub	r9,-2
80003f7e:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
80003f80:	4c 89       	lddpc	r9,800040a0 <phy_tx_func+0x5ac>
80003f82:	92 08       	ld.sh	r8,r9[0x0]
80003f84:	20 28       	sub	r8,2
80003f86:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80003f88:	30 09       	mov	r9,0
80003f8a:	f2 08 19 00 	cp.h	r8,r9
80003f8e:	e0 89 00 10 	brgt	80003fae <phy_tx_func+0x4ba>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80003f92:	4c 58       	lddpc	r8,800040a4 <phy_tx_func+0x5b0>
80003f94:	11 89       	ld.ub	r9,r8[0x0]
80003f96:	30 08       	mov	r8,0
80003f98:	f0 09 18 00 	cp.b	r9,r8
80003f9c:	5f 09       	sreq	r9
80003f9e:	4b 48       	lddpc	r8,8000406c <phy_tx_func+0x578>
80003fa0:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[2] = 0x00BA;
80003fa2:	e0 68 00 ba 	mov	r8,186
80003fa6:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80003fa8:	30 08       	mov	r8,0
80003faa:	ae 78       	st.h	r7[0xe],r8
80003fac:	c4 e8       	rjmp	80004048 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
80003fae:	4b c8       	lddpc	r8,8000409c <phy_tx_func+0x5a8>
80003fb0:	11 89       	ld.ub	r9,r8[0x0]
80003fb2:	30 18       	mov	r8,1
80003fb4:	f0 09 18 00 	cp.b	r9,r8
80003fb8:	c0 41       	brne	80003fc0 <phy_tx_func+0x4cc>
			{
				payload_tx_channel->word[2] =  0x0000;
80003fba:	30 08       	mov	r8,0
80003fbc:	ae 68       	st.h	r7[0xc],r8
80003fbe:	c1 08       	rjmp	80003fde <phy_tx_func+0x4ea>
			}
			else
			{
			
				payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003fc0:	4b 28       	lddpc	r8,80004088 <phy_tx_func+0x594>
80003fc2:	70 09       	ld.w	r9,r8[0x0]
80003fc4:	4b 9a       	lddpc	r10,800040a8 <phy_tx_func+0x5b4>
80003fc6:	f4 09 00 0b 	add	r11,r10,r9
80003fca:	17 9b       	ld.ub	r11,r11[0x1]
80003fcc:	f4 09 07 09 	ld.ub	r9,r10[r9]
80003fd0:	a9 69       	lsl	r9,0x8
80003fd2:	f6 09 00 09 	add	r9,r11,r9
80003fd6:	ae 69       	st.h	r7[0xc],r9
				index+=2;
80003fd8:	70 09       	ld.w	r9,r8[0x0]
80003fda:	2f e9       	sub	r9,-2
80003fdc:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
80003fde:	4b 19       	lddpc	r9,800040a0 <phy_tx_func+0x5ac>
80003fe0:	92 08       	ld.sh	r8,r9[0x0]
80003fe2:	20 28       	sub	r8,2
80003fe4:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80003fe6:	30 09       	mov	r9,0
80003fe8:	f2 08 19 00 	cp.h	r8,r9
80003fec:	e0 89 00 0e 	brgt	80004008 <phy_tx_func+0x514>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80003ff0:	4a d8       	lddpc	r8,800040a4 <phy_tx_func+0x5b0>
80003ff2:	11 89       	ld.ub	r9,r8[0x0]
80003ff4:	30 08       	mov	r8,0
80003ff6:	f0 09 18 00 	cp.b	r9,r8
80003ffa:	5f 09       	sreq	r9
80003ffc:	49 c8       	lddpc	r8,8000406c <phy_tx_func+0x578>
80003ffe:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[3] = 0x00BA;
80004000:	e0 68 00 ba 	mov	r8,186
80004004:	ae 78       	st.h	r7[0xe],r8
80004006:	c2 18       	rjmp	80004048 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
80004008:	4a 58       	lddpc	r8,8000409c <phy_tx_func+0x5a8>
8000400a:	11 89       	ld.ub	r9,r8[0x0]
8000400c:	30 18       	mov	r8,1
8000400e:	f0 09 18 00 	cp.b	r9,r8
80004012:	c0 41       	brne	8000401a <phy_tx_func+0x526>
			{
				payload_tx_channel->word[3] =  0x0000;
80004014:	30 08       	mov	r8,0
80004016:	ae 78       	st.h	r7[0xe],r8
80004018:	c1 08       	rjmp	80004038 <phy_tx_func+0x544>
			}
			else
			{
			
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
8000401a:	49 c8       	lddpc	r8,80004088 <phy_tx_func+0x594>
8000401c:	70 09       	ld.w	r9,r8[0x0]
8000401e:	4a 3a       	lddpc	r10,800040a8 <phy_tx_func+0x5b4>
80004020:	f4 09 00 0b 	add	r11,r10,r9
80004024:	17 9b       	ld.ub	r11,r11[0x1]
80004026:	f4 09 07 09 	ld.ub	r9,r10[r9]
8000402a:	a9 69       	lsl	r9,0x8
8000402c:	f6 09 00 09 	add	r9,r11,r9
80004030:	ae 79       	st.h	r7[0xe],r9
				index+=2;
80004032:	70 09       	ld.w	r9,r8[0x0]
80004034:	2f e9       	sub	r9,-2
80004036:	91 09       	st.w	r8[0x0],r9
			}
		
			//payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
80004038:	49 a8       	lddpc	r8,800040a0 <phy_tx_func+0x5ac>
8000403a:	90 09       	ld.sh	r9,r8[0x0]
8000403c:	20 29       	sub	r9,2
8000403e:	b0 09       	st.h	r8[0x0],r9
80004040:	c0 48       	rjmp	80004048 <phy_tx_func+0x554>
		
			break;
		
		default:
			payload_tx_state = 0;
80004042:	30 09       	mov	r9,0
80004044:	48 a8       	lddpc	r8,8000406c <phy_tx_func+0x578>
80004046:	b0 89       	st.b	r8[0x0],r9
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80004048:	2f fd       	sub	sp,-4
8000404a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000404e:	00 00       	add	r0,r0
80004050:	00 00       	add	r0,r0
80004052:	0f e0       	ld.ub	r0,r7[0x6]
80004054:	00 00       	add	r0,r0
80004056:	0f ac       	ld.ub	r12,r7[0x2]
80004058:	00 00       	add	r0,r0
8000405a:	0f 78       	ld.ub	r8,--r7
8000405c:	80 00       	ld.sh	r0,r0[0x0]
8000405e:	8b d4       	st.w	r5[0x34],r4
80004060:	00 00       	add	r0,r0
80004062:	0f ca       	ld.ub	r10,r7[0x4]
80004064:	00 00       	add	r0,r0
80004066:	0f c1       	ld.ub	r1,r7[0x4]
80004068:	00 00       	add	r0,r0
8000406a:	0a 44       	or	r4,r5
8000406c:	00 00       	add	r0,r0
8000406e:	0f c2       	ld.ub	r2,r7[0x4]
80004070:	00 00       	add	r0,r0
80004072:	0f 80       	ld.ub	r0,r7[0x0]
80004074:	00 00       	add	r0,r0
80004076:	0f b0       	ld.ub	r0,r7[0x3]
80004078:	00 00       	add	r0,r0
8000407a:	13 cc       	ld.ub	r12,r9[0x4]
8000407c:	00 00       	add	r0,r0
8000407e:	0a 4c       	or	r12,r5
80004080:	80 01       	ld.sh	r1,r0[0x0]
80004082:	06 4c       	or	r12,r3
80004084:	00 00       	add	r0,r0
80004086:	12 d4       	st.w	--r9,r4
80004088:	00 00       	add	r0,r0
8000408a:	0f a0       	ld.ub	r0,r7[0x2]
8000408c:	00 00       	add	r0,r0
8000408e:	0a 4d       	or	sp,r5
80004090:	00 00       	add	r0,r0
80004092:	0f e4       	ld.ub	r4,r7[0x6]
80004094:	00 00       	add	r0,r0
80004096:	0f c0       	ld.ub	r0,r7[0x4]
80004098:	00 00       	add	r0,r0
8000409a:	0f d8       	ld.ub	r8,r7[0x5]
8000409c:	00 00       	add	r0,r0
8000409e:	0a 54       	eor	r4,r5
800040a0:	00 00       	add	r0,r0
800040a2:	0f f0       	ld.ub	r0,r7[0x7]
800040a4:	00 00       	add	r0,r0
800040a6:	0f 88       	ld.ub	r8,r7[0x0]
800040a8:	80 01       	ld.sh	r1,r0[0x0]
800040aa:	06 a8       	st.w	r3++,r8
800040ac:	00 00       	add	r0,r0
800040ae:	0f f4       	ld.ub	r4,r7[0x7]

800040b0 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
800040b0:	d4 01       	pushm	lr
800040b2:	20 1d       	sub	sp,4
	void * ptr = NULL;
800040b4:	30 0a       	mov	r10,0
800040b6:	fa cb ff fc 	sub	r11,sp,-4
800040ba:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
800040bc:	14 99       	mov	r9,r10
800040be:	1a 9b       	mov	r11,sp
800040c0:	f0 1f 00 05 	mcall	800040d4 <get_idle_store+0x24>
800040c4:	58 1c       	cp.w	r12,1
800040c6:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
800040ca:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
800040ce:	2f fd       	sub	sp,-4
800040d0:	d8 02       	popm	pc
800040d2:	00 00       	add	r0,r0
800040d4:	80 00       	ld.sh	r0,r0[0x0]
800040d6:	8c c4       	ld.uh	r4,r6[0x8]

800040d8 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
800040d8:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
800040dc:	f0 1f 00 21 	mcall	80004160 <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
800040e0:	4a 1b       	lddpc	r11,80004164 <phy_init+0x8c>
800040e2:	4a 2c       	lddpc	r12,80004168 <phy_init+0x90>
800040e4:	f0 1f 00 22 	mcall	8000416c <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800040e8:	30 4b       	mov	r11,4
800040ea:	31 ec       	mov	r12,30
800040ec:	f0 1f 00 21 	mcall	80004170 <phy_init+0x98>
800040f0:	4a 18       	lddpc	r8,80004174 <phy_init+0x9c>
800040f2:	91 0c       	st.w	r8[0x0],r12
800040f4:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800040f6:	10 96       	mov	r6,r8
800040f8:	4a 05       	lddpc	r5,80004178 <phy_init+0xa0>
800040fa:	6c 0c       	ld.w	r12,r6[0x0]
800040fc:	ea 07 00 0b 	add	r11,r5,r7
80004100:	f0 1f 00 1f 	mcall	8000417c <phy_init+0xa4>
80004104:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004108:	e0 47 1e 00 	cp.w	r7,7680
8000410c:	cf 71       	brne	800040fa <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000410e:	30 4b       	mov	r11,4
80004110:	31 4c       	mov	r12,20
80004112:	f0 1f 00 18 	mcall	80004170 <phy_init+0x98>
80004116:	49 b8       	lddpc	r8,80004180 <phy_init+0xa8>
80004118:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000411a:	30 4b       	mov	r11,4
8000411c:	30 ac       	mov	r12,10
8000411e:	f0 1f 00 15 	mcall	80004170 <phy_init+0x98>
80004122:	49 98       	lddpc	r8,80004184 <phy_init+0xac>
80004124:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004126:	30 4b       	mov	r11,4
80004128:	30 ac       	mov	r12,10
8000412a:	f0 1f 00 12 	mcall	80004170 <phy_init+0x98>
8000412e:	49 78       	lddpc	r8,80004188 <phy_init+0xb0>
80004130:	91 0c       	st.w	r8[0x0],r12
80004132:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004134:	10 96       	mov	r6,r8
80004136:	49 65       	lddpc	r5,8000418c <phy_init+0xb4>
80004138:	6c 0c       	ld.w	r12,r6[0x0]
8000413a:	ea 07 00 0b 	add	r11,r5,r7
8000413e:	f0 1f 00 10 	mcall	8000417c <phy_init+0xa4>
80004142:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004146:	e0 47 14 00 	cp.w	r7,5120
8000414a:	cf 71       	brne	80004138 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
8000414c:	e0 6b 01 00 	mov	r11,256
80004150:	30 5c       	mov	r12,5
80004152:	f0 1f 00 08 	mcall	80004170 <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
80004156:	48 f8       	lddpc	r8,80004190 <phy_init+0xb8>
80004158:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
8000415a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000415e:	00 00       	add	r0,r0
80004160:	80 00       	ld.sh	r0,r0[0x0]
80004162:	4d 98       	lddpc	r8,800042c4 <phy_rx_func+0xd0>
80004164:	80 00       	ld.sh	r0,r0[0x0]
80004166:	3a f4       	mov	r4,-81
80004168:	80 00       	ld.sh	r0,r0[0x0]
8000416a:	41 f4       	lddsp	r4,sp[0x7c]
8000416c:	80 00       	ld.sh	r0,r0[0x0]
8000416e:	4d 84       	lddpc	r4,800042cc <phy_rx_func+0xd8>
80004170:	80 00       	ld.sh	r0,r0[0x0]
80004172:	90 28       	ld.sh	r8,r8[0x4]
80004174:	00 00       	add	r0,r0
80004176:	0f b8       	ld.ub	r8,r7[0x3]
80004178:	00 00       	add	r0,r0
8000417a:	27 d0       	sub	r0,125
8000417c:	80 00       	ld.sh	r0,r0[0x0]
8000417e:	3a 50       	mov	r0,-91
80004180:	00 00       	add	r0,r0
80004182:	0f e0       	ld.ub	r0,r7[0x6]
80004184:	00 00       	add	r0,r0
80004186:	0f cc       	ld.ub	r12,r7[0x4]
80004188:	00 00       	add	r0,r0
8000418a:	0f a8       	ld.ub	r8,r7[0x2]
8000418c:	00 00       	add	r0,r0
8000418e:	13 d0       	ld.ub	r0,r9[0x5]
80004190:	00 00       	add	r0,r0
80004192:	0f c4       	ld.ub	r4,r7[0x4]

80004194 <payload_rx>:




static void payload_rx(void * payload)
{
80004194:	d4 01       	pushm	lr
80004196:	20 2d       	sub	sp,8
80004198:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000419a:	30 08       	mov	r8,0
8000419c:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
8000419e:	48 f8       	lddpc	r8,800041d8 <payload_rx+0x44>
800041a0:	70 08       	ld.w	r8,r8[0x0]
800041a2:	58 08       	cp.w	r8,0
800041a4:	c0 71       	brne	800041b2 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
800041a6:	30 4b       	mov	r11,4
800041a8:	30 5c       	mov	r12,5
800041aa:	f0 1f 00 0d 	mcall	800041dc <payload_rx+0x48>
800041ae:	48 b8       	lddpc	r8,800041d8 <payload_rx+0x44>
800041b0:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
800041b2:	48 a8       	lddpc	r8,800041d8 <payload_rx+0x44>
800041b4:	70 0c       	ld.w	r12,r8[0x0]
800041b6:	30 09       	mov	r9,0
800041b8:	fa ca ff fc 	sub	r10,sp,-4
800041bc:	1a 9b       	mov	r11,sp
800041be:	f0 1f 00 09 	mcall	800041e0 <payload_rx+0x4c>
800041c2:	c0 91       	brne	800041d4 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
800041c4:	48 88       	lddpc	r8,800041e4 <payload_rx+0x50>
800041c6:	70 0c       	ld.w	r12,r8[0x0]
800041c8:	40 0b       	lddsp	r11,sp[0x0]
800041ca:	f0 1f 00 08 	mcall	800041e8 <payload_rx+0x54>
		logFromISR("mm");
800041ce:	48 8c       	lddpc	r12,800041ec <payload_rx+0x58>
800041d0:	f0 1f 00 08 	mcall	800041f0 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
800041d4:	2f ed       	sub	sp,-8
800041d6:	d8 02       	popm	pc
800041d8:	00 00       	add	r0,r0
800041da:	0f 8c       	ld.ub	r12,r7[0x0]
800041dc:	80 00       	ld.sh	r0,r0[0x0]
800041de:	90 28       	ld.sh	r8,r8[0x4]
800041e0:	80 00       	ld.sh	r0,r0[0x0]
800041e2:	8e 80       	ld.uh	r0,r7[0x0]
800041e4:	00 00       	add	r0,r0
800041e6:	0f a8       	ld.ub	r8,r7[0x2]
800041e8:	80 00       	ld.sh	r0,r0[0x0]
800041ea:	39 fc       	mov	r12,-97
800041ec:	80 01       	ld.sh	r1,r0[0x0]
800041ee:	8a 58       	ld.sh	r8,r5[0xa]
800041f0:	80 00       	ld.sh	r0,r0[0x0]
800041f2:	9c 4c       	ld.sh	r12,lr[0x8]

800041f4 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
800041f4:	eb cd 40 e0 	pushm	r5-r7,lr
800041f8:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
800041fa:	fe f8 09 de 	ld.w	r8,pc[2526]
800041fe:	70 08       	ld.w	r8,r8[0x0]
80004200:	58 08       	cp.w	r8,0
80004202:	e0 80 01 05 	breq	8000440c <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80004206:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80004208:	fe f8 09 d4 	ld.w	r8,pc[2516]
8000420c:	70 09       	ld.w	r9,r8[0x0]
8000420e:	2f f9       	sub	r9,-1
80004210:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80004212:	fe f8 09 ce 	ld.w	r8,pc[2510]
80004216:	70 08       	ld.w	r8,r8[0x0]
80004218:	58 18       	cp.w	r8,1
8000421a:	e0 80 00 84 	breq	80004322 <phy_rx_func+0x12e>
8000421e:	c0 73       	brcs	8000422c <phy_rx_func+0x38>
80004220:	58 28       	cp.w	r8,2
80004222:	c5 b0       	breq	800042d8 <phy_rx_func+0xe4>
80004224:	58 38       	cp.w	r8,3
80004226:	e0 81 00 f3 	brne	8000440c <phy_rx_func+0x218>
8000422a:	cd 38       	rjmp	800043d0 <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
8000422c:	e0 6a 5a 5a 	mov	r10,23130
80004230:	ea 1a ab cd 	orh	r10,0xabcd
80004234:	14 36       	cp.w	r6,r10
80004236:	e0 80 00 eb 	breq	8000440c <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
8000423a:	ec 08 16 10 	lsr	r8,r6,0x10
8000423e:	e0 48 ab cd 	cp.w	r8,43981
80004242:	e0 81 00 e5 	brne	8000440c <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80004246:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
8000424a:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000424e:	20 28       	sub	r8,2
80004250:	fe f9 09 94 	ld.w	r9,pc[2452]
80004254:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80004256:	30 09       	mov	r9,0
80004258:	f2 08 19 00 	cp.h	r8,r9
8000425c:	e0 8a 00 d8 	brle	8000440c <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
80004260:	fe f8 09 88 	ld.w	r8,pc[2440]
80004264:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
80004266:	fe f8 09 86 	ld.w	r8,pc[2438]
8000426a:	70 0c       	ld.w	r12,r8[0x0]
8000426c:	f0 1f 02 61 	mcall	80004bf0 <phy_rx_func+0x9fc>
80004270:	fe f8 09 84 	ld.w	r8,pc[2436]
80004274:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80004276:	58 0c       	cp.w	r12,0
80004278:	e0 80 00 ca 	breq	8000440c <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
8000427c:	fe f8 09 6c 	ld.w	r8,pc[2412]
80004280:	90 09       	ld.sh	r9,r8[0x0]
80004282:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80004286:	2f f9       	sub	r9,-1
80004288:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000428a:	fe fa 09 6a 	ld.w	r10,pc[2410]
8000428e:	74 0a       	ld.w	r10,r10[0x0]
80004290:	fe fb 09 4c 	ld.w	r11,pc[2380]
80004294:	76 0b       	ld.w	r11,r11[0x0]
80004296:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
8000429a:	2f f9       	sub	r9,-1
8000429c:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
8000429e:	e2 16 0f 00 	andl	r6,0xf00,COH
800042a2:	e0 46 01 00 	cp.w	r6,256
800042a6:	c0 c0       	breq	800042be <phy_rx_func+0xca>
800042a8:	e0 8b 00 05 	brhi	800042b2 <phy_rx_func+0xbe>
800042ac:	58 06       	cp.w	r6,0
800042ae:	c0 80       	breq	800042be <phy_rx_func+0xca>
800042b0:	c0 c8       	rjmp	800042c8 <phy_rx_func+0xd4>
800042b2:	e0 46 02 00 	cp.w	r6,512
800042b6:	c0 40       	breq	800042be <phy_rx_func+0xca>
800042b8:	e0 46 03 00 	cp.w	r6,768
800042bc:	c0 61       	brne	800042c8 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
800042be:	30 29       	mov	r9,2
800042c0:	fe f8 09 20 	ld.w	r8,pc[2336]
800042c4:	91 09       	st.w	r8[0x0],r9
800042c6:	ca 38       	rjmp	8000440c <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
800042c8:	fe f6 09 2c 	ld.w	r6,pc[2348]
800042cc:	6c 0c       	ld.w	r12,r6[0x0]
800042ce:	f0 1f 02 4b 	mcall	80004bf8 <phy_rx_func+0xa04>
					phy_frame_ptr = NULL;					
800042d2:	30 08       	mov	r8,0
800042d4:	8d 08       	st.w	r6[0x0],r8
800042d6:	c9 b8       	rjmp	8000440c <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
800042d8:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
800042dc:	b1 86       	lsr	r6,0x10
800042de:	14 06       	add	r6,r10
800042e0:	fe f8 09 1c 	ld.w	r8,pc[2332]
800042e4:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800042e6:	fe f8 09 02 	ld.w	r8,pc[2306]
800042ea:	90 09       	ld.sh	r9,r8[0x0]
800042ec:	fe fb 09 08 	ld.w	r11,pc[2312]
800042f0:	76 0b       	ld.w	r11,r11[0x0]
800042f2:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
800042f6:	2f f9       	sub	r9,-1
800042f8:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
800042fa:	fe f9 08 ea 	ld.w	r9,pc[2282]
800042fe:	92 08       	ld.sh	r8,r9[0x0]
80004300:	20 28       	sub	r8,2
80004302:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80004304:	30 09       	mov	r9,0
80004306:	f2 08 19 00 	cp.h	r8,r9
8000430a:	e0 8a 00 07 	brle	80004318 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
8000430e:	30 19       	mov	r9,1
80004310:	fe f8 08 d0 	ld.w	r8,pc[2256]
80004314:	91 09       	st.w	r8[0x0],r9
80004316:	c7 b8       	rjmp	8000440c <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80004318:	30 39       	mov	r9,3
8000431a:	fe f8 08 c6 	ld.w	r8,pc[2246]
8000431e:	91 09       	st.w	r8[0x0],r9
80004320:	c7 68       	rjmp	8000440c <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80004322:	ec 0a 14 10 	asr	r10,r6,0x10
80004326:	fe f8 08 d6 	ld.w	r8,pc[2262]
8000432a:	90 09       	ld.sh	r9,r8[0x0]
8000432c:	14 09       	add	r9,r10
8000432e:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80004330:	fe f9 08 b8 	ld.w	r9,pc[2232]
80004334:	92 08       	ld.sh	r8,r9[0x0]
80004336:	fe fb 08 be 	ld.w	r11,pc[2238]
8000433a:	76 0b       	ld.w	r11,r11[0x0]
8000433c:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80004340:	2f f8       	sub	r8,-1
80004342:	5c 88       	casts.h	r8
80004344:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80004346:	fe fa 08 9e 	ld.w	r10,pc[2206]
8000434a:	94 09       	ld.sh	r9,r10[0x0]
8000434c:	20 29       	sub	r9,2
8000434e:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80004350:	30 0a       	mov	r10,0
80004352:	f4 09 19 00 	cp.h	r9,r10
80004356:	e0 89 00 1f 	brgt	80004394 <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
8000435a:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
8000435e:	e0 46 00 ba 	cp.w	r6,186
80004362:	c0 d1       	brne	8000437c <phy_rx_func+0x188>
80004364:	fe f8 08 98 	ld.w	r8,pc[2200]
80004368:	90 09       	ld.sh	r9,r8[0x0]
8000436a:	f4 09 19 00 	cp.h	r9,r10
8000436e:	c0 71       	brne	8000437c <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80004370:	fe f8 08 84 	ld.w	r8,pc[2180]
80004374:	70 0c       	ld.w	r12,r8[0x0]
80004376:	f0 1f 02 23 	mcall	80004c00 <phy_rx_func+0xa0c>
8000437a:	c0 88       	rjmp	8000438a <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
8000437c:	fe f6 08 78 	ld.w	r6,pc[2168]
80004380:	6c 0c       	ld.w	r12,r6[0x0]
80004382:	f0 1f 02 1e 	mcall	80004bf8 <phy_rx_func+0xa04>
					phy_frame_ptr = NULL;
80004386:	30 08       	mov	r8,0
80004388:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
8000438a:	30 09       	mov	r9,0
8000438c:	fe f8 08 54 	ld.w	r8,pc[2132]
80004390:	91 09       	st.w	r8[0x0],r9
80004392:	c3 d8       	rjmp	8000440c <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80004394:	5c 86       	casts.h	r6
80004396:	fe f9 08 66 	ld.w	r9,pc[2150]
8000439a:	92 0a       	ld.sh	r10,r9[0x0]
8000439c:	0c 0a       	add	r10,r6
8000439e:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800043a0:	fe f9 08 54 	ld.w	r9,pc[2132]
800043a4:	72 09       	ld.w	r9,r9[0x0]
800043a6:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
800043aa:	2f f8       	sub	r8,-1
800043ac:	fe f9 08 3c 	ld.w	r9,pc[2108]
800043b0:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
800043b2:	fe f9 08 32 	ld.w	r9,pc[2098]
800043b6:	92 08       	ld.sh	r8,r9[0x0]
800043b8:	20 28       	sub	r8,2
800043ba:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
800043bc:	30 09       	mov	r9,0
800043be:	f2 08 19 00 	cp.h	r8,r9
800043c2:	e0 89 00 25 	brgt	8000440c <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
800043c6:	30 39       	mov	r9,3
800043c8:	fe f8 08 18 	ld.w	r8,pc[2072]
800043cc:	91 09       	st.w	r8[0x0],r9
800043ce:	c1 f8       	rjmp	8000440c <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
800043d0:	e6 16 00 ff 	andh	r6,0xff,COH
800043d4:	fc 19 00 ba 	movh	r9,0xba
800043d8:	12 36       	cp.w	r6,r9
800043da:	c0 e1       	brne	800043f6 <phy_rx_func+0x202>
800043dc:	fe f8 08 20 	ld.w	r8,pc[2080]
800043e0:	90 09       	ld.sh	r9,r8[0x0]
800043e2:	30 08       	mov	r8,0
800043e4:	f0 09 19 00 	cp.h	r9,r8
800043e8:	c0 71       	brne	800043f6 <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800043ea:	fe f8 08 0a 	ld.w	r8,pc[2058]
800043ee:	70 0c       	ld.w	r12,r8[0x0]
800043f0:	f0 1f 02 04 	mcall	80004c00 <phy_rx_func+0xa0c>
800043f4:	c0 88       	rjmp	80004404 <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
800043f6:	fe f6 07 fe 	ld.w	r6,pc[2046]
800043fa:	6c 0c       	ld.w	r12,r6[0x0]
800043fc:	f0 1f 01 ff 	mcall	80004bf8 <phy_rx_func+0xa04>
				phy_frame_ptr = NULL;
80004400:	30 08       	mov	r8,0
80004402:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80004404:	30 09       	mov	r9,0
80004406:	fe f8 07 da 	ld.w	r8,pc[2010]
8000440a:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
8000440c:	fe f8 07 f8 	ld.w	r8,pc[2040]
80004410:	11 89       	ld.ub	r9,r8[0x0]
80004412:	30 08       	mov	r8,0
80004414:	f0 09 18 00 	cp.b	r9,r8
80004418:	c1 31       	brne	8000443e <phy_rx_func+0x24a>
	{
		payload_ptr = get_payload_idle_isr();
8000441a:	fe f6 07 ee 	ld.w	r6,pc[2030]
8000441e:	6c 0c       	ld.w	r12,r6[0x0]
80004420:	f0 1f 01 f4 	mcall	80004bf0 <phy_rx_func+0x9fc>
80004424:	fe f8 07 e8 	ld.w	r8,pc[2024]
80004428:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
8000442a:	6c 0c       	ld.w	r12,r6[0x0]
8000442c:	f0 1f 01 f1 	mcall	80004bf0 <phy_rx_func+0x9fc>
80004430:	fe f8 07 e0 	ld.w	r8,pc[2016]
80004434:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80004436:	30 19       	mov	r9,1
80004438:	fe f8 07 cc 	ld.w	r8,pc[1996]
8000443c:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
8000443e:	fe f8 07 d6 	ld.w	r8,pc[2006]
80004442:	70 08       	ld.w	r8,r8[0x0]
80004444:	58 28       	cp.w	r8,2
80004446:	e0 80 01 72 	breq	8000472a <phy_rx_func+0x536>
8000444a:	58 38       	cp.w	r8,3
8000444c:	e0 80 02 30 	breq	800048ac <phy_rx_func+0x6b8>
80004450:	58 08       	cp.w	r8,0
80004452:	e0 81 03 c0 	brne	80004bd2 <phy_rx_func+0x9de>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80004456:	6e 28       	ld.w	r8,r7[0x8]
80004458:	e0 6a 5a 5a 	mov	r10,23130
8000445c:	ea 1a ab cd 	orh	r10,0xabcd
80004460:	14 38       	cp.w	r8,r10
80004462:	c0 71       	brne	80004470 <phy_rx_func+0x27c>
			{
				m_RxBurstType = VOICE_WATING;
80004464:	30 09       	mov	r9,0
80004466:	fe f8 07 b2 	ld.w	r8,pc[1970]
8000446a:	91 09       	st.w	r8[0x0],r9
8000446c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80004470:	10 99       	mov	r9,r8
80004472:	e0 19 00 00 	andl	r9,0x0
80004476:	fc 1a ab cd 	movh	r10,0xabcd
8000447a:	14 39       	cp.w	r9,r10
8000447c:	e0 81 03 ab 	brne	80004bd2 <phy_rx_func+0x9de>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80004480:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80004484:	fe f9 07 98 	ld.w	r9,pc[1944]
80004488:	93 08       	st.w	r9[0x0],r8
		
			if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
8000448a:	fe f8 07 82 	ld.w	r8,pc[1922]
8000448e:	70 08       	ld.w	r8,r8[0x0]
80004490:	58 08       	cp.w	r8,0
80004492:	c0 60       	breq	8000449e <phy_rx_func+0x2aa>
80004494:	fe f8 07 7c 	ld.w	r8,pc[1916]
80004498:	70 08       	ld.w	r8,r8[0x0]
8000449a:	58 08       	cp.w	r8,0
8000449c:	c1 61       	brne	800044c8 <phy_rx_func+0x2d4>
			{
				payload_ptr = get_payload_idle_isr();
8000449e:	fe f6 07 6a 	ld.w	r6,pc[1898]
800044a2:	6c 0c       	ld.w	r12,r6[0x0]
800044a4:	f0 1f 01 d3 	mcall	80004bf0 <phy_rx_func+0x9fc>
800044a8:	fe f5 07 64 	ld.w	r5,pc[1892]
800044ac:	8b 0c       	st.w	r5[0x0],r12
				AMBE_payload_ptr = get_payload_idle_isr();
800044ae:	6c 0c       	ld.w	r12,r6[0x0]
800044b0:	f0 1f 01 d0 	mcall	80004bf0 <phy_rx_func+0x9fc>
800044b4:	fe f8 07 5c 	ld.w	r8,pc[1884]
800044b8:	91 0c       	st.w	r8[0x0],r12
				
				if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
800044ba:	6a 08       	ld.w	r8,r5[0x0]
800044bc:	58 08       	cp.w	r8,0
800044be:	e0 80 03 8a 	breq	80004bd2 <phy_rx_func+0x9de>
800044c2:	58 0c       	cp.w	r12,0
800044c4:	e0 80 03 87 	breq	80004bd2 <phy_rx_func+0x9de>
			}
			
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800044c8:	6e 28       	ld.w	r8,r7[0x8]
800044ca:	e2 18 f0 00 	andl	r8,0xf000,COH
800044ce:	e0 48 c0 00 	cp.w	r8,49152
800044d2:	e0 81 00 99 	brne	80004604 <phy_rx_func+0x410>
			{
				AMBE_flag = 1;
800044d6:	30 19       	mov	r9,1
800044d8:	fe f8 07 48 	ld.w	r8,pc[1864]
800044dc:	b0 89       	st.b	r8[0x0],r9
								
				Item_ID = payload_rx_channel->byte[5];
800044de:	ef 39 00 0d 	ld.ub	r9,r7[13]
800044e2:	fe f8 07 42 	ld.w	r8,pc[1858]
800044e6:	b0 89       	st.b	r8[0x0],r9
				
				VF_SN = payload_rx_channel->byte[7];//This parameter is very important to the loop back Radio, as a reference.
800044e8:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800044ec:	fe f9 07 3c 	ld.w	r9,pc[1852]
800044f0:	b2 8c       	st.b	r9[0x0],r12
					
				//The OB know the Call begin and discard the Voice Header
				//The OB know the Call end and discard the Voice  Terminator			
				if (Item_ID == Raw_Tx_Data_HT)
800044f2:	11 89       	ld.ub	r9,r8[0x0]
800044f4:	3f 08       	mov	r8,-16
800044f6:	f0 09 18 00 	cp.b	r9,r8
800044fa:	c3 61       	brne	80004566 <phy_rx_func+0x372>
				{
					//HT_index = 0;
					//AMBE_HT[0] = payload_rx_channel->dword[0];
					//AMBE_HT[1] = payload_rx_channel->dword[1];
					//
					if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800044fc:	ef 38 00 0e 	ld.ub	r8,r7[14]
80004500:	e2 18 00 f0 	andl	r8,0xf0,COH
80004504:	59 08       	cp.w	r8,16
80004506:	c0 71       	brne	80004514 <phy_rx_func+0x320>
					{
						m_RxBurstType = VOICEHEADER;		
80004508:	30 19       	mov	r9,1
8000450a:	fe f8 07 0e 	ld.w	r8,pc[1806]
8000450e:	91 09       	st.w	r8[0x0],r9
80004510:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

					}
					else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80004514:	e0 48 00 20 	cp.w	r8,32
80004518:	c2 11       	brne	8000455a <phy_rx_func+0x366>
					{
						m_RxBurstType = VOICETERMINATOR;
8000451a:	30 99       	mov	r9,9
8000451c:	fe f8 06 fc 	ld.w	r8,pc[1788]
80004520:	91 09       	st.w	r8[0x0],r9
						//AMBE-data and PCM-data is not the same. AMBE is compressed data,
						//if there was a missing portion, a clear voice is difficult to extract the data. 
						//It must ensure that all the data received AMBE.
						
						//0
						memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80004522:	fe f6 07 0a 	ld.w	r6,pc[1802]
80004526:	6c 08       	ld.w	r8,r6[0x0]
80004528:	f0 0a 11 ff 	rsub	r10,r8,-1
8000452c:	fe f7 06 e4 	ld.w	r7,pc[1764]
80004530:	2f f8       	sub	r8,-1
80004532:	6e 0c       	ld.w	r12,r7[0x0]
80004534:	f4 ca fe 00 	sub	r10,r10,-512
80004538:	30 0b       	mov	r11,0
8000453a:	10 0c       	add	r12,r8
8000453c:	f0 1f 01 bd 	mcall	80004c30 <phy_rx_func+0xa3c>
						
						RxAMBE_IsFillingNext8 = 0;
80004540:	30 08       	mov	r8,0
80004542:	8d 08       	st.w	r6[0x0],r8
						payload_rx(AMBE_payload_ptr);
80004544:	6e 0c       	ld.w	r12,r7[0x0]
80004546:	f0 1f 01 bc 	mcall	80004c34 <phy_rx_func+0xa40>
						AMBE_payload_ptr = get_payload_idle_isr();
8000454a:	fe f8 06 be 	ld.w	r8,pc[1726]
8000454e:	70 0c       	ld.w	r12,r8[0x0]
80004550:	f0 1f 01 a8 	mcall	80004bf0 <phy_rx_func+0x9fc>
80004554:	8f 0c       	st.w	r7[0x0],r12
80004556:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						//logFromISR("\n\r QQ1 \n\r");
						
					}
					else//error voice
					{
						m_RxBurstType = VOICE_WATING;
8000455a:	30 09       	mov	r9,0
8000455c:	fe f8 06 bc 	ld.w	r8,pc[1724]
80004560:	91 09       	st.w	r8[0x0],r9
80004562:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					
					break;//WAITINGABAB.
		
						
				}
				else if (Item_ID == Vocoder_Bit_Stream_Parameter)//Vocoder Bits Stream Parameter
80004566:	fe f8 06 be 	ld.w	r8,pc[1726]
8000456a:	11 89       	ld.ub	r9,r8[0x0]
8000456c:	31 28       	mov	r8,18
8000456e:	f0 09 18 00 	cp.b	r9,r8
80004572:	c0 d1       	brne	8000458c <phy_rx_func+0x398>
				{	
						
						VBSP_data[0] = payload_rx_channel->word[2];
80004574:	8e 69       	ld.sh	r9,r7[0xc]
80004576:	fe f8 06 c2 	ld.w	r8,pc[1730]
8000457a:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[3];
8000457c:	8e 79       	ld.sh	r9,r7[0xe]
8000457e:	b0 19       	st.h	r8[0x2],r9
						m_RxBurstType = CalculateBurst(VF_SN);
80004580:	f0 1f 01 af 	mcall	80004c3c <phy_rx_func+0xa48>
80004584:	fe f8 06 94 	ld.w	r8,pc[1684]
80004588:	91 0c       	st.w	r8[0x0],r12
8000458a:	c3 78       	rjmp	800045f8 <phy_rx_func+0x404>

				}
				else if ((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
8000458c:	fe f8 06 98 	ld.w	r8,pc[1688]
80004590:	11 89       	ld.ub	r9,r8[0x0]
80004592:	30 48       	mov	r8,4
80004594:	f0 09 18 00 	cp.b	r9,r8
80004598:	c0 80       	breq	800045a8 <phy_rx_func+0x3b4>
8000459a:	fe f8 06 8a 	ld.w	r8,pc[1674]
8000459e:	11 89       	ld.ub	r9,r8[0x0]
800045a0:	30 38       	mov	r8,3
800045a2:	f0 09 18 00 	cp.b	r9,r8
800045a6:	c1 c1       	brne	800045de <phy_rx_func+0x3ea>
				{
					//break;
					m_RxBurstType = UNSUREDATA;
800045a8:	30 29       	mov	r9,2
800045aa:	fe f8 06 6e 	ld.w	r8,pc[1646]
800045ae:	91 09       	st.w	r8[0x0],r9
					AMBE_HT[0] = payload_rx_channel->dword[0];
800045b0:	6e 29       	ld.w	r9,r7[0x8]
800045b2:	fe f8 06 8e 	ld.w	r8,pc[1678]
800045b6:	91 09       	st.w	r8[0x0],r9
					AMBE_HT[1] = payload_rx_channel->dword[1];
800045b8:	6e 39       	ld.w	r9,r7[0xc]
800045ba:	91 19       	st.w	r8[0x4],r9
					
					if (RxBytesWaiting == 0x00000014)
800045bc:	fe f8 06 60 	ld.w	r8,pc[1632]
800045c0:	70 08       	ld.w	r8,r8[0x0]
800045c2:	59 48       	cp.w	r8,20
800045c4:	c0 61       	brne	800045d0 <phy_rx_func+0x3dc>
					{
						RxBytesWaiting = 0x18;//24 Reassigned
800045c6:	31 89       	mov	r9,24
800045c8:	fe f8 06 54 	ld.w	r8,pc[1620]
800045cc:	91 09       	st.w	r8[0x0],r9
800045ce:	c1 58       	rjmp	800045f8 <phy_rx_func+0x404>
						//_flag =0;
							
					}
					if (RxBytesWaiting == 0x00000010)
800045d0:	59 08       	cp.w	r8,16
800045d2:	c1 31       	brne	800045f8 <phy_rx_func+0x404>
					{
						RxBytesWaiting = 0x10;//16 Reassigned
800045d4:	31 09       	mov	r9,16
800045d6:	fe f8 06 46 	ld.w	r8,pc[1606]
800045da:	91 09       	st.w	r8[0x0],r9
800045dc:	c0 e8       	rjmp	800045f8 <phy_rx_func+0x404>
					
				}
				else
				{
					
					logFromISR("\n\r Item_ID:%x \n\r", payload_rx_channel->word[2]);
800045de:	8e e8       	ld.uh	r8,r7[0xc]
800045e0:	1a d8       	st.w	--sp,r8
800045e2:	fe fc 06 62 	ld.w	r12,pc[1634]
800045e6:	f0 1f 01 99 	mcall	80004c48 <phy_rx_func+0xa54>
					logFromISR("\n\r Axiba \n\r");
800045ea:	fe fc 06 62 	ld.w	r12,pc[1634]
800045ee:	f0 1f 01 97 	mcall	80004c48 <phy_rx_func+0xa54>
800045f2:	2f fd       	sub	sp,-4
800045f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					//Radio Internal Parameter(0x7F):
					//The OB should use the route back this item to radio without change content.
					break;
				}
				
				RxMediaState = READING_AMBE_MEDIA;//Jump
800045f8:	30 39       	mov	r9,3
800045fa:	fe f8 06 1a 	ld.w	r8,pc[1562]
800045fe:	91 09       	st.w	r8[0x0],r9
80004600:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80004604:	e0 48 10 00 	cp.w	r8,4096
80004608:	5f 19       	srne	r9
8000460a:	e0 48 20 00 	cp.w	r8,8192
8000460e:	5f 18       	srne	r8
80004610:	f3 e8 00 08 	and	r8,r9,r8
80004614:	e0 81 02 df 	brne	80004bd2 <phy_rx_func+0x9de>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_flag = 0;
80004618:	fe f9 06 08 	ld.w	r9,pc[1544]
8000461c:	b2 88       	st.b	r9[0x0],r8
				
				Item_ID = 0;//To make sure your save PCM data.
8000461e:	fe f9 06 06 	ld.w	r9,pc[1542]
80004622:	b2 88       	st.b	r9[0x0],r8
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004624:	6e 28       	ld.w	r8,r7[0x8]
80004626:	e2 18 0f 00 	andl	r8,0xf00,COH
8000462a:	58 18       	cp.w	r8,1
8000462c:	e0 8b 00 4d 	brhi	800046c6 <phy_rx_func+0x4d2>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
				if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80004630:	fe f9 05 ec 	ld.w	r9,pc[1516]
80004634:	72 08       	ld.w	r8,r9[0x0]
80004636:	20 48       	sub	r8,4
80004638:	93 08       	st.w	r9[0x0],r8
8000463a:	e0 80 02 cc 	breq	80004bd2 <phy_rx_func+0x9de>
				ArrayDiscLength = payload_rx_channel->word[2];
8000463e:	8e 68       	ld.sh	r8,r7[0xc]
80004640:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80004644:	fe f9 06 0c 	ld.w	r9,pc[1548]
80004648:	93 0a       	st.w	r9[0x0],r10
				
				switch (ArrayDiscLength){
8000464a:	30 09       	mov	r9,0
8000464c:	f2 08 19 00 	cp.h	r8,r9
80004650:	c0 70       	breq	8000465e <phy_rx_func+0x46a>
80004652:	30 19       	mov	r9,1
80004654:	f2 08 19 00 	cp.h	r8,r9
80004658:	e0 81 02 bd 	brne	80004bd2 <phy_rx_func+0x9de>
8000465c:	c2 68       	rjmp	800046a8 <phy_rx_func+0x4b4>
					case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
8000465e:	fe f8 05 f6 	ld.w	r8,pc[1526]
80004662:	70 0a       	ld.w	r10,r8[0x0]
80004664:	fe f9 05 a8 	ld.w	r9,pc[1448]
80004668:	72 09       	ld.w	r9,r9[0x0]
8000466a:	8e 7b       	ld.sh	r11,r7[0xe]
8000466c:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
80004670:	70 09       	ld.w	r9,r8[0x0]
80004672:	2f f9       	sub	r9,-1
80004674:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004676:	e0 49 00 ff 	cp.w	r9,255
8000467a:	e0 88 00 11 	brls	8000469c <phy_rx_func+0x4a8>
						{
							RxMedia_IsFillingNext16 = 0;	
8000467e:	30 09       	mov	r9,0
80004680:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);	
80004682:	fe f7 05 8a 	ld.w	r7,pc[1418]
80004686:	6e 0c       	ld.w	r12,r7[0x0]
80004688:	f0 1f 01 6b 	mcall	80004c34 <phy_rx_func+0xa40>
							payload_ptr = get_payload_idle_isr();
8000468c:	fe f8 05 7c 	ld.w	r8,pc[1404]
80004690:	70 0c       	ld.w	r12,r8[0x0]
80004692:	f0 1f 01 58 	mcall	80004bf0 <phy_rx_func+0x9fc>
80004696:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
80004698:	e0 80 02 9d 	breq	80004bd2 <phy_rx_func+0x9de>
							{
								break;
							}				
						}
							RxMediaState = READINGMEDIA;
8000469c:	30 29       	mov	r9,2
8000469e:	fe f8 05 76 	ld.w	r8,pc[1398]
800046a2:	91 09       	st.w	r8[0x0],r9
800046a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800046a8:	8e 79       	ld.sh	r9,r7[0xe]
800046aa:	30 38       	mov	r8,3
800046ac:	f0 09 19 00 	cp.h	r9,r8
800046b0:	c0 51       	brne	800046ba <phy_rx_func+0x4c6>
				
					case 1: //The next usual case.
							//In general case, add code to process single word Array descriptor.
							if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
							{
								Terminator_Flag = 1;
800046b2:	30 19       	mov	r9,1
800046b4:	fe f8 05 a4 	ld.w	r8,pc[1444]
800046b8:	b0 89       	st.b	r8[0x0],r9
							{
								//Terminator_Flag = 0;
							}
					
					
							RxMediaState = READINGMEDIA;
800046ba:	30 29       	mov	r9,2
800046bc:	fe f8 05 58 	ld.w	r8,pc[1368]
800046c0:	91 09       	st.w	r8[0x0],r9
800046c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
				}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
800046c6:	fe f8 05 56 	ld.w	r8,pc[1366]
800046ca:	70 08       	ld.w	r8,r8[0x0]
800046cc:	58 18       	cp.w	r8,1
800046ce:	e0 88 02 82 	brls	80004bd2 <phy_rx_func+0x9de>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
800046d2:	fe f8 05 82 	ld.w	r8,pc[1410]
800046d6:	70 0a       	ld.w	r10,r8[0x0]
800046d8:	fe f9 05 34 	ld.w	r9,pc[1332]
800046dc:	72 09       	ld.w	r9,r9[0x0]
800046de:	6e 3b       	ld.w	r11,r7[0xc]
800046e0:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800046e4:	70 09       	ld.w	r9,r8[0x0]
800046e6:	2f f9       	sub	r9,-1
800046e8:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800046ea:	e0 49 00 ff 	cp.w	r9,255
800046ee:	e0 88 00 11 	brls	80004710 <phy_rx_func+0x51c>
				{
					RxMedia_IsFillingNext16 = 0;
800046f2:	30 09       	mov	r9,0
800046f4:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800046f6:	fe f7 05 16 	ld.w	r7,pc[1302]
800046fa:	6e 0c       	ld.w	r12,r7[0x0]
800046fc:	f0 1f 01 4e 	mcall	80004c34 <phy_rx_func+0xa40>
								payload_ptr = get_payload_idle_isr();
80004700:	fe f8 05 08 	ld.w	r8,pc[1288]
80004704:	70 0c       	ld.w	r12,r8[0x0]
80004706:	f0 1f 01 3b 	mcall	80004bf0 <phy_rx_func+0x9fc>
8000470a:	8f 0c       	st.w	r7[0x0],r12
													if(NULL == payload_ptr)
8000470c:	e0 80 02 63 	breq	80004bd2 <phy_rx_func+0x9de>
													{
														break;
													}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80004710:	fe f9 05 0c 	ld.w	r9,pc[1292]
80004714:	72 08       	ld.w	r8,r9[0x0]
80004716:	20 28       	sub	r8,2
80004718:	93 08       	st.w	r9[0x0],r8
8000471a:	e0 80 02 5c 	breq	80004bd2 <phy_rx_func+0x9de>
				RxMediaState = READINGMEDIA;
8000471e:	30 29       	mov	r9,2
80004720:	fe f8 04 f4 	ld.w	r8,pc[1268]
80004724:	91 09       	st.w	r8[0x0],r9
80004726:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
8000472a:	fe f8 05 2a 	ld.w	r8,pc[1322]
8000472e:	70 0a       	ld.w	r10,r8[0x0]
80004730:	fe f9 04 dc 	ld.w	r9,pc[1244]
80004734:	72 09       	ld.w	r9,r9[0x0]
80004736:	8e 4b       	ld.sh	r11,r7[0x8]
80004738:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
8000473c:	70 09       	ld.w	r9,r8[0x0]
8000473e:	2f f9       	sub	r9,-1
80004740:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004742:	e0 49 00 ff 	cp.w	r9,255
80004746:	e0 88 00 16 	brls	80004772 <phy_rx_func+0x57e>
					{
							RxMedia_IsFillingNext16 = 0;
8000474a:	30 09       	mov	r9,0
8000474c:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
8000474e:	fe f6 04 be 	ld.w	r6,pc[1214]
80004752:	6c 0c       	ld.w	r12,r6[0x0]
80004754:	f0 1f 01 38 	mcall	80004c34 <phy_rx_func+0xa40>
							payload_ptr = get_payload_idle_isr();
80004758:	fe f8 04 b0 	ld.w	r8,pc[1200]
8000475c:	70 0c       	ld.w	r12,r8[0x0]
8000475e:	f0 1f 01 25 	mcall	80004bf0 <phy_rx_func+0x9fc>
80004762:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == payload_ptr)
80004764:	c0 71       	brne	80004772 <phy_rx_func+0x57e>
							{
								RxMediaState = WAITINGABAB;
80004766:	30 09       	mov	r9,0
80004768:	fe f8 04 ac 	ld.w	r8,pc[1196]
8000476c:	91 09       	st.w	r8[0x0],r9
8000476e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
					}
				if ((RxBytesWaiting -= 2) <= 0)
80004772:	fe f9 04 aa 	ld.w	r9,pc[1194]
80004776:	72 08       	ld.w	r8,r9[0x0]
80004778:	20 28       	sub	r8,2
8000477a:	93 08       	st.w	r9[0x0],r8
8000477c:	c0 71       	brne	8000478a <phy_rx_func+0x596>
				{
					RxMediaState = WAITINGABAB;
8000477e:	30 09       	mov	r9,0
80004780:	fe f8 04 94 	ld.w	r8,pc[1172]
80004784:	91 09       	st.w	r8[0x0],r9
80004786:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
8000478a:	fe f8 04 ca 	ld.w	r8,pc[1226]
8000478e:	70 0a       	ld.w	r10,r8[0x0]
80004790:	fe f9 04 7c 	ld.w	r9,pc[1148]
80004794:	72 09       	ld.w	r9,r9[0x0]
80004796:	8e 5b       	ld.sh	r11,r7[0xa]
80004798:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000479c:	70 09       	ld.w	r9,r8[0x0]
8000479e:	2f f9       	sub	r9,-1
800047a0:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800047a2:	e0 49 00 ff 	cp.w	r9,255
800047a6:	e0 88 00 16 	brls	800047d2 <phy_rx_func+0x5de>
						{
							RxMedia_IsFillingNext16 = 0;
800047aa:	30 09       	mov	r9,0
800047ac:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800047ae:	fe f6 04 5e 	ld.w	r6,pc[1118]
800047b2:	6c 0c       	ld.w	r12,r6[0x0]
800047b4:	f0 1f 01 20 	mcall	80004c34 <phy_rx_func+0xa40>
								payload_ptr = get_payload_idle_isr();
800047b8:	fe f8 04 50 	ld.w	r8,pc[1104]
800047bc:	70 0c       	ld.w	r12,r8[0x0]
800047be:	f0 1f 01 0d 	mcall	80004bf0 <phy_rx_func+0x9fc>
800047c2:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
800047c4:	c0 71       	brne	800047d2 <phy_rx_func+0x5de>
								{
									RxMediaState = WAITINGABAB;
800047c6:	30 09       	mov	r9,0
800047c8:	fe f8 04 4c 	ld.w	r8,pc[1100]
800047cc:	91 09       	st.w	r8[0x0],r9
800047ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
						}
				if ((RxBytesWaiting -= 2) <= 0){
800047d2:	fe f9 04 4a 	ld.w	r9,pc[1098]
800047d6:	72 08       	ld.w	r8,r9[0x0]
800047d8:	20 28       	sub	r8,2
800047da:	93 08       	st.w	r9[0x0],r8
800047dc:	c0 71       	brne	800047ea <phy_rx_func+0x5f6>
					RxMediaState = WAITINGABAB;
800047de:	30 09       	mov	r9,0
800047e0:	fe f8 04 34 	ld.w	r8,pc[1076]
800047e4:	91 09       	st.w	r8[0x0],r9
800047e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
800047ea:	fe f8 04 6a 	ld.w	r8,pc[1130]
800047ee:	70 0a       	ld.w	r10,r8[0x0]
800047f0:	fe f9 04 1c 	ld.w	r9,pc[1052]
800047f4:	72 09       	ld.w	r9,r9[0x0]
800047f6:	8e 6b       	ld.sh	r11,r7[0xc]
800047f8:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800047fc:	70 09       	ld.w	r9,r8[0x0]
800047fe:	2f f9       	sub	r9,-1
80004800:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004802:	e0 49 00 ff 	cp.w	r9,255
80004806:	e0 88 00 16 	brls	80004832 <phy_rx_func+0x63e>
						{
							RxMedia_IsFillingNext16 = 0;
8000480a:	30 09       	mov	r9,0
8000480c:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
8000480e:	fe f6 03 fe 	ld.w	r6,pc[1022]
80004812:	6c 0c       	ld.w	r12,r6[0x0]
80004814:	f0 1f 01 08 	mcall	80004c34 <phy_rx_func+0xa40>
									payload_ptr = get_payload_idle_isr();
80004818:	fe f8 03 f0 	ld.w	r8,pc[1008]
8000481c:	70 0c       	ld.w	r12,r8[0x0]
8000481e:	f0 1f 00 f5 	mcall	80004bf0 <phy_rx_func+0x9fc>
80004822:	8d 0c       	st.w	r6[0x0],r12
									if(NULL == payload_ptr)
80004824:	c0 71       	brne	80004832 <phy_rx_func+0x63e>
									{
										RxMediaState = WAITINGABAB;
80004826:	30 09       	mov	r9,0
80004828:	fe f8 03 ec 	ld.w	r8,pc[1004]
8000482c:	91 09       	st.w	r8[0x0],r9
8000482e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80004832:	fe f9 03 ea 	ld.w	r9,pc[1002]
80004836:	72 08       	ld.w	r8,r9[0x0]
80004838:	20 28       	sub	r8,2
8000483a:	93 08       	st.w	r9[0x0],r8
8000483c:	c0 71       	brne	8000484a <phy_rx_func+0x656>
					RxMediaState = WAITINGABAB;
8000483e:	30 09       	mov	r9,0
80004840:	fe f8 03 d4 	ld.w	r8,pc[980]
80004844:	91 09       	st.w	r8[0x0],r9
80004846:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
8000484a:	fe f8 04 0a 	ld.w	r8,pc[1034]
8000484e:	70 0a       	ld.w	r10,r8[0x0]
80004850:	fe f9 03 bc 	ld.w	r9,pc[956]
80004854:	72 09       	ld.w	r9,r9[0x0]
80004856:	8e 7b       	ld.sh	r11,r7[0xe]
80004858:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000485c:	70 09       	ld.w	r9,r8[0x0]
8000485e:	2f f9       	sub	r9,-1
80004860:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004862:	e0 49 00 ff 	cp.w	r9,255
80004866:	e0 88 00 16 	brls	80004892 <phy_rx_func+0x69e>
						{
							RxMedia_IsFillingNext16 = 0;
8000486a:	30 09       	mov	r9,0
8000486c:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
8000486e:	fe f7 03 9e 	ld.w	r7,pc[926]
80004872:	6e 0c       	ld.w	r12,r7[0x0]
80004874:	f0 1f 00 f0 	mcall	80004c34 <phy_rx_func+0xa40>
							payload_ptr = get_payload_idle_isr();
80004878:	fe f8 03 90 	ld.w	r8,pc[912]
8000487c:	70 0c       	ld.w	r12,r8[0x0]
8000487e:	f0 1f 00 dd 	mcall	80004bf0 <phy_rx_func+0x9fc>
80004882:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
80004884:	c0 71       	brne	80004892 <phy_rx_func+0x69e>
							{
								RxMediaState = WAITINGABAB;
80004886:	30 09       	mov	r9,0
80004888:	fe f8 03 8c 	ld.w	r8,pc[908]
8000488c:	91 09       	st.w	r8[0x0],r9
8000488e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80004892:	fe f9 03 8a 	ld.w	r9,pc[906]
80004896:	72 08       	ld.w	r8,r9[0x0]
80004898:	20 28       	sub	r8,2
8000489a:	93 08       	st.w	r9[0x0],r8
8000489c:	e0 81 01 9b 	brne	80004bd2 <phy_rx_func+0x9de>
					RxMediaState = WAITINGABAB;
800048a0:	30 09       	mov	r9,0
800048a2:	fe f8 03 72 	ld.w	r8,pc[882]
800048a6:	91 09       	st.w	r8[0x0],r9
800048a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			}
			break; //End of READINGMEDIA.

		case READING_AMBE_MEDIA:
			
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800048ac:	fe f8 03 78 	ld.w	r8,pc[888]
800048b0:	11 89       	ld.ub	r9,r8[0x0]
800048b2:	31 28       	mov	r8,18
800048b4:	f0 09 18 00 	cp.b	r9,r8
800048b8:	e0 81 01 32 	brne	80004b1c <phy_rx_func+0x928>
					{
						Item_ID = payload_rx_channel->byte[1];
800048bc:	ef 39 00 09 	ld.ub	r9,r7[9]
800048c0:	fe f8 03 64 	ld.w	r8,pc[868]
800048c4:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)
800048c6:	11 89       	ld.ub	r9,r8[0x0]
800048c8:	3f 28       	mov	r8,-14
800048ca:	f0 09 18 00 	cp.b	r9,r8
800048ce:	e0 81 01 22 	brne	80004b12 <phy_rx_func+0x91e>
						{
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
800048d2:	6e 29       	ld.w	r9,r7[0x8]
800048d4:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
800048d8:	fe f8 03 44 	ld.w	r8,pc[836]
800048dc:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
800048de:	8e 59       	ld.sh	r9,r7[0xa]
800048e0:	fe f8 03 7c 	ld.w	r8,pc[892]
800048e4:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
800048e6:	8e 69       	ld.sh	r9,r7[0xc]
800048e8:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
800048ea:	8e 79       	ld.sh	r9,r7[0xe]
800048ec:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
800048ee:	fe f8 03 3e 	ld.w	r8,pc[830]
800048f2:	fe f9 03 1e 	ld.w	r9,pc[798]
800048f6:	72 0a       	ld.w	r10,r9[0x0]
800048f8:	70 09       	ld.w	r9,r8[0x0]
800048fa:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800048fe:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004902:	70 09       	ld.w	r9,r8[0x0]
80004904:	2f f9       	sub	r9,-1
80004906:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004908:	e0 49 01 ff 	cp.w	r9,511
8000490c:	e0 88 00 16 	brls	80004938 <phy_rx_func+0x744>
							{
								RxAMBE_IsFillingNext8 = 0;
80004910:	30 09       	mov	r9,0
80004912:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004914:	fe f6 02 fc 	ld.w	r6,pc[764]
80004918:	6c 0c       	ld.w	r12,r6[0x0]
8000491a:	f0 1f 00 c7 	mcall	80004c34 <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
8000491e:	fe f8 02 ea 	ld.w	r8,pc[746]
80004922:	70 0c       	ld.w	r12,r8[0x0]
80004924:	f0 1f 00 b3 	mcall	80004bf0 <phy_rx_func+0x9fc>
80004928:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000492a:	c0 71       	brne	80004938 <phy_rx_func+0x744>
								{
									RxMediaState = WAITINGABAB;
8000492c:	30 09       	mov	r9,0
8000492e:	fe f8 02 e6 	ld.w	r8,pc[742]
80004932:	91 09       	st.w	r8[0x0],r9
80004934:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004938:	fe f9 02 e4 	ld.w	r9,pc[740]
8000493c:	72 08       	ld.w	r8,r9[0x0]
8000493e:	20 18       	sub	r8,1
80004940:	93 08       	st.w	r9[0x0],r8
80004942:	c0 71       	brne	80004950 <phy_rx_func+0x75c>
								RxMediaState = WAITINGABAB;
80004944:	30 09       	mov	r9,0
80004946:	fe f8 02 ce 	ld.w	r8,pc[718]
8000494a:	91 09       	st.w	r8[0x0],r9
8000494c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80004950:	fe f8 02 dc 	ld.w	r8,pc[732]
80004954:	fe f9 02 bc 	ld.w	r9,pc[700]
80004958:	72 0a       	ld.w	r10,r9[0x0]
8000495a:	70 09       	ld.w	r9,r8[0x0]
8000495c:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80004960:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004964:	70 09       	ld.w	r9,r8[0x0]
80004966:	2f f9       	sub	r9,-1
80004968:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000496a:	e0 49 01 ff 	cp.w	r9,511
8000496e:	e0 88 00 16 	brls	8000499a <phy_rx_func+0x7a6>
							{
								RxAMBE_IsFillingNext8 = 0;
80004972:	30 09       	mov	r9,0
80004974:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004976:	fe f6 02 9a 	ld.w	r6,pc[666]
8000497a:	6c 0c       	ld.w	r12,r6[0x0]
8000497c:	f0 1f 00 ae 	mcall	80004c34 <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004980:	fe f8 02 88 	ld.w	r8,pc[648]
80004984:	70 0c       	ld.w	r12,r8[0x0]
80004986:	f0 1f 00 9b 	mcall	80004bf0 <phy_rx_func+0x9fc>
8000498a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000498c:	c0 71       	brne	8000499a <phy_rx_func+0x7a6>
								{
									RxMediaState = WAITINGABAB;
8000498e:	30 09       	mov	r9,0
80004990:	fe f8 02 84 	ld.w	r8,pc[644]
80004994:	91 09       	st.w	r8[0x0],r9
80004996:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000499a:	fe f9 02 82 	ld.w	r9,pc[642]
8000499e:	72 08       	ld.w	r8,r9[0x0]
800049a0:	20 18       	sub	r8,1
800049a2:	93 08       	st.w	r9[0x0],r8
800049a4:	c0 71       	brne	800049b2 <phy_rx_func+0x7be>
								RxMediaState = WAITINGABAB;
800049a6:	30 09       	mov	r9,0
800049a8:	fe f8 02 6c 	ld.w	r8,pc[620]
800049ac:	91 09       	st.w	r8[0x0],r9
800049ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800049b2:	fe f8 02 7a 	ld.w	r8,pc[634]
800049b6:	fe f9 02 5a 	ld.w	r9,pc[602]
800049ba:	72 0a       	ld.w	r10,r9[0x0]
800049bc:	70 09       	ld.w	r9,r8[0x0]
800049be:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800049c2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800049c6:	70 09       	ld.w	r9,r8[0x0]
800049c8:	2f f9       	sub	r9,-1
800049ca:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800049cc:	e0 49 01 ff 	cp.w	r9,511
800049d0:	e0 88 00 16 	brls	800049fc <phy_rx_func+0x808>
							{
								RxAMBE_IsFillingNext8 = 0;
800049d4:	30 09       	mov	r9,0
800049d6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800049d8:	fe f6 02 38 	ld.w	r6,pc[568]
800049dc:	6c 0c       	ld.w	r12,r6[0x0]
800049de:	f0 1f 00 96 	mcall	80004c34 <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
800049e2:	fe f8 02 26 	ld.w	r8,pc[550]
800049e6:	70 0c       	ld.w	r12,r8[0x0]
800049e8:	f0 1f 00 82 	mcall	80004bf0 <phy_rx_func+0x9fc>
800049ec:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800049ee:	c0 71       	brne	800049fc <phy_rx_func+0x808>
								{
									RxMediaState = WAITINGABAB;
800049f0:	30 09       	mov	r9,0
800049f2:	fe f8 02 22 	ld.w	r8,pc[546]
800049f6:	91 09       	st.w	r8[0x0],r9
800049f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800049fc:	fe f9 02 20 	ld.w	r9,pc[544]
80004a00:	72 08       	ld.w	r8,r9[0x0]
80004a02:	20 18       	sub	r8,1
80004a04:	93 08       	st.w	r9[0x0],r8
80004a06:	c0 71       	brne	80004a14 <phy_rx_func+0x820>
								RxMediaState = WAITINGABAB;
80004a08:	30 09       	mov	r9,0
80004a0a:	fe f8 02 0a 	ld.w	r8,pc[522]
80004a0e:	91 09       	st.w	r8[0x0],r9
80004a10:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80004a14:	fe f8 02 18 	ld.w	r8,pc[536]
80004a18:	4f e9       	lddpc	r9,80004c10 <phy_rx_func+0xa1c>
80004a1a:	72 0a       	ld.w	r10,r9[0x0]
80004a1c:	70 09       	ld.w	r9,r8[0x0]
80004a1e:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80004a22:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004a26:	70 09       	ld.w	r9,r8[0x0]
80004a28:	2f f9       	sub	r9,-1
80004a2a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004a2c:	e0 49 01 ff 	cp.w	r9,511
80004a30:	e0 88 00 13 	brls	80004a56 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80004a34:	30 09       	mov	r9,0
80004a36:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004a38:	4f 66       	lddpc	r6,80004c10 <phy_rx_func+0xa1c>
80004a3a:	6c 0c       	ld.w	r12,r6[0x0]
80004a3c:	f0 1f 00 7e 	mcall	80004c34 <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004a40:	4f 28       	lddpc	r8,80004c08 <phy_rx_func+0xa14>
80004a42:	70 0c       	ld.w	r12,r8[0x0]
80004a44:	f0 1f 00 6b 	mcall	80004bf0 <phy_rx_func+0x9fc>
80004a48:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004a4a:	c0 61       	brne	80004a56 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80004a4c:	30 09       	mov	r9,0
80004a4e:	4f 28       	lddpc	r8,80004c14 <phy_rx_func+0xa20>
80004a50:	91 09       	st.w	r8[0x0],r9
80004a52:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004a56:	4f 29       	lddpc	r9,80004c1c <phy_rx_func+0xa28>
80004a58:	72 08       	ld.w	r8,r9[0x0]
80004a5a:	20 18       	sub	r8,1
80004a5c:	93 08       	st.w	r9[0x0],r8
80004a5e:	c0 61       	brne	80004a6a <phy_rx_func+0x876>
								RxMediaState = WAITINGABAB;
80004a60:	30 09       	mov	r9,0
80004a62:	4e d8       	lddpc	r8,80004c14 <phy_rx_func+0xa20>
80004a64:	91 09       	st.w	r8[0x0],r9
80004a66:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80004a6a:	4f 18       	lddpc	r8,80004c2c <phy_rx_func+0xa38>
80004a6c:	4e 99       	lddpc	r9,80004c10 <phy_rx_func+0xa1c>
80004a6e:	72 0a       	ld.w	r10,r9[0x0]
80004a70:	70 09       	ld.w	r9,r8[0x0]
80004a72:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80004a76:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004a7a:	70 09       	ld.w	r9,r8[0x0]
80004a7c:	2f f9       	sub	r9,-1
80004a7e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004a80:	e0 49 01 ff 	cp.w	r9,511
80004a84:	e0 88 00 13 	brls	80004aaa <phy_rx_func+0x8b6>
							{
								RxAMBE_IsFillingNext8 = 0;
80004a88:	30 09       	mov	r9,0
80004a8a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004a8c:	4e 16       	lddpc	r6,80004c10 <phy_rx_func+0xa1c>
80004a8e:	6c 0c       	ld.w	r12,r6[0x0]
80004a90:	f0 1f 00 69 	mcall	80004c34 <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004a94:	4d d8       	lddpc	r8,80004c08 <phy_rx_func+0xa14>
80004a96:	70 0c       	ld.w	r12,r8[0x0]
80004a98:	f0 1f 00 56 	mcall	80004bf0 <phy_rx_func+0x9fc>
80004a9c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004a9e:	c0 61       	brne	80004aaa <phy_rx_func+0x8b6>
								{
									RxMediaState = WAITINGABAB;
80004aa0:	30 09       	mov	r9,0
80004aa2:	4d d8       	lddpc	r8,80004c14 <phy_rx_func+0xa20>
80004aa4:	91 09       	st.w	r8[0x0],r9
80004aa6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004aaa:	4d d9       	lddpc	r9,80004c1c <phy_rx_func+0xa28>
80004aac:	72 08       	ld.w	r8,r9[0x0]
80004aae:	20 18       	sub	r8,1
80004ab0:	93 08       	st.w	r9[0x0],r8
80004ab2:	c0 61       	brne	80004abe <phy_rx_func+0x8ca>
								RxMediaState = WAITINGABAB;
80004ab4:	30 09       	mov	r9,0
80004ab6:	4d 88       	lddpc	r8,80004c14 <phy_rx_func+0xa20>
80004ab8:	91 09       	st.w	r8[0x0],r9
80004aba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80004abe:	4d c8       	lddpc	r8,80004c2c <phy_rx_func+0xa38>
80004ac0:	4d 49       	lddpc	r9,80004c10 <phy_rx_func+0xa1c>
80004ac2:	72 0a       	ld.w	r10,r9[0x0]
80004ac4:	70 09       	ld.w	r9,r8[0x0]
80004ac6:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80004aca:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004ace:	70 09       	ld.w	r9,r8[0x0]
80004ad0:	2f f9       	sub	r9,-1
80004ad2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004ad4:	e0 49 01 ff 	cp.w	r9,511
80004ad8:	e0 88 00 13 	brls	80004afe <phy_rx_func+0x90a>
							{
								RxAMBE_IsFillingNext8 = 0;
80004adc:	30 09       	mov	r9,0
80004ade:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004ae0:	4c c7       	lddpc	r7,80004c10 <phy_rx_func+0xa1c>
80004ae2:	6e 0c       	ld.w	r12,r7[0x0]
80004ae4:	f0 1f 00 54 	mcall	80004c34 <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004ae8:	4c 88       	lddpc	r8,80004c08 <phy_rx_func+0xa14>
80004aea:	70 0c       	ld.w	r12,r8[0x0]
80004aec:	f0 1f 00 41 	mcall	80004bf0 <phy_rx_func+0x9fc>
80004af0:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004af2:	c0 61       	brne	80004afe <phy_rx_func+0x90a>
								{
									RxMediaState = WAITINGABAB;
80004af4:	30 09       	mov	r9,0
80004af6:	4c 88       	lddpc	r8,80004c14 <phy_rx_func+0xa20>
80004af8:	91 09       	st.w	r8[0x0],r9
80004afa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004afe:	4c 89       	lddpc	r9,80004c1c <phy_rx_func+0xa28>
80004b00:	72 08       	ld.w	r8,r9[0x0]
80004b02:	20 18       	sub	r8,1
80004b04:	93 08       	st.w	r9[0x0],r8
80004b06:	c6 61       	brne	80004bd2 <phy_rx_func+0x9de>
								RxMediaState = WAITINGABAB;
80004b08:	30 09       	mov	r9,0
80004b0a:	4c 38       	lddpc	r8,80004c14 <phy_rx_func+0xa20>
80004b0c:	91 09       	st.w	r8[0x0],r9
80004b0e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80004b12:	30 09       	mov	r9,0
80004b14:	4c 08       	lddpc	r8,80004c14 <phy_rx_func+0xa20>
80004b16:	91 09       	st.w	r8[0x0],r9
80004b18:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80004b1c:	4c 28       	lddpc	r8,80004c24 <phy_rx_func+0xa30>
80004b1e:	11 89       	ld.ub	r9,r8[0x0]
80004b20:	3f 28       	mov	r8,-14
80004b22:	f0 09 18 00 	cp.b	r9,r8
80004b26:	c3 81       	brne	80004b96 <phy_rx_func+0x9a2>
					{
						
						
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80004b28:	8e 49       	ld.sh	r9,r7[0x8]
80004b2a:	4c d8       	lddpc	r8,80004c5c <phy_rx_func+0xa68>
80004b2c:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//MOTO.bitpad-bits
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80004b2e:	4c 08       	lddpc	r8,80004c2c <phy_rx_func+0xa38>
80004b30:	4b 89       	lddpc	r9,80004c10 <phy_rx_func+0xa1c>
80004b32:	72 0a       	ld.w	r10,r9[0x0]
80004b34:	70 09       	ld.w	r9,r8[0x0]
80004b36:	ef 3b 00 08 	ld.ub	r11,r7[8]
80004b3a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004b3e:	70 09       	ld.w	r9,r8[0x0]
80004b40:	2f f9       	sub	r9,-1
80004b42:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004b44:	e0 49 01 ff 	cp.w	r9,511
80004b48:	e0 88 00 13 	brls	80004b6e <phy_rx_func+0x97a>
						{
							RxAMBE_IsFillingNext8 = 0;
80004b4c:	30 09       	mov	r9,0
80004b4e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004b50:	4b 07       	lddpc	r7,80004c10 <phy_rx_func+0xa1c>
80004b52:	6e 0c       	ld.w	r12,r7[0x0]
80004b54:	f0 1f 00 38 	mcall	80004c34 <phy_rx_func+0xa40>
							AMBE_payload_ptr = get_payload_idle_isr();
80004b58:	4a c8       	lddpc	r8,80004c08 <phy_rx_func+0xa14>
80004b5a:	70 0c       	ld.w	r12,r8[0x0]
80004b5c:	f0 1f 00 25 	mcall	80004bf0 <phy_rx_func+0x9fc>
80004b60:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004b62:	c0 61       	brne	80004b6e <phy_rx_func+0x97a>
							{
								RxMediaState = WAITINGABAB;
80004b64:	30 09       	mov	r9,0
80004b66:	4a c8       	lddpc	r8,80004c14 <phy_rx_func+0xa20>
80004b68:	91 09       	st.w	r8[0x0],r9
80004b6a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004b6e:	4a c9       	lddpc	r9,80004c1c <phy_rx_func+0xa28>
80004b70:	72 08       	ld.w	r8,r9[0x0]
80004b72:	20 18       	sub	r8,1
80004b74:	93 08       	st.w	r9[0x0],r8
80004b76:	c0 61       	brne	80004b82 <phy_rx_func+0x98e>
							RxMediaState = WAITINGABAB;
80004b78:	30 09       	mov	r9,0
80004b7a:	4a 78       	lddpc	r8,80004c14 <phy_rx_func+0xa20>
80004b7c:	91 09       	st.w	r8[0x0],r9
80004b7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//AMBE Vocoder Bits Stream(bit59~63),
80004b82:	20 18       	sub	r8,1
80004b84:	4a 69       	lddpc	r9,80004c1c <phy_rx_func+0xa28>
80004b86:	93 08       	st.w	r9[0x0],r8
80004b88:	58 08       	cp.w	r8,0
80004b8a:	c2 41       	brne	80004bd2 <phy_rx_func+0x9de>
							RxMediaState = WAITINGABAB;
80004b8c:	30 09       	mov	r9,0
80004b8e:	4a 28       	lddpc	r8,80004c14 <phy_rx_func+0xa20>
80004b90:	91 09       	st.w	r8[0x0],r9
80004b92:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						*******************/
						
								
					}
					
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80004b96:	4a 48       	lddpc	r8,80004c24 <phy_rx_func+0xa30>
80004b98:	11 89       	ld.ub	r9,r8[0x0]
80004b9a:	30 48       	mov	r8,4
80004b9c:	f0 09 18 00 	cp.b	r9,r8
80004ba0:	c0 70       	breq	80004bae <phy_rx_func+0x9ba>
80004ba2:	4a 18       	lddpc	r8,80004c24 <phy_rx_func+0xa30>
80004ba4:	11 89       	ld.ub	r9,r8[0x0]
80004ba6:	30 38       	mov	r8,3
80004ba8:	f0 09 18 00 	cp.b	r9,r8
80004bac:	c1 01       	brne	80004bcc <phy_rx_func+0x9d8>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80004bae:	6e 29       	ld.w	r9,r7[0x8]
80004bb0:	4a 48       	lddpc	r8,80004c40 <phy_rx_func+0xa4c>
80004bb2:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80004bb4:	6e 39       	ld.w	r9,r7[0xc]
80004bb6:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80004bb8:	49 99       	lddpc	r9,80004c1c <phy_rx_func+0xa28>
80004bba:	72 08       	ld.w	r8,r9[0x0]
80004bbc:	20 88       	sub	r8,8
80004bbe:	93 08       	st.w	r9[0x0],r8
80004bc0:	c0 91       	brne	80004bd2 <phy_rx_func+0x9de>
						{
					
							RxBytesWaiting = 0;
80004bc2:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80004bc4:	49 49       	lddpc	r9,80004c14 <phy_rx_func+0xa20>
80004bc6:	93 08       	st.w	r9[0x0],r8
80004bc8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					//}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80004bcc:	30 09       	mov	r9,0
80004bce:	49 28       	lddpc	r8,80004c14 <phy_rx_func+0xa20>
80004bd0:	91 09       	st.w	r8[0x0],r9
80004bd2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004bd6:	00 00       	add	r0,r0
80004bd8:	00 00       	add	r0,r0
80004bda:	0f cc       	ld.ub	r12,r7[0x4]
80004bdc:	00 00       	add	r0,r0
80004bde:	0f e8       	ld.ub	r8,r7[0x6]
80004be0:	00 00       	add	r0,r0
80004be2:	0f bc       	ld.ub	r12,r7[0x3]
80004be4:	00 00       	add	r0,r0
80004be6:	0f a4       	ld.ub	r4,r7[0x2]
80004be8:	00 00       	add	r0,r0
80004bea:	0f 9a       	ld.ub	r10,r7[0x1]
80004bec:	00 00       	add	r0,r0
80004bee:	0f b8       	ld.ub	r8,r7[0x3]
80004bf0:	80 00       	ld.sh	r0,r0[0x0]
80004bf2:	3a cc       	mov	r12,-84
80004bf4:	00 00       	add	r0,r0
80004bf6:	0f ec       	ld.ub	r12,r7[0x6]
80004bf8:	80 00       	ld.sh	r0,r0[0x0]
80004bfa:	8b 54       	st.w	r5[0x14],r4
80004bfc:	00 00       	add	r0,r0
80004bfe:	0f c8       	ld.ub	r8,r7[0x4]
80004c00:	80 00       	ld.sh	r0,r0[0x0]
80004c02:	3a 18       	mov	r8,-95
80004c04:	00 00       	add	r0,r0
80004c06:	0f d0       	ld.ub	r0,r7[0x5]
80004c08:	00 00       	add	r0,r0
80004c0a:	0f a8       	ld.ub	r8,r7[0x2]
80004c0c:	00 00       	add	r0,r0
80004c0e:	0f 84       	ld.ub	r4,r7[0x0]
80004c10:	00 00       	add	r0,r0
80004c12:	0f 7c       	ld.ub	r12,--r7
80004c14:	00 00       	add	r0,r0
80004c16:	0f dc       	ld.ub	r12,r7[0x5]
80004c18:	00 00       	add	r0,r0
80004c1a:	0f 80       	ld.ub	r0,r7[0x0]
80004c1c:	00 00       	add	r0,r0
80004c1e:	0f 94       	ld.ub	r4,r7[0x1]
80004c20:	00 00       	add	r0,r0
80004c22:	0a 44       	or	r4,r5
80004c24:	00 00       	add	r0,r0
80004c26:	0f 98       	ld.ub	r8,r7[0x1]
80004c28:	00 00       	add	r0,r0
80004c2a:	0a 4c       	or	r12,r5
80004c2c:	00 00       	add	r0,r0
80004c2e:	0f 90       	ld.ub	r0,r7[0x1]
80004c30:	80 00       	ld.sh	r0,r0[0x0]
80004c32:	a5 ce       	cbr	lr,0x4
80004c34:	80 00       	ld.sh	r0,r0[0x0]
80004c36:	41 94       	lddsp	r4,sp[0x64]
80004c38:	00 00       	add	r0,r0
80004c3a:	13 cc       	ld.ub	r12,r9[0x4]
80004c3c:	80 00       	ld.sh	r0,r0[0x0]
80004c3e:	39 5c       	mov	r12,-107
80004c40:	00 00       	add	r0,r0
80004c42:	0f b0       	ld.ub	r0,r7[0x3]
80004c44:	80 01       	ld.sh	r1,r0[0x0]
80004c46:	8a 5c       	ld.sh	r12,r5[0xa]
80004c48:	80 00       	ld.sh	r0,r0[0x0]
80004c4a:	9c 4c       	ld.sh	r12,lr[0x8]
80004c4c:	80 01       	ld.sh	r1,r0[0x0]
80004c4e:	8a 70       	ld.sh	r0,r5[0xe]
80004c50:	00 00       	add	r0,r0
80004c52:	0f 9c       	ld.ub	r12,r7[0x1]
80004c54:	00 00       	add	r0,r0
80004c56:	0f d4       	ld.ub	r4,r7[0x5]
80004c58:	00 00       	add	r0,r0
80004c5a:	0a 55       	eor	r5,r5
80004c5c:	00 00       	add	r0,r0
80004c5e:	12 d4       	st.w	--r9,r4

80004c60 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80004c60:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80004c62:	49 88       	lddpc	r8,80004cc0 <pdca_int_handler+0x60>
80004c64:	11 89       	ld.ub	r9,r8[0x0]
80004c66:	ec 19 00 01 	eorl	r9,0x1
80004c6a:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80004c6c:	11 89       	ld.ub	r9,r8[0x0]
80004c6e:	a5 69       	lsl	r9,0x4
80004c70:	2f c9       	sub	r9,-4
80004c72:	49 5a       	lddpc	r10,80004cc4 <pdca_int_handler+0x64>
80004c74:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80004c76:	fe 7a 00 40 	mov	r10,-65472
80004c7a:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004c7c:	30 39       	mov	r9,3
80004c7e:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80004c80:	11 8a       	ld.ub	r10,r8[0x0]
80004c82:	a5 6a       	lsl	r10,0x4
80004c84:	2f ca       	sub	r10,-4
80004c86:	49 18       	lddpc	r8,80004cc8 <pdca_int_handler+0x68>
80004c88:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80004c8a:	fe 78 00 00 	mov	r8,-65536
80004c8e:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004c90:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80004c92:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80004c94:	48 e8       	lddpc	r8,80004ccc <pdca_int_handler+0x6c>
80004c96:	70 08       	ld.w	r8,r8[0x0]
80004c98:	58 08       	cp.w	r8,0
80004c9a:	c0 70       	breq	80004ca8 <pdca_int_handler+0x48>
80004c9c:	48 99       	lddpc	r9,80004cc0 <pdca_int_handler+0x60>
80004c9e:	13 89       	ld.ub	r9,r9[0x0]
80004ca0:	a5 69       	lsl	r9,0x4
80004ca2:	48 ac       	lddpc	r12,80004cc8 <pdca_int_handler+0x68>
80004ca4:	12 0c       	add	r12,r9
80004ca6:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80004ca8:	48 a8       	lddpc	r8,80004cd0 <pdca_int_handler+0x70>
80004caa:	70 08       	ld.w	r8,r8[0x0]
80004cac:	58 08       	cp.w	r8,0
80004cae:	c0 70       	breq	80004cbc <pdca_int_handler+0x5c>
80004cb0:	48 49       	lddpc	r9,80004cc0 <pdca_int_handler+0x60>
80004cb2:	13 89       	ld.ub	r9,r9[0x0]
80004cb4:	a5 69       	lsl	r9,0x4
80004cb6:	48 4c       	lddpc	r12,80004cc4 <pdca_int_handler+0x64>
80004cb8:	12 0c       	add	r12,r9
80004cba:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80004cbc:	d4 02       	popm	lr
80004cbe:	d6 03       	rete
80004cc0:	00 00       	add	r0,r0
80004cc2:	45 d4       	lddsp	r4,sp[0x174]
80004cc4:	00 00       	add	r0,r0
80004cc6:	45 fc       	lddsp	r12,sp[0x17c]
80004cc8:	00 00       	add	r0,r0
80004cca:	45 dc       	lddsp	r12,sp[0x174]
80004ccc:	00 00       	add	r0,r0
80004cce:	0f f8       	ld.ub	r8,r7[0x7]
80004cd0:	00 00       	add	r0,r0
80004cd2:	0f fc       	ld.ub	r12,r7[0x7]

80004cd4 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80004cd4:	fe 78 10 00 	mov	r8,-61440
80004cd8:	e0 69 0d c0 	mov	r9,3520
80004cdc:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80004ce0:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80004ce4:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80004ce8:	fe 78 34 00 	mov	r8,-52224
80004cec:	e0 69 80 00 	mov	r9,32768
80004cf0:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80004cf2:	30 09       	mov	r9,0
80004cf4:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80004cf6:	e0 69 04 21 	mov	r9,1057
80004cfa:	ea 19 3f 20 	orh	r9,0x3f20
80004cfe:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80004d00:	e0 69 02 9f 	mov	r9,671
80004d04:	ea 19 01 00 	orh	r9,0x100
80004d08:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80004d0a:	e0 6a 04 02 	mov	r10,1026
80004d0e:	ea 1a 3f 20 	orh	r10,0x3f20
80004d12:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80004d14:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80004d16:	5e fc       	retal	r12

80004d18 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80004d18:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80004d1a:	30 19       	mov	r9,1
80004d1c:	49 78       	lddpc	r8,80004d78 <local_start_PDC+0x60>
80004d1e:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80004d20:	fe 78 00 00 	mov	r8,-65536
80004d24:	30 7b       	mov	r11,7
80004d26:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80004d28:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80004d2a:	49 59       	lddpc	r9,80004d7c <local_start_PDC+0x64>
80004d2c:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80004d30:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80004d32:	30 3a       	mov	r10,3
80004d34:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80004d36:	30 1c       	mov	r12,1
80004d38:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80004d3a:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80004d3c:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004d3e:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004d40:	30 2c       	mov	r12,2
80004d42:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80004d44:	48 f9       	lddpc	r9,80004d80 <local_start_PDC+0x68>
80004d46:	e0 68 5a 5a 	mov	r8,23130
80004d4a:	ea 18 ab cd 	orh	r8,0xabcd
80004d4e:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80004d50:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80004d52:	30 0e       	mov	lr,0
80004d54:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80004d56:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004d58:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80004d5a:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80004d5c:	fe 78 00 40 	mov	r8,-65472
80004d60:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80004d62:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80004d64:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80004d68:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80004d6a:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80004d6c:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80004d6e:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004d70:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004d72:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004d74:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80004d76:	d8 02       	popm	pc
80004d78:	00 00       	add	r0,r0
80004d7a:	45 d4       	lddsp	r4,sp[0x174]
80004d7c:	00 00       	add	r0,r0
80004d7e:	45 dc       	lddsp	r12,sp[0x174]
80004d80:	00 00       	add	r0,r0
80004d82:	45 fc       	lddsp	r12,sp[0x17c]

80004d84 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80004d84:	48 38       	lddpc	r8,80004d90 <register_rx_tx_func+0xc>
80004d86:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80004d88:	48 38       	lddpc	r8,80004d94 <register_rx_tx_func+0x10>
80004d8a:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80004d8c:	5e fc       	retal	r12
80004d8e:	00 00       	add	r0,r0
80004d90:	00 00       	add	r0,r0
80004d92:	0f f8       	ld.ub	r8,r7[0x7]
80004d94:	00 00       	add	r0,r0
80004d96:	0f fc       	ld.ub	r12,r7[0x7]

80004d98 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80004d98:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80004d9a:	fe 78 10 00 	mov	r8,-61440
80004d9e:	30 29       	mov	r9,2
80004da0:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80004da4:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80004da8:	10 99       	mov	r9,r8
80004daa:	f2 f8 01 60 	ld.w	r8,r9[352]
80004dae:	e2 18 00 02 	andl	r8,0x2,COH
80004db2:	cf c0       	breq	80004daa <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80004db4:	fe 79 10 00 	mov	r9,-61440
80004db8:	f2 f8 01 60 	ld.w	r8,r9[352]
80004dbc:	e2 18 00 02 	andl	r8,0x2,COH
80004dc0:	cf c1       	brne	80004db8 <ssc_init+0x20>
				
    INTC_register_interrupt (
80004dc2:	30 3a       	mov	r10,3
80004dc4:	36 0b       	mov	r11,96
80004dc6:	48 bc       	lddpc	r12,80004df0 <ssc_init+0x58>
80004dc8:	f0 1f 00 0b 	mcall	80004df4 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80004dcc:	f0 1f 00 0b 	mcall	80004df8 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80004dd0:	f0 1f 00 0b 	mcall	80004dfc <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004dd4:	fe 79 00 00 	mov	r9,-65536
80004dd8:	30 18       	mov	r8,1
80004dda:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004ddc:	fe 7a 00 40 	mov	r10,-65472
80004de0:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80004de2:	e0 6b 01 01 	mov	r11,257
80004de6:	fe 7a 34 00 	mov	r10,-52224
80004dea:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80004dec:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80004dee:	d8 02       	popm	pc
80004df0:	80 00       	ld.sh	r0,r0[0x0]
80004df2:	4c 60       	lddpc	r0,80004f08 <xcmp_enter_enhanced_OB_mode+0xc>
80004df4:	80 00       	ld.sh	r0,r0[0x0]
80004df6:	59 e0       	cp.w	r0,30
80004df8:	80 00       	ld.sh	r0,r0[0x0]
80004dfa:	4c d4       	lddpc	r4,80004f2c <xcmp_DeviceInitializationStatus_request+0xc>
80004dfc:	80 00       	ld.sh	r0,r0[0x0]
80004dfe:	4d 18       	lddpc	r8,80004f40 <xcmp_DeviceInitializationStatus_request+0x20>

80004e00 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80004e00:	48 28       	lddpc	r8,80004e08 <xcmp_register_app_list+0x8>
80004e02:	91 0c       	st.w	r8[0x0],r12
}
80004e04:	5e fc       	retal	r12
80004e06:	00 00       	add	r0,r0
80004e08:	00 00       	add	r0,r0
80004e0a:	46 1c       	lddsp	r12,sp[0x184]

80004e0c <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80004e0c:	eb cd 40 80 	pushm	r7,lr
80004e10:	fa cd 01 00 	sub	sp,sp,256
80004e14:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80004e16:	16 98       	mov	r8,r11
80004e18:	2f 08       	sub	r8,-16
80004e1a:	af a8       	sbr	r8,0xe
80004e1c:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80004e1e:	3f f8       	mov	r8,-1
80004e20:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80004e22:	30 b9       	mov	r9,11
80004e24:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80004e26:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80004e28:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80004e2a:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004e2c:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80004e2e:	f6 ca ff fe 	sub	r10,r11,-2
80004e32:	18 9b       	mov	r11,r12
80004e34:	fa cc ff f0 	sub	r12,sp,-16
80004e38:	f0 1f 00 05 	mcall	80004e4c <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80004e3c:	2f e7       	sub	r7,-2
80004e3e:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80004e40:	1a 9c       	mov	r12,sp
80004e42:	f0 1f 00 04 	mcall	80004e50 <xcmp_tx+0x44>
}
80004e46:	2c 0d       	sub	sp,-256
80004e48:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e4c:	80 00       	ld.sh	r0,r0[0x0]
80004e4e:	a4 86       	st.b	r2[0x0],r6
80004e50:	80 00       	ld.sh	r0,r0[0x0]
80004e52:	52 c8       	stdsp	sp[0xb0],r8

80004e54 <xcmp_exit_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_exit_device_control_mode(void)
{
80004e54:	d4 01       	pushm	lr
80004e56:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
80004e5a:	e0 68 04 21 	mov	r8,1057
80004e5e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
80004e60:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_EXIT;
80004e64:	30 09       	mov	r9,0
80004e66:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
80004e68:	30 19       	mov	r9,1
80004e6a:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;//DCM_SPEAKER_CTRL;
80004e6c:	30 39       	mov	r9,3
80004e6e:	b0 a9       	st.b	r8[0x2],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80004e70:	30 3b       	mov	r11,3
80004e72:	fa cc ff fe 	sub	r12,sp,-2
80004e76:	f0 1f 00 03 	mcall	80004e80 <xcmp_exit_device_control_mode+0x2c>
}
80004e7a:	2c dd       	sub	sp,-204
80004e7c:	d8 02       	popm	pc
80004e7e:	00 00       	add	r0,r0
80004e80:	80 00       	ld.sh	r0,r0[0x0]
80004e82:	4e 0c       	lddpc	r12,80005000 <xcmp_init+0x34>

80004e84 <xcmp_enter_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_device_control_mode(void)
{
80004e84:	d4 01       	pushm	lr
80004e86:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
80004e8a:	e0 68 04 21 	mov	r8,1057
80004e8e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
80004e90:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_ENTER;
80004e94:	30 19       	mov	r9,1
80004e96:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
80004e98:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;// 0xEB;//user-input
80004e9a:	30 39       	mov	r9,3
80004e9c:	b0 a9       	st.b	r8[0x2],r9
	//ptr->ControlType = DCM_SPEAKER_CTRL;
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80004e9e:	30 3b       	mov	r11,3
80004ea0:	fa cc ff fe 	sub	r12,sp,-2
80004ea4:	f0 1f 00 02 	mcall	80004eac <xcmp_enter_device_control_mode+0x28>
}
80004ea8:	2c dd       	sub	sp,-204
80004eaa:	d8 02       	popm	pc
80004eac:	80 00       	ld.sh	r0,r0[0x0]
80004eae:	4e 0c       	lddpc	r12,8000502c <xcmp_rx_process+0xc>

80004eb0 <xcmp_audio_route_AMBE>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_audio_route_AMBE(void)
{
80004eb0:	d4 01       	pushm	lr
80004eb2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
80004eb6:	e0 68 04 14 	mov	r8,1044
80004eba:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
80004ebc:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = Routing_Func_Update_Source;
80004ec0:	30 19       	mov	r9,1
80004ec2:	b0 89       	st.b	r8[0x0],r9
	
	
	unsigned short NumberofRoutings = 4;//2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
80004ec4:	30 09       	mov	r9,0
80004ec6:	b0 99       	st.b	r8[0x1],r9
	ptr->NumberofRoutings[1] =  NumberofRoutings & 0xFF;
80004ec8:	30 49       	mov	r9,4
80004eca:	b0 a9       	st.b	r8[0x2],r9
	
	//ptr->RoutingData[0].audioInput = IN_Microphone;//Post_AMBE_Encoder;//IN_Pre_Speaker_Audio_Data;//IN_Microphone;//IN_Option_Board;
	//ptr->RoutingData[0].audioOutput = OUT_Option_Board;//Post_AMBE_Encoder;//OUT_Microphone_Data;//
	//
	ptr->RoutingData[0].audioInput = Post_AMBE_Encoder;//IN_Option_Board;
80004ecc:	30 fa       	mov	r10,15
80004ece:	b0 ba       	st.b	r8[0x3],r10
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004ed0:	30 c9       	mov	r9,12
80004ed2:	b0 c9       	st.b	r8[0x4],r9
	ptr->RoutingData[1].audioInput = IN_Option_Board;//IN_Option_Board;
80004ed4:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = Post_AMBE_Encoder;// OUT_Speaker;
80004ed6:	b0 ea       	st.b	r8[0x6],r10

	
	ptr->RoutingData[2].audioInput = Tx_Voice_Header;//IN_Option_Board;
80004ed8:	31 1a       	mov	r10,17
80004eda:	b0 fa       	st.b	r8[0x7],r10
	ptr->RoutingData[2].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004edc:	f1 69 00 08 	st.b	r8[8],r9
	//ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
	//ptr->RoutingData[3].audioOutput = Tx_Voice_Header;// OUT_Speaker;
	
	ptr->RoutingData[3].audioInput = Tx_Voice_Terminator;//IN_Option_Board;
80004ee0:	31 3a       	mov	r10,19
80004ee2:	f1 6a 00 09 	st.b	r8[9],r10
	ptr->RoutingData[3].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004ee6:	f1 69 00 0a 	st.b	r8[10],r9
	
	//ptr->RoutingData[1].audioInput = IN_Option_Board;
	//ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;//OUT_Speaker;//
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
80004eea:	30 bb       	mov	r11,11
80004eec:	fa cc ff fe 	sub	r12,sp,-2
80004ef0:	f0 1f 00 02 	mcall	80004ef8 <xcmp_audio_route_AMBE+0x48>
}
80004ef4:	2c dd       	sub	sp,-204
80004ef6:	d8 02       	popm	pc
80004ef8:	80 00       	ld.sh	r0,r0[0x0]
80004efa:	4e 0c       	lddpc	r12,80005078 <xcmp_rx_process+0x58>

80004efc <xcmp_enter_enhanced_OB_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_enhanced_OB_mode(void)
{
80004efc:	d4 01       	pushm	lr
80004efe:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | EN_OB_CONTROL;
80004f02:	e0 68 04 65 	mov	r8,1125
80004f06:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	En_OB_Control_req_t * ptr = (En_OB_Control_req_t *)xcmp_farme.u8;
	
	ptr->Function = EN_OB_Enter;
80004f08:	fa cc ff fe 	sub	r12,sp,-2
80004f0c:	30 18       	mov	r8,1
80004f0e:	b8 a8       	st.b	r12[0x2],r8
		
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(En_OB_Control_req_t));
80004f10:	30 1b       	mov	r11,1
80004f12:	f0 1f 00 03 	mcall	80004f1c <xcmp_enter_enhanced_OB_mode+0x20>
}
80004f16:	2c dd       	sub	sp,-204
80004f18:	d8 02       	popm	pc
80004f1a:	00 00       	add	r0,r0
80004f1c:	80 00       	ld.sh	r0,r0[0x0]
80004f1e:	4e 0c       	lddpc	r12,8000509c <xcmp_rx_process+0x7c>

80004f20 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80004f20:	d4 01       	pushm	lr
80004f22:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80004f26:	fe 78 b4 00 	mov	r8,-19456
80004f2a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004f2c:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///
	ptr->XCMPVersion[0] = 0x08;
80004f30:	30 89       	mov	r9,8
80004f32:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004f34:	30 19       	mov	r9,1
80004f36:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80004f38:	30 09       	mov	r9,0
80004f3a:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80004f3c:	30 5a       	mov	r10,5
80004f3e:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80004f40:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80004f42:	30 7a       	mov	r10,7
80004f44:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80004f46:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004f48:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80004f4a:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80004f4e:	30 9b       	mov	r11,9
80004f50:	fa cc ff fe 	sub	r12,sp,-2
80004f54:	f0 1f 00 02 	mcall	80004f5c <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004f58:	2c dd       	sub	sp,-204
80004f5a:	d8 02       	popm	pc
80004f5c:	80 00       	ld.sh	r0,r0[0x0]
80004f5e:	4e 0c       	lddpc	r12,800050dc <xcmp_rx_process+0xbc>

80004f60 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80004f60:	d4 01       	pushm	lr
80004f62:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004f66:	fe 78 80 00 	mov	r8,-32768
80004f6a:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80004f6c:	30 38       	mov	r8,3
80004f6e:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80004f70:	30 1b       	mov	r11,1
80004f72:	fa cc ff fe 	sub	r12,sp,-2
80004f76:	f0 1f 00 03 	mcall	80004f80 <xcmp_opcode_not_supported+0x20>
}
80004f7a:	2c dd       	sub	sp,-204
80004f7c:	d8 02       	popm	pc
80004f7e:	00 00       	add	r0,r0
80004f80:	80 00       	ld.sh	r0,r0[0x0]
80004f82:	4e 0c       	lddpc	r12,80005100 <xcmp_rx_process+0xe0>

80004f84 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004f84:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004f86:	96 88       	ld.uh	r8,r11[0x0]
80004f88:	e2 18 f0 00 	andl	r8,0xf000,COH
80004f8c:	e0 48 80 00 	cp.w	r8,32768
80004f90:	c0 f0       	breq	80004fae <xcmp_exec_func+0x2a>
80004f92:	e0 48 b0 00 	cp.w	r8,45056
80004f96:	c1 20       	breq	80004fba <xcmp_exec_func+0x36>
80004f98:	58 08       	cp.w	r8,0
80004f9a:	c1 51       	brne	80004fc4 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004f9c:	78 08       	ld.w	r8,r12[0x0]
80004f9e:	58 08       	cp.w	r8,0
80004fa0:	c0 40       	breq	80004fa8 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80004fa2:	16 9c       	mov	r12,r11
80004fa4:	5d 18       	icall	r8
80004fa6:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004fa8:	f0 1f 00 08 	mcall	80004fc8 <xcmp_exec_func+0x44>
80004fac:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80004fae:	78 18       	ld.w	r8,r12[0x4]
80004fb0:	58 08       	cp.w	r8,0
80004fb2:	c0 90       	breq	80004fc4 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004fb4:	16 9c       	mov	r12,r11
80004fb6:	5d 18       	icall	r8
80004fb8:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004fba:	78 28       	ld.w	r8,r12[0x8]
80004fbc:	58 08       	cp.w	r8,0
80004fbe:	c0 30       	breq	80004fc4 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004fc0:	16 9c       	mov	r12,r11
80004fc2:	5d 18       	icall	r8
80004fc4:	d8 02       	popm	pc
80004fc6:	00 00       	add	r0,r0
80004fc8:	80 00       	ld.sh	r0,r0[0x0]
80004fca:	4f 60       	lddpc	r0,800051a0 <xnl_tx_process>

80004fcc <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004fcc:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
80004fce:	f0 1f 00 0d 	mcall	80005000 <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80004fd2:	48 dc       	lddpc	r12,80005004 <xcmp_init+0x38>
80004fd4:	f0 1f 00 0d 	mcall	80005008 <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004fd8:	30 4b       	mov	r11,4
80004fda:	31 4c       	mov	r12,20
80004fdc:	f0 1f 00 0c 	mcall	8000500c <xcmp_init+0x40>
80004fe0:	48 c8       	lddpc	r8,80005010 <xcmp_init+0x44>
80004fe2:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004fe4:	30 09       	mov	r9,0
80004fe6:	1a d9       	st.w	--sp,r9
80004fe8:	1a d9       	st.w	--sp,r9
80004fea:	1a d9       	st.w	--sp,r9
80004fec:	30 38       	mov	r8,3
80004fee:	e0 6a 01 80 	mov	r10,384
80004ff2:	48 9b       	lddpc	r11,80005014 <xcmp_init+0x48>
80004ff4:	48 9c       	lddpc	r12,80005018 <xcmp_init+0x4c>
80004ff6:	f0 1f 00 0a 	mcall	8000501c <xcmp_init+0x50>
80004ffa:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
80004ffc:	d8 02       	popm	pc
80004ffe:	00 00       	add	r0,r0
80005000:	80 00       	ld.sh	r0,r0[0x0]
80005002:	53 ac       	stdsp	sp[0xe8],r12
80005004:	80 00       	ld.sh	r0,r0[0x0]
80005006:	51 1c       	stdsp	sp[0x44],r12
80005008:	80 00       	ld.sh	r0,r0[0x0]
8000500a:	51 68       	stdsp	sp[0x58],r8
8000500c:	80 00       	ld.sh	r0,r0[0x0]
8000500e:	90 28       	ld.sh	r8,r8[0x4]
80005010:	00 00       	add	r0,r0
80005012:	10 0c       	add	r12,r8
80005014:	80 01       	ld.sh	r1,r0[0x0]
80005016:	8a 7c       	ld.sh	r12,r5[0xe]
80005018:	80 00       	ld.sh	r0,r0[0x0]
8000501a:	50 20       	stdsp	sp[0x8],r0
8000501c:	80 00       	ld.sh	r0,r0[0x0]
8000501e:	96 fc       	ld.uh	r12,r11[0xe]

80005020 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80005020:	d4 31       	pushm	r0-r7,lr
80005022:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
80005024:	4b 16       	lddpc	r6,800050e8 <xcmp_rx_process+0xc8>
80005026:	30 05       	mov	r5,0
80005028:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000502a:	4b 13       	lddpc	r3,800050ec <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000502c:	4b 12       	lddpc	r2,800050f0 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000502e:	4b 21       	lddpc	r1,800050f4 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80005030:	4b 20       	lddpc	r0,800050f8 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
80005032:	6c 0c       	ld.w	r12,r6[0x0]
80005034:	0a 99       	mov	r9,r5
80005036:	08 9a       	mov	r10,r4
80005038:	1a 9b       	mov	r11,sp
8000503a:	f0 1f 00 31 	mcall	800050fc <xcmp_rx_process+0xdc>
8000503e:	58 1c       	cp.w	r12,1
80005040:	cf 91       	brne	80005032 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80005042:	40 0b       	lddsp	r11,sp[0x0]
80005044:	58 0b       	cp.w	r11,0
80005046:	cf 60       	breq	80005032 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80005048:	96 0a       	ld.sh	r10,r11[0x0]
8000504a:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000504e:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80005052:	59 c8       	cp.w	r8,28
80005054:	c1 e0       	breq	80005090 <xcmp_rx_process+0x70>
80005056:	e0 89 00 07 	brgt	80005064 <xcmp_rx_process+0x44>
8000505a:	58 e8       	cp.w	r8,14
8000505c:	c0 e0       	breq	80005078 <xcmp_rx_process+0x58>
8000505e:	58 f8       	cp.w	r8,15
80005060:	c2 41       	brne	800050a8 <xcmp_rx_process+0x88>
80005062:	c0 f8       	rjmp	80005080 <xcmp_rx_process+0x60>
80005064:	e0 48 01 09 	cp.w	r8,265
80005068:	c1 80       	breq	80005098 <xcmp_rx_process+0x78>
8000506a:	e0 48 01 0a 	cp.w	r8,266
8000506e:	c1 90       	breq	800050a0 <xcmp_rx_process+0x80>
80005070:	e0 48 00 2c 	cp.w	r8,44
80005074:	c1 a1       	brne	800050a8 <xcmp_rx_process+0x88>
80005076:	c0 98       	rjmp	80005088 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80005078:	4a 2c       	lddpc	r12,80005100 <xcmp_rx_process+0xe0>
8000507a:	f0 1f 00 23 	mcall	80005104 <xcmp_rx_process+0xe4>
					break;
8000507e:	c2 f8       	rjmp	800050dc <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80005080:	4a 2c       	lddpc	r12,80005108 <xcmp_rx_process+0xe8>
80005082:	f0 1f 00 21 	mcall	80005104 <xcmp_rx_process+0xe4>
					break;
80005086:	c2 b8       	rjmp	800050dc <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80005088:	4a 1c       	lddpc	r12,8000510c <xcmp_rx_process+0xec>
8000508a:	f0 1f 00 1f 	mcall	80005104 <xcmp_rx_process+0xe4>
					break;
8000508e:	c2 78       	rjmp	800050dc <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80005090:	04 9c       	mov	r12,r2
80005092:	f0 1f 00 1d 	mcall	80005104 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80005096:	c2 38       	rjmp	800050dc <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80005098:	02 9c       	mov	r12,r1
8000509a:	f0 1f 00 1b 	mcall	80005104 <xcmp_rx_process+0xe4>
					break;
8000509e:	c1 f8       	rjmp	800050dc <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800050a0:	00 9c       	mov	r12,r0
800050a2:	f0 1f 00 19 	mcall	80005104 <xcmp_rx_process+0xe4>
					break;
800050a6:	c1 b8       	rjmp	800050dc <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800050a8:	12 98       	mov	r8,r9
800050aa:	e2 18 04 00 	andl	r8,0x400,COH
800050ae:	c0 70       	breq	800050bc <xcmp_rx_process+0x9c>
800050b0:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800050b4:	e0 48 00 68 	cp.w	r8,104
800050b8:	e0 8a 00 08 	brle	800050c8 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800050bc:	e2 19 f0 00 	andl	r9,0xf000,COH
800050c0:	c0 e1       	brne	800050dc <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800050c2:	f0 1f 00 14 	mcall	80005110 <xcmp_rx_process+0xf0>
800050c6:	c0 b8       	rjmp	800050dc <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800050c8:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800050cc:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800050d0:	49 19       	lddpc	r9,80005114 <xcmp_rx_process+0xf4>
800050d2:	72 08       	ld.w	r8,r9[0x0]
800050d4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800050d8:	f0 1f 00 0b 	mcall	80005104 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800050dc:	66 0c       	ld.w	r12,r3[0x0]
800050de:	40 0b       	lddsp	r11,sp[0x0]
800050e0:	f0 1f 00 0e 	mcall	80005118 <xcmp_rx_process+0xf8>
800050e4:	ca 7b       	rjmp	80005032 <xcmp_rx_process+0x12>
800050e6:	00 00       	add	r0,r0
800050e8:	00 00       	add	r0,r0
800050ea:	10 0c       	add	r12,r8
800050ec:	00 00       	add	r0,r0
800050ee:	0f b8       	ld.ub	r8,r7[0x3]
800050f0:	00 00       	add	r0,r0
800050f2:	10 1c       	sub	r12,r8
800050f4:	00 00       	add	r0,r0
800050f6:	10 10       	sub	r0,r8
800050f8:	00 00       	add	r0,r0
800050fa:	10 28       	rsub	r8,r8
800050fc:	80 00       	ld.sh	r0,r0[0x0]
800050fe:	8c c4       	ld.uh	r4,r6[0x8]
80005100:	00 00       	add	r0,r0
80005102:	10 40       	or	r0,r8
80005104:	80 00       	ld.sh	r0,r0[0x0]
80005106:	4f 84       	lddpc	r4,800052e4 <xnl_tx+0x1c>
80005108:	00 00       	add	r0,r0
8000510a:	10 00       	add	r0,r8
8000510c:	00 00       	add	r0,r0
8000510e:	10 34       	cp.w	r4,r8
80005110:	80 00       	ld.sh	r0,r0[0x0]
80005112:	4f 60       	lddpc	r0,800052e8 <xnl_tx+0x20>
80005114:	00 00       	add	r0,r0
80005116:	46 1c       	lddsp	r12,sp[0x184]
80005118:	80 00       	ld.sh	r0,r0[0x0]
8000511a:	3a 50       	mov	r0,-91

8000511c <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
8000511c:	eb cd 40 90 	pushm	r4,r7,lr
80005120:	20 1d       	sub	sp,4
80005122:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80005126:	48 c8       	lddpc	r8,80005154 <xcmp_rx+0x38>
80005128:	70 0c       	ld.w	r12,r8[0x0]
8000512a:	f0 1f 00 0c 	mcall	80005158 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000512e:	c1 00       	breq	8000514e <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80005130:	fa c7 ff fc 	sub	r7,sp,-4
80005134:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80005136:	e0 6a 00 ca 	mov	r10,202
8000513a:	08 9b       	mov	r11,r4
8000513c:	f0 1f 00 08 	mcall	8000515c <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80005140:	48 88       	lddpc	r8,80005160 <xcmp_rx+0x44>
80005142:	70 0c       	ld.w	r12,r8[0x0]
80005144:	30 09       	mov	r9,0
80005146:	12 9a       	mov	r10,r9
80005148:	1a 9b       	mov	r11,sp
8000514a:	f0 1f 00 07 	mcall	80005164 <xcmp_rx+0x48>
	}	
}
8000514e:	2f fd       	sub	sp,-4
80005150:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80005154:	00 00       	add	r0,r0
80005156:	0f b8       	ld.ub	r8,r7[0x3]
80005158:	80 00       	ld.sh	r0,r0[0x0]
8000515a:	40 b0       	lddsp	r0,sp[0x2c]
8000515c:	80 00       	ld.sh	r0,r0[0x0]
8000515e:	a4 86       	st.b	r2[0x0],r6
80005160:	00 00       	add	r0,r0
80005162:	10 0c       	add	r12,r8
80005164:	80 00       	ld.sh	r0,r0[0x0]
80005166:	8e d0       	ld.uh	r0,r7[0xa]

80005168 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80005168:	48 28       	lddpc	r8,80005170 <xnl_register_xcmp_func+0x8>
8000516a:	91 0c       	st.w	r8[0x0],r12
}
8000516c:	5e fc       	retal	r12
8000516e:	00 00       	add	r0,r0
80005170:	00 00       	add	r0,r0
80005172:	10 70       	tst	r0,r8

80005174 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80005174:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80005176:	48 88       	lddpc	r8,80005194 <xnl_get_msg_ack_func+0x20>
80005178:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000517a:	98 49       	ld.sh	r9,r12[0x8]
8000517c:	f0 09 19 00 	cp.h	r9,r8
80005180:	c0 81       	brne	80005190 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80005182:	48 68       	lddpc	r8,80005198 <xnl_get_msg_ack_func+0x24>
80005184:	70 0c       	ld.w	r12,r8[0x0]
80005186:	30 09       	mov	r9,0
80005188:	12 9a       	mov	r10,r9
8000518a:	12 9b       	mov	r11,r9
8000518c:	f0 1f 00 04 	mcall	8000519c <xnl_get_msg_ack_func+0x28>
80005190:	d8 02       	popm	pc
80005192:	00 00       	add	r0,r0
80005194:	00 00       	add	r0,r0
80005196:	10 50       	eor	r0,r8
80005198:	00 00       	add	r0,r0
8000519a:	10 4c       	or	r12,r8
8000519c:	80 00       	ld.sh	r0,r0[0x0]
8000519e:	8e d0       	ld.uh	r0,r7[0xa]

800051a0 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
800051a0:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800051a2:	4a 86       	lddpc	r6,80005240 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800051a4:	4a 82       	lddpc	r2,80005244 <xnl_tx_process+0xa4>
800051a6:	4a 94       	lddpc	r4,80005248 <xnl_tx_process+0xa8>
800051a8:	30 07       	mov	r7,0
800051aa:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800051ac:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800051ae:	4a 85       	lddpc	r5,8000524c <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800051b0:	4a 83       	lddpc	r3,80005250 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800051b2:	6c 08       	ld.w	r8,r6[0x0]
800051b4:	58 08       	cp.w	r8,0
800051b6:	c0 40       	breq	800051be <xnl_tx_process+0x1e>
800051b8:	58 18       	cp.w	r8,1
800051ba:	cf d1       	brne	800051b4 <xnl_tx_process+0x14>
800051bc:	c2 08       	rjmp	800051fc <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800051be:	64 0c       	ld.w	r12,r2[0x0]
800051c0:	0e 99       	mov	r9,r7
800051c2:	02 9a       	mov	r10,r1
800051c4:	08 9b       	mov	r11,r4
800051c6:	f0 1f 00 24 	mcall	80005254 <xnl_tx_process+0xb4>
800051ca:	58 1c       	cp.w	r12,1
800051cc:	cf 31       	brne	800051b2 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800051ce:	68 0c       	ld.w	r12,r4[0x0]
800051d0:	58 0c       	cp.w	r12,0
800051d2:	cf 00       	breq	800051b2 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800051d4:	98 28       	ld.sh	r8,r12[0x4]
800051d6:	e0 08 19 00 	cp.h	r8,r0
800051da:	c0 41       	brne	800051e2 <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
800051dc:	f0 1f 00 1f 	mcall	80005258 <xnl_tx_process+0xb8>
						break;
800051e0:	ce 9b       	rjmp	800051b2 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800051e2:	f0 1f 00 1f 	mcall	8000525c <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800051e6:	30 18       	mov	r8,1
800051e8:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800051ea:	66 0c       	ld.w	r12,r3[0x0]
800051ec:	0e 99       	mov	r9,r7
800051ee:	0e 9a       	mov	r10,r7
800051f0:	0e 9b       	mov	r11,r7
800051f2:	f0 1f 00 19 	mcall	80005254 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
800051f6:	30 18       	mov	r8,1
800051f8:	8d 08       	st.w	r6[0x0],r8
800051fa:	cd cb       	rjmp	800051b2 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://ACKdata/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800051fc:	66 0c       	ld.w	r12,r3[0x0]
800051fe:	0e 99       	mov	r9,r7
80005200:	36 4a       	mov	r10,100
80005202:	0e 9b       	mov	r11,r7
80005204:	f0 1f 00 14 	mcall	80005254 <xnl_tx_process+0xb4>
80005208:	58 1c       	cp.w	r12,1
8000520a:	c0 81       	brne	8000521a <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//ADK500ms,freertos
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
8000520c:	49 58       	lddpc	r8,80005260 <xnl_tx_process+0xc0>
8000520e:	70 0c       	ld.w	r12,r8[0x0]
80005210:	68 0b       	ld.w	r11,r4[0x0]
80005212:	f0 1f 00 15 	mcall	80005264 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80005216:	8d 07       	st.w	r6[0x0],r7
80005218:	cc db       	rjmp	800051b2 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
8000521a:	6a 08       	ld.w	r8,r5[0x0]
8000521c:	58 38       	cp.w	r8,3
8000521e:	e0 89 00 09 	brgt	80005230 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80005222:	68 0c       	ld.w	r12,r4[0x0]
80005224:	f0 1f 00 0e 	mcall	8000525c <xnl_tx_process+0xbc>
						xnl_send_times++;
80005228:	6a 08       	ld.w	r8,r5[0x0]
8000522a:	2f f8       	sub	r8,-1
8000522c:	8b 08       	st.w	r5[0x0],r8
8000522e:	cc 2b       	rjmp	800051b2 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80005230:	48 c8       	lddpc	r8,80005260 <xnl_tx_process+0xc0>
80005232:	70 0c       	ld.w	r12,r8[0x0]
80005234:	68 0b       	ld.w	r11,r4[0x0]
80005236:	f0 1f 00 0c 	mcall	80005264 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
8000523a:	8d 07       	st.w	r6[0x0],r7
8000523c:	cb bb       	rjmp	800051b2 <xnl_tx_process+0x12>
8000523e:	00 00       	add	r0,r0
80005240:	00 00       	add	r0,r0
80005242:	10 64       	and	r4,r8
80005244:	00 00       	add	r0,r0
80005246:	10 60       	and	r0,r8
80005248:	00 00       	add	r0,r0
8000524a:	10 5c       	eor	r12,r8
8000524c:	00 00       	add	r0,r0
8000524e:	10 68       	and	r8,r8
80005250:	00 00       	add	r0,r0
80005252:	10 4c       	or	r12,r8
80005254:	80 00       	ld.sh	r0,r0[0x0]
80005256:	8c c4       	ld.uh	r4,r6[0x8]
80005258:	80 00       	ld.sh	r0,r0[0x0]
8000525a:	8b 54       	st.w	r5[0x14],r4
8000525c:	80 00       	ld.sh	r0,r0[0x0]
8000525e:	3a 70       	mov	r0,-89
80005260:	00 00       	add	r0,r0
80005262:	0f b8       	ld.ub	r8,r7[0x3]
80005264:	80 00       	ld.sh	r0,r0[0x0]
80005266:	3a 50       	mov	r0,-91

80005268 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80005268:	eb cd 40 fe 	pushm	r1-r7,lr
8000526c:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000526e:	49 26       	lddpc	r6,800052b4 <xnl_rx_process+0x4c>
80005270:	30 05       	mov	r5,0
80005272:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80005274:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80005276:	49 11       	lddpc	r1,800052b8 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80005278:	49 12       	lddpc	r2,800052bc <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000527a:	6c 0c       	ld.w	r12,r6[0x0]
8000527c:	0a 99       	mov	r9,r5
8000527e:	08 9a       	mov	r10,r4
80005280:	1a 9b       	mov	r11,sp
80005282:	f0 1f 00 10 	mcall	800052c0 <xnl_rx_process+0x58>
80005286:	58 1c       	cp.w	r12,1
80005288:	cf 91       	brne	8000527a <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000528a:	40 0c       	lddsp	r12,sp[0x0]
8000528c:	58 0c       	cp.w	r12,0
8000528e:	cf 60       	breq	8000527a <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80005290:	98 28       	ld.sh	r8,r12[0x4]
80005292:	e6 08 19 00 	cp.h	r8,r3
80005296:	e0 8b 00 0a 	brhi	800052aa <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000529a:	5c 78       	castu.h	r8
8000529c:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800052a0:	58 09       	cp.w	r9,0
800052a2:	c0 40       	breq	800052aa <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800052a4:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800052a8:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800052aa:	62 0c       	ld.w	r12,r1[0x0]
800052ac:	40 0b       	lddsp	r11,sp[0x0]
800052ae:	f0 1f 00 06 	mcall	800052c4 <xnl_rx_process+0x5c>
800052b2:	ce 4b       	rjmp	8000527a <xnl_rx_process+0x12>
800052b4:	00 00       	add	r0,r0
800052b6:	0f cc       	ld.ub	r12,r7[0x4]
800052b8:	00 00       	add	r0,r0
800052ba:	0f b8       	ld.ub	r8,r7[0x3]
800052bc:	00 00       	add	r0,r0
800052be:	04 fc       	st.b	--r2,r12
800052c0:	80 00       	ld.sh	r0,r0[0x0]
800052c2:	8c c4       	ld.uh	r4,r6[0x8]
800052c4:	80 00       	ld.sh	r0,r0[0x0]
800052c6:	3a 50       	mov	r0,-91

800052c8 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800052c8:	eb cd 40 c0 	pushm	r6-r7,lr
800052cc:	20 1d       	sub	sp,4
800052ce:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800052d0:	98 39       	ld.sh	r9,r12[0x6]
800052d2:	3f f8       	mov	r8,-1
800052d4:	f0 09 19 00 	cp.h	r9,r8
800052d8:	c0 a1       	brne	800052ec <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800052da:	4a e9       	lddpc	r9,80005390 <xnl_tx+0xc8>
800052dc:	13 88       	ld.ub	r8,r9[0x0]
800052de:	2f f8       	sub	r8,-1
800052e0:	5c 58       	castu.b	r8
800052e2:	b2 88       	st.b	r9[0x0],r8
800052e4:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800052e8:	a9 a8       	sbr	r8,0x8
800052ea:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800052ec:	8c 49       	ld.sh	r9,r6[0x8]
800052ee:	3f f8       	mov	r8,-1
800052f0:	f0 09 19 00 	cp.h	r9,r8
800052f4:	c0 41       	brne	800052fc <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800052f6:	4a 88       	lddpc	r8,80005394 <xnl_tx+0xcc>
800052f8:	90 18       	ld.sh	r8,r8[0x2]
800052fa:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800052fc:	8c 59       	ld.sh	r9,r6[0xa]
800052fe:	3f f8       	mov	r8,-1
80005300:	f0 09 19 00 	cp.h	r9,r8
80005304:	c0 41       	brne	8000530c <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80005306:	4a 48       	lddpc	r8,80005394 <xnl_tx+0xcc>
80005308:	90 28       	ld.sh	r8,r8[0x4]
8000530a:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
8000530c:	8c 69       	ld.sh	r9,r6[0xc]
8000530e:	3f f8       	mov	r8,-1
80005310:	f0 09 19 00 	cp.h	r9,r8
80005314:	c0 e1       	brne	80005330 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80005316:	4a 08       	lddpc	r8,80005394 <xnl_tx+0xcc>
80005318:	90 49       	ld.sh	r9,r8[0x8]
8000531a:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000531c:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
8000531e:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80005320:	90 49       	ld.sh	r9,r8[0x8]
80005322:	e0 19 ff 00 	andl	r9,0xff00
80005326:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000532a:	f3 e8 10 08 	or	r8,r9,r8
8000532e:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80005330:	0d 98       	ld.ub	r8,r6[0x1]
80005332:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80005334:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80005338:	10 0c       	add	r12,r8
8000533a:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000533c:	58 0c       	cp.w	r12,0
8000533e:	e0 89 00 04 	brgt	80005346 <xnl_tx+0x7e>
80005342:	30 09       	mov	r9,0
80005344:	c0 d8       	rjmp	8000535e <xnl_tx+0x96>
80005346:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
8000534a:	2f ec       	sub	r12,-2
8000534c:	30 09       	mov	r9,0
8000534e:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80005350:	15 1b       	ld.sh	r11,r10++
80005352:	f6 09 00 09 	add	r9,r11,r9
80005356:	5c 89       	casts.h	r9
		indextohWord     += 1;
80005358:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000535a:	18 38       	cp.w	r8,r12
8000535c:	cf a1       	brne	80005350 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000535e:	5c 39       	neg	r9
80005360:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80005362:	48 e8       	lddpc	r8,80005398 <xnl_tx+0xd0>
80005364:	70 0c       	ld.w	r12,r8[0x0]
80005366:	f0 1f 00 0e 	mcall	8000539c <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
8000536a:	c1 00       	breq	8000538a <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000536c:	fa c7 ff fc 	sub	r7,sp,-4
80005370:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80005372:	e0 6a 01 00 	mov	r10,256
80005376:	0c 9b       	mov	r11,r6
80005378:	f0 1f 00 0a 	mcall	800053a0 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
8000537c:	48 a8       	lddpc	r8,800053a4 <xnl_tx+0xdc>
8000537e:	70 0c       	ld.w	r12,r8[0x0]
80005380:	30 09       	mov	r9,0
80005382:	12 9a       	mov	r10,r9
80005384:	1a 9b       	mov	r11,sp
80005386:	f0 1f 00 09 	mcall	800053a8 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
8000538a:	2f fd       	sub	sp,-4
8000538c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005390:	00 00       	add	r0,r0
80005392:	10 6c       	and	r12,r8
80005394:	00 00       	add	r0,r0
80005396:	10 50       	eor	r0,r8
80005398:	00 00       	add	r0,r0
8000539a:	0f b8       	ld.ub	r8,r7[0x3]
8000539c:	80 00       	ld.sh	r0,r0[0x0]
8000539e:	40 b0       	lddsp	r0,sp[0x2c]
800053a0:	80 00       	ld.sh	r0,r0[0x0]
800053a2:	a4 86       	st.b	r2[0x0],r6
800053a4:	00 00       	add	r0,r0
800053a6:	10 60       	and	r0,r8
800053a8:	80 00       	ld.sh	r0,r0[0x0]
800053aa:	8e d0       	ld.uh	r0,r7[0xa]

800053ac <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800053ac:	eb cd 40 80 	pushm	r7,lr
800053b0:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
800053b4:	f0 1f 00 27 	mcall	80005450 <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
800053b8:	30 09       	mov	r9,0
800053ba:	4a 78       	lddpc	r8,80005454 <xnl_init+0xa8>
800053bc:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800053be:	30 0b       	mov	r11,0
800053c0:	30 1c       	mov	r12,1
800053c2:	f0 1f 00 26 	mcall	80005458 <xnl_init+0xac>
800053c6:	4a 68       	lddpc	r8,8000545c <xnl_init+0xb0>
800053c8:	91 0c       	st.w	r8[0x0],r12
800053ca:	70 08       	ld.w	r8,r8[0x0]
800053cc:	58 08       	cp.w	r8,0
800053ce:	c0 80       	breq	800053de <xnl_init+0x32>
800053d0:	4a 38       	lddpc	r8,8000545c <xnl_init+0xb0>
800053d2:	70 0c       	ld.w	r12,r8[0x0]
800053d4:	30 09       	mov	r9,0
800053d6:	12 9a       	mov	r10,r9
800053d8:	12 9b       	mov	r11,r9
800053da:	f0 1f 00 22 	mcall	80005460 <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //xnl_frame_tx
800053de:	30 4b       	mov	r11,4
800053e0:	31 4c       	mov	r12,20
800053e2:	f0 1f 00 1e 	mcall	80005458 <xnl_init+0xac>
800053e6:	4a 08       	lddpc	r8,80005464 <xnl_init+0xb8>
800053e8:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800053ea:	30 07       	mov	r7,0
800053ec:	1a d7       	st.w	--sp,r7
800053ee:	1a d7       	st.w	--sp,r7
800053f0:	1a d7       	st.w	--sp,r7
800053f2:	30 38       	mov	r8,3
800053f4:	0e 99       	mov	r9,r7
800053f6:	e0 6a 02 00 	mov	r10,512
800053fa:	49 cb       	lddpc	r11,80005468 <xnl_init+0xbc>
800053fc:	49 cc       	lddpc	r12,8000546c <xnl_init+0xc0>
800053fe:	f0 1f 00 1d 	mcall	80005470 <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80005402:	1a d7       	st.w	--sp,r7
80005404:	1a d7       	st.w	--sp,r7
80005406:	1a d7       	st.w	--sp,r7
80005408:	30 38       	mov	r8,3
8000540a:	0e 99       	mov	r9,r7
8000540c:	e0 6a 03 20 	mov	r10,800
80005410:	49 9b       	lddpc	r11,80005474 <xnl_init+0xc8>
80005412:	49 ac       	lddpc	r12,80005478 <xnl_init+0xcc>
80005414:	f0 1f 00 17 	mcall	80005470 <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80005418:	e0 68 40 0e 	mov	r8,16398
8000541c:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005420:	3f f8       	mov	r8,-1
80005422:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80005426:	30 38       	mov	r8,3
80005428:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
8000542c:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80005430:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80005434:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80005438:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
8000543c:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005440:	fa cc ff e8 	sub	r12,sp,-24
80005444:	f0 1f 00 0e 	mcall	8000547c <xnl_init+0xd0>
80005448:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
8000544a:	2c 0d       	sub	sp,-256
8000544c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005450:	80 00       	ld.sh	r0,r0[0x0]
80005452:	40 d8       	lddsp	r8,sp[0x34]
80005454:	00 00       	add	r0,r0
80005456:	10 50       	eor	r0,r8
80005458:	80 00       	ld.sh	r0,r0[0x0]
8000545a:	90 28       	ld.sh	r8,r8[0x4]
8000545c:	00 00       	add	r0,r0
8000545e:	10 4c       	or	r12,r8
80005460:	80 00       	ld.sh	r0,r0[0x0]
80005462:	8e d0       	ld.uh	r0,r7[0xa]
80005464:	00 00       	add	r0,r0
80005466:	10 60       	and	r0,r8
80005468:	80 01       	ld.sh	r1,r0[0x0]
8000546a:	8a 84       	ld.uh	r4,r5[0x0]
8000546c:	80 00       	ld.sh	r0,r0[0x0]
8000546e:	52 68       	stdsp	sp[0x98],r8
80005470:	80 00       	ld.sh	r0,r0[0x0]
80005472:	96 fc       	ld.uh	r12,r11[0xe]
80005474:	80 00       	ld.sh	r0,r0[0x0]
80005476:	fe 00       	*unknown*
80005478:	80 00       	ld.sh	r0,r0[0x0]
8000547a:	51 a0       	stdsp	sp[0x68],r0
8000547c:	80 00       	ld.sh	r0,r0[0x0]
8000547e:	52 c8       	stdsp	sp[0xb0],r8

80005480 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80005480:	eb cd 40 80 	pushm	r7,lr
80005484:	fa cd 01 00 	sub	sp,sp,256
80005488:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000548a:	e0 68 40 0e 	mov	r8,16398
8000548e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005490:	3f f8       	mov	r8,-1
80005492:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80005494:	30 c8       	mov	r8,12
80005496:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80005498:	98 38       	ld.sh	r8,r12[0x6]
8000549a:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
8000549c:	98 58       	ld.sh	r8,r12[0xa]
8000549e:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800054a0:	98 48       	ld.sh	r8,r12[0x8]
800054a2:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800054a4:	98 68       	ld.sh	r8,r12[0xc]
800054a6:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800054a8:	30 08       	mov	r8,0
800054aa:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800054ac:	1a 9c       	mov	r12,sp
800054ae:	f0 1f 00 0a 	mcall	800054d4 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800054b2:	fa cd 00 cc 	sub	sp,sp,204
800054b6:	e0 6a 00 ca 	mov	r10,202
800054ba:	ee cb ff f0 	sub	r11,r7,-16
800054be:	1a 9c       	mov	r12,sp
800054c0:	f0 1f 00 06 	mcall	800054d8 <xnl_data_msg_func+0x58>
800054c4:	48 68       	lddpc	r8,800054dc <xnl_data_msg_func+0x5c>
800054c6:	70 08       	ld.w	r8,r8[0x0]
800054c8:	5d 18       	icall	r8
800054ca:	fa cd ff 34 	sub	sp,sp,-204
}
800054ce:	2c 0d       	sub	sp,-256
800054d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800054d4:	80 00       	ld.sh	r0,r0[0x0]
800054d6:	52 c8       	stdsp	sp[0xb0],r8
800054d8:	80 00       	ld.sh	r0,r0[0x0]
800054da:	a4 86       	st.b	r2[0x0],r6
800054dc:	00 00       	add	r0,r0
800054de:	10 70       	tst	r0,r8

800054e0 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
800054e0:	d4 21       	pushm	r4-r7,lr
800054e2:	fa cd 01 00 	sub	sp,sp,256
800054e6:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
800054e8:	4c 28       	lddpc	r8,800055f0 <xnl_device_auth_reply_func+0x110>
800054ea:	11 88       	ld.ub	r8,r8[0x0]
800054ec:	58 08       	cp.w	r8,0
800054ee:	c7 e1       	brne	800055ea <xnl_device_auth_reply_func+0x10a>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
800054f0:	4c 18       	lddpc	r8,800055f4 <xnl_device_auth_reply_func+0x114>
800054f2:	70 0c       	ld.w	r12,r8[0x0]
800054f4:	30 09       	mov	r9,0
800054f6:	12 9a       	mov	r10,r9
800054f8:	12 9b       	mov	r11,r9
800054fa:	f0 1f 00 40 	mcall	800055f8 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
800054fe:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80005502:	4b c8       	lddpc	r8,800055f0 <xnl_device_auth_reply_func+0x110>
80005504:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80005506:	ef 39 00 12 	ld.ub	r9,r7[18]
8000550a:	ef 38 00 13 	ld.ub	r8,r7[19]
8000550e:	b1 68       	lsl	r8,0x10
80005510:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80005514:	ef 38 00 15 	ld.ub	r8,r7[21]
80005518:	f3 e8 10 08 	or	r8,r9,r8
8000551c:	ef 39 00 14 	ld.ub	r9,r7[20]
80005520:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80005524:	ef 3a 00 16 	ld.ub	r10,r7[22]
80005528:	ef 38 00 17 	ld.ub	r8,r7[23]
8000552c:	b1 68       	lsl	r8,0x10
8000552e:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80005532:	ef 38 00 19 	ld.ub	r8,r7[25]
80005536:	f5 e8 10 08 	or	r8,r10,r8
8000553a:	ef 3a 00 18 	ld.ub	r10,r7[24]
8000553e:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80005542:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80005544:	e0 64 79 b9 	mov	r4,31161
80005548:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000554c:	e0 65 45 07 	mov	r5,17671
80005550:	ea 15 8a bd 	orh	r5,0x8abd
80005554:	e0 66 f9 3d 	mov	r6,63805
80005558:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000555c:	e0 6e b8 cf 	mov	lr,47311
80005560:	ea 1e 36 83 	orh	lr,0x3683
80005564:	e0 67 aa 1c 	mov	r7,43548
80005568:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000556c:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000556e:	f4 08 00 0c 	add	r12,r10,r8
80005572:	f0 0b 15 04 	lsl	r11,r8,0x4
80005576:	0a 0b       	add	r11,r5
80005578:	f9 eb 20 0b 	eor	r11,r12,r11
8000557c:	f0 0c 16 05 	lsr	r12,r8,0x5
80005580:	0c 0c       	add	r12,r6
80005582:	18 5b       	eor	r11,r12
80005584:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80005586:	f2 0c 15 04 	lsl	r12,r9,0x4
8000558a:	1c 0c       	add	r12,lr
8000558c:	f2 0b 16 05 	lsr	r11,r9,0x5
80005590:	0e 0b       	add	r11,r7
80005592:	f9 eb 20 0b 	eor	r11,r12,r11
80005596:	f2 0a 00 0c 	add	r12,r9,r10
8000559a:	18 5b       	eor	r11,r12
8000559c:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
8000559e:	e0 6b 37 20 	mov	r11,14112
800055a2:	ea 1b c6 ef 	orh	r11,0xc6ef
800055a6:	16 3a       	cp.w	r10,r11
800055a8:	ce 21       	brne	8000556c <xnl_device_auth_reply_func+0x8c>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800055aa:	e0 6a 40 1a 	mov	r10,16410
800055ae:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800055b0:	3f fa       	mov	r10,-1
800055b2:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800055b4:	30 6b       	mov	r11,6
800055b6:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800055b8:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800055ba:	48 eb       	lddpc	r11,800055f0 <xnl_device_auth_reply_func+0x110>
800055bc:	96 1c       	ld.sh	r12,r11[0x2]
800055be:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800055c0:	96 2b       	ld.sh	r11,r11[0x4]
800055c2:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800055c4:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800055c6:	30 ca       	mov	r10,12
800055c8:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800055ca:	30 0a       	mov	r10,0
800055cc:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
800055d0:	30 7a       	mov	r10,7
800055d2:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
800055d6:	30 2a       	mov	r10,2
800055d8:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800055dc:	fa ca ff ec 	sub	r10,sp,-20
800055e0:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800055e2:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
800055e4:	1a 9c       	mov	r12,sp
800055e6:	f0 1f 00 06 	mcall	800055fc <xnl_device_auth_reply_func+0x11c>
}
800055ea:	2c 0d       	sub	sp,-256
800055ec:	d8 22       	popm	r4-r7,pc
800055ee:	00 00       	add	r0,r0
800055f0:	00 00       	add	r0,r0
800055f2:	10 50       	eor	r0,r8
800055f4:	00 00       	add	r0,r0
800055f6:	10 4c       	or	r12,r8
800055f8:	80 00       	ld.sh	r0,r0[0x0]
800055fa:	8e d0       	ld.uh	r0,r7[0xa]
800055fc:	80 00       	ld.sh	r0,r0[0x0]
800055fe:	52 c8       	stdsp	sp[0xb0],r8

80005600 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80005600:	eb cd 40 80 	pushm	r7,lr
80005604:	fa cd 01 00 	sub	sp,sp,256
80005608:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000560a:	49 28       	lddpc	r8,80005650 <xnl_master_status_brdcst_func+0x50>
8000560c:	11 88       	ld.ub	r8,r8[0x0]
8000560e:	58 08       	cp.w	r8,0
80005610:	c1 c1       	brne	80005648 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80005612:	49 18       	lddpc	r8,80005654 <xnl_master_status_brdcst_func+0x54>
80005614:	70 0c       	ld.w	r12,r8[0x0]
80005616:	30 09       	mov	r9,0
80005618:	12 9a       	mov	r10,r9
8000561a:	12 9b       	mov	r11,r9
8000561c:	f0 1f 00 0f 	mcall	80005658 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80005620:	8e 58       	ld.sh	r8,r7[0xa]
80005622:	48 c9       	lddpc	r9,80005650 <xnl_master_status_brdcst_func+0x50>
80005624:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80005626:	e0 68 40 0e 	mov	r8,16398
8000562a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000562c:	3f f8       	mov	r8,-1
8000562e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80005630:	30 4a       	mov	r10,4
80005632:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80005634:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80005636:	92 19       	ld.sh	r9,r9[0x2]
80005638:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
8000563a:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000563c:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
8000563e:	30 08       	mov	r8,0
80005640:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80005642:	1a 9c       	mov	r12,sp
80005644:	f0 1f 00 06 	mcall	8000565c <xnl_master_status_brdcst_func+0x5c>
}
80005648:	2c 0d       	sub	sp,-256
8000564a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000564e:	00 00       	add	r0,r0
80005650:	00 00       	add	r0,r0
80005652:	10 50       	eor	r0,r8
80005654:	00 00       	add	r0,r0
80005656:	10 4c       	or	r12,r8
80005658:	80 00       	ld.sh	r0,r0[0x0]
8000565a:	8e d0       	ld.uh	r0,r7[0xa]
8000565c:	80 00       	ld.sh	r0,r0[0x0]
8000565e:	52 c8       	stdsp	sp[0xb0],r8

80005660 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80005660:	eb cd 40 80 	pushm	r7,lr
80005664:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80005666:	49 38       	lddpc	r8,800056b0 <xnl_device_conn_reply_func+0x50>
80005668:	70 0c       	ld.w	r12,r8[0x0]
8000566a:	30 09       	mov	r9,0
8000566c:	12 9a       	mov	r10,r9
8000566e:	12 9b       	mov	r11,r9
80005670:	f0 1f 00 11 	mcall	800056b4 <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80005674:	ef 18 00 10 	ld.uh	r8,r7[16]
80005678:	10 99       	mov	r9,r8
8000567a:	e2 19 ff 00 	andl	r9,0xff00,COH
8000567e:	e0 49 01 00 	cp.w	r9,256
80005682:	c0 60       	breq	8000568e <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80005684:	0e 9c       	mov	r12,r7
80005686:	f0 1f 00 0d 	mcall	800056b8 <xnl_device_conn_reply_func+0x58>
8000568a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
8000568e:	a9 68       	lsl	r8,0x8
80005690:	48 b9       	lddpc	r9,800056bc <xnl_device_conn_reply_func+0x5c>
80005692:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80005694:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80005698:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
8000569a:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000569e:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800056a0:	30 18       	mov	r8,1
800056a2:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
800056a4:	48 7c       	lddpc	r12,800056c0 <xnl_device_conn_reply_func+0x60>
800056a6:	f0 1f 00 08 	mcall	800056c4 <xnl_device_conn_reply_func+0x64>
800056aa:	e3 cd 80 80 	ldm	sp++,r7,pc
800056ae:	00 00       	add	r0,r0
800056b0:	00 00       	add	r0,r0
800056b2:	10 4c       	or	r12,r8
800056b4:	80 00       	ld.sh	r0,r0[0x0]
800056b6:	8e d0       	ld.uh	r0,r7[0xa]
800056b8:	80 00       	ld.sh	r0,r0[0x0]
800056ba:	56 00       	stdsp	sp[0x180],r0
800056bc:	00 00       	add	r0,r0
800056be:	10 50       	eor	r0,r8
800056c0:	80 01       	ld.sh	r1,r0[0x0]
800056c2:	8a 8c       	ld.uh	r12,r5[0x0]
800056c4:	80 00       	ld.sh	r0,r0[0x0]
800056c6:	9a c0       	ld.uh	r0,sp[0x8]

800056c8 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
800056c8:	fe 78 0c 00 	mov	r8,-62464
800056cc:	e0 69 03 07 	mov	r9,775
800056d0:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
800056d2:	30 49       	mov	r9,4
800056d4:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800056d6:	71 59       	ld.w	r9,r8[0x54]
800056d8:	e2 19 00 80 	andl	r9,0x80,COH
800056dc:	cf d0       	breq	800056d6 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
800056de:	fe 78 0c 00 	mov	r8,-62464
800056e2:	30 59       	mov	r9,5
800056e4:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
800056e6:	e0 69 01 0d 	mov	r9,269
800056ea:	ea 19 10 07 	orh	r9,0x1007
800056ee:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800056f0:	71 59       	ld.w	r9,r8[0x54]
800056f2:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800056f6:	cf d0       	breq	800056f0 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
800056f8:	fe 78 0c 00 	mov	r8,-62464
800056fc:	fc 19 00 80 	movh	r9,0x80
80005700:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80005702:	34 0a       	mov	r10,64
80005704:	fe 69 14 00 	mov	r9,-125952
80005708:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
8000570a:	30 69       	mov	r9,6
8000570c:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
8000570e:	30 19       	mov	r9,1
80005710:	fe 68 10 00 	mov	r8,-126976
80005714:	91 19       	st.w	r8[0x4],r9
}
80005716:	5e fc       	retal	r12

80005718 <read_a_byte>:
*/
U32 read_a_byte(U32 subaddress, S8 *datareceived)
{
	U32 TWI_Status = 0;

	AVR32_TWI.cr   =  AVR32_TWI_CR_MSEN_MASK | AVR32_TWI_CR_SVDIS_MASK;
80005718:	fe 78 2c 00 	mov	r8,-54272
8000571c:	32 49       	mov	r9,36
8000571e:	91 09       	st.w	r8[0x0],r9
	AVR32_TWI.mmr  =  PCF8563_ADDRESS        << AVR32_TWI_MMR_DADR_OFFSET   |
80005720:	e0 69 11 00 	mov	r9,4352
80005724:	ea 19 00 51 	orh	r9,0x51
80005728:	91 19       	st.w	r8[0x4],r9
	PCF8563_ADDR_LGT		<< AVR32_TWI_MMR_IADRSZ_OFFSET |
	1					<< AVR32_TWI_MMR_MREAD_OFFSET;
	AVR32_TWI.iadr =  subaddress;
8000572a:	91 3c       	st.w	r8[0xc],r12

	AVR32_TWI.cr   =  AVR32_TWI_START_MASK | AVR32_TWI_STOP_MASK;
8000572c:	30 39       	mov	r9,3
8000572e:	91 09       	st.w	r8[0x0],r9

	do
	{
		TWI_Status =  AVR32_TWI.sr & 0x00000102;
80005730:	70 8c       	ld.w	r12,r8[0x20]
80005732:	e2 1c 01 02 	andl	r12,0x102,COH
	}
	while (TWI_Status == 0);
80005736:	cf d0       	breq	80005730 <read_a_byte+0x18>

	if (!(TWI_Status & 0x00000100))
80005738:	18 98       	mov	r8,r12
8000573a:	e2 18 01 00 	andl	r8,0x100,COH
8000573e:	c0 51       	brne	80005748 <read_a_byte+0x30>
	{
		*datareceived = AVR32_TWI.rhr;
80005740:	fe 78 2c 00 	mov	r8,-54272
80005744:	70 c8       	ld.w	r8,r8[0x30]
80005746:	b6 88       	st.b	r11[0x0],r8
	}
	while ((AVR32_TWI.sr & 0x00000001) == 0x00000000); //Wait for complete.
80005748:	fe 78 2c 00 	mov	r8,-54272
8000574c:	70 89       	ld.w	r9,r8[0x20]
8000574e:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80005752:	cf d0       	breq	8000574c <read_a_byte+0x34>
	return (TWI_Status);
}
80005754:	5e fc       	retal	r12
80005756:	d7 03       	nop

80005758 <rtc_read_time>:
Calls: 
    my_writeabyte
Return:rtc_err_t
*/
rtc_err_t rtc_read_time(date_time_t * t)
{	
80005758:	eb cd 40 e0 	pushm	r5-r7,lr
8000575c:	20 2d       	sub	sp,8
8000575e:	18 97       	mov	r7,r12
	if(NULL != rtc_mutex)
80005760:	4c 28       	lddpc	r8,80005868 <rtc_read_time+0x110>
80005762:	70 08       	ld.w	r8,r8[0x0]
80005764:	58 08       	cp.w	r8,0
80005766:	c0 31       	brne	8000576c <rtc_read_time+0x14>
80005768:	30 3c       	mov	r12,3
8000576a:	c7 b8       	rjmp	80005860 <rtc_read_time+0x108>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
8000576c:	4b f6       	lddpc	r6,80005868 <rtc_read_time+0x110>
8000576e:	6c 0c       	ld.w	r12,r6[0x0]
80005770:	30 09       	mov	r9,0
80005772:	3f fa       	mov	r10,-1
80005774:	12 9b       	mov	r11,r9
80005776:	f0 1f 00 3e 	mcall	8000586c <rtc_read_time+0x114>
	int RTC_Status;
	
	unsigned char time[8];
	
	/*read second*/
	res = read_a_byte(0x02, &time[0]);	
8000577a:	1a 9b       	mov	r11,sp
8000577c:	30 2c       	mov	r12,2
8000577e:	f0 1f 00 3d 	mcall	80005870 <rtc_read_time+0x118>
	t->second = ((time[0] & 0x7F) >> 4) * 10 + (time[0] & 0x0F);
80005782:	1b 88       	ld.ub	r8,sp[0x0]
80005784:	f3 d8 c0 83 	bfextu	r9,r8,0x4,0x3
80005788:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000578c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005790:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005794:	ae f9       	st.b	r7[0x7],r9
	
	/*read minute*/
	res = read_a_byte(0x03, &time[1]);
80005796:	fa cb ff ff 	sub	r11,sp,-1
8000579a:	30 3c       	mov	r12,3
8000579c:	f0 1f 00 35 	mcall	80005870 <rtc_read_time+0x118>
	t->minute = ((time[1] & 0x7F) >> 4) * 10 + (time[1] & 0x0F);
800057a0:	1b 98       	ld.ub	r8,sp[0x1]
800057a2:	f3 d8 c0 83 	bfextu	r9,r8,0x4,0x3
800057a6:	f2 09 00 29 	add	r9,r9,r9<<0x2
800057aa:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800057ae:	f0 09 00 19 	add	r9,r8,r9<<0x1
800057b2:	ae e9       	st.b	r7[0x6],r9
	
	/*read hour*/
	res = read_a_byte(0x04, &time[2]);
800057b4:	fa cb ff fe 	sub	r11,sp,-2
800057b8:	30 4c       	mov	r12,4
800057ba:	f0 1f 00 2e 	mcall	80005870 <rtc_read_time+0x118>
	t->hour = ((time[2] & 0x3F) >> 4) * 10 + (time[2] & 0x0F);
800057be:	1b a8       	ld.ub	r8,sp[0x2]
800057c0:	f3 d8 c0 82 	bfextu	r9,r8,0x4,0x2
800057c4:	f2 09 00 29 	add	r9,r9,r9<<0x2
800057c8:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800057cc:	f0 09 00 19 	add	r9,r8,r9<<0x1
800057d0:	ae d9       	st.b	r7[0x5],r9
	
	/*read day*/
	res = read_a_byte(0x05, &time[3]);
800057d2:	fa cb ff fd 	sub	r11,sp,-3
800057d6:	30 5c       	mov	r12,5
800057d8:	f0 1f 00 26 	mcall	80005870 <rtc_read_time+0x118>
	t->day = ((time[3] & 0x3F) >> 4) * 10 + (time[3] & 0x0F);
800057dc:	1b b8       	ld.ub	r8,sp[0x3]
800057de:	f3 d8 c0 82 	bfextu	r9,r8,0x4,0x2
800057e2:	f2 09 00 29 	add	r9,r9,r9<<0x2
800057e6:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800057ea:	f0 09 00 19 	add	r9,r8,r9<<0x1
800057ee:	ae b9       	st.b	r7[0x3],r9
	
	/*read week*/
	res = read_a_byte(0x06, &time[4]);
800057f0:	fa cb ff fc 	sub	r11,sp,-4
800057f4:	30 6c       	mov	r12,6
800057f6:	f0 1f 00 1f 	mcall	80005870 <rtc_read_time+0x118>
	t->week = (time[4] & 0x0F);
800057fa:	1b c8       	ld.ub	r8,sp[0x4]
800057fc:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005800:	ae c8       	st.b	r7[0x4],r8
	
	/*read month*/
	res = read_a_byte(0x07, &time[5]);
80005802:	fa cb ff fb 	sub	r11,sp,-5
80005806:	30 7c       	mov	r12,7
80005808:	f0 1f 00 1a 	mcall	80005870 <rtc_read_time+0x118>
	t->month = ((time[5] & 0x1F) >> 4) * 10 + (time[5] & 0x0F);
8000580c:	1b d8       	ld.ub	r8,sp[0x5]
8000580e:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
80005812:	f2 0a 15 02 	lsl	r10,r9,0x2
80005816:	14 09       	add	r9,r10
80005818:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000581c:	f0 09 00 18 	add	r8,r8,r9<<0x1
80005820:	ae a8       	st.b	r7[0x2],r8
	
	/*read year*/
	res = read_a_byte(0x08, &time[6]);
80005822:	fa cb ff fa 	sub	r11,sp,-6
80005826:	30 8c       	mov	r12,8
80005828:	f0 1f 00 12 	mcall	80005870 <rtc_read_time+0x118>
8000582c:	18 95       	mov	r5,r12
	t->year = ((time[6] & 0xFF) >> 4) * 10 + (time[6] & 0x0F) + 2000;
8000582e:	1b e9       	ld.ub	r9,sp[0x6]
80005830:	f1 d9 c0 04 	bfextu	r8,r9,0x0,0x4
80005834:	f0 c8 f8 30 	sub	r8,r8,-2000
80005838:	a5 89       	lsr	r9,0x4
8000583a:	f2 09 10 0a 	mul	r9,r9,10
8000583e:	12 08       	add	r8,r9
80005840:	5c 78       	castu.h	r8
80005842:	30 0b       	mov	r11,0
80005844:	f0 09 16 08 	lsr	r9,r8,0x8
80005848:	ae 89       	st.b	r7[0x0],r9
8000584a:	ae 98       	st.b	r7[0x1],r8
	
	/*finished accessing the shared resource.Release the semaphore.*/	
	xSemaphoreGive(rtc_mutex);	
8000584c:	6c 0c       	ld.w	r12,r6[0x0]
8000584e:	16 99       	mov	r9,r11
80005850:	16 9a       	mov	r10,r11
80005852:	f0 1f 00 09 	mcall	80005874 <rtc_read_time+0x11c>
		
	if(res)
80005856:	58 05       	cp.w	r5,0
80005858:	f9 bc 01 00 	movne	r12,0
8000585c:	f9 bc 00 02 	moveq	r12,2
	{
		return rtc_success;
	}

	return rtc_write_err;
}
80005860:	2f ed       	sub	sp,-8
80005862:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005866:	00 00       	add	r0,r0
80005868:	00 00       	add	r0,r0
8000586a:	10 80       	andn	r0,r8
8000586c:	80 00       	ld.sh	r0,r0[0x0]
8000586e:	8c c4       	ld.uh	r4,r6[0x8]
80005870:	80 00       	ld.sh	r0,r0[0x0]
80005872:	57 18       	stdsp	sp[0x1c4],r8
80005874:	80 00       	ld.sh	r0,r0[0x0]
80005876:	8e d0       	ld.uh	r0,r7[0xa]

80005878 <getTime>:
Description: define now
Calls:
Return:date_time_t *
*/
date_time_t * getTime(void)
{
80005878:	eb cd 40 80 	pushm	r7,lr
	rtc_read_time(&date_time);
8000587c:	48 47       	lddpc	r7,8000588c <getTime+0x14>
8000587e:	0e 9c       	mov	r12,r7
80005880:	f0 1f 00 04 	mcall	80005890 <getTime+0x18>
	return &date_time;
80005884:	0e 9c       	mov	r12,r7
80005886:	e3 cd 80 80 	ldm	sp++,r7,pc
8000588a:	00 00       	add	r0,r0
8000588c:	00 00       	add	r0,r0
8000588e:	10 78       	tst	r8,r8
80005890:	80 00       	ld.sh	r0,r0[0x0]
80005892:	57 58       	stdsp	sp[0x1d4],r8

80005894 <rtc_init>:
    PCF8563_init
Called By: ..
Return:rtc_err_t
*/
rtc_err_t rtc_init(void)
{
80005894:	eb cd 40 c0 	pushm	r6-r7,lr
80005898:	20 3d       	sub	sp,12
	/* Create the mutex semaphore to guard a shared RTC(TWI).*/	
	rtc_mutex = xSemaphoreCreateMutex();
8000589a:	f0 1f 00 1a 	mcall	80005900 <rtc_init+0x6c>
8000589e:	49 a8       	lddpc	r8,80005904 <rtc_init+0x70>
800058a0:	91 0c       	st.w	r8[0x0],r12
	
	if(NULL != rtc_mutex)
800058a2:	70 08       	ld.w	r8,r8[0x0]
800058a4:	58 08       	cp.w	r8,0
800058a6:	c0 31       	brne	800058ac <rtc_init+0x18>
800058a8:	30 3c       	mov	r12,3
800058aa:	c2 78       	rjmp	800058f8 <rtc_init+0x64>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
800058ac:	49 66       	lddpc	r6,80005904 <rtc_init+0x70>
800058ae:	6c 0c       	ld.w	r12,r6[0x0]
800058b0:	30 09       	mov	r9,0
800058b2:	3f fa       	mov	r10,-1
800058b4:	12 9b       	mov	r11,r9
800058b6:	f0 1f 00 15 	mcall	80005908 <rtc_init+0x74>
	
	/*twi_package_t packet, packet_received*/
	static int status;

	/*TWI gpio pins configuration*/	
	gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
800058ba:	30 2b       	mov	r11,2
800058bc:	49 4c       	lddpc	r12,8000590c <rtc_init+0x78>
800058be:	f0 1f 00 15 	mcall	80005910 <rtc_init+0x7c>
	
	/* options settings*/
	opt.pba_hz = RTC_PBACLK_FREQ_HZ;//FOSC0;24Mhz
800058c2:	e0 68 36 00 	mov	r8,13824
800058c6:	ea 18 01 6e 	orh	r8,0x16e
800058ca:	50 08       	stdsp	sp[0x0],r8
	opt.speed  = TWI_SPEED;//200Khz
800058cc:	e2 78 0d 40 	mov	r8,200000
800058d0:	50 18       	stdsp	sp[0x4],r8
	opt.chip   = PCF8563_ADDRESS;
800058d2:	35 18       	mov	r8,81
800058d4:	fb 68 00 08 	st.b	sp[8],r8

	/*initialize TWI driver with options*/
	status = twi_master_init(&AVR32_TWI, &opt);
800058d8:	1a 9b       	mov	r11,sp
800058da:	fe 7c 2c 00 	mov	r12,-54272
800058de:	f0 1f 00 0e 	mcall	80005914 <rtc_init+0x80>
800058e2:	48 e7       	lddpc	r7,80005918 <rtc_init+0x84>
800058e4:	8f 0c       	st.w	r7[0x0],r12
	
	/*finished accessing the shared resource.Release the semaphore.*/
	xSemaphoreGive(rtc_mutex);		
800058e6:	6c 0c       	ld.w	r12,r6[0x0]
800058e8:	30 09       	mov	r9,0
800058ea:	12 9a       	mov	r10,r9
800058ec:	12 9b       	mov	r11,r9
800058ee:	f0 1f 00 0c 	mcall	8000591c <rtc_init+0x88>
800058f2:	6e 08       	ld.w	r8,r7[0x0]
800058f4:	58 08       	cp.w	r8,0
800058f6:	5f 1c       	srne	r12
	{
		return rtc_success;
	}
		
	return rtc_init_err;
}
800058f8:	2f dd       	sub	sp,-12
800058fa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800058fe:	00 00       	add	r0,r0
80005900:	80 00       	ld.sh	r0,r0[0x0]
80005902:	8f d0       	st.w	r7[0x34],r0
80005904:	00 00       	add	r0,r0
80005906:	10 80       	andn	r0,r8
80005908:	80 00       	ld.sh	r0,r0[0x0]
8000590a:	8c c4       	ld.uh	r4,r6[0x8]
8000590c:	80 01       	ld.sh	r1,r0[0x0]
8000590e:	8a a0       	ld.uh	r0,r5[0x4]
80005910:	80 00       	ld.sh	r0,r0[0x0]
80005912:	9f 60       	st.w	pc[0x18],r0
80005914:	80 00       	ld.sh	r0,r0[0x0]
80005916:	5f 80       	srls	r0
80005918:	00 00       	add	r0,r0
8000591a:	10 74       	tst	r4,r8
8000591c:	80 00       	ld.sh	r0,r0[0x0]
8000591e:	8e d0       	ld.uh	r0,r7[0xa]

80005920 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80005920:	fe 78 10 00 	mov	r8,-61440
80005924:	fc 19 00 10 	movh	r9,0x10
80005928:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
8000592a:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
8000592c:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
8000592e:	30 39       	mov	r9,3
80005930:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80005934:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80005938:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
8000593c:	fe 78 38 00 	mov	r8,-51200
80005940:	30 49       	mov	r9,4
80005942:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80005946:	e0 69 91 0d 	mov	r9,37133
8000594a:	ea 19 00 52 	orh	r9,0x52
8000594e:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005950:	32 09       	mov	r9,32
80005952:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005954:	30 59       	mov	r9,5
80005956:	91 09       	st.w	r8[0x0],r9
}
80005958:	5e fc       	retal	r12
8000595a:	d7 03       	nop

8000595c <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
8000595c:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
8000595e:	30 2a       	mov	r10,2
80005960:	e0 6b 01 c1 	mov	r11,449
80005964:	48 ec       	lddpc	r12,8000599c <tc_init+0x40>
80005966:	f0 1f 00 0f 	mcall	800059a0 <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
8000596a:	48 fb       	lddpc	r11,800059a4 <tc_init+0x48>
8000596c:	fe 7c 38 00 	mov	r12,-51200
80005970:	f0 1f 00 0e 	mcall	800059a8 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80005974:	e0 6a 75 30 	mov	r10,30000
80005978:	30 1b       	mov	r11,1
8000597a:	fe 7c 38 00 	mov	r12,-51200
8000597e:	f0 1f 00 0c 	mcall	800059ac <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80005982:	48 ca       	lddpc	r10,800059b0 <tc_init+0x54>
80005984:	30 1b       	mov	r11,1
80005986:	fe 7c 38 00 	mov	r12,-51200
8000598a:	f0 1f 00 0b 	mcall	800059b4 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
8000598e:	30 1b       	mov	r11,1
80005990:	fe 7c 38 00 	mov	r12,-51200
80005994:	f0 1f 00 09 	mcall	800059b8 <tc_init+0x5c>
80005998:	d8 02       	popm	pc
8000599a:	00 00       	add	r0,r0
8000599c:	80 00       	ld.sh	r0,r0[0x0]
8000599e:	59 bc       	cp.w	r12,27
800059a0:	80 00       	ld.sh	r0,r0[0x0]
800059a2:	59 e0       	cp.w	r0,30
800059a4:	80 01       	ld.sh	r1,r0[0x0]
800059a6:	8a b4       	ld.uh	r4,r5[0x6]
800059a8:	80 00       	ld.sh	r0,r0[0x0]
800059aa:	5c c6       	swap.bh	r6
800059ac:	80 00       	ld.sh	r0,r0[0x0]
800059ae:	5d 86       	*unknown*
800059b0:	80 01       	ld.sh	r1,r0[0x0]
800059b2:	8a b0       	ld.uh	r0,r5[0x6]
800059b4:	80 00       	ld.sh	r0,r0[0x0]
800059b6:	5d ba       	*unknown*
800059b8:	80 00       	ld.sh	r0,r0[0x0]
800059ba:	5d 62       	*unknown*

800059bc <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
800059bc:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
800059be:	48 68       	lddpc	r8,800059d4 <_tc_interrupt+0x18>
800059c0:	70 09       	ld.w	r9,r8[0x0]
800059c2:	2f f9       	sub	r9,-1
800059c4:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
800059c6:	30 1b       	mov	r11,1
800059c8:	fe 7c 38 00 	mov	r12,-51200
800059cc:	f0 1f 00 03 	mcall	800059d8 <_tc_interrupt+0x1c>
	
}
800059d0:	d4 02       	popm	lr
800059d2:	d6 03       	rete
800059d4:	00 00       	add	r0,r0
800059d6:	10 84       	andn	r4,r8
800059d8:	80 00       	ld.sh	r0,r0[0x0]
800059da:	5d 74       	*unknown*

800059dc <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800059dc:	c0 08       	rjmp	800059dc <_unhandled_interrupt>
800059de:	d7 03       	nop

800059e0 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800059e0:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800059e4:	49 99       	lddpc	r9,80005a48 <INTC_register_interrupt+0x68>
800059e6:	f2 08 00 39 	add	r9,r9,r8<<0x3
800059ea:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800059ee:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800059f0:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800059f4:	58 0a       	cp.w	r10,0
800059f6:	c0 91       	brne	80005a08 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800059f8:	49 59       	lddpc	r9,80005a4c <INTC_register_interrupt+0x6c>
800059fa:	49 6a       	lddpc	r10,80005a50 <INTC_register_interrupt+0x70>
800059fc:	12 1a       	sub	r10,r9
800059fe:	fe 79 08 00 	mov	r9,-63488
80005a02:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005a06:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005a08:	58 1a       	cp.w	r10,1
80005a0a:	c0 a1       	brne	80005a1e <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80005a0c:	49 09       	lddpc	r9,80005a4c <INTC_register_interrupt+0x6c>
80005a0e:	49 2a       	lddpc	r10,80005a54 <INTC_register_interrupt+0x74>
80005a10:	12 1a       	sub	r10,r9
80005a12:	bf aa       	sbr	r10,0x1e
80005a14:	fe 79 08 00 	mov	r9,-63488
80005a18:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005a1c:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80005a1e:	58 2a       	cp.w	r10,2
80005a20:	c0 a1       	brne	80005a34 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005a22:	48 b9       	lddpc	r9,80005a4c <INTC_register_interrupt+0x6c>
80005a24:	48 da       	lddpc	r10,80005a58 <INTC_register_interrupt+0x78>
80005a26:	12 1a       	sub	r10,r9
80005a28:	bf ba       	sbr	r10,0x1f
80005a2a:	fe 79 08 00 	mov	r9,-63488
80005a2e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005a32:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005a34:	48 69       	lddpc	r9,80005a4c <INTC_register_interrupt+0x6c>
80005a36:	48 aa       	lddpc	r10,80005a5c <INTC_register_interrupt+0x7c>
80005a38:	12 1a       	sub	r10,r9
80005a3a:	ea 1a c0 00 	orh	r10,0xc000
80005a3e:	fe 79 08 00 	mov	r9,-63488
80005a42:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005a46:	5e fc       	retal	r12
80005a48:	80 01       	ld.sh	r1,r0[0x0]
80005a4a:	8a bc       	ld.uh	r12,r5[0x6]
80005a4c:	80 00       	ld.sh	r0,r0[0x0]
80005a4e:	fc 00       	*unknown*
80005a50:	80 00       	ld.sh	r0,r0[0x0]
80005a52:	fd 04 80 00 	ld.sh	r4,lr[-32768]
80005a56:	fd 12 80 00 	ld.uh	r2,lr[-32768]
80005a5a:	fd 20 80 00 	ld.sb	r0,lr[-32768]
80005a5e:	fd 2e d4 21 	ld.sb	lr,lr[-11231]

80005a60 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80005a60:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005a62:	49 18       	lddpc	r8,80005aa4 <INTC_init_interrupts+0x44>
80005a64:	e3 b8 00 01 	mtsr	0x4,r8
80005a68:	49 0e       	lddpc	lr,80005aa8 <INTC_init_interrupts+0x48>
80005a6a:	30 07       	mov	r7,0
80005a6c:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005a6e:	49 0c       	lddpc	r12,80005aac <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005a70:	49 05       	lddpc	r5,80005ab0 <INTC_init_interrupts+0x50>
80005a72:	10 15       	sub	r5,r8
80005a74:	fe 76 08 00 	mov	r6,-63488
80005a78:	c1 08       	rjmp	80005a98 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005a7a:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005a7c:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005a7e:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005a80:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005a84:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005a86:	10 3a       	cp.w	r10,r8
80005a88:	fe 9b ff fc 	brhi	80005a80 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005a8c:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005a90:	2f f7       	sub	r7,-1
80005a92:	2f 8e       	sub	lr,-8
80005a94:	59 37       	cp.w	r7,19
80005a96:	c0 50       	breq	80005aa0 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005a98:	7c 08       	ld.w	r8,lr[0x0]
80005a9a:	58 08       	cp.w	r8,0
80005a9c:	ce f1       	brne	80005a7a <INTC_init_interrupts+0x1a>
80005a9e:	cf 7b       	rjmp	80005a8c <INTC_init_interrupts+0x2c>
80005aa0:	d8 22       	popm	r4-r7,pc
80005aa2:	00 00       	add	r0,r0
80005aa4:	80 00       	ld.sh	r0,r0[0x0]
80005aa6:	fc 00       	*unknown*
80005aa8:	80 01       	ld.sh	r1,r0[0x0]
80005aaa:	8a bc       	ld.uh	r12,r5[0x6]
80005aac:	80 00       	ld.sh	r0,r0[0x0]
80005aae:	59 dc       	cp.w	r12,29
80005ab0:	80 00       	ld.sh	r0,r0[0x0]
80005ab2:	fd 04 fe 78 	ld.sh	r4,lr[-392]

80005ab4 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005ab4:	fe 78 08 00 	mov	r8,-63488
80005ab8:	e0 69 00 83 	mov	r9,131
80005abc:	f2 0c 01 0c 	sub	r12,r9,r12
80005ac0:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005ac4:	f2 ca ff c0 	sub	r10,r9,-64
80005ac8:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80005acc:	58 08       	cp.w	r8,0
80005ace:	c0 21       	brne	80005ad2 <_get_interrupt_handler+0x1e>
80005ad0:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005ad2:	f0 08 12 00 	clz	r8,r8
80005ad6:	48 5a       	lddpc	r10,80005ae8 <_get_interrupt_handler+0x34>
80005ad8:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005adc:	f0 08 11 1f 	rsub	r8,r8,31
80005ae0:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80005ae2:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005ae6:	5e fc       	retal	r12
80005ae8:	80 01       	ld.sh	r1,r0[0x0]
80005aea:	8a bc       	ld.uh	r12,r5[0x6]

80005aec <spi_initMaster>:

spi_status_t spi_initMaster(volatile avr32_spi_t *spi, const spi_options_t *options)
{
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (options->modfdis > 1) {
80005aec:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005af0:	30 18       	mov	r8,1
80005af2:	f0 09 18 00 	cp.b	r9,r8
80005af6:	e0 88 00 04 	brls	80005afe <spi_initMaster+0x12>
80005afa:	30 2c       	mov	r12,2
80005afc:	5e fc       	retal	r12
    return SPI_ERROR_ARGUMENT;
  }

  // Reset.
  spi->cr = AVR32_SPI_CR_SWRST_MASK;
80005afe:	e0 68 00 80 	mov	r8,128
80005b02:	99 08       	st.w	r12[0x0],r8

  // Master Mode.
  u_avr32_spi_mr.mr = spi->mr;
80005b04:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.mstr = 1;
80005b06:	30 19       	mov	r9,1
80005b08:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_spi_mr.MR.modfdis = options->modfdis;
80005b0c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005b10:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
  u_avr32_spi_mr.MR.llb = 0;
80005b14:	30 09       	mov	r9,0
80005b16:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
  u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005b1a:	30 fa       	mov	r10,15
80005b1c:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
  spi->mr = u_avr32_spi_mr.mr;
80005b20:	99 18       	st.w	r12[0x4],r8
80005b22:	5e f9       	retal	r9

80005b24 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
                               unsigned char variable_ps,
                               unsigned char pcs_decode,
                               unsigned char delay)
{
80005b24:	d4 01       	pushm	lr
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (variable_ps > 1 ||
80005b26:	30 18       	mov	r8,1
80005b28:	f0 0b 18 00 	cp.b	r11,r8
80005b2c:	5f be       	srhi	lr
80005b2e:	f0 0a 18 00 	cp.b	r10,r8
80005b32:	5f b8       	srhi	r8
80005b34:	fd e8 10 08 	or	r8,lr,r8
80005b38:	c0 30       	breq	80005b3e <spi_selectionMode+0x1a>
80005b3a:	30 2c       	mov	r12,2
80005b3c:	d8 02       	popm	pc
      pcs_decode > 1) {
    return SPI_ERROR_ARGUMENT;
  }

  u_avr32_spi_mr.mr = spi->mr;
80005b3e:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.ps = variable_ps;
80005b40:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
  u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005b44:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
  u_avr32_spi_mr.MR.dlybcs = delay;
80005b48:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
  spi->mr = u_avr32_spi_mr.mr;
80005b4c:	99 18       	st.w	r12[0x4],r8
80005b4e:	d8 0a       	popm	pc,r12=0

80005b50 <spi_selectChip>:
   */
  while (pdFALSE == xSemaphoreTake(xSPIMutex, 20));
#endif

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005b50:	78 18       	ld.w	r8,r12[0x4]
80005b52:	ea 18 00 0f 	orh	r8,0xf
80005b56:	99 18       	st.w	r12[0x4],r8

  if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005b58:	78 18       	ld.w	r8,r12[0x4]
80005b5a:	e2 18 00 04 	andl	r8,0x4,COH
80005b5e:	c0 f0       	breq	80005b7c <spi_selectChip+0x2c>
    // The signal is decoded; allow up to 15 chips.
    if (chip > 14) {
80005b60:	30 e8       	mov	r8,14
80005b62:	f0 0b 18 00 	cp.b	r11,r8
80005b66:	e0 8b 00 19 	brhi	80005b98 <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~AVR32_SPI_MR_PCS_MASK | (chip << AVR32_SPI_MR_PCS_OFFSET);
80005b6a:	78 18       	ld.w	r8,r12[0x4]
80005b6c:	b1 6b       	lsl	r11,0x10
80005b6e:	ea 1b ff f0 	orh	r11,0xfff0
80005b72:	e8 1b ff ff 	orl	r11,0xffff
80005b76:	10 6b       	and	r11,r8
80005b78:	99 1b       	st.w	r12[0x4],r11
80005b7a:	5e fd       	retal	0
  } else {
    if (chip > 3) {
80005b7c:	30 38       	mov	r8,3
80005b7e:	f0 0b 18 00 	cp.b	r11,r8
80005b82:	e0 8b 00 0b 	brhi	80005b98 <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005b86:	78 18       	ld.w	r8,r12[0x4]
80005b88:	2f 0b       	sub	r11,-16
80005b8a:	30 19       	mov	r9,1
80005b8c:	f2 0b 09 4b 	lsl	r11,r9,r11
80005b90:	5c db       	com	r11
80005b92:	10 6b       	and	r11,r8
80005b94:	99 1b       	st.w	r12[0x4],r11
80005b96:	5e fd       	retal	0
80005b98:	30 2c       	mov	r12,2
  }

  return SPI_OK;
}
80005b9a:	5e fc       	retal	r12

80005b9c <spi_unselectChip>:


spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
80005b9c:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005ba0:	c0 58       	rjmp	80005baa <spi_unselectChip+0xe>
    if (!timeout--) {
80005ba2:	58 08       	cp.w	r8,0
80005ba4:	c0 21       	brne	80005ba8 <spi_unselectChip+0xc>
80005ba6:	5e ff       	retal	1
80005ba8:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005baa:	78 49       	ld.w	r9,r12[0x10]
80005bac:	e2 19 02 00 	andl	r9,0x200,COH
80005bb0:	cf 90       	breq	80005ba2 <spi_unselectChip+0x6>
      return SPI_ERROR_TIMEOUT;
    }
  }

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005bb2:	78 18       	ld.w	r8,r12[0x4]
80005bb4:	ea 18 00 0f 	orh	r8,0xf
80005bb8:	99 18       	st.w	r12[0x4],r8

  // Last transfer, so deassert the current NPCS if CSAAT is set.
  spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005bba:	fc 18 01 00 	movh	r8,0x100
80005bbe:	99 08       	st.w	r12[0x0],r8
80005bc0:	5e fd       	retal	0

80005bc2 <spi_setupChipReg>:


spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
80005bc2:	eb cd 40 c0 	pushm	r6-r7,lr
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005bc6:	f7 38 00 0c 	ld.ub	r8,r11[12]
80005bca:	30 39       	mov	r9,3
80005bcc:	f2 08 18 00 	cp.b	r8,r9
80005bd0:	e0 8b 00 57 	brhi	80005c7e <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
80005bd4:	f7 39 00 0b 	ld.ub	r9,r11[11]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005bd8:	30 1e       	mov	lr,1
80005bda:	fc 09 18 00 	cp.b	r9,lr
80005bde:	e0 8b 00 50 	brhi	80005c7e <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
80005be2:	f7 3e 00 08 	ld.ub	lr,r11[8]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005be6:	30 77       	mov	r7,7
80005be8:	ee 0e 18 00 	cp.b	lr,r7
80005bec:	e0 88 00 49 	brls	80005c7e <spi_setupChipReg+0xbc>
80005bf0:	31 07       	mov	r7,16
80005bf2:	ee 0e 18 00 	cp.b	lr,r7
80005bf6:	e0 8b 00 44 	brhi	80005c7e <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80005bfa:	76 17       	ld.w	r7,r11[0x4]
80005bfc:	ee 06 16 01 	lsr	r6,r7,0x1
80005c00:	0c 0a       	add	r10,r6
80005c02:	f4 07 0d 06 	divu	r6,r10,r7

  if (baudDiv <= 0 || baudDiv > 255) {
80005c06:	ec c7 00 01 	sub	r7,r6,1
80005c0a:	e0 47 00 fe 	cp.w	r7,254
80005c0e:	e0 8b 00 38 	brhi	80005c7e <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80005c12:	0c 97       	mov	r7,r6
    return SPI_ERROR_ARGUMENT;
  }

  int baudDiv = getBaudDiv(options, pba_hz);

  if (baudDiv < 0) {
80005c14:	58 06       	cp.w	r6,0
80005c16:	c3 45       	brlt	80005c7e <spi_setupChipReg+0xbc>
    return SPI_ERROR_ARGUMENT;
  }

  // Will use CSR0 offsets; these are the same for CSR0 to CSR3.
  u_avr32_spi_csr.csr = 0;
80005c18:	30 0a       	mov	r10,0
  u_avr32_spi_csr.CSR.cpol = options->spi_mode >> 1;
80005c1a:	f0 06 16 01 	lsr	r6,r8,0x1
80005c1e:	f5 d6 d0 01 	bfins	r10,r6,0x0,0x1
  u_avr32_spi_csr.CSR.ncpha = (options->spi_mode & 0x1) ^ 0x1;
80005c22:	ec 18 00 01 	eorl	r8,0x1
80005c26:	f5 d8 d0 21 	bfins	r10,r8,0x1,0x1
  u_avr32_spi_csr.CSR.csaat = options->stay_act;
80005c2a:	f5 d9 d0 61 	bfins	r10,r9,0x3,0x1
  u_avr32_spi_csr.CSR.bits = options->bits - 8;
80005c2e:	20 8e       	sub	lr,8
80005c30:	f5 de d0 84 	bfins	r10,lr,0x4,0x4
  u_avr32_spi_csr.CSR.scbr = baudDiv;
80005c34:	f5 d7 d1 08 	bfins	r10,r7,0x8,0x8
  u_avr32_spi_csr.CSR.dlybs = options->spck_delay;
80005c38:	f7 38 00 09 	ld.ub	r8,r11[9]
80005c3c:	f5 d8 d2 08 	bfins	r10,r8,0x10,0x8
  u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80005c40:	f7 38 00 0a 	ld.ub	r8,r11[10]
80005c44:	f5 d8 d3 08 	bfins	r10,r8,0x18,0x8

  switch(options->reg) {
80005c48:	17 88       	ld.ub	r8,r11[0x0]
80005c4a:	30 19       	mov	r9,1
80005c4c:	f2 08 18 00 	cp.b	r8,r9
80005c50:	c0 e0       	breq	80005c6c <spi_setupChipReg+0xaa>
80005c52:	c0 a3       	brcs	80005c66 <spi_setupChipReg+0xa4>
80005c54:	30 29       	mov	r9,2
80005c56:	f2 08 18 00 	cp.b	r8,r9
80005c5a:	c0 c0       	breq	80005c72 <spi_setupChipReg+0xb0>
80005c5c:	30 39       	mov	r9,3
80005c5e:	f2 08 18 00 	cp.b	r8,r9
80005c62:	c0 e1       	brne	80005c7e <spi_setupChipReg+0xbc>
80005c64:	c0 a8       	rjmp	80005c78 <spi_setupChipReg+0xb6>
    case 0:
      spi->csr0 = u_avr32_spi_csr.csr;
80005c66:	99 ca       	st.w	r12[0x30],r10
80005c68:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 1:
      spi->csr1 = u_avr32_spi_csr.csr;
80005c6c:	99 da       	st.w	r12[0x34],r10
80005c6e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 2:
      spi->csr2 = u_avr32_spi_csr.csr;
80005c72:	99 ea       	st.w	r12[0x38],r10
80005c74:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 3:
      spi->csr3 = u_avr32_spi_csr.csr;
80005c78:	99 fa       	st.w	r12[0x3c],r10
80005c7a:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
80005c7e:	30 2c       	mov	r12,2
    }
  }
#endif

  return SPI_OK;
}
80005c80:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80005c84 <spi_enable>:


void spi_enable(volatile avr32_spi_t *spi)
{
  spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005c84:	30 18       	mov	r8,1
80005c86:	99 08       	st.w	r12[0x0],r8
}
80005c88:	5e fc       	retal	r12

80005c8a <spi_write>:
  return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}


spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
80005c8a:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005c8e:	c0 58       	rjmp	80005c98 <spi_write+0xe>
    if (!timeout--) {
80005c90:	58 08       	cp.w	r8,0
80005c92:	c0 21       	brne	80005c96 <spi_write+0xc>
80005c94:	5e ff       	retal	1
80005c96:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005c98:	78 49       	ld.w	r9,r12[0x10]
80005c9a:	e2 19 00 02 	andl	r9,0x2,COH
80005c9e:	cf 90       	breq	80005c90 <spi_write+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005ca0:	5c 7b       	castu.h	r11
80005ca2:	99 3b       	st.w	r12[0xc],r11
80005ca4:	5e fd       	retal	0

80005ca6 <spi_read>:
  return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}


spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
80005ca6:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80005caa:	c0 58       	rjmp	80005cb4 <spi_read+0xe>
         (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
    if (!timeout--) {
80005cac:	58 08       	cp.w	r8,0
80005cae:	c0 21       	brne	80005cb2 <spi_read+0xc>
80005cb0:	5e ff       	retal	1
80005cb2:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80005cb4:	78 49       	ld.w	r9,r12[0x10]
80005cb6:	e2 19 02 01 	andl	r9,0x201,COH
80005cba:	e0 49 02 01 	cp.w	r9,513
80005cbe:	cf 71       	brne	80005cac <spi_read+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  *data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005cc0:	78 28       	ld.w	r8,r12[0x8]
80005cc2:	b6 08       	st.h	r11[0x0],r8
80005cc4:	5e fd       	retal	0

80005cc6 <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80005cc6:	76 09       	ld.w	r9,r11[0x0]
80005cc8:	58 29       	cp.w	r9,2
80005cca:	e0 88 00 03 	brls	80005cd0 <tc_init_waveform+0xa>
80005cce:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80005cd0:	76 18       	ld.w	r8,r11[0x4]
80005cd2:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80005cd6:	af ba       	sbr	r10,0xf
80005cd8:	10 9b       	mov	r11,r8
80005cda:	e6 1b c0 00 	andh	r11,0xc000,COH
80005cde:	16 4a       	or	r10,r11
80005ce0:	10 9b       	mov	r11,r8
80005ce2:	e6 1b 30 00 	andh	r11,0x3000,COH
80005ce6:	16 4a       	or	r10,r11
80005ce8:	10 9b       	mov	r11,r8
80005cea:	e6 1b 0c 00 	andh	r11,0xc00,COH
80005cee:	16 4a       	or	r10,r11
80005cf0:	10 9b       	mov	r11,r8
80005cf2:	e6 1b 03 00 	andh	r11,0x300,COH
80005cf6:	16 4a       	or	r10,r11
80005cf8:	10 9b       	mov	r11,r8
80005cfa:	e6 1b 00 c0 	andh	r11,0xc0,COH
80005cfe:	16 4a       	or	r10,r11
80005d00:	10 9b       	mov	r11,r8
80005d02:	e6 1b 00 30 	andh	r11,0x30,COH
80005d06:	16 4a       	or	r10,r11
80005d08:	10 9b       	mov	r11,r8
80005d0a:	e6 1b 00 0c 	andh	r11,0xc,COH
80005d0e:	16 4a       	or	r10,r11
80005d10:	10 9b       	mov	r11,r8
80005d12:	e6 1b 00 03 	andh	r11,0x3,COH
80005d16:	16 4a       	or	r10,r11
80005d18:	10 9b       	mov	r11,r8
80005d1a:	e2 1b 60 00 	andl	r11,0x6000,COH
80005d1e:	16 4a       	or	r10,r11
80005d20:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80005d24:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80005d28:	10 9b       	mov	r11,r8
80005d2a:	e2 1b 0c 00 	andl	r11,0xc00,COH
80005d2e:	16 4a       	or	r10,r11
80005d30:	10 9b       	mov	r11,r8
80005d32:	e2 1b 03 00 	andl	r11,0x300,COH
80005d36:	16 4a       	or	r10,r11
80005d38:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80005d3c:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
80005d40:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80005d44:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80005d48:	10 9b       	mov	r11,r8
80005d4a:	e2 1b 00 30 	andl	r11,0x30,COH
80005d4e:	16 4a       	or	r10,r11
80005d50:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80005d54:	f5 e8 10 38 	or	r8,r10,r8<<0x3
80005d58:	a5 69       	lsl	r9,0x4
80005d5a:	2f f9       	sub	r9,-1
80005d5c:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80005d60:	5e fd       	retal	0

80005d62 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005d62:	58 2b       	cp.w	r11,2
80005d64:	e0 88 00 03 	brls	80005d6a <tc_start+0x8>
80005d68:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005d6a:	a7 6b       	lsl	r11,0x6
80005d6c:	16 0c       	add	r12,r11
80005d6e:	30 58       	mov	r8,5
80005d70:	99 08       	st.w	r12[0x0],r8
80005d72:	5e fd       	retal	0

80005d74 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005d74:	58 2b       	cp.w	r11,2
80005d76:	e0 88 00 03 	brls	80005d7c <tc_read_sr+0x8>
80005d7a:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80005d7c:	a7 6b       	lsl	r11,0x6
80005d7e:	2e 0b       	sub	r11,-32
80005d80:	16 0c       	add	r12,r11
80005d82:	78 0c       	ld.w	r12,r12[0x0]
}
80005d84:	5e fc       	retal	r12

80005d86 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005d86:	58 2b       	cp.w	r11,2
80005d88:	e0 88 00 03 	brls	80005d8e <tc_write_rc+0x8>
80005d8c:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80005d8e:	f6 08 15 04 	lsl	r8,r11,0x4
80005d92:	2f f8       	sub	r8,-1
80005d94:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80005d98:	e2 18 80 00 	andl	r8,0x8000,COH
80005d9c:	c0 c0       	breq	80005db4 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80005d9e:	a7 6b       	lsl	r11,0x6
80005da0:	16 0c       	add	r12,r11
80005da2:	2e 4c       	sub	r12,-28
80005da4:	78 08       	ld.w	r8,r12[0x0]
80005da6:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80005daa:	e0 18 00 00 	andl	r8,0x0
80005dae:	f3 e8 10 08 	or	r8,r9,r8
80005db2:	99 08       	st.w	r12[0x0],r8

  return value;
80005db4:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80005db8:	5e fc       	retal	r12

80005dba <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80005dba:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80005dbe:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005dc2:	58 2b       	cp.w	r11,2
80005dc4:	e0 88 00 04 	brls	80005dcc <tc_configure_interrupts+0x12>
80005dc8:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80005dcc:	ee 19 00 01 	eorh	r9,0x1
80005dd0:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80005dd4:	74 08       	ld.w	r8,r10[0x0]
80005dd6:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80005dda:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80005dde:	a7 6e       	lsl	lr,0x6
80005de0:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80005de4:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80005de8:	0e 4e       	or	lr,r7
80005dea:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80005dee:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80005df2:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80005df6:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80005dfa:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80005dfe:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80005e02:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80005e06:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80005e0a:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80005e0e:	fd e8 10 18 	or	r8,lr,r8<<0x1
80005e12:	f6 0e 15 06 	lsl	lr,r11,0x6
80005e16:	f8 0e 00 0e 	add	lr,r12,lr
80005e1a:	2d ce       	sub	lr,-36
80005e1c:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80005e1e:	58 09       	cp.w	r9,0
80005e20:	c0 20       	breq	80005e24 <tc_configure_interrupts+0x6a>
80005e22:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80005e24:	74 08       	ld.w	r8,r10[0x0]
80005e26:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80005e2a:	e0 65 00 80 	mov	r5,128
80005e2e:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80005e32:	74 08       	ld.w	r8,r10[0x0]
80005e34:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80005e38:	f9 b4 00 40 	moveq	r4,64
80005e3c:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80005e40:	74 08       	ld.w	r8,r10[0x0]
80005e42:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80005e46:	f9 b3 00 20 	moveq	r3,32
80005e4a:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80005e4e:	74 08       	ld.w	r8,r10[0x0]
80005e50:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80005e54:	f9 b2 00 10 	moveq	r2,16
80005e58:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80005e5c:	74 08       	ld.w	r8,r10[0x0]
80005e5e:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80005e62:	f9 b6 00 08 	moveq	r6,8
80005e66:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80005e6a:	74 08       	ld.w	r8,r10[0x0]
80005e6c:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80005e70:	f9 b7 00 04 	moveq	r7,4
80005e74:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80005e78:	74 08       	ld.w	r8,r10[0x0]
80005e7a:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80005e7e:	f9 be 00 02 	moveq	lr,2
80005e82:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80005e86:	74 08       	ld.w	r8,r10[0x0]
80005e88:	ec 18 00 01 	eorl	r8,0x1
80005e8c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005e90:	eb e8 10 08 	or	r8,r5,r8
80005e94:	08 48       	or	r8,r4
80005e96:	06 48       	or	r8,r3
80005e98:	04 48       	or	r8,r2
80005e9a:	0c 48       	or	r8,r6
80005e9c:	0e 48       	or	r8,r7
80005e9e:	1c 48       	or	r8,lr
80005ea0:	f6 0a 15 06 	lsl	r10,r11,0x6
80005ea4:	f8 0a 00 0a 	add	r10,r12,r10
80005ea8:	2d 8a       	sub	r10,-40
80005eaa:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80005eac:	a7 6b       	lsl	r11,0x6
80005eae:	2e 0b       	sub	r11,-32
80005eb0:	16 0c       	add	r12,r11
80005eb2:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80005eb4:	58 09       	cp.w	r9,0
80005eb6:	c0 31       	brne	80005ebc <tc_configure_interrupts+0x102>
80005eb8:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80005ebc:	d5 03       	csrf	0x10
80005ebe:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80005ec2:	d7 03       	nop

80005ec4 <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
80005ec4:	4a 78       	lddpc	r8,80005f60 <twi_master_interrupt_handler+0x9c>
80005ec6:	70 08       	ld.w	r8,r8[0x0]
80005ec8:	70 89       	ld.w	r9,r8[0x20]
80005eca:	4a 7a       	lddpc	r10,80005f64 <twi_master_interrupt_handler+0xa0>
80005ecc:	74 0a       	ld.w	r10,r10[0x0]
80005ece:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
80005ed2:	12 9a       	mov	r10,r9
80005ed4:	e2 1a 01 00 	andl	r10,0x100,COH
80005ed8:	c3 91       	brne	80005f4a <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
80005eda:	12 9a       	mov	r10,r9
80005edc:	e2 1a 00 02 	andl	r10,0x2,COH
80005ee0:	c1 70       	breq	80005f0e <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
80005ee2:	4a 29       	lddpc	r9,80005f68 <twi_master_interrupt_handler+0xa4>
80005ee4:	72 0a       	ld.w	r10,r9[0x0]
80005ee6:	70 cb       	ld.w	r11,r8[0x30]
80005ee8:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
80005eea:	72 0a       	ld.w	r10,r9[0x0]
80005eec:	2f fa       	sub	r10,-1
80005eee:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
80005ef0:	49 f9       	lddpc	r9,80005f6c <twi_master_interrupt_handler+0xa8>
80005ef2:	72 0a       	ld.w	r10,r9[0x0]
80005ef4:	20 1a       	sub	r10,1
80005ef6:	93 0a       	st.w	r9[0x0],r10
80005ef8:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
80005efa:	58 19       	cp.w	r9,1
80005efc:	f9 b9 00 02 	moveq	r9,2
80005f00:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
80005f04:	49 a9       	lddpc	r9,80005f6c <twi_master_interrupt_handler+0xa8>
80005f06:	72 09       	ld.w	r9,r9[0x0]
80005f08:	58 09       	cp.w	r9,0
80005f0a:	c2 30       	breq	80005f50 <twi_master_interrupt_handler+0x8c>
80005f0c:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
80005f0e:	12 9a       	mov	r10,r9
80005f10:	e2 1a 00 04 	andl	r10,0x4,COH
80005f14:	c1 70       	breq	80005f42 <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
80005f16:	49 79       	lddpc	r9,80005f70 <twi_master_interrupt_handler+0xac>
80005f18:	72 0a       	ld.w	r10,r9[0x0]
80005f1a:	20 1a       	sub	r10,1
80005f1c:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
80005f1e:	72 09       	ld.w	r9,r9[0x0]
80005f20:	58 09       	cp.w	r9,0
80005f22:	e0 89 00 0a 	brgt	80005f36 <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
80005f26:	49 09       	lddpc	r9,80005f64 <twi_master_interrupt_handler+0xa0>
80005f28:	30 1a       	mov	r10,1
80005f2a:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
80005f2c:	3f fa       	mov	r10,-1
80005f2e:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
80005f30:	72 09       	ld.w	r9,r9[0x0]
80005f32:	91 99       	st.w	r8[0x24],r9
80005f34:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
80005f36:	49 0a       	lddpc	r10,80005f74 <twi_master_interrupt_handler+0xb0>
80005f38:	74 09       	ld.w	r9,r10[0x0]
80005f3a:	13 3b       	ld.ub	r11,r9++
80005f3c:	91 db       	st.w	r8[0x34],r11
80005f3e:	95 09       	st.w	r10[0x0],r9
80005f40:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
80005f42:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80005f46:	c0 51       	brne	80005f50 <twi_master_interrupt_handler+0x8c>
80005f48:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
80005f4a:	30 1a       	mov	r10,1
80005f4c:	48 b9       	lddpc	r9,80005f78 <twi_master_interrupt_handler+0xb4>
80005f4e:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
80005f50:	3f f9       	mov	r9,-1
80005f52:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
80005f54:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
80005f56:	30 09       	mov	r9,0
80005f58:	48 98       	lddpc	r8,80005f7c <twi_master_interrupt_handler+0xb8>
80005f5a:	b0 89       	st.b	r8[0x0],r9
80005f5c:	d6 03       	rete
80005f5e:	00 00       	add	r0,r0
80005f60:	00 00       	add	r0,r0
80005f62:	11 3c       	ld.ub	r12,r8++
80005f64:	00 00       	add	r0,r0
80005f66:	11 38       	ld.ub	r8,r8++
80005f68:	00 00       	add	r0,r0
80005f6a:	11 48       	ld.w	r8,--r8
80005f6c:	00 00       	add	r0,r0
80005f6e:	11 44       	ld.w	r4,--r8
80005f70:	00 00       	add	r0,r0
80005f72:	11 34       	ld.ub	r4,r8++
80005f74:	00 00       	add	r0,r0
80005f76:	11 40       	ld.w	r0,--r8
80005f78:	00 00       	add	r0,r0
80005f7a:	11 31       	ld.ub	r1,r8++
80005f7c:	00 00       	add	r0,r0
80005f7e:	11 30       	ld.ub	r0,r8++

80005f80 <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
80005f80:	eb cd 40 e0 	pushm	r5-r7,lr
80005f84:	18 97       	mov	r7,r12
80005f86:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
80005f88:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
80005f8c:	49 f9       	lddpc	r9,80006008 <twi_master_init+0x88>
80005f8e:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
80005f90:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
80005f92:	3f f9       	mov	r9,-1
80005f94:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
80005f96:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
80005f98:	e0 69 00 80 	mov	r9,128
80005f9c:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80005f9e:	e6 18 00 01 	andh	r8,0x1,COH
80005fa2:	c0 21       	brne	80005fa6 <twi_master_init+0x26>
      cpu_irq_enable();
80005fa4:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
80005fa6:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80005fa8:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80005fac:	d3 03       	ssrf	0x10
	
	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();

	irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL);
80005fae:	30 3a       	mov	r10,3
80005fb0:	e0 6b 01 60 	mov	r11,352
80005fb4:	49 6c       	lddpc	r12,8000600c <twi_master_init+0x8c>
80005fb6:	f0 1f 00 17 	mcall	80006010 <twi_master_init+0x90>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80005fba:	e6 16 00 01 	andh	r6,0x1,COH
80005fbe:	c0 21       	brne	80005fc2 <twi_master_init+0x42>
      cpu_irq_enable();
80005fc0:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
80005fc2:	6a 19       	ld.w	r9,r5[0x4]
80005fc4:	a1 79       	lsl	r9,0x1
80005fc6:	6a 08       	ld.w	r8,r5[0x0]
80005fc8:	f0 09 0d 08 	divu	r8,r8,r9
80005fcc:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80005fce:	e0 48 00 ff 	cp.w	r8,255
80005fd2:	e0 8b 00 04 	brhi	80005fda <twi_master_init+0x5a>
80005fd6:	30 09       	mov	r9,0
80005fd8:	c0 f8       	rjmp	80005ff6 <twi_master_init+0x76>
80005fda:	30 09       	mov	r9,0
80005fdc:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
80005fde:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
80005fe0:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80005fe2:	e0 48 00 ff 	cp.w	r8,255
80005fe6:	5f bb       	srhi	r11
80005fe8:	58 69       	cp.w	r9,6
80005fea:	5f 8a       	srls	r10
80005fec:	f7 ea 00 0a 	and	r10,r11,r10
80005ff0:	f8 0a 18 00 	cp.b	r10,r12
80005ff4:	cf 51       	brne	80005fde <twi_master_init+0x5e>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
80005ff6:	b1 69       	lsl	r9,0x10
80005ff8:	f3 e8 10 89 	or	r9,r9,r8<<0x8
80005ffc:	f3 e8 10 08 	or	r8,r9,r8
80006000:	8f 48       	st.w	r7[0x10],r8

	//Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
80006002:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80006006:	00 00       	add	r0,r0
80006008:	00 00       	add	r0,r0
8000600a:	11 3c       	ld.ub	r12,r8++
8000600c:	80 00       	ld.sh	r0,r0[0x0]
8000600e:	5e c4       	retvs	r4
80006010:	80 00       	ld.sh	r0,r0[0x0]
80006012:	59 e0       	cp.w	r0,30

80006014 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80006014:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80006016:	f6 08 15 04 	lsl	r8,r11,0x4
8000601a:	14 38       	cp.w	r8,r10
8000601c:	f9 b8 08 10 	movls	r8,16
80006020:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80006024:	f0 0b 02 4b 	mul	r11,r8,r11
80006028:	f6 09 16 01 	lsr	r9,r11,0x1
8000602c:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80006030:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80006034:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80006038:	f2 cb 00 01 	sub	r11,r9,1
8000603c:	e0 4b ff fe 	cp.w	r11,65534
80006040:	e0 88 00 03 	brls	80006046 <usart_set_async_baudrate+0x32>
80006044:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80006046:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80006048:	e8 6e 00 00 	mov	lr,524288
8000604c:	59 08       	cp.w	r8,16
8000604e:	fc 08 17 10 	movne	r8,lr
80006052:	f9 b8 00 00 	moveq	r8,0
80006056:	e4 1b ff f7 	andh	r11,0xfff7
8000605a:	e0 1b fe cf 	andl	r11,0xfecf
8000605e:	16 48       	or	r8,r11
80006060:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80006062:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80006066:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000606a:	99 89       	st.w	r12[0x20],r9
8000606c:	d8 0a       	popm	pc,r12=0

8000606e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000606e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80006070:	e2 18 00 02 	andl	r8,0x2,COH
80006074:	c0 31       	brne	8000607a <usart_write_char+0xc>
80006076:	30 2c       	mov	r12,2
80006078:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000607a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000607e:	99 7b       	st.w	r12[0x1c],r11
80006080:	5e fd       	retal	0
80006082:	d7 03       	nop

80006084 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80006084:	eb cd 40 e0 	pushm	r5-r7,lr
80006088:	18 96       	mov	r6,r12
8000608a:	16 95       	mov	r5,r11
8000608c:	e0 67 27 0f 	mov	r7,9999
80006090:	c0 68       	rjmp	8000609c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80006092:	58 07       	cp.w	r7,0
80006094:	c0 31       	brne	8000609a <usart_putchar+0x16>
80006096:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000609a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
8000609c:	0a 9b       	mov	r11,r5
8000609e:	0c 9c       	mov	r12,r6
800060a0:	f0 1f 00 03 	mcall	800060ac <usart_putchar+0x28>
800060a4:	cf 71       	brne	80006092 <usart_putchar+0xe>

  return USART_SUCCESS;
}
800060a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800060aa:	00 00       	add	r0,r0
800060ac:	80 00       	ld.sh	r0,r0[0x0]
800060ae:	60 6e       	ld.w	lr,r0[0x18]

800060b0 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800060b0:	78 58       	ld.w	r8,r12[0x14]
800060b2:	e2 18 00 e0 	andl	r8,0xe0,COH
800060b6:	c0 30       	breq	800060bc <usart_read_char+0xc>
800060b8:	30 4c       	mov	r12,4
800060ba:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800060bc:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800060be:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800060c2:	c0 31       	brne	800060c8 <usart_read_char+0x18>
800060c4:	30 3c       	mov	r12,3
800060c6:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800060c8:	78 68       	ld.w	r8,r12[0x18]
800060ca:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800060ce:	97 08       	st.w	r11[0x0],r8
800060d0:	5e fd       	retal	0
800060d2:	d7 03       	nop

800060d4 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800060d4:	eb cd 40 c0 	pushm	r6-r7,lr
800060d8:	20 1d       	sub	sp,4
800060da:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800060dc:	1a 97       	mov	r7,sp
800060de:	1a 9b       	mov	r11,sp
800060e0:	0c 9c       	mov	r12,r6
800060e2:	f0 1f 00 07 	mcall	800060fc <usart_getchar+0x28>
800060e6:	58 3c       	cp.w	r12,3
800060e8:	cf b0       	breq	800060de <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800060ea:	58 4c       	cp.w	r12,4
800060ec:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800060f0:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800060f4:	2f fd       	sub	sp,-4
800060f6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800060fa:	00 00       	add	r0,r0
800060fc:	80 00       	ld.sh	r0,r0[0x0]
800060fe:	60 b0       	ld.w	r0,r0[0x2c]

80006100 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80006100:	eb cd 40 c0 	pushm	r6-r7,lr
80006104:	18 96       	mov	r6,r12
80006106:	16 97       	mov	r7,r11
  while (*string != '\0')
80006108:	17 8b       	ld.ub	r11,r11[0x0]
8000610a:	58 0b       	cp.w	r11,0
8000610c:	c0 80       	breq	8000611c <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
8000610e:	2f f7       	sub	r7,-1
80006110:	0c 9c       	mov	r12,r6
80006112:	f0 1f 00 04 	mcall	80006120 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80006116:	0f 8b       	ld.ub	r11,r7[0x0]
80006118:	58 0b       	cp.w	r11,0
8000611a:	cf a1       	brne	8000610e <usart_write_line+0xe>
8000611c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006120:	80 00       	ld.sh	r0,r0[0x0]
80006122:	60 84       	ld.w	r4,r0[0x20]

80006124 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80006124:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80006128:	e6 18 00 01 	andh	r8,0x1,COH
8000612c:	c0 71       	brne	8000613a <usart_reset+0x16>
8000612e:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80006130:	3f f8       	mov	r8,-1
80006132:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006134:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80006136:	d5 03       	csrf	0x10
80006138:	c0 48       	rjmp	80006140 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
8000613a:	3f f8       	mov	r8,-1
8000613c:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000613e:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80006140:	30 08       	mov	r8,0
80006142:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80006144:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80006146:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80006148:	ea 68 61 0c 	mov	r8,680204
8000614c:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
8000614e:	5e fc       	retal	r12

80006150 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80006150:	eb cd 40 e0 	pushm	r5-r7,lr
80006154:	18 96       	mov	r6,r12
80006156:	16 97       	mov	r7,r11
80006158:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000615a:	f0 1f 00 2f 	mcall	80006214 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
8000615e:	58 07       	cp.w	r7,0
80006160:	c5 80       	breq	80006210 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80006162:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006164:	30 49       	mov	r9,4
80006166:	f2 08 18 00 	cp.b	r8,r9
8000616a:	e0 88 00 53 	brls	80006210 <usart_init_rs232+0xc0>
8000616e:	30 99       	mov	r9,9
80006170:	f2 08 18 00 	cp.b	r8,r9
80006174:	e0 8b 00 4e 	brhi	80006210 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80006178:	0f d9       	ld.ub	r9,r7[0x5]
8000617a:	30 78       	mov	r8,7
8000617c:	f0 09 18 00 	cp.b	r9,r8
80006180:	e0 8b 00 48 	brhi	80006210 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80006184:	8e 39       	ld.sh	r9,r7[0x6]
80006186:	e0 68 01 01 	mov	r8,257
8000618a:	f0 09 19 00 	cp.h	r9,r8
8000618e:	e0 8b 00 41 	brhi	80006210 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80006192:	ef 39 00 08 	ld.ub	r9,r7[8]
80006196:	30 38       	mov	r8,3
80006198:	f0 09 18 00 	cp.b	r9,r8
8000619c:	e0 8b 00 3a 	brhi	80006210 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
800061a0:	0a 9a       	mov	r10,r5
800061a2:	6e 0b       	ld.w	r11,r7[0x0]
800061a4:	0c 9c       	mov	r12,r6
800061a6:	f0 1f 00 1d 	mcall	80006218 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800061aa:	58 1c       	cp.w	r12,1
800061ac:	c3 20       	breq	80006210 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
800061ae:	0f c8       	ld.ub	r8,r7[0x4]
800061b0:	30 99       	mov	r9,9
800061b2:	f2 08 18 00 	cp.b	r8,r9
800061b6:	c0 51       	brne	800061c0 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800061b8:	6c 18       	ld.w	r8,r6[0x4]
800061ba:	b1 b8       	sbr	r8,0x11
800061bc:	8d 18       	st.w	r6[0x4],r8
800061be:	c0 68       	rjmp	800061ca <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800061c0:	6c 19       	ld.w	r9,r6[0x4]
800061c2:	20 58       	sub	r8,5
800061c4:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800061c8:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800061ca:	6c 19       	ld.w	r9,r6[0x4]
800061cc:	ef 3a 00 08 	ld.ub	r10,r7[8]
800061d0:	0f d8       	ld.ub	r8,r7[0x5]
800061d2:	a9 78       	lsl	r8,0x9
800061d4:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800061d8:	12 48       	or	r8,r9
800061da:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800061dc:	8e 38       	ld.sh	r8,r7[0x6]
800061de:	30 29       	mov	r9,2
800061e0:	f2 08 19 00 	cp.h	r8,r9
800061e4:	e0 88 00 09 	brls	800061f6 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800061e8:	6c 18       	ld.w	r8,r6[0x4]
800061ea:	ad b8       	sbr	r8,0xd
800061ec:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800061ee:	8e b8       	ld.uh	r8,r7[0x6]
800061f0:	20 28       	sub	r8,2
800061f2:	8d a8       	st.w	r6[0x28],r8
800061f4:	c0 68       	rjmp	80006200 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800061f6:	6c 19       	ld.w	r9,r6[0x4]
800061f8:	5c 78       	castu.h	r8
800061fa:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800061fe:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80006200:	6c 18       	ld.w	r8,r6[0x4]
80006202:	e0 18 ff f0 	andl	r8,0xfff0
80006206:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80006208:	35 08       	mov	r8,80
8000620a:	8d 08       	st.w	r6[0x0],r8
8000620c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80006210:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80006214:	80 00       	ld.sh	r0,r0[0x0]
80006216:	61 24       	ld.w	r4,r0[0x48]
80006218:	80 00       	ld.sh	r0,r0[0x0]
8000621a:	60 14       	ld.w	r4,r0[0x4]

8000621c <disk_status>:


	return RES_OK;

	
}
8000621c:	5e fd       	retal	0

8000621e <disk_initialize>:
	//}
	//return STA_NOINIT;

	return stat;
	
}
8000621e:	5e fd       	retal	0

80006220 <get_fattime>:
	
}
#endif

DWORD get_fattime(void)
{
80006220:	d4 01       	pushm	lr
	DWORD current_time = 0;
	date_time_t *t = now();
80006222:	f0 1f 00 0e 	mcall	80006258 <get_fattime+0x38>

	current_time = (t->year - 1980) << 25;
80006226:	19 89       	ld.ub	r9,r12[0x0]
80006228:	19 98       	ld.ub	r8,r12[0x1]
8000622a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000622e:	f0 c8 07 bc 	sub	r8,r8,1980
80006232:	b9 78       	lsl	r8,0x19
	current_time += t->month << 21;
80006234:	19 aa       	ld.ub	r10,r12[0x2]
80006236:	b5 7a       	lsl	r10,0x15
80006238:	19 b9       	ld.ub	r9,r12[0x3]
8000623a:	b1 69       	lsl	r9,0x10
8000623c:	12 0a       	add	r10,r9
	current_time += t->day << 16;
8000623e:	19 f9       	ld.ub	r9,r12[0x7]
80006240:	a1 99       	lsr	r9,0x1
80006242:	12 0a       	add	r10,r9
	current_time += t->hour << 11;
80006244:	19 d9       	ld.ub	r9,r12[0x5]
80006246:	ab 79       	lsl	r9,0xb
80006248:	12 0a       	add	r10,r9
	current_time += t->minute << 5;
8000624a:	19 e9       	ld.ub	r9,r12[0x6]
8000624c:	a5 79       	lsl	r9,0x5
8000624e:	f4 09 00 0c 	add	r12,r10,r9
	current_time += t->second / 2;
	
	return current_time;
80006252:	10 0c       	add	r12,r8
80006254:	d8 02       	popm	pc
80006256:	00 00       	add	r0,r0
80006258:	80 00       	ld.sh	r0,r0[0x0]
8000625a:	58 78       	cp.w	r8,7

8000625c <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
8000625c:	eb cd 40 80 	pushm	r7,lr
80006260:	14 97       	mov	r7,r10
	
	DRESULT res = RES_OK ;
	
	switch (cmd)
80006262:	30 18       	mov	r8,1
80006264:	f0 0b 18 00 	cp.b	r11,r8
80006268:	c1 a0       	breq	8000629c <disk_ioctl+0x40>
8000626a:	58 0b       	cp.w	r11,0
8000626c:	c0 c0       	breq	80006284 <disk_ioctl+0x28>
8000626e:	30 28       	mov	r8,2
80006270:	f0 0b 18 00 	cp.b	r11,r8
80006274:	c0 a0       	breq	80006288 <disk_ioctl+0x2c>
80006276:	30 38       	mov	r8,3
80006278:	f0 0b 18 00 	cp.b	r11,r8
8000627c:	c0 b0       	breq	80006292 <disk_ioctl+0x36>
8000627e:	30 4c       	mov	r12,4
80006280:	e3 cd 80 80 	ldm	sp++,r7,pc
80006284:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
	  
			break;
	  
		case GET_SECTOR_SIZE:
		
			*(WORD*)buff = 512;
80006288:	e0 68 02 00 	mov	r8,512
8000628c:	b4 08       	st.h	r10[0x0],r8
8000628e:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		
			break;	
		
		case GET_BLOCK_SIZE:
		
			*(WORD*)buff = 512;
80006292:	e0 68 02 00 	mov	r8,512
80006296:	b4 08       	st.h	r10[0x0],r8
80006298:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		
			break;
		
		case GET_SECTOR_COUNT:
		
			*(DWORD*)buff = SD_GetSectorCount();
8000629c:	f0 1f 00 03 	mcall	800062a8 <disk_ioctl+0x4c>
800062a0:	8f 0c       	st.w	r7[0x0],r12
800062a2:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
800062a6:	00 00       	add	r0,r0
800062a8:	80 00       	ld.sh	r0,r0[0x0]
800062aa:	34 94       	mov	r4,73

800062ac <disk_write>:
	BYTE pdrv,			/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count			/* Number of sectors to write */
)
{
800062ac:	d4 01       	pushm	lr
800062ae:	16 9c       	mov	r12,r11
800062b0:	14 9b       	mov	r11,r10


	*******************************/

	
	 if(MAL_WriteDisk(buff, sector, BLOCK_BYTE_SIZE, count)==WRITE_DATA_SUCCESS)
800062b2:	5c 59       	castu.b	r9
800062b4:	e0 6a 02 00 	mov	r10,512
800062b8:	f0 1f 00 03 	mcall	800062c4 <disk_write+0x18>
800062bc:	58 4c       	cp.w	r12,4
	 return RES_ERROR;
	



}
800062be:	5f 1c       	srne	r12
800062c0:	d8 02       	popm	pc
800062c2:	00 00       	add	r0,r0
800062c4:	80 00       	ld.sh	r0,r0[0x0]
800062c6:	34 b4       	mov	r4,75

800062c8 <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
800062c8:	d4 01       	pushm	lr
800062ca:	16 9c       	mov	r12,r11
800062cc:	14 9b       	mov	r11,r10

	***********************************/

	

	if(MAL_ReadDisk(buff, sector, BLOCK_BYTE_SIZE, count)==READ_DATA_SUCCESS)
800062ce:	5c 59       	castu.b	r9
800062d0:	e0 6a 02 00 	mov	r10,512
800062d4:	f0 1f 00 03 	mcall	800062e0 <disk_read+0x18>
800062d8:	58 8c       	cp.w	r12,8
   		return RES_ERROR;




}
800062da:	5f 1c       	srne	r12
800062dc:	d8 02       	popm	pc
800062de:	00 00       	add	r0,r0
800062e0:	80 00       	ld.sh	r0,r0[0x0]
800062e2:	34 e4       	mov	r4,78

800062e4 <mem_cpy>:
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
800062e4:	58 0a       	cp.w	r10,0
800062e6:	5e 0c       	reteq	r12
800062e8:	30 08       	mov	r8,0
		*d++ = *s++;
800062ea:	f6 08 07 09 	ld.ub	r9,r11[r8]
800062ee:	f8 08 0b 09 	st.b	r12[r8],r9
800062f2:	2f f8       	sub	r8,-1
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
800062f4:	14 38       	cp.w	r8,r10
800062f6:	cf a1       	brne	800062ea <mem_cpy+0x6>
800062f8:	5e fc       	retal	r12

800062fa <mem_set>:
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
800062fa:	58 0a       	cp.w	r10,0
800062fc:	5e 0c       	reteq	r12
		*d++ = (BYTE)val;
800062fe:	18 cb       	st.b	r12++,r11
80006300:	20 1a       	sub	r10,1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
80006302:	cf e1       	brne	800062fe <mem_set+0x4>
80006304:	5e fc       	retal	r12

80006306 <chk_chr>:
	return r;
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
80006306:	18 98       	mov	r8,r12
	while (*str && *str != chr) str++;
80006308:	19 8c       	ld.ub	r12,r12[0x0]
8000630a:	58 0c       	cp.w	r12,0
8000630c:	5e 0c       	reteq	r12
8000630e:	16 3c       	cp.w	r12,r11
80006310:	5e 0c       	reteq	r12
80006312:	2f f8       	sub	r8,-1
80006314:	11 8c       	ld.ub	r12,r8[0x0]
80006316:	58 0c       	cp.w	r12,0
80006318:	5e 0c       	reteq	r12
8000631a:	16 3c       	cp.w	r12,r11
8000631c:	cf b1       	brne	80006312 <chk_chr+0xc>
	return *str;
}
8000631e:	5e fc       	retal	r12

80006320 <clust2sect>:
DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
80006320:	20 2b       	sub	r11,2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
80006322:	78 58       	ld.w	r8,r12[0x14]
80006324:	20 28       	sub	r8,2
80006326:	10 3b       	cp.w	r11,r8
80006328:	c0 23       	brcs	8000632c <clust2sect+0xc>
8000632a:	5e fd       	retal	0
	return clst * fs->csize + fs->database;
8000632c:	19 a8       	ld.ub	r8,r12[0x2]
8000632e:	b1 3b       	mul	r11,r8
80006330:	78 a8       	ld.w	r8,r12[0x28]
80006332:	f6 08 00 0c 	add	r12,r11,r8
}
80006336:	5e fc       	retal	r12

80006338 <clmt_clust>:
)
{
	DWORD cl, ncl, *tbl;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
80006338:	78 9a       	ld.w	r10,r12[0x24]
8000633a:	2f ca       	sub	r10,-4
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
8000633c:	78 08       	ld.w	r8,r12[0x0]
8000633e:	11 a8       	ld.ub	r8,r8[0x2]
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
80006340:	74 0c       	ld.w	r12,r10[0x0]
		if (!ncl) return 0;		/* End of table? (error) */
80006342:	58 0c       	cp.w	r12,0
80006344:	c1 80       	breq	80006374 <clmt_clust+0x3c>
{
	DWORD cl, ncl, *tbl;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
80006346:	f6 09 16 09 	lsr	r9,r11,0x9
8000634a:	f2 08 0d 08 	divu	r8,r9,r8
8000634e:	10 99       	mov	r9,r8
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
80006350:	2f ca       	sub	r10,-4
		if (!ncl) return 0;		/* End of table? (error) */
		if (cl < ncl) break;	/* In this fragment? */
80006352:	18 38       	cp.w	r8,r12
80006354:	c0 82       	brcc	80006364 <clmt_clust+0x2c>
80006356:	c0 b8       	rjmp	8000636c <clmt_clust+0x34>
		cl -= ncl; tbl++;		/* Next fragment */
80006358:	18 19       	sub	r9,r12
/* FAT handling - Convert offset into cluster with link map table        */
/*-----------------------------------------------------------------------*/

#if _USE_FASTSEEK
static
DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
8000635a:	2f 8a       	sub	r10,-8
	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
		if (!ncl) return 0;		/* End of table? (error) */
		if (cl < ncl) break;	/* In this fragment? */
8000635c:	12 38       	cp.w	r8,r9
8000635e:	e0 8b 00 07 	brhi	8000636c <clmt_clust+0x34>
80006362:	10 9c       	mov	r12,r8


	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
80006364:	74 18       	ld.w	r8,r10[0x4]
		if (!ncl) return 0;		/* End of table? (error) */
80006366:	58 08       	cp.w	r8,0
80006368:	cf 81       	brne	80006358 <clmt_clust+0x20>
8000636a:	c0 58       	rjmp	80006374 <clmt_clust+0x3c>
		if (cl < ncl) break;	/* In this fragment? */
		cl -= ncl; tbl++;		/* Next fragment */
	}
	return cl + *tbl;	/* Return the cluster number */
8000636c:	74 0c       	ld.w	r12,r10[0x0]
8000636e:	f2 0c 00 0c 	add	r12,r9,r12
80006372:	5e fc       	retal	r12
80006374:	5e fd       	retal	0

80006376 <ld_clust>:
	const BYTE* dir	/* Pointer to the SFN entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir + DIR_FstClusLO);
80006376:	f7 39 00 1b 	ld.ub	r9,r11[27]
8000637a:	f7 38 00 1a 	ld.ub	r8,r11[26]
8000637e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	if (fs->fs_type == FS_FAT32)
80006382:	19 8a       	ld.ub	r10,r12[0x0]
80006384:	30 39       	mov	r9,3
80006386:	f2 0a 18 00 	cp.b	r10,r9
8000638a:	c0 91       	brne	8000639c <ld_clust+0x26>
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
8000638c:	f7 3a 00 15 	ld.ub	r10,r11[21]
80006390:	f7 39 00 14 	ld.ub	r9,r11[20]
80006394:	f3 ea 10 89 	or	r9,r9,r10<<0x8
80006398:	f1 e9 11 08 	or	r8,r8,r9<<0x10

	return cl;
}
8000639c:	5e f8       	retal	r8

8000639e <st_clust>:
void st_clust (
	BYTE* dir,	/* Pointer to the SFN entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
8000639e:	f9 6b 00 1a 	st.b	r12[26],r11
800063a2:	f1 db c1 08 	bfextu	r8,r11,0x8,0x8
800063a6:	f9 68 00 1b 	st.b	r12[27],r8
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
800063aa:	b1 8b       	lsr	r11,0x10
800063ac:	f9 6b 00 14 	st.b	r12[20],r11
800063b0:	a9 8b       	lsr	r11,0x8
800063b2:	f9 6b 00 15 	st.b	r12[21],r11
}
800063b6:	5e fc       	retal	r12

800063b8 <get_ldnumber>:

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
800063b8:	d4 21       	pushm	r4-r7,lr
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
800063ba:	78 05       	ld.w	r5,r12[0x0]
800063bc:	58 05       	cp.w	r5,0
800063be:	c5 50       	breq	80006468 <get_ldnumber+0xb0>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
800063c0:	0b 84       	ld.ub	r4,r5[0x0]
800063c2:	32 08       	mov	r8,32
800063c4:	f0 04 18 00 	cp.b	r4,r8
800063c8:	5f b9       	srhi	r9
800063ca:	33 a8       	mov	r8,58
800063cc:	f0 04 18 00 	cp.b	r4,r8
800063d0:	5f 18       	srne	r8
800063d2:	f3 e8 00 08 	and	r8,r9,r8
800063d6:	c0 41       	brne	800063de <get_ldnumber+0x26>
800063d8:	08 99       	mov	r9,r4
800063da:	0a 98       	mov	r8,r5
800063dc:	c1 28       	rjmp	80006400 <get_ldnumber+0x48>
800063de:	0a 98       	mov	r8,r5
800063e0:	32 06       	mov	r6,32
800063e2:	33 a7       	mov	r7,58
800063e4:	30 0e       	mov	lr,0
800063e6:	2f f8       	sub	r8,-1
800063e8:	11 89       	ld.ub	r9,r8[0x0]
800063ea:	ec 09 18 00 	cp.b	r9,r6
800063ee:	5f bb       	srhi	r11
800063f0:	ee 09 18 00 	cp.b	r9,r7
800063f4:	5f 1a       	srne	r10
800063f6:	f7 ea 00 0a 	and	r10,r11,r10
800063fa:	fc 0a 18 00 	cp.b	r10,lr
800063fe:	cf 41       	brne	800063e6 <get_ldnumber+0x2e>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
80006400:	33 aa       	mov	r10,58
80006402:	f4 09 18 00 	cp.b	r9,r10
80006406:	c0 30       	breq	8000640c <get_ldnumber+0x54>
80006408:	30 04       	mov	r4,0
8000640a:	c3 08       	rjmp	8000646a <get_ldnumber+0xb2>
			tp = *path;
			i = *tp++ - '0'; 
8000640c:	23 04       	sub	r4,48
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
8000640e:	58 94       	cp.w	r4,9
80006410:	5f 8a       	srls	r10
80006412:	ea c9 ff ff 	sub	r9,r5,-1
80006416:	12 38       	cp.w	r8,r9
80006418:	5f 09       	sreq	r9
8000641a:	f5 e9 00 09 	and	r9,r10,r9
8000641e:	c0 60       	breq	8000642a <get_ldnumber+0x72>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
80006420:	58 04       	cp.w	r4,0
80006422:	c2 31       	brne	80006468 <get_ldnumber+0xb0>
					vol = (int)i;
					*path = ++tt;
80006424:	2f f8       	sub	r8,-1
80006426:	99 08       	st.w	r12[0x0],r8
80006428:	c2 18       	rjmp	8000646a <get_ldnumber+0xb2>
				}
			}
#if _STR_VOLUME_ID
			 else {	/* No numeric drive number, find string drive id */
				i = 0; tt++;
8000642a:	2f f8       	sub	r8,-1
				do {
					sp = str[i]; tp = *path;
8000642c:	49 17       	lddpc	r7,80006470 <get_ldnumber+0xb8>
					do {	/* Compare a string drive id with path name */
						c = *sp++; tc = *tp++;
						if (IsLower(tc)) tc -= 0x20;
8000642e:	31 96       	mov	r6,25
					} while (c && (TCHAR)c == tc);
80006430:	30 0e       	mov	lr,0
			 else {	/* No numeric drive number, find string drive id */
				i = 0; tt++;
				do {
					sp = str[i]; tp = *path;
					do {	/* Compare a string drive id with path name */
						c = *sp++; tc = *tp++;
80006432:	0f 3a       	ld.ub	r10,r7++
80006434:	0b 39       	ld.ub	r9,r5++
						if (IsLower(tc)) tc -= 0x20;
80006436:	f2 cb 00 61 	sub	r11,r9,97
8000643a:	ec 0b 18 00 	cp.b	r11,r6
8000643e:	e0 8b 00 03 	brhi	80006444 <get_ldnumber+0x8c>
80006442:	22 09       	sub	r9,32
					} while (c && (TCHAR)c == tc);
80006444:	fc 0a 18 00 	cp.b	r10,lr
80006448:	5f 1b       	srne	r11
8000644a:	f2 0a 18 00 	cp.b	r10,r9
8000644e:	5f 09       	sreq	r9
80006450:	f7 e9 00 09 	and	r9,r11,r9
80006454:	fc 09 18 00 	cp.b	r9,lr
80006458:	ce d1       	brne	80006432 <get_ldnumber+0x7a>
				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
8000645a:	10 35       	cp.w	r5,r8
8000645c:	5f 19       	srne	r9
8000645e:	12 4b       	or	r11,r9
80006460:	c0 41       	brne	80006468 <get_ldnumber+0xb0>
					vol = (int)i;
					*path = tt;
80006462:	99 08       	st.w	r12[0x0],r8
80006464:	30 04       	mov	r4,0
80006466:	c0 28       	rjmp	8000646a <get_ldnumber+0xb2>
80006468:	3f f4       	mov	r4,-1
#else
		vol = 0;		/* Drive 0 */
#endif
	}
	return vol;
}
8000646a:	08 9c       	mov	r12,r4
8000646c:	d8 22       	popm	r4-r7,pc
8000646e:	00 00       	add	r0,r0
80006470:	80 01       	ld.sh	r1,r0[0x0]
80006472:	8b 80       	st.w	r5[0x20],r0

80006474 <sync_window>:
#if !_FS_READONLY
static
FRESULT sync_window (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
80006474:	eb cd 40 f8 	pushm	r3-r7,lr
80006478:	18 97       	mov	r7,r12
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
8000647a:	19 c9       	ld.ub	r9,r12[0x4]
8000647c:	30 08       	mov	r8,0
8000647e:	f0 09 18 00 	cp.b	r9,r8
80006482:	c2 60       	breq	800064ce <sync_window+0x5a>
		wsect = fs->winsect;	/* Current sector number */
80006484:	78 b6       	ld.w	r6,r12[0x2c]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
80006486:	f8 c4 ff d0 	sub	r4,r12,-48
8000648a:	30 19       	mov	r9,1
8000648c:	0c 9a       	mov	r10,r6
8000648e:	08 9b       	mov	r11,r4
80006490:	19 9c       	ld.ub	r12,r12[0x1]
80006492:	f0 1f 00 11 	mcall	800064d4 <sync_window+0x60>
80006496:	c0 30       	breq	8000649c <sync_window+0x28>
80006498:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
8000649c:	30 08       	mov	r8,0
8000649e:	ae c8       	st.b	r7[0x4],r8
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
800064a0:	6e 89       	ld.w	r9,r7[0x20]
800064a2:	ec 09 01 09 	sub	r9,r6,r9
800064a6:	6e 68       	ld.w	r8,r7[0x18]
800064a8:	10 39       	cp.w	r9,r8
800064aa:	c1 22       	brcc	800064ce <sync_window+0x5a>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
800064ac:	0f b5       	ld.ub	r5,r7[0x3]
800064ae:	58 15       	cp.w	r5,1
800064b0:	e0 88 00 0f 	brls	800064ce <sync_window+0x5a>
					wsect += fs->fsize;
					disk_write(fs->drv, fs->win, wsect, 1);
800064b4:	30 13       	mov	r3,1
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
					wsect += fs->fsize;
800064b6:	6e 68       	ld.w	r8,r7[0x18]
800064b8:	10 06       	add	r6,r8
					disk_write(fs->drv, fs->win, wsect, 1);
800064ba:	06 99       	mov	r9,r3
800064bc:	0c 9a       	mov	r10,r6
800064be:	08 9b       	mov	r11,r4
800064c0:	0f 9c       	ld.ub	r12,r7[0x1]
800064c2:	f0 1f 00 05 	mcall	800064d4 <sync_window+0x60>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
800064c6:	20 15       	sub	r5,1
800064c8:	58 15       	cp.w	r5,1
800064ca:	fe 9b ff f6 	brhi	800064b6 <sync_window+0x42>
800064ce:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800064d2:	00 00       	add	r0,r0
800064d4:	80 00       	ld.sh	r0,r0[0x0]
800064d6:	62 ac       	ld.w	r12,r1[0x28]

800064d8 <sync_fs>:
#if !_FS_READONLY
static
FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
800064d8:	eb cd 40 e0 	pushm	r5-r7,lr
800064dc:	18 96       	mov	r6,r12
	FRESULT res;


	res = sync_window(fs);
800064de:	f0 1f 00 31 	mcall	800065a0 <sync_fs+0xc8>
800064e2:	18 97       	mov	r7,r12
	if (res == FR_OK) {
800064e4:	c5 a1       	brne	80006598 <sync_fs+0xc0>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
800064e6:	0d 89       	ld.ub	r9,r6[0x0]
800064e8:	30 38       	mov	r8,3
800064ea:	f0 09 18 00 	cp.b	r9,r8
800064ee:	c4 e1       	brne	8000658a <sync_fs+0xb2>
800064f0:	0d d9       	ld.ub	r9,r6[0x5]
800064f2:	30 18       	mov	r8,1
800064f4:	f0 09 18 00 	cp.b	r9,r8
800064f8:	c4 91       	brne	8000658a <sync_fs+0xb2>
			/* Create FSInfo structure */
			mem_set(fs->win, 0, SS(fs));
800064fa:	ec c5 ff d0 	sub	r5,r6,-48
800064fe:	e0 6a 02 00 	mov	r10,512
80006502:	30 0b       	mov	r11,0
80006504:	0a 9c       	mov	r12,r5
80006506:	f0 1f 00 28 	mcall	800065a4 <sync_fs+0xcc>
			ST_WORD(fs->win + BS_55AA, 0xAA55);
8000650a:	35 58       	mov	r8,85
8000650c:	ed 68 02 2e 	st.b	r6[558],r8
80006510:	3a a8       	mov	r8,-86
80006512:	ed 68 02 2f 	st.b	r6[559],r8
			ST_DWORD(fs->win + FSI_LeadSig, 0x41615252);
80006516:	35 28       	mov	r8,82
80006518:	ed 68 00 30 	st.b	r6[48],r8
8000651c:	ed 68 00 31 	st.b	r6[49],r8
80006520:	36 18       	mov	r8,97
80006522:	ed 68 00 32 	st.b	r6[50],r8
80006526:	34 19       	mov	r9,65
80006528:	ed 69 00 33 	st.b	r6[51],r9
			ST_DWORD(fs->win + FSI_StrucSig, 0x61417272);
8000652c:	37 2a       	mov	r10,114
8000652e:	ed 6a 02 14 	st.b	r6[532],r10
80006532:	ed 6a 02 15 	st.b	r6[533],r10
80006536:	ed 69 02 16 	st.b	r6[534],r9
8000653a:	ed 68 02 17 	st.b	r6[535],r8
			ST_DWORD(fs->win + FSI_Free_Count, fs->free_clust);
8000653e:	6c 48       	ld.w	r8,r6[0x10]
80006540:	ed 68 02 18 	st.b	r6[536],r8
80006544:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
80006548:	ed 69 02 19 	st.b	r6[537],r9
8000654c:	f0 09 16 10 	lsr	r9,r8,0x10
80006550:	ed 69 02 1a 	st.b	r6[538],r9
80006554:	b9 88       	lsr	r8,0x18
80006556:	ed 68 02 1b 	st.b	r6[539],r8
			ST_DWORD(fs->win + FSI_Nxt_Free, fs->last_clust);
8000655a:	6c 38       	ld.w	r8,r6[0xc]
8000655c:	ed 68 02 1c 	st.b	r6[540],r8
80006560:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
80006564:	ed 69 02 1d 	st.b	r6[541],r9
80006568:	f0 09 16 10 	lsr	r9,r8,0x10
8000656c:	ed 69 02 1e 	st.b	r6[542],r9
80006570:	b9 88       	lsr	r8,0x18
80006572:	ed 68 02 1f 	st.b	r6[543],r8
			/* Write it into the FSInfo sector */
			fs->winsect = fs->volbase + 1;
80006576:	6c 7a       	ld.w	r10,r6[0x1c]
80006578:	2f fa       	sub	r10,-1
8000657a:	8d ba       	st.w	r6[0x2c],r10
			disk_write(fs->drv, fs->win, fs->winsect, 1);
8000657c:	30 19       	mov	r9,1
8000657e:	0a 9b       	mov	r11,r5
80006580:	0d 9c       	ld.ub	r12,r6[0x1]
80006582:	f0 1f 00 0a 	mcall	800065a8 <sync_fs+0xd0>
			fs->fsi_flag = 0;
80006586:	30 08       	mov	r8,0
80006588:	ac d8       	st.b	r6[0x5],r8
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
8000658a:	30 0a       	mov	r10,0
8000658c:	14 9b       	mov	r11,r10
8000658e:	0d 9c       	ld.ub	r12,r6[0x1]
80006590:	f0 1f 00 07 	mcall	800065ac <sync_fs+0xd4>
80006594:	f9 b7 01 01 	movne	r7,1
			res = FR_DISK_ERR;
	}

	return res;
}
80006598:	0e 9c       	mov	r12,r7
8000659a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000659e:	00 00       	add	r0,r0
800065a0:	80 00       	ld.sh	r0,r0[0x0]
800065a2:	64 74       	ld.w	r4,r2[0x1c]
800065a4:	80 00       	ld.sh	r0,r0[0x0]
800065a6:	62 fa       	ld.w	r10,r1[0x3c]
800065a8:	80 00       	ld.sh	r0,r0[0x0]
800065aa:	62 ac       	ld.w	r12,r1[0x28]
800065ac:	80 00       	ld.sh	r0,r0[0x0]
800065ae:	62 5c       	ld.w	r12,r1[0x14]

800065b0 <f_mkfs>:
FRESULT f_mkfs (
	const TCHAR* path,	/* Logical drive number */
	BYTE sfd,			/* Partitioning rule 0:FDISK, 1:SFD */
	UINT au				/* Size of allocation unit in unit of byte or sector */
)
{
800065b0:	d4 31       	pushm	r0-r7,lr
800065b2:	20 ad       	sub	sp,40
800065b4:	50 7c       	stdsp	sp[0x1c],r12
800065b6:	16 97       	mov	r7,r11
800065b8:	14 96       	mov	r6,r10
	DWORD eb[2];
#endif


	/* Check mounted drive and clear work area */
	if (sfd > 1) return FR_INVALID_PARAMETER;
800065ba:	30 18       	mov	r8,1
800065bc:	f0 0b 18 00 	cp.b	r11,r8
800065c0:	e0 88 00 05 	brls	800065ca <f_mkfs+0x1a>
800065c4:	31 3c       	mov	r12,19
800065c6:	e0 8f 03 16 	bral	80006bf2 <f_mkfs+0x642>
	vol = get_ldnumber(&path);
800065ca:	fa cc ff e4 	sub	r12,sp,-28
800065ce:	f0 1f 01 8e 	mcall	80006c04 <f_mkfs+0x654>
	if (vol < 0) return FR_INVALID_DRIVE;
800065d2:	c0 44       	brge	800065da <f_mkfs+0x2a>
800065d4:	30 bc       	mov	r12,11
800065d6:	e0 8f 03 0e 	bral	80006bf2 <f_mkfs+0x642>
	fs = FatFs[vol];
800065da:	fe f8 06 2e 	ld.w	r8,pc[1582]
800065de:	f0 0c 03 25 	ld.w	r5,r8[r12<<0x2]
	if (!fs) return FR_NOT_ENABLED;
800065e2:	58 05       	cp.w	r5,0
800065e4:	c0 41       	brne	800065ec <f_mkfs+0x3c>
800065e6:	30 cc       	mov	r12,12
800065e8:	e0 8f 03 05 	bral	80006bf2 <f_mkfs+0x642>
	fs->fs_type = 0;
800065ec:	30 08       	mov	r8,0
800065ee:	aa 88       	st.b	r5[0x0],r8
	pdrv = LD2PD(vol);	/* Physical drive */
	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/

	/* Get disk statics */
	stat = disk_initialize(pdrv);
800065f0:	e9 dc c0 08 	bfextu	r4,r12,0x0,0x8
800065f4:	08 9c       	mov	r12,r4
800065f6:	f0 1f 01 86 	mcall	80006c0c <f_mkfs+0x65c>
	if (stat & STA_NOINIT) return FR_NOT_READY;
800065fa:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
800065fe:	c0 40       	breq	80006606 <f_mkfs+0x56>
80006600:	30 3c       	mov	r12,3
80006602:	e0 8f 02 f8 	bral	80006bf2 <f_mkfs+0x642>
	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
80006606:	e2 1c 00 04 	andl	r12,0x4,COH
8000660a:	c0 40       	breq	80006612 <f_mkfs+0x62>
8000660c:	30 ac       	mov	r12,10
8000660e:	e0 8f 02 f2 	bral	80006bf2 <f_mkfs+0x642>
		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
		b_vol = LD_DWORD(tbl + 8);	/* Volume start sector */
		n_vol = LD_DWORD(tbl + 12);	/* Volume size */
	} else {
		/* Create a partition in this function */
		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
80006612:	fa ca ff e0 	sub	r10,sp,-32
80006616:	30 1b       	mov	r11,1
80006618:	08 9c       	mov	r12,r4
8000661a:	f0 1f 01 7e 	mcall	80006c10 <f_mkfs+0x660>
8000661e:	e0 81 02 e7 	brne	80006bec <f_mkfs+0x63c>
80006622:	40 89       	lddsp	r9,sp[0x20]
80006624:	e0 49 00 7f 	cp.w	r9,127
80006628:	e0 88 02 e2 	brls	80006bec <f_mkfs+0x63c>
			return FR_DISK_ERR;
		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
8000662c:	58 07       	cp.w	r7,0
8000662e:	f9 b1 01 00 	movne	r1,0
80006632:	f9 b1 00 3f 	moveq	r1,63
		n_vol -= b_vol;				/* Volume size */
80006636:	02 19       	sub	r9,r1
80006638:	50 89       	stdsp	sp[0x20],r9
	}

	if (au & (au - 1)) au = 0;
8000663a:	ec c8 00 01 	sub	r8,r6,1
8000663e:	0c 68       	and	r8,r6
80006640:	c0 31       	brne	80006646 <f_mkfs+0x96>
	if (!au) {						/* AU auto selection */
80006642:	58 06       	cp.w	r6,0
80006644:	c1 a1       	brne	80006678 <f_mkfs+0xc8>
		vs = n_vol / (2000 / (SS(fs) / 512));
80006646:	e0 6b 4d d3 	mov	r11,19923
8000664a:	ea 1b 10 62 	orh	r11,0x1062
8000664e:	f2 0b 06 4a 	mulu.d	r10,r9,r11
80006652:	f6 0c 16 07 	lsr	r12,r11,0x7
		for (i = 0; vs < vst[i]; i++) ;
80006656:	e0 4c 04 00 	cp.w	r12,1024
8000665a:	c0 33       	brcs	80006660 <f_mkfs+0xb0>
8000665c:	30 08       	mov	r8,0
8000665e:	c0 98       	rjmp	80006670 <f_mkfs+0xc0>
80006660:	fe fa 05 b4 	ld.w	r10,pc[1460]
80006664:	2f ea       	sub	r10,-2
80006666:	30 08       	mov	r8,0
80006668:	2f f8       	sub	r8,-1
8000666a:	15 2b       	ld.uh	r11,r10++
8000666c:	16 3c       	cp.w	r12,r11
8000666e:	cf d3       	brcs	80006668 <f_mkfs+0xb8>
		au = cst[i];
80006670:	fe fa 05 a8 	ld.w	r10,pc[1448]
80006674:	f4 08 05 16 	ld.uh	r6,r10[r8<<0x1]
	}
	if (au >= _MIN_SS) au /= SS(fs);	/* Number of sectors per cluster */
80006678:	e0 46 01 ff 	cp.w	r6,511
8000667c:	e0 88 00 03 	brls	80006682 <f_mkfs+0xd2>
80006680:	a9 96       	lsr	r6,0x9
	if (!au) au = 1;
80006682:	58 06       	cp.w	r6,0
80006684:	f9 b6 00 01 	moveq	r6,1
80006688:	e0 60 00 80 	mov	r0,128
8000668c:	00 36       	cp.w	r6,r0
8000668e:	ec 00 17 80 	movls	r0,r6
	if (au > 128) au = 128;

	/* Pre-compute number of clusters and FAT sub-type */
	n_clst = n_vol / au;
80006692:	f2 00 0d 0a 	divu	r10,r9,r0
80006696:	14 98       	mov	r8,r10
	fmt = FS_FAT12;
	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
80006698:	e0 4a 0f f6 	cp.w	r10,4086
8000669c:	f9 b3 03 01 	movlo	r3,1
800066a0:	f9 b3 02 02 	movhs	r3,2
	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
800066a4:	e0 4a ff f5 	cp.w	r10,65525
800066a8:	e0 88 00 04 	brls	800066b0 <f_mkfs+0x100>
800066ac:	30 33       	mov	r3,3
800066ae:	c0 58       	rjmp	800066b8 <f_mkfs+0x108>

	/* Determine offset and size of FAT structure */
	if (fmt == FS_FAT32) {
800066b0:	30 3a       	mov	r10,3
800066b2:	f4 03 18 00 	cp.b	r3,r10
800066b6:	c0 a1       	brne	800066ca <f_mkfs+0x11a>
		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
800066b8:	a3 68       	lsl	r8,0x2
800066ba:	f0 c2 fd f9 	sub	r2,r8,-519
800066be:	a9 92       	lsr	r2,0x9
800066c0:	30 0b       	mov	r11,0
800066c2:	50 2b       	stdsp	sp[0x8],r11
800066c4:	32 0a       	mov	r10,32
800066c6:	50 0a       	stdsp	sp[0x0],r10
800066c8:	c1 68       	rjmp	800066f4 <f_mkfs+0x144>
		n_rsv = 32;
		n_dir = 0;
	} else {
		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
800066ca:	30 1a       	mov	r10,1
800066cc:	f4 03 18 00 	cp.b	r3,r10
800066d0:	c0 81       	brne	800066e0 <f_mkfs+0x130>
800066d2:	f0 08 00 18 	add	r8,r8,r8<<0x1
800066d6:	f0 c2 ff ff 	sub	r2,r8,-1
800066da:	a1 92       	lsr	r2,0x1
800066dc:	2f d2       	sub	r2,-3
800066de:	c0 48       	rjmp	800066e6 <f_mkfs+0x136>
800066e0:	2f e8       	sub	r8,-2
800066e2:	f0 02 15 01 	lsl	r2,r8,0x1
		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
800066e6:	e4 c2 fe 01 	sub	r2,r2,-511
800066ea:	a9 92       	lsr	r2,0x9
800066ec:	32 08       	mov	r8,32
800066ee:	50 28       	stdsp	sp[0x8],r8
800066f0:	30 1c       	mov	r12,1
800066f2:	50 0c       	stdsp	sp[0x0],r12
		n_rsv = 1;
		n_dir = (DWORD)N_ROOTDIR * SZ_DIRE / SS(fs);
	}
	b_fat = b_vol + n_rsv;				/* FAT area start sector */
800066f4:	40 0b       	lddsp	r11,sp[0x0]
800066f6:	02 0b       	add	r11,r1
800066f8:	50 1b       	stdsp	sp[0x4],r11
	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
	b_data = b_dir + n_dir;				/* Data area start sector */
800066fa:	40 26       	lddsp	r6,sp[0x8]
800066fc:	04 06       	add	r6,r2
800066fe:	16 06       	add	r6,r11
	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
80006700:	e0 01 01 08 	sub	r8,r0,r1
80006704:	0c 08       	add	r8,r6
80006706:	10 39       	cp.w	r9,r8
80006708:	e0 83 02 74 	brlo	80006bf0 <f_mkfs+0x640>

	/* Align data start sector to erase block boundary (for flash memory media) */
	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
8000670c:	fa ca ff dc 	sub	r10,sp,-36
80006710:	30 3b       	mov	r11,3
80006712:	08 9c       	mov	r12,r4
80006714:	f0 1f 01 3f 	mcall	80006c10 <f_mkfs+0x660>
80006718:	c0 81       	brne	80006728 <f_mkfs+0x178>
8000671a:	40 98       	lddsp	r8,sp[0x24]
8000671c:	58 08       	cp.w	r8,0
8000671e:	c0 50       	breq	80006728 <f_mkfs+0x178>
80006720:	e0 48 80 00 	cp.w	r8,32768
80006724:	e0 88 00 04 	brls	8000672c <f_mkfs+0x17c>
80006728:	30 18       	mov	r8,1
8000672a:	50 98       	stdsp	sp[0x24],r8
	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
8000672c:	40 98       	lddsp	r8,sp[0x24]
	n = (n - b_data) / N_FATS;
8000672e:	f0 c9 00 01 	sub	r9,r8,1
80006732:	0c 09       	add	r9,r6
80006734:	5c 38       	neg	r8
80006736:	f3 e8 00 08 	and	r8,r9,r8
8000673a:	f0 06 01 06 	sub	r6,r8,r6
8000673e:	50 96       	stdsp	sp[0x24],r6
	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
80006740:	30 38       	mov	r8,3
80006742:	f0 03 18 00 	cp.b	r3,r8
80006746:	c1 d1       	brne	80006780 <f_mkfs+0x1d0>
		n_rsv += n;
80006748:	40 0a       	lddsp	r10,sp[0x0]
8000674a:	0c 0a       	add	r10,r6
8000674c:	50 0a       	stdsp	sp[0x0],r10
		b_fat += n;
8000674e:	40 19       	lddsp	r9,sp[0x4]
80006750:	0c 09       	add	r9,r6
80006752:	50 19       	stdsp	sp[0x4],r9
	} else {					/* FAT12/16: Expand FAT size */
		n_fat += n;
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
80006754:	40 88       	lddsp	r8,sp[0x20]
80006756:	f0 0a 01 0b 	sub	r11,r8,r10
8000675a:	04 1b       	sub	r11,r2
8000675c:	40 2c       	lddsp	r12,sp[0x8]
8000675e:	18 1b       	sub	r11,r12
80006760:	f6 00 0d 0a 	divu	r10,r11,r0
80006764:	50 4a       	stdsp	sp[0x10],r10
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
80006766:	30 39       	mov	r9,3
80006768:	f2 03 18 00 	cp.b	r3,r9
8000676c:	5f 0b       	sreq	r11
8000676e:	50 3b       	stdsp	sp[0xc],r11
		n_fat += n;
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
80006770:	e0 4a ff f5 	cp.w	r10,65525
80006774:	5f 89       	srls	r9
80006776:	f7 e9 00 09 	and	r9,r11,r9
8000677a:	e0 81 02 3b 	brne	80006bf0 <f_mkfs+0x640>
8000677e:	c1 a8       	rjmp	800067b2 <f_mkfs+0x202>
	n = (n - b_data) / N_FATS;
	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
		n_rsv += n;
		b_fat += n;
	} else {					/* FAT12/16: Expand FAT size */
		n_fat += n;
80006780:	0c 02       	add	r2,r6
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
80006782:	40 88       	lddsp	r8,sp[0x20]
80006784:	40 0a       	lddsp	r10,sp[0x0]
80006786:	f0 0a 01 0b 	sub	r11,r8,r10
8000678a:	04 1b       	sub	r11,r2
8000678c:	40 29       	lddsp	r9,sp[0x8]
8000678e:	12 1b       	sub	r11,r9
80006790:	f6 00 0d 0a 	divu	r10,r11,r0
80006794:	50 4a       	stdsp	sp[0x10],r10
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
80006796:	30 29       	mov	r9,2
80006798:	f2 03 18 00 	cp.b	r3,r9
8000679c:	5f 0a       	sreq	r10
8000679e:	40 4c       	lddsp	r12,sp[0x10]
800067a0:	e0 4c 0f f5 	cp.w	r12,4085
800067a4:	5f 89       	srls	r9
800067a6:	f5 e9 00 09 	and	r9,r10,r9
800067aa:	e0 80 02 26 	breq	80006bf6 <f_mkfs+0x646>
800067ae:	e0 8f 02 21 	bral	80006bf0 <f_mkfs+0x640>
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
		return FR_MKFS_ABORTED;

	/* Determine system ID in the partition table */
	if (fmt == FS_FAT32) {
800067b2:	40 3b       	lddsp	r11,sp[0xc]
800067b4:	58 0b       	cp.w	r11,0
800067b6:	c0 30       	breq	800067bc <f_mkfs+0x20c>
800067b8:	30 c6       	mov	r6,12
800067ba:	c1 28       	rjmp	800067de <f_mkfs+0x22e>
		sys = 0x0C;		/* FAT32X */
	} else {
		if (fmt == FS_FAT12 && n_vol < 0x10000) {
800067bc:	30 19       	mov	r9,1
800067be:	f2 03 18 00 	cp.b	r3,r9
800067c2:	c0 71       	brne	800067d0 <f_mkfs+0x220>
800067c4:	e0 48 ff ff 	cp.w	r8,65535
800067c8:	e0 8b 00 0a 	brhi	800067dc <f_mkfs+0x22c>
800067cc:	30 16       	mov	r6,1
800067ce:	c0 88       	rjmp	800067de <f_mkfs+0x22e>
			sys = 0x01;	/* FAT12(<65536) */
		} else {
			sys = (n_vol < 0x10000) ? 0x04 : 0x06;	/* FAT16(<65536) : FAT12/16(>=65536) */
800067d0:	e0 48 ff ff 	cp.w	r8,65535
800067d4:	e0 8b 00 04 	brhi	800067dc <f_mkfs+0x22c>
800067d8:	30 46       	mov	r6,4
800067da:	c0 28       	rjmp	800067de <f_mkfs+0x22e>
800067dc:	30 66       	mov	r6,6
		tbl[4] = sys;
		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to teh MBR */
			return FR_DISK_ERR;
		md = 0xF8;
	} else {
		if (sfd) {	/* No partition table (SFD) */
800067de:	58 07       	cp.w	r7,0
800067e0:	c0 40       	breq	800067e8 <f_mkfs+0x238>
800067e2:	e0 67 00 f0 	mov	r7,240
800067e6:	c5 68       	rjmp	80006892 <f_mkfs+0x2e2>
			md = 0xF0;
		} else {	/* Create partition table (FDISK) */
			mem_set(fs->win, 0, SS(fs));
800067e8:	ea ca ff d0 	sub	r10,r5,-48
800067ec:	50 5a       	stdsp	sp[0x14],r10
800067ee:	e0 6a 02 00 	mov	r10,512
800067f2:	30 0b       	mov	r11,0
800067f4:	40 5c       	lddsp	r12,sp[0x14]
800067f6:	f0 1f 01 0a 	mcall	80006c1c <f_mkfs+0x66c>
			tbl = fs->win + MBR_Table;	/* Create partition table for single partition in the drive */
800067fa:	ea c8 fe 12 	sub	r8,r5,-494
			tbl[1] = 1;						/* Partition start head */
800067fe:	30 19       	mov	r9,1
80006800:	b0 99       	st.b	r8[0x1],r9
			tbl[2] = 1;						/* Partition start sector */
80006802:	b0 a9       	st.b	r8[0x2],r9
			tbl[3] = 0;						/* Partition start cylinder */
80006804:	30 09       	mov	r9,0
80006806:	b0 b9       	st.b	r8[0x3],r9
			tbl[4] = sys;					/* System type */
80006808:	b0 c6       	st.b	r8[0x4],r6
			tbl[5] = 254;					/* Partition end head */
8000680a:	3f ea       	mov	r10,-2
8000680c:	b0 da       	st.b	r8[0x5],r10
			n = (b_vol + n_vol) / 63 / 255;
8000680e:	40 8b       	lddsp	r11,sp[0x20]
80006810:	e2 0b 00 0b 	add	r11,r1,r11
80006814:	e0 6a 56 5b 	mov	r10,22107
80006818:	ea 1a 05 15 	orh	r10,0x515
8000681c:	f6 0a 06 46 	mulu.d	r6,r11,r10
80006820:	0e 9c       	mov	r12,r7
80006822:	f6 0c 01 0a 	sub	r10,r11,r12
80006826:	a1 9a       	lsr	r10,0x1
80006828:	f4 0c 00 07 	add	r7,r10,r12
8000682c:	ee 0a 16 0d 	lsr	r10,r7,0xd
80006830:	50 9a       	stdsp	sp[0x24],r10
			tbl[6] = (BYTE)(n >> 2 | 63);	/* Partition end sector */
80006832:	ee 0b 16 0f 	lsr	r11,r7,0xf
80006836:	16 97       	mov	r7,r11
80006838:	e8 17 00 3f 	orl	r7,0x3f
8000683c:	b0 e7       	st.b	r8[0x6],r7
			tbl[7] = (BYTE)n;				/* End cylinder */
8000683e:	40 9a       	lddsp	r10,sp[0x24]
80006840:	b0 fa       	st.b	r8[0x7],r10
			ST_DWORD(tbl + 8, 63);			/* Partition start in LBA */
80006842:	33 fa       	mov	r10,63
80006844:	f1 6a 00 08 	st.b	r8[8],r10
80006848:	f1 69 00 09 	st.b	r8[9],r9
8000684c:	f1 69 00 0a 	st.b	r8[10],r9
80006850:	f1 69 00 0b 	st.b	r8[11],r9
			ST_DWORD(tbl + 12, n_vol);		/* Partition size in LBA */
80006854:	40 89       	lddsp	r9,sp[0x20]
80006856:	f1 69 00 0c 	st.b	r8[12],r9
8000685a:	fb 39 00 22 	ld.ub	r9,sp[34]
8000685e:	f1 69 00 0d 	st.b	r8[13],r9
80006862:	fb 19 00 20 	ld.uh	r9,sp[32]
80006866:	f1 69 00 0e 	st.b	r8[14],r9
8000686a:	fb 39 00 20 	ld.ub	r9,sp[32]
8000686e:	f1 69 00 0f 	st.b	r8[15],r9
			ST_WORD(fs->win + BS_55AA, 0xAA55);	/* MBR signature */
80006872:	35 58       	mov	r8,85
80006874:	eb 68 02 2e 	st.b	r5[558],r8
80006878:	3a a8       	mov	r8,-86
8000687a:	eb 68 02 2f 	st.b	r5[559],r8
			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR */
8000687e:	30 19       	mov	r9,1
80006880:	30 0a       	mov	r10,0
80006882:	40 5b       	lddsp	r11,sp[0x14]
80006884:	08 9c       	mov	r12,r4
80006886:	f0 1f 00 e7 	mcall	80006c20 <f_mkfs+0x670>
8000688a:	e0 81 01 b1 	brne	80006bec <f_mkfs+0x63c>
8000688e:	e0 67 00 f8 	mov	r7,248
			md = 0xF8;
		}
	}

	/* Create BPB in the VBR */
	tbl = fs->win;							/* Clear sector */
80006892:	ea c6 ff d0 	sub	r6,r5,-48
	mem_set(tbl, 0, SS(fs));
80006896:	e0 6a 02 00 	mov	r10,512
8000689a:	30 0b       	mov	r11,0
8000689c:	0c 9c       	mov	r12,r6
8000689e:	f0 1f 00 e0 	mcall	80006c1c <f_mkfs+0x66c>
	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
800068a2:	30 ba       	mov	r10,11
800068a4:	fe fb 03 80 	ld.w	r11,pc[896]
800068a8:	0c 9c       	mov	r12,r6
800068aa:	f0 1f 00 e0 	mcall	80006c28 <f_mkfs+0x678>
	i = SS(fs);								/* Sector size */
	ST_WORD(tbl + BPB_BytsPerSec, i);
800068ae:	ea ca ff c5 	sub	r10,r5,-59
800068b2:	50 5a       	stdsp	sp[0x14],r10
800068b4:	30 08       	mov	r8,0
800068b6:	b4 88       	st.b	r10[0x0],r8
800068b8:	30 28       	mov	r8,2
800068ba:	ed 68 00 0c 	st.b	r6[12],r8
	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
800068be:	ed 60 00 0d 	st.b	r6[13],r0
	ST_WORD(tbl + BPB_RsvdSecCnt, n_rsv);	/* Reserved sectors */
800068c2:	40 09       	lddsp	r9,sp[0x0]
800068c4:	ed 69 00 0e 	st.b	r6[14],r9
800068c8:	f1 d9 c1 08 	bfextu	r8,r9,0x8,0x8
800068cc:	ed 68 00 0f 	st.b	r6[15],r8
	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
800068d0:	30 18       	mov	r8,1
800068d2:	ed 68 00 10 	st.b	r6[16],r8
	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of root directory entries */
800068d6:	e0 68 02 00 	mov	r8,512
800068da:	40 3c       	lddsp	r12,sp[0xc]
800068dc:	58 0c       	cp.w	r12,0
800068de:	f9 b8 01 00 	movne	r8,0
	ST_WORD(tbl + BPB_RootEntCnt, i);
800068e2:	ed 68 00 11 	st.b	r6[17],r8
800068e6:	58 08       	cp.w	r8,0
800068e8:	f9 b8 01 02 	movne	r8,2
800068ec:	f9 b8 00 00 	moveq	r8,0
800068f0:	ed 68 00 12 	st.b	r6[18],r8
	if (n_vol < 0x10000) {					/* Number of total sectors */
800068f4:	40 88       	lddsp	r8,sp[0x20]
800068f6:	e0 48 ff ff 	cp.w	r8,65535
800068fa:	e0 8b 00 09 	brhi	8000690c <f_mkfs+0x35c>
		ST_WORD(tbl + BPB_TotSec16, n_vol);
800068fe:	ed 68 00 13 	st.b	r6[19],r8
80006902:	fb 38 00 22 	ld.ub	r8,sp[34]
80006906:	ed 68 00 14 	st.b	r6[20],r8
8000690a:	c0 f8       	rjmp	80006928 <f_mkfs+0x378>
	} else {
		ST_DWORD(tbl + BPB_TotSec32, n_vol);
8000690c:	ed 68 00 20 	st.b	r6[32],r8
80006910:	fb 38 00 22 	ld.ub	r8,sp[34]
80006914:	ed 68 00 21 	st.b	r6[33],r8
80006918:	fb 18 00 20 	ld.uh	r8,sp[32]
8000691c:	ed 68 00 22 	st.b	r6[34],r8
80006920:	fb 38 00 20 	ld.ub	r8,sp[32]
80006924:	ed 68 00 23 	st.b	r6[35],r8
	}
	tbl[BPB_Media] = md;					/* Media descriptor */
80006928:	ed 67 00 15 	st.b	r6[21],r7
	ST_WORD(tbl + BPB_SecPerTrk, 63);		/* Number of sectors per track */
8000692c:	33 f8       	mov	r8,63
8000692e:	ed 68 00 18 	st.b	r6[24],r8
80006932:	30 08       	mov	r8,0
80006934:	ed 68 00 19 	st.b	r6[25],r8
	ST_WORD(tbl + BPB_NumHeads, 255);		/* Number of heads */
80006938:	3f f9       	mov	r9,-1
8000693a:	ed 69 00 1a 	st.b	r6[26],r9
8000693e:	ed 68 00 1b 	st.b	r6[27],r8
	ST_DWORD(tbl + BPB_HiddSec, b_vol);		/* Hidden sectors */
80006942:	ed 61 00 1c 	st.b	r6[28],r1
80006946:	30 08       	mov	r8,0
80006948:	ed 68 00 1d 	st.b	r6[29],r8
8000694c:	e2 08 16 10 	lsr	r8,r1,0x10
80006950:	ed 68 00 1e 	st.b	r6[30],r8
80006954:	e2 08 16 18 	lsr	r8,r1,0x18
80006958:	ed 68 00 1f 	st.b	r6[31],r8
	n = GET_FATTIME();						/* Use current time as VSN */
8000695c:	f0 1f 00 b4 	mcall	80006c2c <f_mkfs+0x67c>
80006960:	50 9c       	stdsp	sp[0x24],r12
	if (fmt == FS_FAT32) {
80006962:	40 3a       	lddsp	r10,sp[0xc]
80006964:	58 0a       	cp.w	r10,0
80006966:	c3 f0       	breq	800069e4 <f_mkfs+0x434>
		ST_DWORD(tbl + BS_VolID32, n);		/* VSN */
80006968:	ed 6c 00 43 	st.b	r6[67],r12
8000696c:	fb 38 00 26 	ld.ub	r8,sp[38]
80006970:	ed 68 00 44 	st.b	r6[68],r8
80006974:	fb 18 00 24 	ld.uh	r8,sp[36]
80006978:	ed 68 00 45 	st.b	r6[69],r8
8000697c:	fb 38 00 24 	ld.ub	r8,sp[36]
80006980:	ed 68 00 46 	st.b	r6[70],r8
		ST_DWORD(tbl + BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
80006984:	ed 62 00 24 	st.b	r6[36],r2
80006988:	f1 d2 c1 08 	bfextu	r8,r2,0x8,0x8
8000698c:	ed 68 00 25 	st.b	r6[37],r8
80006990:	e4 08 16 10 	lsr	r8,r2,0x10
80006994:	ed 68 00 26 	st.b	r6[38],r8
80006998:	e4 08 16 18 	lsr	r8,r2,0x18
8000699c:	ed 68 00 27 	st.b	r6[39],r8
		ST_DWORD(tbl + BPB_RootClus, 2);	/* Root directory start cluster (2) */
800069a0:	30 28       	mov	r8,2
800069a2:	ed 68 00 2c 	st.b	r6[44],r8
800069a6:	30 08       	mov	r8,0
800069a8:	ed 68 00 2d 	st.b	r6[45],r8
800069ac:	ed 68 00 2e 	st.b	r6[46],r8
800069b0:	ed 68 00 2f 	st.b	r6[47],r8
		ST_WORD(tbl + BPB_FSInfo, 1);		/* FSINFO record offset (VBR + 1) */
800069b4:	30 19       	mov	r9,1
800069b6:	ed 69 00 30 	st.b	r6[48],r9
800069ba:	ed 68 00 31 	st.b	r6[49],r8
		ST_WORD(tbl + BPB_BkBootSec, 6);	/* Backup boot record offset (VBR + 6) */
800069be:	30 69       	mov	r9,6
800069c0:	ed 69 00 32 	st.b	r6[50],r9
800069c4:	ed 68 00 33 	st.b	r6[51],r8
		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
800069c8:	38 08       	mov	r8,-128
800069ca:	ed 68 00 40 	st.b	r6[64],r8
		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
800069ce:	32 98       	mov	r8,41
800069d0:	ed 68 00 42 	st.b	r6[66],r8
		mem_cpy(tbl + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
800069d4:	31 3a       	mov	r10,19
800069d6:	fe fb 02 5a 	ld.w	r11,pc[602]
800069da:	ec cc ff b9 	sub	r12,r6,-71
800069de:	f0 1f 00 93 	mcall	80006c28 <f_mkfs+0x678>
800069e2:	c2 28       	rjmp	80006a26 <f_mkfs+0x476>
	} else {
		ST_DWORD(tbl + BS_VolID, n);		/* VSN */
800069e4:	ed 6c 00 27 	st.b	r6[39],r12
800069e8:	fb 38 00 26 	ld.ub	r8,sp[38]
800069ec:	ed 68 00 28 	st.b	r6[40],r8
800069f0:	fb 18 00 24 	ld.uh	r8,sp[36]
800069f4:	ed 68 00 29 	st.b	r6[41],r8
800069f8:	fb 38 00 24 	ld.ub	r8,sp[36]
800069fc:	ed 68 00 2a 	st.b	r6[42],r8
		ST_WORD(tbl + BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
80006a00:	ed 62 00 16 	st.b	r6[22],r2
80006a04:	f1 d2 c1 08 	bfextu	r8,r2,0x8,0x8
80006a08:	ed 68 00 17 	st.b	r6[23],r8
		tbl[BS_DrvNum] = 0x80;				/* Drive number */
80006a0c:	38 08       	mov	r8,-128
80006a0e:	ed 68 00 24 	st.b	r6[36],r8
		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
80006a12:	32 98       	mov	r8,41
80006a14:	ed 68 00 26 	st.b	r6[38],r8
		mem_cpy(tbl + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
80006a18:	31 3a       	mov	r10,19
80006a1a:	fe fb 02 1a 	ld.w	r11,pc[538]
80006a1e:	ec cc ff d5 	sub	r12,r6,-43
80006a22:	f0 1f 00 82 	mcall	80006c28 <f_mkfs+0x678>
	}
	ST_WORD(tbl + BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
80006a26:	ec c9 fe 02 	sub	r9,r6,-510
80006a2a:	50 69       	stdsp	sp[0x18],r9
80006a2c:	35 58       	mov	r8,85
80006a2e:	b2 88       	st.b	r9[0x0],r8
80006a30:	ec c8 fe 01 	sub	r8,r6,-511
80006a34:	50 08       	stdsp	sp[0x0],r8
80006a36:	3a a8       	mov	r8,-86
80006a38:	40 0c       	lddsp	r12,sp[0x0]
80006a3a:	b8 88       	st.b	r12[0x0],r8
	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
80006a3c:	30 19       	mov	r9,1
80006a3e:	02 9a       	mov	r10,r1
80006a40:	0c 9b       	mov	r11,r6
80006a42:	08 9c       	mov	r12,r4
80006a44:	f0 1f 00 77 	mcall	80006c20 <f_mkfs+0x670>
80006a48:	e0 81 00 d2 	brne	80006bec <f_mkfs+0x63c>
		return FR_DISK_ERR;
	if (fmt == FS_FAT32)					/* Write it to the backup VBR if needed (VBR + 6) */
80006a4c:	40 3b       	lddsp	r11,sp[0xc]
80006a4e:	58 0b       	cp.w	r11,0
80006a50:	c0 80       	breq	80006a60 <f_mkfs+0x4b0>
		disk_write(pdrv, tbl, b_vol + 6, 1);
80006a52:	30 19       	mov	r9,1
80006a54:	e2 ca ff fa 	sub	r10,r1,-6
80006a58:	0c 9b       	mov	r11,r6
80006a5a:	08 9c       	mov	r12,r4
80006a5c:	f0 1f 00 71 	mcall	80006c20 <f_mkfs+0x670>

	/* Initialize FAT area */
	wsect = b_fat;
	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
80006a60:	e0 6a 02 00 	mov	r10,512
80006a64:	30 0b       	mov	r11,0
80006a66:	0c 9c       	mov	r12,r6
80006a68:	f0 1f 00 6d 	mcall	80006c1c <f_mkfs+0x66c>
		n = md;								/* Media descriptor byte */
		if (fmt != FS_FAT32) {
80006a6c:	30 38       	mov	r8,3
80006a6e:	f0 03 18 00 	cp.b	r3,r8
80006a72:	c1 d0       	breq	80006aac <f_mkfs+0x4fc>
			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
80006a74:	30 18       	mov	r8,1
80006a76:	fe 7a ff 00 	mov	r10,-256
80006a7a:	e0 69 ff 00 	mov	r9,65280
80006a7e:	ea 19 00 ff 	orh	r9,0xff
80006a82:	e6 08 18 00 	cp.b	r8,r3
80006a86:	f2 08 17 00 	moveq	r8,r9
80006a8a:	f4 08 17 10 	movne	r8,r10
80006a8e:	f1 e7 10 07 	or	r7,r8,r7
80006a92:	50 97       	stdsp	sp[0x24],r7
			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT12/16) */
80006a94:	eb 67 00 30 	st.b	r5[48],r7
80006a98:	fb 38 00 26 	ld.ub	r8,sp[38]
80006a9c:	ac 98       	st.b	r6[0x1],r8
80006a9e:	fb 18 00 24 	ld.uh	r8,sp[36]
80006aa2:	ac a8       	st.b	r6[0x2],r8
80006aa4:	fb 38 00 24 	ld.ub	r8,sp[36]
80006aa8:	ac b8       	st.b	r6[0x3],r8
80006aaa:	c1 f8       	rjmp	80006ae8 <f_mkfs+0x538>
		} else {
			n |= 0xFFFFFF00;
80006aac:	ea 17 ff ff 	orh	r7,0xffff
80006ab0:	e8 17 ff 00 	orl	r7,0xff00
80006ab4:	50 97       	stdsp	sp[0x24],r7
			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT32) */
80006ab6:	eb 67 00 30 	st.b	r5[48],r7
80006aba:	fb 38 00 26 	ld.ub	r8,sp[38]
80006abe:	ac 98       	st.b	r6[0x1],r8
80006ac0:	fb 18 00 24 	ld.uh	r8,sp[36]
80006ac4:	ac a8       	st.b	r6[0x2],r8
80006ac6:	fb 38 00 24 	ld.ub	r8,sp[36]
80006aca:	ac b8       	st.b	r6[0x3],r8
			ST_DWORD(tbl + 4, 0xFFFFFFFF);
80006acc:	3f f8       	mov	r8,-1
80006ace:	ac c8       	st.b	r6[0x4],r8
80006ad0:	ac d8       	st.b	r6[0x5],r8
80006ad2:	ac e8       	st.b	r6[0x6],r8
80006ad4:	ac f8       	st.b	r6[0x7],r8
			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
80006ad6:	ed 68 00 08 	st.b	r6[8],r8
80006ada:	ed 68 00 09 	st.b	r6[9],r8
80006ade:	ed 68 00 0a 	st.b	r6[10],r8
80006ae2:	30 f8       	mov	r8,15
80006ae4:	40 5a       	lddsp	r10,sp[0x14]
80006ae6:	b4 88       	st.b	r10[0x0],r8
		}
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
80006ae8:	30 19       	mov	r9,1
80006aea:	40 1a       	lddsp	r10,sp[0x4]
80006aec:	0c 9b       	mov	r11,r6
80006aee:	08 9c       	mov	r12,r4
80006af0:	f0 1f 00 4c 	mcall	80006c20 <f_mkfs+0x670>
80006af4:	c7 c1       	brne	80006bec <f_mkfs+0x63c>
80006af6:	40 13       	lddsp	r3,sp[0x4]
80006af8:	2f f3       	sub	r3,-1
			return FR_DISK_ERR;
		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
80006afa:	e0 6a 02 00 	mov	r10,512
80006afe:	30 0b       	mov	r11,0
80006b00:	0c 9c       	mov	r12,r6
80006b02:	f0 1f 00 47 	mcall	80006c1c <f_mkfs+0x66c>
		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
80006b06:	30 18       	mov	r8,1
80006b08:	50 98       	stdsp	sp[0x24],r8
80006b0a:	10 32       	cp.w	r2,r8
80006b0c:	e0 88 00 11 	brls	80006b2e <f_mkfs+0x57e>
			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
80006b10:	10 97       	mov	r7,r8
80006b12:	0e 99       	mov	r9,r7
80006b14:	06 9a       	mov	r10,r3
80006b16:	0c 9b       	mov	r11,r6
80006b18:	08 9c       	mov	r12,r4
80006b1a:	f0 1f 00 42 	mcall	80006c20 <f_mkfs+0x670>
80006b1e:	c6 71       	brne	80006bec <f_mkfs+0x63c>
80006b20:	2f f3       	sub	r3,-1
			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
		}
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
			return FR_DISK_ERR;
		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
80006b22:	40 98       	lddsp	r8,sp[0x24]
80006b24:	2f f8       	sub	r8,-1
80006b26:	50 98       	stdsp	sp[0x24],r8
80006b28:	10 32       	cp.w	r2,r8
80006b2a:	fe 9b ff f4 	brhi	80006b12 <f_mkfs+0x562>
				return FR_DISK_ERR;
		}
	}

	/* Initialize root directory */
	i = (fmt == FS_FAT32) ? au : (UINT)n_dir;
80006b2e:	40 29       	lddsp	r9,sp[0x8]
80006b30:	40 38       	lddsp	r8,sp[0xc]
80006b32:	58 08       	cp.w	r8,0
80006b34:	f2 00 17 00 	moveq	r0,r9
	do {
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
80006b38:	30 12       	mov	r2,1
80006b3a:	06 9a       	mov	r10,r3
80006b3c:	f4 c7 ff ff 	sub	r7,r10,-1
80006b40:	04 99       	mov	r9,r2
80006b42:	0c 9b       	mov	r11,r6
80006b44:	08 9c       	mov	r12,r4
80006b46:	f0 1f 00 37 	mcall	80006c20 <f_mkfs+0x670>
80006b4a:	c5 11       	brne	80006bec <f_mkfs+0x63c>
			return FR_DISK_ERR;
	} while (--i);
80006b4c:	20 10       	sub	r0,1
80006b4e:	c0 30       	breq	80006b54 <f_mkfs+0x5a4>
80006b50:	0e 9a       	mov	r10,r7
80006b52:	cf 5b       	rjmp	80006b3c <f_mkfs+0x58c>
		disk_ioctl(pdrv, CTRL_TRIM, eb);
	}
#endif

	/* Create FSINFO if needed */
	if (fmt == FS_FAT32) {
80006b54:	40 3c       	lddsp	r12,sp[0xc]
80006b56:	58 0c       	cp.w	r12,0
80006b58:	c4 30       	breq	80006bde <f_mkfs+0x62e>
		ST_DWORD(tbl + FSI_LeadSig, 0x41615252);
80006b5a:	35 28       	mov	r8,82
80006b5c:	eb 68 00 30 	st.b	r5[48],r8
80006b60:	ac 98       	st.b	r6[0x1],r8
80006b62:	36 18       	mov	r8,97
80006b64:	ac a8       	st.b	r6[0x2],r8
80006b66:	34 19       	mov	r9,65
80006b68:	ac b9       	st.b	r6[0x3],r9
		ST_DWORD(tbl + FSI_StrucSig, 0x61417272);
80006b6a:	37 2a       	mov	r10,114
80006b6c:	ed 6a 01 e4 	st.b	r6[484],r10
80006b70:	ed 6a 01 e5 	st.b	r6[485],r10
80006b74:	ed 69 01 e6 	st.b	r6[486],r9
80006b78:	ed 68 01 e7 	st.b	r6[487],r8
		ST_DWORD(tbl + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
80006b7c:	40 48       	lddsp	r8,sp[0x10]
80006b7e:	20 18       	sub	r8,1
80006b80:	ed 68 01 e8 	st.b	r6[488],r8
80006b84:	40 48       	lddsp	r8,sp[0x10]
80006b86:	20 18       	sub	r8,1
80006b88:	f1 d8 c1 08 	bfextu	r8,r8,0x8,0x8
80006b8c:	ed 68 01 e9 	st.b	r6[489],r8
80006b90:	40 48       	lddsp	r8,sp[0x10]
80006b92:	20 18       	sub	r8,1
80006b94:	f0 09 16 10 	lsr	r9,r8,0x10
80006b98:	ed 69 01 ea 	st.b	r6[490],r9
80006b9c:	b9 88       	lsr	r8,0x18
80006b9e:	ed 68 01 eb 	st.b	r6[491],r8
		ST_DWORD(tbl + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
80006ba2:	30 28       	mov	r8,2
80006ba4:	ed 68 01 ec 	st.b	r6[492],r8
80006ba8:	30 08       	mov	r8,0
80006baa:	ed 68 01 ed 	st.b	r6[493],r8
80006bae:	ed 68 01 ee 	st.b	r6[494],r8
80006bb2:	ed 68 01 ef 	st.b	r6[495],r8
		ST_WORD(tbl + BS_55AA, 0xAA55);
80006bb6:	35 58       	mov	r8,85
80006bb8:	40 6b       	lddsp	r11,sp[0x18]
80006bba:	b6 88       	st.b	r11[0x0],r8
80006bbc:	3a a8       	mov	r8,-86
80006bbe:	40 0a       	lddsp	r10,sp[0x0]
80006bc0:	b4 88       	st.b	r10[0x0],r8
		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR + 1) */
80006bc2:	30 19       	mov	r9,1
80006bc4:	e2 09 00 0a 	add	r10,r1,r9
80006bc8:	0c 9b       	mov	r11,r6
80006bca:	08 9c       	mov	r12,r4
80006bcc:	f0 1f 00 15 	mcall	80006c20 <f_mkfs+0x670>
		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR + 7) */
80006bd0:	30 19       	mov	r9,1
80006bd2:	e2 ca ff f9 	sub	r10,r1,-7
80006bd6:	0c 9b       	mov	r11,r6
80006bd8:	08 9c       	mov	r12,r4
80006bda:	f0 1f 00 12 	mcall	80006c20 <f_mkfs+0x670>
	}

	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
80006bde:	30 0a       	mov	r10,0
80006be0:	14 9b       	mov	r11,r10
80006be2:	08 9c       	mov	r12,r4
80006be4:	f0 1f 00 0b 	mcall	80006c10 <f_mkfs+0x660>
80006be8:	5f 1c       	srne	r12
80006bea:	c0 48       	rjmp	80006bf2 <f_mkfs+0x642>
80006bec:	30 1c       	mov	r12,1
80006bee:	c0 28       	rjmp	80006bf2 <f_mkfs+0x642>
80006bf0:	30 ec       	mov	r12,14
}
80006bf2:	2f 6d       	sub	sp,-40
80006bf4:	d8 32       	popm	r0-r7,pc
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
80006bf6:	30 39       	mov	r9,3
80006bf8:	f2 03 18 00 	cp.b	r3,r9
80006bfc:	5f 09       	sreq	r9
80006bfe:	50 39       	stdsp	sp[0xc],r9
80006c00:	fe 9f fd d9 	bral	800067b2 <f_mkfs+0x202>
80006c04:	80 00       	ld.sh	r0,r0[0x0]
80006c06:	63 b8       	ld.w	r8,r1[0x6c]
80006c08:	00 00       	add	r0,r0
80006c0a:	11 50       	ld.sh	r0,--r8
80006c0c:	80 00       	ld.sh	r0,r0[0x0]
80006c0e:	62 1e       	ld.w	lr,r1[0x4]
80006c10:	80 00       	ld.sh	r0,r0[0x0]
80006c12:	62 5c       	ld.w	r12,r1[0x14]
80006c14:	80 01       	ld.sh	r1,r0[0x0]
80006c16:	8b 6a       	st.w	r5[0x18],r10
80006c18:	80 01       	ld.sh	r1,r0[0x0]
80006c1a:	8b 54       	st.w	r5[0x14],r4
80006c1c:	80 00       	ld.sh	r0,r0[0x0]
80006c1e:	62 fa       	ld.w	r10,r1[0x3c]
80006c20:	80 00       	ld.sh	r0,r0[0x0]
80006c22:	62 ac       	ld.w	r12,r1[0x28]
80006c24:	80 01       	ld.sh	r1,r0[0x0]
80006c26:	8b 84       	st.w	r5[0x20],r4
80006c28:	80 00       	ld.sh	r0,r0[0x0]
80006c2a:	62 e4       	ld.w	r4,r1[0x38]
80006c2c:	80 00       	ld.sh	r0,r0[0x0]
80006c2e:	62 20       	ld.w	r0,r1[0x8]
80006c30:	80 01       	ld.sh	r1,r0[0x0]
80006c32:	8b 90       	st.w	r5[0x24],r0
80006c34:	80 01       	ld.sh	r1,r0[0x0]
80006c36:	8b a4       	st.w	r5[0x28],r4

80006c38 <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
80006c38:	d4 01       	pushm	lr
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
80006c3a:	58 0c       	cp.w	r12,0
80006c3c:	c1 40       	breq	80006c64 <validate+0x2c>
80006c3e:	78 08       	ld.w	r8,r12[0x0]
80006c40:	58 08       	cp.w	r8,0
80006c42:	c1 10       	breq	80006c64 <validate+0x2c>
80006c44:	11 8a       	ld.ub	r10,r8[0x0]
80006c46:	30 09       	mov	r9,0
80006c48:	f2 0a 18 00 	cp.b	r10,r9
80006c4c:	c0 c0       	breq	80006c64 <validate+0x2c>
80006c4e:	90 3a       	ld.sh	r10,r8[0x6]
80006c50:	98 29       	ld.sh	r9,r12[0x4]
80006c52:	f2 0a 19 00 	cp.h	r10,r9
80006c56:	c0 71       	brne	80006c64 <validate+0x2c>
80006c58:	11 9c       	ld.ub	r12,r8[0x1]
80006c5a:	f0 1f 00 04 	mcall	80006c68 <validate+0x30>
80006c5e:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80006c62:	c0 20       	breq	80006c66 <validate+0x2e>
80006c64:	30 9c       	mov	r12,9
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	return FR_OK;
}
80006c66:	d8 02       	popm	pc
80006c68:	80 00       	ld.sh	r0,r0[0x0]
80006c6a:	62 1c       	ld.w	r12,r1[0x4]

80006c6c <move_window>:
static
FRESULT move_window (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)
{
80006c6c:	eb cd 40 e0 	pushm	r5-r7,lr
80006c70:	18 97       	mov	r7,r12
80006c72:	16 95       	mov	r5,r11
	FRESULT res = FR_OK;


	if (sector != fs->winsect) {	/* Window offset changed? */
80006c74:	78 b8       	ld.w	r8,r12[0x2c]
80006c76:	16 38       	cp.w	r8,r11
80006c78:	c0 31       	brne	80006c7e <move_window+0x12>
80006c7a:	30 06       	mov	r6,0
80006c7c:	c1 18       	rjmp	80006c9e <move_window+0x32>
#if !_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
80006c7e:	f0 1f 00 0a 	mcall	80006ca4 <move_window+0x38>
80006c82:	18 96       	mov	r6,r12
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
80006c84:	c0 d1       	brne	80006c9e <move_window+0x32>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
80006c86:	30 19       	mov	r9,1
80006c88:	0a 9a       	mov	r10,r5
80006c8a:	ee cb ff d0 	sub	r11,r7,-48
80006c8e:	0f 9c       	ld.ub	r12,r7[0x1]
80006c90:	f0 1f 00 06 	mcall	80006ca8 <move_window+0x3c>
80006c94:	f9 b6 01 01 	movne	r6,1
80006c98:	f9 b5 01 ff 	movne	r5,-1
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
				res = FR_DISK_ERR;
			}
			fs->winsect = sector;
80006c9c:	8f b5       	st.w	r7[0x2c],r5
		}
	}
	return res;
}
80006c9e:	0c 9c       	mov	r12,r6
80006ca0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006ca4:	80 00       	ld.sh	r0,r0[0x0]
80006ca6:	64 74       	ld.w	r4,r2[0x1c]
80006ca8:	80 00       	ld.sh	r0,r0[0x0]
80006caa:	62 c8       	ld.w	r8,r1[0x30]

80006cac <check_fs>:
static
BYTE check_fs (	/* 0:Valid FAT-BS, 1:Valid BS but not FAT, 2:Not a BS, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
80006cac:	eb cd 40 80 	pushm	r7,lr
80006cb0:	18 97       	mov	r7,r12
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
80006cb2:	30 08       	mov	r8,0
80006cb4:	b8 c8       	st.b	r12[0x4],r8
80006cb6:	3f f8       	mov	r8,-1
80006cb8:	99 b8       	st.w	r12[0x2c],r8
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
80006cba:	f0 1f 00 23 	mcall	80006d44 <check_fs+0x98>
80006cbe:	c0 40       	breq	80006cc6 <check_fs+0x1a>
80006cc0:	30 3c       	mov	r12,3
80006cc2:	e3 cd 80 80 	ldm	sp++,r7,pc
		return 3;

	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
80006cc6:	ef 39 02 2f 	ld.ub	r9,r7[559]
80006cca:	ef 38 02 2e 	ld.ub	r8,r7[558]
80006cce:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80006cd2:	fe 78 aa 55 	mov	r8,-21931
80006cd6:	f0 09 19 00 	cp.h	r9,r8
80006cda:	c0 40       	breq	80006ce2 <check_fs+0x36>
80006cdc:	30 2c       	mov	r12,2
80006cde:	e3 cd 80 80 	ldm	sp++,r7,pc
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
80006ce2:	ef 39 00 69 	ld.ub	r9,r7[105]
80006ce6:	ef 38 00 68 	ld.ub	r8,r7[104]
80006cea:	b1 68       	lsl	r8,0x10
80006cec:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80006cf0:	ef 39 00 66 	ld.ub	r9,r7[102]
80006cf4:	12 48       	or	r8,r9
80006cf6:	ef 39 00 67 	ld.ub	r9,r7[103]
80006cfa:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006cfe:	f1 d8 c0 18 	bfextu	r8,r8,0x0,0x18
80006d02:	e0 69 41 46 	mov	r9,16710
80006d06:	ea 19 00 54 	orh	r9,0x54
80006d0a:	12 38       	cp.w	r8,r9
80006d0c:	c0 31       	brne	80006d12 <check_fs+0x66>
80006d0e:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80006d12:	ef 39 00 85 	ld.ub	r9,r7[133]
80006d16:	ef 38 00 84 	ld.ub	r8,r7[132]
80006d1a:	b1 68       	lsl	r8,0x10
80006d1c:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80006d20:	ef 39 00 82 	ld.ub	r9,r7[130]
80006d24:	12 48       	or	r8,r9
80006d26:	ef 39 00 83 	ld.ub	r9,r7[131]
80006d2a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006d2e:	f1 d8 c0 18 	bfextu	r8,r8,0x0,0x18
80006d32:	e0 69 41 46 	mov	r9,16710
80006d36:	ea 19 00 54 	orh	r9,0x54
80006d3a:	12 38       	cp.w	r8,r9
80006d3c:	5f 1c       	srne	r12
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;

	return 1;
}
80006d3e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006d42:	00 00       	add	r0,r0
80006d44:	80 00       	ld.sh	r0,r0[0x0]
80006d46:	6c 6c       	ld.w	r12,r6[0x18]

80006d48 <find_volume>:
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
80006d48:	eb cd 40 fb 	pushm	r0-r1,r3-r7,lr
80006d4c:	20 4d       	sub	sp,16
80006d4e:	18 95       	mov	r5,r12
80006d50:	14 94       	mov	r4,r10
	FATFS *fs;
	UINT i;


	/* Get logical drive number from the path name */
	*rfs = 0;
80006d52:	30 08       	mov	r8,0
80006d54:	99 08       	st.w	r12[0x0],r8
	vol = get_ldnumber(path);
80006d56:	16 9c       	mov	r12,r11
80006d58:	f0 1f 00 de 	mcall	800070d0 <find_volume+0x388>
80006d5c:	18 96       	mov	r6,r12
	if (vol < 0) return FR_INVALID_DRIVE;
80006d5e:	c0 34       	brge	80006d64 <find_volume+0x1c>
80006d60:	30 bc       	mov	r12,11
80006d62:	ca a9       	rjmp	800070b6 <find_volume+0x36e>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
80006d64:	fe f8 03 70 	ld.w	r8,pc[880]
80006d68:	f0 0c 03 27 	ld.w	r7,r8[r12<<0x2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
80006d6c:	58 07       	cp.w	r7,0
80006d6e:	c0 31       	brne	80006d74 <find_volume+0x2c>
80006d70:	30 cc       	mov	r12,12
80006d72:	ca 29       	rjmp	800070b6 <find_volume+0x36e>

	ENTER_FF(fs);						/* Lock the volume */
	*rfs = fs;							/* Return pointer to the file system object */
80006d74:	8b 07       	st.w	r5[0x0],r7

	if (fs->fs_type) {					/* If the volume has been mounted */
80006d76:	0f 89       	ld.ub	r9,r7[0x0]
80006d78:	30 08       	mov	r8,0
80006d7a:	f0 09 18 00 	cp.b	r9,r8
80006d7e:	c0 f0       	breq	80006d9c <find_volume+0x54>
		stat = disk_status(fs->drv);
80006d80:	0f 9c       	ld.ub	r12,r7[0x1]
80006d82:	f0 1f 00 d6 	mcall	800070d8 <find_volume+0x390>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
80006d86:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80006d8a:	c0 91       	brne	80006d9c <find_volume+0x54>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
80006d8c:	58 04       	cp.w	r4,0
80006d8e:	e0 80 01 91 	breq	800070b0 <find_volume+0x368>
80006d92:	e2 1c 00 04 	andl	r12,0x4,COH
80006d96:	e0 81 01 8b 	brne	800070ac <find_volume+0x364>
80006d9a:	c8 b9       	rjmp	800070b0 <find_volume+0x368>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
80006d9c:	30 08       	mov	r8,0
80006d9e:	ae 88       	st.b	r7[0x0],r8
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
80006da0:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80006da4:	ae 9c       	st.b	r7[0x1],r12
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
80006da6:	f0 1f 00 ce 	mcall	800070dc <find_volume+0x394>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
80006daa:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80006dae:	c0 30       	breq	80006db4 <find_volume+0x6c>
80006db0:	30 3c       	mov	r12,3
80006db2:	c8 29       	rjmp	800070b6 <find_volume+0x36e>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
80006db4:	58 04       	cp.w	r4,0
80006db6:	c0 50       	breq	80006dc0 <find_volume+0x78>
80006db8:	e2 1c 00 04 	andl	r12,0x4,COH
80006dbc:	e0 81 01 78 	brne	800070ac <find_volume+0x364>
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
80006dc0:	30 0b       	mov	r11,0
80006dc2:	0e 9c       	mov	r12,r7
80006dc4:	f0 1f 00 c7 	mcall	800070e0 <find_volume+0x398>
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
80006dc8:	30 18       	mov	r8,1
80006dca:	f0 0c 18 00 	cp.b	r12,r8
80006dce:	c0 30       	breq	80006dd4 <find_volume+0x8c>
80006dd0:	30 05       	mov	r5,0
80006dd2:	c3 48       	rjmp	80006e3a <find_volume+0xf2>
80006dd4:	1a 96       	mov	r6,sp
80006dd6:	1a 9a       	mov	r10,sp
80006dd8:	e0 68 01 be 	mov	r8,446
		for (i = 0; i < 4; i++) {			/* Get partition offset */
			pt = fs->win + MBR_Table + i * SZ_PTE;
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
80006ddc:	30 0c       	mov	r12,0
80006dde:	30 04       	mov	r4,0
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
			pt = fs->win + MBR_Table + i * SZ_PTE;
80006de0:	f0 c9 ff d0 	sub	r9,r8,-48
80006de4:	ee 09 00 09 	add	r9,r7,r9
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
80006de8:	13 cb       	ld.ub	r11,r9[0x4]
80006dea:	f8 0b 18 00 	cp.b	r11,r12
80006dee:	c0 31       	brne	80006df4 <find_volume+0xac>
80006df0:	08 99       	mov	r9,r4
80006df2:	c0 f8       	rjmp	80006e10 <find_volume+0xc8>
80006df4:	f3 35 00 0b 	ld.ub	r5,r9[11]
80006df8:	f3 3b 00 0a 	ld.ub	r11,r9[10]
80006dfc:	b1 6b       	lsl	r11,0x10
80006dfe:	f7 e5 11 8b 	or	r11,r11,r5<<0x18
80006e02:	f3 35 00 08 	ld.ub	r5,r9[8]
80006e06:	0a 4b       	or	r11,r5
80006e08:	f3 39 00 09 	ld.ub	r9,r9[9]
80006e0c:	f7 e9 10 89 	or	r9,r11,r9<<0x8
80006e10:	14 a9       	st.w	r10++,r9
80006e12:	2f 08       	sub	r8,-16
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
80006e14:	e0 48 01 fe 	cp.w	r8,510
80006e18:	ce 41       	brne	80006de0 <find_volume+0x98>
/*-----------------------------------------------------------------------*/
/* Find logical drive and check if the volume is mounted                 */
/*-----------------------------------------------------------------------*/

static
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
80006e1a:	fa c4 ff f0 	sub	r4,sp,-16
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
80006e1e:	30 23       	mov	r3,2
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
80006e20:	6c 05       	ld.w	r5,r6[0x0]
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
80006e22:	58 05       	cp.w	r5,0
80006e24:	c0 31       	brne	80006e2a <find_volume+0xe2>
80006e26:	06 9c       	mov	r12,r3
80006e28:	c0 68       	rjmp	80006e34 <find_volume+0xec>
80006e2a:	0a 9b       	mov	r11,r5
80006e2c:	0e 9c       	mov	r12,r7
80006e2e:	f0 1f 00 ad 	mcall	800070e0 <find_volume+0x398>
		} while (!LD2PT(vol) && fmt && ++i < 4);
80006e32:	c0 d0       	breq	80006e4c <find_volume+0x104>
80006e34:	2f c6       	sub	r6,-4
80006e36:	08 36       	cp.w	r6,r4
80006e38:	cf 41       	brne	80006e20 <find_volume+0xd8>
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
80006e3a:	30 38       	mov	r8,3
80006e3c:	f0 0c 18 00 	cp.b	r12,r8
80006e40:	c0 31       	brne	80006e46 <find_volume+0xfe>
80006e42:	30 1c       	mov	r12,1
80006e44:	c3 99       	rjmp	800070b6 <find_volume+0x36e>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
80006e46:	58 0c       	cp.w	r12,0
80006e48:	e0 81 01 36 	brne	800070b4 <find_volume+0x36c>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
80006e4c:	ef 39 00 3c 	ld.ub	r9,r7[60]
80006e50:	ef 38 00 3b 	ld.ub	r8,r7[59]
80006e54:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80006e58:	e0 68 02 00 	mov	r8,512
80006e5c:	f0 09 19 00 	cp.h	r9,r8
80006e60:	e0 81 01 2a 	brne	800070b4 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
80006e64:	ef 39 00 47 	ld.ub	r9,r7[71]
80006e68:	ef 38 00 46 	ld.ub	r8,r7[70]
80006e6c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	if (!fasize) fasize = LD_DWORD(fs->win + BPB_FATSz32);
80006e70:	c1 01       	brne	80006e90 <find_volume+0x148>
80006e72:	ef 39 00 57 	ld.ub	r9,r7[87]
80006e76:	ef 38 00 56 	ld.ub	r8,r7[86]
80006e7a:	b1 68       	lsl	r8,0x10
80006e7c:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80006e80:	ef 38 00 54 	ld.ub	r8,r7[84]
80006e84:	f3 e8 10 08 	or	r8,r9,r8
80006e88:	ef 39 00 55 	ld.ub	r9,r7[85]
80006e8c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	fs->fsize = fasize;
80006e90:	8f 68       	st.w	r7[0x18],r8

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
80006e92:	ef 39 00 40 	ld.ub	r9,r7[64]
80006e96:	ae b9       	st.b	r7[0x3],r9
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
80006e98:	f2 cb 00 01 	sub	r11,r9,1
80006e9c:	30 1a       	mov	r10,1
80006e9e:	f4 0b 18 00 	cp.b	r11,r10
80006ea2:	e0 8b 01 09 	brhi	800070b4 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */

	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
80006ea6:	ef 3a 00 3d 	ld.ub	r10,r7[61]
80006eaa:	ae aa       	st.b	r7[0x2],r10
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
80006eac:	58 0a       	cp.w	r10,0
80006eae:	e0 80 01 03 	breq	800070b4 <find_volume+0x36c>
80006eb2:	f4 cb 00 01 	sub	r11,r10,1
80006eb6:	14 6b       	and	r11,r10
80006eb8:	e0 81 00 fe 	brne	800070b4 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
80006ebc:	ef 3c 00 42 	ld.ub	r12,r7[66]
80006ec0:	ef 3b 00 41 	ld.ub	r11,r7[65]
80006ec4:	f7 ec 10 8b 	or	r11,r11,r12<<0x8
80006ec8:	5c 8b       	casts.h	r11
80006eca:	ae 4b       	st.h	r7[0x8],r11
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
80006ecc:	f9 db c0 04 	bfextu	r12,r11,0x0,0x4
80006ed0:	e0 81 00 f2 	brne	800070b4 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	tsect = LD_WORD(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
80006ed4:	ef 36 00 44 	ld.ub	r6,r7[68]
80006ed8:	ef 3c 00 43 	ld.ub	r12,r7[67]
80006edc:	f9 e6 10 8c 	or	r12,r12,r6<<0x8
	if (!tsect) tsect = LD_DWORD(fs->win + BPB_TotSec32);
80006ee0:	c1 01       	brne	80006f00 <find_volume+0x1b8>
80006ee2:	ef 36 00 53 	ld.ub	r6,r7[83]
80006ee6:	ef 3c 00 52 	ld.ub	r12,r7[82]
80006eea:	b1 6c       	lsl	r12,0x10
80006eec:	f9 e6 11 86 	or	r6,r12,r6<<0x18
80006ef0:	ef 3c 00 50 	ld.ub	r12,r7[80]
80006ef4:	ed ec 10 0c 	or	r12,r6,r12
80006ef8:	ef 36 00 51 	ld.ub	r6,r7[81]
80006efc:	f9 e6 10 8c 	or	r12,r12,r6<<0x8

	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
80006f00:	ef 34 00 3f 	ld.ub	r4,r7[63]
80006f04:	ef 36 00 3e 	ld.ub	r6,r7[62]
80006f08:	ed e4 10 86 	or	r6,r6,r4<<0x8
80006f0c:	5c 86       	casts.h	r6
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
80006f0e:	e0 80 00 d3 	breq	800070b4 <find_volume+0x36c>
	fs->fsize = fasize;

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
80006f12:	b3 38       	mul	r8,r9

	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
80006f14:	e7 d6 c0 10 	bfextu	r3,r6,0x0,0x10
80006f18:	e9 db c0 8c 	bfextu	r4,r11,0x4,0xc
80006f1c:	06 04       	add	r4,r3
80006f1e:	10 04       	add	r4,r8
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
80006f20:	08 3c       	cp.w	r12,r4
80006f22:	e0 83 00 c9 	brlo	800070b4 <find_volume+0x36c>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
80006f26:	f8 04 01 01 	sub	r1,r12,r4
80006f2a:	e2 0a 0d 00 	divu	r0,r1,r10
80006f2e:	00 99       	mov	r9,r0
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
80006f30:	58 00       	cp.w	r0,0
80006f32:	e0 80 00 c1 	breq	800070b4 <find_volume+0x36c>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
80006f36:	e0 40 0f f6 	cp.w	r0,4086
80006f3a:	f9 b6 03 01 	movlo	r6,1
80006f3e:	f9 b6 02 02 	movhs	r6,2
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
80006f42:	e0 40 ff f5 	cp.w	r0,65525
80006f46:	e0 8b 00 bb 	brhi	800070bc <find_volume+0x374>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
80006f4a:	2f e9       	sub	r9,-2
80006f4c:	8f 59       	st.w	r7[0x14],r9
	fs->volbase = bsect;								/* Volume start sector */
80006f4e:	8f 75       	st.w	r7[0x1c],r5
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
80006f50:	ea 03 00 03 	add	r3,r5,r3
80006f54:	8f 83       	st.w	r7[0x20],r3
	fs->database = bsect + sysect;						/* Data start sector */
80006f56:	0a 04       	add	r4,r5
80006f58:	8f a4       	st.w	r7[0x28],r4
	if (fmt == FS_FAT32) {
80006f5a:	30 3a       	mov	r10,3
80006f5c:	f4 06 18 00 	cp.b	r6,r10
80006f60:	c1 61       	brne	80006f8c <find_volume+0x244>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
80006f62:	58 0b       	cp.w	r11,0
80006f64:	e0 81 00 a8 	brne	800070b4 <find_volume+0x36c>
		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus);	/* Root directory start cluster */
80006f68:	ef 3a 00 5f 	ld.ub	r10,r7[95]
80006f6c:	ef 38 00 5e 	ld.ub	r8,r7[94]
80006f70:	b1 68       	lsl	r8,0x10
80006f72:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80006f76:	ef 38 00 5c 	ld.ub	r8,r7[92]
80006f7a:	f5 e8 10 08 	or	r8,r10,r8
80006f7e:	ef 3a 00 5d 	ld.ub	r10,r7[93]
80006f82:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80006f86:	8f 98       	st.w	r7[0x24],r8
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
80006f88:	a3 69       	lsl	r9,0x2
80006f8a:	c1 38       	rjmp	80006fb0 <find_volume+0x268>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
80006f8c:	58 0b       	cp.w	r11,0
80006f8e:	e0 80 00 93 	breq	800070b4 <find_volume+0x36c>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
80006f92:	06 08       	add	r8,r3
80006f94:	8f 98       	st.w	r7[0x24],r8
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
80006f96:	30 28       	mov	r8,2
80006f98:	f0 06 18 00 	cp.b	r6,r8
80006f9c:	c0 31       	brne	80006fa2 <find_volume+0x25a>
80006f9e:	a1 79       	lsl	r9,0x1
80006fa0:	c0 88       	rjmp	80006fb0 <find_volume+0x268>
80006fa2:	f2 09 00 18 	add	r8,r9,r9<<0x1
80006fa6:	a1 98       	lsr	r8,0x1
80006fa8:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80006fac:	f0 09 00 09 	add	r9,r8,r9
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
80006fb0:	f2 c8 fe 01 	sub	r8,r9,-511
80006fb4:	a9 98       	lsr	r8,0x9
80006fb6:	6e 69       	ld.w	r9,r7[0x18]
80006fb8:	10 39       	cp.w	r9,r8
80006fba:	c7 d3       	brcs	800070b4 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
80006fbc:	3f f8       	mov	r8,-1
80006fbe:	8f 48       	st.w	r7[0x10],r8
80006fc0:	8f 38       	st.w	r7[0xc],r8

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
80006fc2:	38 08       	mov	r8,-128
80006fc4:	ae d8       	st.b	r7[0x5],r8
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo == 1 */
80006fc6:	30 38       	mov	r8,3
80006fc8:	f0 06 18 00 	cp.b	r6,r8
80006fcc:	c6 81       	brne	8000709c <find_volume+0x354>
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
80006fce:	ef 39 00 61 	ld.ub	r9,r7[97]
80006fd2:	ef 38 00 60 	ld.ub	r8,r7[96]
80006fd6:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80006fda:	30 18       	mov	r8,1
80006fdc:	f0 09 19 00 	cp.h	r9,r8
80006fe0:	c5 e1       	brne	8000709c <find_volume+0x354>
		&& move_window(fs, bsect + 1) == FR_OK)
80006fe2:	ea cb ff ff 	sub	r11,r5,-1
80006fe6:	0e 9c       	mov	r12,r7
80006fe8:	f0 1f 00 3f 	mcall	800070e4 <find_volume+0x39c>
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo == 1 */
80006fec:	c5 81       	brne	8000709c <find_volume+0x354>
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
		&& move_window(fs, bsect + 1) == FR_OK)
	{
		fs->fsi_flag = 0;
80006fee:	30 08       	mov	r8,0
80006ff0:	ae d8       	st.b	r7[0x5],r8
		if (LD_WORD(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
80006ff2:	ef 39 02 2f 	ld.ub	r9,r7[559]
80006ff6:	ef 38 02 2e 	ld.ub	r8,r7[558]
80006ffa:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80006ffe:	fe 78 aa 55 	mov	r8,-21931
80007002:	f0 09 19 00 	cp.h	r9,r8
80007006:	c4 b1       	brne	8000709c <find_volume+0x354>
			&& LD_DWORD(fs->win + FSI_LeadSig) == 0x41615252
80007008:	ef 39 00 33 	ld.ub	r9,r7[51]
8000700c:	ef 38 00 32 	ld.ub	r8,r7[50]
80007010:	b1 68       	lsl	r8,0x10
80007012:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80007016:	ef 38 00 30 	ld.ub	r8,r7[48]
8000701a:	f3 e8 10 08 	or	r8,r9,r8
8000701e:	ef 39 00 31 	ld.ub	r9,r7[49]
80007022:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80007026:	e0 69 52 52 	mov	r9,21074
8000702a:	ea 19 41 61 	orh	r9,0x4161
8000702e:	12 38       	cp.w	r8,r9
80007030:	c3 61       	brne	8000709c <find_volume+0x354>
			&& LD_DWORD(fs->win + FSI_StrucSig) == 0x61417272)
80007032:	ef 39 02 17 	ld.ub	r9,r7[535]
80007036:	ef 38 02 16 	ld.ub	r8,r7[534]
8000703a:	b1 68       	lsl	r8,0x10
8000703c:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80007040:	ef 38 02 14 	ld.ub	r8,r7[532]
80007044:	f3 e8 10 08 	or	r8,r9,r8
80007048:	ef 39 02 15 	ld.ub	r9,r7[533]
8000704c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80007050:	e0 69 72 72 	mov	r9,29298
80007054:	ea 19 61 41 	orh	r9,0x6141
80007058:	12 38       	cp.w	r8,r9
8000705a:	c2 11       	brne	8000709c <find_volume+0x354>
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win + FSI_Free_Count);
8000705c:	ef 39 02 1b 	ld.ub	r9,r7[539]
80007060:	ef 38 02 1a 	ld.ub	r8,r7[538]
80007064:	b1 68       	lsl	r8,0x10
80007066:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000706a:	ef 38 02 18 	ld.ub	r8,r7[536]
8000706e:	f3 e8 10 08 	or	r8,r9,r8
80007072:	ef 39 02 19 	ld.ub	r9,r7[537]
80007076:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000707a:	8f 48       	st.w	r7[0x10],r8
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win + FSI_Nxt_Free);
8000707c:	ef 39 02 1f 	ld.ub	r9,r7[543]
80007080:	ef 38 02 1e 	ld.ub	r8,r7[542]
80007084:	b1 68       	lsl	r8,0x10
80007086:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000708a:	ef 38 02 1c 	ld.ub	r8,r7[540]
8000708e:	f3 e8 10 08 	or	r8,r9,r8
80007092:	ef 39 02 1d 	ld.ub	r9,r7[541]
80007096:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000709a:	8f 38       	st.w	r7[0xc],r8
#endif
		}
	}
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
8000709c:	ae 86       	st.b	r7[0x0],r6
	fs->id = ++Fsid;	/* File system mount ID */
8000709e:	49 39       	lddpc	r9,800070e8 <find_volume+0x3a0>
800070a0:	92 08       	ld.sh	r8,r9[0x0]
800070a2:	2f f8       	sub	r8,-1
800070a4:	b2 08       	st.h	r9[0x0],r8
800070a6:	ae 38       	st.h	r7[0x6],r8
800070a8:	30 0c       	mov	r12,0
#endif
#if _FS_LOCK			/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
800070aa:	c0 68       	rjmp	800070b6 <find_volume+0x36e>
800070ac:	30 ac       	mov	r12,10
800070ae:	c0 48       	rjmp	800070b6 <find_volume+0x36e>
800070b0:	30 0c       	mov	r12,0
800070b2:	c0 28       	rjmp	800070b6 <find_volume+0x36e>
800070b4:	30 dc       	mov	r12,13
}
800070b6:	2f cd       	sub	sp,-16
800070b8:	e3 cd 80 fb 	ldm	sp++,r0-r1,r3-r7,pc
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
800070bc:	2f e9       	sub	r9,-2
800070be:	8f 59       	st.w	r7[0x14],r9
	fs->volbase = bsect;								/* Volume start sector */
800070c0:	8f 75       	st.w	r7[0x1c],r5
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
800070c2:	ea 03 00 03 	add	r3,r5,r3
800070c6:	8f 83       	st.w	r7[0x20],r3
	fs->database = bsect + sysect;						/* Data start sector */
800070c8:	0a 04       	add	r4,r5
800070ca:	8f a4       	st.w	r7[0x28],r4
800070cc:	30 36       	mov	r6,3
800070ce:	c4 ab       	rjmp	80006f62 <find_volume+0x21a>
800070d0:	80 00       	ld.sh	r0,r0[0x0]
800070d2:	63 b8       	ld.w	r8,r1[0x6c]
800070d4:	00 00       	add	r0,r0
800070d6:	11 50       	ld.sh	r0,--r8
800070d8:	80 00       	ld.sh	r0,r0[0x0]
800070da:	62 1c       	ld.w	r12,r1[0x4]
800070dc:	80 00       	ld.sh	r0,r0[0x0]
800070de:	62 1e       	ld.w	lr,r1[0x4]
800070e0:	80 00       	ld.sh	r0,r0[0x0]
800070e2:	6c ac       	ld.w	r12,r6[0x28]
800070e4:	80 00       	ld.sh	r0,r0[0x0]
800070e6:	6c 6c       	ld.w	r12,r6[0x18]
800070e8:	00 00       	add	r0,r0
800070ea:	11 4c       	ld.w	r12,--r8

800070ec <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
800070ec:	eb cd 40 40 	pushm	r6,lr
800070f0:	20 3d       	sub	sp,12
800070f2:	50 1c       	stdsp	sp[0x4],r12
800070f4:	50 0b       	stdsp	sp[0x0],r11
800070f6:	14 96       	mov	r6,r10
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
800070f8:	fa cc ff f4 	sub	r12,sp,-12
800070fc:	18 db       	st.w	--r12,r11


	vol = get_ldnumber(&rp);
800070fe:	f0 1f 00 1a 	mcall	80007164 <f_mount+0x78>
	if (vol < 0) return FR_INVALID_DRIVE;
80007102:	c0 34       	brge	80007108 <f_mount+0x1c>
80007104:	30 bc       	mov	r12,11
80007106:	c2 58       	rjmp	80007150 <f_mount+0x64>
	cfs = FatFs[vol];					/* Pointer to fs object */
80007108:	49 88       	lddpc	r8,80007168 <f_mount+0x7c>
8000710a:	f0 0c 03 28 	ld.w	r8,r8[r12<<0x2]
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
8000710e:	58 08       	cp.w	r8,0
80007110:	f9 b9 01 00 	movne	r9,0
80007114:	f1 f9 1e 00 	st.bne	r8[0x0],r9
	}

	if (fs) {
80007118:	40 18       	lddsp	r8,sp[0x4]
8000711a:	58 08       	cp.w	r8,0
8000711c:	c1 d0       	breq	80007156 <f_mount+0x6a>
		fs->fs_type = 0;				/* Clear new fs object */
8000711e:	30 09       	mov	r9,0
80007120:	b0 89       	st.b	r8[0x0],r9
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
80007122:	40 18       	lddsp	r8,sp[0x4]
80007124:	49 1a       	lddpc	r10,80007168 <f_mount+0x7c>
80007126:	f4 0c 09 28 	st.w	r10[r12<<0x2],r8

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
8000712a:	58 08       	cp.w	r8,0
8000712c:	5f 0a       	sreq	r10
8000712e:	30 18       	mov	r8,1
80007130:	f0 06 18 00 	cp.b	r6,r8
80007134:	5f 18       	srne	r8
80007136:	f5 e8 10 08 	or	r8,r10,r8
8000713a:	f2 08 18 00 	cp.b	r8,r9
8000713e:	c0 30       	breq	80007144 <f_mount+0x58>
80007140:	30 0c       	mov	r12,0
80007142:	c0 78       	rjmp	80007150 <f_mount+0x64>

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
80007144:	30 0a       	mov	r10,0
80007146:	1a 9b       	mov	r11,sp
80007148:	fa cc ff fc 	sub	r12,sp,-4
8000714c:	f0 1f 00 08 	mcall	8000716c <f_mount+0x80>
	LEAVE_FF(fs, res);
}
80007150:	2f dd       	sub	sp,-12
80007152:	e3 cd 80 40 	ldm	sp++,r6,pc
		fs->fs_type = 0;				/* Clear new fs object */
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
80007156:	30 08       	mov	r8,0
80007158:	48 49       	lddpc	r9,80007168 <f_mount+0x7c>
8000715a:	f2 0c 09 28 	st.w	r9[r12<<0x2],r8
8000715e:	10 9c       	mov	r12,r8
80007160:	cf 8b       	rjmp	80007150 <f_mount+0x64>
80007162:	00 00       	add	r0,r0
80007164:	80 00       	ld.sh	r0,r0[0x0]
80007166:	63 b8       	ld.w	r8,r1[0x6c]
80007168:	00 00       	add	r0,r0
8000716a:	11 50       	ld.sh	r0,--r8
8000716c:	80 00       	ld.sh	r0,r0[0x0]
8000716e:	6d 48       	ld.w	r8,r6[0x50]

80007170 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
80007170:	eb cd 40 c0 	pushm	r6-r7,lr
80007174:	18 97       	mov	r7,r12
	FRESULT res;
	DWORD tm;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
80007176:	f0 1f 00 2b 	mcall	80007220 <f_sync+0xb0>
	if (res == FR_OK) {
8000717a:	c5 11       	brne	8000721c <f_sync+0xac>
		if (fp->flag & FA__WRITTEN) {	/* Is there any change to the file? */
8000717c:	0f e8       	ld.ub	r8,r7[0x6]
8000717e:	10 99       	mov	r9,r8
80007180:	e2 19 00 20 	andl	r9,0x20,COH
80007184:	c4 c0       	breq	8000721c <f_sync+0xac>
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {	/* Write-back cached data if needed */
80007186:	e2 18 00 40 	andl	r8,0x40,COH
8000718a:	c0 f0       	breq	800071a8 <f_sync+0x38>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
8000718c:	6e 08       	ld.w	r8,r7[0x0]
8000718e:	30 19       	mov	r9,1
80007190:	6e 6a       	ld.w	r10,r7[0x18]
80007192:	ee cb ff d8 	sub	r11,r7,-40
80007196:	11 9c       	ld.ub	r12,r8[0x1]
80007198:	f0 1f 00 23 	mcall	80007224 <f_sync+0xb4>
8000719c:	c0 30       	breq	800071a2 <f_sync+0x32>
8000719e:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
800071a2:	0f e8       	ld.ub	r8,r7[0x6]
800071a4:	a7 c8       	cbr	r8,0x6
800071a6:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
800071a8:	6e 7b       	ld.w	r11,r7[0x1c]
800071aa:	6e 0c       	ld.w	r12,r7[0x0]
800071ac:	f0 1f 00 1f 	mcall	80007228 <f_sync+0xb8>
			if (res == FR_OK) {
800071b0:	c3 61       	brne	8000721c <f_sync+0xac>
				dir = fp->dir_ptr;
800071b2:	6e 86       	ld.w	r6,r7[0x20]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
800071b4:	ec c8 ff f5 	sub	r8,r6,-11
800071b8:	11 89       	ld.ub	r9,r8[0x0]
800071ba:	a5 b9       	sbr	r9,0x5
800071bc:	b0 89       	st.b	r8[0x0],r9
				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
800071be:	6e 38       	ld.w	r8,r7[0xc]
800071c0:	ed 68 00 1c 	st.b	r6[28],r8
800071c4:	ef 38 00 0e 	ld.ub	r8,r7[14]
800071c8:	ed 68 00 1d 	st.b	r6[29],r8
800071cc:	8e e8       	ld.uh	r8,r7[0xc]
800071ce:	ed 68 00 1e 	st.b	r6[30],r8
800071d2:	ef 38 00 0c 	ld.ub	r8,r7[12]
800071d6:	ed 68 00 1f 	st.b	r6[31],r8
				st_clust(dir, fp->sclust);					/* Update start cluster */
800071da:	6e 4b       	ld.w	r11,r7[0x10]
800071dc:	0c 9c       	mov	r12,r6
800071de:	f0 1f 00 14 	mcall	8000722c <f_sync+0xbc>
				tm = GET_FATTIME();							/* Update modified time */
800071e2:	f0 1f 00 14 	mcall	80007230 <f_sync+0xc0>
				ST_DWORD(dir + DIR_WrtTime, tm);
800071e6:	ed 6c 00 16 	st.b	r6[22],r12
800071ea:	f1 dc c1 08 	bfextu	r8,r12,0x8,0x8
800071ee:	ed 68 00 17 	st.b	r6[23],r8
800071f2:	f8 08 16 10 	lsr	r8,r12,0x10
800071f6:	ed 68 00 18 	st.b	r6[24],r8
800071fa:	b9 8c       	lsr	r12,0x18
800071fc:	ed 6c 00 19 	st.b	r6[25],r12
				ST_WORD(dir + DIR_LstAccDate, 0);
80007200:	30 08       	mov	r8,0
80007202:	ed 68 00 12 	st.b	r6[18],r8
80007206:	ed 68 00 13 	st.b	r6[19],r8
				fp->flag &= ~FA__WRITTEN;
8000720a:	0f e8       	ld.ub	r8,r7[0x6]
8000720c:	a5 d8       	cbr	r8,0x5
8000720e:	ae e8       	st.b	r7[0x6],r8
				fp->fs->wflag = 1;
80007210:	6e 08       	ld.w	r8,r7[0x0]
80007212:	30 19       	mov	r9,1
80007214:	b0 c9       	st.b	r8[0x4],r9
				res = sync_fs(fp->fs);
80007216:	6e 0c       	ld.w	r12,r7[0x0]
80007218:	f0 1f 00 07 	mcall	80007234 <f_sync+0xc4>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
8000721c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007220:	80 00       	ld.sh	r0,r0[0x0]
80007222:	6c 38       	ld.w	r8,r6[0xc]
80007224:	80 00       	ld.sh	r0,r0[0x0]
80007226:	62 ac       	ld.w	r12,r1[0x28]
80007228:	80 00       	ld.sh	r0,r0[0x0]
8000722a:	6c 6c       	ld.w	r12,r6[0x18]
8000722c:	80 00       	ld.sh	r0,r0[0x0]
8000722e:	63 9e       	ld.w	lr,r1[0x64]
80007230:	80 00       	ld.sh	r0,r0[0x0]
80007232:	62 20       	ld.w	r0,r1[0x8]
80007234:	80 00       	ld.sh	r0,r0[0x0]
80007236:	64 d8       	ld.w	r8,r2[0x34]

80007238 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
80007238:	eb cd 40 80 	pushm	r7,lr
8000723c:	18 97       	mov	r7,r12
	FRESULT res;


#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
8000723e:	f0 1f 00 07 	mcall	80007258 <f_close+0x20>
	if (res == FR_OK)
80007242:	c0 81       	brne	80007252 <f_close+0x1a>
#endif
	{
		res = validate(fp);				/* Lock volume */
80007244:	0e 9c       	mov	r12,r7
80007246:	f0 1f 00 06 	mcall	8000725c <f_close+0x24>
#endif
#if _FS_LOCK
			res = dec_lock(fp->lockid);	/* Decrement file open counter */
			if (res == FR_OK)
#endif
				fp->fs = 0;				/* Invalidate file object */
8000724a:	f9 b8 00 00 	moveq	r8,0
8000724e:	ef f8 0a 00 	st.weq	r7[0x0],r8
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
80007252:	e3 cd 80 80 	ldm	sp++,r7,pc
80007256:	00 00       	add	r0,r0
80007258:	80 00       	ld.sh	r0,r0[0x0]
8000725a:	71 70       	ld.w	r0,r8[0x5c]
8000725c:	80 00       	ld.sh	r0,r0[0x0]
8000725e:	6c 38       	ld.w	r8,r6[0xc]

80007260 <put_fat>:
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* File system object */
	DWORD clst,		/* FAT index number (cluster number) to be changed */
	DWORD val		/* New value to be set to the entry */
)
{
80007260:	d4 21       	pushm	r4-r7,lr
80007262:	18 97       	mov	r7,r12
80007264:	16 96       	mov	r6,r11
80007266:	14 95       	mov	r5,r10
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
80007268:	58 1b       	cp.w	r11,1
8000726a:	e0 88 00 90 	brls	8000738a <put_fat+0x12a>
8000726e:	78 58       	ld.w	r8,r12[0x14]
80007270:	10 3b       	cp.w	r11,r8
80007272:	e0 82 00 8c 	brhs	8000738a <put_fat+0x12a>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
80007276:	19 88       	ld.ub	r8,r12[0x0]
80007278:	30 29       	mov	r9,2
8000727a:	f2 08 18 00 	cp.b	r8,r9
8000727e:	c4 d0       	breq	80007318 <put_fat+0xb8>
80007280:	30 39       	mov	r9,3
80007282:	f2 08 18 00 	cp.b	r8,r9
80007286:	c5 e0       	breq	80007342 <put_fat+0xe2>
80007288:	30 19       	mov	r9,1
8000728a:	f2 08 18 00 	cp.b	r8,r9
8000728e:	c7 e1       	brne	8000738a <put_fat+0x12a>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
80007290:	f6 04 16 01 	lsr	r4,r11,0x1
80007294:	16 04       	add	r4,r11
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
80007296:	e8 0b 16 09 	lsr	r11,r4,0x9
8000729a:	78 88       	ld.w	r8,r12[0x20]
8000729c:	10 0b       	add	r11,r8
8000729e:	f0 1f 00 3d 	mcall	80007390 <put_fat+0x130>
			if (res != FR_OK) break;
800072a2:	c7 51       	brne	8000738c <put_fat+0x12c>
			p = &fs->win[bc++ % SS(fs)];
800072a4:	f1 d4 c0 09 	bfextu	r8,r4,0x0,0x9
800072a8:	2f f4       	sub	r4,-1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
800072aa:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
800072ae:	c0 d0       	breq	800072c8 <put_fat+0x68>
800072b0:	ee 08 00 09 	add	r9,r7,r8
800072b4:	f3 39 00 30 	ld.ub	r9,r9[48]
800072b8:	f5 d5 c0 08 	bfextu	r10,r5,0x0,0x8
800072bc:	f3 d9 c0 04 	bfextu	r9,r9,0x0,0x4
800072c0:	f3 ea 10 49 	or	r9,r9,r10<<0x4
800072c4:	5c 59       	castu.b	r9
800072c6:	c0 38       	rjmp	800072cc <put_fat+0x6c>
800072c8:	f3 d5 c0 08 	bfextu	r9,r5,0x0,0x8
800072cc:	ee 08 00 08 	add	r8,r7,r8
800072d0:	f1 69 00 30 	st.b	r8[48],r9
			fs->wflag = 1;
800072d4:	30 18       	mov	r8,1
800072d6:	ae c8       	st.b	r7[0x4],r8
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
800072d8:	e8 0b 16 09 	lsr	r11,r4,0x9
800072dc:	6e 88       	ld.w	r8,r7[0x20]
800072de:	10 0b       	add	r11,r8
800072e0:	0e 9c       	mov	r12,r7
800072e2:	f0 1f 00 2c 	mcall	80007390 <put_fat+0x130>
			if (res != FR_OK) break;
800072e6:	c5 31       	brne	8000738c <put_fat+0x12c>
			p = &fs->win[bc % SS(fs)];
800072e8:	e9 d4 c0 09 	bfextu	r4,r4,0x0,0x9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
800072ec:	58 06       	cp.w	r6,0
800072ee:	c0 40       	breq	800072f6 <put_fat+0x96>
800072f0:	eb d5 c0 88 	bfextu	r5,r5,0x4,0x8
800072f4:	c0 b8       	rjmp	8000730a <put_fat+0xaa>
800072f6:	ee 04 00 08 	add	r8,r7,r4
800072fa:	f1 38 00 30 	ld.ub	r8,r8[48]
800072fe:	eb d5 c1 04 	bfextu	r5,r5,0x8,0x4
80007302:	e2 18 00 f0 	andl	r8,0xf0,COH
80007306:	f1 e5 10 05 	or	r5,r8,r5
8000730a:	ee 04 00 04 	add	r4,r7,r4
8000730e:	e9 65 00 30 	st.b	r4[48],r5
			fs->wflag = 1;
80007312:	30 18       	mov	r8,1
80007314:	ae c8       	st.b	r7[0x4],r8
			break;
80007316:	d8 22       	popm	r4-r7,pc

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
80007318:	a9 8b       	lsr	r11,0x8
8000731a:	78 88       	ld.w	r8,r12[0x20]
8000731c:	10 0b       	add	r11,r8
8000731e:	f0 1f 00 1d 	mcall	80007390 <put_fat+0x130>
			if (res != FR_OK) break;
80007322:	c3 51       	brne	8000738c <put_fat+0x12c>
			p = &fs->win[clst * 2 % SS(fs)];
80007324:	a1 76       	lsl	r6,0x1
80007326:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
			ST_WORD(p, (WORD)val);
8000732a:	ee 06 00 08 	add	r8,r7,r6
8000732e:	f1 65 00 30 	st.b	r8[48],r5
80007332:	10 96       	mov	r6,r8
80007334:	eb d5 c1 08 	bfextu	r5,r5,0x8,0x8
80007338:	f1 65 00 31 	st.b	r8[49],r5
			fs->wflag = 1;
8000733c:	30 18       	mov	r8,1
8000733e:	ae c8       	st.b	r7[0x4],r8
			break;
80007340:	d8 22       	popm	r4-r7,pc

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
80007342:	a7 9b       	lsr	r11,0x7
80007344:	78 88       	ld.w	r8,r12[0x20]
80007346:	10 0b       	add	r11,r8
80007348:	f0 1f 00 12 	mcall	80007390 <put_fat+0x130>
			if (res != FR_OK) break;
8000734c:	c2 01       	brne	8000738c <put_fat+0x12c>
			p = &fs->win[clst * 4 % SS(fs)];
8000734e:	a3 66       	lsl	r6,0x2
80007350:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
80007354:	ec c8 ff d0 	sub	r8,r6,-48
80007358:	ee 08 00 08 	add	r8,r7,r8
			val |= LD_DWORD(p) & 0xF0000000;
8000735c:	f0 c9 ff fd 	sub	r9,r8,-3
80007360:	13 8a       	ld.ub	r10,r9[0x0]
80007362:	b9 6a       	lsl	r10,0x18
80007364:	ee 06 00 06 	add	r6,r7,r6
80007368:	e6 1a f0 00 	andh	r10,0xf000,COH
8000736c:	f5 e5 10 05 	or	r5,r10,r5
			ST_DWORD(p, val);
80007370:	ed 65 00 30 	st.b	r6[48],r5
80007374:	f5 d5 c1 08 	bfextu	r10,r5,0x8,0x8
80007378:	b0 9a       	st.b	r8[0x1],r10
8000737a:	ea 0a 16 10 	lsr	r10,r5,0x10
8000737e:	b0 aa       	st.b	r8[0x2],r10
80007380:	b9 85       	lsr	r5,0x18
80007382:	b2 85       	st.b	r9[0x0],r5
			fs->wflag = 1;
80007384:	30 18       	mov	r8,1
80007386:	ae c8       	st.b	r7[0x4],r8
			break;
80007388:	d8 22       	popm	r4-r7,pc
8000738a:	30 2c       	mov	r12,2
			res = FR_INT_ERR;
		}
	}

	return res;
}
8000738c:	d8 22       	popm	r4-r7,pc
8000738e:	00 00       	add	r0,r0
80007390:	80 00       	ld.sh	r0,r0[0x0]
80007392:	6c 6c       	ld.w	r12,r6[0x18]

80007394 <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x0FFFFFFF:Cluster status */
	FATFS* fs,	/* File system object */
	DWORD clst	/* FAT index number (cluster number) to get the value */
)
{
80007394:	d4 21       	pushm	r4-r7,lr
80007396:	18 97       	mov	r7,r12
80007398:	16 96       	mov	r6,r11
	UINT wc, bc;
	BYTE *p;
	DWORD val;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
8000739a:	58 1b       	cp.w	r11,1
8000739c:	e0 88 00 69 	brls	8000746e <get_fat+0xda>
800073a0:	78 58       	ld.w	r8,r12[0x14]
800073a2:	10 3b       	cp.w	r11,r8
800073a4:	c6 52       	brcc	8000746e <get_fat+0xda>
		val = 1;	/* Internal error */

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */

		switch (fs->fs_type) {
800073a6:	19 88       	ld.ub	r8,r12[0x0]
800073a8:	30 29       	mov	r9,2
800073aa:	f2 08 18 00 	cp.b	r8,r9
800073ae:	c3 10       	breq	80007410 <get_fat+0x7c>
800073b0:	30 39       	mov	r9,3
800073b2:	f2 08 18 00 	cp.b	r8,r9
800073b6:	c4 00       	breq	80007436 <get_fat+0xa2>
800073b8:	30 19       	mov	r9,1
800073ba:	f2 08 18 00 	cp.b	r8,r9
800073be:	c5 81       	brne	8000746e <get_fat+0xda>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
800073c0:	f6 05 16 01 	lsr	r5,r11,0x1
800073c4:	16 05       	add	r5,r11
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
800073c6:	ea 0b 16 09 	lsr	r11,r5,0x9
800073ca:	78 88       	ld.w	r8,r12[0x20]
800073cc:	10 0b       	add	r11,r8
800073ce:	f0 1f 00 2a 	mcall	80007474 <get_fat+0xe0>
800073d2:	c4 f1       	brne	80007470 <get_fat+0xdc>
			wc = fs->win[bc++ % SS(fs)];
800073d4:	f1 d5 c0 09 	bfextu	r8,r5,0x0,0x9
800073d8:	ee 08 00 08 	add	r8,r7,r8
800073dc:	f1 34 00 30 	ld.ub	r4,r8[48]
800073e0:	2f f5       	sub	r5,-1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
800073e2:	ea 0b 16 09 	lsr	r11,r5,0x9
800073e6:	6e 88       	ld.w	r8,r7[0x20]
800073e8:	10 0b       	add	r11,r8
800073ea:	0e 9c       	mov	r12,r7
800073ec:	f0 1f 00 22 	mcall	80007474 <get_fat+0xe0>
800073f0:	c4 01       	brne	80007470 <get_fat+0xdc>
			wc |= fs->win[bc % SS(fs)] << 8;
800073f2:	eb d5 c0 09 	bfextu	r5,r5,0x0,0x9
800073f6:	0a 07       	add	r7,r5
800073f8:	ef 3c 00 30 	ld.ub	r12,r7[48]
800073fc:	e9 ec 10 8c 	or	r12,r4,r12<<0x8
			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
80007400:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
80007404:	c0 30       	breq	8000740a <get_fat+0x76>
80007406:	a5 8c       	lsr	r12,0x4
80007408:	d8 22       	popm	r4-r7,pc
8000740a:	f9 dc c0 0c 	bfextu	r12,r12,0x0,0xc
8000740e:	d8 22       	popm	r4-r7,pc
			break;

		case FS_FAT16 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
80007410:	a9 8b       	lsr	r11,0x8
80007412:	78 88       	ld.w	r8,r12[0x20]
80007414:	10 0b       	add	r11,r8
80007416:	f0 1f 00 18 	mcall	80007474 <get_fat+0xe0>
8000741a:	c2 b1       	brne	80007470 <get_fat+0xdc>
			p = &fs->win[clst * 2 % SS(fs)];
8000741c:	a1 76       	lsl	r6,0x1
8000741e:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
			val = LD_WORD(p);
80007422:	ee 06 00 08 	add	r8,r7,r6
80007426:	10 97       	mov	r7,r8
80007428:	f1 3c 00 31 	ld.ub	r12,r8[49]
8000742c:	f1 38 00 30 	ld.ub	r8,r8[48]
80007430:	f1 ec 10 8c 	or	r12,r8,r12<<0x8
			break;
80007434:	d8 22       	popm	r4-r7,pc

		case FS_FAT32 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
80007436:	a7 9b       	lsr	r11,0x7
80007438:	78 88       	ld.w	r8,r12[0x20]
8000743a:	10 0b       	add	r11,r8
8000743c:	f0 1f 00 0e 	mcall	80007474 <get_fat+0xe0>
80007440:	c1 81       	brne	80007470 <get_fat+0xdc>
			p = &fs->win[clst * 4 % SS(fs)];
80007442:	a3 66       	lsl	r6,0x2
80007444:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
80007448:	ec c8 ff d0 	sub	r8,r6,-48
8000744c:	ee 08 00 08 	add	r8,r7,r8
			val = LD_DWORD(p) & 0x0FFFFFFF;
80007450:	11 a9       	ld.ub	r9,r8[0x2]
80007452:	11 bc       	ld.ub	r12,r8[0x3]
80007454:	b9 6c       	lsl	r12,0x18
80007456:	f9 e9 11 0c 	or	r12,r12,r9<<0x10
8000745a:	11 98       	ld.ub	r8,r8[0x1]
8000745c:	f9 e8 10 8c 	or	r12,r12,r8<<0x8
80007460:	0c 07       	add	r7,r6
80007462:	ef 38 00 30 	ld.ub	r8,r7[48]
80007466:	10 4c       	or	r12,r8
80007468:	f9 dc c0 1c 	bfextu	r12,r12,0x0,0x1c
			break;
8000746c:	d8 22       	popm	r4-r7,pc
8000746e:	da 2a       	popm	r4-r7,pc,r12=1
80007470:	dc 2a       	popm	r4-r7,pc,r12=-1
80007472:	00 00       	add	r0,r0
80007474:	80 00       	ld.sh	r0,r0[0x0]
80007476:	6c 6c       	ld.w	r12,r6[0x18]

80007478 <dir_sdi>:
static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to directory object */
	UINT idx		/* Index of directory table */
)
{
80007478:	eb cd 40 f8 	pushm	r3-r7,lr
8000747c:	18 96       	mov	r6,r12
8000747e:	16 95       	mov	r5,r11
	DWORD clst, sect;
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
80007480:	ac 3b       	st.h	r6[0x6],r11
	clst = dp->sclust;		/* Table start cluster (0:root) */
80007482:	78 28       	ld.w	r8,r12[0x8]
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
80007484:	58 18       	cp.w	r8,1
80007486:	c4 c0       	breq	8000751e <dir_sdi+0xa6>
80007488:	78 09       	ld.w	r9,r12[0x0]
8000748a:	72 5a       	ld.w	r10,r9[0x14]
8000748c:	14 38       	cp.w	r8,r10
8000748e:	c4 82       	brcc	8000751e <dir_sdi+0xa6>
		return FR_INT_ERR;
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
80007490:	58 08       	cp.w	r8,0
80007492:	c0 f1       	brne	800074b0 <dir_sdi+0x38>
80007494:	13 8b       	ld.ub	r11,r9[0x0]
80007496:	30 3a       	mov	r10,3
80007498:	f4 0b 18 00 	cp.b	r11,r10
8000749c:	c0 41       	brne	800074a4 <dir_sdi+0x2c>
		clst = dp->fs->dirbase;
8000749e:	72 97       	ld.w	r7,r9[0x24]

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
800074a0:	58 07       	cp.w	r7,0
800074a2:	c0 81       	brne	800074b2 <dir_sdi+0x3a>
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
800074a4:	92 ca       	ld.uh	r10,r9[0x8]
800074a6:	14 35       	cp.w	r5,r10
800074a8:	c3 b2       	brcc	8000751e <dir_sdi+0xa6>
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
800074aa:	72 9c       	ld.w	r12,r9[0x24]
800074ac:	10 97       	mov	r7,r8
800074ae:	c2 68       	rjmp	800074fa <dir_sdi+0x82>
800074b0:	10 97       	mov	r7,r8
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
800074b2:	13 a4       	ld.ub	r4,r9[0x2]
800074b4:	a5 64       	lsl	r4,0x4
		while (idx >= ic) {	/* Follow cluster chain */
800074b6:	08 35       	cp.w	r5,r4
800074b8:	c1 d3       	brcs	800074f2 <dir_sdi+0x7a>
/*-----------------------------------------------------------------------*/
/* Directory handling - Set directory index                              */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
800074ba:	e8 03 11 00 	rsub	r3,r4,0
800074be:	08 15       	sub	r5,r4
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
800074c0:	0e 9b       	mov	r11,r7
800074c2:	6c 0c       	ld.w	r12,r6[0x0]
800074c4:	f0 1f 00 18 	mcall	80007524 <dir_sdi+0xac>
800074c8:	18 97       	mov	r7,r12
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
800074ca:	5b fc       	cp.w	r12,-1
800074cc:	c0 31       	brne	800074d2 <dir_sdi+0x5a>
800074ce:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
800074d2:	58 1c       	cp.w	r12,1
800074d4:	e0 88 00 25 	brls	8000751e <dir_sdi+0xa6>
800074d8:	6c 08       	ld.w	r8,r6[0x0]
800074da:	70 58       	ld.w	r8,r8[0x14]
800074dc:	10 3c       	cp.w	r12,r8
800074de:	c2 02       	brcc	8000751e <dir_sdi+0xa6>
800074e0:	ea 03 00 08 	add	r8,r5,r3
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
800074e4:	f0 04 00 09 	add	r9,r8,r4
800074e8:	12 34       	cp.w	r4,r9
800074ea:	e0 8b 00 04 	brhi	800074f2 <dir_sdi+0x7a>
800074ee:	10 95       	mov	r5,r8
800074f0:	ce 8b       	rjmp	800074c0 <dir_sdi+0x48>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
				return FR_INT_ERR;
			idx -= ic;
		}
		sect = clust2sect(dp->fs, clst);
800074f2:	0e 9b       	mov	r11,r7
800074f4:	6c 0c       	ld.w	r12,r6[0x0]
800074f6:	f0 1f 00 0d 	mcall	80007528 <dir_sdi+0xb0>
	}
	dp->clust = clst;	/* Current cluster# */
800074fa:	8d 37       	st.w	r6[0xc],r7
	if (!sect) return FR_INT_ERR;
800074fc:	58 0c       	cp.w	r12,0
800074fe:	c1 00       	breq	8000751e <dir_sdi+0xa6>
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
80007500:	ea 08 16 04 	lsr	r8,r5,0x4
80007504:	f0 0c 00 0c 	add	r12,r8,r12
80007508:	8d 4c       	st.w	r6[0x10],r12
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
8000750a:	6c 08       	ld.w	r8,r6[0x0]
8000750c:	2d 08       	sub	r8,-48
8000750e:	eb d5 c0 04 	bfextu	r5,r5,0x0,0x4
80007512:	a5 75       	lsl	r5,0x5
80007514:	f0 05 00 05 	add	r5,r8,r5
80007518:	8d 55       	st.w	r6[0x14],r5
8000751a:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0

	return FR_OK;
8000751e:	30 2c       	mov	r12,2
}
80007520:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80007524:	80 00       	ld.sh	r0,r0[0x0]
80007526:	73 94       	ld.w	r4,r9[0x64]
80007528:	80 00       	ld.sh	r0,r0[0x0]
8000752a:	63 20       	ld.w	r0,r1[0x48]

8000752c <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
)
{
8000752c:	eb cd 40 fc 	pushm	r2-r7,lr
80007530:	18 96       	mov	r6,r12
80007532:	16 92       	mov	r2,r11
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
80007534:	58 0b       	cp.w	r11,0
80007536:	c0 81       	brne	80007546 <create_chain+0x1a>
		scl = fs->last_clust;			/* Get suggested start point */
80007538:	78 35       	ld.w	r5,r12[0xc]
		if (!scl || scl >= fs->n_fatent) scl = 1;
8000753a:	58 05       	cp.w	r5,0
8000753c:	c1 10       	breq	8000755e <create_chain+0x32>
8000753e:	78 58       	ld.w	r8,r12[0x14]
80007540:	10 35       	cp.w	r5,r8
80007542:	c0 e2       	brcc	8000755e <create_chain+0x32>
80007544:	c0 e8       	rjmp	80007560 <create_chain+0x34>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
80007546:	f0 1f 00 2c 	mcall	800075f4 <create_chain+0xc8>
		if (cs < 2) return 1;			/* Invalid value */
8000754a:	58 1c       	cp.w	r12,1
8000754c:	e0 88 00 4f 	brls	800075ea <create_chain+0xbe>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
80007550:	5b fc       	cp.w	r12,-1
80007552:	c4 f0       	breq	800075f0 <create_chain+0xc4>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
80007554:	6c 58       	ld.w	r8,r6[0x14]
80007556:	10 3c       	cp.w	r12,r8
80007558:	c4 c3       	brcs	800075f0 <create_chain+0xc4>
8000755a:	04 95       	mov	r5,r2
8000755c:	c0 28       	rjmp	80007560 <create_chain+0x34>
8000755e:	30 15       	mov	r5,1
80007560:	0a 97       	mov	r7,r5
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
80007562:	30 23       	mov	r3,2
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
80007564:	30 04       	mov	r4,0
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
80007566:	2f f7       	sub	r7,-1
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
80007568:	6c 58       	ld.w	r8,r6[0x14]
8000756a:	10 37       	cp.w	r7,r8
8000756c:	c0 53       	brcs	80007576 <create_chain+0x4a>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
8000756e:	58 15       	cp.w	r5,1
80007570:	e0 88 00 3f 	brls	800075ee <create_chain+0xc2>
80007574:	06 97       	mov	r7,r3
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
80007576:	0e 9b       	mov	r11,r7
80007578:	0c 9c       	mov	r12,r6
8000757a:	f0 1f 00 1f 	mcall	800075f4 <create_chain+0xc8>
		if (cs == 0) break;				/* Found a free cluster */
8000757e:	c0 d0       	breq	80007598 <create_chain+0x6c>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
80007580:	5b fc       	cp.w	r12,-1
80007582:	5f 09       	sreq	r9
80007584:	58 1c       	cp.w	r12,1
80007586:	5f 08       	sreq	r8
80007588:	f3 e8 10 08 	or	r8,r9,r8
8000758c:	e8 08 18 00 	cp.b	r8,r4
80007590:	c3 01       	brne	800075f0 <create_chain+0xc4>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
80007592:	0a 37       	cp.w	r7,r5
80007594:	ce 91       	brne	80007566 <create_chain+0x3a>
80007596:	c2 c8       	rjmp	800075ee <create_chain+0xc2>
80007598:	0e 95       	mov	r5,r7
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
8000759a:	e0 6a ff ff 	mov	r10,65535
8000759e:	ea 1a 0f ff 	orh	r10,0xfff
800075a2:	0e 9b       	mov	r11,r7
800075a4:	0c 9c       	mov	r12,r6
800075a6:	f0 1f 00 15 	mcall	800075f8 <create_chain+0xcc>
	if (res == FR_OK && clst != 0) {
800075aa:	5f 09       	sreq	r9
800075ac:	58 02       	cp.w	r2,0
800075ae:	5f 18       	srne	r8
800075b0:	f3 e8 00 08 	and	r8,r9,r8
800075b4:	c0 60       	breq	800075c0 <create_chain+0x94>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
800075b6:	0e 9a       	mov	r10,r7
800075b8:	04 9b       	mov	r11,r2
800075ba:	0c 9c       	mov	r12,r6
800075bc:	f0 1f 00 0f 	mcall	800075f8 <create_chain+0xcc>
	}
	if (res == FR_OK) {
800075c0:	58 0c       	cp.w	r12,0
800075c2:	c1 01       	brne	800075e2 <create_chain+0xb6>
		fs->last_clust = ncl;			/* Update FSINFO */
800075c4:	8d 35       	st.w	r6[0xc],r5
		if (fs->free_clust != 0xFFFFFFFF) {
800075c6:	6c 48       	ld.w	r8,r6[0x10]
800075c8:	5b f8       	cp.w	r8,-1
800075ca:	c0 41       	brne	800075d2 <create_chain+0xa6>
800075cc:	0e 9c       	mov	r12,r7
800075ce:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
			fs->free_clust--;
800075d2:	20 18       	sub	r8,1
800075d4:	8d 48       	st.w	r6[0x10],r8
			fs->fsi_flag |= 1;
800075d6:	0d d8       	ld.ub	r8,r6[0x5]
800075d8:	a1 a8       	sbr	r8,0x0
800075da:	ac d8       	st.b	r6[0x5],r8
800075dc:	0e 9c       	mov	r12,r7
800075de:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
800075e2:	58 1c       	cp.w	r12,1
800075e4:	c0 31       	brne	800075ea <create_chain+0xbe>
800075e6:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
800075ea:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
800075ee:	30 0c       	mov	r12,0
	}

	return ncl;		/* Return new cluster number or error code */
}
800075f0:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800075f4:	80 00       	ld.sh	r0,r0[0x0]
800075f6:	73 94       	ld.w	r4,r9[0x64]
800075f8:	80 00       	ld.sh	r0,r0[0x0]
800075fa:	72 60       	ld.w	r0,r9[0x18]

800075fc <dir_next>:
static
FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
800075fc:	eb cd 40 fc 	pushm	r2-r7,lr
80007600:	18 97       	mov	r7,r12
80007602:	16 96       	mov	r6,r11
#if !_FS_READONLY
	UINT c;
#endif


	i = dp->index + 1;
80007604:	98 b5       	ld.uh	r5,r12[0x6]
80007606:	2f f5       	sub	r5,-1
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
80007608:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000760c:	c6 d0       	breq	800076e6 <dir_next+0xea>
8000760e:	78 48       	ld.w	r8,r12[0x10]
80007610:	58 08       	cp.w	r8,0
80007612:	c6 a0       	breq	800076e6 <dir_next+0xea>
		return FR_NO_FILE;

	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
80007614:	e9 d5 c0 04 	bfextu	r4,r5,0x0,0x4
80007618:	c5 e1       	brne	800076d4 <dir_next+0xd8>
		dp->sect++;					/* Next sector */
8000761a:	2f f8       	sub	r8,-1
8000761c:	99 48       	st.w	r12[0x10],r8

		if (!dp->clust) {		/* Static table */
8000761e:	78 3b       	ld.w	r11,r12[0xc]
80007620:	58 0b       	cp.w	r11,0
80007622:	c0 61       	brne	8000762e <dir_next+0x32>
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
80007624:	78 08       	ld.w	r8,r12[0x0]
80007626:	90 c8       	ld.uh	r8,r8[0x8]
80007628:	10 35       	cp.w	r5,r8
8000762a:	c5 53       	brcs	800076d4 <dir_next+0xd8>
8000762c:	c5 d8       	rjmp	800076e6 <dir_next+0xea>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
8000762e:	78 0c       	ld.w	r12,r12[0x0]
80007630:	19 a8       	ld.ub	r8,r12[0x2]
80007632:	20 18       	sub	r8,1
80007634:	f1 e5 02 48 	and	r8,r8,r5>>0x4
80007638:	c4 e1       	brne	800076d4 <dir_next+0xd8>
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
8000763a:	f0 1f 00 30 	mcall	800076f8 <dir_next+0xfc>
8000763e:	18 93       	mov	r3,r12
				if (clst <= 1) return FR_INT_ERR;
80007640:	58 1c       	cp.w	r12,1
80007642:	e0 88 00 55 	brls	800076ec <dir_next+0xf0>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
80007646:	5b fc       	cp.w	r12,-1
80007648:	c5 50       	breq	800076f2 <dir_next+0xf6>
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
8000764a:	6e 0c       	ld.w	r12,r7[0x0]
8000764c:	78 58       	ld.w	r8,r12[0x14]
8000764e:	10 33       	cp.w	r3,r8
80007650:	c3 c3       	brcs	800076c8 <dir_next+0xcc>
#if !_FS_READONLY
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
80007652:	58 06       	cp.w	r6,0
80007654:	c4 90       	breq	800076e6 <dir_next+0xea>
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
80007656:	6e 3b       	ld.w	r11,r7[0xc]
80007658:	f0 1f 00 29 	mcall	800076fc <dir_next+0x100>
8000765c:	18 93       	mov	r3,r12
					if (clst == 0) return FR_DENIED;			/* No free cluster */
8000765e:	c0 41       	brne	80007666 <dir_next+0x6a>
80007660:	30 7c       	mov	r12,7
80007662:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
					if (clst == 1) return FR_INT_ERR;
80007666:	58 1c       	cp.w	r12,1
80007668:	c4 20       	breq	800076ec <dir_next+0xf0>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
8000766a:	5b fc       	cp.w	r12,-1
8000766c:	c4 30       	breq	800076f2 <dir_next+0xf6>
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
8000766e:	6e 0c       	ld.w	r12,r7[0x0]
80007670:	f0 1f 00 24 	mcall	80007700 <dir_next+0x104>
80007674:	c3 f1       	brne	800076f2 <dir_next+0xf6>
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
80007676:	6e 0c       	ld.w	r12,r7[0x0]
80007678:	e0 6a 02 00 	mov	r10,512
8000767c:	30 0b       	mov	r11,0
8000767e:	2d 0c       	sub	r12,-48
80007680:	f0 1f 00 21 	mcall	80007704 <dir_next+0x108>
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
80007684:	6e 06       	ld.w	r6,r7[0x0]
80007686:	06 9b       	mov	r11,r3
80007688:	0c 9c       	mov	r12,r6
8000768a:	f0 1f 00 20 	mcall	80007708 <dir_next+0x10c>
8000768e:	8d bc       	st.w	r6[0x2c],r12
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
80007690:	6e 08       	ld.w	r8,r7[0x0]
80007692:	11 aa       	ld.ub	r10,r8[0x2]
80007694:	30 09       	mov	r9,0
80007696:	f2 0a 18 00 	cp.b	r10,r9
8000769a:	c0 31       	brne	800076a0 <dir_next+0xa4>
8000769c:	30 06       	mov	r6,0
8000769e:	c1 28       	rjmp	800076c2 <dir_next+0xc6>
800076a0:	30 06       	mov	r6,0
						dp->fs->wflag = 1;
800076a2:	30 12       	mov	r2,1
800076a4:	b0 c2       	st.b	r8[0x4],r2
						if (sync_window(dp->fs)) return FR_DISK_ERR;
800076a6:	6e 0c       	ld.w	r12,r7[0x0]
800076a8:	f0 1f 00 16 	mcall	80007700 <dir_next+0x104>
800076ac:	c2 31       	brne	800076f2 <dir_next+0xf6>
						dp->fs->winsect++;
800076ae:	6e 08       	ld.w	r8,r7[0x0]
800076b0:	70 b9       	ld.w	r9,r8[0x2c]
800076b2:	2f f9       	sub	r9,-1
800076b4:	91 b9       	st.w	r8[0x2c],r9
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
800076b6:	2f f6       	sub	r6,-1
800076b8:	6e 08       	ld.w	r8,r7[0x0]
800076ba:	11 a9       	ld.ub	r9,r8[0x2]
800076bc:	0c 39       	cp.w	r9,r6
800076be:	fe 9b ff f3 	brhi	800076a4 <dir_next+0xa8>
						dp->fs->wflag = 1;
						if (sync_window(dp->fs)) return FR_DISK_ERR;
						dp->fs->winsect++;
					}
					dp->fs->winsect -= c;						/* Rewind window offset */
800076c2:	70 b9       	ld.w	r9,r8[0x2c]
800076c4:	0c 19       	sub	r9,r6
800076c6:	91 b9       	st.w	r8[0x2c],r9
#else
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
					return FR_NO_FILE;							/* Report EOT */
#endif
				}
				dp->clust = clst;				/* Initialize data for new cluster */
800076c8:	8f 33       	st.w	r7[0xc],r3
				dp->sect = clust2sect(dp->fs, clst);
800076ca:	06 9b       	mov	r11,r3
800076cc:	6e 0c       	ld.w	r12,r7[0x0]
800076ce:	f0 1f 00 0f 	mcall	80007708 <dir_next+0x10c>
800076d2:	8f 4c       	st.w	r7[0x10],r12
			}
		}
	}

	dp->index = (WORD)i;	/* Current index */
800076d4:	ae 35       	st.h	r7[0x6],r5
	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
800076d6:	6e 08       	ld.w	r8,r7[0x0]
800076d8:	2d 08       	sub	r8,-48
800076da:	a5 74       	lsl	r4,0x5
800076dc:	f0 04 00 04 	add	r4,r8,r4
800076e0:	8f 54       	st.w	r7[0x14],r4
800076e2:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

	return FR_OK;
800076e6:	30 4c       	mov	r12,4
800076e8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800076ec:	30 2c       	mov	r12,2
800076ee:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800076f2:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
800076f6:	00 00       	add	r0,r0
800076f8:	80 00       	ld.sh	r0,r0[0x0]
800076fa:	73 94       	ld.w	r4,r9[0x64]
800076fc:	80 00       	ld.sh	r0,r0[0x0]
800076fe:	75 2c       	ld.w	r12,r10[0x48]
80007700:	80 00       	ld.sh	r0,r0[0x0]
80007702:	64 74       	ld.w	r4,r2[0x1c]
80007704:	80 00       	ld.sh	r0,r0[0x0]
80007706:	62 fa       	ld.w	r10,r1[0x3c]
80007708:	80 00       	ld.sh	r0,r0[0x0]
8000770a:	63 20       	ld.w	r0,r1[0x48]

8000770c <remove_chain>:
static
FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
8000770c:	d4 21       	pushm	r4-r7,lr
8000770e:	18 97       	mov	r7,r12
80007710:	16 95       	mov	r5,r11
	DWORD nxt;
#if _USE_TRIM
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
80007712:	58 1b       	cp.w	r11,1
80007714:	e0 88 00 26 	brls	80007760 <remove_chain+0x54>
80007718:	78 58       	ld.w	r8,r12[0x14]
8000771a:	10 3b       	cp.w	r11,r8
8000771c:	c2 22       	brcc	80007760 <remove_chain+0x54>
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
8000771e:	30 04       	mov	r4,0
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
80007720:	0a 9b       	mov	r11,r5
80007722:	0e 9c       	mov	r12,r7
80007724:	f0 1f 00 10 	mcall	80007764 <remove_chain+0x58>
80007728:	18 96       	mov	r6,r12
			if (nxt == 0) break;				/* Empty cluster? */
8000772a:	c0 21       	brne	8000772e <remove_chain+0x22>
8000772c:	d8 2a       	popm	r4-r7,pc,r12=0
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
8000772e:	58 1c       	cp.w	r12,1
80007730:	c1 80       	breq	80007760 <remove_chain+0x54>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
80007732:	5b fc       	cp.w	r12,-1
80007734:	c0 21       	brne	80007738 <remove_chain+0x2c>
80007736:	da 2a       	popm	r4-r7,pc,r12=1
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
80007738:	08 9a       	mov	r10,r4
8000773a:	0a 9b       	mov	r11,r5
8000773c:	0e 9c       	mov	r12,r7
8000773e:	f0 1f 00 0b 	mcall	80007768 <remove_chain+0x5c>
			if (res != FR_OK) break;
80007742:	c1 01       	brne	80007762 <remove_chain+0x56>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
80007744:	6e 48       	ld.w	r8,r7[0x10]
80007746:	5b f8       	cp.w	r8,-1
80007748:	c0 60       	breq	80007754 <remove_chain+0x48>
				fs->free_clust++;
8000774a:	2f f8       	sub	r8,-1
8000774c:	8f 48       	st.w	r7[0x10],r8
				fs->fsi_flag |= 1;
8000774e:	0f d8       	ld.ub	r8,r7[0x5]
80007750:	a1 a8       	sbr	r8,0x0
80007752:	ae d8       	st.b	r7[0x5],r8
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
80007754:	6e 58       	ld.w	r8,r7[0x14]
80007756:	0c 38       	cp.w	r8,r6
80007758:	e0 88 00 05 	brls	80007762 <remove_chain+0x56>
8000775c:	0c 95       	mov	r5,r6
8000775e:	ce 1b       	rjmp	80007720 <remove_chain+0x14>
80007760:	30 2c       	mov	r12,2
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
80007762:	d8 22       	popm	r4-r7,pc
80007764:	80 00       	ld.sh	r0,r0[0x0]
80007766:	73 94       	ld.w	r4,r9[0x64]
80007768:	80 00       	ld.sh	r0,r0[0x0]
8000776a:	72 60       	ld.w	r0,r9[0x18]

8000776c <dir_read>:
static
FRESULT dir_read (
	DIR* dp,		/* Pointer to the directory object */
	int vol			/* Filtered by 0:file/directory or 1:volume label */
)
{
8000776c:	eb cd 40 fe 	pushm	r1-r7,lr
80007770:	18 97       	mov	r7,r12
80007772:	16 91       	mov	r1,r11
80007774:	30 4c       	mov	r12,4
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
80007776:	3e 56       	mov	r6,-27
80007778:	32 e5       	mov	r5,46
8000777a:	30 04       	mov	r4,0
8000777c:	30 f2       	mov	r2,15
			break;
#endif
		res = dir_next(dp, 0);				/* Next entry */
8000777e:	30 03       	mov	r3,0
#if _USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dp->sect) {
80007780:	c2 58       	rjmp	800077ca <dir_read+0x5e>
		res = move_window(dp->fs, dp->sect);
80007782:	6e 0c       	ld.w	r12,r7[0x0]
80007784:	f0 1f 00 17 	mcall	800077e0 <dir_read+0x74>
		if (res != FR_OK) break;
80007788:	c2 61       	brne	800077d4 <dir_read+0x68>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
8000778a:	6e 59       	ld.w	r9,r7[0x14]
		c = dir[DIR_Name];
8000778c:	13 88       	ld.ub	r8,r9[0x0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
8000778e:	58 08       	cp.w	r8,0
80007790:	c2 60       	breq	800077dc <dir_read+0x70>
		a = dir[DIR_Attr] & AM_MASK;
80007792:	f3 3a 00 0b 	ld.ub	r10,r9[11]
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
80007796:	ec 08 18 00 	cp.b	r8,r6
8000779a:	5f 19       	srne	r9
8000779c:	ea 08 18 00 	cp.b	r8,r5
800077a0:	5f 18       	srne	r8
800077a2:	f3 e8 00 08 	and	r8,r9,r8
800077a6:	e8 08 18 00 	cp.b	r8,r4
800077aa:	c0 b0       	breq	800077c0 <dir_read+0x54>
		res = move_window(dp->fs, dp->sect);
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
		a = dir[DIR_Attr] & AM_MASK;
800077ac:	f1 da c0 06 	bfextu	r8,r10,0x0,0x6
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
800077b0:	e4 08 18 00 	cp.b	r8,r2
800077b4:	c0 60       	breq	800077c0 <dir_read+0x54>
800077b6:	a5 d8       	cbr	r8,0x5
800077b8:	58 88       	cp.w	r8,8
800077ba:	5f 08       	sreq	r8
800077bc:	02 38       	cp.w	r8,r1
800077be:	c0 d0       	breq	800077d8 <dir_read+0x6c>
			break;
#endif
		res = dir_next(dp, 0);				/* Next entry */
800077c0:	06 9b       	mov	r11,r3
800077c2:	0e 9c       	mov	r12,r7
800077c4:	f0 1f 00 08 	mcall	800077e4 <dir_read+0x78>
		if (res != FR_OK) break;
800077c8:	c0 61       	brne	800077d4 <dir_read+0x68>
#if _USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dp->sect) {
800077ca:	6e 4b       	ld.w	r11,r7[0x10]
800077cc:	58 0b       	cp.w	r11,0
800077ce:	cd a1       	brne	80007782 <dir_read+0x16>
#endif
		res = dir_next(dp, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dp->sect = 0;
800077d0:	58 0c       	cp.w	r12,0
800077d2:	c0 30       	breq	800077d8 <dir_read+0x6c>
800077d4:	30 08       	mov	r8,0
800077d6:	8f 48       	st.w	r7[0x10],r8

	return res;
}
800077d8:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
#endif
		res = dir_next(dp, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dp->sect = 0;
800077dc:	30 4c       	mov	r12,4
800077de:	cf bb       	rjmp	800077d4 <dir_read+0x68>
800077e0:	80 00       	ld.sh	r0,r0[0x0]
800077e2:	6c 6c       	ld.w	r12,r6[0x18]
800077e4:	80 00       	ld.sh	r0,r0[0x0]
800077e6:	75 fc       	ld.w	r12,r10[0x7c]

800077e8 <f_getlabel>:
FRESULT f_getlabel (
	const TCHAR* path,	/* Path name of the logical drive number */
	TCHAR* label,		/* Pointer to a buffer to return the volume label */
	DWORD* vsn			/* Pointer to a variable to return the volume serial number */
)
{
800077e8:	d4 21       	pushm	r4-r7,lr
800077ea:	20 9d       	sub	sp,36
800077ec:	50 0c       	stdsp	sp[0x0],r12
800077ee:	16 96       	mov	r6,r11
800077f0:	14 95       	mov	r5,r10
	WCHAR w;
#endif


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
800077f2:	30 0a       	mov	r10,0
800077f4:	1a 9b       	mov	r11,sp
800077f6:	fa cc ff fc 	sub	r12,sp,-4
800077fa:	f0 1f 00 30 	mcall	800078b8 <f_getlabel+0xd0>
800077fe:	18 97       	mov	r7,r12

	/* Get volume label */
	if (res == FR_OK && label) {
80007800:	5f 09       	sreq	r9
80007802:	58 06       	cp.w	r6,0
80007804:	5f 18       	srne	r8
80007806:	f3 e8 00 08 	and	r8,r9,r8
8000780a:	c2 d0       	breq	80007864 <f_getlabel+0x7c>
		dj.sclust = 0;					/* Open root directory */
8000780c:	30 0b       	mov	r11,0
8000780e:	50 3b       	stdsp	sp[0xc],r11
		res = dir_sdi(&dj, 0);
80007810:	fa cc ff fc 	sub	r12,sp,-4
80007814:	f0 1f 00 2a 	mcall	800078bc <f_getlabel+0xd4>
80007818:	18 97       	mov	r7,r12
		if (res == FR_OK) {
8000781a:	c4 c1       	brne	800078b2 <f_getlabel+0xca>
			res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
8000781c:	30 1b       	mov	r11,1
8000781e:	fa cc ff fc 	sub	r12,sp,-4
80007822:	f0 1f 00 28 	mcall	800078c0 <f_getlabel+0xd8>
80007826:	18 94       	mov	r4,r12
			if (res == FR_OK) {			/* A volume label is exist */
80007828:	c1 81       	brne	80007858 <f_getlabel+0x70>
					if (IsDBCS1(w) && i < 11 && IsDBCS2(dj.dir[i]))
						w = w << 8 | dj.dir[i++];
					label[j++] = ff_convert(w, 1);	/* OEM -> Unicode */
				} while (j < 11);
#else
				mem_cpy(label, dj.dir, 11);
8000782a:	30 ba       	mov	r10,11
8000782c:	40 6b       	lddsp	r11,sp[0x18]
8000782e:	0c 9c       	mov	r12,r6
80007830:	f0 1f 00 25 	mcall	800078c4 <f_getlabel+0xdc>
#endif
				j = 11;
				do {
					label[j] = 0;
80007834:	30 08       	mov	r8,0
80007836:	ed 68 00 0b 	st.b	r6[11],r8
8000783a:	2f 66       	sub	r6,-10
8000783c:	30 b8       	mov	r8,11
					if (!j) break;
				} while (label[--j] == ' ');
8000783e:	32 0a       	mov	r10,32
#else
				mem_cpy(label, dj.dir, 11);
#endif
				j = 11;
				do {
					label[j] = 0;
80007840:	30 0b       	mov	r11,0
80007842:	c0 58       	rjmp	8000784c <f_getlabel+0x64>
80007844:	ac 8b       	st.b	r6[0x0],r11
80007846:	20 16       	sub	r6,1
					if (!j) break;
80007848:	58 08       	cp.w	r8,0
8000784a:	c0 c0       	breq	80007862 <f_getlabel+0x7a>
				} while (label[--j] == ' ');
8000784c:	20 18       	sub	r8,1
8000784e:	0d 89       	ld.ub	r9,r6[0x0]
80007850:	f4 09 18 00 	cp.b	r9,r10
80007854:	cf 80       	breq	80007844 <f_getlabel+0x5c>
80007856:	c0 68       	rjmp	80007862 <f_getlabel+0x7a>
			}
			if (res == FR_NO_FILE) {	/* No label, return nul string */
80007858:	58 4c       	cp.w	r12,4
8000785a:	c0 41       	brne	80007862 <f_getlabel+0x7a>
				label[0] = 0;
8000785c:	30 08       	mov	r8,0
8000785e:	ac 88       	st.b	r6[0x0],r8
80007860:	c0 28       	rjmp	80007864 <f_getlabel+0x7c>
80007862:	08 97       	mov	r7,r4
			}
		}
	}

	/* Get volume serial number */
	if (res == FR_OK && vsn) {
80007864:	58 07       	cp.w	r7,0
80007866:	5f 09       	sreq	r9
80007868:	58 05       	cp.w	r5,0
8000786a:	5f 18       	srne	r8
8000786c:	f3 e8 00 08 	and	r8,r9,r8
80007870:	c2 10       	breq	800078b2 <f_getlabel+0xca>
		res = move_window(dj.fs, dj.fs->volbase);
80007872:	40 1c       	lddsp	r12,sp[0x4]
80007874:	78 7b       	ld.w	r11,r12[0x1c]
80007876:	f0 1f 00 15 	mcall	800078c8 <f_getlabel+0xe0>
8000787a:	18 97       	mov	r7,r12
		if (res == FR_OK) {
8000787c:	c1 b1       	brne	800078b2 <f_getlabel+0xca>
			i = dj.fs->fs_type == FS_FAT32 ? BS_VolID32 : BS_VolID;
8000787e:	40 19       	lddsp	r9,sp[0x4]
80007880:	13 8a       	ld.ub	r10,r9[0x0]
80007882:	30 38       	mov	r8,3
80007884:	f0 0a 18 00 	cp.b	r10,r8
80007888:	f9 b8 00 43 	moveq	r8,67
8000788c:	f9 b8 01 27 	movne	r8,39
			*vsn = LD_DWORD(&dj.fs->win[i]);
80007890:	f2 08 00 08 	add	r8,r9,r8
80007894:	f1 3a 00 33 	ld.ub	r10,r8[51]
80007898:	f1 39 00 32 	ld.ub	r9,r8[50]
8000789c:	b1 69       	lsl	r9,0x10
8000789e:	f3 ea 11 89 	or	r9,r9,r10<<0x18
800078a2:	f1 3a 00 30 	ld.ub	r10,r8[48]
800078a6:	14 49       	or	r9,r10
800078a8:	f1 38 00 31 	ld.ub	r8,r8[49]
800078ac:	f3 e8 10 88 	or	r8,r9,r8<<0x8
800078b0:	8b 08       	st.w	r5[0x0],r8
		}
	}

	LEAVE_FF(dj.fs, res);
}
800078b2:	0e 9c       	mov	r12,r7
800078b4:	2f 7d       	sub	sp,-36
800078b6:	d8 22       	popm	r4-r7,pc
800078b8:	80 00       	ld.sh	r0,r0[0x0]
800078ba:	6d 48       	ld.w	r8,r6[0x50]
800078bc:	80 00       	ld.sh	r0,r0[0x0]
800078be:	74 78       	ld.w	r8,r10[0x1c]
800078c0:	80 00       	ld.sh	r0,r0[0x0]
800078c2:	77 6c       	ld.w	r12,r11[0x58]
800078c4:	80 00       	ld.sh	r0,r0[0x0]
800078c6:	62 e4       	ld.w	r4,r1[0x38]
800078c8:	80 00       	ld.sh	r0,r0[0x0]
800078ca:	6c 6c       	ld.w	r12,r6[0x18]

800078cc <dir_alloc>:
static
FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to the directory object */
	UINT nent		/* Number of contiguous entries to allocate (1-21) */
)
{
800078cc:	eb cd 40 fe 	pushm	r1-r7,lr
800078d0:	18 97       	mov	r7,r12
800078d2:	16 92       	mov	r2,r11
	FRESULT res;
	UINT n;


	res = dir_sdi(dp, 0);
800078d4:	30 0b       	mov	r11,0
800078d6:	f0 1f 00 15 	mcall	80007928 <dir_alloc+0x5c>
	if (res == FR_OK) {
800078da:	c2 21       	brne	8000791e <dir_alloc+0x52>
800078dc:	30 05       	mov	r5,0
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
			if (res != FR_OK) break;
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
800078de:	3e 54       	mov	r4,-27
800078e0:	30 06       	mov	r6,0
800078e2:	0a 91       	mov	r1,r5
				if (++n == nent) break;	/* A block of contiguous free entries is found */
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
800078e4:	30 13       	mov	r3,1

	res = dir_sdi(dp, 0);
	if (res == FR_OK) {
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
800078e6:	6e 4b       	ld.w	r11,r7[0x10]
800078e8:	6e 0c       	ld.w	r12,r7[0x0]
800078ea:	f0 1f 00 11 	mcall	8000792c <dir_alloc+0x60>
			if (res != FR_OK) break;
800078ee:	c1 81       	brne	8000791e <dir_alloc+0x52>
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
800078f0:	6e 58       	ld.w	r8,r7[0x14]
800078f2:	11 88       	ld.ub	r8,r8[0x0]
800078f4:	e8 08 18 00 	cp.b	r8,r4
800078f8:	5f 09       	sreq	r9
800078fa:	ec 08 18 00 	cp.b	r8,r6
800078fe:	5f 08       	sreq	r8
80007900:	f3 e8 10 08 	or	r8,r9,r8
80007904:	ec 08 18 00 	cp.b	r8,r6
80007908:	c0 31       	brne	8000790e <dir_alloc+0x42>
8000790a:	02 95       	mov	r5,r1
8000790c:	c0 48       	rjmp	80007914 <dir_alloc+0x48>
				if (++n == nent) break;	/* A block of contiguous free entries is found */
8000790e:	2f f5       	sub	r5,-1
80007910:	04 35       	cp.w	r5,r2
80007912:	c0 90       	breq	80007924 <dir_alloc+0x58>
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
80007914:	06 9b       	mov	r11,r3
80007916:	0e 9c       	mov	r12,r7
80007918:	f0 1f 00 06 	mcall	80007930 <dir_alloc+0x64>
		} while (res == FR_OK);
8000791c:	ce 50       	breq	800078e6 <dir_alloc+0x1a>
	}
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
8000791e:	58 4c       	cp.w	r12,4
80007920:	f9 bc 00 07 	moveq	r12,7
	return res;
}
80007924:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80007928:	80 00       	ld.sh	r0,r0[0x0]
8000792a:	74 78       	ld.w	r8,r10[0x1c]
8000792c:	80 00       	ld.sh	r0,r0[0x0]
8000792e:	6c 6c       	ld.w	r12,r6[0x18]
80007930:	80 00       	ld.sh	r0,r0[0x0]
80007932:	75 fc       	ld.w	r12,r10[0x7c]

80007934 <f_setlabel>:
/*-----------------------------------------------------------------------*/

FRESULT f_setlabel (
	const TCHAR* label	/* Pointer to the volume label to set */
)
{
80007934:	d4 31       	pushm	r0-r7,lr
80007936:	20 cd       	sub	sp,48
80007938:	50 0c       	stdsp	sp[0x0],r12
	WCHAR w;
	DWORD tm;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &label, 1);
8000793a:	30 1a       	mov	r10,1
8000793c:	1a 9b       	mov	r11,sp
8000793e:	fa cc ff f0 	sub	r12,sp,-16
80007942:	f0 1f 00 8b 	mcall	80007b6c <f_setlabel+0x238>
	if (res) LEAVE_FF(dj.fs, res);
80007946:	e0 81 01 08 	brne	80007b56 <f_setlabel+0x222>

	/* Create a volume label in directory form */
	vn[0] = 0;
8000794a:	30 08       	mov	r8,0
8000794c:	ba c8       	st.b	sp[0x4],r8
	for (sl = 0; label[sl]; sl++) ;				/* Get name length */
8000794e:	40 0a       	lddsp	r10,sp[0x0]
80007950:	15 89       	ld.ub	r9,r10[0x0]
80007952:	f0 09 18 00 	cp.b	r9,r8
80007956:	e0 80 00 90 	breq	80007a76 <f_setlabel+0x142>
8000795a:	30 07       	mov	r7,0
8000795c:	2f f7       	sub	r7,-1
8000795e:	f4 07 07 09 	ld.ub	r9,r10[r7]
80007962:	f0 09 18 00 	cp.b	r9,r8
80007966:	cf b1       	brne	8000795c <f_setlabel+0x28>
80007968:	0e 98       	mov	r8,r7
	for ( ; sl && label[sl - 1] == ' '; sl--) ;	/* Remove trailing spaces */
8000796a:	58 07       	cp.w	r7,0
8000796c:	e0 80 00 85 	breq	80007a76 <f_setlabel+0x142>
80007970:	f4 07 00 09 	add	r9,r10,r7
80007974:	f3 3b ff ff 	ld.ub	r11,r9[-1]
80007978:	32 09       	mov	r9,32
8000797a:	f2 0b 18 00 	cp.b	r11,r9
8000797e:	e0 81 00 ee 	brne	80007b5a <f_setlabel+0x226>
80007982:	20 28       	sub	r8,2
80007984:	f4 08 00 08 	add	r8,r10,r8
80007988:	12 9a       	mov	r10,r9
8000798a:	20 17       	sub	r7,1
8000798c:	c7 50       	breq	80007a76 <f_setlabel+0x142>
8000798e:	11 89       	ld.ub	r9,r8[0x0]
80007990:	20 18       	sub	r8,1
80007992:	f4 09 18 00 	cp.b	r9,r10
80007996:	cf a0       	breq	8000798a <f_setlabel+0x56>
80007998:	ce 18       	rjmp	80007b5a <f_setlabel+0x226>
		i = j = 0;
		do {
#if _USE_LFN && _LFN_UNICODE
			w = ff_convert(ff_wtoupper(label[i++]), 0);
#else
			w = (BYTE)label[i++];
8000799a:	40 08       	lddsp	r8,sp[0x0]
8000799c:	f0 04 07 06 	ld.ub	r6,r8[r4]
800079a0:	2f f4       	sub	r4,-1
			if (IsDBCS1(w))
800079a2:	ec c9 ff 81 	sub	r9,r6,-127
800079a6:	e4 09 18 00 	cp.b	r9,r2
800079aa:	e0 8b 00 24 	brhi	800079f2 <f_setlabel+0xbe>
				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
800079ae:	58 95       	cp.w	r5,9
800079b0:	5f 8a       	srls	r10
800079b2:	0e 34       	cp.w	r4,r7
800079b4:	5f 39       	srlo	r9
800079b6:	f5 e9 00 09 	and	r9,r10,r9
800079ba:	e2 09 18 00 	cp.b	r9,r1
800079be:	e0 80 00 c9 	breq	80007b50 <f_setlabel+0x21c>
800079c2:	f0 04 07 08 	ld.ub	r8,r8[r4]
800079c6:	f0 c9 00 40 	sub	r9,r8,64
800079ca:	33 eb       	mov	r11,62
800079cc:	f6 09 18 00 	cp.b	r9,r11
800079d0:	5f 8a       	srls	r10
800079d2:	f0 c9 00 80 	sub	r9,r8,128
800079d6:	37 eb       	mov	r11,126
800079d8:	f6 09 18 00 	cp.b	r9,r11
800079dc:	5f 89       	srls	r9
800079de:	f5 e9 10 09 	or	r9,r10,r9
800079e2:	e2 09 18 00 	cp.b	r9,r1
800079e6:	e0 80 00 b5 	breq	80007b50 <f_setlabel+0x21c>
800079ea:	f1 e6 10 86 	or	r6,r8,r6<<0x8
800079ee:	5c 86       	casts.h	r6
800079f0:	2f f4       	sub	r4,-1
#if _USE_LFN
			w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
#else
			if (IsLower(w)) w -= 0x20;			/* To upper ASCII characters */
800079f2:	ec c8 00 61 	sub	r8,r6,97
800079f6:	31 9a       	mov	r10,25
800079f8:	f4 08 19 00 	cp.h	r8,r10
800079fc:	e0 8b 00 04 	brhi	80007a04 <f_setlabel+0xd0>
80007a00:	22 06       	sub	r6,32
80007a02:	5c 86       	casts.h	r6
#else
			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
#endif
			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for volume label */
80007a04:	58 06       	cp.w	r6,0
80007a06:	e0 80 00 a5 	breq	80007b50 <f_setlabel+0x21c>
80007a0a:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80007a0e:	00 9c       	mov	r12,r0
80007a10:	f0 1f 00 58 	mcall	80007b70 <f_setlabel+0x23c>
80007a14:	e0 81 00 9e 	brne	80007b50 <f_setlabel+0x21c>
80007a18:	ec 03 19 00 	cp.h	r3,r6
80007a1c:	f9 b8 03 0a 	movlo	r8,10
80007a20:	f9 b8 02 0b 	movhs	r8,11
80007a24:	10 35       	cp.w	r5,r8
80007a26:	e0 82 00 95 	brhs	80007b50 <f_setlabel+0x21c>
				LEAVE_FF(dj.fs, FR_INVALID_NAME);
			if (w >= 0x100) vn[j++] = (BYTE)(w >> 8);
80007a2a:	e6 06 19 00 	cp.h	r6,r3
80007a2e:	e0 88 00 0a 	brls	80007a42 <f_setlabel+0x10e>
80007a32:	fa c8 ff d0 	sub	r8,sp,-48
80007a36:	0a 08       	add	r8,r5
80007a38:	f3 d6 c1 08 	bfextu	r9,r6,0x8,0x8
80007a3c:	f1 69 ff d4 	st.b	r8[-44],r9
80007a40:	2f f5       	sub	r5,-1
			vn[j++] = (BYTE)w;
80007a42:	fa c8 ff d0 	sub	r8,sp,-48
80007a46:	0a 08       	add	r8,r5
80007a48:	f1 66 ff d4 	st.b	r8[-44],r6
80007a4c:	2f f5       	sub	r5,-1
		} while (i < sl);
80007a4e:	0e 34       	cp.w	r4,r7
80007a50:	ca 53       	brcs	8000799a <f_setlabel+0x66>
		while (j < 11) vn[j++] = ' ';	/* Fill remaining name field */
80007a52:	58 a5       	cp.w	r5,10
80007a54:	e0 8b 00 0c 	brhi	80007a6c <f_setlabel+0x138>
80007a58:	fa c9 ff fc 	sub	r9,sp,-4
80007a5c:	f2 05 00 08 	add	r8,r9,r5
80007a60:	32 09       	mov	r9,32
80007a62:	10 c9       	st.b	r8++,r9
80007a64:	2f f5       	sub	r5,-1
80007a66:	58 a5       	cp.w	r5,10
80007a68:	fe 98 ff fd 	brls	80007a62 <f_setlabel+0x12e>
		if (vn[0] == DDEM) LEAVE_FF(dj.fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
80007a6c:	3e 58       	mov	r8,-27
80007a6e:	1b c9       	ld.ub	r9,sp[0x4]
80007a70:	f0 09 18 00 	cp.b	r9,r8
80007a74:	c6 e0       	breq	80007b50 <f_setlabel+0x21c>
	}

	/* Set volume label */
	dj.sclust = 0;					/* Open root directory */
80007a76:	30 0b       	mov	r11,0
80007a78:	50 6b       	stdsp	sp[0x18],r11
	res = dir_sdi(&dj, 0);
80007a7a:	fa cc ff f0 	sub	r12,sp,-16
80007a7e:	f0 1f 00 3e 	mcall	80007b74 <f_setlabel+0x240>
80007a82:	18 97       	mov	r7,r12
	if (res == FR_OK) {
80007a84:	c6 81       	brne	80007b54 <f_setlabel+0x220>
		res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
80007a86:	30 1b       	mov	r11,1
80007a88:	fa cc ff f0 	sub	r12,sp,-16
80007a8c:	f0 1f 00 3b 	mcall	80007b78 <f_setlabel+0x244>
		if (res == FR_OK) {			/* A volume label is found */
80007a90:	c2 a1       	brne	80007ae4 <f_setlabel+0x1b0>
			if (vn[0]) {
80007a92:	30 08       	mov	r8,0
80007a94:	1b c9       	ld.ub	r9,sp[0x4]
80007a96:	f0 09 18 00 	cp.b	r9,r8
80007a9a:	c1 b0       	breq	80007ad0 <f_setlabel+0x19c>
				mem_cpy(dj.dir, vn, 11);	/* Change the volume label name */
80007a9c:	30 ba       	mov	r10,11
80007a9e:	fa cb ff fc 	sub	r11,sp,-4
80007aa2:	40 9c       	lddsp	r12,sp[0x24]
80007aa4:	f0 1f 00 36 	mcall	80007b7c <f_setlabel+0x248>
				tm = GET_FATTIME();
80007aa8:	f0 1f 00 36 	mcall	80007b80 <f_setlabel+0x24c>
				ST_DWORD(dj.dir + DIR_WrtTime, tm);
80007aac:	40 98       	lddsp	r8,sp[0x24]
80007aae:	f1 6c 00 16 	st.b	r8[22],r12
80007ab2:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80007ab6:	40 98       	lddsp	r8,sp[0x24]
80007ab8:	f1 69 00 17 	st.b	r8[23],r9
80007abc:	f8 09 16 10 	lsr	r9,r12,0x10
80007ac0:	40 98       	lddsp	r8,sp[0x24]
80007ac2:	f1 69 00 18 	st.b	r8[24],r9
80007ac6:	b9 8c       	lsr	r12,0x18
80007ac8:	40 98       	lddsp	r8,sp[0x24]
80007aca:	f1 6c 00 19 	st.b	r8[25],r12
80007ace:	c0 48       	rjmp	80007ad6 <f_setlabel+0x1a2>
			} else {
				dj.dir[0] = DDEM;			/* Remove the volume label */
80007ad0:	3e 59       	mov	r9,-27
80007ad2:	40 98       	lddsp	r8,sp[0x24]
80007ad4:	b0 89       	st.b	r8[0x0],r9
			}
			dj.fs->wflag = 1;
80007ad6:	30 19       	mov	r9,1
80007ad8:	40 48       	lddsp	r8,sp[0x10]
80007ada:	b0 c9       	st.b	r8[0x4],r9
			res = sync_fs(dj.fs);
80007adc:	40 4c       	lddsp	r12,sp[0x10]
80007ade:	f0 1f 00 2a 	mcall	80007b84 <f_setlabel+0x250>
80007ae2:	c3 a8       	rjmp	80007b56 <f_setlabel+0x222>
		} else {					/* No volume label is found or error */
			if (res == FR_NO_FILE) {
80007ae4:	58 4c       	cp.w	r12,4
80007ae6:	c3 81       	brne	80007b56 <f_setlabel+0x222>
				res = FR_OK;
				if (vn[0]) {				/* Create volume label as new */
80007ae8:	30 08       	mov	r8,0
80007aea:	1b c9       	ld.ub	r9,sp[0x4]
80007aec:	f0 09 18 00 	cp.b	r9,r8
80007af0:	c3 20       	breq	80007b54 <f_setlabel+0x220>
					res = dir_alloc(&dj, 1);	/* Allocate an entry for volume label */
80007af2:	30 1b       	mov	r11,1
80007af4:	fa cc ff f0 	sub	r12,sp,-16
80007af8:	f0 1f 00 24 	mcall	80007b88 <f_setlabel+0x254>
					if (res == FR_OK) {
80007afc:	c2 d1       	brne	80007b56 <f_setlabel+0x222>
						mem_set(dj.dir, 0, SZ_DIRE);	/* Set volume label */
80007afe:	32 0a       	mov	r10,32
80007b00:	30 0b       	mov	r11,0
80007b02:	40 9c       	lddsp	r12,sp[0x24]
80007b04:	f0 1f 00 22 	mcall	80007b8c <f_setlabel+0x258>
						mem_cpy(dj.dir, vn, 11);
80007b08:	30 ba       	mov	r10,11
80007b0a:	fa cb ff fc 	sub	r11,sp,-4
80007b0e:	40 9c       	lddsp	r12,sp[0x24]
80007b10:	f0 1f 00 1b 	mcall	80007b7c <f_setlabel+0x248>
						dj.dir[DIR_Attr] = AM_VOL;
80007b14:	30 89       	mov	r9,8
80007b16:	40 98       	lddsp	r8,sp[0x24]
80007b18:	f1 69 00 0b 	st.b	r8[11],r9
						tm = GET_FATTIME();
80007b1c:	f0 1f 00 19 	mcall	80007b80 <f_setlabel+0x24c>
						ST_DWORD(dj.dir + DIR_WrtTime, tm);
80007b20:	40 98       	lddsp	r8,sp[0x24]
80007b22:	f1 6c 00 16 	st.b	r8[22],r12
80007b26:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80007b2a:	40 98       	lddsp	r8,sp[0x24]
80007b2c:	f1 69 00 17 	st.b	r8[23],r9
80007b30:	f8 09 16 10 	lsr	r9,r12,0x10
80007b34:	40 98       	lddsp	r8,sp[0x24]
80007b36:	f1 69 00 18 	st.b	r8[24],r9
80007b3a:	b9 8c       	lsr	r12,0x18
80007b3c:	40 98       	lddsp	r8,sp[0x24]
80007b3e:	f1 6c 00 19 	st.b	r8[25],r12
						dj.fs->wflag = 1;
80007b42:	30 19       	mov	r9,1
80007b44:	40 48       	lddsp	r8,sp[0x10]
80007b46:	b0 c9       	st.b	r8[0x4],r9
						res = sync_fs(dj.fs);
80007b48:	40 4c       	lddsp	r12,sp[0x10]
80007b4a:	f0 1f 00 0f 	mcall	80007b84 <f_setlabel+0x250>
80007b4e:	c0 48       	rjmp	80007b56 <f_setlabel+0x222>
80007b50:	30 6c       	mov	r12,6
80007b52:	c0 28       	rjmp	80007b56 <f_setlabel+0x222>
80007b54:	0e 9c       	mov	r12,r7
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
80007b56:	2f 4d       	sub	sp,-48
80007b58:	d8 32       	popm	r0-r7,pc
						mem_cpy(dj.dir, vn, 11);
						dj.dir[DIR_Attr] = AM_VOL;
						tm = GET_FATTIME();
						ST_DWORD(dj.dir + DIR_WrtTime, tm);
						dj.fs->wflag = 1;
						res = sync_fs(dj.fs);
80007b5a:	30 05       	mov	r5,0
80007b5c:	0a 94       	mov	r4,r5
		do {
#if _USE_LFN && _LFN_UNICODE
			w = ff_convert(ff_wtoupper(label[i++]), 0);
#else
			w = (BYTE)label[i++];
			if (IsDBCS1(w))
80007b5e:	37 d2       	mov	r2,125
				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
80007b60:	30 01       	mov	r1,0
#else
			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
#endif
			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for volume label */
80007b62:	48 c0       	lddpc	r0,80007b90 <f_setlabel+0x25c>
80007b64:	e0 63 00 ff 	mov	r3,255
80007b68:	c1 9b       	rjmp	8000799a <f_setlabel+0x66>
80007b6a:	00 00       	add	r0,r0
80007b6c:	80 00       	ld.sh	r0,r0[0x0]
80007b6e:	6d 48       	ld.w	r8,r6[0x50]
80007b70:	80 00       	ld.sh	r0,r0[0x0]
80007b72:	63 06       	ld.w	r6,r1[0x40]
80007b74:	80 00       	ld.sh	r0,r0[0x0]
80007b76:	74 78       	ld.w	r8,r10[0x1c]
80007b78:	80 00       	ld.sh	r0,r0[0x0]
80007b7a:	77 6c       	ld.w	r12,r11[0x58]
80007b7c:	80 00       	ld.sh	r0,r0[0x0]
80007b7e:	62 e4       	ld.w	r4,r1[0x38]
80007b80:	80 00       	ld.sh	r0,r0[0x0]
80007b82:	62 20       	ld.w	r0,r1[0x8]
80007b84:	80 00       	ld.sh	r0,r0[0x0]
80007b86:	64 d8       	ld.w	r8,r2[0x34]
80007b88:	80 00       	ld.sh	r0,r0[0x0]
80007b8a:	78 cc       	ld.w	r12,r12[0x30]
80007b8c:	80 00       	ld.sh	r0,r0[0x0]
80007b8e:	62 fa       	ld.w	r10,r1[0x3c]
80007b90:	80 01       	ld.sh	r1,r0[0x0]
80007b92:	8b b8       	st.w	r5[0x2c],r8

80007b94 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
80007b94:	eb cd 40 c0 	pushm	r6-r7,lr
80007b98:	18 96       	mov	r6,r12
				res = dir_next(dp, 0);	/* Next entry */
			} while (res == FR_OK && --nent);
		}
	}
#else	/* Non LFN configuration */
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
80007b9a:	30 1b       	mov	r11,1
80007b9c:	f0 1f 00 0d 	mcall	80007bd0 <dir_register+0x3c>
80007ba0:	18 97       	mov	r7,r12
#endif

	if (res == FR_OK) {				/* Set SFN entry */
80007ba2:	c1 41       	brne	80007bca <dir_register+0x36>
		res = move_window(dp->fs, dp->sect);
80007ba4:	6c 4b       	ld.w	r11,r6[0x10]
80007ba6:	6c 0c       	ld.w	r12,r6[0x0]
80007ba8:	f0 1f 00 0b 	mcall	80007bd4 <dir_register+0x40>
80007bac:	18 97       	mov	r7,r12
		if (res == FR_OK) {
80007bae:	c0 e1       	brne	80007bca <dir_register+0x36>
			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
80007bb0:	32 0a       	mov	r10,32
80007bb2:	30 0b       	mov	r11,0
80007bb4:	6c 5c       	ld.w	r12,r6[0x14]
80007bb6:	f0 1f 00 09 	mcall	80007bd8 <dir_register+0x44>
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
80007bba:	30 ba       	mov	r10,11
80007bbc:	6c 6b       	ld.w	r11,r6[0x18]
80007bbe:	6c 5c       	ld.w	r12,r6[0x14]
80007bc0:	f0 1f 00 07 	mcall	80007bdc <dir_register+0x48>
#if _USE_LFN
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			dp->fs->wflag = 1;
80007bc4:	6c 08       	ld.w	r8,r6[0x0]
80007bc6:	30 19       	mov	r9,1
80007bc8:	b0 c9       	st.b	r8[0x4],r9
		}
	}

	return res;
}
80007bca:	0e 9c       	mov	r12,r7
80007bcc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007bd0:	80 00       	ld.sh	r0,r0[0x0]
80007bd2:	78 cc       	ld.w	r12,r12[0x30]
80007bd4:	80 00       	ld.sh	r0,r0[0x0]
80007bd6:	6c 6c       	ld.w	r12,r6[0x18]
80007bd8:	80 00       	ld.sh	r0,r0[0x0]
80007bda:	62 fa       	ld.w	r10,r1[0x3c]
80007bdc:	80 00       	ld.sh	r0,r0[0x0]
80007bde:	62 e4       	ld.w	r4,r1[0x38]

80007be0 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
80007be0:	d4 31       	pushm	r0-r7,lr
80007be2:	20 3d       	sub	sp,12
80007be4:	18 92       	mov	r2,r12
80007be6:	16 97       	mov	r7,r11
		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
	} else {								/* No heading separator */
		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
	}
#else
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
80007be8:	17 88       	ld.ub	r8,r11[0x0]
80007bea:	32 f9       	mov	r9,47
80007bec:	f2 08 18 00 	cp.b	r8,r9
80007bf0:	5f 09       	sreq	r9
80007bf2:	35 ca       	mov	r10,92
80007bf4:	f4 08 18 00 	cp.b	r8,r10
80007bf8:	5f 08       	sreq	r8
80007bfa:	f3 e8 10 08 	or	r8,r9,r8
		path++;
80007bfe:	f7 b7 01 ff 	subne	r7,-1
	dp->sclust = 0;							/* Always start from the root directory */
80007c02:	30 08       	mov	r8,0
80007c04:	99 28       	st.w	r12[0x8],r8
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
80007c06:	0f 89       	ld.ub	r9,r7[0x0]
80007c08:	31 f8       	mov	r8,31
80007c0a:	f0 09 18 00 	cp.b	r9,r8
80007c0e:	e0 8b 00 08 	brhi	80007c1e <follow_path+0x3e>
		res = dir_sdi(dp, 0);
80007c12:	30 0b       	mov	r11,0
80007c14:	f0 1f 00 93 	mcall	80007e60 <follow_path+0x280>
		dp->dir = 0;
80007c18:	30 08       	mov	r8,0
80007c1a:	85 58       	st.w	r2[0x14],r8
80007c1c:	c1 49       	rjmp	80007e44 <follow_path+0x264>
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Skip duplicated separator */
80007c1e:	32 f4       	mov	r4,47
80007c20:	35 c3       	mov	r3,92
80007c22:	30 06       	mov	r6,0
80007c24:	0f 88       	ld.ub	r8,r7[0x0]
80007c26:	e8 08 18 00 	cp.b	r8,r4
80007c2a:	5f 09       	sreq	r9
80007c2c:	e6 08 18 00 	cp.b	r8,r3
80007c30:	5f 08       	sreq	r8
80007c32:	f3 e8 10 08 	or	r8,r9,r8
80007c36:	ec 08 18 00 	cp.b	r8,r6
80007c3a:	c0 e0       	breq	80007c56 <follow_path+0x76>
80007c3c:	2f f7       	sub	r7,-1
80007c3e:	0f 88       	ld.ub	r8,r7[0x0]
80007c40:	e8 08 18 00 	cp.b	r8,r4
80007c44:	5f 09       	sreq	r9
80007c46:	e6 08 18 00 	cp.b	r8,r3
80007c4a:	5f 08       	sreq	r8
80007c4c:	f3 e8 10 08 	or	r8,r9,r8
80007c50:	ec 08 18 00 	cp.b	r8,r6
80007c54:	cf 41       	brne	80007c3c <follow_path+0x5c>
	sfn = dp->fn;
80007c56:	64 6a       	ld.w	r10,r2[0x18]
80007c58:	50 2a       	stdsp	sp[0x8],r10
	mem_set(sfn, ' ', 11);
80007c5a:	30 ba       	mov	r10,11
80007c5c:	32 0b       	mov	r11,32
80007c5e:	40 2c       	lddsp	r12,sp[0x8]
80007c60:	f0 1f 00 81 	mcall	80007e64 <follow_path+0x284>
80007c64:	30 89       	mov	r9,8
80007c66:	50 09       	stdsp	sp[0x0],r9
80007c68:	30 08       	mov	r8,0
80007c6a:	50 18       	stdsp	sp[0x4],r8
80007c6c:	10 90       	mov	r0,r8
80007c6e:	10 91       	mov	r1,r8
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
80007c70:	0e 95       	mov	r5,r7
		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
80007c72:	ea 01 07 07 	ld.ub	r7,r5[r1]
80007c76:	2f f1       	sub	r1,-1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
80007c78:	32 09       	mov	r9,32
80007c7a:	f2 07 18 00 	cp.b	r7,r9
80007c7e:	5f 88       	srls	r8
80007c80:	e8 07 18 00 	cp.b	r7,r4
80007c84:	5f 09       	sreq	r9
80007c86:	f1 e9 10 09 	or	r9,r8,r9
80007c8a:	ec 09 18 00 	cp.b	r9,r6
80007c8e:	c7 51       	brne	80007d78 <follow_path+0x198>
80007c90:	e6 07 18 00 	cp.b	r7,r3
80007c94:	c7 20       	breq	80007d78 <follow_path+0x198>
		if (c == '.' || i >= ni) {
80007c96:	32 e8       	mov	r8,46
80007c98:	f0 07 18 00 	cp.b	r7,r8
80007c9c:	5f 09       	sreq	r9
80007c9e:	40 0a       	lddsp	r10,sp[0x0]
80007ca0:	14 30       	cp.w	r0,r10
80007ca2:	5f 28       	srhs	r8
80007ca4:	f3 e8 10 08 	or	r8,r9,r8
80007ca8:	ec 08 18 00 	cp.b	r8,r6
80007cac:	c1 50       	breq	80007cd6 <follow_path+0xf6>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
80007cae:	58 8a       	cp.w	r10,8
80007cb0:	5f 19       	srne	r9
80007cb2:	32 e8       	mov	r8,46
80007cb4:	f0 07 18 00 	cp.b	r7,r8
80007cb8:	5f 18       	srne	r8
80007cba:	f3 e8 10 08 	or	r8,r9,r8
80007cbe:	ec 08 18 00 	cp.b	r8,r6
80007cc2:	e0 81 00 be 	brne	80007e3e <follow_path+0x25e>
			i = 8; ni = 11;
			b <<= 2; continue;
80007cc6:	40 18       	lddsp	r8,sp[0x4]
80007cc8:	a3 68       	lsl	r8,0x2
80007cca:	5c 58       	castu.b	r8
80007ccc:	50 18       	stdsp	sp[0x4],r8
80007cce:	30 ba       	mov	r10,11
80007cd0:	50 0a       	stdsp	sp[0x0],r10
80007cd2:	30 80       	mov	r0,8
80007cd4:	cc fb       	rjmp	80007c72 <follow_path+0x92>
		}
		if (c >= 0x80) {				/* Extended character? */
80007cd6:	ec 07 18 00 	cp.b	r7,r6
80007cda:	c0 54       	brge	80007ce4 <follow_path+0x104>
			b |= 3;						/* Eliminate NT flag */
80007cdc:	40 18       	lddsp	r8,sp[0x4]
80007cde:	e8 18 00 03 	orl	r8,0x3
80007ce2:	50 18       	stdsp	sp[0x4],r8
#if !_DF1S
			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
80007ce4:	0e 98       	mov	r8,r7
80007ce6:	28 18       	sub	r8,-127
80007ce8:	37 da       	mov	r10,125
80007cea:	f4 08 18 00 	cp.b	r8,r10
80007cee:	e0 8b 00 23 	brhi	80007d34 <follow_path+0x154>
			d = (BYTE)p[si++];			/* Get 2nd byte */
80007cf2:	ea 01 07 08 	ld.ub	r8,r5[r1]
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
80007cf6:	f0 c9 00 40 	sub	r9,r8,64
80007cfa:	33 ea       	mov	r10,62
80007cfc:	f4 09 18 00 	cp.b	r9,r10
80007d00:	5f b9       	srhi	r9
80007d02:	f0 cb 00 80 	sub	r11,r8,128
80007d06:	37 ea       	mov	r10,126
80007d08:	f4 0b 18 00 	cp.b	r11,r10
80007d0c:	5f ba       	srhi	r10
80007d0e:	14 69       	and	r9,r10
80007d10:	ec 09 18 00 	cp.b	r9,r6
80007d14:	e0 81 00 95 	brne	80007e3e <follow_path+0x25e>
80007d18:	40 09       	lddsp	r9,sp[0x0]
80007d1a:	20 19       	sub	r9,1
80007d1c:	12 30       	cp.w	r0,r9
80007d1e:	e0 82 00 90 	brhs	80007e3e <follow_path+0x25e>
			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
80007d22:	2f f1       	sub	r1,-1
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
80007d24:	40 29       	lddsp	r9,sp[0x8]
80007d26:	f2 00 0b 07 	st.b	r9[r0],r7
80007d2a:	2f f0       	sub	r0,-1
			sfn[i++] = d;
80007d2c:	f2 00 0b 08 	st.b	r9[r0],r8
80007d30:	2f f0       	sub	r0,-1
80007d32:	ca 0b       	rjmp	80007c72 <follow_path+0x92>
		} else {						/* SBC */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
80007d34:	0e 9b       	mov	r11,r7
80007d36:	4c dc       	lddpc	r12,80007e68 <follow_path+0x288>
80007d38:	f0 1f 00 4d 	mcall	80007e6c <follow_path+0x28c>
80007d3c:	e0 81 00 81 	brne	80007e3e <follow_path+0x25e>
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
80007d40:	0e 98       	mov	r8,r7
80007d42:	24 18       	sub	r8,65
80007d44:	31 99       	mov	r9,25
80007d46:	f2 08 18 00 	cp.b	r8,r9
80007d4a:	e0 8b 00 06 	brhi	80007d56 <follow_path+0x176>
				b |= 2;
80007d4e:	40 18       	lddsp	r8,sp[0x4]
80007d50:	a1 b8       	sbr	r8,0x1
80007d52:	50 18       	stdsp	sp[0x4],r8
80007d54:	c0 d8       	rjmp	80007d6e <follow_path+0x18e>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
80007d56:	0e 98       	mov	r8,r7
80007d58:	26 18       	sub	r8,97
80007d5a:	31 9a       	mov	r10,25
80007d5c:	f4 08 18 00 	cp.b	r8,r10
80007d60:	e0 8b 00 07 	brhi	80007d6e <follow_path+0x18e>
					b |= 1; c -= 0x20;
80007d64:	40 19       	lddsp	r9,sp[0x4]
80007d66:	a1 a9       	sbr	r9,0x0
80007d68:	50 19       	stdsp	sp[0x4],r9
80007d6a:	22 07       	sub	r7,32
80007d6c:	5c 57       	castu.b	r7
				}
			}
			sfn[i++] = c;
80007d6e:	40 28       	lddsp	r8,sp[0x8]
80007d70:	f0 00 0b 07 	st.b	r8[r0],r7
80007d74:	2f f0       	sub	r0,-1
80007d76:	c7 eb       	rjmp	80007c72 <follow_path+0x92>
80007d78:	0a 97       	mov	r7,r5
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
80007d7a:	58 08       	cp.w	r8,0
80007d7c:	f9 b8 01 04 	movne	r8,4
80007d80:	f9 b8 00 00 	moveq	r8,0

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
80007d84:	58 00       	cp.w	r0,0
80007d86:	c5 c0       	breq	80007e3e <follow_path+0x25e>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
80007d88:	40 29       	lddsp	r9,sp[0x8]
80007d8a:	13 8a       	ld.ub	r10,r9[0x0]
80007d8c:	3e 59       	mov	r9,-27
80007d8e:	f2 0a 18 00 	cp.b	r10,r9
80007d92:	f9 b9 00 05 	moveq	r9,5
80007d96:	fb fa 00 02 	ld.weq	r10,sp[0x8]
80007d9a:	f5 f9 0e 00 	st.beq	r10[0x0],r9

	if (ni == 8) b <<= 2;
80007d9e:	40 09       	lddsp	r9,sp[0x0]
80007da0:	58 89       	cp.w	r9,8
80007da2:	c0 51       	brne	80007dac <follow_path+0x1cc>
80007da4:	40 19       	lddsp	r9,sp[0x4]
80007da6:	a3 69       	lsl	r9,0x2
80007da8:	5c 59       	castu.b	r9
80007daa:	50 19       	stdsp	sp[0x4],r9
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
80007dac:	40 19       	lddsp	r9,sp[0x4]
80007dae:	f5 d9 c0 02 	bfextu	r10,r9,0x0,0x2
80007db2:	58 1a       	cp.w	r10,1
80007db4:	c0 21       	brne	80007db8 <follow_path+0x1d8>
80007db6:	a5 a8       	sbr	r8,0x4
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
80007db8:	e2 19 00 0c 	andl	r9,0xc,COH
80007dbc:	58 49       	cp.w	r9,4
80007dbe:	c0 21       	brne	80007dc2 <follow_path+0x1e2>
80007dc0:	a3 b8       	sbr	r8,0x3

	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */
80007dc2:	40 2a       	lddsp	r10,sp[0x8]
80007dc4:	f5 68 00 0b 	st.b	r10[11],r8
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
80007dc8:	30 0b       	mov	r11,0
80007dca:	04 9c       	mov	r12,r2
80007dcc:	f0 1f 00 25 	mcall	80007e60 <follow_path+0x280>
	if (res != FR_OK) return res;
80007dd0:	c2 11       	brne	80007e12 <follow_path+0x232>

#if _USE_LFN
	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
#endif
	do {
		res = move_window(dp->fs, dp->sect);
80007dd2:	64 4b       	ld.w	r11,r2[0x10]
80007dd4:	64 0c       	ld.w	r12,r2[0x0]
80007dd6:	f0 1f 00 27 	mcall	80007e70 <follow_path+0x290>
		if (res != FR_OK) break;
80007dda:	c1 c1       	brne	80007e12 <follow_path+0x232>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
80007ddc:	64 59       	ld.w	r9,r2[0x14]
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
80007dde:	13 88       	ld.ub	r8,r9[0x0]
80007de0:	ec 08 18 00 	cp.b	r8,r6
80007de4:	c3 90       	breq	80007e56 <follow_path+0x276>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
80007de6:	f3 38 00 0b 	ld.ub	r8,r9[11]
80007dea:	e2 18 00 08 	andl	r8,0x8,COH
80007dee:	c0 d1       	brne	80007e08 <follow_path+0x228>
80007df0:	64 65       	ld.w	r5,r2[0x18]
80007df2:	c0 48       	rjmp	80007dfa <follow_path+0x21a>
80007df4:	2f f8       	sub	r8,-1
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
80007df6:	58 b8       	cp.w	r8,11
80007df8:	c2 80       	breq	80007e48 <follow_path+0x268>
80007dfa:	f2 08 07 0b 	ld.ub	r11,r9[r8]
80007dfe:	ea 08 07 0a 	ld.ub	r10,r5[r8]
80007e02:	f4 0b 18 00 	cp.b	r11,r10
80007e06:	cf 70       	breq	80007df4 <follow_path+0x214>
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dp, 0);		/* Next entry */
80007e08:	30 0b       	mov	r11,0
80007e0a:	04 9c       	mov	r12,r2
80007e0c:	f0 1f 00 1a 	mcall	80007e74 <follow_path+0x294>
	} while (res == FR_OK);
80007e10:	ce 10       	breq	80007dd2 <follow_path+0x1f2>
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NSFLAG];
80007e12:	64 68       	ld.w	r8,r2[0x18]
80007e14:	f1 38 00 0b 	ld.ub	r8,r8[11]
			if (res != FR_OK) {				/* Failed to find the object */
				if (res == FR_NO_FILE) {	/* Object is not found */
80007e18:	58 4c       	cp.w	r12,4
80007e1a:	c1 51       	brne	80007e44 <follow_path+0x264>
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						res = FR_OK;					/* Ended at the root directroy. Function completed. */
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
80007e1c:	e2 18 00 04 	andl	r8,0x4,COH
80007e20:	c1 10       	breq	80007e42 <follow_path+0x262>
80007e22:	30 4c       	mov	r12,4
80007e24:	c1 08       	rjmp	80007e44 <follow_path+0x264>
					}
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
80007e26:	64 5b       	ld.w	r11,r2[0x14]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
80007e28:	f7 38 00 0b 	ld.ub	r8,r11[11]
80007e2c:	e2 18 00 10 	andl	r8,0x10,COH
80007e30:	c0 90       	breq	80007e42 <follow_path+0x262>
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
80007e32:	02 07       	add	r7,r1
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
				res = FR_NO_PATH; break;
			}
			dp->sclust = ld_clust(dp->fs, dir);
80007e34:	64 0c       	ld.w	r12,r2[0x0]
80007e36:	f0 1f 00 11 	mcall	80007e78 <follow_path+0x298>
80007e3a:	85 2c       	st.w	r2[0x8],r12
		}
80007e3c:	cf 4a       	rjmp	80007c24 <follow_path+0x44>
80007e3e:	30 6c       	mov	r12,6
80007e40:	c0 28       	rjmp	80007e44 <follow_path+0x264>
80007e42:	30 5c       	mov	r12,5
	}

	return res;
}
80007e44:	2f dd       	sub	sp,-12
80007e46:	d8 32       	popm	r0-r7,pc
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NSFLAG];
80007e48:	64 68       	ld.w	r8,r2[0x18]
80007e4a:	f1 38 00 0b 	ld.ub	r8,r8[11]
80007e4e:	e2 18 00 04 	andl	r8,0x4,COH
80007e52:	ce a0       	breq	80007e26 <follow_path+0x246>
80007e54:	cf 8b       	rjmp	80007e44 <follow_path+0x264>
80007e56:	64 68       	ld.w	r8,r2[0x18]
80007e58:	f1 38 00 0b 	ld.ub	r8,r8[11]
80007e5c:	ce 0b       	rjmp	80007e1c <follow_path+0x23c>
80007e5e:	00 00       	add	r0,r0
80007e60:	80 00       	ld.sh	r0,r0[0x0]
80007e62:	74 78       	ld.w	r8,r10[0x1c]
80007e64:	80 00       	ld.sh	r0,r0[0x0]
80007e66:	62 fa       	ld.w	r10,r1[0x3c]
80007e68:	80 01       	ld.sh	r1,r0[0x0]
80007e6a:	8b c8       	st.w	r5[0x30],r8
80007e6c:	80 00       	ld.sh	r0,r0[0x0]
80007e6e:	63 06       	ld.w	r6,r1[0x40]
80007e70:	80 00       	ld.sh	r0,r0[0x0]
80007e72:	6c 6c       	ld.w	r12,r6[0x18]
80007e74:	80 00       	ld.sh	r0,r0[0x0]
80007e76:	75 fc       	ld.w	r12,r10[0x7c]
80007e78:	80 00       	ld.sh	r0,r0[0x0]
80007e7a:	63 76       	ld.w	r6,r1[0x5c]

80007e7c <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
80007e7c:	eb cd 40 80 	pushm	r7,lr
80007e80:	20 5d       	sub	sp,20
80007e82:	18 97       	mov	r7,r12
80007e84:	50 0b       	stdsp	sp[0x0],r11
	FRESULT res;
	FATFS* fs;
	DEFINE_NAMEBUF;


	if (!dp) return FR_INVALID_OBJECT;
80007e86:	58 0c       	cp.w	r12,0
80007e88:	c0 31       	brne	80007e8e <f_opendir+0x12>
80007e8a:	30 9c       	mov	r12,9
80007e8c:	c2 d8       	rjmp	80007ee6 <f_opendir+0x6a>

	/* Get logical drive number */
	res = find_volume(&fs, &path, 0);
80007e8e:	30 0a       	mov	r10,0
80007e90:	1a 9b       	mov	r11,sp
80007e92:	fa cc ff f0 	sub	r12,sp,-16
80007e96:	f0 1f 00 17 	mcall	80007ef0 <f_opendir+0x74>
	if (res == FR_OK) {
80007e9a:	c2 41       	brne	80007ee2 <f_opendir+0x66>
		dp->fs = fs;
80007e9c:	40 48       	lddsp	r8,sp[0x10]
80007e9e:	8f 08       	st.w	r7[0x0],r8
		INIT_BUF(*dp);
80007ea0:	fa c8 ff fc 	sub	r8,sp,-4
80007ea4:	8f 68       	st.w	r7[0x18],r8
		res = follow_path(dp, path);			/* Follow the path to the directory */
80007ea6:	40 0b       	lddsp	r11,sp[0x0]
80007ea8:	0e 9c       	mov	r12,r7
80007eaa:	f0 1f 00 13 	mcall	80007ef4 <f_opendir+0x78>
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
80007eae:	c1 61       	brne	80007eda <f_opendir+0x5e>
			if (dp->dir) {						/* It is not the origin directory itself */
80007eb0:	6e 5b       	ld.w	r11,r7[0x14]
80007eb2:	58 0b       	cp.w	r11,0
80007eb4:	c0 c0       	breq	80007ecc <f_opendir+0x50>
				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
80007eb6:	f7 38 00 0b 	ld.ub	r8,r11[11]
80007eba:	e2 18 00 10 	andl	r8,0x10,COH
80007ebe:	c0 31       	brne	80007ec4 <f_opendir+0x48>
80007ec0:	30 5c       	mov	r12,5
80007ec2:	c0 e8       	rjmp	80007ede <f_opendir+0x62>
					dp->sclust = ld_clust(fs, dp->dir);
80007ec4:	40 4c       	lddsp	r12,sp[0x10]
80007ec6:	f0 1f 00 0d 	mcall	80007ef8 <f_opendir+0x7c>
80007eca:	8f 2c       	st.w	r7[0x8],r12
				else							/* The object is a file */
					res = FR_NO_PATH;
			}
			if (res == FR_OK) {
				dp->id = fs->id;
80007ecc:	40 48       	lddsp	r8,sp[0x10]
80007ece:	90 38       	ld.sh	r8,r8[0x6]
80007ed0:	ae 28       	st.h	r7[0x4],r8
				res = dir_sdi(dp, 0);			/* Rewind directory */
80007ed2:	30 0b       	mov	r11,0
80007ed4:	0e 9c       	mov	r12,r7
80007ed6:	f0 1f 00 0a 	mcall	80007efc <f_opendir+0x80>
					}
				}
#endif
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
80007eda:	58 4c       	cp.w	r12,4
80007edc:	c0 80       	breq	80007eec <f_opendir+0x70>
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
80007ede:	58 0c       	cp.w	r12,0
80007ee0:	c0 30       	breq	80007ee6 <f_opendir+0x6a>
80007ee2:	30 08       	mov	r8,0
80007ee4:	8f 08       	st.w	r7[0x0],r8

	LEAVE_FF(fs, res);
}
80007ee6:	2f bd       	sub	sp,-20
80007ee8:	e3 cd 80 80 	ldm	sp++,r7,pc
#endif
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
80007eec:	30 5c       	mov	r12,5
80007eee:	cf ab       	rjmp	80007ee2 <f_opendir+0x66>
80007ef0:	80 00       	ld.sh	r0,r0[0x0]
80007ef2:	6d 48       	ld.w	r8,r6[0x50]
80007ef4:	80 00       	ld.sh	r0,r0[0x0]
80007ef6:	7b e0       	ld.w	r0,sp[0x78]
80007ef8:	80 00       	ld.sh	r0,r0[0x0]
80007efa:	63 76       	ld.w	r6,r1[0x5c]
80007efc:	80 00       	ld.sh	r0,r0[0x0]
80007efe:	74 78       	ld.w	r8,r10[0x1c]

80007f00 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR* path		/* Pointer to the directory path */
)
{
80007f00:	d4 31       	pushm	r0-r7,lr
80007f02:	21 0d       	sub	sp,64
80007f04:	50 4c       	stdsp	sp[0x10],r12
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tm = GET_FATTIME();
80007f06:	f0 1f 00 61 	mcall	80008088 <f_mkdir+0x188>
80007f0a:	18 95       	mov	r5,r12
	DEFINE_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 1);
80007f0c:	30 1a       	mov	r10,1
80007f0e:	fa cb ff f0 	sub	r11,sp,-16
80007f12:	fa cc ff e0 	sub	r12,sp,-32
80007f16:	f0 1f 00 5e 	mcall	8000808c <f_mkdir+0x18c>
80007f1a:	18 97       	mov	r7,r12
	if (res == FR_OK) {
80007f1c:	c0 30       	breq	80007f22 <f_mkdir+0x22>
80007f1e:	18 96       	mov	r6,r12
80007f20:	ca 78       	rjmp	8000806e <f_mkdir+0x16e>
		INIT_BUF(dj);
80007f22:	fa c8 ff ec 	sub	r8,sp,-20
80007f26:	50 e8       	stdsp	sp[0x38],r8
		res = follow_path(&dj, path);			/* Follow the file path */
80007f28:	40 4b       	lddsp	r11,sp[0x10]
80007f2a:	fa cc ff e0 	sub	r12,sp,-32
80007f2e:	f0 1f 00 59 	mcall	80008090 <f_mkdir+0x190>
80007f32:	18 96       	mov	r6,r12
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
80007f34:	c0 31       	brne	80007f3a <f_mkdir+0x3a>
80007f36:	30 86       	mov	r6,8
80007f38:	c9 b8       	rjmp	8000806e <f_mkdir+0x16e>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
80007f3a:	58 4c       	cp.w	r12,4
80007f3c:	e0 81 00 99 	brne	8000806e <f_mkdir+0x16e>
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
80007f40:	30 0b       	mov	r11,0
80007f42:	40 8c       	lddsp	r12,sp[0x20]
80007f44:	f0 1f 00 54 	mcall	80008094 <f_mkdir+0x194>
80007f48:	18 92       	mov	r2,r12
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
80007f4a:	c0 31       	brne	80007f50 <f_mkdir+0x50>
80007f4c:	30 77       	mov	r7,7
80007f4e:	c0 88       	rjmp	80007f5e <f_mkdir+0x5e>
			if (dcl == 1) res = FR_INT_ERR;
80007f50:	58 1c       	cp.w	r12,1
80007f52:	c0 31       	brne	80007f58 <f_mkdir+0x58>
80007f54:	30 27       	mov	r7,2
80007f56:	c6 c8       	rjmp	8000802e <f_mkdir+0x12e>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
80007f58:	5b fc       	cp.w	r12,-1
80007f5a:	e0 80 00 8d 	breq	80008074 <f_mkdir+0x174>
			if (res == FR_OK)					/* Flush FAT */
80007f5e:	58 07       	cp.w	r7,0
80007f60:	c6 71       	brne	8000802e <f_mkdir+0x12e>
				res = sync_window(dj.fs);
80007f62:	40 8c       	lddsp	r12,sp[0x20]
80007f64:	f0 1f 00 4d 	mcall	80008098 <f_mkdir+0x198>
80007f68:	18 97       	mov	r7,r12
			if (res == FR_OK) {					/* Initialize the new directory table */
80007f6a:	c6 21       	brne	8000802e <f_mkdir+0x12e>
				dsc = clust2sect(dj.fs, dcl);
80007f6c:	40 87       	lddsp	r7,sp[0x20]
80007f6e:	04 9b       	mov	r11,r2
80007f70:	0e 9c       	mov	r12,r7
80007f72:	f0 1f 00 4b 	mcall	8000809c <f_mkdir+0x19c>
80007f76:	18 94       	mov	r4,r12
				dir = dj.fs->win;
80007f78:	ee c3 ff d0 	sub	r3,r7,-48
				mem_set(dir, 0, SS(dj.fs));
80007f7c:	e0 6a 02 00 	mov	r10,512
80007f80:	30 0b       	mov	r11,0
80007f82:	06 9c       	mov	r12,r3
80007f84:	f0 1f 00 47 	mcall	800080a0 <f_mkdir+0x1a0>
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
80007f88:	30 ba       	mov	r10,11
80007f8a:	32 0b       	mov	r11,32
80007f8c:	06 9c       	mov	r12,r3
80007f8e:	f0 1f 00 45 	mcall	800080a0 <f_mkdir+0x1a0>
				dir[DIR_Name] = '.';
80007f92:	32 e6       	mov	r6,46
80007f94:	ef 66 00 30 	st.b	r7[48],r6
				dir[DIR_Attr] = AM_DIR;
80007f98:	31 08       	mov	r8,16
80007f9a:	e7 68 00 0b 	st.b	r3[11],r8
				ST_DWORD(dir + DIR_WrtTime, tm);
80007f9e:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80007fa2:	50 38       	stdsp	sp[0xc],r8
80007fa4:	e7 68 00 16 	st.b	r3[22],r8
80007fa8:	f1 d5 c1 08 	bfextu	r8,r5,0x8,0x8
80007fac:	50 28       	stdsp	sp[0x8],r8
80007fae:	e7 68 00 17 	st.b	r3[23],r8
80007fb2:	f1 d5 c2 08 	bfextu	r8,r5,0x10,0x8
80007fb6:	50 18       	stdsp	sp[0x4],r8
80007fb8:	e7 68 00 18 	st.b	r3[24],r8
80007fbc:	b9 85       	lsr	r5,0x18
80007fbe:	50 05       	stdsp	sp[0x0],r5
80007fc0:	e7 65 00 19 	st.b	r3[25],r5
				st_clust(dir, dcl);
80007fc4:	04 9b       	mov	r11,r2
80007fc6:	06 9c       	mov	r12,r3
80007fc8:	f0 1f 00 37 	mcall	800080a4 <f_mkdir+0x1a4>
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
80007fcc:	2b 07       	sub	r7,-80
80007fce:	32 0a       	mov	r10,32
80007fd0:	06 9b       	mov	r11,r3
80007fd2:	0e 9c       	mov	r12,r7
80007fd4:	f0 1f 00 35 	mcall	800080a8 <f_mkdir+0x1a8>
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
80007fd8:	e7 66 00 21 	st.b	r3[33],r6
80007fdc:	40 ab       	lddsp	r11,sp[0x28]
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
80007fde:	40 88       	lddsp	r8,sp[0x20]
80007fe0:	11 8a       	ld.ub	r10,r8[0x0]
80007fe2:	30 39       	mov	r9,3
80007fe4:	f2 0a 18 00 	cp.b	r10,r9
80007fe8:	c0 51       	brne	80007ff2 <f_mkdir+0xf2>
80007fea:	70 98       	ld.w	r8,r8[0x24]
80007fec:	16 38       	cp.w	r8,r11
80007fee:	f9 bb 00 00 	moveq	r11,0
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
80007ff2:	0e 9c       	mov	r12,r7
80007ff4:	f0 1f 00 2c 	mcall	800080a4 <f_mkdir+0x1a4>
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
80007ff8:	40 88       	lddsp	r8,sp[0x20]
80007ffa:	11 a6       	ld.ub	r6,r8[0x2]
80007ffc:	58 06       	cp.w	r6,0
80007ffe:	c3 d0       	breq	80008078 <f_mkdir+0x178>
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
80008000:	30 15       	mov	r5,1
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
80008002:	e0 61 02 00 	mov	r1,512
80008006:	30 00       	mov	r0,0
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
80008008:	40 88       	lddsp	r8,sp[0x20]
8000800a:	91 b4       	st.w	r8[0x2c],r4
8000800c:	2f f4       	sub	r4,-1
					dj.fs->wflag = 1;
8000800e:	40 88       	lddsp	r8,sp[0x20]
80008010:	b0 c5       	st.b	r8[0x4],r5
					res = sync_window(dj.fs);
80008012:	40 8c       	lddsp	r12,sp[0x20]
80008014:	f0 1f 00 21 	mcall	80008098 <f_mkdir+0x198>
					if (res != FR_OK) break;
80008018:	c0 a1       	brne	8000802c <f_mkdir+0x12c>
					mem_set(dir, 0, SS(dj.fs));
8000801a:	02 9a       	mov	r10,r1
8000801c:	00 9b       	mov	r11,r0
8000801e:	06 9c       	mov	r12,r3
80008020:	f0 1f 00 20 	mcall	800080a0 <f_mkdir+0x1a0>
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
80008024:	20 16       	sub	r6,1
80008026:	5c 56       	castu.b	r6
80008028:	cf 01       	brne	80008008 <f_mkdir+0x108>
8000802a:	c2 78       	rjmp	80008078 <f_mkdir+0x178>
8000802c:	18 97       	mov	r7,r12
8000802e:	0e 96       	mov	r6,r7
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
80008030:	04 9b       	mov	r11,r2
80008032:	40 8c       	lddsp	r12,sp[0x20]
80008034:	f0 1f 00 1e 	mcall	800080ac <f_mkdir+0x1ac>
80008038:	c1 b8       	rjmp	8000806e <f_mkdir+0x16e>
			} else {
				dir = dj.dir;
8000803a:	40 dc       	lddsp	r12,sp[0x34]
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
8000803c:	31 08       	mov	r8,16
8000803e:	f9 68 00 0b 	st.b	r12[11],r8
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
80008042:	40 38       	lddsp	r8,sp[0xc]
80008044:	f9 68 00 16 	st.b	r12[22],r8
80008048:	40 28       	lddsp	r8,sp[0x8]
8000804a:	f9 68 00 17 	st.b	r12[23],r8
8000804e:	40 18       	lddsp	r8,sp[0x4]
80008050:	f9 68 00 18 	st.b	r12[24],r8
80008054:	40 08       	lddsp	r8,sp[0x0]
80008056:	f9 68 00 19 	st.b	r12[25],r8
				st_clust(dir, dcl);					/* Table start cluster */
8000805a:	04 9b       	mov	r11,r2
8000805c:	f0 1f 00 12 	mcall	800080a4 <f_mkdir+0x1a4>
				dj.fs->wflag = 1;
80008060:	30 19       	mov	r9,1
80008062:	40 88       	lddsp	r8,sp[0x20]
80008064:	b0 c9       	st.b	r8[0x4],r9
				res = sync_fs(dj.fs);
80008066:	40 8c       	lddsp	r12,sp[0x20]
80008068:	f0 1f 00 12 	mcall	800080b0 <f_mkdir+0x1b0>
8000806c:	18 96       	mov	r6,r12
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
8000806e:	0c 9c       	mov	r12,r6
80008070:	2f 0d       	sub	sp,-64
80008072:	d8 32       	popm	r0-r7,pc
				dir = dj.dir;
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
				st_clust(dir, dcl);					/* Table start cluster */
				dj.fs->wflag = 1;
				res = sync_fs(dj.fs);
80008074:	30 17       	mov	r7,1
80008076:	cd cb       	rjmp	8000802e <f_mkdir+0x12e>
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
80008078:	fa cc ff e0 	sub	r12,sp,-32
8000807c:	f0 1f 00 0e 	mcall	800080b4 <f_mkdir+0x1b4>
80008080:	18 96       	mov	r6,r12
			if (res != FR_OK) {
80008082:	cd c0       	breq	8000803a <f_mkdir+0x13a>
80008084:	cd 6b       	rjmp	80008030 <f_mkdir+0x130>
80008086:	00 00       	add	r0,r0
80008088:	80 00       	ld.sh	r0,r0[0x0]
8000808a:	62 20       	ld.w	r0,r1[0x8]
8000808c:	80 00       	ld.sh	r0,r0[0x0]
8000808e:	6d 48       	ld.w	r8,r6[0x50]
80008090:	80 00       	ld.sh	r0,r0[0x0]
80008092:	7b e0       	ld.w	r0,sp[0x78]
80008094:	80 00       	ld.sh	r0,r0[0x0]
80008096:	75 2c       	ld.w	r12,r10[0x48]
80008098:	80 00       	ld.sh	r0,r0[0x0]
8000809a:	64 74       	ld.w	r4,r2[0x1c]
8000809c:	80 00       	ld.sh	r0,r0[0x0]
8000809e:	63 20       	ld.w	r0,r1[0x48]
800080a0:	80 00       	ld.sh	r0,r0[0x0]
800080a2:	62 fa       	ld.w	r10,r1[0x3c]
800080a4:	80 00       	ld.sh	r0,r0[0x0]
800080a6:	63 9e       	ld.w	lr,r1[0x64]
800080a8:	80 00       	ld.sh	r0,r0[0x0]
800080aa:	62 e4       	ld.w	r4,r1[0x38]
800080ac:	80 00       	ld.sh	r0,r0[0x0]
800080ae:	77 0c       	ld.w	r12,r11[0x40]
800080b0:	80 00       	ld.sh	r0,r0[0x0]
800080b2:	64 d8       	ld.w	r8,r2[0x34]
800080b4:	80 00       	ld.sh	r0,r0[0x0]
800080b6:	7b 94       	ld.w	r4,sp[0x64]

800080b8 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
800080b8:	eb cd 40 fc 	pushm	r2-r7,lr
800080bc:	20 cd       	sub	sp,48
800080be:	18 97       	mov	r7,r12
800080c0:	50 0b       	stdsp	sp[0x0],r11
#if !_FS_READONLY
	DWORD dw, cl;
#endif


	if (!fp) return FR_INVALID_OBJECT;
800080c2:	58 0c       	cp.w	r12,0
800080c4:	c0 31       	brne	800080ca <f_open+0x12>
800080c6:	30 96       	mov	r6,9
800080c8:	cb 68       	rjmp	80008234 <f_open+0x17c>
	fp->fs = 0;			/* Clear file object */
800080ca:	30 08       	mov	r8,0
800080cc:	99 08       	st.w	r12[0x0],r8

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
800080ce:	eb da c0 05 	bfextu	r5,r10,0x0,0x5
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
800080d2:	0a 93       	mov	r3,r5
800080d4:	e2 1a 00 1e 	andl	r10,0x1e,COH
800080d8:	1a 9b       	mov	r11,sp
800080da:	fa cc ff f0 	sub	r12,sp,-16
800080de:	f0 1f 00 5c 	mcall	8000824c <f_open+0x194>
800080e2:	18 96       	mov	r6,r12
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
800080e4:	e0 81 00 a8 	brne	80008234 <f_open+0x17c>
		INIT_BUF(dj);
800080e8:	fa c8 ff fc 	sub	r8,sp,-4
800080ec:	50 a8       	stdsp	sp[0x28],r8
		res = follow_path(&dj, path);	/* Follow the file path */
800080ee:	40 0b       	lddsp	r11,sp[0x0]
800080f0:	fa cc ff f0 	sub	r12,sp,-16
800080f4:	f0 1f 00 57 	mcall	80008250 <f_open+0x198>
		dir = dj.dir;
800080f8:	40 94       	lddsp	r4,sp[0x24]
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
800080fa:	c0 41       	brne	80008102 <f_open+0x4a>
			if (!dir)	/* Default directory itself */
800080fc:	58 04       	cp.w	r4,0
800080fe:	f9 bc 00 06 	moveq	r12,6
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
80008102:	06 98       	mov	r8,r3
80008104:	e2 18 00 1c 	andl	r8,0x1c,COH
80008108:	c5 f0       	breq	800081c6 <f_open+0x10e>
			if (res != FR_OK) {					/* No file, create new */
8000810a:	58 0c       	cp.w	r12,0
8000810c:	c0 d0       	breq	80008126 <f_open+0x6e>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
8000810e:	58 4c       	cp.w	r12,4
80008110:	e0 81 00 91 	brne	80008232 <f_open+0x17a>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
80008114:	fa cc ff f0 	sub	r12,sp,-16
80008118:	f0 1f 00 4f 	mcall	80008254 <f_open+0x19c>
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
8000811c:	40 94       	lddsp	r4,sp[0x24]
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
8000811e:	e0 81 00 8a 	brne	80008232 <f_open+0x17a>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
80008122:	a3 b5       	sbr	r5,0x3
80008124:	c0 c8       	rjmp	8000813c <f_open+0x84>
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
80008126:	e9 38 00 0b 	ld.ub	r8,r4[11]
8000812a:	e2 18 00 11 	andl	r8,0x11,COH
8000812e:	c0 30       	breq	80008134 <f_open+0x7c>
80008130:	30 7c       	mov	r12,7
80008132:	c8 08       	rjmp	80008232 <f_open+0x17a>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
80008134:	e2 13 00 04 	andl	r3,0x4,COH
80008138:	e0 81 00 82 	brne	8000823c <f_open+0x184>
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
8000813c:	0a 98       	mov	r8,r5
8000813e:	e2 18 00 08 	andl	r8,0x8,COH
80008142:	c7 f0       	breq	80008240 <f_open+0x188>
				dw = GET_FATTIME();
80008144:	f0 1f 00 45 	mcall	80008258 <f_open+0x1a0>
				ST_DWORD(dir + DIR_CrtTime, dw);/* Set created time */
80008148:	f5 dc c0 08 	bfextu	r10,r12,0x0,0x8
8000814c:	e9 6a 00 0e 	st.b	r4[14],r10
80008150:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80008154:	e9 69 00 0f 	st.b	r4[15],r9
80008158:	f1 dc c2 08 	bfextu	r8,r12,0x10,0x8
8000815c:	e9 68 00 10 	st.b	r4[16],r8
80008160:	b9 8c       	lsr	r12,0x18
80008162:	e9 6c 00 11 	st.b	r4[17],r12
				ST_DWORD(dir + DIR_WrtTime, dw);/* Set modified time */
80008166:	e9 6a 00 16 	st.b	r4[22],r10
8000816a:	e9 69 00 17 	st.b	r4[23],r9
8000816e:	e9 68 00 18 	st.b	r4[24],r8
80008172:	e9 6c 00 19 	st.b	r4[25],r12
				dir[DIR_Attr] = 0;				/* Reset attribute */
80008176:	30 08       	mov	r8,0
80008178:	e9 68 00 0b 	st.b	r4[11],r8
				ST_DWORD(dir + DIR_FileSize, 0);/* Reset file size */
8000817c:	e9 68 00 1c 	st.b	r4[28],r8
80008180:	e9 68 00 1d 	st.b	r4[29],r8
80008184:	e9 68 00 1e 	st.b	r4[30],r8
80008188:	e9 68 00 1f 	st.b	r4[31],r8
				cl = ld_clust(dj.fs, dir);		/* Get cluster chain */
8000818c:	08 9b       	mov	r11,r4
8000818e:	40 4c       	lddsp	r12,sp[0x10]
80008190:	f0 1f 00 33 	mcall	8000825c <f_open+0x1a4>
80008194:	18 93       	mov	r3,r12
				st_clust(dir, 0);				/* Reset cluster */
80008196:	30 0b       	mov	r11,0
80008198:	08 9c       	mov	r12,r4
8000819a:	f0 1f 00 32 	mcall	80008260 <f_open+0x1a8>
				dj.fs->wflag = 1;
8000819e:	30 19       	mov	r9,1
800081a0:	40 48       	lddsp	r8,sp[0x10]
800081a2:	b0 c9       	st.b	r8[0x4],r9
				if (cl) {						/* Remove the cluster chain if exist */
800081a4:	58 03       	cp.w	r3,0
800081a6:	c4 d0       	breq	80008240 <f_open+0x188>
					dw = dj.fs->winsect;
800081a8:	40 4c       	lddsp	r12,sp[0x10]
800081aa:	78 b2       	ld.w	r2,r12[0x2c]
					res = remove_chain(dj.fs, cl);
800081ac:	06 9b       	mov	r11,r3
800081ae:	f0 1f 00 2e 	mcall	80008264 <f_open+0x1ac>
					if (res == FR_OK) {
800081b2:	c4 01       	brne	80008232 <f_open+0x17a>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
800081b4:	20 13       	sub	r3,1
800081b6:	40 48       	lddsp	r8,sp[0x10]
800081b8:	91 33       	st.w	r8[0xc],r3
						res = move_window(dj.fs, dw);
800081ba:	04 9b       	mov	r11,r2
800081bc:	40 4c       	lddsp	r12,sp[0x10]
800081be:	f0 1f 00 2b 	mcall	80008268 <f_open+0x1b0>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
800081c2:	c1 40       	breq	800081ea <f_open+0x132>
800081c4:	c3 78       	rjmp	80008232 <f_open+0x17a>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Following succeeded */
800081c6:	58 0c       	cp.w	r12,0
800081c8:	c3 51       	brne	80008232 <f_open+0x17a>
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
800081ca:	e9 38 00 0b 	ld.ub	r8,r4[11]
800081ce:	10 99       	mov	r9,r8
800081d0:	e2 19 00 10 	andl	r9,0x10,COH
800081d4:	c0 30       	breq	800081da <f_open+0x122>
800081d6:	30 4c       	mov	r12,4
800081d8:	c2 d8       	rjmp	80008232 <f_open+0x17a>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
800081da:	e2 13 00 02 	andl	r3,0x2,COH
800081de:	c3 10       	breq	80008240 <f_open+0x188>
800081e0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800081e4:	c2 e0       	breq	80008240 <f_open+0x188>
800081e6:	30 7c       	mov	r12,7
800081e8:	c2 58       	rjmp	80008232 <f_open+0x17a>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
800081ea:	a5 b5       	sbr	r5,0x5
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
800081ec:	40 43       	lddsp	r3,sp[0x10]
800081ee:	66 b8       	ld.w	r8,r3[0x2c]
800081f0:	8f 78       	st.w	r7[0x1c],r8
			fp->dir_ptr = dir;
800081f2:	8f 84       	st.w	r7[0x20],r4
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
800081f4:	ae e5       	st.b	r7[0x6],r5
			fp->err = 0;						/* Clear error flag */
800081f6:	30 08       	mov	r8,0
800081f8:	ae f8       	st.b	r7[0x7],r8
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
800081fa:	08 9b       	mov	r11,r4
800081fc:	06 9c       	mov	r12,r3
800081fe:	f0 1f 00 18 	mcall	8000825c <f_open+0x1a4>
80008202:	8f 4c       	st.w	r7[0x10],r12
			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
80008204:	e9 39 00 1f 	ld.ub	r9,r4[31]
80008208:	e9 38 00 1e 	ld.ub	r8,r4[30]
8000820c:	b1 68       	lsl	r8,0x10
8000820e:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80008212:	e9 39 00 1c 	ld.ub	r9,r4[28]
80008216:	12 48       	or	r8,r9
80008218:	e9 39 00 1d 	ld.ub	r9,r4[29]
8000821c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80008220:	8f 38       	st.w	r7[0xc],r8
			fp->fptr = 0;						/* File pointer */
80008222:	30 08       	mov	r8,0
80008224:	8f 28       	st.w	r7[0x8],r8
			fp->dsect = 0;
80008226:	8f 68       	st.w	r7[0x18],r8
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
80008228:	8f 98       	st.w	r7[0x24],r8
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
8000822a:	8f 03       	st.w	r7[0x0],r3
			fp->id = fp->fs->id;
8000822c:	86 38       	ld.sh	r8,r3[0x6]
8000822e:	ae 28       	st.h	r7[0x4],r8
80008230:	c0 28       	rjmp	80008234 <f_open+0x17c>
80008232:	18 96       	mov	r6,r12
		}
	}

	LEAVE_FF(dj.fs, res);
}
80008234:	0c 9c       	mov	r12,r6
80008236:	2f 4d       	sub	sp,-48
80008238:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
			fp->dsect = 0;
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
			fp->id = fp->fs->id;
8000823c:	30 8c       	mov	r12,8
8000823e:	cf ab       	rjmp	80008232 <f_open+0x17a>
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
80008240:	0a 98       	mov	r8,r5
80008242:	e2 18 00 08 	andl	r8,0x8,COH
80008246:	cd 30       	breq	800081ec <f_open+0x134>
80008248:	cd 1b       	rjmp	800081ea <f_open+0x132>
8000824a:	00 00       	add	r0,r0
8000824c:	80 00       	ld.sh	r0,r0[0x0]
8000824e:	6d 48       	ld.w	r8,r6[0x50]
80008250:	80 00       	ld.sh	r0,r0[0x0]
80008252:	7b e0       	ld.w	r0,sp[0x78]
80008254:	80 00       	ld.sh	r0,r0[0x0]
80008256:	7b 94       	ld.w	r4,sp[0x64]
80008258:	80 00       	ld.sh	r0,r0[0x0]
8000825a:	62 20       	ld.w	r0,r1[0x8]
8000825c:	80 00       	ld.sh	r0,r0[0x0]
8000825e:	63 76       	ld.w	r6,r1[0x5c]
80008260:	80 00       	ld.sh	r0,r0[0x0]
80008262:	63 9e       	ld.w	lr,r1[0x64]
80008264:	80 00       	ld.sh	r0,r0[0x0]
80008266:	77 0c       	ld.w	r12,r11[0x40]
80008268:	80 00       	ld.sh	r0,r0[0x0]
8000826a:	6c 6c       	ld.w	r12,r6[0x18]

8000826c <f_getfree>:
FRESULT f_getfree (
	const TCHAR* path,	/* Path name of the logical drive number */
	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
)
{
8000826c:	d4 31       	pushm	r0-r7,lr
8000826e:	20 2d       	sub	sp,8
80008270:	fa c7 ff f8 	sub	r7,sp,-8
80008274:	0e dc       	st.w	--r7,r12
80008276:	16 90       	mov	r0,r11
80008278:	14 96       	mov	r6,r10
	UINT i;
	BYTE fat, *p;


	/* Get logical drive number */
	res = find_volume(fatfs, &path, 0);
8000827a:	30 0a       	mov	r10,0
8000827c:	0e 9b       	mov	r11,r7
8000827e:	0c 9c       	mov	r12,r6
80008280:	f0 1f 00 33 	mcall	8000834c <f_getfree+0xe0>
80008284:	18 93       	mov	r3,r12
	fs = *fatfs;
80008286:	6c 06       	ld.w	r6,r6[0x0]
	if (res == FR_OK) {
80008288:	c5 f1       	brne	80008346 <f_getfree+0xda>
		/* If free_clust is valid, return it without full cluster scan */
		if (fs->free_clust <= fs->n_fatent - 2) {
8000828a:	6c 48       	ld.w	r8,r6[0x10]
8000828c:	6c 57       	ld.w	r7,r6[0x14]
8000828e:	ee c9 00 02 	sub	r9,r7,2
80008292:	12 38       	cp.w	r8,r9
80008294:	e0 8b 00 04 	brhi	8000829c <f_getfree+0x30>
			*nclst = fs->free_clust;
80008298:	81 08       	st.w	r0[0x0],r8
8000829a:	c5 68       	rjmp	80008346 <f_getfree+0xda>
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
8000829c:	0d 84       	ld.ub	r4,r6[0x0]
			nfree = 0;
			if (fat == FS_FAT12) {	/* Sector unalighed entries: Search FAT via regular routine. */
8000829e:	30 18       	mov	r8,1
800082a0:	f0 04 18 00 	cp.b	r4,r8
800082a4:	c1 71       	brne	800082d2 <f_getfree+0x66>
800082a6:	30 27       	mov	r7,2
800082a8:	30 05       	mov	r5,0
				clst = 2;
				do {
					stat = get_fat(fs, clst);
800082aa:	0e 9b       	mov	r11,r7
800082ac:	0c 9c       	mov	r12,r6
800082ae:	f0 1f 00 29 	mcall	80008350 <f_getfree+0xe4>
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
800082b2:	5b fc       	cp.w	r12,-1
800082b4:	c0 31       	brne	800082ba <f_getfree+0x4e>
800082b6:	30 1c       	mov	r12,1
800082b8:	c4 28       	rjmp	8000833c <f_getfree+0xd0>
					if (stat == 1) { res = FR_INT_ERR; break; }
800082ba:	58 1c       	cp.w	r12,1
800082bc:	c0 31       	brne	800082c2 <f_getfree+0x56>
800082be:	30 2c       	mov	r12,2
800082c0:	c3 e8       	rjmp	8000833c <f_getfree+0xd0>
					if (stat == 0) nfree++;
800082c2:	58 0c       	cp.w	r12,0
800082c4:	f7 b5 00 ff 	subeq	r5,-1
				} while (++clst < fs->n_fatent);
800082c8:	2f f7       	sub	r7,-1
800082ca:	6c 58       	ld.w	r8,r6[0x14]
800082cc:	10 37       	cp.w	r7,r8
800082ce:	ce e3       	brcs	800082aa <f_getfree+0x3e>
800082d0:	c3 58       	rjmp	8000833a <f_getfree+0xce>
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
800082d2:	6c 81       	ld.w	r1,r6[0x20]
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
						if (res != FR_OK) break;
						p = fs->win;
800082d4:	30 08       	mov	r8,0
800082d6:	10 99       	mov	r9,r8
800082d8:	10 95       	mov	r5,r8
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
800082da:	ec ca ff d0 	sub	r10,r6,-48
800082de:	50 0a       	stdsp	sp[0x0],r10
						if (res != FR_OK) break;
						p = fs->win;
						i = SS(fs);
					}
					if (fat == FS_FAT16) {
800082e0:	30 22       	mov	r2,2
				} while (++clst < fs->n_fatent);
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
800082e2:	58 09       	cp.w	r9,0
800082e4:	c0 a1       	brne	800082f8 <f_getfree+0x8c>
						res = move_window(fs, sect++);
800082e6:	02 9b       	mov	r11,r1
800082e8:	0c 9c       	mov	r12,r6
800082ea:	f0 1f 00 1b 	mcall	80008354 <f_getfree+0xe8>
						if (res != FR_OK) break;
800082ee:	c2 71       	brne	8000833c <f_getfree+0xd0>
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
800082f0:	2f f1       	sub	r1,-1
800082f2:	40 08       	lddsp	r8,sp[0x0]
800082f4:	e0 69 02 00 	mov	r9,512
						if (res != FR_OK) break;
						p = fs->win;
						i = SS(fs);
					}
					if (fat == FS_FAT16) {
800082f8:	e4 04 18 00 	cp.b	r4,r2
800082fc:	c0 d1       	brne	80008316 <f_getfree+0xaa>
						if (LD_WORD(p) == 0) nfree++;
800082fe:	11 9b       	ld.ub	r11,r8[0x1]
80008300:	11 8a       	ld.ub	r10,r8[0x0]
80008302:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
80008306:	30 0b       	mov	r11,0
80008308:	f6 0a 19 00 	cp.h	r10,r11
8000830c:	f7 b5 00 ff 	subeq	r5,-1
						p += 2; i -= 2;
80008310:	2f e8       	sub	r8,-2
80008312:	20 29       	sub	r9,2
80008314:	c1 18       	rjmp	80008336 <f_getfree+0xca>
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) nfree++;
80008316:	11 bb       	ld.ub	r11,r8[0x3]
80008318:	11 aa       	ld.ub	r10,r8[0x2]
8000831a:	b1 6a       	lsl	r10,0x10
8000831c:	f5 eb 11 8a 	or	r10,r10,r11<<0x18
80008320:	11 8b       	ld.ub	r11,r8[0x0]
80008322:	16 4a       	or	r10,r11
80008324:	11 9b       	ld.ub	r11,r8[0x1]
80008326:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
8000832a:	f5 da c0 1c 	bfextu	r10,r10,0x0,0x1c
8000832e:	f7 b5 00 ff 	subeq	r5,-1
						p += 4; i -= 4;
80008332:	2f c8       	sub	r8,-4
80008334:	20 49       	sub	r9,4
					}
				} while (--clst);
80008336:	20 17       	sub	r7,1
80008338:	cd 51       	brne	800082e2 <f_getfree+0x76>
8000833a:	06 9c       	mov	r12,r3
			}
			fs->free_clust = nfree;	/* free_clust is valid */
8000833c:	8d 45       	st.w	r6[0x10],r5
			fs->fsi_flag |= 1;		/* FSInfo is to be updated */
8000833e:	0d d8       	ld.ub	r8,r6[0x5]
80008340:	a1 a8       	sbr	r8,0x0
80008342:	ac d8       	st.b	r6[0x5],r8
			*nclst = nfree;			/* Return the free clusters */
80008344:	81 05       	st.w	r0[0x0],r5
		}
	}
	LEAVE_FF(fs, res);
}
80008346:	2f ed       	sub	sp,-8
80008348:	d8 32       	popm	r0-r7,pc
8000834a:	00 00       	add	r0,r0
8000834c:	80 00       	ld.sh	r0,r0[0x0]
8000834e:	6d 48       	ld.w	r8,r6[0x50]
80008350:	80 00       	ld.sh	r0,r0[0x0]
80008352:	73 94       	ld.w	r4,r9[0x64]
80008354:	80 00       	ld.sh	r0,r0[0x0]
80008356:	6c 6c       	ld.w	r12,r6[0x18]

80008358 <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
80008358:	d4 31       	pushm	r0-r7,lr
8000835a:	18 97       	mov	r7,r12
8000835c:	16 95       	mov	r5,r11
#if _USE_FASTSEEK
	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
#endif


	res = validate(fp);					/* Check validity of the object */
8000835e:	f0 1f 00 a5 	mcall	800085f0 <f_lseek+0x298>
80008362:	18 96       	mov	r6,r12
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
80008364:	e0 81 01 44 	brne	800085ec <f_lseek+0x294>
	if (fp->err)						/* Check error */
80008368:	0f f8       	ld.ub	r8,r7[0x7]
8000836a:	58 08       	cp.w	r8,0
8000836c:	c0 30       	breq	80008372 <f_lseek+0x1a>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
8000836e:	10 96       	mov	r6,r8
80008370:	c3 e9       	rjmp	800085ec <f_lseek+0x294>

#if _USE_FASTSEEK
	if (fp->cltbl) {	/* Fast seek */
80008372:	6e 93       	ld.w	r3,r7[0x24]
80008374:	58 03       	cp.w	r3,0
80008376:	e0 80 00 85 	breq	80008480 <f_lseek+0x128>
		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
8000837a:	5b f5       	cp.w	r5,-1
8000837c:	c3 71       	brne	800083ea <f_lseek+0x92>
			tbl = fp->cltbl;
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
8000837e:	07 00       	ld.w	r0,r3++
			cl = fp->sclust;			/* Top of the chain */
80008380:	6e 41       	ld.w	r1,r7[0x10]
			if (cl) {
80008382:	58 01       	cp.w	r1,0
80008384:	c2 80       	breq	800083d4 <f_lseek+0x7c>
80008386:	30 22       	mov	r2,2
80008388:	02 95       	mov	r5,r1
8000838a:	30 04       	mov	r4,0
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
					do {
						pcl = cl; ncl++;
						cl = get_fat(fp->fs, cl);
8000838c:	0a 9b       	mov	r11,r5
8000838e:	6e 0c       	ld.w	r12,r7[0x0]
80008390:	f0 1f 00 99 	mcall	800085f4 <f_lseek+0x29c>
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
80008394:	58 1c       	cp.w	r12,1
80008396:	e0 8b 00 06 	brhi	800083a2 <f_lseek+0x4a>
8000839a:	30 28       	mov	r8,2
8000839c:	ae f8       	st.b	r7[0x7],r8
8000839e:	30 26       	mov	r6,2
800083a0:	c2 69       	rjmp	800085ec <f_lseek+0x294>
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
800083a2:	5b fc       	cp.w	r12,-1
800083a4:	c0 51       	brne	800083ae <f_lseek+0x56>
800083a6:	30 18       	mov	r8,1
800083a8:	ae f8       	st.b	r7[0x7],r8
800083aa:	30 16       	mov	r6,1
800083ac:	c2 09       	rjmp	800085ec <f_lseek+0x294>
			if (cl) {
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
					do {
						pcl = cl; ncl++;
800083ae:	2f f4       	sub	r4,-1
						cl = get_fat(fp->fs, cl);
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					} while (cl == pcl + 1);
800083b0:	2f f5       	sub	r5,-1
800083b2:	0a 3c       	cp.w	r12,r5
800083b4:	c0 31       	brne	800083ba <f_lseek+0x62>
800083b6:	18 95       	mov	r5,r12
800083b8:	ce ab       	rjmp	8000838c <f_lseek+0x34>
800083ba:	18 98       	mov	r8,r12
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
			cl = fp->sclust;			/* Top of the chain */
			if (cl) {
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
800083bc:	2f e2       	sub	r2,-2
						pcl = cl; ncl++;
						cl = get_fat(fp->fs, cl);
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					} while (cl == pcl + 1);
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
800083be:	04 30       	cp.w	r0,r2
800083c0:	c0 33       	brcs	800083c6 <f_lseek+0x6e>
						*tbl++ = ncl; *tbl++ = tcl;
800083c2:	06 a4       	st.w	r3++,r4
800083c4:	06 a1       	st.w	r3++,r1
					}
				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
800083c6:	6e 09       	ld.w	r9,r7[0x0]
800083c8:	72 59       	ld.w	r9,r9[0x14]
800083ca:	10 39       	cp.w	r9,r8
800083cc:	e0 88 00 05 	brls	800083d6 <f_lseek+0x7e>
800083d0:	18 91       	mov	r1,r12
800083d2:	cd bb       	rjmp	80008388 <f_lseek+0x30>
800083d4:	30 22       	mov	r2,2
			}
			*fp->cltbl = ulen;	/* Number of items used */
800083d6:	6e 98       	ld.w	r8,r7[0x24]
800083d8:	91 02       	st.w	r8[0x0],r2
			if (ulen <= tlen)
800083da:	00 32       	cp.w	r2,r0
800083dc:	f9 b6 0b 11 	movhi	r6,17
				*tbl = 0;		/* Terminate table */
800083e0:	f9 b8 08 00 	movls	r8,0
800083e4:	e7 f8 8a 00 	st.wls	r3[0x0],r8
800083e8:	c0 29       	rjmp	800085ec <f_lseek+0x294>
800083ea:	6e 34       	ld.w	r4,r7[0xc]
800083ec:	08 35       	cp.w	r5,r4
800083ee:	e8 05 17 b0 	movhi	r5,r4
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */

		} else {						/* Fast seek */
			if (ofs > fp->fsize)		/* Clip offset at the file size */
				ofs = fp->fsize;
			fp->fptr = ofs;				/* Set file pointer */
800083f2:	8f 25       	st.w	r7[0x8],r5
			if (ofs) {
800083f4:	58 05       	cp.w	r5,0
800083f6:	e0 80 00 fb 	breq	800085ec <f_lseek+0x294>
				fp->clust = clmt_clust(fp, ofs - 1);
800083fa:	ea c4 00 01 	sub	r4,r5,1
800083fe:	08 9b       	mov	r11,r4
80008400:	0e 9c       	mov	r12,r7
80008402:	f0 1f 00 7e 	mcall	800085f8 <f_lseek+0x2a0>
80008406:	18 9b       	mov	r11,r12
80008408:	8f 5c       	st.w	r7[0x14],r12
				dsc = clust2sect(fp->fs, fp->clust);
8000840a:	6e 05       	ld.w	r5,r7[0x0]
8000840c:	0a 9c       	mov	r12,r5
8000840e:	f0 1f 00 7c 	mcall	800085fc <f_lseek+0x2a4>
				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
80008412:	c0 51       	brne	8000841c <f_lseek+0xc4>
80008414:	30 28       	mov	r8,2
80008416:	ae f8       	st.b	r7[0x7],r8
80008418:	30 26       	mov	r6,2
8000841a:	ce 98       	rjmp	800085ec <f_lseek+0x294>
				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
8000841c:	0b a9       	ld.ub	r9,r5[0x2]
				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
8000841e:	6e 28       	ld.w	r8,r7[0x8]
80008420:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80008424:	e0 80 00 e4 	breq	800085ec <f_lseek+0x294>
			fp->fptr = ofs;				/* Set file pointer */
			if (ofs) {
				fp->clust = clmt_clust(fp, ofs - 1);
				dsc = clust2sect(fp->fs, fp->clust);
				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
80008428:	20 19       	sub	r9,1
8000842a:	f3 e4 02 94 	and	r4,r9,r4>>0x9
8000842e:	f8 04 00 04 	add	r4,r12,r4
				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
80008432:	6e 6a       	ld.w	r10,r7[0x18]
80008434:	08 3a       	cp.w	r10,r4
80008436:	e0 80 00 db 	breq	800085ec <f_lseek+0x294>
#if !_FS_TINY
#if !_FS_READONLY
					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
8000843a:	0f e8       	ld.ub	r8,r7[0x6]
8000843c:	e2 18 00 40 	andl	r8,0x40,COH
80008440:	c0 f0       	breq	8000845e <f_lseek+0x106>
						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80008442:	30 19       	mov	r9,1
80008444:	ee cb ff d8 	sub	r11,r7,-40
80008448:	0b 9c       	ld.ub	r12,r5[0x1]
8000844a:	f0 1f 00 6e 	mcall	80008600 <f_lseek+0x2a8>
8000844e:	c0 50       	breq	80008458 <f_lseek+0x100>
							ABORT(fp->fs, FR_DISK_ERR);
80008450:	30 18       	mov	r8,1
80008452:	ae f8       	st.b	r7[0x7],r8
80008454:	30 16       	mov	r6,1
80008456:	cc b8       	rjmp	800085ec <f_lseek+0x294>
						fp->flag &= ~FA__DIRTY;
80008458:	0f e8       	ld.ub	r8,r7[0x6]
8000845a:	a7 c8       	cbr	r8,0x6
8000845c:	ae e8       	st.b	r7[0x6],r8
					}
#endif
					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
8000845e:	6e 08       	ld.w	r8,r7[0x0]
80008460:	30 19       	mov	r9,1
80008462:	08 9a       	mov	r10,r4
80008464:	ee cb ff d8 	sub	r11,r7,-40
80008468:	11 9c       	ld.ub	r12,r8[0x1]
8000846a:	f0 1f 00 67 	mcall	80008604 <f_lseek+0x2ac>
						ABORT(fp->fs, FR_DISK_ERR);
8000846e:	f9 b8 01 01 	movne	r8,1
80008472:	ef f8 1e 07 	st.bne	r7[0x7],r8
80008476:	f9 b6 01 01 	movne	r6,1
#endif
					fp->dsect = dsc;
8000847a:	ef f4 0a 06 	st.weq	r7[0x18],r4
8000847e:	cb 78       	rjmp	800085ec <f_lseek+0x294>

	/* Normal Seek */
	{
		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
80008480:	6e 34       	ld.w	r4,r7[0xc]
	} else
#endif

	/* Normal Seek */
	{
		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
80008482:	08 35       	cp.w	r5,r4
80008484:	e0 88 00 06 	brls	80008490 <f_lseek+0x138>
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
80008488:	0f e8       	ld.ub	r8,r7[0x6]
8000848a:	e2 18 00 02 	andl	r8,0x2,COH
8000848e:	c0 20       	breq	80008492 <f_lseek+0x13a>
80008490:	0a 94       	mov	r4,r5
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
80008492:	6e 29       	ld.w	r9,r7[0x8]
		fp->fptr = nsect = 0;
80008494:	30 08       	mov	r8,0
80008496:	8f 28       	st.w	r7[0x8],r8
		if (ofs) {
80008498:	58 04       	cp.w	r4,0
8000849a:	e0 80 00 a9 	breq	800085ec <f_lseek+0x294>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
8000849e:	6e 08       	ld.w	r8,r7[0x0]
800084a0:	11 a5       	ld.ub	r5,r8[0x2]
800084a2:	a9 75       	lsl	r5,0x9
			if (ifptr > 0 &&
800084a4:	58 09       	cp.w	r9,0
800084a6:	c1 30       	breq	800084cc <f_lseek+0x174>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
800084a8:	20 19       	sub	r9,1

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
800084aa:	e8 cb 00 01 	sub	r11,r4,1
800084ae:	f6 05 0d 0a 	divu	r10,r11,r5
800084b2:	14 9b       	mov	r11,r10
800084b4:	f2 05 0d 02 	divu	r2,r9,r5
800084b8:	04 3b       	cp.w	r11,r2
800084ba:	c0 93       	brcs	800084cc <f_lseek+0x174>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
800084bc:	ea 08 11 00 	rsub	r8,r5,0
800084c0:	f1 e9 00 09 	and	r9,r8,r9
800084c4:	8f 29       	st.w	r7[0x8],r9
				ofs -= fp->fptr;
800084c6:	12 14       	sub	r4,r9
				clst = fp->clust;
800084c8:	6e 5c       	ld.w	r12,r7[0x14]

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
800084ca:	c1 68       	rjmp	800084f6 <f_lseek+0x19e>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
				ofs -= fp->fptr;
				clst = fp->clust;
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
800084cc:	6e 4c       	ld.w	r12,r7[0x10]
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
800084ce:	58 0c       	cp.w	r12,0
800084d0:	c1 21       	brne	800084f4 <f_lseek+0x19c>
					clst = create_chain(fp->fs, 0);
800084d2:	30 0b       	mov	r11,0
800084d4:	10 9c       	mov	r12,r8
800084d6:	f0 1f 00 4d 	mcall	80008608 <f_lseek+0x2b0>
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
800084da:	58 1c       	cp.w	r12,1
800084dc:	c0 51       	brne	800084e6 <f_lseek+0x18e>
800084de:	30 28       	mov	r8,2
800084e0:	ae f8       	st.b	r7[0x7],r8
800084e2:	30 26       	mov	r6,2
800084e4:	c8 48       	rjmp	800085ec <f_lseek+0x294>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
800084e6:	5b fc       	cp.w	r12,-1
800084e8:	c0 51       	brne	800084f2 <f_lseek+0x19a>
800084ea:	30 18       	mov	r8,1
800084ec:	ae f8       	st.b	r7[0x7],r8
800084ee:	30 16       	mov	r6,1
800084f0:	c7 e8       	rjmp	800085ec <f_lseek+0x294>
					fp->sclust = clst;
800084f2:	8f 4c       	st.w	r7[0x10],r12
				}
#endif
				fp->clust = clst;
800084f4:	8f 5c       	st.w	r7[0x14],r12
			}
			if (clst != 0) {
800084f6:	58 0c       	cp.w	r12,0
800084f8:	c4 80       	breq	80008588 <f_lseek+0x230>
				while (ofs > bcs) {						/* Cluster following loop */
800084fa:	0a 34       	cp.w	r4,r5
800084fc:	e0 88 00 32 	brls	80008560 <f_lseek+0x208>
#if _FS_MINIMIZE <= 2
/*-----------------------------------------------------------------------*/
/* Seek File R/W Pointer                                                 */
/*-----------------------------------------------------------------------*/

FRESULT f_lseek (
80008500:	ea 03 11 00 	rsub	r3,r5,0
80008504:	0a 14       	sub	r4,r5
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
80008506:	0f e8       	ld.ub	r8,r7[0x6]
80008508:	e2 18 00 02 	andl	r8,0x2,COH
8000850c:	c0 70       	breq	8000851a <f_lseek+0x1c2>
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
8000850e:	18 9b       	mov	r11,r12
80008510:	6e 0c       	ld.w	r12,r7[0x0]
80008512:	f0 1f 00 3e 	mcall	80008608 <f_lseek+0x2b0>
						if (clst == 0) {				/* When disk gets full, clip file size */
80008516:	c0 61       	brne	80008522 <f_lseek+0x1ca>
80008518:	c2 38       	rjmp	8000855e <f_lseek+0x206>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
8000851a:	18 9b       	mov	r11,r12
8000851c:	6e 0c       	ld.w	r12,r7[0x0]
8000851e:	f0 1f 00 36 	mcall	800085f4 <f_lseek+0x29c>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
80008522:	5b fc       	cp.w	r12,-1
80008524:	c0 51       	brne	8000852e <f_lseek+0x1d6>
80008526:	30 18       	mov	r8,1
80008528:	ae f8       	st.b	r7[0x7],r8
8000852a:	30 16       	mov	r6,1
8000852c:	c6 08       	rjmp	800085ec <f_lseek+0x294>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
8000852e:	58 1c       	cp.w	r12,1
80008530:	e0 88 00 06 	brls	8000853c <f_lseek+0x1e4>
80008534:	6e 08       	ld.w	r8,r7[0x0]
80008536:	70 58       	ld.w	r8,r8[0x14]
80008538:	10 3c       	cp.w	r12,r8
8000853a:	c0 53       	brcs	80008544 <f_lseek+0x1ec>
8000853c:	30 28       	mov	r8,2
8000853e:	ae f8       	st.b	r7[0x7],r8
80008540:	30 26       	mov	r6,2
80008542:	c5 58       	rjmp	800085ec <f_lseek+0x294>
					fp->clust = clst;
80008544:	8f 5c       	st.w	r7[0x14],r12
					fp->fptr += bcs;
80008546:	6e 28       	ld.w	r8,r7[0x8]
80008548:	0a 08       	add	r8,r5
8000854a:	8f 28       	st.w	r7[0x8],r8
8000854c:	e8 03 00 08 	add	r8,r4,r3
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
80008550:	f0 05 00 09 	add	r9,r8,r5
80008554:	0a 39       	cp.w	r9,r5
80008556:	e0 88 00 05 	brls	80008560 <f_lseek+0x208>
8000855a:	10 94       	mov	r4,r8
8000855c:	cd 5b       	rjmp	80008506 <f_lseek+0x1ae>
8000855e:	0a 94       	mov	r4,r5
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
80008560:	6e 28       	ld.w	r8,r7[0x8]
80008562:	08 08       	add	r8,r4
80008564:	8f 28       	st.w	r7[0x8],r8
				if (ofs % SS(fp->fs)) {
80008566:	f1 d4 c0 09 	bfextu	r8,r4,0x0,0x9
8000856a:	c0 f0       	breq	80008588 <f_lseek+0x230>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
8000856c:	18 9b       	mov	r11,r12
8000856e:	6e 0c       	ld.w	r12,r7[0x0]
80008570:	f0 1f 00 23 	mcall	800085fc <f_lseek+0x2a4>
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
80008574:	c0 51       	brne	8000857e <f_lseek+0x226>
80008576:	30 28       	mov	r8,2
80008578:	ae f8       	st.b	r7[0x7],r8
8000857a:	30 26       	mov	r6,2
8000857c:	c3 88       	rjmp	800085ec <f_lseek+0x294>
					nsect += ofs / SS(fp->fs);
8000857e:	e8 05 16 09 	lsr	r5,r4,0x9
80008582:	f8 05 00 05 	add	r5,r12,r5
80008586:	c0 28       	rjmp	8000858a <f_lseek+0x232>
80008588:	30 05       	mov	r5,0
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
8000858a:	6e 28       	ld.w	r8,r7[0x8]
8000858c:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80008590:	c2 50       	breq	800085da <f_lseek+0x282>
80008592:	6e 6a       	ld.w	r10,r7[0x18]
80008594:	0a 3a       	cp.w	r10,r5
80008596:	c2 20       	breq	800085da <f_lseek+0x282>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
80008598:	0f e8       	ld.ub	r8,r7[0x6]
8000859a:	e2 18 00 40 	andl	r8,0x40,COH
8000859e:	c1 00       	breq	800085be <f_lseek+0x266>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
800085a0:	6e 08       	ld.w	r8,r7[0x0]
800085a2:	30 19       	mov	r9,1
800085a4:	ee cb ff d8 	sub	r11,r7,-40
800085a8:	11 9c       	ld.ub	r12,r8[0x1]
800085aa:	f0 1f 00 16 	mcall	80008600 <f_lseek+0x2a8>
800085ae:	c0 50       	breq	800085b8 <f_lseek+0x260>
					ABORT(fp->fs, FR_DISK_ERR);
800085b0:	30 18       	mov	r8,1
800085b2:	ae f8       	st.b	r7[0x7],r8
800085b4:	30 16       	mov	r6,1
800085b6:	c1 b8       	rjmp	800085ec <f_lseek+0x294>
				fp->flag &= ~FA__DIRTY;
800085b8:	0f e8       	ld.ub	r8,r7[0x6]
800085ba:	a7 c8       	cbr	r8,0x6
800085bc:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
800085be:	6e 08       	ld.w	r8,r7[0x0]
800085c0:	30 19       	mov	r9,1
800085c2:	0a 9a       	mov	r10,r5
800085c4:	ee cb ff d8 	sub	r11,r7,-40
800085c8:	11 9c       	ld.ub	r12,r8[0x1]
800085ca:	f0 1f 00 0f 	mcall	80008604 <f_lseek+0x2ac>
800085ce:	c0 50       	breq	800085d8 <f_lseek+0x280>
				ABORT(fp->fs, FR_DISK_ERR);
800085d0:	30 18       	mov	r8,1
800085d2:	ae f8       	st.b	r7[0x7],r8
800085d4:	30 16       	mov	r6,1
800085d6:	c0 b8       	rjmp	800085ec <f_lseek+0x294>
#endif
			fp->dsect = nsect;
800085d8:	8f 65       	st.w	r7[0x18],r5
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
800085da:	6e 28       	ld.w	r8,r7[0x8]
800085dc:	6e 39       	ld.w	r9,r7[0xc]
800085de:	12 38       	cp.w	r8,r9
800085e0:	e0 88 00 06 	brls	800085ec <f_lseek+0x294>
			fp->fsize = fp->fptr;
800085e4:	8f 38       	st.w	r7[0xc],r8
			fp->flag |= FA__WRITTEN;
800085e6:	0f e8       	ld.ub	r8,r7[0x6]
800085e8:	a5 b8       	sbr	r8,0x5
800085ea:	ae e8       	st.b	r7[0x6],r8
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
800085ec:	0c 9c       	mov	r12,r6
800085ee:	d8 32       	popm	r0-r7,pc
800085f0:	80 00       	ld.sh	r0,r0[0x0]
800085f2:	6c 38       	ld.w	r8,r6[0xc]
800085f4:	80 00       	ld.sh	r0,r0[0x0]
800085f6:	73 94       	ld.w	r4,r9[0x64]
800085f8:	80 00       	ld.sh	r0,r0[0x0]
800085fa:	63 38       	ld.w	r8,r1[0x4c]
800085fc:	80 00       	ld.sh	r0,r0[0x0]
800085fe:	63 20       	ld.w	r0,r1[0x48]
80008600:	80 00       	ld.sh	r0,r0[0x0]
80008602:	62 ac       	ld.w	r12,r1[0x28]
80008604:	80 00       	ld.sh	r0,r0[0x0]
80008606:	62 c8       	ld.w	r8,r1[0x30]
80008608:	80 00       	ld.sh	r0,r0[0x0]
8000860a:	75 2c       	ld.w	r12,r10[0x48]

8000860c <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
8000860c:	d4 31       	pushm	r0-r7,lr
8000860e:	20 3d       	sub	sp,12
80008610:	18 97       	mov	r7,r12
80008612:	16 93       	mov	r3,r11
80008614:	14 96       	mov	r6,r10
80008616:	12 94       	mov	r4,r9
	UINT wcnt, cc;
	const BYTE *wbuff = (const BYTE*)buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
80008618:	30 08       	mov	r8,0
8000861a:	93 08       	st.w	r9[0x0],r8

	res = validate(fp);						/* Check validity */
8000861c:	f0 1f 00 6d 	mcall	800087d0 <f_write+0x1c4>
80008620:	18 92       	mov	r2,r12
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
80008622:	e0 81 00 d3 	brne	800087c8 <f_write+0x1bc>
	if (fp->err)							/* Check error */
80008626:	0f f8       	ld.ub	r8,r7[0x7]
80008628:	58 08       	cp.w	r8,0
8000862a:	c0 30       	breq	80008630 <f_write+0x24>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
8000862c:	10 92       	mov	r2,r8
8000862e:	cc d8       	rjmp	800087c8 <f_write+0x1bc>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
80008630:	0f e8       	ld.ub	r8,r7[0x6]
80008632:	e2 18 00 02 	andl	r8,0x2,COH
80008636:	c0 31       	brne	8000863c <f_write+0x30>
80008638:	30 72       	mov	r2,7
8000863a:	cc 78       	rjmp	800087c8 <f_write+0x1bc>
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
8000863c:	6e 28       	ld.w	r8,r7[0x8]
8000863e:	ec 08 00 09 	add	r9,r6,r8
80008642:	12 38       	cp.w	r8,r9
80008644:	e0 8b 00 ba 	brhi	800087b8 <f_write+0x1ac>

	for ( ;  btw;							/* Repeat until all data written */
80008648:	58 06       	cp.w	r6,0
8000864a:	e0 80 00 b7 	breq	800087b8 <f_write+0x1ac>
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
8000864e:	ee c8 ff d8 	sub	r8,r7,-40
80008652:	50 18       	stdsp	sp[0x4],r8
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
80008654:	50 08       	stdsp	sp[0x0],r8
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
			if (!csect) {					/* On the cluster boundary? */
				if (fp->fptr == 0) {		/* On the top of the file? */
					clst = fp->sclust;		/* Follow from the origin */
					if (clst == 0)			/* When no cluster is allocated, */
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
80008656:	50 2c       	stdsp	sp[0x8],r12
80008658:	0c 95       	mov	r5,r6
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
8000865a:	6e 2b       	ld.w	r11,r7[0x8]
8000865c:	f1 db c0 09 	bfextu	r8,r11,0x0,0x9
80008660:	e0 81 00 8c 	brne	80008778 <f_write+0x16c>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
80008664:	6e 08       	ld.w	r8,r7[0x0]
80008666:	11 a6       	ld.ub	r6,r8[0x2]
80008668:	20 16       	sub	r6,1
8000866a:	ed eb 02 96 	and	r6,r6,r11>>0x9
8000866e:	5c 56       	castu.b	r6
			if (!csect) {					/* On the cluster boundary? */
80008670:	c2 91       	brne	800086c2 <f_write+0xb6>
				if (fp->fptr == 0) {		/* On the top of the file? */
80008672:	58 0b       	cp.w	r11,0
80008674:	c0 81       	brne	80008684 <f_write+0x78>
					clst = fp->sclust;		/* Follow from the origin */
80008676:	6e 4c       	ld.w	r12,r7[0x10]
					if (clst == 0)			/* When no cluster is allocated, */
80008678:	58 0c       	cp.w	r12,0
8000867a:	c1 31       	brne	800086a0 <f_write+0x94>
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
8000867c:	10 9c       	mov	r12,r8
8000867e:	f0 1f 00 56 	mcall	800087d4 <f_write+0x1c8>
80008682:	c0 c8       	rjmp	8000869a <f_write+0x8e>
				} else {					/* Middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl)
80008684:	6e 99       	ld.w	r9,r7[0x24]
80008686:	58 09       	cp.w	r9,0
80008688:	c0 50       	breq	80008692 <f_write+0x86>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
8000868a:	0e 9c       	mov	r12,r7
8000868c:	f0 1f 00 53 	mcall	800087d8 <f_write+0x1cc>
80008690:	c0 58       	rjmp	8000869a <f_write+0x8e>
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
80008692:	6e 5b       	ld.w	r11,r7[0x14]
80008694:	10 9c       	mov	r12,r8
80008696:	f0 1f 00 50 	mcall	800087d4 <f_write+0x1c8>
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
8000869a:	58 0c       	cp.w	r12,0
8000869c:	e0 80 00 8b 	breq	800087b2 <f_write+0x1a6>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
800086a0:	58 1c       	cp.w	r12,1
800086a2:	c0 51       	brne	800086ac <f_write+0xa0>
800086a4:	30 28       	mov	r8,2
800086a6:	ae f8       	st.b	r7[0x7],r8
800086a8:	30 22       	mov	r2,2
800086aa:	c8 f8       	rjmp	800087c8 <f_write+0x1bc>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
800086ac:	5b fc       	cp.w	r12,-1
800086ae:	c0 51       	brne	800086b8 <f_write+0xac>
800086b0:	30 18       	mov	r8,1
800086b2:	ae f8       	st.b	r7[0x7],r8
800086b4:	30 12       	mov	r2,1
800086b6:	c8 98       	rjmp	800087c8 <f_write+0x1bc>
				fp->clust = clst;			/* Update current cluster */
800086b8:	8f 5c       	st.w	r7[0x14],r12
				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
800086ba:	6e 48       	ld.w	r8,r7[0x10]
800086bc:	58 08       	cp.w	r8,0
800086be:	ef fc 0a 04 	st.weq	r7[0x10],r12
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
800086c2:	0f e8       	ld.ub	r8,r7[0x6]
800086c4:	e2 18 00 40 	andl	r8,0x40,COH
800086c8:	c1 00       	breq	800086e8 <f_write+0xdc>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
800086ca:	6e 08       	ld.w	r8,r7[0x0]
800086cc:	30 19       	mov	r9,1
800086ce:	6e 6a       	ld.w	r10,r7[0x18]
800086d0:	40 1b       	lddsp	r11,sp[0x4]
800086d2:	11 9c       	ld.ub	r12,r8[0x1]
800086d4:	f0 1f 00 42 	mcall	800087dc <f_write+0x1d0>
800086d8:	c0 50       	breq	800086e2 <f_write+0xd6>
					ABORT(fp->fs, FR_DISK_ERR);
800086da:	30 18       	mov	r8,1
800086dc:	ae f8       	st.b	r7[0x7],r8
800086de:	30 12       	mov	r2,1
800086e0:	c7 48       	rjmp	800087c8 <f_write+0x1bc>
				fp->flag &= ~FA__DIRTY;
800086e2:	0f e8       	ld.ub	r8,r7[0x6]
800086e4:	a7 c8       	cbr	r8,0x6
800086e6:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
800086e8:	6e 01       	ld.w	r1,r7[0x0]
800086ea:	6e 5b       	ld.w	r11,r7[0x14]
800086ec:	02 9c       	mov	r12,r1
800086ee:	f0 1f 00 3d 	mcall	800087e0 <f_write+0x1d4>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
800086f2:	c0 51       	brne	800086fc <f_write+0xf0>
800086f4:	30 28       	mov	r8,2
800086f6:	ae f8       	st.b	r7[0x7],r8
800086f8:	30 22       	mov	r2,2
800086fa:	c6 78       	rjmp	800087c8 <f_write+0x1bc>
			sect += csect;
800086fc:	f8 06 00 00 	add	r0,r12,r6
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
80008700:	ea 02 16 09 	lsr	r2,r5,0x9
			if (cc) {						/* Write maximum contiguous sectors directly */
80008704:	c2 70       	breq	80008752 <f_write+0x146>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
80008706:	03 a9       	ld.ub	r9,r1[0x2]
80008708:	e4 06 00 08 	add	r8,r2,r6
					cc = fp->fs->csize - csect;
8000870c:	12 38       	cp.w	r8,r9
8000870e:	f3 d6 eb 12 	subhi	r2,r9,r6
				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
80008712:	04 99       	mov	r9,r2
80008714:	00 9a       	mov	r10,r0
80008716:	06 9b       	mov	r11,r3
80008718:	03 9c       	ld.ub	r12,r1[0x1]
8000871a:	f0 1f 00 31 	mcall	800087dc <f_write+0x1d0>
8000871e:	c0 50       	breq	80008728 <f_write+0x11c>
					ABORT(fp->fs, FR_DISK_ERR);
80008720:	30 18       	mov	r8,1
80008722:	ae f8       	st.b	r7[0x7],r8
80008724:	30 12       	mov	r2,1
80008726:	c5 18       	rjmp	800087c8 <f_write+0x1bc>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
80008728:	6e 6b       	ld.w	r11,r7[0x18]
8000872a:	f6 00 01 00 	sub	r0,r11,r0
8000872e:	00 32       	cp.w	r2,r0
80008730:	e0 88 00 0e 	brls	8000874c <f_write+0x140>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
80008734:	e0 0b 15 09 	lsl	r11,r0,0x9
80008738:	e0 6a 02 00 	mov	r10,512
8000873c:	e6 0b 00 0b 	add	r11,r3,r11
80008740:	40 0c       	lddsp	r12,sp[0x0]
80008742:	f0 1f 00 29 	mcall	800087e4 <f_write+0x1d8>
					fp->flag &= ~FA__DIRTY;
80008746:	0f e8       	ld.ub	r8,r7[0x6]
80008748:	a7 c8       	cbr	r8,0x6
8000874a:	ae e8       	st.b	r7[0x6],r8
				}
#endif
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
8000874c:	e4 06 15 09 	lsl	r6,r2,0x9
				continue;
80008750:	c2 78       	rjmp	8000879e <f_write+0x192>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
80008752:	6e 68       	ld.w	r8,r7[0x18]
80008754:	00 38       	cp.w	r8,r0
80008756:	c1 00       	breq	80008776 <f_write+0x16a>
				if (fp->fptr < fp->fsize &&
80008758:	6e 29       	ld.w	r9,r7[0x8]
8000875a:	6e 38       	ld.w	r8,r7[0xc]
8000875c:	10 39       	cp.w	r9,r8
8000875e:	c0 c2       	brcc	80008776 <f_write+0x16a>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
80008760:	30 19       	mov	r9,1
80008762:	00 9a       	mov	r10,r0
80008764:	40 1b       	lddsp	r11,sp[0x4]
80008766:	03 9c       	ld.ub	r12,r1[0x1]
80008768:	f0 1f 00 20 	mcall	800087e8 <f_write+0x1dc>
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
8000876c:	c0 50       	breq	80008776 <f_write+0x16a>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
8000876e:	30 18       	mov	r8,1
80008770:	ae f8       	st.b	r7[0x7],r8
80008772:	30 12       	mov	r2,1
80008774:	c2 a8       	rjmp	800087c8 <f_write+0x1bc>
			}
#endif
			fp->dsect = sect;
80008776:	8f 60       	st.w	r7[0x18],r0
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
80008778:	6e 2c       	ld.w	r12,r7[0x8]
8000877a:	f9 dc c0 09 	bfextu	r12,r12,0x0,0x9
8000877e:	e0 66 02 00 	mov	r6,512
80008782:	18 16       	sub	r6,r12
80008784:	0c 35       	cp.w	r5,r6
80008786:	ea 06 17 80 	movls	r6,r5
		if (move_window(fp->fs, fp->dsect) != FR_OK)	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
8000878a:	0c 9a       	mov	r10,r6
8000878c:	06 9b       	mov	r11,r3
8000878e:	40 08       	lddsp	r8,sp[0x0]
80008790:	f0 0c 00 0c 	add	r12,r8,r12
80008794:	f0 1f 00 14 	mcall	800087e4 <f_write+0x1d8>
		fp->flag |= FA__DIRTY;
80008798:	0f e8       	ld.ub	r8,r7[0x6]
8000879a:	a7 a8       	sbr	r8,0x6
8000879c:	ae e8       	st.b	r7[0x6],r8
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
8000879e:	6e 28       	ld.w	r8,r7[0x8]
800087a0:	0c 08       	add	r8,r6
800087a2:	8f 28       	st.w	r7[0x8],r8
800087a4:	68 08       	ld.w	r8,r4[0x0]
800087a6:	0c 08       	add	r8,r6
800087a8:	89 08       	st.w	r4[0x0],r8
800087aa:	0c 15       	sub	r5,r6
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
800087ac:	c0 50       	breq	800087b6 <f_write+0x1aa>
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
800087ae:	0c 03       	add	r3,r6
800087b0:	c5 5b       	rjmp	8000865a <f_write+0x4e>
800087b2:	40 22       	lddsp	r2,sp[0x8]
800087b4:	c0 28       	rjmp	800087b8 <f_write+0x1ac>
800087b6:	40 22       	lddsp	r2,sp[0x8]
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
800087b8:	6e 28       	ld.w	r8,r7[0x8]
800087ba:	6e 39       	ld.w	r9,r7[0xc]
800087bc:	12 38       	cp.w	r8,r9
800087be:	ef f8 ba 03 	st.whi	r7[0xc],r8
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
800087c2:	0f e8       	ld.ub	r8,r7[0x6]
800087c4:	a5 b8       	sbr	r8,0x5
800087c6:	ae e8       	st.b	r7[0x6],r8

	LEAVE_FF(fp->fs, FR_OK);
}
800087c8:	04 9c       	mov	r12,r2
800087ca:	2f dd       	sub	sp,-12
800087cc:	d8 32       	popm	r0-r7,pc
800087ce:	00 00       	add	r0,r0
800087d0:	80 00       	ld.sh	r0,r0[0x0]
800087d2:	6c 38       	ld.w	r8,r6[0xc]
800087d4:	80 00       	ld.sh	r0,r0[0x0]
800087d6:	75 2c       	ld.w	r12,r10[0x48]
800087d8:	80 00       	ld.sh	r0,r0[0x0]
800087da:	63 38       	ld.w	r8,r1[0x4c]
800087dc:	80 00       	ld.sh	r0,r0[0x0]
800087de:	62 ac       	ld.w	r12,r1[0x28]
800087e0:	80 00       	ld.sh	r0,r0[0x0]
800087e2:	63 20       	ld.w	r0,r1[0x48]
800087e4:	80 00       	ld.sh	r0,r0[0x0]
800087e6:	62 e4       	ld.w	r4,r1[0x38]
800087e8:	80 00       	ld.sh	r0,r0[0x0]
800087ea:	62 c8       	ld.w	r8,r1[0x30]

800087ec <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
800087ec:	f8 c8 ff f8 	sub	r8,r12,-8
800087f0:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
800087f2:	3f f9       	mov	r9,-1
800087f4:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
800087f6:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
800087f8:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
800087fa:	30 08       	mov	r8,0
800087fc:	99 08       	st.w	r12[0x0],r8
}
800087fe:	5e fc       	retal	r12

80008800 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80008800:	30 08       	mov	r8,0
80008802:	99 48       	st.w	r12[0x10],r8
}
80008804:	5e fc       	retal	r12

80008806 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80008806:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80008808:	70 19       	ld.w	r9,r8[0x4]
8000880a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
8000880c:	78 19       	ld.w	r9,r12[0x4]
8000880e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80008810:	70 19       	ld.w	r9,r8[0x4]
80008812:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80008814:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80008816:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80008818:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000881a:	78 08       	ld.w	r8,r12[0x0]
8000881c:	2f f8       	sub	r8,-1
8000881e:	99 08       	st.w	r12[0x0],r8
}
80008820:	5e fc       	retal	r12

80008822 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80008822:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80008824:	5b fa       	cp.w	r10,-1
80008826:	c0 31       	brne	8000882c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80008828:	78 48       	ld.w	r8,r12[0x10]
8000882a:	c0 c8       	rjmp	80008842 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
8000882c:	f8 c8 ff f8 	sub	r8,r12,-8
80008830:	70 19       	ld.w	r9,r8[0x4]
80008832:	72 09       	ld.w	r9,r9[0x0]
80008834:	12 3a       	cp.w	r10,r9
80008836:	c0 63       	brcs	80008842 <vListInsert+0x20>
80008838:	70 18       	ld.w	r8,r8[0x4]
8000883a:	70 19       	ld.w	r9,r8[0x4]
8000883c:	72 09       	ld.w	r9,r9[0x0]
8000883e:	12 3a       	cp.w	r10,r9
80008840:	cf c2       	brcc	80008838 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80008842:	70 19       	ld.w	r9,r8[0x4]
80008844:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80008846:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80008848:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
8000884a:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
8000884c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000884e:	78 08       	ld.w	r8,r12[0x0]
80008850:	2f f8       	sub	r8,-1
80008852:	99 08       	st.w	r12[0x0],r8
}
80008854:	5e fc       	retal	r12

80008856 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80008856:	78 18       	ld.w	r8,r12[0x4]
80008858:	78 29       	ld.w	r9,r12[0x8]
8000885a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
8000885c:	78 28       	ld.w	r8,r12[0x8]
8000885e:	78 19       	ld.w	r9,r12[0x4]
80008860:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80008862:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80008864:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80008866:	18 39       	cp.w	r9,r12
80008868:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
8000886c:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80008870:	30 09       	mov	r9,0
80008872:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80008874:	70 09       	ld.w	r9,r8[0x0]
80008876:	20 19       	sub	r9,1
80008878:	91 09       	st.w	r8[0x0],r9
}
8000887a:	5e fc       	retal	r12

8000887c <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
8000887c:	e0 68 08 08 	mov	r8,2056
80008880:	ea 18 08 08 	orh	r8,0x808
80008884:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80008886:	e0 68 09 09 	mov	r8,2313
8000888a:	ea 18 09 09 	orh	r8,0x909
8000888e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80008890:	e0 68 0a 0a 	mov	r8,2570
80008894:	ea 18 0a 0a 	orh	r8,0xa0a
80008898:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
8000889a:	e0 68 0b 0b 	mov	r8,2827
8000889e:	ea 18 0b 0b 	orh	r8,0xb0b
800088a2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800088a4:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
800088a6:	e0 68 be ef 	mov	r8,48879
800088aa:	ea 18 de ad 	orh	r8,0xdead
800088ae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
800088b0:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
800088b2:	fc 18 00 40 	movh	r8,0x40
800088b6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
800088b8:	e0 68 00 ff 	mov	r8,255
800088bc:	ea 18 ff 00 	orh	r8,0xff00
800088c0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
800088c2:	e0 68 01 01 	mov	r8,257
800088c6:	ea 18 01 01 	orh	r8,0x101
800088ca:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
800088cc:	e0 68 02 02 	mov	r8,514
800088d0:	ea 18 02 02 	orh	r8,0x202
800088d4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
800088d6:	e0 68 03 03 	mov	r8,771
800088da:	ea 18 03 03 	orh	r8,0x303
800088de:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
800088e0:	e0 68 04 04 	mov	r8,1028
800088e4:	ea 18 04 04 	orh	r8,0x404
800088e8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800088ea:	e0 68 05 05 	mov	r8,1285
800088ee:	ea 18 05 05 	orh	r8,0x505
800088f2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800088f4:	e0 68 06 06 	mov	r8,1542
800088f8:	ea 18 06 06 	orh	r8,0x606
800088fc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
800088fe:	e0 68 07 07 	mov	r8,1799
80008902:	ea 18 07 07 	orh	r8,0x707
80008906:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80008908:	30 08       	mov	r8,0
8000890a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
8000890c:	5e fc       	retal	r12
8000890e:	d7 03       	nop

80008910 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80008910:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80008912:	48 38       	lddpc	r8,8000891c <vPortEnterCritical+0xc>
80008914:	70 09       	ld.w	r9,r8[0x0]
80008916:	2f f9       	sub	r9,-1
80008918:	91 09       	st.w	r8[0x0],r9
}
8000891a:	5e fc       	retal	r12
8000891c:	00 00       	add	r0,r0
8000891e:	05 30       	ld.ub	r0,r2++

80008920 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80008920:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80008922:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80008924:	30 0a       	mov	r10,0
80008926:	14 9b       	mov	r11,r10
80008928:	49 2c       	lddpc	r12,80008970 <xPortStartScheduler+0x50>
8000892a:	f0 1f 00 13 	mcall	80008974 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
8000892e:	e0 68 5d c0 	mov	r8,24000
80008932:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80008936:	30 08       	mov	r8,0
80008938:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000893c:	e0 68 12 24 	mov	r8,4644
80008940:	ea 18 00 00 	orh	r8,0x0
80008944:	70 00       	ld.w	r0,r8[0x0]
80008946:	60 0d       	ld.w	sp,r0[0x0]
80008948:	1b 00       	ld.w	r0,sp++
8000894a:	e0 68 05 30 	mov	r8,1328
8000894e:	ea 18 00 00 	orh	r8,0x0
80008952:	91 00       	st.w	r8[0x0],r0
80008954:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008958:	2f ed       	sub	sp,-8
8000895a:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000895e:	fa f0 ff e0 	ld.w	r0,sp[-32]
80008962:	e3 b0 00 00 	mtsr	0x0,r0
80008966:	fa f0 ff dc 	ld.w	r0,sp[-36]
8000896a:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
8000896e:	d8 0a       	popm	pc,r12=0
80008970:	80 00       	ld.sh	r0,r0[0x0]
80008972:	8a 3c       	ld.sh	r12,r5[0x6]
80008974:	80 00       	ld.sh	r0,r0[0x0]
80008976:	59 e0       	cp.w	r0,30

80008978 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80008978:	20 6d       	sub	sp,24
8000897a:	eb cd 00 ff 	pushm	r0-r7
8000897e:	fa c7 ff c0 	sub	r7,sp,-64
80008982:	ee f0 ff f8 	ld.w	r0,r7[-8]
80008986:	ef 40 ff e0 	st.w	r7[-32],r0
8000898a:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000898e:	ef 40 ff e4 	st.w	r7[-28],r0
80008992:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80008996:	e0 68 05 30 	mov	r8,1328
8000899a:	ea 18 00 00 	orh	r8,0x0
8000899e:	70 00       	ld.w	r0,r8[0x0]
800089a0:	1a d0       	st.w	--sp,r0
800089a2:	f0 1f 00 1a 	mcall	80008a08 <LABEL_RET_SCALL_263+0x14>
800089a6:	e0 68 12 24 	mov	r8,4644
800089aa:	ea 18 00 00 	orh	r8,0x0
800089ae:	70 00       	ld.w	r0,r8[0x0]
800089b0:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800089b2:	f0 1f 00 17 	mcall	80008a0c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
800089b6:	e0 68 12 24 	mov	r8,4644
800089ba:	ea 18 00 00 	orh	r8,0x0
800089be:	70 00       	ld.w	r0,r8[0x0]
800089c0:	60 0d       	ld.w	sp,r0[0x0]
800089c2:	1b 00       	ld.w	r0,sp++
800089c4:	e0 68 05 30 	mov	r8,1328
800089c8:	ea 18 00 00 	orh	r8,0x0
800089cc:	91 00       	st.w	r8[0x0],r0
800089ce:	fa c7 ff d8 	sub	r7,sp,-40
800089d2:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800089d6:	ee f0 ff e0 	ld.w	r0,r7[-32]
800089da:	e0 61 05 30 	mov	r1,1328
800089de:	ea 11 00 00 	orh	r1,0x0
800089e2:	62 02       	ld.w	r2,r1[0x0]
800089e4:	58 02       	cp.w	r2,0
800089e6:	c0 70       	breq	800089f4 <LABEL_RET_SCALL_263>
800089e8:	e4 c2 00 01 	sub	r2,r2,1
800089ec:	83 02       	st.w	r1[0x0],r2
800089ee:	58 02       	cp.w	r2,0
800089f0:	c0 21       	brne	800089f4 <LABEL_RET_SCALL_263>
800089f2:	b1 c0       	cbr	r0,0x10

800089f4 <LABEL_RET_SCALL_263>:
800089f4:	ef 40 ff f8 	st.w	r7[-8],r0
800089f8:	ee f0 ff e4 	ld.w	r0,r7[-28]
800089fc:	ef 40 ff fc 	st.w	r7[-4],r0
80008a00:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008a04:	2f ad       	sub	sp,-24
80008a06:	d6 13       	rets
80008a08:	80 00       	ld.sh	r0,r0[0x0]
80008a0a:	89 10       	st.w	r4[0x4],r0
80008a0c:	80 00       	ld.sh	r0,r0[0x0]
80008a0e:	90 ac       	ld.uh	r12,r8[0x4]

80008a10 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80008a10:	e1 b8 00 43 	mfsr	r8,0x10c
80008a14:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80008a18:	5e fc       	retal	r12
80008a1a:	d7 03       	nop

80008a1c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80008a1c:	48 78       	lddpc	r8,80008a38 <vPortExitCritical+0x1c>
80008a1e:	70 08       	ld.w	r8,r8[0x0]
80008a20:	58 08       	cp.w	r8,0
80008a22:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80008a24:	48 58       	lddpc	r8,80008a38 <vPortExitCritical+0x1c>
80008a26:	70 09       	ld.w	r9,r8[0x0]
80008a28:	20 19       	sub	r9,1
80008a2a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80008a2c:	70 08       	ld.w	r8,r8[0x0]
80008a2e:	58 08       	cp.w	r8,0
80008a30:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80008a32:	d5 03       	csrf	0x10
80008a34:	5e fc       	retal	r12
80008a36:	00 00       	add	r0,r0
80008a38:	00 00       	add	r0,r0
80008a3a:	05 30       	ld.ub	r0,r2++

80008a3c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80008a3c:	eb cd 00 ff 	pushm	r0-r7
80008a40:	e0 68 05 30 	mov	r8,1328
80008a44:	ea 18 00 00 	orh	r8,0x0
80008a48:	70 00       	ld.w	r0,r8[0x0]
80008a4a:	1a d0       	st.w	--sp,r0
80008a4c:	7a 90       	ld.w	r0,sp[0x24]
80008a4e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008a52:	58 10       	cp.w	r0,1
80008a54:	e0 8b 00 08 	brhi	80008a64 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80008a58:	e0 68 12 24 	mov	r8,4644
80008a5c:	ea 18 00 00 	orh	r8,0x0
80008a60:	70 00       	ld.w	r0,r8[0x0]
80008a62:	81 0d       	st.w	r0[0x0],sp

80008a64 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80008a64:	f0 1f 00 12 	mcall	80008aac <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80008a68:	f0 1f 00 12 	mcall	80008ab0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80008a6c:	f0 1f 00 12 	mcall	80008ab4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80008a70:	f0 1f 00 12 	mcall	80008ab8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80008a74:	7a 90       	ld.w	r0,sp[0x24]
80008a76:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008a7a:	58 10       	cp.w	r0,1
80008a7c:	e0 8b 00 0e 	brhi	80008a98 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80008a80:	f0 1f 00 0c 	mcall	80008ab0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80008a84:	f0 1f 00 0e 	mcall	80008abc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80008a88:	f0 1f 00 0c 	mcall	80008ab8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80008a8c:	e0 68 12 24 	mov	r8,4644
80008a90:	ea 18 00 00 	orh	r8,0x0
80008a94:	70 00       	ld.w	r0,r8[0x0]
80008a96:	60 0d       	ld.w	sp,r0[0x0]

80008a98 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80008a98:	1b 00       	ld.w	r0,sp++
80008a9a:	e0 68 05 30 	mov	r8,1328
80008a9e:	ea 18 00 00 	orh	r8,0x0
80008aa2:	91 00       	st.w	r8[0x0],r0
80008aa4:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008aa8:	d6 03       	rete
80008aaa:	00 00       	add	r0,r0
80008aac:	80 00       	ld.sh	r0,r0[0x0]
80008aae:	8a 10       	ld.sh	r0,r5[0x2]
80008ab0:	80 00       	ld.sh	r0,r0[0x0]
80008ab2:	89 10       	st.w	r4[0x4],r0
80008ab4:	80 00       	ld.sh	r0,r0[0x0]
80008ab6:	92 b0       	ld.uh	r0,r9[0x6]
80008ab8:	80 00       	ld.sh	r0,r0[0x0]
80008aba:	8a 1c       	ld.sh	r12,r5[0x2]
80008abc:	80 00       	ld.sh	r0,r0[0x0]
80008abe:	90 ac       	ld.uh	r12,r8[0x4]

80008ac0 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80008ac0:	d4 01       	pushm	lr
	vTaskSuspendAll();
80008ac2:	f0 1f 00 02 	mcall	80008ac8 <__malloc_lock+0x8>
}
80008ac6:	d8 02       	popm	pc
80008ac8:	80 00       	ld.sh	r0,r0[0x0]
80008aca:	90 9c       	ld.uh	r12,r8[0x2]

80008acc <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80008acc:	d4 01       	pushm	lr
	xTaskResumeAll();
80008ace:	f0 1f 00 02 	mcall	80008ad4 <__malloc_unlock+0x8>
}
80008ad2:	d8 02       	popm	pc
80008ad4:	80 00       	ld.sh	r0,r0[0x0]
80008ad6:	94 58       	ld.sh	r8,r10[0xa]

80008ad8 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80008ad8:	d4 21       	pushm	r4-r7,lr
80008ada:	16 95       	mov	r5,r11
80008adc:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80008ade:	58 0c       	cp.w	r12,0
80008ae0:	c0 30       	breq	80008ae6 <_read+0xe>
80008ae2:	3f f7       	mov	r7,-1
80008ae4:	c1 48       	rjmp	80008b0c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80008ae6:	58 0a       	cp.w	r10,0
80008ae8:	e0 89 00 04 	brgt	80008af0 <_read+0x18>
80008aec:	30 07       	mov	r7,0
80008aee:	c0 f8       	rjmp	80008b0c <_read+0x34>
80008af0:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80008af2:	48 84       	lddpc	r4,80008b10 <_read+0x38>
80008af4:	68 0c       	ld.w	r12,r4[0x0]
80008af6:	f0 1f 00 08 	mcall	80008b14 <_read+0x3c>
    if (c < 0)
80008afa:	c0 95       	brlt	80008b0c <_read+0x34>
      break;

    *ptr++ = c;
80008afc:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80008b00:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80008b02:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80008b06:	58 08       	cp.w	r8,0
80008b08:	fe 99 ff f6 	brgt	80008af4 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80008b0c:	0e 9c       	mov	r12,r7
80008b0e:	d8 22       	popm	r4-r7,pc
80008b10:	00 00       	add	r0,r0
80008b12:	46 20       	lddsp	r0,sp[0x188]
80008b14:	80 00       	ld.sh	r0,r0[0x0]
80008b16:	60 d4       	ld.w	r4,r0[0x34]

80008b18 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80008b18:	d4 21       	pushm	r4-r7,lr
80008b1a:	16 95       	mov	r5,r11
80008b1c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80008b1e:	20 1c       	sub	r12,1
80008b20:	58 2c       	cp.w	r12,2
80008b22:	e0 8b 00 12 	brhi	80008b46 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80008b26:	58 0a       	cp.w	r10,0
80008b28:	c0 31       	brne	80008b2e <_write+0x16>
80008b2a:	30 07       	mov	r7,0
80008b2c:	c0 e8       	rjmp	80008b48 <_write+0x30>
80008b2e:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80008b30:	48 74       	lddpc	r4,80008b4c <_write+0x34>
80008b32:	68 0c       	ld.w	r12,r4[0x0]
80008b34:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80008b38:	f0 1f 00 06 	mcall	80008b50 <_write+0x38>
80008b3c:	c0 55       	brlt	80008b46 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80008b3e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80008b40:	0e 36       	cp.w	r6,r7
80008b42:	cf 81       	brne	80008b32 <_write+0x1a>
80008b44:	c0 28       	rjmp	80008b48 <_write+0x30>
80008b46:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80008b48:	0e 9c       	mov	r12,r7
80008b4a:	d8 22       	popm	r4-r7,pc
80008b4c:	00 00       	add	r0,r0
80008b4e:	46 20       	lddsp	r0,sp[0x188]
80008b50:	80 00       	ld.sh	r0,r0[0x0]
80008b52:	60 84       	ld.w	r4,r0[0x20]

80008b54 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80008b54:	eb cd 40 80 	pushm	r7,lr
80008b58:	18 97       	mov	r7,r12
	if( pv )
80008b5a:	58 0c       	cp.w	r12,0
80008b5c:	c0 80       	breq	80008b6c <vPortFree+0x18>
	{
		vTaskSuspendAll();
80008b5e:	f0 1f 00 05 	mcall	80008b70 <vPortFree+0x1c>
		{
			free( pv );
80008b62:	0e 9c       	mov	r12,r7
80008b64:	f0 1f 00 04 	mcall	80008b74 <vPortFree+0x20>
		}
		xTaskResumeAll();
80008b68:	f0 1f 00 04 	mcall	80008b78 <vPortFree+0x24>
80008b6c:	e3 cd 80 80 	ldm	sp++,r7,pc
80008b70:	80 00       	ld.sh	r0,r0[0x0]
80008b72:	90 9c       	ld.uh	r12,r8[0x2]
80008b74:	80 00       	ld.sh	r0,r0[0x0]
80008b76:	a0 08       	st.h	r0[0x0],r8
80008b78:	80 00       	ld.sh	r0,r0[0x0]
80008b7a:	94 58       	ld.sh	r8,r10[0xa]

80008b7c <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80008b7c:	eb cd 40 80 	pushm	r7,lr
80008b80:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80008b82:	f0 1f 00 06 	mcall	80008b98 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80008b86:	0e 9c       	mov	r12,r7
80008b88:	f0 1f 00 05 	mcall	80008b9c <pvPortMalloc+0x20>
80008b8c:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80008b8e:	f0 1f 00 05 	mcall	80008ba0 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80008b92:	0e 9c       	mov	r12,r7
80008b94:	e3 cd 80 80 	ldm	sp++,r7,pc
80008b98:	80 00       	ld.sh	r0,r0[0x0]
80008b9a:	90 9c       	ld.uh	r12,r8[0x2]
80008b9c:	80 00       	ld.sh	r0,r0[0x0]
80008b9e:	a0 18       	st.h	r0[0x2],r8
80008ba0:	80 00       	ld.sh	r0,r0[0x0]
80008ba2:	94 58       	ld.sh	r8,r10[0xa]

80008ba4 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80008ba4:	d4 01       	pushm	lr
80008ba6:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80008ba8:	78 09       	ld.w	r9,r12[0x0]
80008baa:	58 09       	cp.w	r9,0
80008bac:	c1 10       	breq	80008bce <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80008bae:	78 3a       	ld.w	r10,r12[0xc]
80008bb0:	79 09       	ld.w	r9,r12[0x40]
80008bb2:	f4 09 00 09 	add	r9,r10,r9
80008bb6:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80008bb8:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80008bba:	14 39       	cp.w	r9,r10
80008bbc:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80008bc0:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80008bc4:	79 0a       	ld.w	r10,r12[0x40]
80008bc6:	78 3b       	ld.w	r11,r12[0xc]
80008bc8:	10 9c       	mov	r12,r8
80008bca:	f0 1f 00 02 	mcall	80008bd0 <prvCopyDataFromQueue+0x2c>
80008bce:	d8 02       	popm	pc
80008bd0:	80 00       	ld.sh	r0,r0[0x0]
80008bd2:	a4 86       	st.b	r2[0x0],r6

80008bd4 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80008bd4:	eb cd 40 c0 	pushm	r6-r7,lr
80008bd8:	18 97       	mov	r7,r12
80008bda:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80008bdc:	78 e8       	ld.w	r8,r12[0x38]
80008bde:	58 08       	cp.w	r8,0
80008be0:	c0 31       	brne	80008be6 <xQueueReceiveFromISR+0x12>
80008be2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80008be6:	f0 1f 00 0e 	mcall	80008c1c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80008bea:	6e e8       	ld.w	r8,r7[0x38]
80008bec:	20 18       	sub	r8,1
80008bee:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80008bf0:	6f 18       	ld.w	r8,r7[0x44]
80008bf2:	5b f8       	cp.w	r8,-1
80008bf4:	c0 d1       	brne	80008c0e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80008bf6:	6e 48       	ld.w	r8,r7[0x10]
80008bf8:	58 08       	cp.w	r8,0
80008bfa:	c0 f0       	breq	80008c18 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80008bfc:	ee cc ff f0 	sub	r12,r7,-16
80008c00:	f0 1f 00 08 	mcall	80008c20 <xQueueReceiveFromISR+0x4c>
80008c04:	c0 a0       	breq	80008c18 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80008c06:	30 1c       	mov	r12,1
80008c08:	8d 0c       	st.w	r6[0x0],r12
80008c0a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80008c0e:	2f f8       	sub	r8,-1
80008c10:	ef 48 00 44 	st.w	r7[68],r8
80008c14:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80008c18:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80008c1c:	80 00       	ld.sh	r0,r0[0x0]
80008c1e:	8b a4       	st.w	r5[0x28],r4
80008c20:	80 00       	ld.sh	r0,r0[0x0]
80008c22:	92 34       	ld.sh	r4,r9[0x6]

80008c24 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80008c24:	eb cd 40 c0 	pushm	r6-r7,lr
80008c28:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80008c2a:	f0 1f 00 23 	mcall	80008cb4 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80008c2e:	6f 28       	ld.w	r8,r7[0x48]
80008c30:	58 08       	cp.w	r8,0
80008c32:	e0 8a 00 18 	brle	80008c62 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008c36:	6e 98       	ld.w	r8,r7[0x24]
80008c38:	58 08       	cp.w	r8,0
80008c3a:	c1 40       	breq	80008c62 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80008c3c:	ee c6 ff dc 	sub	r6,r7,-36
80008c40:	c0 48       	rjmp	80008c48 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008c42:	6e 98       	ld.w	r8,r7[0x24]
80008c44:	58 08       	cp.w	r8,0
80008c46:	c0 e0       	breq	80008c62 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80008c48:	0c 9c       	mov	r12,r6
80008c4a:	f0 1f 00 1c 	mcall	80008cb8 <prvUnlockQueue+0x94>
80008c4e:	c0 30       	breq	80008c54 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80008c50:	f0 1f 00 1b 	mcall	80008cbc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80008c54:	6f 28       	ld.w	r8,r7[0x48]
80008c56:	20 18       	sub	r8,1
80008c58:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80008c5c:	58 08       	cp.w	r8,0
80008c5e:	fe 99 ff f2 	brgt	80008c42 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80008c62:	3f f8       	mov	r8,-1
80008c64:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80008c68:	f0 1f 00 16 	mcall	80008cc0 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80008c6c:	f0 1f 00 12 	mcall	80008cb4 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80008c70:	6f 18       	ld.w	r8,r7[0x44]
80008c72:	58 08       	cp.w	r8,0
80008c74:	e0 8a 00 18 	brle	80008ca4 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80008c78:	6e 48       	ld.w	r8,r7[0x10]
80008c7a:	58 08       	cp.w	r8,0
80008c7c:	c1 40       	breq	80008ca4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80008c7e:	ee c6 ff f0 	sub	r6,r7,-16
80008c82:	c0 48       	rjmp	80008c8a <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80008c84:	6e 48       	ld.w	r8,r7[0x10]
80008c86:	58 08       	cp.w	r8,0
80008c88:	c0 e0       	breq	80008ca4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80008c8a:	0c 9c       	mov	r12,r6
80008c8c:	f0 1f 00 0b 	mcall	80008cb8 <prvUnlockQueue+0x94>
80008c90:	c0 30       	breq	80008c96 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80008c92:	f0 1f 00 0b 	mcall	80008cbc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80008c96:	6f 18       	ld.w	r8,r7[0x44]
80008c98:	20 18       	sub	r8,1
80008c9a:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80008c9e:	58 08       	cp.w	r8,0
80008ca0:	fe 99 ff f2 	brgt	80008c84 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80008ca4:	3f f8       	mov	r8,-1
80008ca6:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80008caa:	f0 1f 00 06 	mcall	80008cc0 <prvUnlockQueue+0x9c>
}
80008cae:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008cb2:	00 00       	add	r0,r0
80008cb4:	80 00       	ld.sh	r0,r0[0x0]
80008cb6:	89 10       	st.w	r4[0x4],r0
80008cb8:	80 00       	ld.sh	r0,r0[0x0]
80008cba:	92 34       	ld.sh	r4,r9[0x6]
80008cbc:	80 00       	ld.sh	r0,r0[0x0]
80008cbe:	91 40       	st.w	r8[0x10],r0
80008cc0:	80 00       	ld.sh	r0,r0[0x0]
80008cc2:	8a 1c       	ld.sh	r12,r5[0x2]

80008cc4 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80008cc4:	d4 31       	pushm	r0-r7,lr
80008cc6:	20 5d       	sub	sp,20
80008cc8:	18 97       	mov	r7,r12
80008cca:	50 0b       	stdsp	sp[0x0],r11
80008ccc:	50 2a       	stdsp	sp[0x8],r10
80008cce:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80008cd0:	f8 c2 ff dc 	sub	r2,r12,-36
80008cd4:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80008cd6:	fa c4 ff f4 	sub	r4,sp,-12
80008cda:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80008cdc:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80008cde:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80008ce2:	f0 1f 00 3e 	mcall	80008dd8 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80008ce6:	6e e8       	ld.w	r8,r7[0x38]
80008ce8:	58 08       	cp.w	r8,0
80008cea:	c2 a0       	breq	80008d3e <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80008cec:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80008cee:	40 0b       	lddsp	r11,sp[0x0]
80008cf0:	0e 9c       	mov	r12,r7
80008cf2:	f0 1f 00 3b 	mcall	80008ddc <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80008cf6:	40 18       	lddsp	r8,sp[0x4]
80008cf8:	58 08       	cp.w	r8,0
80008cfa:	c1 51       	brne	80008d24 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80008cfc:	6e e8       	ld.w	r8,r7[0x38]
80008cfe:	20 18       	sub	r8,1
80008d00:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80008d02:	6e 08       	ld.w	r8,r7[0x0]
80008d04:	58 08       	cp.w	r8,0
80008d06:	c0 41       	brne	80008d0e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80008d08:	f0 1f 00 36 	mcall	80008de0 <xQueueGenericReceive+0x11c>
80008d0c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80008d0e:	6e 48       	ld.w	r8,r7[0x10]
80008d10:	58 08       	cp.w	r8,0
80008d12:	c1 20       	breq	80008d36 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80008d14:	ee cc ff f0 	sub	r12,r7,-16
80008d18:	f0 1f 00 33 	mcall	80008de4 <xQueueGenericReceive+0x120>
80008d1c:	58 1c       	cp.w	r12,1
80008d1e:	c0 c1       	brne	80008d36 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80008d20:	d7 33       	scall
80008d22:	c0 a8       	rjmp	80008d36 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80008d24:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008d26:	6e 98       	ld.w	r8,r7[0x24]
80008d28:	58 08       	cp.w	r8,0
80008d2a:	c0 60       	breq	80008d36 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80008d2c:	04 9c       	mov	r12,r2
80008d2e:	f0 1f 00 2e 	mcall	80008de4 <xQueueGenericReceive+0x120>
80008d32:	c0 20       	breq	80008d36 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80008d34:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80008d36:	f0 1f 00 2d 	mcall	80008de8 <xQueueGenericReceive+0x124>
80008d3a:	30 1c       	mov	r12,1
				return pdPASS;
80008d3c:	c4 c8       	rjmp	80008dd4 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80008d3e:	40 28       	lddsp	r8,sp[0x8]
80008d40:	58 08       	cp.w	r8,0
80008d42:	c0 51       	brne	80008d4c <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80008d44:	f0 1f 00 29 	mcall	80008de8 <xQueueGenericReceive+0x124>
80008d48:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80008d4a:	c4 58       	rjmp	80008dd4 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80008d4c:	58 05       	cp.w	r5,0
80008d4e:	c0 51       	brne	80008d58 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80008d50:	08 9c       	mov	r12,r4
80008d52:	f0 1f 00 27 	mcall	80008dec <xQueueGenericReceive+0x128>
80008d56:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80008d58:	f0 1f 00 24 	mcall	80008de8 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80008d5c:	f0 1f 00 25 	mcall	80008df0 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80008d60:	f0 1f 00 1e 	mcall	80008dd8 <xQueueGenericReceive+0x114>
80008d64:	6f 18       	ld.w	r8,r7[0x44]
80008d66:	5b f8       	cp.w	r8,-1
80008d68:	ef f1 0a 11 	st.weq	r7[0x44],r1
80008d6c:	6f 28       	ld.w	r8,r7[0x48]
80008d6e:	5b f8       	cp.w	r8,-1
80008d70:	ef f1 0a 12 	st.weq	r7[0x48],r1
80008d74:	f0 1f 00 1d 	mcall	80008de8 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80008d78:	06 9b       	mov	r11,r3
80008d7a:	08 9c       	mov	r12,r4
80008d7c:	f0 1f 00 1e 	mcall	80008df4 <xQueueGenericReceive+0x130>
80008d80:	c2 41       	brne	80008dc8 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80008d82:	f0 1f 00 16 	mcall	80008dd8 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80008d86:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80008d88:	f0 1f 00 18 	mcall	80008de8 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80008d8c:	58 06       	cp.w	r6,0
80008d8e:	c1 71       	brne	80008dbc <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80008d90:	6e 08       	ld.w	r8,r7[0x0]
80008d92:	58 08       	cp.w	r8,0
80008d94:	c0 81       	brne	80008da4 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80008d96:	f0 1f 00 11 	mcall	80008dd8 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80008d9a:	6e 1c       	ld.w	r12,r7[0x4]
80008d9c:	f0 1f 00 17 	mcall	80008df8 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80008da0:	f0 1f 00 12 	mcall	80008de8 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80008da4:	40 2b       	lddsp	r11,sp[0x8]
80008da6:	04 9c       	mov	r12,r2
80008da8:	f0 1f 00 15 	mcall	80008dfc <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80008dac:	0e 9c       	mov	r12,r7
80008dae:	f0 1f 00 15 	mcall	80008e00 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80008db2:	f0 1f 00 15 	mcall	80008e04 <xQueueGenericReceive+0x140>
80008db6:	c9 61       	brne	80008ce2 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80008db8:	d7 33       	scall
80008dba:	c9 4b       	rjmp	80008ce2 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80008dbc:	0e 9c       	mov	r12,r7
80008dbe:	f0 1f 00 11 	mcall	80008e00 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80008dc2:	f0 1f 00 11 	mcall	80008e04 <xQueueGenericReceive+0x140>
80008dc6:	c8 eb       	rjmp	80008ce2 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80008dc8:	0e 9c       	mov	r12,r7
80008dca:	f0 1f 00 0e 	mcall	80008e00 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80008dce:	f0 1f 00 0e 	mcall	80008e04 <xQueueGenericReceive+0x140>
80008dd2:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80008dd4:	2f bd       	sub	sp,-20
80008dd6:	d8 32       	popm	r0-r7,pc
80008dd8:	80 00       	ld.sh	r0,r0[0x0]
80008dda:	89 10       	st.w	r4[0x4],r0
80008ddc:	80 00       	ld.sh	r0,r0[0x0]
80008dde:	8b a4       	st.w	r5[0x28],r4
80008de0:	80 00       	ld.sh	r0,r0[0x0]
80008de2:	91 4c       	st.w	r8[0x10],r12
80008de4:	80 00       	ld.sh	r0,r0[0x0]
80008de6:	92 34       	ld.sh	r4,r9[0x6]
80008de8:	80 00       	ld.sh	r0,r0[0x0]
80008dea:	8a 1c       	ld.sh	r12,r5[0x2]
80008dec:	80 00       	ld.sh	r0,r0[0x0]
80008dee:	91 28       	st.w	r8[0x8],r8
80008df0:	80 00       	ld.sh	r0,r0[0x0]
80008df2:	90 9c       	ld.uh	r12,r8[0x2]
80008df4:	80 00       	ld.sh	r0,r0[0x0]
80008df6:	93 c4       	st.w	r9[0x30],r4
80008df8:	80 00       	ld.sh	r0,r0[0x0]
80008dfa:	91 b0       	st.w	r8[0x2c],r0
80008dfc:	80 00       	ld.sh	r0,r0[0x0]
80008dfe:	96 1c       	ld.sh	r12,r11[0x2]
80008e00:	80 00       	ld.sh	r0,r0[0x0]
80008e02:	8c 24       	ld.sh	r4,r6[0x4]
80008e04:	80 00       	ld.sh	r0,r0[0x0]
80008e06:	94 58       	ld.sh	r8,r10[0xa]

80008e08 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80008e08:	eb cd 40 80 	pushm	r7,lr
80008e0c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80008e0e:	79 08       	ld.w	r8,r12[0x40]
80008e10:	58 08       	cp.w	r8,0
80008e12:	c0 a1       	brne	80008e26 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80008e14:	78 08       	ld.w	r8,r12[0x0]
80008e16:	58 08       	cp.w	r8,0
80008e18:	c2 b1       	brne	80008e6e <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80008e1a:	78 1c       	ld.w	r12,r12[0x4]
80008e1c:	f0 1f 00 17 	mcall	80008e78 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80008e20:	30 08       	mov	r8,0
80008e22:	8f 18       	st.w	r7[0x4],r8
80008e24:	c2 58       	rjmp	80008e6e <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80008e26:	58 0a       	cp.w	r10,0
80008e28:	c1 01       	brne	80008e48 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80008e2a:	10 9a       	mov	r10,r8
80008e2c:	78 2c       	ld.w	r12,r12[0x8]
80008e2e:	f0 1f 00 14 	mcall	80008e7c <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80008e32:	6e 29       	ld.w	r9,r7[0x8]
80008e34:	6f 08       	ld.w	r8,r7[0x40]
80008e36:	f2 08 00 08 	add	r8,r9,r8
80008e3a:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80008e3c:	6e 19       	ld.w	r9,r7[0x4]
80008e3e:	12 38       	cp.w	r8,r9
80008e40:	c1 73       	brcs	80008e6e <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80008e42:	6e 08       	ld.w	r8,r7[0x0]
80008e44:	8f 28       	st.w	r7[0x8],r8
80008e46:	c1 48       	rjmp	80008e6e <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80008e48:	10 9a       	mov	r10,r8
80008e4a:	78 3c       	ld.w	r12,r12[0xc]
80008e4c:	f0 1f 00 0c 	mcall	80008e7c <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80008e50:	6f 08       	ld.w	r8,r7[0x40]
80008e52:	6e 39       	ld.w	r9,r7[0xc]
80008e54:	f2 08 01 08 	sub	r8,r9,r8
80008e58:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80008e5a:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80008e5c:	12 38       	cp.w	r8,r9
80008e5e:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80008e62:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80008e66:	f3 d8 e3 19 	subcs	r9,r9,r8
80008e6a:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80008e6e:	6e e8       	ld.w	r8,r7[0x38]
80008e70:	2f f8       	sub	r8,-1
80008e72:	8f e8       	st.w	r7[0x38],r8
}
80008e74:	e3 cd 80 80 	ldm	sp++,r7,pc
80008e78:	80 00       	ld.sh	r0,r0[0x0]
80008e7a:	91 58       	st.w	r8[0x14],r8
80008e7c:	80 00       	ld.sh	r0,r0[0x0]
80008e7e:	a4 86       	st.b	r2[0x0],r6

80008e80 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80008e80:	eb cd 40 c0 	pushm	r6-r7,lr
80008e84:	18 97       	mov	r7,r12
80008e86:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80008e88:	78 ec       	ld.w	r12,r12[0x38]
80008e8a:	6e f8       	ld.w	r8,r7[0x3c]
80008e8c:	10 3c       	cp.w	r12,r8
80008e8e:	c0 33       	brcs	80008e94 <xQueueGenericSendFromISR+0x14>
80008e90:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80008e94:	12 9a       	mov	r10,r9
80008e96:	0e 9c       	mov	r12,r7
80008e98:	f0 1f 00 0c 	mcall	80008ec8 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80008e9c:	6f 28       	ld.w	r8,r7[0x48]
80008e9e:	5b f8       	cp.w	r8,-1
80008ea0:	c0 d1       	brne	80008eba <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008ea2:	6e 98       	ld.w	r8,r7[0x24]
80008ea4:	58 08       	cp.w	r8,0
80008ea6:	c0 f0       	breq	80008ec4 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80008ea8:	ee cc ff dc 	sub	r12,r7,-36
80008eac:	f0 1f 00 08 	mcall	80008ecc <xQueueGenericSendFromISR+0x4c>
80008eb0:	c0 a0       	breq	80008ec4 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80008eb2:	30 1c       	mov	r12,1
80008eb4:	8d 0c       	st.w	r6[0x0],r12
80008eb6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80008eba:	2f f8       	sub	r8,-1
80008ebc:	ef 48 00 48 	st.w	r7[72],r8
80008ec0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80008ec4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80008ec8:	80 00       	ld.sh	r0,r0[0x0]
80008eca:	8e 08       	ld.sh	r8,r7[0x0]
80008ecc:	80 00       	ld.sh	r0,r0[0x0]
80008ece:	92 34       	ld.sh	r4,r9[0x6]

80008ed0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80008ed0:	d4 31       	pushm	r0-r7,lr
80008ed2:	20 5d       	sub	sp,20
80008ed4:	18 97       	mov	r7,r12
80008ed6:	50 0b       	stdsp	sp[0x0],r11
80008ed8:	50 2a       	stdsp	sp[0x8],r10
80008eda:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80008edc:	f8 c0 ff f0 	sub	r0,r12,-16
80008ee0:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80008ee2:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80008ee6:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80008ee8:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80008eec:	f0 1f 00 2f 	mcall	80008fa8 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80008ef0:	6e e9       	ld.w	r9,r7[0x38]
80008ef2:	6e f8       	ld.w	r8,r7[0x3c]
80008ef4:	10 39       	cp.w	r9,r8
80008ef6:	c1 42       	brcc	80008f1e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80008ef8:	40 1a       	lddsp	r10,sp[0x4]
80008efa:	40 0b       	lddsp	r11,sp[0x0]
80008efc:	0e 9c       	mov	r12,r7
80008efe:	f0 1f 00 2c 	mcall	80008fac <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008f02:	6e 98       	ld.w	r8,r7[0x24]
80008f04:	58 08       	cp.w	r8,0
80008f06:	c0 80       	breq	80008f16 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80008f08:	ee cc ff dc 	sub	r12,r7,-36
80008f0c:	f0 1f 00 29 	mcall	80008fb0 <xQueueGenericSend+0xe0>
80008f10:	58 1c       	cp.w	r12,1
80008f12:	c0 21       	brne	80008f16 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80008f14:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80008f16:	f0 1f 00 28 	mcall	80008fb4 <xQueueGenericSend+0xe4>
80008f1a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80008f1c:	c4 38       	rjmp	80008fa2 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80008f1e:	40 28       	lddsp	r8,sp[0x8]
80008f20:	58 08       	cp.w	r8,0
80008f22:	c0 51       	brne	80008f2c <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80008f24:	f0 1f 00 24 	mcall	80008fb4 <xQueueGenericSend+0xe4>
80008f28:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80008f2a:	c3 c8       	rjmp	80008fa2 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80008f2c:	58 04       	cp.w	r4,0
80008f2e:	c0 51       	brne	80008f38 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80008f30:	06 9c       	mov	r12,r3
80008f32:	f0 1f 00 22 	mcall	80008fb8 <xQueueGenericSend+0xe8>
80008f36:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80008f38:	f0 1f 00 1f 	mcall	80008fb4 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80008f3c:	f0 1f 00 20 	mcall	80008fbc <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80008f40:	f0 1f 00 1a 	mcall	80008fa8 <xQueueGenericSend+0xd8>
80008f44:	6f 18       	ld.w	r8,r7[0x44]
80008f46:	5b f8       	cp.w	r8,-1
80008f48:	ef f1 0a 11 	st.weq	r7[0x44],r1
80008f4c:	6f 28       	ld.w	r8,r7[0x48]
80008f4e:	5b f8       	cp.w	r8,-1
80008f50:	ef f1 0a 12 	st.weq	r7[0x48],r1
80008f54:	f0 1f 00 18 	mcall	80008fb4 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80008f58:	04 9b       	mov	r11,r2
80008f5a:	06 9c       	mov	r12,r3
80008f5c:	f0 1f 00 19 	mcall	80008fc0 <xQueueGenericSend+0xf0>
80008f60:	c1 b1       	brne	80008f96 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80008f62:	f0 1f 00 12 	mcall	80008fa8 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80008f66:	6e e5       	ld.w	r5,r7[0x38]
80008f68:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80008f6a:	f0 1f 00 13 	mcall	80008fb4 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80008f6e:	0c 35       	cp.w	r5,r6
80008f70:	c0 d1       	brne	80008f8a <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80008f72:	40 2b       	lddsp	r11,sp[0x8]
80008f74:	00 9c       	mov	r12,r0
80008f76:	f0 1f 00 14 	mcall	80008fc4 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80008f7a:	0e 9c       	mov	r12,r7
80008f7c:	f0 1f 00 13 	mcall	80008fc8 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80008f80:	f0 1f 00 13 	mcall	80008fcc <xQueueGenericSend+0xfc>
80008f84:	cb 41       	brne	80008eec <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80008f86:	d7 33       	scall
80008f88:	cb 2b       	rjmp	80008eec <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80008f8a:	0e 9c       	mov	r12,r7
80008f8c:	f0 1f 00 0f 	mcall	80008fc8 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80008f90:	f0 1f 00 0f 	mcall	80008fcc <xQueueGenericSend+0xfc>
80008f94:	ca cb       	rjmp	80008eec <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80008f96:	0e 9c       	mov	r12,r7
80008f98:	f0 1f 00 0c 	mcall	80008fc8 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80008f9c:	f0 1f 00 0c 	mcall	80008fcc <xQueueGenericSend+0xfc>
80008fa0:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80008fa2:	2f bd       	sub	sp,-20
80008fa4:	d8 32       	popm	r0-r7,pc
80008fa6:	00 00       	add	r0,r0
80008fa8:	80 00       	ld.sh	r0,r0[0x0]
80008faa:	89 10       	st.w	r4[0x4],r0
80008fac:	80 00       	ld.sh	r0,r0[0x0]
80008fae:	8e 08       	ld.sh	r8,r7[0x0]
80008fb0:	80 00       	ld.sh	r0,r0[0x0]
80008fb2:	92 34       	ld.sh	r4,r9[0x6]
80008fb4:	80 00       	ld.sh	r0,r0[0x0]
80008fb6:	8a 1c       	ld.sh	r12,r5[0x2]
80008fb8:	80 00       	ld.sh	r0,r0[0x0]
80008fba:	91 28       	st.w	r8[0x8],r8
80008fbc:	80 00       	ld.sh	r0,r0[0x0]
80008fbe:	90 9c       	ld.uh	r12,r8[0x2]
80008fc0:	80 00       	ld.sh	r0,r0[0x0]
80008fc2:	93 c4       	st.w	r9[0x30],r4
80008fc4:	80 00       	ld.sh	r0,r0[0x0]
80008fc6:	96 1c       	ld.sh	r12,r11[0x2]
80008fc8:	80 00       	ld.sh	r0,r0[0x0]
80008fca:	8c 24       	ld.sh	r4,r6[0x4]
80008fcc:	80 00       	ld.sh	r0,r0[0x0]
80008fce:	94 58       	ld.sh	r8,r10[0xa]

80008fd0 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80008fd0:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80008fd4:	34 cc       	mov	r12,76
80008fd6:	f0 1f 00 12 	mcall	8000901c <xQueueCreateMutex+0x4c>
80008fda:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80008fdc:	c1 d0       	breq	80009016 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80008fde:	30 06       	mov	r6,0
80008fe0:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80008fe2:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80008fe4:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80008fe6:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80008fe8:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
80008fea:	30 18       	mov	r8,1
80008fec:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
80008fee:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80008ff2:	3f f8       	mov	r8,-1
80008ff4:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80008ff8:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80008ffc:	2f 0c       	sub	r12,-16
80008ffe:	f0 1f 00 09 	mcall	80009020 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80009002:	ee cc ff dc 	sub	r12,r7,-36
80009006:	f0 1f 00 07 	mcall	80009020 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
8000900a:	0c 99       	mov	r9,r6
8000900c:	0c 9a       	mov	r10,r6
8000900e:	0c 9b       	mov	r11,r6
80009010:	0e 9c       	mov	r12,r7
80009012:	f0 1f 00 05 	mcall	80009024 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80009016:	0e 9c       	mov	r12,r7
80009018:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000901c:	80 00       	ld.sh	r0,r0[0x0]
8000901e:	8b 7c       	st.w	r5[0x1c],r12
80009020:	80 00       	ld.sh	r0,r0[0x0]
80009022:	87 ec       	st.w	r3[0x38],r12
80009024:	80 00       	ld.sh	r0,r0[0x0]
80009026:	8e d0       	ld.uh	r0,r7[0xa]

80009028 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80009028:	d4 21       	pushm	r4-r7,lr
8000902a:	18 97       	mov	r7,r12
8000902c:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000902e:	58 0c       	cp.w	r12,0
80009030:	c2 f0       	breq	8000908e <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80009032:	34 cc       	mov	r12,76
80009034:	f0 1f 00 17 	mcall	80009090 <xQueueCreate+0x68>
80009038:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000903a:	c2 a0       	breq	8000908e <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000903c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80009040:	e8 cc ff ff 	sub	r12,r4,-1
80009044:	f0 1f 00 13 	mcall	80009090 <xQueueCreate+0x68>
80009048:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000904a:	c1 e0       	breq	80009086 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000904c:	f8 04 00 04 	add	r4,r12,r4
80009050:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80009052:	30 08       	mov	r8,0
80009054:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80009056:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80009058:	ee c8 00 01 	sub	r8,r7,1
8000905c:	ad 38       	mul	r8,r6
8000905e:	10 0c       	add	r12,r8
80009060:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80009062:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80009064:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80009068:	3f f8       	mov	r8,-1
8000906a:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000906e:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80009072:	ea cc ff f0 	sub	r12,r5,-16
80009076:	f0 1f 00 08 	mcall	80009094 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000907a:	ea cc ff dc 	sub	r12,r5,-36
8000907e:	f0 1f 00 06 	mcall	80009094 <xQueueCreate+0x6c>
80009082:	0a 9c       	mov	r12,r5
80009084:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80009086:	0a 9c       	mov	r12,r5
80009088:	f0 1f 00 04 	mcall	80009098 <xQueueCreate+0x70>
8000908c:	d8 2a       	popm	r4-r7,pc,r12=0
8000908e:	d8 2a       	popm	r4-r7,pc,r12=0
80009090:	80 00       	ld.sh	r0,r0[0x0]
80009092:	8b 7c       	st.w	r5[0x1c],r12
80009094:	80 00       	ld.sh	r0,r0[0x0]
80009096:	87 ec       	st.w	r3[0x38],r12
80009098:	80 00       	ld.sh	r0,r0[0x0]
8000909a:	8b 54       	st.w	r5[0x14],r4

8000909c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
8000909c:	48 38       	lddpc	r8,800090a8 <vTaskSuspendAll+0xc>
8000909e:	70 09       	ld.w	r9,r8[0x0]
800090a0:	2f f9       	sub	r9,-1
800090a2:	91 09       	st.w	r8[0x0],r9
}
800090a4:	5e fc       	retal	r12
800090a6:	00 00       	add	r0,r0
800090a8:	00 00       	add	r0,r0
800090aa:	12 54       	eor	r4,r9

800090ac <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800090ac:	49 a8       	lddpc	r8,80009114 <vTaskSwitchContext+0x68>
800090ae:	70 08       	ld.w	r8,r8[0x0]
800090b0:	58 08       	cp.w	r8,0
800090b2:	c0 b1       	brne	800090c8 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800090b4:	49 98       	lddpc	r8,80009118 <vTaskSwitchContext+0x6c>
800090b6:	70 08       	ld.w	r8,r8[0x0]
800090b8:	f0 08 00 28 	add	r8,r8,r8<<0x2
800090bc:	49 89       	lddpc	r9,8000911c <vTaskSwitchContext+0x70>
800090be:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800090c2:	58 08       	cp.w	r8,0
800090c4:	c0 60       	breq	800090d0 <vTaskSwitchContext+0x24>
800090c6:	c1 18       	rjmp	800090e8 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800090c8:	30 19       	mov	r9,1
800090ca:	49 68       	lddpc	r8,80009120 <vTaskSwitchContext+0x74>
800090cc:	91 09       	st.w	r8[0x0],r9
800090ce:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800090d0:	49 28       	lddpc	r8,80009118 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800090d2:	49 3a       	lddpc	r10,8000911c <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800090d4:	70 09       	ld.w	r9,r8[0x0]
800090d6:	20 19       	sub	r9,1
800090d8:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800090da:	70 09       	ld.w	r9,r8[0x0]
800090dc:	f2 09 00 29 	add	r9,r9,r9<<0x2
800090e0:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800090e4:	58 09       	cp.w	r9,0
800090e6:	cf 70       	breq	800090d4 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800090e8:	48 c8       	lddpc	r8,80009118 <vTaskSwitchContext+0x6c>
800090ea:	70 08       	ld.w	r8,r8[0x0]
800090ec:	f0 08 00 28 	add	r8,r8,r8<<0x2
800090f0:	48 b9       	lddpc	r9,8000911c <vTaskSwitchContext+0x70>
800090f2:	f2 08 00 28 	add	r8,r9,r8<<0x2
800090f6:	70 19       	ld.w	r9,r8[0x4]
800090f8:	72 19       	ld.w	r9,r9[0x4]
800090fa:	91 19       	st.w	r8[0x4],r9
800090fc:	f0 ca ff f8 	sub	r10,r8,-8
80009100:	14 39       	cp.w	r9,r10
80009102:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80009106:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000910a:	70 18       	ld.w	r8,r8[0x4]
8000910c:	70 39       	ld.w	r9,r8[0xc]
8000910e:	48 68       	lddpc	r8,80009124 <vTaskSwitchContext+0x78>
80009110:	91 09       	st.w	r8[0x0],r9
80009112:	5e fc       	retal	r12
80009114:	00 00       	add	r0,r0
80009116:	12 54       	eor	r4,r9
80009118:	00 00       	add	r0,r0
8000911a:	12 8c       	andn	r12,r9
8000911c:	00 00       	add	r0,r0
8000911e:	11 70       	ld.ub	r0,--r8
80009120:	00 00       	add	r0,r0
80009122:	12 74       	tst	r4,r9
80009124:	00 00       	add	r0,r0
80009126:	12 24       	rsub	r4,r9

80009128 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80009128:	48 48       	lddpc	r8,80009138 <vTaskSetTimeOutState+0x10>
8000912a:	70 08       	ld.w	r8,r8[0x0]
8000912c:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000912e:	48 48       	lddpc	r8,8000913c <vTaskSetTimeOutState+0x14>
80009130:	70 08       	ld.w	r8,r8[0x0]
80009132:	99 18       	st.w	r12[0x4],r8
}
80009134:	5e fc       	retal	r12
80009136:	00 00       	add	r0,r0
80009138:	00 00       	add	r0,r0
8000913a:	11 68       	ld.uh	r8,--r8
8000913c:	00 00       	add	r0,r0
8000913e:	12 50       	eor	r0,r9

80009140 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80009140:	30 19       	mov	r9,1
80009142:	48 28       	lddpc	r8,80009148 <vTaskMissedYield+0x8>
80009144:	91 09       	st.w	r8[0x0],r9
}
80009146:	5e fc       	retal	r12
80009148:	00 00       	add	r0,r0
8000914a:	12 74       	tst	r4,r9

8000914c <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
8000914c:	48 28       	lddpc	r8,80009154 <xTaskGetCurrentTaskHandle+0x8>
8000914e:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80009150:	5e fc       	retal	r12
80009152:	00 00       	add	r0,r0
80009154:	00 00       	add	r0,r0
80009156:	12 24       	rsub	r4,r9

80009158 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80009158:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
8000915c:	58 0c       	cp.w	r12,0
8000915e:	c1 f0       	breq	8000919c <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80009160:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80009162:	78 b9       	ld.w	r9,r12[0x2c]
80009164:	79 18       	ld.w	r8,r12[0x44]
80009166:	10 39       	cp.w	r9,r8
80009168:	c1 a0       	breq	8000919c <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000916a:	f8 c6 ff fc 	sub	r6,r12,-4
8000916e:	0c 9c       	mov	r12,r6
80009170:	f0 1f 00 0c 	mcall	800091a0 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80009174:	6f 1c       	ld.w	r12,r7[0x44]
80009176:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80009178:	f8 08 11 08 	rsub	r8,r12,8
8000917c:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000917e:	48 a8       	lddpc	r8,800091a4 <vTaskPriorityDisinherit+0x4c>
80009180:	70 08       	ld.w	r8,r8[0x0]
80009182:	10 3c       	cp.w	r12,r8
80009184:	e0 88 00 04 	brls	8000918c <vTaskPriorityDisinherit+0x34>
80009188:	48 78       	lddpc	r8,800091a4 <vTaskPriorityDisinherit+0x4c>
8000918a:	91 0c       	st.w	r8[0x0],r12
8000918c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009190:	0c 9b       	mov	r11,r6
80009192:	48 68       	lddpc	r8,800091a8 <vTaskPriorityDisinherit+0x50>
80009194:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80009198:	f0 1f 00 05 	mcall	800091ac <vTaskPriorityDisinherit+0x54>
8000919c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800091a0:	80 00       	ld.sh	r0,r0[0x0]
800091a2:	88 56       	ld.sh	r6,r4[0xa]
800091a4:	00 00       	add	r0,r0
800091a6:	12 8c       	andn	r12,r9
800091a8:	00 00       	add	r0,r0
800091aa:	11 70       	ld.ub	r0,--r8
800091ac:	80 00       	ld.sh	r0,r0[0x0]
800091ae:	88 06       	ld.sh	r6,r4[0x0]

800091b0 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800091b0:	eb cd 40 c0 	pushm	r6-r7,lr
800091b4:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800091b6:	49 b8       	lddpc	r8,80009220 <vTaskPriorityInherit+0x70>
800091b8:	70 08       	ld.w	r8,r8[0x0]
800091ba:	78 b9       	ld.w	r9,r12[0x2c]
800091bc:	70 b8       	ld.w	r8,r8[0x2c]
800091be:	10 39       	cp.w	r9,r8
800091c0:	c2 d2       	brcc	8000921a <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800091c2:	49 88       	lddpc	r8,80009220 <vTaskPriorityInherit+0x70>
800091c4:	70 08       	ld.w	r8,r8[0x0]
800091c6:	70 b8       	ld.w	r8,r8[0x2c]
800091c8:	f0 08 11 08 	rsub	r8,r8,8
800091cc:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800091ce:	f2 09 00 28 	add	r8,r9,r9<<0x2
800091d2:	49 59       	lddpc	r9,80009224 <vTaskPriorityInherit+0x74>
800091d4:	f2 08 00 28 	add	r8,r9,r8<<0x2
800091d8:	78 59       	ld.w	r9,r12[0x14]
800091da:	10 39       	cp.w	r9,r8
800091dc:	c1 b1       	brne	80009212 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800091de:	f8 c6 ff fc 	sub	r6,r12,-4
800091e2:	0c 9c       	mov	r12,r6
800091e4:	f0 1f 00 11 	mcall	80009228 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800091e8:	48 e8       	lddpc	r8,80009220 <vTaskPriorityInherit+0x70>
800091ea:	70 08       	ld.w	r8,r8[0x0]
800091ec:	70 bc       	ld.w	r12,r8[0x2c]
800091ee:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800091f0:	48 f8       	lddpc	r8,8000922c <vTaskPriorityInherit+0x7c>
800091f2:	70 08       	ld.w	r8,r8[0x0]
800091f4:	10 3c       	cp.w	r12,r8
800091f6:	e0 88 00 04 	brls	800091fe <vTaskPriorityInherit+0x4e>
800091fa:	48 d8       	lddpc	r8,8000922c <vTaskPriorityInherit+0x7c>
800091fc:	91 0c       	st.w	r8[0x0],r12
800091fe:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009202:	0c 9b       	mov	r11,r6
80009204:	48 88       	lddpc	r8,80009224 <vTaskPriorityInherit+0x74>
80009206:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000920a:	f0 1f 00 0a 	mcall	80009230 <vTaskPriorityInherit+0x80>
8000920e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80009212:	48 48       	lddpc	r8,80009220 <vTaskPriorityInherit+0x70>
80009214:	70 08       	ld.w	r8,r8[0x0]
80009216:	70 b8       	ld.w	r8,r8[0x2c]
80009218:	99 b8       	st.w	r12[0x2c],r8
8000921a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000921e:	00 00       	add	r0,r0
80009220:	00 00       	add	r0,r0
80009222:	12 24       	rsub	r4,r9
80009224:	00 00       	add	r0,r0
80009226:	11 70       	ld.ub	r0,--r8
80009228:	80 00       	ld.sh	r0,r0[0x0]
8000922a:	88 56       	ld.sh	r6,r4[0xa]
8000922c:	00 00       	add	r0,r0
8000922e:	12 8c       	andn	r12,r9
80009230:	80 00       	ld.sh	r0,r0[0x0]
80009232:	88 06       	ld.sh	r6,r4[0x0]

80009234 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80009234:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80009238:	78 38       	ld.w	r8,r12[0xc]
8000923a:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
8000923c:	ee c6 ff e8 	sub	r6,r7,-24
80009240:	0c 9c       	mov	r12,r6
80009242:	f0 1f 00 15 	mcall	80009294 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80009246:	49 58       	lddpc	r8,80009298 <xTaskRemoveFromEventList+0x64>
80009248:	70 08       	ld.w	r8,r8[0x0]
8000924a:	58 08       	cp.w	r8,0
8000924c:	c1 71       	brne	8000927a <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000924e:	ee c6 ff fc 	sub	r6,r7,-4
80009252:	0c 9c       	mov	r12,r6
80009254:	f0 1f 00 10 	mcall	80009294 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80009258:	6e bc       	ld.w	r12,r7[0x2c]
8000925a:	49 18       	lddpc	r8,8000929c <xTaskRemoveFromEventList+0x68>
8000925c:	70 08       	ld.w	r8,r8[0x0]
8000925e:	10 3c       	cp.w	r12,r8
80009260:	e0 88 00 04 	brls	80009268 <xTaskRemoveFromEventList+0x34>
80009264:	48 e8       	lddpc	r8,8000929c <xTaskRemoveFromEventList+0x68>
80009266:	91 0c       	st.w	r8[0x0],r12
80009268:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000926c:	0c 9b       	mov	r11,r6
8000926e:	48 d8       	lddpc	r8,800092a0 <xTaskRemoveFromEventList+0x6c>
80009270:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80009274:	f0 1f 00 0c 	mcall	800092a4 <xTaskRemoveFromEventList+0x70>
80009278:	c0 58       	rjmp	80009282 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000927a:	0c 9b       	mov	r11,r6
8000927c:	48 bc       	lddpc	r12,800092a8 <xTaskRemoveFromEventList+0x74>
8000927e:	f0 1f 00 0a 	mcall	800092a4 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80009282:	48 b8       	lddpc	r8,800092ac <xTaskRemoveFromEventList+0x78>
80009284:	70 08       	ld.w	r8,r8[0x0]
80009286:	6e b9       	ld.w	r9,r7[0x2c]
80009288:	70 b8       	ld.w	r8,r8[0x2c]
8000928a:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
8000928c:	5f 2c       	srhs	r12
8000928e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009292:	00 00       	add	r0,r0
80009294:	80 00       	ld.sh	r0,r0[0x0]
80009296:	88 56       	ld.sh	r6,r4[0xa]
80009298:	00 00       	add	r0,r0
8000929a:	12 54       	eor	r4,r9
8000929c:	00 00       	add	r0,r0
8000929e:	12 8c       	andn	r12,r9
800092a0:	00 00       	add	r0,r0
800092a2:	11 70       	ld.ub	r0,--r8
800092a4:	80 00       	ld.sh	r0,r0[0x0]
800092a6:	88 06       	ld.sh	r6,r4[0x0]
800092a8:	00 00       	add	r0,r0
800092aa:	12 28       	rsub	r8,r9
800092ac:	00 00       	add	r0,r0
800092ae:	12 24       	rsub	r4,r9

800092b0 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800092b0:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800092b4:	4b 98       	lddpc	r8,80009398 <vTaskIncrementTick+0xe8>
800092b6:	70 08       	ld.w	r8,r8[0x0]
800092b8:	58 08       	cp.w	r8,0
800092ba:	c6 91       	brne	8000938c <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800092bc:	4b 88       	lddpc	r8,8000939c <vTaskIncrementTick+0xec>
800092be:	70 09       	ld.w	r9,r8[0x0]
800092c0:	2f f9       	sub	r9,-1
800092c2:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800092c4:	70 08       	ld.w	r8,r8[0x0]
800092c6:	58 08       	cp.w	r8,0
800092c8:	c1 a1       	brne	800092fc <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800092ca:	4b 68       	lddpc	r8,800093a0 <vTaskIncrementTick+0xf0>
800092cc:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800092ce:	4b 69       	lddpc	r9,800093a4 <vTaskIncrementTick+0xf4>
800092d0:	72 0b       	ld.w	r11,r9[0x0]
800092d2:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800092d4:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800092d6:	4b 59       	lddpc	r9,800093a8 <vTaskIncrementTick+0xf8>
800092d8:	72 0a       	ld.w	r10,r9[0x0]
800092da:	2f fa       	sub	r10,-1
800092dc:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800092de:	70 08       	ld.w	r8,r8[0x0]
800092e0:	70 08       	ld.w	r8,r8[0x0]
800092e2:	58 08       	cp.w	r8,0
800092e4:	c0 51       	brne	800092ee <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800092e6:	3f f9       	mov	r9,-1
800092e8:	4b 18       	lddpc	r8,800093ac <vTaskIncrementTick+0xfc>
800092ea:	91 09       	st.w	r8[0x0],r9
800092ec:	c0 88       	rjmp	800092fc <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800092ee:	4a d8       	lddpc	r8,800093a0 <vTaskIncrementTick+0xf0>
800092f0:	70 08       	ld.w	r8,r8[0x0]
800092f2:	70 38       	ld.w	r8,r8[0xc]
800092f4:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800092f6:	70 19       	ld.w	r9,r8[0x4]
800092f8:	4a d8       	lddpc	r8,800093ac <vTaskIncrementTick+0xfc>
800092fa:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800092fc:	4a 88       	lddpc	r8,8000939c <vTaskIncrementTick+0xec>
800092fe:	70 09       	ld.w	r9,r8[0x0]
80009300:	4a b8       	lddpc	r8,800093ac <vTaskIncrementTick+0xfc>
80009302:	70 08       	ld.w	r8,r8[0x0]
80009304:	10 39       	cp.w	r9,r8
80009306:	c4 73       	brcs	80009394 <vTaskIncrementTick+0xe4>
80009308:	4a 68       	lddpc	r8,800093a0 <vTaskIncrementTick+0xf0>
8000930a:	70 08       	ld.w	r8,r8[0x0]
8000930c:	70 08       	ld.w	r8,r8[0x0]
8000930e:	58 08       	cp.w	r8,0
80009310:	c0 c0       	breq	80009328 <vTaskIncrementTick+0x78>
80009312:	4a 48       	lddpc	r8,800093a0 <vTaskIncrementTick+0xf0>
80009314:	70 08       	ld.w	r8,r8[0x0]
80009316:	70 38       	ld.w	r8,r8[0xc]
80009318:	70 37       	ld.w	r7,r8[0xc]
8000931a:	6e 18       	ld.w	r8,r7[0x4]
8000931c:	4a 09       	lddpc	r9,8000939c <vTaskIncrementTick+0xec>
8000931e:	72 09       	ld.w	r9,r9[0x0]
80009320:	12 38       	cp.w	r8,r9
80009322:	e0 88 00 14 	brls	8000934a <vTaskIncrementTick+0x9a>
80009326:	c0 e8       	rjmp	80009342 <vTaskIncrementTick+0x92>
80009328:	3f f9       	mov	r9,-1
8000932a:	4a 18       	lddpc	r8,800093ac <vTaskIncrementTick+0xfc>
8000932c:	91 09       	st.w	r8[0x0],r9
8000932e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80009332:	6a 08       	ld.w	r8,r5[0x0]
80009334:	70 38       	ld.w	r8,r8[0xc]
80009336:	70 37       	ld.w	r7,r8[0xc]
80009338:	6e 18       	ld.w	r8,r7[0x4]
8000933a:	64 09       	ld.w	r9,r2[0x0]
8000933c:	12 38       	cp.w	r8,r9
8000933e:	e0 88 00 0a 	brls	80009352 <vTaskIncrementTick+0xa2>
80009342:	49 b9       	lddpc	r9,800093ac <vTaskIncrementTick+0xfc>
80009344:	93 08       	st.w	r9[0x0],r8
80009346:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000934a:	49 a4       	lddpc	r4,800093b0 <vTaskIncrementTick+0x100>
8000934c:	49 a3       	lddpc	r3,800093b4 <vTaskIncrementTick+0x104>
8000934e:	49 55       	lddpc	r5,800093a0 <vTaskIncrementTick+0xf0>
80009350:	49 32       	lddpc	r2,8000939c <vTaskIncrementTick+0xec>
80009352:	ee c6 ff fc 	sub	r6,r7,-4
80009356:	0c 9c       	mov	r12,r6
80009358:	f0 1f 00 18 	mcall	800093b8 <vTaskIncrementTick+0x108>
8000935c:	6e a8       	ld.w	r8,r7[0x28]
8000935e:	58 08       	cp.w	r8,0
80009360:	c0 50       	breq	8000936a <vTaskIncrementTick+0xba>
80009362:	ee cc ff e8 	sub	r12,r7,-24
80009366:	f0 1f 00 15 	mcall	800093b8 <vTaskIncrementTick+0x108>
8000936a:	6e bc       	ld.w	r12,r7[0x2c]
8000936c:	68 08       	ld.w	r8,r4[0x0]
8000936e:	10 3c       	cp.w	r12,r8
80009370:	e9 fc ba 00 	st.whi	r4[0x0],r12
80009374:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009378:	0c 9b       	mov	r11,r6
8000937a:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000937e:	f0 1f 00 10 	mcall	800093bc <vTaskIncrementTick+0x10c>
80009382:	6a 08       	ld.w	r8,r5[0x0]
80009384:	70 08       	ld.w	r8,r8[0x0]
80009386:	58 08       	cp.w	r8,0
80009388:	cd 51       	brne	80009332 <vTaskIncrementTick+0x82>
8000938a:	cc fb       	rjmp	80009328 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
8000938c:	48 d8       	lddpc	r8,800093c0 <vTaskIncrementTick+0x110>
8000938e:	70 09       	ld.w	r9,r8[0x0]
80009390:	2f f9       	sub	r9,-1
80009392:	91 09       	st.w	r8[0x0],r9
80009394:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80009398:	00 00       	add	r0,r0
8000939a:	12 54       	eor	r4,r9
8000939c:	00 00       	add	r0,r0
8000939e:	12 50       	eor	r0,r9
800093a0:	00 00       	add	r0,r0
800093a2:	11 5c       	ld.sh	r12,--r8
800093a4:	00 00       	add	r0,r0
800093a6:	11 6c       	ld.uh	r12,--r8
800093a8:	00 00       	add	r0,r0
800093aa:	11 68       	ld.uh	r8,--r8
800093ac:	00 00       	add	r0,r0
800093ae:	05 34       	ld.ub	r4,r2++
800093b0:	00 00       	add	r0,r0
800093b2:	12 8c       	andn	r12,r9
800093b4:	00 00       	add	r0,r0
800093b6:	11 70       	ld.ub	r0,--r8
800093b8:	80 00       	ld.sh	r0,r0[0x0]
800093ba:	88 56       	ld.sh	r6,r4[0xa]
800093bc:	80 00       	ld.sh	r0,r0[0x0]
800093be:	88 06       	ld.sh	r6,r4[0x0]
800093c0:	00 00       	add	r0,r0
800093c2:	11 54       	ld.sh	r4,--r8

800093c4 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800093c4:	eb cd 40 c0 	pushm	r6-r7,lr
800093c8:	18 97       	mov	r7,r12
800093ca:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800093cc:	f0 1f 00 15 	mcall	80009420 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800093d0:	6c 08       	ld.w	r8,r6[0x0]
800093d2:	5b f8       	cp.w	r8,-1
800093d4:	c0 31       	brne	800093da <xTaskCheckForTimeOut+0x16>
800093d6:	30 07       	mov	r7,0
800093d8:	c1 f8       	rjmp	80009416 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800093da:	49 39       	lddpc	r9,80009424 <xTaskCheckForTimeOut+0x60>
800093dc:	72 09       	ld.w	r9,r9[0x0]
800093de:	6e 0a       	ld.w	r10,r7[0x0]
800093e0:	12 3a       	cp.w	r10,r9
800093e2:	c0 70       	breq	800093f0 <xTaskCheckForTimeOut+0x2c>
800093e4:	49 19       	lddpc	r9,80009428 <xTaskCheckForTimeOut+0x64>
800093e6:	72 09       	ld.w	r9,r9[0x0]
800093e8:	6e 1a       	ld.w	r10,r7[0x4]
800093ea:	12 3a       	cp.w	r10,r9
800093ec:	e0 88 00 14 	brls	80009414 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800093f0:	48 e9       	lddpc	r9,80009428 <xTaskCheckForTimeOut+0x64>
800093f2:	72 0a       	ld.w	r10,r9[0x0]
800093f4:	6e 19       	ld.w	r9,r7[0x4]
800093f6:	12 1a       	sub	r10,r9
800093f8:	14 38       	cp.w	r8,r10
800093fa:	e0 88 00 0d 	brls	80009414 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800093fe:	48 ba       	lddpc	r10,80009428 <xTaskCheckForTimeOut+0x64>
80009400:	74 0a       	ld.w	r10,r10[0x0]
80009402:	14 19       	sub	r9,r10
80009404:	f2 08 00 08 	add	r8,r9,r8
80009408:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000940a:	0e 9c       	mov	r12,r7
8000940c:	f0 1f 00 08 	mcall	8000942c <xTaskCheckForTimeOut+0x68>
80009410:	30 07       	mov	r7,0
80009412:	c0 28       	rjmp	80009416 <xTaskCheckForTimeOut+0x52>
80009414:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80009416:	f0 1f 00 07 	mcall	80009430 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000941a:	0e 9c       	mov	r12,r7
8000941c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009420:	80 00       	ld.sh	r0,r0[0x0]
80009422:	89 10       	st.w	r4[0x4],r0
80009424:	00 00       	add	r0,r0
80009426:	11 68       	ld.uh	r8,--r8
80009428:	00 00       	add	r0,r0
8000942a:	12 50       	eor	r0,r9
8000942c:	80 00       	ld.sh	r0,r0[0x0]
8000942e:	91 28       	st.w	r8[0x8],r8
80009430:	80 00       	ld.sh	r0,r0[0x0]
80009432:	8a 1c       	ld.sh	r12,r5[0x2]

80009434 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80009434:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80009438:	f0 1f 00 05 	mcall	8000944c <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
8000943c:	48 58       	lddpc	r8,80009450 <xTaskGetTickCount+0x1c>
8000943e:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80009440:	f0 1f 00 05 	mcall	80009454 <xTaskGetTickCount+0x20>

	return xTicks;
}
80009444:	0e 9c       	mov	r12,r7
80009446:	e3 cd 80 80 	ldm	sp++,r7,pc
8000944a:	00 00       	add	r0,r0
8000944c:	80 00       	ld.sh	r0,r0[0x0]
8000944e:	89 10       	st.w	r4[0x4],r0
80009450:	00 00       	add	r0,r0
80009452:	12 50       	eor	r0,r9
80009454:	80 00       	ld.sh	r0,r0[0x0]
80009456:	8a 1c       	ld.sh	r12,r5[0x2]

80009458 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80009458:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
8000945c:	f0 1f 00 2c 	mcall	8000950c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80009460:	4a c8       	lddpc	r8,80009510 <xTaskResumeAll+0xb8>
80009462:	70 09       	ld.w	r9,r8[0x0]
80009464:	20 19       	sub	r9,1
80009466:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80009468:	70 08       	ld.w	r8,r8[0x0]
8000946a:	58 08       	cp.w	r8,0
8000946c:	c4 91       	brne	800094fe <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000946e:	4a a8       	lddpc	r8,80009514 <xTaskResumeAll+0xbc>
80009470:	70 08       	ld.w	r8,r8[0x0]
80009472:	58 08       	cp.w	r8,0
80009474:	c4 50       	breq	800094fe <xTaskResumeAll+0xa6>
80009476:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80009478:	4a 85       	lddpc	r5,80009518 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000947a:	4a 93       	lddpc	r3,8000951c <xTaskResumeAll+0xc4>
8000947c:	4a 92       	lddpc	r2,80009520 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000947e:	4a a1       	lddpc	r1,80009524 <xTaskResumeAll+0xcc>
80009480:	c1 e8       	rjmp	800094bc <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80009482:	6a 38       	ld.w	r8,r5[0xc]
80009484:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80009486:	ee cc ff e8 	sub	r12,r7,-24
8000948a:	f0 1f 00 28 	mcall	80009528 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000948e:	ee c6 ff fc 	sub	r6,r7,-4
80009492:	0c 9c       	mov	r12,r6
80009494:	f0 1f 00 25 	mcall	80009528 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80009498:	6e bc       	ld.w	r12,r7[0x2c]
8000949a:	66 08       	ld.w	r8,r3[0x0]
8000949c:	10 3c       	cp.w	r12,r8
8000949e:	e7 fc ba 00 	st.whi	r3[0x0],r12
800094a2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800094a6:	0c 9b       	mov	r11,r6
800094a8:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800094ac:	f0 1f 00 20 	mcall	8000952c <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800094b0:	62 08       	ld.w	r8,r1[0x0]
800094b2:	6e b9       	ld.w	r9,r7[0x2c]
800094b4:	70 b8       	ld.w	r8,r8[0x2c]
800094b6:	10 39       	cp.w	r9,r8
800094b8:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800094bc:	6a 08       	ld.w	r8,r5[0x0]
800094be:	58 08       	cp.w	r8,0
800094c0:	ce 11       	brne	80009482 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800094c2:	49 c8       	lddpc	r8,80009530 <xTaskResumeAll+0xd8>
800094c4:	70 08       	ld.w	r8,r8[0x0]
800094c6:	58 08       	cp.w	r8,0
800094c8:	c0 f0       	breq	800094e6 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800094ca:	49 a8       	lddpc	r8,80009530 <xTaskResumeAll+0xd8>
800094cc:	70 08       	ld.w	r8,r8[0x0]
800094ce:	58 08       	cp.w	r8,0
800094d0:	c1 10       	breq	800094f2 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800094d2:	49 87       	lddpc	r7,80009530 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800094d4:	f0 1f 00 18 	mcall	80009534 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800094d8:	6e 08       	ld.w	r8,r7[0x0]
800094da:	20 18       	sub	r8,1
800094dc:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800094de:	6e 08       	ld.w	r8,r7[0x0]
800094e0:	58 08       	cp.w	r8,0
800094e2:	cf 91       	brne	800094d4 <xTaskResumeAll+0x7c>
800094e4:	c0 78       	rjmp	800094f2 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800094e6:	58 14       	cp.w	r4,1
800094e8:	c0 50       	breq	800094f2 <xTaskResumeAll+0x9a>
800094ea:	49 48       	lddpc	r8,80009538 <xTaskResumeAll+0xe0>
800094ec:	70 08       	ld.w	r8,r8[0x0]
800094ee:	58 18       	cp.w	r8,1
800094f0:	c0 71       	brne	800094fe <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800094f2:	30 09       	mov	r9,0
800094f4:	49 18       	lddpc	r8,80009538 <xTaskResumeAll+0xe0>
800094f6:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800094f8:	d7 33       	scall
800094fa:	30 17       	mov	r7,1
800094fc:	c0 28       	rjmp	80009500 <xTaskResumeAll+0xa8>
800094fe:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80009500:	f0 1f 00 0f 	mcall	8000953c <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80009504:	0e 9c       	mov	r12,r7
80009506:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000950a:	00 00       	add	r0,r0
8000950c:	80 00       	ld.sh	r0,r0[0x0]
8000950e:	89 10       	st.w	r4[0x4],r0
80009510:	00 00       	add	r0,r0
80009512:	12 54       	eor	r4,r9
80009514:	00 00       	add	r0,r0
80009516:	12 70       	tst	r0,r9
80009518:	00 00       	add	r0,r0
8000951a:	12 28       	rsub	r8,r9
8000951c:	00 00       	add	r0,r0
8000951e:	12 8c       	andn	r12,r9
80009520:	00 00       	add	r0,r0
80009522:	11 70       	ld.ub	r0,--r8
80009524:	00 00       	add	r0,r0
80009526:	12 24       	rsub	r4,r9
80009528:	80 00       	ld.sh	r0,r0[0x0]
8000952a:	88 56       	ld.sh	r6,r4[0xa]
8000952c:	80 00       	ld.sh	r0,r0[0x0]
8000952e:	88 06       	ld.sh	r6,r4[0x0]
80009530:	00 00       	add	r0,r0
80009532:	11 54       	ld.sh	r4,--r8
80009534:	80 00       	ld.sh	r0,r0[0x0]
80009536:	92 b0       	ld.uh	r0,r9[0x6]
80009538:	00 00       	add	r0,r0
8000953a:	12 74       	tst	r4,r9
8000953c:	80 00       	ld.sh	r0,r0[0x0]
8000953e:	8a 1c       	ld.sh	r12,r5[0x2]

80009540 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80009540:	eb cd 40 80 	pushm	r7,lr
80009544:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80009546:	49 08       	lddpc	r8,80009584 <prvAddCurrentTaskToDelayedList+0x44>
80009548:	70 08       	ld.w	r8,r8[0x0]
8000954a:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
8000954c:	48 f8       	lddpc	r8,80009588 <prvAddCurrentTaskToDelayedList+0x48>
8000954e:	70 08       	ld.w	r8,r8[0x0]
80009550:	10 3c       	cp.w	r12,r8
80009552:	c0 a2       	brcc	80009566 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009554:	48 c8       	lddpc	r8,80009584 <prvAddCurrentTaskToDelayedList+0x44>
80009556:	70 0b       	ld.w	r11,r8[0x0]
80009558:	48 d8       	lddpc	r8,8000958c <prvAddCurrentTaskToDelayedList+0x4c>
8000955a:	70 0c       	ld.w	r12,r8[0x0]
8000955c:	2f cb       	sub	r11,-4
8000955e:	f0 1f 00 0d 	mcall	80009590 <prvAddCurrentTaskToDelayedList+0x50>
80009562:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009566:	48 88       	lddpc	r8,80009584 <prvAddCurrentTaskToDelayedList+0x44>
80009568:	70 0b       	ld.w	r11,r8[0x0]
8000956a:	48 b8       	lddpc	r8,80009594 <prvAddCurrentTaskToDelayedList+0x54>
8000956c:	70 0c       	ld.w	r12,r8[0x0]
8000956e:	2f cb       	sub	r11,-4
80009570:	f0 1f 00 08 	mcall	80009590 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80009574:	48 98       	lddpc	r8,80009598 <prvAddCurrentTaskToDelayedList+0x58>
80009576:	70 08       	ld.w	r8,r8[0x0]
80009578:	10 37       	cp.w	r7,r8
8000957a:	c0 32       	brcc	80009580 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
8000957c:	48 78       	lddpc	r8,80009598 <prvAddCurrentTaskToDelayedList+0x58>
8000957e:	91 07       	st.w	r8[0x0],r7
80009580:	e3 cd 80 80 	ldm	sp++,r7,pc
80009584:	00 00       	add	r0,r0
80009586:	12 24       	rsub	r4,r9
80009588:	00 00       	add	r0,r0
8000958a:	12 50       	eor	r0,r9
8000958c:	00 00       	add	r0,r0
8000958e:	11 6c       	ld.uh	r12,--r8
80009590:	80 00       	ld.sh	r0,r0[0x0]
80009592:	88 22       	ld.sh	r2,r4[0x4]
80009594:	00 00       	add	r0,r0
80009596:	11 5c       	ld.sh	r12,--r8
80009598:	00 00       	add	r0,r0
8000959a:	05 34       	ld.ub	r4,r2++

8000959c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
8000959c:	eb cd 40 c0 	pushm	r6-r7,lr
800095a0:	18 96       	mov	r6,r12
800095a2:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
800095a4:	f0 1f 00 18 	mcall	80009604 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
800095a8:	6c 08       	ld.w	r8,r6[0x0]
800095aa:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
800095ac:	49 79       	lddpc	r9,80009608 <vTaskDelayUntil+0x6c>
800095ae:	72 09       	ld.w	r9,r9[0x0]
800095b0:	12 38       	cp.w	r8,r9
800095b2:	e0 88 00 0c 	brls	800095ca <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
800095b6:	0e 38       	cp.w	r8,r7
800095b8:	e0 88 00 22 	brls	800095fc <vTaskDelayUntil+0x60>
800095bc:	49 38       	lddpc	r8,80009608 <vTaskDelayUntil+0x6c>
800095be:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800095c0:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
800095c2:	10 37       	cp.w	r7,r8
800095c4:	e0 88 00 14 	brls	800095ec <vTaskDelayUntil+0x50>
800095c8:	c0 a8       	rjmp	800095dc <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
800095ca:	0e 38       	cp.w	r8,r7
800095cc:	e0 8b 00 16 	brhi	800095f8 <vTaskDelayUntil+0x5c>
800095d0:	48 e8       	lddpc	r8,80009608 <vTaskDelayUntil+0x6c>
800095d2:	70 08       	ld.w	r8,r8[0x0]
800095d4:	10 37       	cp.w	r7,r8
800095d6:	e0 8b 00 11 	brhi	800095f8 <vTaskDelayUntil+0x5c>
800095da:	c1 18       	rjmp	800095fc <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800095dc:	48 c8       	lddpc	r8,8000960c <vTaskDelayUntil+0x70>
800095de:	70 0c       	ld.w	r12,r8[0x0]
800095e0:	2f cc       	sub	r12,-4
800095e2:	f0 1f 00 0c 	mcall	80009610 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800095e6:	0e 9c       	mov	r12,r7
800095e8:	f0 1f 00 0b 	mcall	80009614 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
800095ec:	f0 1f 00 0b 	mcall	80009618 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800095f0:	c0 81       	brne	80009600 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
800095f2:	d7 33       	scall
800095f4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800095f8:	8d 07       	st.w	r6[0x0],r7
800095fa:	cf 1b       	rjmp	800095dc <vTaskDelayUntil+0x40>
800095fc:	8d 07       	st.w	r6[0x0],r7
800095fe:	cf 7b       	rjmp	800095ec <vTaskDelayUntil+0x50>
80009600:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009604:	80 00       	ld.sh	r0,r0[0x0]
80009606:	90 9c       	ld.uh	r12,r8[0x2]
80009608:	00 00       	add	r0,r0
8000960a:	12 50       	eor	r0,r9
8000960c:	00 00       	add	r0,r0
8000960e:	12 24       	rsub	r4,r9
80009610:	80 00       	ld.sh	r0,r0[0x0]
80009612:	88 56       	ld.sh	r6,r4[0xa]
80009614:	80 00       	ld.sh	r0,r0[0x0]
80009616:	95 40       	st.w	r10[0x10],r0
80009618:	80 00       	ld.sh	r0,r0[0x0]
8000961a:	94 58       	ld.sh	r8,r10[0xa]

8000961c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
8000961c:	eb cd 40 c0 	pushm	r6-r7,lr
80009620:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80009622:	48 e7       	lddpc	r7,80009658 <vTaskPlaceOnEventList+0x3c>
80009624:	6e 0b       	ld.w	r11,r7[0x0]
80009626:	2e 8b       	sub	r11,-24
80009628:	f0 1f 00 0d 	mcall	8000965c <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000962c:	6e 0c       	ld.w	r12,r7[0x0]
8000962e:	2f cc       	sub	r12,-4
80009630:	f0 1f 00 0c 	mcall	80009660 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80009634:	5b f6       	cp.w	r6,-1
80009636:	c0 81       	brne	80009646 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009638:	6e 0b       	ld.w	r11,r7[0x0]
8000963a:	2f cb       	sub	r11,-4
8000963c:	48 ac       	lddpc	r12,80009664 <vTaskPlaceOnEventList+0x48>
8000963e:	f0 1f 00 0b 	mcall	80009668 <vTaskPlaceOnEventList+0x4c>
80009642:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80009646:	48 a8       	lddpc	r8,8000966c <vTaskPlaceOnEventList+0x50>
80009648:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000964a:	ec 0c 00 0c 	add	r12,r6,r12
8000964e:	f0 1f 00 09 	mcall	80009670 <vTaskPlaceOnEventList+0x54>
80009652:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009656:	00 00       	add	r0,r0
80009658:	00 00       	add	r0,r0
8000965a:	12 24       	rsub	r4,r9
8000965c:	80 00       	ld.sh	r0,r0[0x0]
8000965e:	88 22       	ld.sh	r2,r4[0x4]
80009660:	80 00       	ld.sh	r0,r0[0x0]
80009662:	88 56       	ld.sh	r6,r4[0xa]
80009664:	00 00       	add	r0,r0
80009666:	12 78       	tst	r8,r9
80009668:	80 00       	ld.sh	r0,r0[0x0]
8000966a:	88 06       	ld.sh	r6,r4[0x0]
8000966c:	00 00       	add	r0,r0
8000966e:	12 50       	eor	r0,r9
80009670:	80 00       	ld.sh	r0,r0[0x0]
80009672:	95 40       	st.w	r10[0x10],r0

80009674 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80009674:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80009678:	49 67       	lddpc	r7,800096d0 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000967a:	49 74       	lddpc	r4,800096d4 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
8000967c:	49 73       	lddpc	r3,800096d8 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000967e:	49 85       	lddpc	r5,800096dc <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80009680:	6e 08       	ld.w	r8,r7[0x0]
80009682:	58 08       	cp.w	r8,0
80009684:	c1 e0       	breq	800096c0 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80009686:	f0 1f 00 17 	mcall	800096e0 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000968a:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
8000968c:	f0 1f 00 16 	mcall	800096e4 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80009690:	58 06       	cp.w	r6,0
80009692:	c1 70       	breq	800096c0 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80009694:	f0 1f 00 15 	mcall	800096e8 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80009698:	68 38       	ld.w	r8,r4[0xc]
8000969a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
8000969c:	ec cc ff fc 	sub	r12,r6,-4
800096a0:	f0 1f 00 13 	mcall	800096ec <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
800096a4:	66 08       	ld.w	r8,r3[0x0]
800096a6:	20 18       	sub	r8,1
800096a8:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
800096aa:	6e 08       	ld.w	r8,r7[0x0]
800096ac:	20 18       	sub	r8,1
800096ae:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
800096b0:	f0 1f 00 10 	mcall	800096f0 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
800096b4:	6c cc       	ld.w	r12,r6[0x30]
800096b6:	f0 1f 00 10 	mcall	800096f4 <prvIdleTask+0x80>
		vPortFree( pxTCB );
800096ba:	0c 9c       	mov	r12,r6
800096bc:	f0 1f 00 0e 	mcall	800096f4 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800096c0:	6a 08       	ld.w	r8,r5[0x0]
800096c2:	58 18       	cp.w	r8,1
800096c4:	e0 88 00 03 	brls	800096ca <prvIdleTask+0x56>
			{
				taskYIELD();
800096c8:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
800096ca:	f0 1f 00 0c 	mcall	800096f8 <prvIdleTask+0x84>
		}
		#endif
	}
800096ce:	cd 9b       	rjmp	80009680 <prvIdleTask+0xc>
800096d0:	00 00       	add	r0,r0
800096d2:	11 64       	ld.uh	r4,--r8
800096d4:	00 00       	add	r0,r0
800096d6:	12 10       	sub	r0,r9
800096d8:	00 00       	add	r0,r0
800096da:	12 70       	tst	r0,r9
800096dc:	00 00       	add	r0,r0
800096de:	11 70       	ld.ub	r0,--r8
800096e0:	80 00       	ld.sh	r0,r0[0x0]
800096e2:	90 9c       	ld.uh	r12,r8[0x2]
800096e4:	80 00       	ld.sh	r0,r0[0x0]
800096e6:	94 58       	ld.sh	r8,r10[0xa]
800096e8:	80 00       	ld.sh	r0,r0[0x0]
800096ea:	89 10       	st.w	r4[0x4],r0
800096ec:	80 00       	ld.sh	r0,r0[0x0]
800096ee:	88 56       	ld.sh	r6,r4[0xa]
800096f0:	80 00       	ld.sh	r0,r0[0x0]
800096f2:	8a 1c       	ld.sh	r12,r5[0x2]
800096f4:	80 00       	ld.sh	r0,r0[0x0]
800096f6:	8b 54       	st.w	r5[0x14],r4
800096f8:	80 00       	ld.sh	r0,r0[0x0]
800096fa:	20 34       	sub	r4,3

800096fc <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800096fc:	d4 31       	pushm	r0-r7,lr
800096fe:	20 1d       	sub	sp,4
80009700:	fa c4 ff d8 	sub	r4,sp,-40
80009704:	50 0c       	stdsp	sp[0x0],r12
80009706:	16 91       	mov	r1,r11
80009708:	14 97       	mov	r7,r10
8000970a:	12 90       	mov	r0,r9
8000970c:	10 93       	mov	r3,r8
8000970e:	68 02       	ld.w	r2,r4[0x0]
80009710:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80009712:	34 8c       	mov	r12,72
80009714:	f0 1f 00 5c 	mcall	80009884 <xTaskGenericCreate+0x188>
80009718:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
8000971a:	c0 31       	brne	80009720 <xTaskGenericCreate+0x24>
8000971c:	3f fc       	mov	r12,-1
8000971e:	ca f8       	rjmp	8000987c <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80009720:	58 06       	cp.w	r6,0
80009722:	e0 81 00 af 	brne	80009880 <xTaskGenericCreate+0x184>
80009726:	0e 9c       	mov	r12,r7
80009728:	5c 7c       	castu.h	r12
8000972a:	a3 6c       	lsl	r12,0x2
8000972c:	f0 1f 00 56 	mcall	80009884 <xTaskGenericCreate+0x188>
80009730:	18 96       	mov	r6,r12
80009732:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80009734:	c0 61       	brne	80009740 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80009736:	0a 9c       	mov	r12,r5
80009738:	f0 1f 00 54 	mcall	80009888 <xTaskGenericCreate+0x18c>
8000973c:	3f fc       	mov	r12,-1
8000973e:	c9 f8       	rjmp	8000987c <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80009740:	5c 77       	castu.h	r7
80009742:	ee 0a 15 02 	lsl	r10,r7,0x2
80009746:	e0 6b 00 a5 	mov	r11,165
8000974a:	0c 9c       	mov	r12,r6
8000974c:	f0 1f 00 50 	mcall	8000988c <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80009750:	ee c6 00 01 	sub	r6,r7,1
80009754:	6a c8       	ld.w	r8,r5[0x30]
80009756:	f0 06 00 26 	add	r6,r8,r6<<0x2
8000975a:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
8000975e:	31 0a       	mov	r10,16
80009760:	02 9b       	mov	r11,r1
80009762:	ea cc ff cc 	sub	r12,r5,-52
80009766:	f0 1f 00 4b 	mcall	80009890 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
8000976a:	30 08       	mov	r8,0
8000976c:	eb 68 00 43 	st.b	r5[67],r8
80009770:	58 73       	cp.w	r3,7
80009772:	e6 07 17 80 	movls	r7,r3
80009776:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
8000977a:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
8000977c:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80009780:	ea c4 ff fc 	sub	r4,r5,-4
80009784:	08 9c       	mov	r12,r4
80009786:	f0 1f 00 44 	mcall	80009894 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
8000978a:	ea cc ff e8 	sub	r12,r5,-24
8000978e:	f0 1f 00 42 	mcall	80009894 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80009792:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80009794:	ee 07 11 08 	rsub	r7,r7,8
80009798:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
8000979a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
8000979c:	00 9a       	mov	r10,r0
8000979e:	40 0b       	lddsp	r11,sp[0x0]
800097a0:	0c 9c       	mov	r12,r6
800097a2:	f0 1f 00 3e 	mcall	80009898 <xTaskGenericCreate+0x19c>
800097a6:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
800097a8:	58 02       	cp.w	r2,0
800097aa:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
800097ae:	f0 1f 00 3c 	mcall	8000989c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
800097b2:	4b c8       	lddpc	r8,800098a0 <xTaskGenericCreate+0x1a4>
800097b4:	70 09       	ld.w	r9,r8[0x0]
800097b6:	2f f9       	sub	r9,-1
800097b8:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
800097ba:	4b b8       	lddpc	r8,800098a4 <xTaskGenericCreate+0x1a8>
800097bc:	70 08       	ld.w	r8,r8[0x0]
800097be:	58 08       	cp.w	r8,0
800097c0:	c2 61       	brne	8000980c <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
800097c2:	4b 98       	lddpc	r8,800098a4 <xTaskGenericCreate+0x1a8>
800097c4:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
800097c6:	4b 78       	lddpc	r8,800098a0 <xTaskGenericCreate+0x1a4>
800097c8:	70 08       	ld.w	r8,r8[0x0]
800097ca:	58 18       	cp.w	r8,1
800097cc:	c2 b1       	brne	80009822 <xTaskGenericCreate+0x126>
800097ce:	4b 77       	lddpc	r7,800098a8 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
800097d0:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
800097d4:	0e 9c       	mov	r12,r7
800097d6:	f0 1f 00 36 	mcall	800098ac <xTaskGenericCreate+0x1b0>
800097da:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
800097dc:	0c 37       	cp.w	r7,r6
800097de:	cf b1       	brne	800097d4 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
800097e0:	4b 47       	lddpc	r7,800098b0 <xTaskGenericCreate+0x1b4>
800097e2:	0e 9c       	mov	r12,r7
800097e4:	f0 1f 00 32 	mcall	800098ac <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
800097e8:	4b 36       	lddpc	r6,800098b4 <xTaskGenericCreate+0x1b8>
800097ea:	0c 9c       	mov	r12,r6
800097ec:	f0 1f 00 30 	mcall	800098ac <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
800097f0:	4b 2c       	lddpc	r12,800098b8 <xTaskGenericCreate+0x1bc>
800097f2:	f0 1f 00 2f 	mcall	800098ac <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
800097f6:	4b 2c       	lddpc	r12,800098bc <xTaskGenericCreate+0x1c0>
800097f8:	f0 1f 00 2d 	mcall	800098ac <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
800097fc:	4b 1c       	lddpc	r12,800098c0 <xTaskGenericCreate+0x1c4>
800097fe:	f0 1f 00 2c 	mcall	800098ac <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80009802:	4b 18       	lddpc	r8,800098c4 <xTaskGenericCreate+0x1c8>
80009804:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80009806:	4b 18       	lddpc	r8,800098c8 <xTaskGenericCreate+0x1cc>
80009808:	91 06       	st.w	r8[0x0],r6
8000980a:	c0 c8       	rjmp	80009822 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
8000980c:	4b 08       	lddpc	r8,800098cc <xTaskGenericCreate+0x1d0>
8000980e:	70 08       	ld.w	r8,r8[0x0]
80009810:	58 08       	cp.w	r8,0
80009812:	c0 81       	brne	80009822 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80009814:	4a 48       	lddpc	r8,800098a4 <xTaskGenericCreate+0x1a8>
80009816:	70 08       	ld.w	r8,r8[0x0]
80009818:	70 b8       	ld.w	r8,r8[0x2c]
8000981a:	10 33       	cp.w	r3,r8
8000981c:	c0 33       	brcs	80009822 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
8000981e:	4a 28       	lddpc	r8,800098a4 <xTaskGenericCreate+0x1a8>
80009820:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80009822:	6a b8       	ld.w	r8,r5[0x2c]
80009824:	4a b9       	lddpc	r9,800098d0 <xTaskGenericCreate+0x1d4>
80009826:	72 09       	ld.w	r9,r9[0x0]
80009828:	12 38       	cp.w	r8,r9
8000982a:	e0 88 00 04 	brls	80009832 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
8000982e:	4a 99       	lddpc	r9,800098d0 <xTaskGenericCreate+0x1d4>
80009830:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80009832:	4a 98       	lddpc	r8,800098d4 <xTaskGenericCreate+0x1d8>
80009834:	70 09       	ld.w	r9,r8[0x0]
80009836:	2f f9       	sub	r9,-1
80009838:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
8000983a:	6a b8       	ld.w	r8,r5[0x2c]
8000983c:	4a 79       	lddpc	r9,800098d8 <xTaskGenericCreate+0x1dc>
8000983e:	72 09       	ld.w	r9,r9[0x0]
80009840:	12 38       	cp.w	r8,r9
80009842:	e0 88 00 04 	brls	8000984a <xTaskGenericCreate+0x14e>
80009846:	4a 59       	lddpc	r9,800098d8 <xTaskGenericCreate+0x1dc>
80009848:	93 08       	st.w	r9[0x0],r8
8000984a:	6a bc       	ld.w	r12,r5[0x2c]
8000984c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009850:	08 9b       	mov	r11,r4
80009852:	49 68       	lddpc	r8,800098a8 <xTaskGenericCreate+0x1ac>
80009854:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80009858:	f0 1f 00 21 	mcall	800098dc <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
8000985c:	f0 1f 00 21 	mcall	800098e0 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80009860:	49 b8       	lddpc	r8,800098cc <xTaskGenericCreate+0x1d0>
80009862:	70 08       	ld.w	r8,r8[0x0]
80009864:	58 08       	cp.w	r8,0
80009866:	c0 a0       	breq	8000987a <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80009868:	48 f8       	lddpc	r8,800098a4 <xTaskGenericCreate+0x1a8>
8000986a:	70 08       	ld.w	r8,r8[0x0]
8000986c:	70 b8       	ld.w	r8,r8[0x2c]
8000986e:	10 33       	cp.w	r3,r8
80009870:	e0 88 00 05 	brls	8000987a <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80009874:	d7 33       	scall
80009876:	30 1c       	mov	r12,1
80009878:	c0 28       	rjmp	8000987c <xTaskGenericCreate+0x180>
8000987a:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
8000987c:	2f fd       	sub	sp,-4
8000987e:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80009880:	99 c6       	st.w	r12[0x30],r6
80009882:	c5 fb       	rjmp	80009740 <xTaskGenericCreate+0x44>
80009884:	80 00       	ld.sh	r0,r0[0x0]
80009886:	8b 7c       	st.w	r5[0x1c],r12
80009888:	80 00       	ld.sh	r0,r0[0x0]
8000988a:	8b 54       	st.w	r5[0x14],r4
8000988c:	80 00       	ld.sh	r0,r0[0x0]
8000988e:	a5 ce       	cbr	lr,0x4
80009890:	80 00       	ld.sh	r0,r0[0x0]
80009892:	a9 20       	st.d	r4++,r0
80009894:	80 00       	ld.sh	r0,r0[0x0]
80009896:	88 00       	ld.sh	r0,r4[0x0]
80009898:	80 00       	ld.sh	r0,r0[0x0]
8000989a:	88 7c       	ld.sh	r12,r4[0xe]
8000989c:	80 00       	ld.sh	r0,r0[0x0]
8000989e:	89 10       	st.w	r4[0x4],r0
800098a0:	00 00       	add	r0,r0
800098a2:	12 70       	tst	r0,r9
800098a4:	00 00       	add	r0,r0
800098a6:	12 24       	rsub	r4,r9
800098a8:	00 00       	add	r0,r0
800098aa:	11 70       	ld.ub	r0,--r8
800098ac:	80 00       	ld.sh	r0,r0[0x0]
800098ae:	87 ec       	st.w	r3[0x38],r12
800098b0:	00 00       	add	r0,r0
800098b2:	12 3c       	cp.w	r12,r9
800098b4:	00 00       	add	r0,r0
800098b6:	12 58       	eor	r8,r9
800098b8:	00 00       	add	r0,r0
800098ba:	12 28       	rsub	r8,r9
800098bc:	00 00       	add	r0,r0
800098be:	12 10       	sub	r0,r9
800098c0:	00 00       	add	r0,r0
800098c2:	12 78       	tst	r8,r9
800098c4:	00 00       	add	r0,r0
800098c6:	11 5c       	ld.sh	r12,--r8
800098c8:	00 00       	add	r0,r0
800098ca:	11 6c       	ld.uh	r12,--r8
800098cc:	00 00       	add	r0,r0
800098ce:	11 60       	ld.uh	r0,--r8
800098d0:	00 00       	add	r0,r0
800098d2:	11 58       	ld.sh	r8,--r8
800098d4:	00 00       	add	r0,r0
800098d6:	12 6c       	and	r12,r9
800098d8:	00 00       	add	r0,r0
800098da:	12 8c       	andn	r12,r9
800098dc:	80 00       	ld.sh	r0,r0[0x0]
800098de:	88 06       	ld.sh	r6,r4[0x0]
800098e0:	80 00       	ld.sh	r0,r0[0x0]
800098e2:	8a 1c       	ld.sh	r12,r5[0x2]

800098e4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
800098e4:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
800098e6:	30 09       	mov	r9,0
800098e8:	1a d9       	st.w	--sp,r9
800098ea:	1a d9       	st.w	--sp,r9
800098ec:	1a d9       	st.w	--sp,r9
800098ee:	12 98       	mov	r8,r9
800098f0:	e0 6a 01 00 	mov	r10,256
800098f4:	48 9b       	lddpc	r11,80009918 <vTaskStartScheduler+0x34>
800098f6:	48 ac       	lddpc	r12,8000991c <vTaskStartScheduler+0x38>
800098f8:	f0 1f 00 0a 	mcall	80009920 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
800098fc:	2f dd       	sub	sp,-12
800098fe:	58 1c       	cp.w	r12,1
80009900:	c0 a1       	brne	80009914 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80009902:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80009904:	30 19       	mov	r9,1
80009906:	48 88       	lddpc	r8,80009924 <vTaskStartScheduler+0x40>
80009908:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
8000990a:	30 09       	mov	r9,0
8000990c:	48 78       	lddpc	r8,80009928 <vTaskStartScheduler+0x44>
8000990e:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80009910:	f0 1f 00 07 	mcall	8000992c <vTaskStartScheduler+0x48>
80009914:	d8 02       	popm	pc
80009916:	00 00       	add	r0,r0
80009918:	80 01       	ld.sh	r1,r0[0x0]
8000991a:	8b d8       	st.w	r5[0x34],r8
8000991c:	80 00       	ld.sh	r0,r0[0x0]
8000991e:	96 74       	ld.sh	r4,r11[0xe]
80009920:	80 00       	ld.sh	r0,r0[0x0]
80009922:	96 fc       	ld.uh	r12,r11[0xe]
80009924:	00 00       	add	r0,r0
80009926:	11 60       	ld.uh	r0,--r8
80009928:	00 00       	add	r0,r0
8000992a:	12 50       	eor	r0,r9
8000992c:	80 00       	ld.sh	r0,r0[0x0]
8000992e:	89 20       	st.w	r4[0x8],r0

80009930 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80009930:	16 cc       	st.b	r11++,r12
	return str;
}
80009932:	5e fb       	retal	r11

80009934 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80009934:	eb cd 40 c0 	pushm	r6-r7,lr
80009938:	20 3d       	sub	sp,12
8000993a:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
8000993c:	30 06       	mov	r6,0
8000993e:	30 07       	mov	r7,0
80009940:	fa e7 00 00 	st.d	sp[0],r6
80009944:	30 0c       	mov	r12,0
80009946:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80009948:	58 08       	cp.w	r8,0
8000994a:	c1 30       	breq	80009970 <PrintHex+0x3c>
8000994c:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
8000994e:	1a 9c       	mov	r12,sp
80009950:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80009954:	58 9e       	cp.w	lr,9
80009956:	e0 8a 00 04 	brle	8000995e <PrintHex+0x2a>
8000995a:	2c 9e       	sub	lr,-55
8000995c:	c0 48       	rjmp	80009964 <PrintHex+0x30>
8000995e:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80009962:	2d 0e       	sub	lr,-48
80009964:	f8 09 0b 0e 	st.b	r12[r9],lr
80009968:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
8000996a:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
8000996c:	cf 21       	brne	80009950 <PrintHex+0x1c>
8000996e:	c0 48       	rjmp	80009976 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80009970:	33 08       	mov	r8,48
80009972:	ba 88       	st.b	sp[0x0],r8
80009974:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80009976:	f6 09 01 08 	sub	r8,r11,r9
8000997a:	58 08       	cp.w	r8,0
8000997c:	e0 8a 00 13 	brle	800099a2 <PrintHex+0x6e>
	{
		char num = len - cnt;
80009980:	12 1b       	sub	r11,r9
80009982:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80009986:	18 9e       	mov	lr,r12
80009988:	58 0c       	cp.w	r12,0
8000998a:	e0 8a 00 0c 	brle	800099a2 <PrintHex+0x6e>
8000998e:	1a 9b       	mov	r11,sp
80009990:	12 0b       	add	r11,r9
80009992:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80009994:	33 07       	mov	r7,48
80009996:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80009998:	2f f8       	sub	r8,-1
8000999a:	1c 38       	cp.w	r8,lr
8000999c:	cf d5       	brlt	80009996 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000999e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
800099a2:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
800099a6:	f0 cb ff ff 	sub	r11,r8,-1
800099aa:	58 0b       	cp.w	r11,0
800099ac:	e0 8a 00 19 	brle	800099de <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
800099b0:	fa cb ff f4 	sub	r11,sp,-12
800099b4:	f6 09 00 09 	add	r9,r11,r9
800099b8:	37 8b       	mov	r11,120
800099ba:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
800099be:	fa c9 ff f4 	sub	r9,sp,-12
800099c2:	10 09       	add	r9,r8
800099c4:	33 0b       	mov	r11,48
800099c6:	f3 6b ff f4 	st.b	r9[-12],r11
800099ca:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
800099ce:	fa ce 00 01 	sub	lr,sp,1
800099d2:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
800099d4:	11 8b       	ld.ub	r11,r8[0x0]
800099d6:	12 cb       	st.b	r9++,r11
800099d8:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
800099da:	1c 38       	cp.w	r8,lr
800099dc:	cf c1       	brne	800099d4 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
800099de:	14 9c       	mov	r12,r10
800099e0:	2f dd       	sub	sp,-12
800099e2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800099e6 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
800099e6:	d4 21       	pushm	r4-r7,lr
800099e8:	20 3d       	sub	sp,12
800099ea:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
800099ec:	30 06       	mov	r6,0
800099ee:	30 07       	mov	r7,0
800099f0:	fa e7 00 00 	st.d	sp[0],r6
800099f4:	30 0c       	mov	r12,0
800099f6:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
800099f8:	58 08       	cp.w	r8,0
800099fa:	c0 35       	brlt	80009a00 <PrintDec+0x1a>
800099fc:	14 97       	mov	r7,r10
800099fe:	c0 58       	rjmp	80009a08 <PrintDec+0x22>
	{
		*p++ = '-';
80009a00:	14 97       	mov	r7,r10
80009a02:	32 d9       	mov	r9,45
80009a04:	0e c9       	st.b	r7++,r9
		i = -i;
80009a06:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80009a08:	58 08       	cp.w	r8,0
80009a0a:	c0 51       	brne	80009a14 <PrintDec+0x2e>
80009a0c:	33 08       	mov	r8,48
80009a0e:	ba 88       	st.b	sp[0x0],r8
80009a10:	30 1e       	mov	lr,1
80009a12:	c2 f8       	rjmp	80009a70 <PrintDec+0x8a>
	
	int ten = i%10;
80009a14:	e0 65 66 67 	mov	r5,26215
80009a18:	ea 15 66 66 	orh	r5,0x6666
80009a1c:	f0 05 04 44 	muls.d	r4,r8,r5
80009a20:	ea 0c 14 02 	asr	r12,r5,0x2
80009a24:	f0 09 14 1f 	asr	r9,r8,0x1f
80009a28:	f8 09 01 09 	sub	r9,r12,r9
80009a2c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009a30:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80009a34:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80009a36:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80009a38:	e0 66 66 67 	mov	r6,26215
80009a3c:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80009a40:	2d 09       	sub	r9,-48
80009a42:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80009a46:	2f fe       	sub	lr,-1
		i /= 10;
80009a48:	f0 06 04 44 	muls.d	r4,r8,r6
80009a4c:	ea 09 14 02 	asr	r9,r5,0x2
80009a50:	bf 58       	asr	r8,0x1f
80009a52:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80009a56:	f0 06 04 44 	muls.d	r4,r8,r6
80009a5a:	ea 09 14 02 	asr	r9,r5,0x2
80009a5e:	f0 05 14 1f 	asr	r5,r8,0x1f
80009a62:	0a 19       	sub	r9,r5
80009a64:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009a68:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80009a6c:	58 08       	cp.w	r8,0
80009a6e:	ce 91       	brne	80009a40 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80009a70:	f6 0e 01 08 	sub	r8,r11,lr
80009a74:	58 08       	cp.w	r8,0
80009a76:	e0 89 00 06 	brgt	80009a82 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80009a7a:	58 0e       	cp.w	lr,0
80009a7c:	e0 89 00 14 	brgt	80009aa4 <PrintDec+0xbe>
80009a80:	c1 d8       	rjmp	80009aba <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80009a82:	1c 1b       	sub	r11,lr
80009a84:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80009a86:	16 9c       	mov	r12,r11
80009a88:	58 0b       	cp.w	r11,0
80009a8a:	fe 9a ff f8 	brle	80009a7a <PrintDec+0x94>
80009a8e:	1a 99       	mov	r9,sp
80009a90:	1c 09       	add	r9,lr
80009a92:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80009a94:	33 06       	mov	r6,48
80009a96:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80009a98:	2f f8       	sub	r8,-1
80009a9a:	18 38       	cp.w	r8,r12
80009a9c:	cf d5       	brlt	80009a96 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80009a9e:	f6 0e 00 0e 	add	lr,r11,lr
80009aa2:	ce cb       	rjmp	80009a7a <PrintDec+0x94>
80009aa4:	fa c8 ff f4 	sub	r8,sp,-12
80009aa8:	1c 08       	add	r8,lr
80009aaa:	20 d8       	sub	r8,13
80009aac:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80009ab0:	11 89       	ld.ub	r9,r8[0x0]
80009ab2:	0e c9       	st.b	r7++,r9
80009ab4:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80009ab6:	16 38       	cp.w	r8,r11
80009ab8:	cf c1       	brne	80009ab0 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80009aba:	14 9c       	mov	r12,r10
80009abc:	2f dd       	sub	sp,-12
80009abe:	d8 22       	popm	r4-r7,pc

80009ac0 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80009ac0:	d4 31       	pushm	r0-r7,lr
80009ac2:	fa cd 02 08 	sub	sp,sp,520
80009ac6:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80009ac8:	e0 6a 01 00 	mov	r10,256
80009acc:	30 0b       	mov	r11,0
80009ace:	fa cc fe f8 	sub	r12,sp,-264
80009ad2:	f0 1f 00 4e 	mcall	80009c08 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80009ad6:	fa c4 fd d4 	sub	r4,sp,-556
80009ada:	30 0a       	mov	r10,0
80009adc:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009ade:	fa c3 ff fc 	sub	r3,sp,-4
80009ae2:	e0 61 01 00 	mov	r1,256
80009ae6:	14 90       	mov	r0,r10
			
					if(*str == '%')
80009ae8:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80009aea:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009aee:	02 9a       	mov	r10,r1
80009af0:	00 9b       	mov	r11,r0
80009af2:	06 9c       	mov	r12,r3
80009af4:	f0 1f 00 45 	mcall	80009c08 <log+0x148>
			
					if(*str == '%')
80009af8:	0f 88       	ld.ub	r8,r7[0x0]
80009afa:	e4 08 18 00 	cp.b	r8,r2
80009afe:	c5 71       	brne	80009bac <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80009b00:	ee c8 ff ff 	sub	r8,r7,-1
80009b04:	11 89       	ld.ub	r9,r8[0x0]
80009b06:	4c 2a       	lddpc	r10,80009c0c <log+0x14c>
80009b08:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80009b0a:	23 09       	sub	r9,48
80009b0c:	30 9a       	mov	r10,9
80009b0e:	f4 09 18 00 	cp.b	r9,r10
80009b12:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80009b16:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80009b1a:	f7 b9 08 30 	subls	r9,48
80009b1e:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80009b22:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80009b26:	0f 88       	ld.ub	r8,r7[0x0]
80009b28:	22 58       	sub	r8,37
80009b2a:	e0 48 00 53 	cp.w	r8,83
80009b2e:	e0 8b 00 31 	brhi	80009b90 <log+0xd0>
80009b32:	4b 89       	lddpc	r9,80009c10 <log+0x150>
80009b34:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80009b38:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80009b3c:	06 9a       	mov	r10,r3
80009b3e:	40 0b       	lddsp	r11,sp[0x0]
80009b40:	5c 5b       	castu.b	r11
80009b42:	68 0c       	ld.w	r12,r4[0x0]
80009b44:	f0 1f 00 34 	mcall	80009c14 <log+0x154>
							break;
80009b48:	c2 98       	rjmp	80009b9a <log+0xda>
							
							case('f')://
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80009b4a:	4b 4c       	lddpc	r12,80009c18 <log+0x158>
80009b4c:	f0 1f 00 34 	mcall	80009c1c <log+0x15c>
80009b50:	08 95       	mov	r5,r4
80009b52:	06 9c       	mov	r12,r3
							break;
80009b54:	c2 38       	rjmp	80009b9a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80009b56:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80009b5a:	06 9a       	mov	r10,r3
80009b5c:	40 0b       	lddsp	r11,sp[0x0]
80009b5e:	5c 5b       	castu.b	r11
80009b60:	68 0c       	ld.w	r12,r4[0x0]
80009b62:	f0 1f 00 30 	mcall	80009c20 <log+0x160>
80009b66:	06 9c       	mov	r12,r3
							break;
80009b68:	c1 98       	rjmp	80009b9a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80009b6a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80009b6e:	06 9b       	mov	r11,r3
80009b70:	09 bc       	ld.ub	r12,r4[0x3]
80009b72:	f0 1f 00 2d 	mcall	80009c24 <log+0x164>
80009b76:	06 9c       	mov	r12,r3
							break;
80009b78:	c1 18       	rjmp	80009b9a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80009b7a:	e8 c5 ff fc 	sub	r5,r4,-4
80009b7e:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80009b80:	c0 d8       	rjmp	80009b9a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80009b82:	06 9b       	mov	r11,r3
80009b84:	32 5c       	mov	r12,37
80009b86:	f0 1f 00 28 	mcall	80009c24 <log+0x164>
80009b8a:	08 95       	mov	r5,r4
80009b8c:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80009b8e:	c0 68       	rjmp	80009b9a <log+0xda>
							
							default:
							log("I need relax.");
80009b90:	4a 6c       	lddpc	r12,80009c28 <log+0x168>
80009b92:	f0 1f 00 23 	mcall	80009c1c <log+0x15c>
80009b96:	08 95       	mov	r5,r4
80009b98:	06 9c       	mov	r12,r3
						}
						str++;
80009b9a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80009b9c:	1a dc       	st.w	--sp,r12
80009b9e:	1a d6       	st.w	--sp,r6
80009ba0:	4a 3b       	lddpc	r11,80009c2c <log+0x16c>
80009ba2:	0c 9c       	mov	r12,r6
80009ba4:	f0 1f 00 23 	mcall	80009c30 <log+0x170>
80009ba8:	2f ed       	sub	sp,-8
80009baa:	c0 a8       	rjmp	80009bbe <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80009bac:	2f f7       	sub	r7,-1
80009bae:	1a d8       	st.w	--sp,r8
80009bb0:	1a d6       	st.w	--sp,r6
80009bb2:	4a 1b       	lddpc	r11,80009c34 <log+0x174>
80009bb4:	0c 9c       	mov	r12,r6
80009bb6:	f0 1f 00 1f 	mcall	80009c30 <log+0x170>
80009bba:	08 95       	mov	r5,r4
80009bbc:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80009bbe:	0f 89       	ld.ub	r9,r7[0x0]
80009bc0:	30 08       	mov	r8,0
80009bc2:	f0 09 18 00 	cp.b	r9,r8
80009bc6:	c0 30       	breq	80009bcc <log+0x10c>
80009bc8:	0a 94       	mov	r4,r5
80009bca:	c9 2b       	rjmp	80009aee <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80009bcc:	fa c7 fe f8 	sub	r7,sp,-264
80009bd0:	1a d7       	st.w	--sp,r7
80009bd2:	49 ab       	lddpc	r11,80009c38 <log+0x178>
80009bd4:	0e 9c       	mov	r12,r7
80009bd6:	f0 1f 00 17 	mcall	80009c30 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80009bda:	5c 5c       	castu.b	r12
80009bdc:	f8 c6 ff ff 	sub	r6,r12,-1
80009be0:	0c 9c       	mov	r12,r6
80009be2:	f0 1f 00 17 	mcall	80009c3c <log+0x17c>
80009be6:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80009be8:	0c 9a       	mov	r10,r6
80009bea:	0e 9b       	mov	r11,r7
80009bec:	f0 1f 00 15 	mcall	80009c40 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
80009bf0:	30 09       	mov	r9,0
80009bf2:	30 5a       	mov	r10,5
80009bf4:	fa cb fe f8 	sub	r11,sp,-264
80009bf8:	49 38       	lddpc	r8,80009c44 <log+0x184>
80009bfa:	70 0c       	ld.w	r12,r8[0x0]
80009bfc:	f0 1f 00 13 	mcall	80009c48 <log+0x188>
80009c00:	2f fd       	sub	sp,-4
}
80009c02:	fe 3d fd f8 	sub	sp,-520
80009c06:	d8 32       	popm	r0-r7,pc
80009c08:	80 00       	ld.sh	r0,r0[0x0]
80009c0a:	a5 ce       	cbr	lr,0x4
80009c0c:	00 00       	add	r0,r0
80009c0e:	12 90       	mov	r0,r9
80009c10:	80 01       	ld.sh	r1,r0[0x0]
80009c12:	8b e0       	st.w	r5[0x38],r0
80009c14:	80 00       	ld.sh	r0,r0[0x0]
80009c16:	99 e6       	st.w	r12[0x38],r6
80009c18:	80 01       	ld.sh	r1,r0[0x0]
80009c1a:	8e 8c       	ld.uh	r12,r7[0x0]
80009c1c:	80 00       	ld.sh	r0,r0[0x0]
80009c1e:	9a c0       	ld.uh	r0,sp[0x8]
80009c20:	80 00       	ld.sh	r0,r0[0x0]
80009c22:	99 34       	st.w	r12[0xc],r4
80009c24:	80 00       	ld.sh	r0,r0[0x0]
80009c26:	99 30       	st.w	r12[0xc],r0
80009c28:	80 01       	ld.sh	r1,r0[0x0]
80009c2a:	8e 9c       	ld.uh	r12,r7[0x2]
80009c2c:	80 01       	ld.sh	r1,r0[0x0]
80009c2e:	8e ac       	ld.uh	r12,r7[0x4]
80009c30:	80 00       	ld.sh	r0,r0[0x0]
80009c32:	a8 bc       	st.b	r4[0x3],r12
80009c34:	80 01       	ld.sh	r1,r0[0x0]
80009c36:	8e b4       	ld.uh	r4,r7[0x6]
80009c38:	80 01       	ld.sh	r1,r0[0x0]
80009c3a:	8e bc       	ld.uh	r12,r7[0x6]
80009c3c:	80 00       	ld.sh	r0,r0[0x0]
80009c3e:	8b 7c       	st.w	r5[0x1c],r12
80009c40:	80 00       	ld.sh	r0,r0[0x0]
80009c42:	a4 86       	st.b	r2[0x0],r6
80009c44:	00 00       	add	r0,r0
80009c46:	46 24       	lddsp	r4,sp[0x188]
80009c48:	80 00       	ld.sh	r0,r0[0x0]
80009c4a:	8e d0       	ld.uh	r0,r7[0xa]

80009c4c <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80009c4c:	d4 31       	pushm	r0-r7,lr
80009c4e:	fa cd 02 0c 	sub	sp,sp,524
80009c52:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80009c54:	e0 6a 01 00 	mov	r10,256
80009c58:	30 0b       	mov	r11,0
80009c5a:	fa cc fe f4 	sub	r12,sp,-268
80009c5e:	f0 1f 00 4c 	mcall	80009d8c <logFromISR+0x140>
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
}
	
	
int logFromISR(char * content, ...)
80009c62:	fa c4 fd d0 	sub	r4,sp,-560
80009c66:	30 0a       	mov	r10,0
80009c68:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009c6a:	fa c3 ff fc 	sub	r3,sp,-4
80009c6e:	e0 61 01 00 	mov	r1,256
80009c72:	14 90       	mov	r0,r10
			
			if(*str == '%')
80009c74:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80009c76:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009c7a:	02 9a       	mov	r10,r1
80009c7c:	00 9b       	mov	r11,r0
80009c7e:	06 9c       	mov	r12,r3
80009c80:	f0 1f 00 43 	mcall	80009d8c <logFromISR+0x140>
			
			if(*str == '%')
80009c84:	0f 88       	ld.ub	r8,r7[0x0]
80009c86:	e4 08 18 00 	cp.b	r8,r2
80009c8a:	c5 11       	brne	80009d2c <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80009c8c:	ee c8 ff ff 	sub	r8,r7,-1
80009c90:	11 89       	ld.ub	r9,r8[0x0]
80009c92:	4c 0a       	lddpc	r10,80009d90 <logFromISR+0x144>
80009c94:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80009c96:	23 09       	sub	r9,48
80009c98:	30 9a       	mov	r10,9
80009c9a:	f4 09 18 00 	cp.b	r9,r10
80009c9e:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80009ca2:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80009ca6:	f7 b9 08 30 	subls	r9,48
80009caa:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80009cae:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80009cb2:	0f 88       	ld.ub	r8,r7[0x0]
80009cb4:	22 58       	sub	r8,37
80009cb6:	e0 48 00 53 	cp.w	r8,83
80009cba:	e0 8b 00 2b 	brhi	80009d10 <logFromISR+0xc4>
80009cbe:	4b 69       	lddpc	r9,80009d94 <logFromISR+0x148>
80009cc0:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80009cc4:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80009cc8:	06 9a       	mov	r10,r3
80009cca:	40 0b       	lddsp	r11,sp[0x0]
80009ccc:	5c 5b       	castu.b	r11
80009cce:	68 0c       	ld.w	r12,r4[0x0]
80009cd0:	f0 1f 00 32 	mcall	80009d98 <logFromISR+0x14c>
					break;
80009cd4:	c2 38       	rjmp	80009d1a <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80009cd6:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80009cda:	06 9a       	mov	r10,r3
80009cdc:	40 0b       	lddsp	r11,sp[0x0]
80009cde:	5c 5b       	castu.b	r11
80009ce0:	68 0c       	ld.w	r12,r4[0x0]
80009ce2:	f0 1f 00 2f 	mcall	80009d9c <logFromISR+0x150>
80009ce6:	06 9c       	mov	r12,r3
					break;
80009ce8:	c1 98       	rjmp	80009d1a <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80009cea:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80009cee:	06 9b       	mov	r11,r3
80009cf0:	09 bc       	ld.ub	r12,r4[0x3]
80009cf2:	f0 1f 00 2c 	mcall	80009da0 <logFromISR+0x154>
80009cf6:	06 9c       	mov	r12,r3
					break;
80009cf8:	c1 18       	rjmp	80009d1a <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80009cfa:	e8 c5 ff fc 	sub	r5,r4,-4
80009cfe:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80009d00:	c0 d8       	rjmp	80009d1a <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80009d02:	06 9b       	mov	r11,r3
80009d04:	32 5c       	mov	r12,37
80009d06:	f0 1f 00 27 	mcall	80009da0 <logFromISR+0x154>
80009d0a:	08 95       	mov	r5,r4
80009d0c:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80009d0e:	c0 68       	rjmp	80009d1a <logFromISR+0xce>
					default:
					log("I need relax.");
80009d10:	4a 5c       	lddpc	r12,80009da4 <logFromISR+0x158>
80009d12:	f0 1f 00 26 	mcall	80009da8 <logFromISR+0x15c>
80009d16:	08 95       	mov	r5,r4
80009d18:	06 9c       	mov	r12,r3
				}
				str++;
80009d1a:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80009d1c:	1a dc       	st.w	--sp,r12
80009d1e:	1a d6       	st.w	--sp,r6
80009d20:	4a 3b       	lddpc	r11,80009dac <logFromISR+0x160>
80009d22:	0c 9c       	mov	r12,r6
80009d24:	f0 1f 00 23 	mcall	80009db0 <logFromISR+0x164>
80009d28:	2f ed       	sub	sp,-8
80009d2a:	c0 a8       	rjmp	80009d3e <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80009d2c:	2f f7       	sub	r7,-1
80009d2e:	1a d8       	st.w	--sp,r8
80009d30:	1a d6       	st.w	--sp,r6
80009d32:	4a 1b       	lddpc	r11,80009db4 <logFromISR+0x168>
80009d34:	0c 9c       	mov	r12,r6
80009d36:	f0 1f 00 1f 	mcall	80009db0 <logFromISR+0x164>
80009d3a:	08 95       	mov	r5,r4
80009d3c:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80009d3e:	0f 89       	ld.ub	r9,r7[0x0]
80009d40:	30 08       	mov	r8,0
80009d42:	f0 09 18 00 	cp.b	r9,r8
80009d46:	c0 30       	breq	80009d4c <logFromISR+0x100>
80009d48:	0a 94       	mov	r4,r5
80009d4a:	c9 8b       	rjmp	80009c7a <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80009d4c:	fa c7 fe f4 	sub	r7,sp,-268
80009d50:	1a d7       	st.w	--sp,r7
80009d52:	49 ab       	lddpc	r11,80009db8 <logFromISR+0x16c>
80009d54:	0e 9c       	mov	r12,r7
80009d56:	f0 1f 00 17 	mcall	80009db0 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80009d5a:	5c 5c       	castu.b	r12
80009d5c:	f8 c6 ff ff 	sub	r6,r12,-1
80009d60:	0c 9c       	mov	r12,r6
80009d62:	f0 1f 00 17 	mcall	80009dbc <logFromISR+0x170>
80009d66:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80009d68:	0c 9a       	mov	r10,r6
80009d6a:	0e 9b       	mov	r11,r7
80009d6c:	f0 1f 00 15 	mcall	80009dc0 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80009d70:	30 09       	mov	r9,0
80009d72:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80009d74:	fa ca fe f8 	sub	r10,sp,-264
80009d78:	fa cb fe f4 	sub	r11,sp,-268
80009d7c:	49 28       	lddpc	r8,80009dc4 <logFromISR+0x178>
80009d7e:	70 0c       	ld.w	r12,r8[0x0]
80009d80:	f0 1f 00 12 	mcall	80009dc8 <logFromISR+0x17c>
80009d84:	2f fd       	sub	sp,-4
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80009d86:	fe 3d fd f4 	sub	sp,-524
80009d8a:	d8 32       	popm	r0-r7,pc
80009d8c:	80 00       	ld.sh	r0,r0[0x0]
80009d8e:	a5 ce       	cbr	lr,0x4
80009d90:	00 00       	add	r0,r0
80009d92:	12 91       	mov	r1,r9
80009d94:	80 01       	ld.sh	r1,r0[0x0]
80009d96:	8d 30       	st.w	r6[0xc],r0
80009d98:	80 00       	ld.sh	r0,r0[0x0]
80009d9a:	99 e6       	st.w	r12[0x38],r6
80009d9c:	80 00       	ld.sh	r0,r0[0x0]
80009d9e:	99 34       	st.w	r12[0xc],r4
80009da0:	80 00       	ld.sh	r0,r0[0x0]
80009da2:	99 30       	st.w	r12[0xc],r0
80009da4:	80 01       	ld.sh	r1,r0[0x0]
80009da6:	8e 9c       	ld.uh	r12,r7[0x2]
80009da8:	80 00       	ld.sh	r0,r0[0x0]
80009daa:	9a c0       	ld.uh	r0,sp[0x8]
80009dac:	80 01       	ld.sh	r1,r0[0x0]
80009dae:	8e ac       	ld.uh	r12,r7[0x4]
80009db0:	80 00       	ld.sh	r0,r0[0x0]
80009db2:	a8 bc       	st.b	r4[0x3],r12
80009db4:	80 01       	ld.sh	r1,r0[0x0]
80009db6:	8e b4       	ld.uh	r4,r7[0x6]
80009db8:	80 01       	ld.sh	r1,r0[0x0]
80009dba:	8e bc       	ld.uh	r12,r7[0x6]
80009dbc:	80 00       	ld.sh	r0,r0[0x0]
80009dbe:	8b 7c       	st.w	r5[0x1c],r12
80009dc0:	80 00       	ld.sh	r0,r0[0x0]
80009dc2:	a4 86       	st.b	r2[0x0],r6
80009dc4:	00 00       	add	r0,r0
80009dc6:	46 24       	lddsp	r4,sp[0x188]
80009dc8:	80 00       	ld.sh	r0,r0[0x0]
80009dca:	8e 80       	ld.uh	r0,r7[0x0]

80009dcc <log_init>:
		
	return str;
}

void log_init(void)
{
80009dcc:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80009dce:	30 2b       	mov	r11,2
80009dd0:	49 0c       	lddpc	r12,80009e10 <log_init+0x44>
80009dd2:	f0 1f 00 11 	mcall	80009e14 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80009dd6:	e0 6a 36 00 	mov	r10,13824
80009dda:	ea 1a 01 6e 	orh	r10,0x16e
80009dde:	48 fb       	lddpc	r11,80009e18 <log_init+0x4c>
80009de0:	fe 7c 18 00 	mov	r12,-59392
80009de4:	f0 1f 00 0e 	mcall	80009e1c <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80009de8:	30 4b       	mov	r11,4
80009dea:	33 2c       	mov	r12,50
80009dec:	f0 1f 00 0d 	mcall	80009e20 <log_init+0x54>
80009df0:	48 d8       	lddpc	r8,80009e24 <log_init+0x58>
80009df2:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80009df4:	30 09       	mov	r9,0
80009df6:	1a d9       	st.w	--sp,r9
80009df8:	1a d9       	st.w	--sp,r9
80009dfa:	1a d9       	st.w	--sp,r9
80009dfc:	30 28       	mov	r8,2
80009dfe:	e0 6a 01 80 	mov	r10,384
80009e02:	48 ab       	lddpc	r11,80009e28 <log_init+0x5c>
80009e04:	48 ac       	lddpc	r12,80009e2c <log_init+0x60>
80009e06:	f0 1f 00 0b 	mcall	80009e30 <log_init+0x64>
80009e0a:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80009e0c:	d8 02       	popm	pc
80009e0e:	00 00       	add	r0,r0
80009e10:	80 01       	ld.sh	r1,r0[0x0]
80009e12:	8e c8       	ld.uh	r8,r7[0x8]
80009e14:	80 00       	ld.sh	r0,r0[0x0]
80009e16:	9f 60       	st.w	pc[0x18],r0
80009e18:	80 01       	ld.sh	r1,r0[0x0]
80009e1a:	8e 80       	ld.uh	r0,r7[0x0]
80009e1c:	80 00       	ld.sh	r0,r0[0x0]
80009e1e:	61 50       	ld.w	r0,r0[0x54]
80009e20:	80 00       	ld.sh	r0,r0[0x0]
80009e22:	90 28       	ld.sh	r8,r8[0x4]
80009e24:	00 00       	add	r0,r0
80009e26:	46 24       	lddsp	r4,sp[0x188]
80009e28:	80 01       	ld.sh	r1,r0[0x0]
80009e2a:	8e c4       	ld.uh	r4,r7[0x8]
80009e2c:	80 00       	ld.sh	r0,r0[0x0]
80009e2e:	9e 34       	ld.sh	r4,pc[0x6]
80009e30:	80 00       	ld.sh	r0,r0[0x0]
80009e32:	96 fc       	ld.uh	r12,r11[0xe]

80009e34 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80009e34:	eb cd 40 f8 	pushm	r3-r7,lr
80009e38:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80009e3a:	48 c7       	lddpc	r7,80009e68 <task_log+0x34>
80009e3c:	30 05       	mov	r5,0
80009e3e:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80009e40:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80009e44:	0a 99       	mov	r9,r5
80009e46:	08 9a       	mov	r10,r4
80009e48:	1a 9b       	mov	r11,sp
80009e4a:	6e 0c       	ld.w	r12,r7[0x0]
80009e4c:	f0 1f 00 08 	mcall	80009e6c <task_log+0x38>
80009e50:	58 1c       	cp.w	r12,1
80009e52:	cf 91       	brne	80009e44 <task_log+0x10>
		{
			if( NULL != str)
80009e54:	40 0b       	lddsp	r11,sp[0x0]
80009e56:	58 0b       	cp.w	r11,0
80009e58:	cf 60       	breq	80009e44 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80009e5a:	06 9c       	mov	r12,r3
80009e5c:	f0 1f 00 05 	mcall	80009e70 <task_log+0x3c>
				vPortFree(str);
80009e60:	40 0c       	lddsp	r12,sp[0x0]
80009e62:	f0 1f 00 05 	mcall	80009e74 <task_log+0x40>
80009e66:	ce fb       	rjmp	80009e44 <task_log+0x10>
80009e68:	00 00       	add	r0,r0
80009e6a:	46 24       	lddsp	r4,sp[0x188]
80009e6c:	80 00       	ld.sh	r0,r0[0x0]
80009e6e:	8c c4       	ld.uh	r4,r6[0x8]
80009e70:	80 00       	ld.sh	r0,r0[0x0]
80009e72:	61 00       	ld.w	r0,r0[0x40]
80009e74:	80 00       	ld.sh	r0,r0[0x0]
80009e76:	8b 54       	st.w	r5[0x14],r4

80009e78 <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
80009e78:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80009e7a:	fe 78 10 00 	mov	r8,-61440
80009e7e:	30 19       	mov	r9,1
80009e80:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80009e84:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80009e88:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80009e8c:	d3 03       	ssrf	0x10
	local_start_pll0();
80009e8e:	f0 1f 00 14 	mcall	80009edc <main+0x64>
		
	INTC_init_interrupts();
80009e92:	f0 1f 00 14 	mcall	80009ee0 <main+0x68>
	
	log_init();		
80009e96:	f0 1f 00 14 	mcall	80009ee4 <main+0x6c>
	log("----start debug----");	
80009e9a:	49 4c       	lddpc	r12,80009ee8 <main+0x70>
80009e9c:	f0 1f 00 14 	mcall	80009eec <main+0x74>
		
	rtc_init();
80009ea0:	f0 1f 00 14 	mcall	80009ef0 <main+0x78>
	
	fs_init();//65795
80009ea4:	f0 1f 00 14 	mcall	80009ef4 <main+0x7c>

	tc_init();	
80009ea8:	f0 1f 00 14 	mcall	80009ef8 <main+0x80>
			
	xcmp_init();
80009eac:	f0 1f 00 14 	mcall	80009efc <main+0x84>
	
	app_init();
80009eb0:	f0 1f 00 14 	mcall	80009f00 <main+0x88>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80009eb4:	fe 79 10 00 	mov	r9,-61440
80009eb8:	f2 f8 01 60 	ld.w	r8,r9[352]
80009ebc:	e2 18 00 02 	andl	r8,0x2,COH
80009ec0:	cf c0       	breq	80009eb8 <main+0x40>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80009ec2:	fe 79 10 00 	mov	r9,-61440
80009ec6:	f2 f8 01 60 	ld.w	r8,r9[352]
80009eca:	e2 18 00 02 	andl	r8,0x2,COH
80009ece:	cf c1       	brne	80009ec6 <main+0x4e>
	local_start_timer();
80009ed0:	f0 1f 00 0d 	mcall	80009f04 <main+0x8c>
	
	Enable_global_interrupt();
80009ed4:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
80009ed6:	f0 1f 00 0d 	mcall	80009f08 <main+0x90>
	return 0;
}
80009eda:	d8 0a       	popm	pc,r12=0
80009edc:	80 00       	ld.sh	r0,r0[0x0]
80009ede:	56 c8       	stdsp	sp[0x1b0],r8
80009ee0:	80 00       	ld.sh	r0,r0[0x0]
80009ee2:	5a 60       	cp.w	r0,-26
80009ee4:	80 00       	ld.sh	r0,r0[0x0]
80009ee6:	9d cc       	st.w	lr[0x30],r12
80009ee8:	80 01       	ld.sh	r1,r0[0x0]
80009eea:	8e d8       	ld.uh	r8,r7[0xa]
80009eec:	80 00       	ld.sh	r0,r0[0x0]
80009eee:	9a c0       	ld.uh	r0,sp[0x8]
80009ef0:	80 00       	ld.sh	r0,r0[0x0]
80009ef2:	58 94       	cp.w	r4,9
80009ef4:	80 00       	ld.sh	r0,r0[0x0]
80009ef6:	39 0c       	mov	r12,-112
80009ef8:	80 00       	ld.sh	r0,r0[0x0]
80009efa:	59 5c       	cp.w	r12,21
80009efc:	80 00       	ld.sh	r0,r0[0x0]
80009efe:	4f cc       	lddpc	r12,8000a0ec <_malloc_r+0xc4>
80009f00:	80 00       	ld.sh	r0,r0[0x0]
80009f02:	20 44       	sub	r4,4
80009f04:	80 00       	ld.sh	r0,r0[0x0]
80009f06:	59 20       	cp.w	r0,18
80009f08:	80 00       	ld.sh	r0,r0[0x0]
80009f0a:	98 e4       	ld.uh	r4,r12[0xc]

80009f0c <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80009f0c:	f8 08 16 05 	lsr	r8,r12,0x5
80009f10:	a9 68       	lsl	r8,0x8
80009f12:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80009f16:	58 1b       	cp.w	r11,1
80009f18:	c0 d0       	breq	80009f32 <gpio_enable_module_pin+0x26>
80009f1a:	c0 63       	brcs	80009f26 <gpio_enable_module_pin+0x1a>
80009f1c:	58 2b       	cp.w	r11,2
80009f1e:	c1 00       	breq	80009f3e <gpio_enable_module_pin+0x32>
80009f20:	58 3b       	cp.w	r11,3
80009f22:	c1 40       	breq	80009f4a <gpio_enable_module_pin+0x3e>
80009f24:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80009f26:	30 19       	mov	r9,1
80009f28:	f2 0c 09 49 	lsl	r9,r9,r12
80009f2c:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80009f2e:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80009f30:	c1 28       	rjmp	80009f54 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80009f32:	30 19       	mov	r9,1
80009f34:	f2 0c 09 49 	lsl	r9,r9,r12
80009f38:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80009f3a:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80009f3c:	c0 c8       	rjmp	80009f54 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80009f3e:	30 19       	mov	r9,1
80009f40:	f2 0c 09 49 	lsl	r9,r9,r12
80009f44:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80009f46:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80009f48:	c0 68       	rjmp	80009f54 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80009f4a:	30 19       	mov	r9,1
80009f4c:	f2 0c 09 49 	lsl	r9,r9,r12
80009f50:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80009f52:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80009f54:	30 19       	mov	r9,1
80009f56:	f2 0c 09 4c 	lsl	r12,r9,r12
80009f5a:	91 2c       	st.w	r8[0x8],r12
80009f5c:	5e fd       	retal	0
80009f5e:	d7 03       	nop

80009f60 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80009f60:	d4 21       	pushm	r4-r7,lr
80009f62:	18 97       	mov	r7,r12
80009f64:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80009f66:	58 0b       	cp.w	r11,0
80009f68:	c0 31       	brne	80009f6e <gpio_enable_module+0xe>
80009f6a:	30 05       	mov	r5,0
80009f6c:	c0 d8       	rjmp	80009f86 <gpio_enable_module+0x26>
80009f6e:	30 06       	mov	r6,0
80009f70:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80009f72:	6e 1b       	ld.w	r11,r7[0x4]
80009f74:	6e 0c       	ld.w	r12,r7[0x0]
80009f76:	f0 1f 00 06 	mcall	80009f8c <gpio_enable_module+0x2c>
80009f7a:	18 45       	or	r5,r12
		gpiomap++;
80009f7c:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80009f7e:	2f f6       	sub	r6,-1
80009f80:	0c 34       	cp.w	r4,r6
80009f82:	fe 9b ff f8 	brhi	80009f72 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80009f86:	0a 9c       	mov	r12,r5
80009f88:	d8 22       	popm	r4-r7,pc
80009f8a:	00 00       	add	r0,r0
80009f8c:	80 00       	ld.sh	r0,r0[0x0]
80009f8e:	9f 0c       	st.w	pc[0x0],r12

80009f90 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80009f90:	f8 08 16 05 	lsr	r8,r12,0x5
80009f94:	a9 68       	lsl	r8,0x8
80009f96:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);																				
80009f9a:	30 19       	mov	r9,1
80009f9c:	f2 0c 09 4c 	lsl	r12,r9,r12
80009fa0:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80009fa4:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80009fa8:	91 1c       	st.w	r8[0x4],r12
}
80009faa:	5e fc       	retal	r12

80009fac <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80009fac:	f8 08 16 05 	lsr	r8,r12,0x5
80009fb0:	a9 68       	lsl	r8,0x8
80009fb2:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80009fb6:	30 19       	mov	r9,1
80009fb8:	f2 0c 09 4c 	lsl	r12,r9,r12
80009fbc:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80009fc0:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80009fc4:	91 1c       	st.w	r8[0x4],r12
}
80009fc6:	5e fc       	retal	r12

80009fc8 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80009fc8:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80009fcc:	fe c0 a3 cc 	sub	r0,pc,-23604

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80009fd0:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80009fd4:	d5 53       	csrf	0x15
  cp      r0, r1
80009fd6:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80009fd8:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80009fdc:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80009fde:	c0 62       	brcc	80009fea <idata_load_loop_end>
  cp      r0, r1
80009fe0:	48 92       	lddpc	r2,8000a004 <udata_clear_loop_end+0x4>

80009fe2 <idata_load_loop>:
  brlo    idata_load_loop
80009fe2:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80009fe4:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80009fe6:	02 30       	cp.w	r0,r1
  cp      r0, r1
80009fe8:	cf d3       	brcs	80009fe2 <idata_load_loop>

80009fea <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80009fea:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80009fee:	e0 61 46 30 	mov	r1,17968
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80009ff2:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80009ff4:	c0 62       	brcc	8000a000 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80009ff6:	30 02       	mov	r2,0
80009ff8:	30 03       	mov	r3,0

80009ffa <udata_clear_loop>:
80009ffa:	a1 22       	st.d	r0++,r2
80009ffc:	02 30       	cp.w	r0,r1
80009ffe:	cf e3       	brcs	80009ffa <udata_clear_loop>

8000a000 <udata_clear_loop_end>:
8000a000:	fe cf 01 88 	sub	pc,pc,392
8000a004:	80 01       	ld.sh	r1,r0[0x0]
8000a006:	94 70       	ld.sh	r0,r10[0xe]

8000a008 <free>:
8000a008:	d4 01       	pushm	lr
8000a00a:	e0 68 0a 38 	mov	r8,2616
8000a00e:	18 9b       	mov	r11,r12
8000a010:	70 0c       	ld.w	r12,r8[0x0]
8000a012:	e0 a0 1f 19 	rcall	8000de44 <_free_r>
8000a016:	d8 02       	popm	pc

8000a018 <malloc>:
8000a018:	d4 01       	pushm	lr
8000a01a:	e0 68 0a 38 	mov	r8,2616
8000a01e:	18 9b       	mov	r11,r12
8000a020:	70 0c       	ld.w	r12,r8[0x0]
8000a022:	c0 3c       	rcall	8000a028 <_malloc_r>
8000a024:	d8 02       	popm	pc
8000a026:	d7 03       	nop

8000a028 <_malloc_r>:
8000a028:	d4 31       	pushm	r0-r7,lr
8000a02a:	f6 c8 ff f5 	sub	r8,r11,-11
8000a02e:	18 95       	mov	r5,r12
8000a030:	10 97       	mov	r7,r8
8000a032:	e0 17 ff f8 	andl	r7,0xfff8
8000a036:	59 68       	cp.w	r8,22
8000a038:	f9 b7 08 10 	movls	r7,16
8000a03c:	16 37       	cp.w	r7,r11
8000a03e:	5f 38       	srlo	r8
8000a040:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000a044:	c0 50       	breq	8000a04e <_malloc_r+0x26>
8000a046:	30 c8       	mov	r8,12
8000a048:	99 38       	st.w	r12[0xc],r8
8000a04a:	e0 8f 01 fa 	bral	8000a43e <_malloc_r+0x416>
8000a04e:	fe b0 f5 39 	rcall	80008ac0 <__malloc_lock>
8000a052:	e0 47 01 f7 	cp.w	r7,503
8000a056:	e0 8b 00 1d 	brhi	8000a090 <_malloc_r+0x68>
8000a05a:	ee 03 16 03 	lsr	r3,r7,0x3
8000a05e:	e0 68 05 38 	mov	r8,1336
8000a062:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000a066:	70 36       	ld.w	r6,r8[0xc]
8000a068:	10 36       	cp.w	r6,r8
8000a06a:	c0 61       	brne	8000a076 <_malloc_r+0x4e>
8000a06c:	ec c8 ff f8 	sub	r8,r6,-8
8000a070:	70 36       	ld.w	r6,r8[0xc]
8000a072:	10 36       	cp.w	r6,r8
8000a074:	c0 c0       	breq	8000a08c <_malloc_r+0x64>
8000a076:	6c 18       	ld.w	r8,r6[0x4]
8000a078:	e0 18 ff fc 	andl	r8,0xfffc
8000a07c:	6c 3a       	ld.w	r10,r6[0xc]
8000a07e:	ec 08 00 09 	add	r9,r6,r8
8000a082:	0a 9c       	mov	r12,r5
8000a084:	6c 28       	ld.w	r8,r6[0x8]
8000a086:	95 28       	st.w	r10[0x8],r8
8000a088:	91 3a       	st.w	r8[0xc],r10
8000a08a:	c4 78       	rjmp	8000a118 <_malloc_r+0xf0>
8000a08c:	2f e3       	sub	r3,-2
8000a08e:	c4 d8       	rjmp	8000a128 <_malloc_r+0x100>
8000a090:	ee 03 16 09 	lsr	r3,r7,0x9
8000a094:	c0 41       	brne	8000a09c <_malloc_r+0x74>
8000a096:	ee 03 16 03 	lsr	r3,r7,0x3
8000a09a:	c2 68       	rjmp	8000a0e6 <_malloc_r+0xbe>
8000a09c:	58 43       	cp.w	r3,4
8000a09e:	e0 8b 00 06 	brhi	8000a0aa <_malloc_r+0x82>
8000a0a2:	ee 03 16 06 	lsr	r3,r7,0x6
8000a0a6:	2c 83       	sub	r3,-56
8000a0a8:	c1 f8       	rjmp	8000a0e6 <_malloc_r+0xbe>
8000a0aa:	59 43       	cp.w	r3,20
8000a0ac:	e0 8b 00 04 	brhi	8000a0b4 <_malloc_r+0x8c>
8000a0b0:	2a 53       	sub	r3,-91
8000a0b2:	c1 a8       	rjmp	8000a0e6 <_malloc_r+0xbe>
8000a0b4:	e0 43 00 54 	cp.w	r3,84
8000a0b8:	e0 8b 00 06 	brhi	8000a0c4 <_malloc_r+0x9c>
8000a0bc:	ee 03 16 0c 	lsr	r3,r7,0xc
8000a0c0:	29 23       	sub	r3,-110
8000a0c2:	c1 28       	rjmp	8000a0e6 <_malloc_r+0xbe>
8000a0c4:	e0 43 01 54 	cp.w	r3,340
8000a0c8:	e0 8b 00 06 	brhi	8000a0d4 <_malloc_r+0xac>
8000a0cc:	ee 03 16 0f 	lsr	r3,r7,0xf
8000a0d0:	28 93       	sub	r3,-119
8000a0d2:	c0 a8       	rjmp	8000a0e6 <_malloc_r+0xbe>
8000a0d4:	e0 43 05 54 	cp.w	r3,1364
8000a0d8:	e0 88 00 04 	brls	8000a0e0 <_malloc_r+0xb8>
8000a0dc:	37 e3       	mov	r3,126
8000a0de:	c0 48       	rjmp	8000a0e6 <_malloc_r+0xbe>
8000a0e0:	ee 03 16 12 	lsr	r3,r7,0x12
8000a0e4:	28 43       	sub	r3,-124
8000a0e6:	e0 6a 05 38 	mov	r10,1336
8000a0ea:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000a0ee:	74 36       	ld.w	r6,r10[0xc]
8000a0f0:	c1 98       	rjmp	8000a122 <_malloc_r+0xfa>
8000a0f2:	6c 19       	ld.w	r9,r6[0x4]
8000a0f4:	e0 19 ff fc 	andl	r9,0xfffc
8000a0f8:	f2 07 01 0b 	sub	r11,r9,r7
8000a0fc:	58 fb       	cp.w	r11,15
8000a0fe:	e0 8a 00 04 	brle	8000a106 <_malloc_r+0xde>
8000a102:	20 13       	sub	r3,1
8000a104:	c1 18       	rjmp	8000a126 <_malloc_r+0xfe>
8000a106:	6c 38       	ld.w	r8,r6[0xc]
8000a108:	58 0b       	cp.w	r11,0
8000a10a:	c0 b5       	brlt	8000a120 <_malloc_r+0xf8>
8000a10c:	6c 2a       	ld.w	r10,r6[0x8]
8000a10e:	ec 09 00 09 	add	r9,r6,r9
8000a112:	0a 9c       	mov	r12,r5
8000a114:	91 2a       	st.w	r8[0x8],r10
8000a116:	95 38       	st.w	r10[0xc],r8
8000a118:	72 18       	ld.w	r8,r9[0x4]
8000a11a:	a1 a8       	sbr	r8,0x0
8000a11c:	93 18       	st.w	r9[0x4],r8
8000a11e:	cb c8       	rjmp	8000a296 <_malloc_r+0x26e>
8000a120:	10 96       	mov	r6,r8
8000a122:	14 36       	cp.w	r6,r10
8000a124:	ce 71       	brne	8000a0f2 <_malloc_r+0xca>
8000a126:	2f f3       	sub	r3,-1
8000a128:	e0 6a 05 38 	mov	r10,1336
8000a12c:	f4 cc ff f8 	sub	r12,r10,-8
8000a130:	78 26       	ld.w	r6,r12[0x8]
8000a132:	18 36       	cp.w	r6,r12
8000a134:	c6 c0       	breq	8000a20c <_malloc_r+0x1e4>
8000a136:	6c 19       	ld.w	r9,r6[0x4]
8000a138:	e0 19 ff fc 	andl	r9,0xfffc
8000a13c:	f2 07 01 08 	sub	r8,r9,r7
8000a140:	58 f8       	cp.w	r8,15
8000a142:	e0 89 00 8f 	brgt	8000a260 <_malloc_r+0x238>
8000a146:	99 3c       	st.w	r12[0xc],r12
8000a148:	99 2c       	st.w	r12[0x8],r12
8000a14a:	58 08       	cp.w	r8,0
8000a14c:	c0 55       	brlt	8000a156 <_malloc_r+0x12e>
8000a14e:	ec 09 00 09 	add	r9,r6,r9
8000a152:	0a 9c       	mov	r12,r5
8000a154:	ce 2b       	rjmp	8000a118 <_malloc_r+0xf0>
8000a156:	e0 49 01 ff 	cp.w	r9,511
8000a15a:	e0 8b 00 13 	brhi	8000a180 <_malloc_r+0x158>
8000a15e:	a3 99       	lsr	r9,0x3
8000a160:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000a164:	70 2b       	ld.w	r11,r8[0x8]
8000a166:	8d 38       	st.w	r6[0xc],r8
8000a168:	8d 2b       	st.w	r6[0x8],r11
8000a16a:	97 36       	st.w	r11[0xc],r6
8000a16c:	91 26       	st.w	r8[0x8],r6
8000a16e:	a3 49       	asr	r9,0x2
8000a170:	74 18       	ld.w	r8,r10[0x4]
8000a172:	30 1b       	mov	r11,1
8000a174:	f6 09 09 49 	lsl	r9,r11,r9
8000a178:	f1 e9 10 09 	or	r9,r8,r9
8000a17c:	95 19       	st.w	r10[0x4],r9
8000a17e:	c4 78       	rjmp	8000a20c <_malloc_r+0x1e4>
8000a180:	f2 0a 16 09 	lsr	r10,r9,0x9
8000a184:	58 4a       	cp.w	r10,4
8000a186:	e0 8b 00 07 	brhi	8000a194 <_malloc_r+0x16c>
8000a18a:	f2 0a 16 06 	lsr	r10,r9,0x6
8000a18e:	2c 8a       	sub	r10,-56
8000a190:	c2 08       	rjmp	8000a1d0 <_malloc_r+0x1a8>
8000a192:	d7 03       	nop
8000a194:	59 4a       	cp.w	r10,20
8000a196:	e0 8b 00 04 	brhi	8000a19e <_malloc_r+0x176>
8000a19a:	2a 5a       	sub	r10,-91
8000a19c:	c1 a8       	rjmp	8000a1d0 <_malloc_r+0x1a8>
8000a19e:	e0 4a 00 54 	cp.w	r10,84
8000a1a2:	e0 8b 00 06 	brhi	8000a1ae <_malloc_r+0x186>
8000a1a6:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000a1aa:	29 2a       	sub	r10,-110
8000a1ac:	c1 28       	rjmp	8000a1d0 <_malloc_r+0x1a8>
8000a1ae:	e0 4a 01 54 	cp.w	r10,340
8000a1b2:	e0 8b 00 06 	brhi	8000a1be <_malloc_r+0x196>
8000a1b6:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000a1ba:	28 9a       	sub	r10,-119
8000a1bc:	c0 a8       	rjmp	8000a1d0 <_malloc_r+0x1a8>
8000a1be:	e0 4a 05 54 	cp.w	r10,1364
8000a1c2:	e0 88 00 04 	brls	8000a1ca <_malloc_r+0x1a2>
8000a1c6:	37 ea       	mov	r10,126
8000a1c8:	c0 48       	rjmp	8000a1d0 <_malloc_r+0x1a8>
8000a1ca:	f2 0a 16 12 	lsr	r10,r9,0x12
8000a1ce:	28 4a       	sub	r10,-124
8000a1d0:	e0 6b 05 38 	mov	r11,1336
8000a1d4:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000a1d8:	68 28       	ld.w	r8,r4[0x8]
8000a1da:	08 38       	cp.w	r8,r4
8000a1dc:	c0 e1       	brne	8000a1f8 <_malloc_r+0x1d0>
8000a1de:	76 19       	ld.w	r9,r11[0x4]
8000a1e0:	a3 4a       	asr	r10,0x2
8000a1e2:	30 1e       	mov	lr,1
8000a1e4:	fc 0a 09 4a 	lsl	r10,lr,r10
8000a1e8:	f3 ea 10 0a 	or	r10,r9,r10
8000a1ec:	10 99       	mov	r9,r8
8000a1ee:	97 1a       	st.w	r11[0x4],r10
8000a1f0:	c0 a8       	rjmp	8000a204 <_malloc_r+0x1dc>
8000a1f2:	70 28       	ld.w	r8,r8[0x8]
8000a1f4:	08 38       	cp.w	r8,r4
8000a1f6:	c0 60       	breq	8000a202 <_malloc_r+0x1da>
8000a1f8:	70 1a       	ld.w	r10,r8[0x4]
8000a1fa:	e0 1a ff fc 	andl	r10,0xfffc
8000a1fe:	14 39       	cp.w	r9,r10
8000a200:	cf 93       	brcs	8000a1f2 <_malloc_r+0x1ca>
8000a202:	70 39       	ld.w	r9,r8[0xc]
8000a204:	8d 39       	st.w	r6[0xc],r9
8000a206:	8d 28       	st.w	r6[0x8],r8
8000a208:	91 36       	st.w	r8[0xc],r6
8000a20a:	93 26       	st.w	r9[0x8],r6
8000a20c:	e6 08 14 02 	asr	r8,r3,0x2
8000a210:	30 1b       	mov	r11,1
8000a212:	e0 64 05 38 	mov	r4,1336
8000a216:	f6 08 09 4b 	lsl	r11,r11,r8
8000a21a:	68 18       	ld.w	r8,r4[0x4]
8000a21c:	10 3b       	cp.w	r11,r8
8000a21e:	e0 8b 00 6b 	brhi	8000a2f4 <_malloc_r+0x2cc>
8000a222:	f7 e8 00 09 	and	r9,r11,r8
8000a226:	c0 b1       	brne	8000a23c <_malloc_r+0x214>
8000a228:	e0 13 ff fc 	andl	r3,0xfffc
8000a22c:	a1 7b       	lsl	r11,0x1
8000a22e:	2f c3       	sub	r3,-4
8000a230:	c0 38       	rjmp	8000a236 <_malloc_r+0x20e>
8000a232:	2f c3       	sub	r3,-4
8000a234:	a1 7b       	lsl	r11,0x1
8000a236:	f7 e8 00 09 	and	r9,r11,r8
8000a23a:	cf c0       	breq	8000a232 <_malloc_r+0x20a>
8000a23c:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000a240:	06 92       	mov	r2,r3
8000a242:	1c 91       	mov	r1,lr
8000a244:	62 36       	ld.w	r6,r1[0xc]
8000a246:	c2 e8       	rjmp	8000a2a2 <_malloc_r+0x27a>
8000a248:	6c 1a       	ld.w	r10,r6[0x4]
8000a24a:	e0 1a ff fc 	andl	r10,0xfffc
8000a24e:	f4 07 01 08 	sub	r8,r10,r7
8000a252:	58 f8       	cp.w	r8,15
8000a254:	e0 8a 00 15 	brle	8000a27e <_malloc_r+0x256>
8000a258:	6c 3a       	ld.w	r10,r6[0xc]
8000a25a:	6c 29       	ld.w	r9,r6[0x8]
8000a25c:	95 29       	st.w	r10[0x8],r9
8000a25e:	93 3a       	st.w	r9[0xc],r10
8000a260:	0e 99       	mov	r9,r7
8000a262:	ec 07 00 07 	add	r7,r6,r7
8000a266:	a1 a9       	sbr	r9,0x0
8000a268:	99 37       	st.w	r12[0xc],r7
8000a26a:	99 27       	st.w	r12[0x8],r7
8000a26c:	8d 19       	st.w	r6[0x4],r9
8000a26e:	ee 08 09 08 	st.w	r7[r8],r8
8000a272:	8f 2c       	st.w	r7[0x8],r12
8000a274:	8f 3c       	st.w	r7[0xc],r12
8000a276:	a1 a8       	sbr	r8,0x0
8000a278:	0a 9c       	mov	r12,r5
8000a27a:	8f 18       	st.w	r7[0x4],r8
8000a27c:	c0 d8       	rjmp	8000a296 <_malloc_r+0x26e>
8000a27e:	6c 39       	ld.w	r9,r6[0xc]
8000a280:	58 08       	cp.w	r8,0
8000a282:	c0 f5       	brlt	8000a2a0 <_malloc_r+0x278>
8000a284:	ec 0a 00 0a 	add	r10,r6,r10
8000a288:	74 18       	ld.w	r8,r10[0x4]
8000a28a:	a1 a8       	sbr	r8,0x0
8000a28c:	0a 9c       	mov	r12,r5
8000a28e:	95 18       	st.w	r10[0x4],r8
8000a290:	6c 28       	ld.w	r8,r6[0x8]
8000a292:	93 28       	st.w	r9[0x8],r8
8000a294:	91 39       	st.w	r8[0xc],r9
8000a296:	fe b0 f4 1b 	rcall	80008acc <__malloc_unlock>
8000a29a:	ec cc ff f8 	sub	r12,r6,-8
8000a29e:	d8 32       	popm	r0-r7,pc
8000a2a0:	12 96       	mov	r6,r9
8000a2a2:	02 36       	cp.w	r6,r1
8000a2a4:	cd 21       	brne	8000a248 <_malloc_r+0x220>
8000a2a6:	2f f2       	sub	r2,-1
8000a2a8:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000a2ac:	c0 30       	breq	8000a2b2 <_malloc_r+0x28a>
8000a2ae:	2f 81       	sub	r1,-8
8000a2b0:	cc ab       	rjmp	8000a244 <_malloc_r+0x21c>
8000a2b2:	1c 98       	mov	r8,lr
8000a2b4:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000a2b8:	c0 81       	brne	8000a2c8 <_malloc_r+0x2a0>
8000a2ba:	68 19       	ld.w	r9,r4[0x4]
8000a2bc:	f6 08 11 ff 	rsub	r8,r11,-1
8000a2c0:	f3 e8 00 08 	and	r8,r9,r8
8000a2c4:	89 18       	st.w	r4[0x4],r8
8000a2c6:	c0 78       	rjmp	8000a2d4 <_malloc_r+0x2ac>
8000a2c8:	f0 c9 00 08 	sub	r9,r8,8
8000a2cc:	20 13       	sub	r3,1
8000a2ce:	70 08       	ld.w	r8,r8[0x0]
8000a2d0:	12 38       	cp.w	r8,r9
8000a2d2:	cf 10       	breq	8000a2b4 <_malloc_r+0x28c>
8000a2d4:	a1 7b       	lsl	r11,0x1
8000a2d6:	68 18       	ld.w	r8,r4[0x4]
8000a2d8:	10 3b       	cp.w	r11,r8
8000a2da:	e0 8b 00 0d 	brhi	8000a2f4 <_malloc_r+0x2cc>
8000a2de:	58 0b       	cp.w	r11,0
8000a2e0:	c0 a0       	breq	8000a2f4 <_malloc_r+0x2cc>
8000a2e2:	04 93       	mov	r3,r2
8000a2e4:	c0 38       	rjmp	8000a2ea <_malloc_r+0x2c2>
8000a2e6:	2f c3       	sub	r3,-4
8000a2e8:	a1 7b       	lsl	r11,0x1
8000a2ea:	f7 e8 00 09 	and	r9,r11,r8
8000a2ee:	ca 71       	brne	8000a23c <_malloc_r+0x214>
8000a2f0:	cf bb       	rjmp	8000a2e6 <_malloc_r+0x2be>
8000a2f2:	d7 03       	nop
8000a2f4:	68 23       	ld.w	r3,r4[0x8]
8000a2f6:	66 12       	ld.w	r2,r3[0x4]
8000a2f8:	e0 12 ff fc 	andl	r2,0xfffc
8000a2fc:	0e 32       	cp.w	r2,r7
8000a2fe:	5f 39       	srlo	r9
8000a300:	e4 07 01 08 	sub	r8,r2,r7
8000a304:	58 f8       	cp.w	r8,15
8000a306:	5f aa       	srle	r10
8000a308:	f5 e9 10 09 	or	r9,r10,r9
8000a30c:	e0 80 00 9a 	breq	8000a440 <_malloc_r+0x418>
8000a310:	e0 68 12 9c 	mov	r8,4764
8000a314:	70 01       	ld.w	r1,r8[0x0]
8000a316:	e0 68 09 44 	mov	r8,2372
8000a31a:	2f 01       	sub	r1,-16
8000a31c:	70 08       	ld.w	r8,r8[0x0]
8000a31e:	0e 01       	add	r1,r7
8000a320:	5b f8       	cp.w	r8,-1
8000a322:	c0 40       	breq	8000a32a <_malloc_r+0x302>
8000a324:	28 11       	sub	r1,-127
8000a326:	e0 11 ff 80 	andl	r1,0xff80
8000a32a:	02 9b       	mov	r11,r1
8000a32c:	0a 9c       	mov	r12,r5
8000a32e:	e0 a0 02 b7 	rcall	8000a89c <_sbrk_r>
8000a332:	18 96       	mov	r6,r12
8000a334:	5b fc       	cp.w	r12,-1
8000a336:	c7 50       	breq	8000a420 <_malloc_r+0x3f8>
8000a338:	e6 02 00 08 	add	r8,r3,r2
8000a33c:	10 3c       	cp.w	r12,r8
8000a33e:	c0 32       	brcc	8000a344 <_malloc_r+0x31c>
8000a340:	08 33       	cp.w	r3,r4
8000a342:	c6 f1       	brne	8000a420 <_malloc_r+0x3f8>
8000a344:	e0 6a 12 a0 	mov	r10,4768
8000a348:	74 09       	ld.w	r9,r10[0x0]
8000a34a:	e2 09 00 09 	add	r9,r1,r9
8000a34e:	95 09       	st.w	r10[0x0],r9
8000a350:	10 36       	cp.w	r6,r8
8000a352:	c0 a1       	brne	8000a366 <_malloc_r+0x33e>
8000a354:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000a358:	c0 71       	brne	8000a366 <_malloc_r+0x33e>
8000a35a:	e2 02 00 02 	add	r2,r1,r2
8000a35e:	68 28       	ld.w	r8,r4[0x8]
8000a360:	a1 a2       	sbr	r2,0x0
8000a362:	91 12       	st.w	r8[0x4],r2
8000a364:	c4 f8       	rjmp	8000a402 <_malloc_r+0x3da>
8000a366:	e0 6a 09 44 	mov	r10,2372
8000a36a:	74 0b       	ld.w	r11,r10[0x0]
8000a36c:	5b fb       	cp.w	r11,-1
8000a36e:	c0 31       	brne	8000a374 <_malloc_r+0x34c>
8000a370:	95 06       	st.w	r10[0x0],r6
8000a372:	c0 78       	rjmp	8000a380 <_malloc_r+0x358>
8000a374:	ec 09 00 09 	add	r9,r6,r9
8000a378:	e0 6a 12 a0 	mov	r10,4768
8000a37c:	10 19       	sub	r9,r8
8000a37e:	95 09       	st.w	r10[0x0],r9
8000a380:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000a384:	f0 09 11 08 	rsub	r9,r8,8
8000a388:	58 08       	cp.w	r8,0
8000a38a:	f2 08 17 10 	movne	r8,r9
8000a38e:	ed d8 e1 06 	addne	r6,r6,r8
8000a392:	28 08       	sub	r8,-128
8000a394:	ec 01 00 01 	add	r1,r6,r1
8000a398:	0a 9c       	mov	r12,r5
8000a39a:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000a39e:	f0 01 01 01 	sub	r1,r8,r1
8000a3a2:	02 9b       	mov	r11,r1
8000a3a4:	e0 a0 02 7c 	rcall	8000a89c <_sbrk_r>
8000a3a8:	e0 68 12 a0 	mov	r8,4768
8000a3ac:	5b fc       	cp.w	r12,-1
8000a3ae:	ec 0c 17 00 	moveq	r12,r6
8000a3b2:	f9 b1 00 00 	moveq	r1,0
8000a3b6:	70 09       	ld.w	r9,r8[0x0]
8000a3b8:	0c 1c       	sub	r12,r6
8000a3ba:	89 26       	st.w	r4[0x8],r6
8000a3bc:	02 0c       	add	r12,r1
8000a3be:	12 01       	add	r1,r9
8000a3c0:	a1 ac       	sbr	r12,0x0
8000a3c2:	91 01       	st.w	r8[0x0],r1
8000a3c4:	8d 1c       	st.w	r6[0x4],r12
8000a3c6:	08 33       	cp.w	r3,r4
8000a3c8:	c1 d0       	breq	8000a402 <_malloc_r+0x3da>
8000a3ca:	58 f2       	cp.w	r2,15
8000a3cc:	e0 8b 00 05 	brhi	8000a3d6 <_malloc_r+0x3ae>
8000a3d0:	30 18       	mov	r8,1
8000a3d2:	8d 18       	st.w	r6[0x4],r8
8000a3d4:	c2 68       	rjmp	8000a420 <_malloc_r+0x3f8>
8000a3d6:	30 59       	mov	r9,5
8000a3d8:	20 c2       	sub	r2,12
8000a3da:	e0 12 ff f8 	andl	r2,0xfff8
8000a3de:	e6 02 00 08 	add	r8,r3,r2
8000a3e2:	91 29       	st.w	r8[0x8],r9
8000a3e4:	91 19       	st.w	r8[0x4],r9
8000a3e6:	66 18       	ld.w	r8,r3[0x4]
8000a3e8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a3ec:	e5 e8 10 08 	or	r8,r2,r8
8000a3f0:	87 18       	st.w	r3[0x4],r8
8000a3f2:	58 f2       	cp.w	r2,15
8000a3f4:	e0 88 00 07 	brls	8000a402 <_malloc_r+0x3da>
8000a3f8:	e6 cb ff f8 	sub	r11,r3,-8
8000a3fc:	0a 9c       	mov	r12,r5
8000a3fe:	e0 a0 1d 23 	rcall	8000de44 <_free_r>
8000a402:	e0 69 12 98 	mov	r9,4760
8000a406:	72 0a       	ld.w	r10,r9[0x0]
8000a408:	e0 68 12 a0 	mov	r8,4768
8000a40c:	70 08       	ld.w	r8,r8[0x0]
8000a40e:	14 38       	cp.w	r8,r10
8000a410:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000a414:	e0 69 12 94 	mov	r9,4756
8000a418:	72 0a       	ld.w	r10,r9[0x0]
8000a41a:	14 38       	cp.w	r8,r10
8000a41c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000a420:	68 28       	ld.w	r8,r4[0x8]
8000a422:	70 18       	ld.w	r8,r8[0x4]
8000a424:	e0 18 ff fc 	andl	r8,0xfffc
8000a428:	0e 38       	cp.w	r8,r7
8000a42a:	5f 39       	srlo	r9
8000a42c:	0e 18       	sub	r8,r7
8000a42e:	58 f8       	cp.w	r8,15
8000a430:	5f aa       	srle	r10
8000a432:	f5 e9 10 09 	or	r9,r10,r9
8000a436:	c0 50       	breq	8000a440 <_malloc_r+0x418>
8000a438:	0a 9c       	mov	r12,r5
8000a43a:	fe b0 f3 49 	rcall	80008acc <__malloc_unlock>
8000a43e:	d8 3a       	popm	r0-r7,pc,r12=0
8000a440:	68 26       	ld.w	r6,r4[0x8]
8000a442:	a1 a8       	sbr	r8,0x0
8000a444:	0e 99       	mov	r9,r7
8000a446:	a1 a9       	sbr	r9,0x0
8000a448:	8d 19       	st.w	r6[0x4],r9
8000a44a:	ec 07 00 07 	add	r7,r6,r7
8000a44e:	0a 9c       	mov	r12,r5
8000a450:	89 27       	st.w	r4[0x8],r7
8000a452:	8f 18       	st.w	r7[0x4],r8
8000a454:	fe b0 f3 3c 	rcall	80008acc <__malloc_unlock>
8000a458:	ec cc ff f8 	sub	r12,r6,-8
8000a45c:	d8 32       	popm	r0-r7,pc
8000a45e:	d7 03       	nop

8000a460 <memcmp>:
8000a460:	d4 01       	pushm	lr
8000a462:	30 08       	mov	r8,0
8000a464:	c0 d8       	rjmp	8000a47e <memcmp+0x1e>
8000a466:	f8 08 07 0e 	ld.ub	lr,r12[r8]
8000a46a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a46e:	20 1a       	sub	r10,1
8000a470:	2f f8       	sub	r8,-1
8000a472:	f2 0e 18 00 	cp.b	lr,r9
8000a476:	c0 40       	breq	8000a47e <memcmp+0x1e>
8000a478:	fc 09 01 0c 	sub	r12,lr,r9
8000a47c:	d8 02       	popm	pc
8000a47e:	58 0a       	cp.w	r10,0
8000a480:	cf 31       	brne	8000a466 <memcmp+0x6>
8000a482:	14 9c       	mov	r12,r10
8000a484:	d8 02       	popm	pc

8000a486 <memcpy>:
8000a486:	58 8a       	cp.w	r10,8
8000a488:	c2 f5       	brlt	8000a4e6 <memcpy+0x60>
8000a48a:	f9 eb 10 09 	or	r9,r12,r11
8000a48e:	e2 19 00 03 	andl	r9,0x3,COH
8000a492:	e0 81 00 97 	brne	8000a5c0 <memcpy+0x13a>
8000a496:	e0 4a 00 20 	cp.w	r10,32
8000a49a:	c3 b4       	brge	8000a510 <memcpy+0x8a>
8000a49c:	f4 08 14 02 	asr	r8,r10,0x2
8000a4a0:	f0 09 11 08 	rsub	r9,r8,8
8000a4a4:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000a4a8:	76 69       	ld.w	r9,r11[0x18]
8000a4aa:	99 69       	st.w	r12[0x18],r9
8000a4ac:	76 59       	ld.w	r9,r11[0x14]
8000a4ae:	99 59       	st.w	r12[0x14],r9
8000a4b0:	76 49       	ld.w	r9,r11[0x10]
8000a4b2:	99 49       	st.w	r12[0x10],r9
8000a4b4:	76 39       	ld.w	r9,r11[0xc]
8000a4b6:	99 39       	st.w	r12[0xc],r9
8000a4b8:	76 29       	ld.w	r9,r11[0x8]
8000a4ba:	99 29       	st.w	r12[0x8],r9
8000a4bc:	76 19       	ld.w	r9,r11[0x4]
8000a4be:	99 19       	st.w	r12[0x4],r9
8000a4c0:	76 09       	ld.w	r9,r11[0x0]
8000a4c2:	99 09       	st.w	r12[0x0],r9
8000a4c4:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000a4c8:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000a4cc:	e0 1a 00 03 	andl	r10,0x3
8000a4d0:	f4 0a 11 04 	rsub	r10,r10,4
8000a4d4:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000a4d8:	17 a9       	ld.ub	r9,r11[0x2]
8000a4da:	b0 a9       	st.b	r8[0x2],r9
8000a4dc:	17 99       	ld.ub	r9,r11[0x1]
8000a4de:	b0 99       	st.b	r8[0x1],r9
8000a4e0:	17 89       	ld.ub	r9,r11[0x0]
8000a4e2:	b0 89       	st.b	r8[0x0],r9
8000a4e4:	5e fc       	retal	r12
8000a4e6:	f4 0a 11 09 	rsub	r10,r10,9
8000a4ea:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000a4ee:	17 f9       	ld.ub	r9,r11[0x7]
8000a4f0:	b8 f9       	st.b	r12[0x7],r9
8000a4f2:	17 e9       	ld.ub	r9,r11[0x6]
8000a4f4:	b8 e9       	st.b	r12[0x6],r9
8000a4f6:	17 d9       	ld.ub	r9,r11[0x5]
8000a4f8:	b8 d9       	st.b	r12[0x5],r9
8000a4fa:	17 c9       	ld.ub	r9,r11[0x4]
8000a4fc:	b8 c9       	st.b	r12[0x4],r9
8000a4fe:	17 b9       	ld.ub	r9,r11[0x3]
8000a500:	b8 b9       	st.b	r12[0x3],r9
8000a502:	17 a9       	ld.ub	r9,r11[0x2]
8000a504:	b8 a9       	st.b	r12[0x2],r9
8000a506:	17 99       	ld.ub	r9,r11[0x1]
8000a508:	b8 99       	st.b	r12[0x1],r9
8000a50a:	17 89       	ld.ub	r9,r11[0x0]
8000a50c:	b8 89       	st.b	r12[0x0],r9
8000a50e:	5e fc       	retal	r12
8000a510:	eb cd 40 c0 	pushm	r6-r7,lr
8000a514:	18 99       	mov	r9,r12
8000a516:	22 0a       	sub	r10,32
8000a518:	b7 07       	ld.d	r6,r11++
8000a51a:	b3 26       	st.d	r9++,r6
8000a51c:	b7 07       	ld.d	r6,r11++
8000a51e:	b3 26       	st.d	r9++,r6
8000a520:	b7 07       	ld.d	r6,r11++
8000a522:	b3 26       	st.d	r9++,r6
8000a524:	b7 07       	ld.d	r6,r11++
8000a526:	b3 26       	st.d	r9++,r6
8000a528:	22 0a       	sub	r10,32
8000a52a:	cf 74       	brge	8000a518 <memcpy+0x92>
8000a52c:	2f 0a       	sub	r10,-16
8000a52e:	c0 65       	brlt	8000a53a <memcpy+0xb4>
8000a530:	b7 07       	ld.d	r6,r11++
8000a532:	b3 26       	st.d	r9++,r6
8000a534:	b7 07       	ld.d	r6,r11++
8000a536:	b3 26       	st.d	r9++,r6
8000a538:	21 0a       	sub	r10,16
8000a53a:	5c 3a       	neg	r10
8000a53c:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000a540:	d7 03       	nop
8000a542:	d7 03       	nop
8000a544:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000a548:	f3 66 00 0e 	st.b	r9[14],r6
8000a54c:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000a550:	f3 66 00 0d 	st.b	r9[13],r6
8000a554:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000a558:	f3 66 00 0c 	st.b	r9[12],r6
8000a55c:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000a560:	f3 66 00 0b 	st.b	r9[11],r6
8000a564:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000a568:	f3 66 00 0a 	st.b	r9[10],r6
8000a56c:	f7 36 00 09 	ld.ub	r6,r11[9]
8000a570:	f3 66 00 09 	st.b	r9[9],r6
8000a574:	f7 36 00 08 	ld.ub	r6,r11[8]
8000a578:	f3 66 00 08 	st.b	r9[8],r6
8000a57c:	f7 36 00 07 	ld.ub	r6,r11[7]
8000a580:	f3 66 00 07 	st.b	r9[7],r6
8000a584:	f7 36 00 06 	ld.ub	r6,r11[6]
8000a588:	f3 66 00 06 	st.b	r9[6],r6
8000a58c:	f7 36 00 05 	ld.ub	r6,r11[5]
8000a590:	f3 66 00 05 	st.b	r9[5],r6
8000a594:	f7 36 00 04 	ld.ub	r6,r11[4]
8000a598:	f3 66 00 04 	st.b	r9[4],r6
8000a59c:	f7 36 00 03 	ld.ub	r6,r11[3]
8000a5a0:	f3 66 00 03 	st.b	r9[3],r6
8000a5a4:	f7 36 00 02 	ld.ub	r6,r11[2]
8000a5a8:	f3 66 00 02 	st.b	r9[2],r6
8000a5ac:	f7 36 00 01 	ld.ub	r6,r11[1]
8000a5b0:	f3 66 00 01 	st.b	r9[1],r6
8000a5b4:	f7 36 00 00 	ld.ub	r6,r11[0]
8000a5b8:	f3 66 00 00 	st.b	r9[0],r6
8000a5bc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a5c0:	20 1a       	sub	r10,1
8000a5c2:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000a5c6:	f8 0a 0b 09 	st.b	r12[r10],r9
8000a5ca:	cf b1       	brne	8000a5c0 <memcpy+0x13a>
8000a5cc:	5e fc       	retal	r12

8000a5ce <memset>:
8000a5ce:	18 98       	mov	r8,r12
8000a5d0:	c0 38       	rjmp	8000a5d6 <memset+0x8>
8000a5d2:	10 cb       	st.b	r8++,r11
8000a5d4:	20 1a       	sub	r10,1
8000a5d6:	58 0a       	cp.w	r10,0
8000a5d8:	cf d1       	brne	8000a5d2 <memset+0x4>
8000a5da:	5e fc       	retal	r12

8000a5dc <_realloc_r>:
8000a5dc:	d4 31       	pushm	r0-r7,lr
8000a5de:	20 1d       	sub	sp,4
8000a5e0:	16 94       	mov	r4,r11
8000a5e2:	18 92       	mov	r2,r12
8000a5e4:	14 9b       	mov	r11,r10
8000a5e6:	58 04       	cp.w	r4,0
8000a5e8:	c0 51       	brne	8000a5f2 <_realloc_r+0x16>
8000a5ea:	fe b0 fd 1f 	rcall	8000a028 <_malloc_r>
8000a5ee:	18 95       	mov	r5,r12
8000a5f0:	c5 39       	rjmp	8000a896 <_realloc_r+0x2ba>
8000a5f2:	50 0a       	stdsp	sp[0x0],r10
8000a5f4:	fe b0 f2 66 	rcall	80008ac0 <__malloc_lock>
8000a5f8:	40 0b       	lddsp	r11,sp[0x0]
8000a5fa:	f6 c8 ff f5 	sub	r8,r11,-11
8000a5fe:	e8 c1 00 08 	sub	r1,r4,8
8000a602:	10 96       	mov	r6,r8
8000a604:	62 1c       	ld.w	r12,r1[0x4]
8000a606:	e0 16 ff f8 	andl	r6,0xfff8
8000a60a:	59 68       	cp.w	r8,22
8000a60c:	f9 b6 08 10 	movls	r6,16
8000a610:	16 36       	cp.w	r6,r11
8000a612:	5f 38       	srlo	r8
8000a614:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8000a618:	c0 50       	breq	8000a622 <_realloc_r+0x46>
8000a61a:	30 c8       	mov	r8,12
8000a61c:	30 05       	mov	r5,0
8000a61e:	85 38       	st.w	r2[0xc],r8
8000a620:	c3 b9       	rjmp	8000a896 <_realloc_r+0x2ba>
8000a622:	18 90       	mov	r0,r12
8000a624:	e0 10 ff fc 	andl	r0,0xfffc
8000a628:	0c 30       	cp.w	r0,r6
8000a62a:	e0 84 01 0b 	brge	8000a840 <_realloc_r+0x264>
8000a62e:	e0 68 05 38 	mov	r8,1336
8000a632:	e2 00 00 09 	add	r9,r1,r0
8000a636:	70 25       	ld.w	r5,r8[0x8]
8000a638:	0a 39       	cp.w	r9,r5
8000a63a:	c0 90       	breq	8000a64c <_realloc_r+0x70>
8000a63c:	72 1a       	ld.w	r10,r9[0x4]
8000a63e:	a1 ca       	cbr	r10,0x0
8000a640:	f2 0a 00 0a 	add	r10,r9,r10
8000a644:	74 1a       	ld.w	r10,r10[0x4]
8000a646:	ed ba 00 00 	bld	r10,0x0
8000a64a:	c2 20       	breq	8000a68e <_realloc_r+0xb2>
8000a64c:	72 1a       	ld.w	r10,r9[0x4]
8000a64e:	e0 1a ff fc 	andl	r10,0xfffc
8000a652:	f4 00 00 03 	add	r3,r10,r0
8000a656:	0a 39       	cp.w	r9,r5
8000a658:	c1 31       	brne	8000a67e <_realloc_r+0xa2>
8000a65a:	ec c7 ff f0 	sub	r7,r6,-16
8000a65e:	0e 33       	cp.w	r3,r7
8000a660:	c1 95       	brlt	8000a692 <_realloc_r+0xb6>
8000a662:	e2 06 00 09 	add	r9,r1,r6
8000a666:	0c 13       	sub	r3,r6
8000a668:	a1 a3       	sbr	r3,0x0
8000a66a:	93 13       	st.w	r9[0x4],r3
8000a66c:	91 29       	st.w	r8[0x8],r9
8000a66e:	04 9c       	mov	r12,r2
8000a670:	62 18       	ld.w	r8,r1[0x4]
8000a672:	08 95       	mov	r5,r4
8000a674:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a678:	10 46       	or	r6,r8
8000a67a:	83 16       	st.w	r1[0x4],r6
8000a67c:	c0 b9       	rjmp	8000a892 <_realloc_r+0x2b6>
8000a67e:	0c 33       	cp.w	r3,r6
8000a680:	c0 95       	brlt	8000a692 <_realloc_r+0xb6>
8000a682:	72 28       	ld.w	r8,r9[0x8]
8000a684:	02 97       	mov	r7,r1
8000a686:	72 39       	ld.w	r9,r9[0xc]
8000a688:	93 28       	st.w	r9[0x8],r8
8000a68a:	91 39       	st.w	r8[0xc],r9
8000a68c:	cd c8       	rjmp	8000a844 <_realloc_r+0x268>
8000a68e:	30 0a       	mov	r10,0
8000a690:	14 99       	mov	r9,r10
8000a692:	ed bc 00 00 	bld	r12,0x0
8000a696:	e0 80 00 95 	breq	8000a7c0 <_realloc_r+0x1e4>
8000a69a:	62 07       	ld.w	r7,r1[0x0]
8000a69c:	e2 07 01 07 	sub	r7,r1,r7
8000a6a0:	6e 1c       	ld.w	r12,r7[0x4]
8000a6a2:	e0 1c ff fc 	andl	r12,0xfffc
8000a6a6:	58 09       	cp.w	r9,0
8000a6a8:	c5 60       	breq	8000a754 <_realloc_r+0x178>
8000a6aa:	f8 00 00 03 	add	r3,r12,r0
8000a6ae:	0a 39       	cp.w	r9,r5
8000a6b0:	c4 81       	brne	8000a740 <_realloc_r+0x164>
8000a6b2:	14 03       	add	r3,r10
8000a6b4:	ec c9 ff f0 	sub	r9,r6,-16
8000a6b8:	12 33       	cp.w	r3,r9
8000a6ba:	c4 d5       	brlt	8000a754 <_realloc_r+0x178>
8000a6bc:	6e 3a       	ld.w	r10,r7[0xc]
8000a6be:	6e 29       	ld.w	r9,r7[0x8]
8000a6c0:	95 29       	st.w	r10[0x8],r9
8000a6c2:	93 3a       	st.w	r9[0xc],r10
8000a6c4:	ee c5 ff f8 	sub	r5,r7,-8
8000a6c8:	e0 ca 00 04 	sub	r10,r0,4
8000a6cc:	e0 4a 00 24 	cp.w	r10,36
8000a6d0:	e0 8b 00 25 	brhi	8000a71a <_realloc_r+0x13e>
8000a6d4:	0a 99       	mov	r9,r5
8000a6d6:	59 3a       	cp.w	r10,19
8000a6d8:	e0 88 00 1a 	brls	8000a70c <_realloc_r+0x130>
8000a6dc:	09 09       	ld.w	r9,r4++
8000a6de:	8b 09       	st.w	r5[0x0],r9
8000a6e0:	09 09       	ld.w	r9,r4++
8000a6e2:	8f 39       	st.w	r7[0xc],r9
8000a6e4:	ee c9 ff f0 	sub	r9,r7,-16
8000a6e8:	59 ba       	cp.w	r10,27
8000a6ea:	e0 88 00 11 	brls	8000a70c <_realloc_r+0x130>
8000a6ee:	09 0b       	ld.w	r11,r4++
8000a6f0:	93 0b       	st.w	r9[0x0],r11
8000a6f2:	09 09       	ld.w	r9,r4++
8000a6f4:	8f 59       	st.w	r7[0x14],r9
8000a6f6:	ee c9 ff e8 	sub	r9,r7,-24
8000a6fa:	e0 4a 00 24 	cp.w	r10,36
8000a6fe:	c0 71       	brne	8000a70c <_realloc_r+0x130>
8000a700:	09 0a       	ld.w	r10,r4++
8000a702:	93 0a       	st.w	r9[0x0],r10
8000a704:	ee c9 ff e0 	sub	r9,r7,-32
8000a708:	09 0a       	ld.w	r10,r4++
8000a70a:	8f 7a       	st.w	r7[0x1c],r10
8000a70c:	09 0a       	ld.w	r10,r4++
8000a70e:	12 aa       	st.w	r9++,r10
8000a710:	68 0a       	ld.w	r10,r4[0x0]
8000a712:	93 0a       	st.w	r9[0x0],r10
8000a714:	68 1a       	ld.w	r10,r4[0x4]
8000a716:	93 1a       	st.w	r9[0x4],r10
8000a718:	c0 78       	rjmp	8000a726 <_realloc_r+0x14a>
8000a71a:	50 08       	stdsp	sp[0x0],r8
8000a71c:	08 9b       	mov	r11,r4
8000a71e:	0a 9c       	mov	r12,r5
8000a720:	e0 a0 1e 35 	rcall	8000e38a <memmove>
8000a724:	40 08       	lddsp	r8,sp[0x0]
8000a726:	ee 06 00 09 	add	r9,r7,r6
8000a72a:	0c 13       	sub	r3,r6
8000a72c:	a1 a3       	sbr	r3,0x0
8000a72e:	93 13       	st.w	r9[0x4],r3
8000a730:	91 29       	st.w	r8[0x8],r9
8000a732:	04 9c       	mov	r12,r2
8000a734:	6e 18       	ld.w	r8,r7[0x4]
8000a736:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a73a:	10 46       	or	r6,r8
8000a73c:	8f 16       	st.w	r7[0x4],r6
8000a73e:	ca a8       	rjmp	8000a892 <_realloc_r+0x2b6>
8000a740:	14 03       	add	r3,r10
8000a742:	0c 33       	cp.w	r3,r6
8000a744:	c0 85       	brlt	8000a754 <_realloc_r+0x178>
8000a746:	72 28       	ld.w	r8,r9[0x8]
8000a748:	72 39       	ld.w	r9,r9[0xc]
8000a74a:	93 28       	st.w	r9[0x8],r8
8000a74c:	91 39       	st.w	r8[0xc],r9
8000a74e:	6e 28       	ld.w	r8,r7[0x8]
8000a750:	6e 39       	ld.w	r9,r7[0xc]
8000a752:	c0 78       	rjmp	8000a760 <_realloc_r+0x184>
8000a754:	f8 00 00 03 	add	r3,r12,r0
8000a758:	0c 33       	cp.w	r3,r6
8000a75a:	c3 35       	brlt	8000a7c0 <_realloc_r+0x1e4>
8000a75c:	6e 39       	ld.w	r9,r7[0xc]
8000a75e:	6e 28       	ld.w	r8,r7[0x8]
8000a760:	93 28       	st.w	r9[0x8],r8
8000a762:	91 39       	st.w	r8[0xc],r9
8000a764:	e0 ca 00 04 	sub	r10,r0,4
8000a768:	ee cc ff f8 	sub	r12,r7,-8
8000a76c:	e0 4a 00 24 	cp.w	r10,36
8000a770:	e0 8b 00 24 	brhi	8000a7b8 <_realloc_r+0x1dc>
8000a774:	59 3a       	cp.w	r10,19
8000a776:	e0 88 00 1a 	brls	8000a7aa <_realloc_r+0x1ce>
8000a77a:	09 08       	ld.w	r8,r4++
8000a77c:	99 08       	st.w	r12[0x0],r8
8000a77e:	09 08       	ld.w	r8,r4++
8000a780:	8f 38       	st.w	r7[0xc],r8
8000a782:	ee cc ff f0 	sub	r12,r7,-16
8000a786:	59 ba       	cp.w	r10,27
8000a788:	e0 88 00 11 	brls	8000a7aa <_realloc_r+0x1ce>
8000a78c:	09 08       	ld.w	r8,r4++
8000a78e:	99 08       	st.w	r12[0x0],r8
8000a790:	09 08       	ld.w	r8,r4++
8000a792:	8f 58       	st.w	r7[0x14],r8
8000a794:	ee cc ff e8 	sub	r12,r7,-24
8000a798:	e0 4a 00 24 	cp.w	r10,36
8000a79c:	c0 71       	brne	8000a7aa <_realloc_r+0x1ce>
8000a79e:	09 08       	ld.w	r8,r4++
8000a7a0:	99 08       	st.w	r12[0x0],r8
8000a7a2:	ee cc ff e0 	sub	r12,r7,-32
8000a7a6:	09 08       	ld.w	r8,r4++
8000a7a8:	8f 78       	st.w	r7[0x1c],r8
8000a7aa:	09 08       	ld.w	r8,r4++
8000a7ac:	18 a8       	st.w	r12++,r8
8000a7ae:	68 08       	ld.w	r8,r4[0x0]
8000a7b0:	99 08       	st.w	r12[0x0],r8
8000a7b2:	68 18       	ld.w	r8,r4[0x4]
8000a7b4:	99 18       	st.w	r12[0x4],r8
8000a7b6:	c4 78       	rjmp	8000a844 <_realloc_r+0x268>
8000a7b8:	08 9b       	mov	r11,r4
8000a7ba:	e0 a0 1d e8 	rcall	8000e38a <memmove>
8000a7be:	c4 38       	rjmp	8000a844 <_realloc_r+0x268>
8000a7c0:	04 9c       	mov	r12,r2
8000a7c2:	fe b0 fc 33 	rcall	8000a028 <_malloc_r>
8000a7c6:	18 95       	mov	r5,r12
8000a7c8:	c3 a0       	breq	8000a83c <_realloc_r+0x260>
8000a7ca:	62 18       	ld.w	r8,r1[0x4]
8000a7cc:	f8 c9 00 08 	sub	r9,r12,8
8000a7d0:	a1 c8       	cbr	r8,0x0
8000a7d2:	e2 08 00 08 	add	r8,r1,r8
8000a7d6:	10 39       	cp.w	r9,r8
8000a7d8:	c0 71       	brne	8000a7e6 <_realloc_r+0x20a>
8000a7da:	72 13       	ld.w	r3,r9[0x4]
8000a7dc:	02 97       	mov	r7,r1
8000a7de:	e0 13 ff fc 	andl	r3,0xfffc
8000a7e2:	00 03       	add	r3,r0
8000a7e4:	c3 08       	rjmp	8000a844 <_realloc_r+0x268>
8000a7e6:	e0 ca 00 04 	sub	r10,r0,4
8000a7ea:	e0 4a 00 24 	cp.w	r10,36
8000a7ee:	e0 8b 00 20 	brhi	8000a82e <_realloc_r+0x252>
8000a7f2:	08 99       	mov	r9,r4
8000a7f4:	18 98       	mov	r8,r12
8000a7f6:	59 3a       	cp.w	r10,19
8000a7f8:	e0 88 00 14 	brls	8000a820 <_realloc_r+0x244>
8000a7fc:	13 0b       	ld.w	r11,r9++
8000a7fe:	10 ab       	st.w	r8++,r11
8000a800:	13 0b       	ld.w	r11,r9++
8000a802:	10 ab       	st.w	r8++,r11
8000a804:	59 ba       	cp.w	r10,27
8000a806:	e0 88 00 0d 	brls	8000a820 <_realloc_r+0x244>
8000a80a:	13 0b       	ld.w	r11,r9++
8000a80c:	10 ab       	st.w	r8++,r11
8000a80e:	13 0b       	ld.w	r11,r9++
8000a810:	10 ab       	st.w	r8++,r11
8000a812:	e0 4a 00 24 	cp.w	r10,36
8000a816:	c0 51       	brne	8000a820 <_realloc_r+0x244>
8000a818:	13 0a       	ld.w	r10,r9++
8000a81a:	10 aa       	st.w	r8++,r10
8000a81c:	13 0a       	ld.w	r10,r9++
8000a81e:	10 aa       	st.w	r8++,r10
8000a820:	13 0a       	ld.w	r10,r9++
8000a822:	10 aa       	st.w	r8++,r10
8000a824:	72 0a       	ld.w	r10,r9[0x0]
8000a826:	91 0a       	st.w	r8[0x0],r10
8000a828:	72 19       	ld.w	r9,r9[0x4]
8000a82a:	91 19       	st.w	r8[0x4],r9
8000a82c:	c0 48       	rjmp	8000a834 <_realloc_r+0x258>
8000a82e:	08 9b       	mov	r11,r4
8000a830:	e0 a0 1d ad 	rcall	8000e38a <memmove>
8000a834:	08 9b       	mov	r11,r4
8000a836:	04 9c       	mov	r12,r2
8000a838:	e0 a0 1b 06 	rcall	8000de44 <_free_r>
8000a83c:	04 9c       	mov	r12,r2
8000a83e:	c2 a8       	rjmp	8000a892 <_realloc_r+0x2b6>
8000a840:	00 93       	mov	r3,r0
8000a842:	02 97       	mov	r7,r1
8000a844:	e6 06 01 09 	sub	r9,r3,r6
8000a848:	6e 18       	ld.w	r8,r7[0x4]
8000a84a:	58 f9       	cp.w	r9,15
8000a84c:	e0 88 00 16 	brls	8000a878 <_realloc_r+0x29c>
8000a850:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a854:	ed e8 10 08 	or	r8,r6,r8
8000a858:	8f 18       	st.w	r7[0x4],r8
8000a85a:	12 98       	mov	r8,r9
8000a85c:	a1 a8       	sbr	r8,0x0
8000a85e:	ee 06 00 0b 	add	r11,r7,r6
8000a862:	f6 09 00 09 	add	r9,r11,r9
8000a866:	97 18       	st.w	r11[0x4],r8
8000a868:	72 18       	ld.w	r8,r9[0x4]
8000a86a:	a1 a8       	sbr	r8,0x0
8000a86c:	2f 8b       	sub	r11,-8
8000a86e:	93 18       	st.w	r9[0x4],r8
8000a870:	04 9c       	mov	r12,r2
8000a872:	e0 a0 1a e9 	rcall	8000de44 <_free_r>
8000a876:	c0 b8       	rjmp	8000a88c <_realloc_r+0x2b0>
8000a878:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a87c:	e7 e8 10 08 	or	r8,r3,r8
8000a880:	8f 18       	st.w	r7[0x4],r8
8000a882:	ee 03 00 03 	add	r3,r7,r3
8000a886:	66 18       	ld.w	r8,r3[0x4]
8000a888:	a1 a8       	sbr	r8,0x0
8000a88a:	87 18       	st.w	r3[0x4],r8
8000a88c:	04 9c       	mov	r12,r2
8000a88e:	ee c5 ff f8 	sub	r5,r7,-8
8000a892:	fe b0 f1 1d 	rcall	80008acc <__malloc_unlock>
8000a896:	0a 9c       	mov	r12,r5
8000a898:	2f fd       	sub	sp,-4
8000a89a:	d8 32       	popm	r0-r7,pc

8000a89c <_sbrk_r>:
8000a89c:	d4 21       	pushm	r4-r7,lr
8000a89e:	30 08       	mov	r8,0
8000a8a0:	18 97       	mov	r7,r12
8000a8a2:	e0 66 46 28 	mov	r6,17960
8000a8a6:	16 9c       	mov	r12,r11
8000a8a8:	8d 08       	st.w	r6[0x0],r8
8000a8aa:	c1 1d       	rcall	8000aacc <_sbrk>
8000a8ac:	5b fc       	cp.w	r12,-1
8000a8ae:	c0 51       	brne	8000a8b8 <_sbrk_r+0x1c>
8000a8b0:	6c 08       	ld.w	r8,r6[0x0]
8000a8b2:	58 08       	cp.w	r8,0
8000a8b4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a8b8:	d8 22       	popm	r4-r7,pc
8000a8ba:	d7 03       	nop

8000a8bc <sprintf>:
8000a8bc:	d4 01       	pushm	lr
8000a8be:	21 7d       	sub	sp,92
8000a8c0:	e0 68 ff ff 	mov	r8,65535
8000a8c4:	ea 18 7f ff 	orh	r8,0x7fff
8000a8c8:	50 58       	stdsp	sp[0x14],r8
8000a8ca:	50 28       	stdsp	sp[0x8],r8
8000a8cc:	e0 68 02 08 	mov	r8,520
8000a8d0:	ba 68       	st.h	sp[0xc],r8
8000a8d2:	3f f8       	mov	r8,-1
8000a8d4:	ba 78       	st.h	sp[0xe],r8
8000a8d6:	e0 68 0a 38 	mov	r8,2616
8000a8da:	50 4c       	stdsp	sp[0x10],r12
8000a8dc:	16 9a       	mov	r10,r11
8000a8de:	50 0c       	stdsp	sp[0x0],r12
8000a8e0:	fa c9 ff a0 	sub	r9,sp,-96
8000a8e4:	70 0c       	ld.w	r12,r8[0x0]
8000a8e6:	1a 9b       	mov	r11,sp
8000a8e8:	e0 a0 02 ac 	rcall	8000ae40 <_vfprintf_r>
8000a8ec:	30 09       	mov	r9,0
8000a8ee:	40 08       	lddsp	r8,sp[0x0]
8000a8f0:	b0 89       	st.b	r8[0x0],r9
8000a8f2:	2e 9d       	sub	sp,-92
8000a8f4:	d8 02       	popm	pc
8000a8f6:	d7 03       	nop

8000a8f8 <strcpy>:
8000a8f8:	30 08       	mov	r8,0
8000a8fa:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a8fe:	f8 08 0b 09 	st.b	r12[r8],r9
8000a902:	2f f8       	sub	r8,-1
8000a904:	58 09       	cp.w	r9,0
8000a906:	cf a1       	brne	8000a8fa <strcpy+0x2>
8000a908:	5e fc       	retal	r12

8000a90a <strlen>:
8000a90a:	30 09       	mov	r9,0
8000a90c:	18 98       	mov	r8,r12
8000a90e:	c0 28       	rjmp	8000a912 <strlen+0x8>
8000a910:	2f f8       	sub	r8,-1
8000a912:	11 8a       	ld.ub	r10,r8[0x0]
8000a914:	f2 0a 18 00 	cp.b	r10,r9
8000a918:	cf c1       	brne	8000a910 <strlen+0x6>
8000a91a:	f0 0c 01 0c 	sub	r12,r8,r12
8000a91e:	5e fc       	retal	r12

8000a920 <strncpy>:
8000a920:	30 08       	mov	r8,0
8000a922:	10 3a       	cp.w	r10,r8
8000a924:	5e 0c       	reteq	r12
8000a926:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a92a:	f8 08 0b 09 	st.b	r12[r8],r9
8000a92e:	2f f8       	sub	r8,-1
8000a930:	58 09       	cp.w	r9,0
8000a932:	cf 81       	brne	8000a922 <strncpy+0x2>
8000a934:	10 3a       	cp.w	r10,r8
8000a936:	5e 0c       	reteq	r12
8000a938:	f8 08 0b 09 	st.b	r12[r8],r9
8000a93c:	2f f8       	sub	r8,-1
8000a93e:	cf bb       	rjmp	8000a934 <strncpy+0x14>

8000a940 <strtok>:
8000a940:	d4 21       	pushm	r4-r7,lr
8000a942:	20 1d       	sub	sp,4
8000a944:	e0 65 0a 38 	mov	r5,2616
8000a948:	18 97       	mov	r7,r12
8000a94a:	6a 04       	ld.w	r4,r5[0x0]
8000a94c:	e8 f6 00 e8 	ld.w	r6,r4[232]
8000a950:	58 06       	cp.w	r6,0
8000a952:	c3 51       	brne	8000a9bc <strtok+0x7c>
8000a954:	50 0b       	stdsp	sp[0x0],r11
8000a956:	35 0c       	mov	r12,80
8000a958:	fe b0 fb 60 	rcall	8000a018 <malloc>
8000a95c:	6a 08       	ld.w	r8,r5[0x0]
8000a95e:	e9 4c 00 e8 	st.w	r4[232],r12
8000a962:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a966:	93 26       	st.w	r9[0x8],r6
8000a968:	93 06       	st.w	r9[0x0],r6
8000a96a:	93 16       	st.w	r9[0x4],r6
8000a96c:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a970:	93 46       	st.w	r9[0x10],r6
8000a972:	93 36       	st.w	r9[0xc],r6
8000a974:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a978:	93 66       	st.w	r9[0x18],r6
8000a97a:	93 56       	st.w	r9[0x14],r6
8000a97c:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a980:	93 b6       	st.w	r9[0x2c],r6
8000a982:	93 a6       	st.w	r9[0x28],r6
8000a984:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a988:	93 d6       	st.w	r9[0x34],r6
8000a98a:	93 c6       	st.w	r9[0x30],r6
8000a98c:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a990:	93 f6       	st.w	r9[0x3c],r6
8000a992:	93 e6       	st.w	r9[0x38],r6
8000a994:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a998:	f3 46 00 44 	st.w	r9[68],r6
8000a99c:	f3 46 00 40 	st.w	r9[64],r6
8000a9a0:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a9a4:	f3 46 00 4c 	st.w	r9[76],r6
8000a9a8:	f3 46 00 48 	st.w	r9[72],r6
8000a9ac:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a9b0:	f3 66 00 1c 	st.b	r9[28],r6
8000a9b4:	f0 f8 00 e8 	ld.w	r8,r8[232]
8000a9b8:	40 0b       	lddsp	r11,sp[0x0]
8000a9ba:	91 96       	st.w	r8[0x24],r6
8000a9bc:	e0 68 0a 38 	mov	r8,2616
8000a9c0:	70 08       	ld.w	r8,r8[0x0]
8000a9c2:	0e 9c       	mov	r12,r7
8000a9c4:	f0 fa 00 e8 	ld.w	r10,r8[232]
8000a9c8:	30 19       	mov	r9,1
8000a9ca:	c0 3c       	rcall	8000a9d0 <__strtok_r>
8000a9cc:	2f fd       	sub	sp,-4
8000a9ce:	d8 22       	popm	r4-r7,pc

8000a9d0 <__strtok_r>:
8000a9d0:	d4 21       	pushm	r4-r7,lr
8000a9d2:	58 0c       	cp.w	r12,0
8000a9d4:	c0 41       	brne	8000a9dc <__strtok_r+0xc>
8000a9d6:	74 0c       	ld.w	r12,r10[0x0]
8000a9d8:	58 0c       	cp.w	r12,0
8000a9da:	c2 90       	breq	8000aa2c <__strtok_r+0x5c>
8000a9dc:	18 98       	mov	r8,r12
8000a9de:	16 97       	mov	r7,r11
8000a9e0:	11 3e       	ld.ub	lr,r8++
8000a9e2:	c0 a8       	rjmp	8000a9f6 <__strtok_r+0x26>
8000a9e4:	0c 3e       	cp.w	lr,r6
8000a9e6:	c0 81       	brne	8000a9f6 <__strtok_r+0x26>
8000a9e8:	58 09       	cp.w	r9,0
8000a9ea:	c0 30       	breq	8000a9f0 <__strtok_r+0x20>
8000a9ec:	10 9c       	mov	r12,r8
8000a9ee:	cf 7b       	rjmp	8000a9dc <__strtok_r+0xc>
8000a9f0:	95 08       	st.w	r10[0x0],r8
8000a9f2:	b8 89       	st.b	r12[0x0],r9
8000a9f4:	d8 22       	popm	r4-r7,pc
8000a9f6:	0f 36       	ld.ub	r6,r7++
8000a9f8:	58 06       	cp.w	r6,0
8000a9fa:	cf 51       	brne	8000a9e4 <__strtok_r+0x14>
8000a9fc:	58 0e       	cp.w	lr,0
8000a9fe:	c0 51       	brne	8000aa08 <__strtok_r+0x38>
8000aa00:	95 0e       	st.w	r10[0x0],lr
8000aa02:	1c 9c       	mov	r12,lr
8000aa04:	d8 22       	popm	r4-r7,pc
8000aa06:	12 98       	mov	r8,r9
8000aa08:	10 99       	mov	r9,r8
8000aa0a:	16 97       	mov	r7,r11
8000aa0c:	13 3e       	ld.ub	lr,r9++
8000aa0e:	0f 36       	ld.ub	r6,r7++
8000aa10:	1c 36       	cp.w	r6,lr
8000aa12:	c0 a1       	brne	8000aa26 <__strtok_r+0x56>
8000aa14:	58 0e       	cp.w	lr,0
8000aa16:	fc 09 17 00 	moveq	r9,lr
8000aa1a:	f9 bb 01 00 	movne	r11,0
8000aa1e:	f1 fb 1e 00 	st.bne	r8[0x0],r11
8000aa22:	95 09       	st.w	r10[0x0],r9
8000aa24:	d8 22       	popm	r4-r7,pc
8000aa26:	58 06       	cp.w	r6,0
8000aa28:	cf 31       	brne	8000aa0e <__strtok_r+0x3e>
8000aa2a:	ce eb       	rjmp	8000aa06 <__strtok_r+0x36>
8000aa2c:	d8 22       	popm	r4-r7,pc
8000aa2e:	d7 03       	nop

8000aa30 <_close>:
8000aa30:	30 28       	mov	r8,2
8000aa32:	d6 73       	breakpoint
8000aa34:	3f fc       	mov	r12,-1
8000aa36:	35 8b       	mov	r11,88
8000aa38:	58 0c       	cp.w	r12,0
8000aa3a:	5e 4c       	retge	r12
8000aa3c:	e0 6a 46 28 	mov	r10,17960
8000aa40:	95 0b       	st.w	r10[0x0],r11
8000aa42:	5e fc       	retal	r12

8000aa44 <_lseek>:
8000aa44:	30 58       	mov	r8,5
8000aa46:	d6 73       	breakpoint
8000aa48:	3f fc       	mov	r12,-1
8000aa4a:	35 8b       	mov	r11,88
8000aa4c:	58 0c       	cp.w	r12,0
8000aa4e:	5e 4c       	retge	r12
8000aa50:	e0 6a 46 28 	mov	r10,17960
8000aa54:	95 0b       	st.w	r10[0x0],r11
8000aa56:	5e fc       	retal	r12

8000aa58 <isatty>:
8000aa58:	30 b8       	mov	r8,11
8000aa5a:	d6 73       	breakpoint
8000aa5c:	3f fc       	mov	r12,-1
8000aa5e:	35 8b       	mov	r11,88
8000aa60:	58 0c       	cp.w	r12,0
8000aa62:	5e 4c       	retge	r12
8000aa64:	e0 6a 46 28 	mov	r10,17960
8000aa68:	95 0b       	st.w	r10[0x0],r11
8000aa6a:	5e fc       	retal	r12

8000aa6c <_fstat_host>:
8000aa6c:	30 98       	mov	r8,9
8000aa6e:	d6 73       	breakpoint
8000aa70:	3f fc       	mov	r12,-1
8000aa72:	35 8b       	mov	r11,88
8000aa74:	58 0c       	cp.w	r12,0
8000aa76:	5e 4c       	retge	r12
8000aa78:	e0 6a 46 28 	mov	r10,17960
8000aa7c:	95 0b       	st.w	r10[0x0],r11
8000aa7e:	5e fc       	retal	r12

8000aa80 <_fstat>:
8000aa80:	d4 21       	pushm	r4-r7,lr
8000aa82:	21 0d       	sub	sp,64
8000aa84:	16 97       	mov	r7,r11
8000aa86:	1a 9b       	mov	r11,sp
8000aa88:	cf 2f       	rcall	8000aa6c <_fstat_host>
8000aa8a:	c0 34       	brge	8000aa90 <_fstat+0x10>
8000aa8c:	3f fc       	mov	r12,-1
8000aa8e:	c1 c8       	rjmp	8000aac6 <_fstat+0x46>
8000aa90:	40 08       	lddsp	r8,sp[0x0]
8000aa92:	ae 08       	st.h	r7[0x0],r8
8000aa94:	40 18       	lddsp	r8,sp[0x4]
8000aa96:	ae 18       	st.h	r7[0x2],r8
8000aa98:	40 28       	lddsp	r8,sp[0x8]
8000aa9a:	8f 18       	st.w	r7[0x4],r8
8000aa9c:	40 38       	lddsp	r8,sp[0xc]
8000aa9e:	ae 48       	st.h	r7[0x8],r8
8000aaa0:	40 48       	lddsp	r8,sp[0x10]
8000aaa2:	ae 58       	st.h	r7[0xa],r8
8000aaa4:	40 58       	lddsp	r8,sp[0x14]
8000aaa6:	ae 68       	st.h	r7[0xc],r8
8000aaa8:	40 68       	lddsp	r8,sp[0x18]
8000aaaa:	ae 78       	st.h	r7[0xe],r8
8000aaac:	40 88       	lddsp	r8,sp[0x20]
8000aaae:	8f 48       	st.w	r7[0x10],r8
8000aab0:	40 a8       	lddsp	r8,sp[0x28]
8000aab2:	8f b8       	st.w	r7[0x2c],r8
8000aab4:	40 c8       	lddsp	r8,sp[0x30]
8000aab6:	8f c8       	st.w	r7[0x30],r8
8000aab8:	40 d8       	lddsp	r8,sp[0x34]
8000aaba:	8f 58       	st.w	r7[0x14],r8
8000aabc:	40 e8       	lddsp	r8,sp[0x38]
8000aabe:	30 0c       	mov	r12,0
8000aac0:	8f 78       	st.w	r7[0x1c],r8
8000aac2:	40 f8       	lddsp	r8,sp[0x3c]
8000aac4:	8f 98       	st.w	r7[0x24],r8
8000aac6:	2f 0d       	sub	sp,-64
8000aac8:	d8 22       	popm	r4-r7,pc
8000aaca:	d7 03       	nop

8000aacc <_sbrk>:
8000aacc:	d4 01       	pushm	lr
8000aace:	e0 68 12 c8 	mov	r8,4808
8000aad2:	70 09       	ld.w	r9,r8[0x0]
8000aad4:	58 09       	cp.w	r9,0
8000aad6:	c0 41       	brne	8000aade <_sbrk+0x12>
8000aad8:	e0 69 46 30 	mov	r9,17968
8000aadc:	91 09       	st.w	r8[0x0],r9
8000aade:	e0 69 12 c8 	mov	r9,4808
8000aae2:	e0 7a 70 00 	mov	r10,94208
8000aae6:	72 08       	ld.w	r8,r9[0x0]
8000aae8:	f0 0c 00 0c 	add	r12,r8,r12
8000aaec:	14 3c       	cp.w	r12,r10
8000aaee:	e0 8b 00 04 	brhi	8000aaf6 <_sbrk+0x2a>
8000aaf2:	93 0c       	st.w	r9[0x0],r12
8000aaf4:	c0 68       	rjmp	8000ab00 <_sbrk+0x34>
8000aaf6:	e0 a0 18 2b 	rcall	8000db4c <__errno>
8000aafa:	30 c8       	mov	r8,12
8000aafc:	99 08       	st.w	r12[0x0],r8
8000aafe:	3f f8       	mov	r8,-1
8000ab00:	10 9c       	mov	r12,r8
8000ab02:	d8 02       	popm	pc

8000ab04 <get_arg>:
8000ab04:	d4 31       	pushm	r0-r7,lr
8000ab06:	20 8d       	sub	sp,32
8000ab08:	fa c4 ff bc 	sub	r4,sp,-68
8000ab0c:	50 4b       	stdsp	sp[0x10],r11
8000ab0e:	68 2e       	ld.w	lr,r4[0x8]
8000ab10:	50 58       	stdsp	sp[0x14],r8
8000ab12:	12 96       	mov	r6,r9
8000ab14:	7c 0b       	ld.w	r11,lr[0x0]
8000ab16:	70 05       	ld.w	r5,r8[0x0]
8000ab18:	50 6e       	stdsp	sp[0x18],lr
8000ab1a:	58 0b       	cp.w	r11,0
8000ab1c:	f4 0b 17 00 	moveq	r11,r10
8000ab20:	68 03       	ld.w	r3,r4[0x0]
8000ab22:	68 11       	ld.w	r1,r4[0x4]
8000ab24:	40 49       	lddsp	r9,sp[0x10]
8000ab26:	30 08       	mov	r8,0
8000ab28:	c2 e9       	rjmp	8000ad84 <get_arg+0x280>
8000ab2a:	2f fb       	sub	r11,-1
8000ab2c:	32 5c       	mov	r12,37
8000ab2e:	17 8a       	ld.ub	r10,r11[0x0]
8000ab30:	f8 0a 18 00 	cp.b	r10,r12
8000ab34:	5f 1e       	srne	lr
8000ab36:	f0 0a 18 00 	cp.b	r10,r8
8000ab3a:	5f 1c       	srne	r12
8000ab3c:	fd ec 00 0c 	and	r12,lr,r12
8000ab40:	f0 0c 18 00 	cp.b	r12,r8
8000ab44:	cf 31       	brne	8000ab2a <get_arg+0x26>
8000ab46:	58 0a       	cp.w	r10,0
8000ab48:	e0 80 01 2b 	breq	8000ad9e <get_arg+0x29a>
8000ab4c:	30 0c       	mov	r12,0
8000ab4e:	3f fa       	mov	r10,-1
8000ab50:	18 90       	mov	r0,r12
8000ab52:	50 3a       	stdsp	sp[0xc],r10
8000ab54:	18 94       	mov	r4,r12
8000ab56:	18 92       	mov	r2,r12
8000ab58:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
8000ab5c:	16 97       	mov	r7,r11
8000ab5e:	50 7c       	stdsp	sp[0x1c],r12
8000ab60:	4c ec       	lddpc	r12,8000ac98 <get_arg+0x194>
8000ab62:	0f 3a       	ld.ub	r10,r7++
8000ab64:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000ab68:	40 7c       	lddsp	r12,sp[0x1c]
8000ab6a:	1c 0c       	add	r12,lr
8000ab6c:	4c ce       	lddpc	lr,8000ac9c <get_arg+0x198>
8000ab6e:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000ab72:	20 1e       	sub	lr,1
8000ab74:	50 0e       	stdsp	sp[0x0],lr
8000ab76:	4c be       	lddpc	lr,8000aca0 <get_arg+0x19c>
8000ab78:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000ab7c:	50 7c       	stdsp	sp[0x1c],r12
8000ab7e:	40 0c       	lddsp	r12,sp[0x0]
8000ab80:	58 7c       	cp.w	r12,7
8000ab82:	e0 8b 00 fa 	brhi	8000ad76 <get_arg+0x272>
8000ab86:	4c 8e       	lddpc	lr,8000aca4 <get_arg+0x1a0>
8000ab88:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000ab8c:	36 8b       	mov	r11,104
8000ab8e:	f6 0a 18 00 	cp.b	r10,r11
8000ab92:	e0 80 00 f2 	breq	8000ad76 <get_arg+0x272>
8000ab96:	37 1b       	mov	r11,113
8000ab98:	f6 0a 18 00 	cp.b	r10,r11
8000ab9c:	c0 70       	breq	8000abaa <get_arg+0xa6>
8000ab9e:	34 cb       	mov	r11,76
8000aba0:	f6 0a 18 00 	cp.b	r10,r11
8000aba4:	c0 51       	brne	8000abae <get_arg+0xaa>
8000aba6:	a3 b4       	sbr	r4,0x3
8000aba8:	ce 78       	rjmp	8000ad76 <get_arg+0x272>
8000abaa:	a5 b4       	sbr	r4,0x5
8000abac:	ce 58       	rjmp	8000ad76 <get_arg+0x272>
8000abae:	08 9a       	mov	r10,r4
8000abb0:	0e 9b       	mov	r11,r7
8000abb2:	a5 aa       	sbr	r10,0x4
8000abb4:	17 3c       	ld.ub	r12,r11++
8000abb6:	a5 b4       	sbr	r4,0x5
8000abb8:	36 ce       	mov	lr,108
8000abba:	fc 0c 18 00 	cp.b	r12,lr
8000abbe:	e0 80 00 dd 	breq	8000ad78 <get_arg+0x274>
8000abc2:	14 94       	mov	r4,r10
8000abc4:	cd 98       	rjmp	8000ad76 <get_arg+0x272>
8000abc6:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000abca:	36 7c       	mov	r12,103
8000abcc:	f8 0a 18 00 	cp.b	r10,r12
8000abd0:	e0 8b 00 27 	brhi	8000ac1e <get_arg+0x11a>
8000abd4:	36 5b       	mov	r11,101
8000abd6:	f6 0a 18 00 	cp.b	r10,r11
8000abda:	c4 82       	brcc	8000ac6a <get_arg+0x166>
8000abdc:	34 fb       	mov	r11,79
8000abde:	f6 0a 18 00 	cp.b	r10,r11
8000abe2:	c4 80       	breq	8000ac72 <get_arg+0x16e>
8000abe4:	e0 8b 00 0c 	brhi	8000abfc <get_arg+0xf8>
8000abe8:	34 5b       	mov	r11,69
8000abea:	f6 0a 18 00 	cp.b	r10,r11
8000abee:	c3 e0       	breq	8000ac6a <get_arg+0x166>
8000abf0:	34 7b       	mov	r11,71
8000abf2:	f6 0a 18 00 	cp.b	r10,r11
8000abf6:	c3 a0       	breq	8000ac6a <get_arg+0x166>
8000abf8:	34 4b       	mov	r11,68
8000abfa:	c0 88       	rjmp	8000ac0a <get_arg+0x106>
8000abfc:	35 8b       	mov	r11,88
8000abfe:	f6 0a 18 00 	cp.b	r10,r11
8000ac02:	c2 c0       	breq	8000ac5a <get_arg+0x156>
8000ac04:	e0 8b 00 07 	brhi	8000ac12 <get_arg+0x10e>
8000ac08:	35 5b       	mov	r11,85
8000ac0a:	f6 0a 18 00 	cp.b	r10,r11
8000ac0e:	c3 51       	brne	8000ac78 <get_arg+0x174>
8000ac10:	c3 18       	rjmp	8000ac72 <get_arg+0x16e>
8000ac12:	36 3b       	mov	r11,99
8000ac14:	f6 0a 18 00 	cp.b	r10,r11
8000ac18:	c2 f0       	breq	8000ac76 <get_arg+0x172>
8000ac1a:	36 4b       	mov	r11,100
8000ac1c:	c0 e8       	rjmp	8000ac38 <get_arg+0x134>
8000ac1e:	37 0b       	mov	r11,112
8000ac20:	f6 0a 18 00 	cp.b	r10,r11
8000ac24:	c2 50       	breq	8000ac6e <get_arg+0x16a>
8000ac26:	e0 8b 00 0d 	brhi	8000ac40 <get_arg+0x13c>
8000ac2a:	36 eb       	mov	r11,110
8000ac2c:	f6 0a 18 00 	cp.b	r10,r11
8000ac30:	c1 f0       	breq	8000ac6e <get_arg+0x16a>
8000ac32:	e0 8b 00 14 	brhi	8000ac5a <get_arg+0x156>
8000ac36:	36 9b       	mov	r11,105
8000ac38:	f6 0a 18 00 	cp.b	r10,r11
8000ac3c:	c1 e1       	brne	8000ac78 <get_arg+0x174>
8000ac3e:	c0 e8       	rjmp	8000ac5a <get_arg+0x156>
8000ac40:	37 5b       	mov	r11,117
8000ac42:	f6 0a 18 00 	cp.b	r10,r11
8000ac46:	c0 a0       	breq	8000ac5a <get_arg+0x156>
8000ac48:	37 8b       	mov	r11,120
8000ac4a:	f6 0a 18 00 	cp.b	r10,r11
8000ac4e:	c0 60       	breq	8000ac5a <get_arg+0x156>
8000ac50:	37 3b       	mov	r11,115
8000ac52:	f6 0a 18 00 	cp.b	r10,r11
8000ac56:	c1 11       	brne	8000ac78 <get_arg+0x174>
8000ac58:	c0 b8       	rjmp	8000ac6e <get_arg+0x16a>
8000ac5a:	ed b4 00 04 	bld	r4,0x4
8000ac5e:	c0 a0       	breq	8000ac72 <get_arg+0x16e>
8000ac60:	ed b4 00 05 	bld	r4,0x5
8000ac64:	c0 91       	brne	8000ac76 <get_arg+0x172>
8000ac66:	30 20       	mov	r0,2
8000ac68:	c0 88       	rjmp	8000ac78 <get_arg+0x174>
8000ac6a:	30 40       	mov	r0,4
8000ac6c:	c0 68       	rjmp	8000ac78 <get_arg+0x174>
8000ac6e:	30 30       	mov	r0,3
8000ac70:	c0 48       	rjmp	8000ac78 <get_arg+0x174>
8000ac72:	30 10       	mov	r0,1
8000ac74:	c0 28       	rjmp	8000ac78 <get_arg+0x174>
8000ac76:	30 00       	mov	r0,0
8000ac78:	40 3b       	lddsp	r11,sp[0xc]
8000ac7a:	5b fb       	cp.w	r11,-1
8000ac7c:	c0 40       	breq	8000ac84 <get_arg+0x180>
8000ac7e:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000ac82:	c7 a8       	rjmp	8000ad76 <get_arg+0x272>
8000ac84:	58 60       	cp.w	r0,6
8000ac86:	e0 8b 00 78 	brhi	8000ad76 <get_arg+0x272>
8000ac8a:	6c 0a       	ld.w	r10,r6[0x0]
8000ac8c:	ea cc ff ff 	sub	r12,r5,-1
8000ac90:	48 6e       	lddpc	lr,8000aca8 <get_arg+0x1a4>
8000ac92:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000ac96:	d7 03       	nop
8000ac98:	80 01       	ld.sh	r1,r0[0x0]
8000ac9a:	91 c0       	st.w	r8[0x30],r0
8000ac9c:	80 01       	ld.sh	r1,r0[0x0]
8000ac9e:	90 f8       	ld.uh	r8,r8[0xe]
8000aca0:	80 01       	ld.sh	r1,r0[0x0]
8000aca2:	90 8c       	ld.uh	r12,r8[0x0]
8000aca4:	80 01       	ld.sh	r1,r0[0x0]
8000aca6:	8e ec       	ld.uh	r12,r7[0xc]
8000aca8:	80 01       	ld.sh	r1,r0[0x0]
8000acaa:	8f 0c       	st.w	r7[0x0],r12
8000acac:	f4 cb ff f8 	sub	r11,r10,-8
8000acb0:	8d 0b       	st.w	r6[0x0],r11
8000acb2:	f4 ea 00 00 	ld.d	r10,r10[0]
8000acb6:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000acba:	c0 f8       	rjmp	8000acd8 <get_arg+0x1d4>
8000acbc:	f4 cb ff fc 	sub	r11,r10,-4
8000acc0:	8d 0b       	st.w	r6[0x0],r11
8000acc2:	74 0a       	ld.w	r10,r10[0x0]
8000acc4:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000acc8:	c0 88       	rjmp	8000acd8 <get_arg+0x1d4>
8000acca:	f4 cb ff f8 	sub	r11,r10,-8
8000acce:	8d 0b       	st.w	r6[0x0],r11
8000acd0:	f4 ea 00 00 	ld.d	r10,r10[0]
8000acd4:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000acd8:	0e 9b       	mov	r11,r7
8000acda:	18 95       	mov	r5,r12
8000acdc:	c4 e8       	rjmp	8000ad78 <get_arg+0x274>
8000acde:	62 0a       	ld.w	r10,r1[0x0]
8000ace0:	5b fa       	cp.w	r10,-1
8000ace2:	c0 b1       	brne	8000acf8 <get_arg+0x1f4>
8000ace4:	50 19       	stdsp	sp[0x4],r9
8000ace6:	50 28       	stdsp	sp[0x8],r8
8000ace8:	e0 6a 00 80 	mov	r10,128
8000acec:	30 0b       	mov	r11,0
8000acee:	02 9c       	mov	r12,r1
8000acf0:	fe b0 fc 6f 	rcall	8000a5ce <memset>
8000acf4:	40 28       	lddsp	r8,sp[0x8]
8000acf6:	40 19       	lddsp	r9,sp[0x4]
8000acf8:	e4 cc 00 01 	sub	r12,r2,1
8000acfc:	0e 9b       	mov	r11,r7
8000acfe:	50 3c       	stdsp	sp[0xc],r12
8000ad00:	f2 0c 0c 49 	max	r9,r9,r12
8000ad04:	c3 a8       	rjmp	8000ad78 <get_arg+0x274>
8000ad06:	62 0a       	ld.w	r10,r1[0x0]
8000ad08:	5b fa       	cp.w	r10,-1
8000ad0a:	c0 b1       	brne	8000ad20 <get_arg+0x21c>
8000ad0c:	50 19       	stdsp	sp[0x4],r9
8000ad0e:	50 28       	stdsp	sp[0x8],r8
8000ad10:	e0 6a 00 80 	mov	r10,128
8000ad14:	30 0b       	mov	r11,0
8000ad16:	02 9c       	mov	r12,r1
8000ad18:	fe b0 fc 5b 	rcall	8000a5ce <memset>
8000ad1c:	40 28       	lddsp	r8,sp[0x8]
8000ad1e:	40 19       	lddsp	r9,sp[0x4]
8000ad20:	20 12       	sub	r2,1
8000ad22:	30 0a       	mov	r10,0
8000ad24:	0e 9b       	mov	r11,r7
8000ad26:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000ad2a:	f2 02 0c 49 	max	r9,r9,r2
8000ad2e:	c2 58       	rjmp	8000ad78 <get_arg+0x274>
8000ad30:	16 97       	mov	r7,r11
8000ad32:	6c 0a       	ld.w	r10,r6[0x0]
8000ad34:	f4 cb ff fc 	sub	r11,r10,-4
8000ad38:	8d 0b       	st.w	r6[0x0],r11
8000ad3a:	74 0a       	ld.w	r10,r10[0x0]
8000ad3c:	0e 9b       	mov	r11,r7
8000ad3e:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000ad42:	2f f5       	sub	r5,-1
8000ad44:	c1 a8       	rjmp	8000ad78 <get_arg+0x274>
8000ad46:	f4 c2 00 30 	sub	r2,r10,48
8000ad4a:	c0 68       	rjmp	8000ad56 <get_arg+0x252>
8000ad4c:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000ad50:	2f f7       	sub	r7,-1
8000ad52:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000ad56:	0f 8a       	ld.ub	r10,r7[0x0]
8000ad58:	58 0a       	cp.w	r10,0
8000ad5a:	c0 e0       	breq	8000ad76 <get_arg+0x272>
8000ad5c:	23 0a       	sub	r10,48
8000ad5e:	58 9a       	cp.w	r10,9
8000ad60:	fe 98 ff f6 	brls	8000ad4c <get_arg+0x248>
8000ad64:	c0 98       	rjmp	8000ad76 <get_arg+0x272>
8000ad66:	2f f7       	sub	r7,-1
8000ad68:	0f 8a       	ld.ub	r10,r7[0x0]
8000ad6a:	58 0a       	cp.w	r10,0
8000ad6c:	c0 50       	breq	8000ad76 <get_arg+0x272>
8000ad6e:	23 0a       	sub	r10,48
8000ad70:	58 9a       	cp.w	r10,9
8000ad72:	fe 98 ff fa 	brls	8000ad66 <get_arg+0x262>
8000ad76:	0e 9b       	mov	r11,r7
8000ad78:	40 7c       	lddsp	r12,sp[0x1c]
8000ad7a:	30 ba       	mov	r10,11
8000ad7c:	f4 0c 18 00 	cp.b	r12,r10
8000ad80:	fe 91 fe ec 	brne	8000ab58 <get_arg+0x54>
8000ad84:	40 42       	lddsp	r2,sp[0x10]
8000ad86:	17 8c       	ld.ub	r12,r11[0x0]
8000ad88:	0a 32       	cp.w	r2,r5
8000ad8a:	5f 4a       	srge	r10
8000ad8c:	f0 0c 18 00 	cp.b	r12,r8
8000ad90:	5f 1c       	srne	r12
8000ad92:	f9 ea 00 0a 	and	r10,r12,r10
8000ad96:	f0 0a 18 00 	cp.b	r10,r8
8000ad9a:	fe 91 fe c9 	brne	8000ab2c <get_arg+0x28>
8000ad9e:	30 08       	mov	r8,0
8000ada0:	40 4e       	lddsp	lr,sp[0x10]
8000ada2:	17 8a       	ld.ub	r10,r11[0x0]
8000ada4:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000ada8:	f0 0a 18 00 	cp.b	r10,r8
8000adac:	fc 09 17 10 	movne	r9,lr
8000adb0:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000adb4:	06 9e       	mov	lr,r3
8000adb6:	c2 a8       	rjmp	8000ae0a <get_arg+0x306>
8000adb8:	62 0a       	ld.w	r10,r1[0x0]
8000adba:	58 3a       	cp.w	r10,3
8000adbc:	c1 e0       	breq	8000adf8 <get_arg+0x2f4>
8000adbe:	e0 89 00 07 	brgt	8000adcc <get_arg+0x2c8>
8000adc2:	58 1a       	cp.w	r10,1
8000adc4:	c1 a0       	breq	8000adf8 <get_arg+0x2f4>
8000adc6:	58 2a       	cp.w	r10,2
8000adc8:	c1 81       	brne	8000adf8 <get_arg+0x2f4>
8000adca:	c0 58       	rjmp	8000add4 <get_arg+0x2d0>
8000adcc:	58 5a       	cp.w	r10,5
8000adce:	c0 c0       	breq	8000ade6 <get_arg+0x2e2>
8000add0:	c0 b5       	brlt	8000ade6 <get_arg+0x2e2>
8000add2:	c1 38       	rjmp	8000adf8 <get_arg+0x2f4>
8000add4:	6c 0a       	ld.w	r10,r6[0x0]
8000add6:	f4 cc ff f8 	sub	r12,r10,-8
8000adda:	8d 0c       	st.w	r6[0x0],r12
8000addc:	f4 e2 00 00 	ld.d	r2,r10[0]
8000ade0:	f0 e3 00 00 	st.d	r8[0],r2
8000ade4:	c1 08       	rjmp	8000ae04 <get_arg+0x300>
8000ade6:	6c 0a       	ld.w	r10,r6[0x0]
8000ade8:	f4 cc ff f8 	sub	r12,r10,-8
8000adec:	8d 0c       	st.w	r6[0x0],r12
8000adee:	f4 e2 00 00 	ld.d	r2,r10[0]
8000adf2:	f0 e3 00 00 	st.d	r8[0],r2
8000adf6:	c0 78       	rjmp	8000ae04 <get_arg+0x300>
8000adf8:	6c 0a       	ld.w	r10,r6[0x0]
8000adfa:	f4 cc ff fc 	sub	r12,r10,-4
8000adfe:	8d 0c       	st.w	r6[0x0],r12
8000ae00:	74 0a       	ld.w	r10,r10[0x0]
8000ae02:	91 0a       	st.w	r8[0x0],r10
8000ae04:	2f f5       	sub	r5,-1
8000ae06:	2f 88       	sub	r8,-8
8000ae08:	2f c1       	sub	r1,-4
8000ae0a:	12 35       	cp.w	r5,r9
8000ae0c:	fe 9a ff d6 	brle	8000adb8 <get_arg+0x2b4>
8000ae10:	1c 93       	mov	r3,lr
8000ae12:	40 52       	lddsp	r2,sp[0x14]
8000ae14:	40 6e       	lddsp	lr,sp[0x18]
8000ae16:	85 05       	st.w	r2[0x0],r5
8000ae18:	9d 0b       	st.w	lr[0x0],r11
8000ae1a:	40 4b       	lddsp	r11,sp[0x10]
8000ae1c:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000ae20:	2f 8d       	sub	sp,-32
8000ae22:	d8 32       	popm	r0-r7,pc

8000ae24 <__sprint_r>:
8000ae24:	d4 21       	pushm	r4-r7,lr
8000ae26:	14 97       	mov	r7,r10
8000ae28:	74 28       	ld.w	r8,r10[0x8]
8000ae2a:	58 08       	cp.w	r8,0
8000ae2c:	c0 41       	brne	8000ae34 <__sprint_r+0x10>
8000ae2e:	95 18       	st.w	r10[0x4],r8
8000ae30:	10 9c       	mov	r12,r8
8000ae32:	d8 22       	popm	r4-r7,pc
8000ae34:	e0 a0 18 ce 	rcall	8000dfd0 <__sfvwrite_r>
8000ae38:	30 08       	mov	r8,0
8000ae3a:	8f 18       	st.w	r7[0x4],r8
8000ae3c:	8f 28       	st.w	r7[0x8],r8
8000ae3e:	d8 22       	popm	r4-r7,pc

8000ae40 <_vfprintf_r>:
8000ae40:	d4 31       	pushm	r0-r7,lr
8000ae42:	fa cd 06 bc 	sub	sp,sp,1724
8000ae46:	51 09       	stdsp	sp[0x40],r9
8000ae48:	16 91       	mov	r1,r11
8000ae4a:	14 97       	mov	r7,r10
8000ae4c:	18 95       	mov	r5,r12
8000ae4e:	e0 a0 1a 31 	rcall	8000e2b0 <_localeconv_r>
8000ae52:	78 0c       	ld.w	r12,r12[0x0]
8000ae54:	50 cc       	stdsp	sp[0x30],r12
8000ae56:	58 05       	cp.w	r5,0
8000ae58:	c0 70       	breq	8000ae66 <_vfprintf_r+0x26>
8000ae5a:	6a 68       	ld.w	r8,r5[0x18]
8000ae5c:	58 08       	cp.w	r8,0
8000ae5e:	c0 41       	brne	8000ae66 <_vfprintf_r+0x26>
8000ae60:	0a 9c       	mov	r12,r5
8000ae62:	e0 a0 17 57 	rcall	8000dd10 <__sinit>
8000ae66:	4d 08       	lddpc	r8,8000afa4 <_vfprintf_r+0x164>
8000ae68:	10 31       	cp.w	r1,r8
8000ae6a:	c0 31       	brne	8000ae70 <_vfprintf_r+0x30>
8000ae6c:	6a 01       	ld.w	r1,r5[0x0]
8000ae6e:	c0 a8       	rjmp	8000ae82 <_vfprintf_r+0x42>
8000ae70:	4c e8       	lddpc	r8,8000afa8 <_vfprintf_r+0x168>
8000ae72:	10 31       	cp.w	r1,r8
8000ae74:	c0 31       	brne	8000ae7a <_vfprintf_r+0x3a>
8000ae76:	6a 11       	ld.w	r1,r5[0x4]
8000ae78:	c0 58       	rjmp	8000ae82 <_vfprintf_r+0x42>
8000ae7a:	4c d8       	lddpc	r8,8000afac <_vfprintf_r+0x16c>
8000ae7c:	10 31       	cp.w	r1,r8
8000ae7e:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000ae82:	82 68       	ld.sh	r8,r1[0xc]
8000ae84:	ed b8 00 03 	bld	r8,0x3
8000ae88:	c0 41       	brne	8000ae90 <_vfprintf_r+0x50>
8000ae8a:	62 48       	ld.w	r8,r1[0x10]
8000ae8c:	58 08       	cp.w	r8,0
8000ae8e:	c0 71       	brne	8000ae9c <_vfprintf_r+0x5c>
8000ae90:	02 9b       	mov	r11,r1
8000ae92:	0a 9c       	mov	r12,r5
8000ae94:	e0 a0 0f 6c 	rcall	8000cd6c <__swsetup_r>
8000ae98:	e0 81 0f 63 	brne	8000cd5e <_vfprintf_r+0x1f1e>
8000ae9c:	82 68       	ld.sh	r8,r1[0xc]
8000ae9e:	10 99       	mov	r9,r8
8000aea0:	e2 19 00 1a 	andl	r9,0x1a,COH
8000aea4:	58 a9       	cp.w	r9,10
8000aea6:	c3 c1       	brne	8000af1e <_vfprintf_r+0xde>
8000aea8:	82 79       	ld.sh	r9,r1[0xe]
8000aeaa:	30 0a       	mov	r10,0
8000aeac:	f4 09 19 00 	cp.h	r9,r10
8000aeb0:	c3 75       	brlt	8000af1e <_vfprintf_r+0xde>
8000aeb2:	a1 d8       	cbr	r8,0x1
8000aeb4:	fb 58 05 d0 	st.h	sp[1488],r8
8000aeb8:	62 88       	ld.w	r8,r1[0x20]
8000aeba:	fb 48 05 e4 	st.w	sp[1508],r8
8000aebe:	62 a8       	ld.w	r8,r1[0x28]
8000aec0:	fb 48 05 ec 	st.w	sp[1516],r8
8000aec4:	fa c8 ff bc 	sub	r8,sp,-68
8000aec8:	fb 48 05 d4 	st.w	sp[1492],r8
8000aecc:	fb 48 05 c4 	st.w	sp[1476],r8
8000aed0:	e0 68 04 00 	mov	r8,1024
8000aed4:	fb 48 05 d8 	st.w	sp[1496],r8
8000aed8:	fb 48 05 cc 	st.w	sp[1484],r8
8000aedc:	30 08       	mov	r8,0
8000aede:	fb 59 05 d2 	st.h	sp[1490],r9
8000aee2:	0e 9a       	mov	r10,r7
8000aee4:	41 09       	lddsp	r9,sp[0x40]
8000aee6:	fa c7 fa 3c 	sub	r7,sp,-1476
8000aeea:	fb 48 05 dc 	st.w	sp[1500],r8
8000aeee:	0a 9c       	mov	r12,r5
8000aef0:	0e 9b       	mov	r11,r7
8000aef2:	ca 7f       	rcall	8000ae40 <_vfprintf_r>
8000aef4:	50 bc       	stdsp	sp[0x2c],r12
8000aef6:	c0 95       	brlt	8000af08 <_vfprintf_r+0xc8>
8000aef8:	0e 9b       	mov	r11,r7
8000aefa:	0a 9c       	mov	r12,r5
8000aefc:	e0 a0 16 2e 	rcall	8000db58 <_fflush_r>
8000af00:	40 be       	lddsp	lr,sp[0x2c]
8000af02:	f9 be 01 ff 	movne	lr,-1
8000af06:	50 be       	stdsp	sp[0x2c],lr
8000af08:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000af0c:	ed b8 00 06 	bld	r8,0x6
8000af10:	e0 81 0f 29 	brne	8000cd62 <_vfprintf_r+0x1f22>
8000af14:	82 68       	ld.sh	r8,r1[0xc]
8000af16:	a7 a8       	sbr	r8,0x6
8000af18:	a2 68       	st.h	r1[0xc],r8
8000af1a:	e0 8f 0f 24 	bral	8000cd62 <_vfprintf_r+0x1f22>
8000af1e:	30 08       	mov	r8,0
8000af20:	fb 48 06 b4 	st.w	sp[1716],r8
8000af24:	fb 48 06 90 	st.w	sp[1680],r8
8000af28:	fb 48 06 8c 	st.w	sp[1676],r8
8000af2c:	fb 48 06 b0 	st.w	sp[1712],r8
8000af30:	30 08       	mov	r8,0
8000af32:	30 09       	mov	r9,0
8000af34:	50 a7       	stdsp	sp[0x28],r7
8000af36:	50 78       	stdsp	sp[0x1c],r8
8000af38:	fa c3 f9 e0 	sub	r3,sp,-1568
8000af3c:	3f f8       	mov	r8,-1
8000af3e:	50 59       	stdsp	sp[0x14],r9
8000af40:	fb 43 06 88 	st.w	sp[1672],r3
8000af44:	fb 48 05 44 	st.w	sp[1348],r8
8000af48:	12 9c       	mov	r12,r9
8000af4a:	50 69       	stdsp	sp[0x18],r9
8000af4c:	50 d9       	stdsp	sp[0x34],r9
8000af4e:	50 e9       	stdsp	sp[0x38],r9
8000af50:	50 b9       	stdsp	sp[0x2c],r9
8000af52:	12 97       	mov	r7,r9
8000af54:	0a 94       	mov	r4,r5
8000af56:	40 a2       	lddsp	r2,sp[0x28]
8000af58:	32 5a       	mov	r10,37
8000af5a:	30 08       	mov	r8,0
8000af5c:	c0 28       	rjmp	8000af60 <_vfprintf_r+0x120>
8000af5e:	2f f2       	sub	r2,-1
8000af60:	05 89       	ld.ub	r9,r2[0x0]
8000af62:	f0 09 18 00 	cp.b	r9,r8
8000af66:	5f 1b       	srne	r11
8000af68:	f4 09 18 00 	cp.b	r9,r10
8000af6c:	5f 19       	srne	r9
8000af6e:	f3 eb 00 0b 	and	r11,r9,r11
8000af72:	f0 0b 18 00 	cp.b	r11,r8
8000af76:	cf 41       	brne	8000af5e <_vfprintf_r+0x11e>
8000af78:	40 ab       	lddsp	r11,sp[0x28]
8000af7a:	e4 0b 01 06 	sub	r6,r2,r11
8000af7e:	c2 50       	breq	8000afc8 <_vfprintf_r+0x188>
8000af80:	fa f8 06 90 	ld.w	r8,sp[1680]
8000af84:	0c 08       	add	r8,r6
8000af86:	87 0b       	st.w	r3[0x0],r11
8000af88:	fb 48 06 90 	st.w	sp[1680],r8
8000af8c:	87 16       	st.w	r3[0x4],r6
8000af8e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000af92:	2f f8       	sub	r8,-1
8000af94:	fb 48 06 8c 	st.w	sp[1676],r8
8000af98:	58 78       	cp.w	r8,7
8000af9a:	e0 89 00 0b 	brgt	8000afb0 <_vfprintf_r+0x170>
8000af9e:	2f 83       	sub	r3,-8
8000afa0:	c1 18       	rjmp	8000afc2 <_vfprintf_r+0x182>
8000afa2:	d7 03       	nop
8000afa4:	80 01       	ld.sh	r1,r0[0x0]
8000afa6:	92 d0       	ld.uh	r0,r9[0xa]
8000afa8:	80 01       	ld.sh	r1,r0[0x0]
8000afaa:	92 f0       	ld.uh	r0,r9[0xe]
8000afac:	80 01       	ld.sh	r1,r0[0x0]
8000afae:	93 10       	st.w	r9[0x4],r0
8000afb0:	fa ca f9 78 	sub	r10,sp,-1672
8000afb4:	02 9b       	mov	r11,r1
8000afb6:	08 9c       	mov	r12,r4
8000afb8:	c3 6f       	rcall	8000ae24 <__sprint_r>
8000afba:	e0 81 0e ce 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000afbe:	fa c3 f9 e0 	sub	r3,sp,-1568
8000afc2:	40 ba       	lddsp	r10,sp[0x2c]
8000afc4:	0c 0a       	add	r10,r6
8000afc6:	50 ba       	stdsp	sp[0x2c],r10
8000afc8:	05 89       	ld.ub	r9,r2[0x0]
8000afca:	30 08       	mov	r8,0
8000afcc:	f0 09 18 00 	cp.b	r9,r8
8000afd0:	e0 80 0e b2 	breq	8000cd34 <_vfprintf_r+0x1ef4>
8000afd4:	30 09       	mov	r9,0
8000afd6:	fb 68 06 bb 	st.b	sp[1723],r8
8000afda:	0e 96       	mov	r6,r7
8000afdc:	e4 c8 ff ff 	sub	r8,r2,-1
8000afe0:	3f fe       	mov	lr,-1
8000afe2:	50 93       	stdsp	sp[0x24],r3
8000afe4:	50 41       	stdsp	sp[0x10],r1
8000afe6:	0e 93       	mov	r3,r7
8000afe8:	04 91       	mov	r1,r2
8000afea:	50 89       	stdsp	sp[0x20],r9
8000afec:	50 a8       	stdsp	sp[0x28],r8
8000afee:	50 2e       	stdsp	sp[0x8],lr
8000aff0:	50 39       	stdsp	sp[0xc],r9
8000aff2:	12 95       	mov	r5,r9
8000aff4:	12 90       	mov	r0,r9
8000aff6:	10 97       	mov	r7,r8
8000aff8:	08 92       	mov	r2,r4
8000affa:	c0 78       	rjmp	8000b008 <_vfprintf_r+0x1c8>
8000affc:	3f fc       	mov	r12,-1
8000affe:	08 97       	mov	r7,r4
8000b000:	50 2c       	stdsp	sp[0x8],r12
8000b002:	c0 38       	rjmp	8000b008 <_vfprintf_r+0x1c8>
8000b004:	30 0b       	mov	r11,0
8000b006:	50 3b       	stdsp	sp[0xc],r11
8000b008:	0f 38       	ld.ub	r8,r7++
8000b00a:	c0 28       	rjmp	8000b00e <_vfprintf_r+0x1ce>
8000b00c:	12 90       	mov	r0,r9
8000b00e:	f0 c9 00 20 	sub	r9,r8,32
8000b012:	e0 49 00 58 	cp.w	r9,88
8000b016:	e0 8b 0a 36 	brhi	8000c482 <_vfprintf_r+0x1642>
8000b01a:	4d 9a       	lddpc	r10,8000b17c <_vfprintf_r+0x33c>
8000b01c:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000b020:	50 a7       	stdsp	sp[0x28],r7
8000b022:	50 80       	stdsp	sp[0x20],r0
8000b024:	0c 97       	mov	r7,r6
8000b026:	04 94       	mov	r4,r2
8000b028:	06 96       	mov	r6,r3
8000b02a:	02 92       	mov	r2,r1
8000b02c:	4d 59       	lddpc	r9,8000b180 <_vfprintf_r+0x340>
8000b02e:	40 93       	lddsp	r3,sp[0x24]
8000b030:	10 90       	mov	r0,r8
8000b032:	40 41       	lddsp	r1,sp[0x10]
8000b034:	50 d9       	stdsp	sp[0x34],r9
8000b036:	e0 8f 08 95 	bral	8000c160 <_vfprintf_r+0x1320>
8000b03a:	30 08       	mov	r8,0
8000b03c:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000b040:	f0 09 18 00 	cp.b	r9,r8
8000b044:	ce 21       	brne	8000b008 <_vfprintf_r+0x1c8>
8000b046:	32 08       	mov	r8,32
8000b048:	c6 e8       	rjmp	8000b124 <_vfprintf_r+0x2e4>
8000b04a:	a1 a5       	sbr	r5,0x0
8000b04c:	cd eb       	rjmp	8000b008 <_vfprintf_r+0x1c8>
8000b04e:	0f 89       	ld.ub	r9,r7[0x0]
8000b050:	f2 c8 00 30 	sub	r8,r9,48
8000b054:	58 98       	cp.w	r8,9
8000b056:	e0 8b 00 1d 	brhi	8000b090 <_vfprintf_r+0x250>
8000b05a:	ee c8 ff ff 	sub	r8,r7,-1
8000b05e:	30 0b       	mov	r11,0
8000b060:	23 09       	sub	r9,48
8000b062:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000b066:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000b06a:	11 39       	ld.ub	r9,r8++
8000b06c:	f2 ca 00 30 	sub	r10,r9,48
8000b070:	58 9a       	cp.w	r10,9
8000b072:	fe 98 ff f7 	brls	8000b060 <_vfprintf_r+0x220>
8000b076:	e0 49 00 24 	cp.w	r9,36
8000b07a:	cc 51       	brne	8000b004 <_vfprintf_r+0x1c4>
8000b07c:	e0 4b 00 20 	cp.w	r11,32
8000b080:	e0 89 0e 6a 	brgt	8000cd54 <_vfprintf_r+0x1f14>
8000b084:	20 1b       	sub	r11,1
8000b086:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000b08a:	12 3b       	cp.w	r11,r9
8000b08c:	c0 95       	brlt	8000b09e <_vfprintf_r+0x25e>
8000b08e:	c1 08       	rjmp	8000b0ae <_vfprintf_r+0x26e>
8000b090:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000b094:	ec ca ff ff 	sub	r10,r6,-1
8000b098:	12 36       	cp.w	r6,r9
8000b09a:	c1 f5       	brlt	8000b0d8 <_vfprintf_r+0x298>
8000b09c:	c2 68       	rjmp	8000b0e8 <_vfprintf_r+0x2a8>
8000b09e:	fa ce f9 44 	sub	lr,sp,-1724
8000b0a2:	10 97       	mov	r7,r8
8000b0a4:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000b0a8:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000b0ac:	c3 58       	rjmp	8000b116 <_vfprintf_r+0x2d6>
8000b0ae:	10 97       	mov	r7,r8
8000b0b0:	fa c8 f9 50 	sub	r8,sp,-1712
8000b0b4:	1a d8       	st.w	--sp,r8
8000b0b6:	fa c8 fa b8 	sub	r8,sp,-1352
8000b0ba:	1a d8       	st.w	--sp,r8
8000b0bc:	fa c8 fb b4 	sub	r8,sp,-1100
8000b0c0:	02 9a       	mov	r10,r1
8000b0c2:	1a d8       	st.w	--sp,r8
8000b0c4:	04 9c       	mov	r12,r2
8000b0c6:	fa c8 f9 40 	sub	r8,sp,-1728
8000b0ca:	fa c9 ff b4 	sub	r9,sp,-76
8000b0ce:	fe b0 fd 1b 	rcall	8000ab04 <get_arg>
8000b0d2:	2f dd       	sub	sp,-12
8000b0d4:	78 00       	ld.w	r0,r12[0x0]
8000b0d6:	c2 08       	rjmp	8000b116 <_vfprintf_r+0x2d6>
8000b0d8:	fa cc f9 44 	sub	r12,sp,-1724
8000b0dc:	14 96       	mov	r6,r10
8000b0de:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000b0e2:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000b0e6:	c1 88       	rjmp	8000b116 <_vfprintf_r+0x2d6>
8000b0e8:	41 08       	lddsp	r8,sp[0x40]
8000b0ea:	59 f9       	cp.w	r9,31
8000b0ec:	e0 89 00 11 	brgt	8000b10e <_vfprintf_r+0x2ce>
8000b0f0:	f0 cb ff fc 	sub	r11,r8,-4
8000b0f4:	51 0b       	stdsp	sp[0x40],r11
8000b0f6:	70 00       	ld.w	r0,r8[0x0]
8000b0f8:	fa cb f9 44 	sub	r11,sp,-1724
8000b0fc:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000b100:	f1 40 fd 88 	st.w	r8[-632],r0
8000b104:	2f f9       	sub	r9,-1
8000b106:	14 96       	mov	r6,r10
8000b108:	fb 49 06 b4 	st.w	sp[1716],r9
8000b10c:	c0 58       	rjmp	8000b116 <_vfprintf_r+0x2d6>
8000b10e:	70 00       	ld.w	r0,r8[0x0]
8000b110:	14 96       	mov	r6,r10
8000b112:	2f c8       	sub	r8,-4
8000b114:	51 08       	stdsp	sp[0x40],r8
8000b116:	58 00       	cp.w	r0,0
8000b118:	fe 94 ff 78 	brge	8000b008 <_vfprintf_r+0x1c8>
8000b11c:	5c 30       	neg	r0
8000b11e:	a3 a5       	sbr	r5,0x2
8000b120:	c7 4b       	rjmp	8000b008 <_vfprintf_r+0x1c8>
8000b122:	32 b8       	mov	r8,43
8000b124:	fb 68 06 bb 	st.b	sp[1723],r8
8000b128:	c7 0b       	rjmp	8000b008 <_vfprintf_r+0x1c8>
8000b12a:	0f 38       	ld.ub	r8,r7++
8000b12c:	e0 48 00 2a 	cp.w	r8,42
8000b130:	c0 30       	breq	8000b136 <_vfprintf_r+0x2f6>
8000b132:	30 09       	mov	r9,0
8000b134:	c7 d8       	rjmp	8000b22e <_vfprintf_r+0x3ee>
8000b136:	0f 88       	ld.ub	r8,r7[0x0]
8000b138:	f0 c9 00 30 	sub	r9,r8,48
8000b13c:	58 99       	cp.w	r9,9
8000b13e:	e0 8b 00 23 	brhi	8000b184 <_vfprintf_r+0x344>
8000b142:	ee c4 ff ff 	sub	r4,r7,-1
8000b146:	30 0b       	mov	r11,0
8000b148:	23 08       	sub	r8,48
8000b14a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000b14e:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000b152:	09 38       	ld.ub	r8,r4++
8000b154:	f0 c9 00 30 	sub	r9,r8,48
8000b158:	58 99       	cp.w	r9,9
8000b15a:	fe 98 ff f7 	brls	8000b148 <_vfprintf_r+0x308>
8000b15e:	e0 48 00 24 	cp.w	r8,36
8000b162:	fe 91 ff 51 	brne	8000b004 <_vfprintf_r+0x1c4>
8000b166:	e0 4b 00 20 	cp.w	r11,32
8000b16a:	e0 89 0d f5 	brgt	8000cd54 <_vfprintf_r+0x1f14>
8000b16e:	20 1b       	sub	r11,1
8000b170:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b174:	10 3b       	cp.w	r11,r8
8000b176:	c0 e5       	brlt	8000b192 <_vfprintf_r+0x352>
8000b178:	c1 58       	rjmp	8000b1a2 <_vfprintf_r+0x362>
8000b17a:	d7 03       	nop
8000b17c:	80 01       	ld.sh	r1,r0[0x0]
8000b17e:	8f 28       	st.w	r7[0x8],r8
8000b180:	80 01       	ld.sh	r1,r0[0x0]
8000b182:	91 64       	st.w	r8[0x18],r4
8000b184:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000b188:	ec c9 ff ff 	sub	r9,r6,-1
8000b18c:	14 36       	cp.w	r6,r10
8000b18e:	c1 f5       	brlt	8000b1cc <_vfprintf_r+0x38c>
8000b190:	c2 88       	rjmp	8000b1e0 <_vfprintf_r+0x3a0>
8000b192:	fa ca f9 44 	sub	r10,sp,-1724
8000b196:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000b19a:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000b19e:	50 2b       	stdsp	sp[0x8],r11
8000b1a0:	c3 c8       	rjmp	8000b218 <_vfprintf_r+0x3d8>
8000b1a2:	fa c8 f9 50 	sub	r8,sp,-1712
8000b1a6:	1a d8       	st.w	--sp,r8
8000b1a8:	fa c8 fa b8 	sub	r8,sp,-1352
8000b1ac:	1a d8       	st.w	--sp,r8
8000b1ae:	fa c8 fb b4 	sub	r8,sp,-1100
8000b1b2:	02 9a       	mov	r10,r1
8000b1b4:	1a d8       	st.w	--sp,r8
8000b1b6:	04 9c       	mov	r12,r2
8000b1b8:	fa c8 f9 40 	sub	r8,sp,-1728
8000b1bc:	fa c9 ff b4 	sub	r9,sp,-76
8000b1c0:	fe b0 fc a2 	rcall	8000ab04 <get_arg>
8000b1c4:	2f dd       	sub	sp,-12
8000b1c6:	78 0c       	ld.w	r12,r12[0x0]
8000b1c8:	50 2c       	stdsp	sp[0x8],r12
8000b1ca:	c2 78       	rjmp	8000b218 <_vfprintf_r+0x3d8>
8000b1cc:	12 96       	mov	r6,r9
8000b1ce:	0e 94       	mov	r4,r7
8000b1d0:	fa c9 f9 44 	sub	r9,sp,-1724
8000b1d4:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000b1d8:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000b1dc:	50 28       	stdsp	sp[0x8],r8
8000b1de:	c1 d8       	rjmp	8000b218 <_vfprintf_r+0x3d8>
8000b1e0:	41 08       	lddsp	r8,sp[0x40]
8000b1e2:	59 fa       	cp.w	r10,31
8000b1e4:	e0 89 00 14 	brgt	8000b20c <_vfprintf_r+0x3cc>
8000b1e8:	f0 cb ff fc 	sub	r11,r8,-4
8000b1ec:	70 08       	ld.w	r8,r8[0x0]
8000b1ee:	51 0b       	stdsp	sp[0x40],r11
8000b1f0:	50 28       	stdsp	sp[0x8],r8
8000b1f2:	fa c6 f9 44 	sub	r6,sp,-1724
8000b1f6:	40 2e       	lddsp	lr,sp[0x8]
8000b1f8:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000b1fc:	f1 4e fd 88 	st.w	r8[-632],lr
8000b200:	2f fa       	sub	r10,-1
8000b202:	0e 94       	mov	r4,r7
8000b204:	fb 4a 06 b4 	st.w	sp[1716],r10
8000b208:	12 96       	mov	r6,r9
8000b20a:	c0 78       	rjmp	8000b218 <_vfprintf_r+0x3d8>
8000b20c:	70 0c       	ld.w	r12,r8[0x0]
8000b20e:	0e 94       	mov	r4,r7
8000b210:	2f c8       	sub	r8,-4
8000b212:	50 2c       	stdsp	sp[0x8],r12
8000b214:	12 96       	mov	r6,r9
8000b216:	51 08       	stdsp	sp[0x40],r8
8000b218:	40 2b       	lddsp	r11,sp[0x8]
8000b21a:	58 0b       	cp.w	r11,0
8000b21c:	fe 95 fe f0 	brlt	8000affc <_vfprintf_r+0x1bc>
8000b220:	08 97       	mov	r7,r4
8000b222:	cf 3a       	rjmp	8000b008 <_vfprintf_r+0x1c8>
8000b224:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000b228:	0f 38       	ld.ub	r8,r7++
8000b22a:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000b22e:	f0 ca 00 30 	sub	r10,r8,48
8000b232:	58 9a       	cp.w	r10,9
8000b234:	fe 98 ff f8 	brls	8000b224 <_vfprintf_r+0x3e4>
8000b238:	3f fa       	mov	r10,-1
8000b23a:	f2 0a 0c 49 	max	r9,r9,r10
8000b23e:	50 29       	stdsp	sp[0x8],r9
8000b240:	ce 7a       	rjmp	8000b00e <_vfprintf_r+0x1ce>
8000b242:	a7 b5       	sbr	r5,0x7
8000b244:	ce 2a       	rjmp	8000b008 <_vfprintf_r+0x1c8>
8000b246:	30 09       	mov	r9,0
8000b248:	23 08       	sub	r8,48
8000b24a:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000b24e:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000b252:	0f 38       	ld.ub	r8,r7++
8000b254:	f0 ca 00 30 	sub	r10,r8,48
8000b258:	58 9a       	cp.w	r10,9
8000b25a:	fe 98 ff f7 	brls	8000b248 <_vfprintf_r+0x408>
8000b25e:	e0 48 00 24 	cp.w	r8,36
8000b262:	fe 91 fe d5 	brne	8000b00c <_vfprintf_r+0x1cc>
8000b266:	e0 49 00 20 	cp.w	r9,32
8000b26a:	e0 89 0d 75 	brgt	8000cd54 <_vfprintf_r+0x1f14>
8000b26e:	f2 c3 00 01 	sub	r3,r9,1
8000b272:	30 19       	mov	r9,1
8000b274:	50 39       	stdsp	sp[0xc],r9
8000b276:	cc 9a       	rjmp	8000b008 <_vfprintf_r+0x1c8>
8000b278:	a3 b5       	sbr	r5,0x3
8000b27a:	cc 7a       	rjmp	8000b008 <_vfprintf_r+0x1c8>
8000b27c:	a7 a5       	sbr	r5,0x6
8000b27e:	cc 5a       	rjmp	8000b008 <_vfprintf_r+0x1c8>
8000b280:	0a 98       	mov	r8,r5
8000b282:	a5 b5       	sbr	r5,0x5
8000b284:	a5 a8       	sbr	r8,0x4
8000b286:	0f 89       	ld.ub	r9,r7[0x0]
8000b288:	36 ce       	mov	lr,108
8000b28a:	fc 09 18 00 	cp.b	r9,lr
8000b28e:	f7 b7 00 ff 	subeq	r7,-1
8000b292:	f0 05 17 10 	movne	r5,r8
8000b296:	cb 9a       	rjmp	8000b008 <_vfprintf_r+0x1c8>
8000b298:	a5 b5       	sbr	r5,0x5
8000b29a:	cb 7a       	rjmp	8000b008 <_vfprintf_r+0x1c8>
8000b29c:	50 a7       	stdsp	sp[0x28],r7
8000b29e:	50 80       	stdsp	sp[0x20],r0
8000b2a0:	0c 97       	mov	r7,r6
8000b2a2:	10 90       	mov	r0,r8
8000b2a4:	06 96       	mov	r6,r3
8000b2a6:	04 94       	mov	r4,r2
8000b2a8:	40 93       	lddsp	r3,sp[0x24]
8000b2aa:	02 92       	mov	r2,r1
8000b2ac:	0e 99       	mov	r9,r7
8000b2ae:	40 41       	lddsp	r1,sp[0x10]
8000b2b0:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b2b4:	40 3c       	lddsp	r12,sp[0xc]
8000b2b6:	58 0c       	cp.w	r12,0
8000b2b8:	c1 d0       	breq	8000b2f2 <_vfprintf_r+0x4b2>
8000b2ba:	10 36       	cp.w	r6,r8
8000b2bc:	c0 64       	brge	8000b2c8 <_vfprintf_r+0x488>
8000b2be:	fa cb f9 44 	sub	r11,sp,-1724
8000b2c2:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b2c6:	c1 d8       	rjmp	8000b300 <_vfprintf_r+0x4c0>
8000b2c8:	fa c8 f9 50 	sub	r8,sp,-1712
8000b2cc:	1a d8       	st.w	--sp,r8
8000b2ce:	fa c8 fa b8 	sub	r8,sp,-1352
8000b2d2:	1a d8       	st.w	--sp,r8
8000b2d4:	fa c8 fb b4 	sub	r8,sp,-1100
8000b2d8:	1a d8       	st.w	--sp,r8
8000b2da:	fa c8 f9 40 	sub	r8,sp,-1728
8000b2de:	fa c9 ff b4 	sub	r9,sp,-76
8000b2e2:	04 9a       	mov	r10,r2
8000b2e4:	0c 9b       	mov	r11,r6
8000b2e6:	08 9c       	mov	r12,r4
8000b2e8:	fe b0 fc 0e 	rcall	8000ab04 <get_arg>
8000b2ec:	2f dd       	sub	sp,-12
8000b2ee:	19 b8       	ld.ub	r8,r12[0x3]
8000b2f0:	c2 28       	rjmp	8000b334 <_vfprintf_r+0x4f4>
8000b2f2:	2f f7       	sub	r7,-1
8000b2f4:	10 39       	cp.w	r9,r8
8000b2f6:	c0 84       	brge	8000b306 <_vfprintf_r+0x4c6>
8000b2f8:	fa ca f9 44 	sub	r10,sp,-1724
8000b2fc:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000b300:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000b304:	c1 88       	rjmp	8000b334 <_vfprintf_r+0x4f4>
8000b306:	41 09       	lddsp	r9,sp[0x40]
8000b308:	59 f8       	cp.w	r8,31
8000b30a:	e0 89 00 12 	brgt	8000b32e <_vfprintf_r+0x4ee>
8000b30e:	f2 ca ff fc 	sub	r10,r9,-4
8000b312:	51 0a       	stdsp	sp[0x40],r10
8000b314:	72 09       	ld.w	r9,r9[0x0]
8000b316:	fa c6 f9 44 	sub	r6,sp,-1724
8000b31a:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000b31e:	2f f8       	sub	r8,-1
8000b320:	f5 49 fd 88 	st.w	r10[-632],r9
8000b324:	fb 48 06 b4 	st.w	sp[1716],r8
8000b328:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000b32c:	c0 48       	rjmp	8000b334 <_vfprintf_r+0x4f4>
8000b32e:	13 b8       	ld.ub	r8,r9[0x3]
8000b330:	2f c9       	sub	r9,-4
8000b332:	51 09       	stdsp	sp[0x40],r9
8000b334:	fb 68 06 60 	st.b	sp[1632],r8
8000b338:	30 0e       	mov	lr,0
8000b33a:	30 08       	mov	r8,0
8000b33c:	30 12       	mov	r2,1
8000b33e:	fb 68 06 bb 	st.b	sp[1723],r8
8000b342:	50 2e       	stdsp	sp[0x8],lr
8000b344:	e0 8f 08 b1 	bral	8000c4a6 <_vfprintf_r+0x1666>
8000b348:	50 a7       	stdsp	sp[0x28],r7
8000b34a:	50 80       	stdsp	sp[0x20],r0
8000b34c:	0c 97       	mov	r7,r6
8000b34e:	04 94       	mov	r4,r2
8000b350:	06 96       	mov	r6,r3
8000b352:	02 92       	mov	r2,r1
8000b354:	40 93       	lddsp	r3,sp[0x24]
8000b356:	10 90       	mov	r0,r8
8000b358:	40 41       	lddsp	r1,sp[0x10]
8000b35a:	a5 a5       	sbr	r5,0x4
8000b35c:	c0 a8       	rjmp	8000b370 <_vfprintf_r+0x530>
8000b35e:	50 a7       	stdsp	sp[0x28],r7
8000b360:	50 80       	stdsp	sp[0x20],r0
8000b362:	0c 97       	mov	r7,r6
8000b364:	04 94       	mov	r4,r2
8000b366:	06 96       	mov	r6,r3
8000b368:	02 92       	mov	r2,r1
8000b36a:	40 93       	lddsp	r3,sp[0x24]
8000b36c:	10 90       	mov	r0,r8
8000b36e:	40 41       	lddsp	r1,sp[0x10]
8000b370:	ed b5 00 05 	bld	r5,0x5
8000b374:	c5 11       	brne	8000b416 <_vfprintf_r+0x5d6>
8000b376:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b37a:	40 3c       	lddsp	r12,sp[0xc]
8000b37c:	58 0c       	cp.w	r12,0
8000b37e:	c1 e0       	breq	8000b3ba <_vfprintf_r+0x57a>
8000b380:	10 36       	cp.w	r6,r8
8000b382:	c0 64       	brge	8000b38e <_vfprintf_r+0x54e>
8000b384:	fa cb f9 44 	sub	r11,sp,-1724
8000b388:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b38c:	c2 08       	rjmp	8000b3cc <_vfprintf_r+0x58c>
8000b38e:	fa c8 f9 50 	sub	r8,sp,-1712
8000b392:	1a d8       	st.w	--sp,r8
8000b394:	fa c8 fa b8 	sub	r8,sp,-1352
8000b398:	0c 9b       	mov	r11,r6
8000b39a:	1a d8       	st.w	--sp,r8
8000b39c:	fa c8 fb b4 	sub	r8,sp,-1100
8000b3a0:	1a d8       	st.w	--sp,r8
8000b3a2:	fa c9 ff b4 	sub	r9,sp,-76
8000b3a6:	fa c8 f9 40 	sub	r8,sp,-1728
8000b3aa:	04 9a       	mov	r10,r2
8000b3ac:	08 9c       	mov	r12,r4
8000b3ae:	fe b0 fb ab 	rcall	8000ab04 <get_arg>
8000b3b2:	2f dd       	sub	sp,-12
8000b3b4:	78 1b       	ld.w	r11,r12[0x4]
8000b3b6:	78 09       	ld.w	r9,r12[0x0]
8000b3b8:	c2 b8       	rjmp	8000b40e <_vfprintf_r+0x5ce>
8000b3ba:	ee ca ff ff 	sub	r10,r7,-1
8000b3be:	10 37       	cp.w	r7,r8
8000b3c0:	c0 b4       	brge	8000b3d6 <_vfprintf_r+0x596>
8000b3c2:	fa c9 f9 44 	sub	r9,sp,-1724
8000b3c6:	14 97       	mov	r7,r10
8000b3c8:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b3cc:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000b3d0:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000b3d4:	c1 d8       	rjmp	8000b40e <_vfprintf_r+0x5ce>
8000b3d6:	41 09       	lddsp	r9,sp[0x40]
8000b3d8:	59 f8       	cp.w	r8,31
8000b3da:	e0 89 00 14 	brgt	8000b402 <_vfprintf_r+0x5c2>
8000b3de:	f2 cb ff f8 	sub	r11,r9,-8
8000b3e2:	51 0b       	stdsp	sp[0x40],r11
8000b3e4:	fa c6 f9 44 	sub	r6,sp,-1724
8000b3e8:	72 1b       	ld.w	r11,r9[0x4]
8000b3ea:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000b3ee:	72 09       	ld.w	r9,r9[0x0]
8000b3f0:	f9 4b fd 8c 	st.w	r12[-628],r11
8000b3f4:	f9 49 fd 88 	st.w	r12[-632],r9
8000b3f8:	2f f8       	sub	r8,-1
8000b3fa:	14 97       	mov	r7,r10
8000b3fc:	fb 48 06 b4 	st.w	sp[1716],r8
8000b400:	c0 78       	rjmp	8000b40e <_vfprintf_r+0x5ce>
8000b402:	f2 c8 ff f8 	sub	r8,r9,-8
8000b406:	72 1b       	ld.w	r11,r9[0x4]
8000b408:	14 97       	mov	r7,r10
8000b40a:	51 08       	stdsp	sp[0x40],r8
8000b40c:	72 09       	ld.w	r9,r9[0x0]
8000b40e:	16 98       	mov	r8,r11
8000b410:	fa e9 00 00 	st.d	sp[0],r8
8000b414:	ca e8       	rjmp	8000b570 <_vfprintf_r+0x730>
8000b416:	ed b5 00 04 	bld	r5,0x4
8000b41a:	c1 71       	brne	8000b448 <_vfprintf_r+0x608>
8000b41c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b420:	40 3e       	lddsp	lr,sp[0xc]
8000b422:	58 0e       	cp.w	lr,0
8000b424:	c0 80       	breq	8000b434 <_vfprintf_r+0x5f4>
8000b426:	10 36       	cp.w	r6,r8
8000b428:	c6 94       	brge	8000b4fa <_vfprintf_r+0x6ba>
8000b42a:	fa cc f9 44 	sub	r12,sp,-1724
8000b42e:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000b432:	c8 28       	rjmp	8000b536 <_vfprintf_r+0x6f6>
8000b434:	ee ca ff ff 	sub	r10,r7,-1
8000b438:	10 37       	cp.w	r7,r8
8000b43a:	e0 84 00 81 	brge	8000b53c <_vfprintf_r+0x6fc>
8000b43e:	fa cb f9 44 	sub	r11,sp,-1724
8000b442:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b446:	c7 78       	rjmp	8000b534 <_vfprintf_r+0x6f4>
8000b448:	ed b5 00 06 	bld	r5,0x6
8000b44c:	c4 b1       	brne	8000b4e2 <_vfprintf_r+0x6a2>
8000b44e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b452:	40 3c       	lddsp	r12,sp[0xc]
8000b454:	58 0c       	cp.w	r12,0
8000b456:	c1 d0       	breq	8000b490 <_vfprintf_r+0x650>
8000b458:	10 36       	cp.w	r6,r8
8000b45a:	c0 64       	brge	8000b466 <_vfprintf_r+0x626>
8000b45c:	fa cb f9 44 	sub	r11,sp,-1724
8000b460:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b464:	c1 f8       	rjmp	8000b4a2 <_vfprintf_r+0x662>
8000b466:	fa c8 f9 50 	sub	r8,sp,-1712
8000b46a:	1a d8       	st.w	--sp,r8
8000b46c:	fa c8 fa b8 	sub	r8,sp,-1352
8000b470:	1a d8       	st.w	--sp,r8
8000b472:	fa c8 fb b4 	sub	r8,sp,-1100
8000b476:	1a d8       	st.w	--sp,r8
8000b478:	fa c8 f9 40 	sub	r8,sp,-1728
8000b47c:	fa c9 ff b4 	sub	r9,sp,-76
8000b480:	04 9a       	mov	r10,r2
8000b482:	0c 9b       	mov	r11,r6
8000b484:	08 9c       	mov	r12,r4
8000b486:	fe b0 fb 3f 	rcall	8000ab04 <get_arg>
8000b48a:	2f dd       	sub	sp,-12
8000b48c:	98 18       	ld.sh	r8,r12[0x2]
8000b48e:	c2 68       	rjmp	8000b4da <_vfprintf_r+0x69a>
8000b490:	ee ca ff ff 	sub	r10,r7,-1
8000b494:	10 37       	cp.w	r7,r8
8000b496:	c0 94       	brge	8000b4a8 <_vfprintf_r+0x668>
8000b498:	fa c9 f9 44 	sub	r9,sp,-1724
8000b49c:	14 97       	mov	r7,r10
8000b49e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b4a2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000b4a6:	c1 a8       	rjmp	8000b4da <_vfprintf_r+0x69a>
8000b4a8:	41 09       	lddsp	r9,sp[0x40]
8000b4aa:	59 f8       	cp.w	r8,31
8000b4ac:	e0 89 00 13 	brgt	8000b4d2 <_vfprintf_r+0x692>
8000b4b0:	f2 cb ff fc 	sub	r11,r9,-4
8000b4b4:	51 0b       	stdsp	sp[0x40],r11
8000b4b6:	72 09       	ld.w	r9,r9[0x0]
8000b4b8:	fa c6 f9 44 	sub	r6,sp,-1724
8000b4bc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000b4c0:	2f f8       	sub	r8,-1
8000b4c2:	f7 49 fd 88 	st.w	r11[-632],r9
8000b4c6:	fb 48 06 b4 	st.w	sp[1716],r8
8000b4ca:	14 97       	mov	r7,r10
8000b4cc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000b4d0:	c0 58       	rjmp	8000b4da <_vfprintf_r+0x69a>
8000b4d2:	92 18       	ld.sh	r8,r9[0x2]
8000b4d4:	14 97       	mov	r7,r10
8000b4d6:	2f c9       	sub	r9,-4
8000b4d8:	51 09       	stdsp	sp[0x40],r9
8000b4da:	50 18       	stdsp	sp[0x4],r8
8000b4dc:	bf 58       	asr	r8,0x1f
8000b4de:	50 08       	stdsp	sp[0x0],r8
8000b4e0:	c4 88       	rjmp	8000b570 <_vfprintf_r+0x730>
8000b4e2:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b4e6:	40 3c       	lddsp	r12,sp[0xc]
8000b4e8:	58 0c       	cp.w	r12,0
8000b4ea:	c1 d0       	breq	8000b524 <_vfprintf_r+0x6e4>
8000b4ec:	10 36       	cp.w	r6,r8
8000b4ee:	c0 64       	brge	8000b4fa <_vfprintf_r+0x6ba>
8000b4f0:	fa cb f9 44 	sub	r11,sp,-1724
8000b4f4:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b4f8:	c1 f8       	rjmp	8000b536 <_vfprintf_r+0x6f6>
8000b4fa:	fa c8 f9 50 	sub	r8,sp,-1712
8000b4fe:	1a d8       	st.w	--sp,r8
8000b500:	fa c8 fa b8 	sub	r8,sp,-1352
8000b504:	0c 9b       	mov	r11,r6
8000b506:	1a d8       	st.w	--sp,r8
8000b508:	fa c8 fb b4 	sub	r8,sp,-1100
8000b50c:	04 9a       	mov	r10,r2
8000b50e:	1a d8       	st.w	--sp,r8
8000b510:	08 9c       	mov	r12,r4
8000b512:	fa c8 f9 40 	sub	r8,sp,-1728
8000b516:	fa c9 ff b4 	sub	r9,sp,-76
8000b51a:	fe b0 fa f5 	rcall	8000ab04 <get_arg>
8000b51e:	2f dd       	sub	sp,-12
8000b520:	78 0b       	ld.w	r11,r12[0x0]
8000b522:	c2 48       	rjmp	8000b56a <_vfprintf_r+0x72a>
8000b524:	ee ca ff ff 	sub	r10,r7,-1
8000b528:	10 37       	cp.w	r7,r8
8000b52a:	c0 94       	brge	8000b53c <_vfprintf_r+0x6fc>
8000b52c:	fa c9 f9 44 	sub	r9,sp,-1724
8000b530:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b534:	14 97       	mov	r7,r10
8000b536:	ec fb fd 88 	ld.w	r11,r6[-632]
8000b53a:	c1 88       	rjmp	8000b56a <_vfprintf_r+0x72a>
8000b53c:	41 09       	lddsp	r9,sp[0x40]
8000b53e:	59 f8       	cp.w	r8,31
8000b540:	e0 89 00 11 	brgt	8000b562 <_vfprintf_r+0x722>
8000b544:	f2 cb ff fc 	sub	r11,r9,-4
8000b548:	51 0b       	stdsp	sp[0x40],r11
8000b54a:	fa c6 f9 44 	sub	r6,sp,-1724
8000b54e:	72 0b       	ld.w	r11,r9[0x0]
8000b550:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000b554:	f3 4b fd 88 	st.w	r9[-632],r11
8000b558:	2f f8       	sub	r8,-1
8000b55a:	14 97       	mov	r7,r10
8000b55c:	fb 48 06 b4 	st.w	sp[1716],r8
8000b560:	c0 58       	rjmp	8000b56a <_vfprintf_r+0x72a>
8000b562:	72 0b       	ld.w	r11,r9[0x0]
8000b564:	14 97       	mov	r7,r10
8000b566:	2f c9       	sub	r9,-4
8000b568:	51 09       	stdsp	sp[0x40],r9
8000b56a:	50 1b       	stdsp	sp[0x4],r11
8000b56c:	bf 5b       	asr	r11,0x1f
8000b56e:	50 0b       	stdsp	sp[0x0],r11
8000b570:	fa ea 00 00 	ld.d	r10,sp[0]
8000b574:	58 0a       	cp.w	r10,0
8000b576:	5c 2b       	cpc	r11
8000b578:	c0 e4       	brge	8000b594 <_vfprintf_r+0x754>
8000b57a:	30 08       	mov	r8,0
8000b57c:	fa ea 00 00 	ld.d	r10,sp[0]
8000b580:	30 09       	mov	r9,0
8000b582:	f0 0a 01 0a 	sub	r10,r8,r10
8000b586:	f2 0b 01 4b 	sbc	r11,r9,r11
8000b58a:	32 d8       	mov	r8,45
8000b58c:	fa eb 00 00 	st.d	sp[0],r10
8000b590:	fb 68 06 bb 	st.b	sp[1723],r8
8000b594:	30 18       	mov	r8,1
8000b596:	e0 8f 06 fe 	bral	8000c392 <_vfprintf_r+0x1552>
8000b59a:	50 a7       	stdsp	sp[0x28],r7
8000b59c:	50 80       	stdsp	sp[0x20],r0
8000b59e:	0c 97       	mov	r7,r6
8000b5a0:	04 94       	mov	r4,r2
8000b5a2:	06 96       	mov	r6,r3
8000b5a4:	02 92       	mov	r2,r1
8000b5a6:	40 93       	lddsp	r3,sp[0x24]
8000b5a8:	10 90       	mov	r0,r8
8000b5aa:	40 41       	lddsp	r1,sp[0x10]
8000b5ac:	0e 99       	mov	r9,r7
8000b5ae:	ed b5 00 03 	bld	r5,0x3
8000b5b2:	c4 11       	brne	8000b634 <_vfprintf_r+0x7f4>
8000b5b4:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b5b8:	40 3a       	lddsp	r10,sp[0xc]
8000b5ba:	58 0a       	cp.w	r10,0
8000b5bc:	c1 90       	breq	8000b5ee <_vfprintf_r+0x7ae>
8000b5be:	10 36       	cp.w	r6,r8
8000b5c0:	c6 45       	brlt	8000b688 <_vfprintf_r+0x848>
8000b5c2:	fa c8 f9 50 	sub	r8,sp,-1712
8000b5c6:	1a d8       	st.w	--sp,r8
8000b5c8:	fa c8 fa b8 	sub	r8,sp,-1352
8000b5cc:	1a d8       	st.w	--sp,r8
8000b5ce:	fa c8 fb b4 	sub	r8,sp,-1100
8000b5d2:	0c 9b       	mov	r11,r6
8000b5d4:	1a d8       	st.w	--sp,r8
8000b5d6:	04 9a       	mov	r10,r2
8000b5d8:	fa c8 f9 40 	sub	r8,sp,-1728
8000b5dc:	fa c9 ff b4 	sub	r9,sp,-76
8000b5e0:	08 9c       	mov	r12,r4
8000b5e2:	fe b0 fa 91 	rcall	8000ab04 <get_arg>
8000b5e6:	2f dd       	sub	sp,-12
8000b5e8:	78 16       	ld.w	r6,r12[0x4]
8000b5ea:	50 76       	stdsp	sp[0x1c],r6
8000b5ec:	c4 88       	rjmp	8000b67c <_vfprintf_r+0x83c>
8000b5ee:	2f f7       	sub	r7,-1
8000b5f0:	10 39       	cp.w	r9,r8
8000b5f2:	c0 c4       	brge	8000b60a <_vfprintf_r+0x7ca>
8000b5f4:	fa ce f9 44 	sub	lr,sp,-1724
8000b5f8:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000b5fc:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000b600:	50 7c       	stdsp	sp[0x1c],r12
8000b602:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000b606:	50 56       	stdsp	sp[0x14],r6
8000b608:	c6 68       	rjmp	8000b6d4 <_vfprintf_r+0x894>
8000b60a:	41 09       	lddsp	r9,sp[0x40]
8000b60c:	59 f8       	cp.w	r8,31
8000b60e:	e0 89 00 10 	brgt	8000b62e <_vfprintf_r+0x7ee>
8000b612:	f2 ca ff f8 	sub	r10,r9,-8
8000b616:	72 1b       	ld.w	r11,r9[0x4]
8000b618:	51 0a       	stdsp	sp[0x40],r10
8000b61a:	72 09       	ld.w	r9,r9[0x0]
8000b61c:	fa ca f9 44 	sub	r10,sp,-1724
8000b620:	50 7b       	stdsp	sp[0x1c],r11
8000b622:	50 59       	stdsp	sp[0x14],r9
8000b624:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b628:	40 5b       	lddsp	r11,sp[0x14]
8000b62a:	40 7a       	lddsp	r10,sp[0x1c]
8000b62c:	c4 78       	rjmp	8000b6ba <_vfprintf_r+0x87a>
8000b62e:	72 18       	ld.w	r8,r9[0x4]
8000b630:	50 78       	stdsp	sp[0x1c],r8
8000b632:	c4 c8       	rjmp	8000b6ca <_vfprintf_r+0x88a>
8000b634:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b638:	40 3e       	lddsp	lr,sp[0xc]
8000b63a:	58 0e       	cp.w	lr,0
8000b63c:	c2 30       	breq	8000b682 <_vfprintf_r+0x842>
8000b63e:	10 36       	cp.w	r6,r8
8000b640:	c0 94       	brge	8000b652 <_vfprintf_r+0x812>
8000b642:	fa cc f9 44 	sub	r12,sp,-1724
8000b646:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000b64a:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000b64e:	50 7b       	stdsp	sp[0x1c],r11
8000b650:	cd 9b       	rjmp	8000b602 <_vfprintf_r+0x7c2>
8000b652:	fa c8 f9 50 	sub	r8,sp,-1712
8000b656:	1a d8       	st.w	--sp,r8
8000b658:	fa c8 fa b8 	sub	r8,sp,-1352
8000b65c:	04 9a       	mov	r10,r2
8000b65e:	1a d8       	st.w	--sp,r8
8000b660:	fa c8 fb b4 	sub	r8,sp,-1100
8000b664:	0c 9b       	mov	r11,r6
8000b666:	1a d8       	st.w	--sp,r8
8000b668:	08 9c       	mov	r12,r4
8000b66a:	fa c8 f9 40 	sub	r8,sp,-1728
8000b66e:	fa c9 ff b4 	sub	r9,sp,-76
8000b672:	fe b0 fa 49 	rcall	8000ab04 <get_arg>
8000b676:	2f dd       	sub	sp,-12
8000b678:	78 1a       	ld.w	r10,r12[0x4]
8000b67a:	50 7a       	stdsp	sp[0x1c],r10
8000b67c:	78 0c       	ld.w	r12,r12[0x0]
8000b67e:	50 5c       	stdsp	sp[0x14],r12
8000b680:	c2 a8       	rjmp	8000b6d4 <_vfprintf_r+0x894>
8000b682:	2f f7       	sub	r7,-1
8000b684:	10 39       	cp.w	r9,r8
8000b686:	c0 94       	brge	8000b698 <_vfprintf_r+0x858>
8000b688:	fa c9 f9 44 	sub	r9,sp,-1724
8000b68c:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b690:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000b694:	50 78       	stdsp	sp[0x1c],r8
8000b696:	cb 6b       	rjmp	8000b602 <_vfprintf_r+0x7c2>
8000b698:	41 09       	lddsp	r9,sp[0x40]
8000b69a:	59 f8       	cp.w	r8,31
8000b69c:	e0 89 00 15 	brgt	8000b6c6 <_vfprintf_r+0x886>
8000b6a0:	f2 ca ff f8 	sub	r10,r9,-8
8000b6a4:	72 16       	ld.w	r6,r9[0x4]
8000b6a6:	72 09       	ld.w	r9,r9[0x0]
8000b6a8:	51 0a       	stdsp	sp[0x40],r10
8000b6aa:	50 59       	stdsp	sp[0x14],r9
8000b6ac:	fa ce f9 44 	sub	lr,sp,-1724
8000b6b0:	50 76       	stdsp	sp[0x1c],r6
8000b6b2:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000b6b6:	40 5b       	lddsp	r11,sp[0x14]
8000b6b8:	0c 9a       	mov	r10,r6
8000b6ba:	f2 eb fd 88 	st.d	r9[-632],r10
8000b6be:	2f f8       	sub	r8,-1
8000b6c0:	fb 48 06 b4 	st.w	sp[1716],r8
8000b6c4:	c0 88       	rjmp	8000b6d4 <_vfprintf_r+0x894>
8000b6c6:	72 1c       	ld.w	r12,r9[0x4]
8000b6c8:	50 7c       	stdsp	sp[0x1c],r12
8000b6ca:	f2 c8 ff f8 	sub	r8,r9,-8
8000b6ce:	51 08       	stdsp	sp[0x40],r8
8000b6d0:	72 09       	ld.w	r9,r9[0x0]
8000b6d2:	50 59       	stdsp	sp[0x14],r9
8000b6d4:	40 5b       	lddsp	r11,sp[0x14]
8000b6d6:	40 7a       	lddsp	r10,sp[0x1c]
8000b6d8:	e0 a0 19 64 	rcall	8000e9a0 <__isinfd>
8000b6dc:	18 96       	mov	r6,r12
8000b6de:	c1 50       	breq	8000b708 <_vfprintf_r+0x8c8>
8000b6e0:	30 08       	mov	r8,0
8000b6e2:	30 09       	mov	r9,0
8000b6e4:	40 5b       	lddsp	r11,sp[0x14]
8000b6e6:	40 7a       	lddsp	r10,sp[0x1c]
8000b6e8:	e0 a0 1d ba 	rcall	8000f25c <__avr32_f64_cmp_lt>
8000b6ec:	c0 40       	breq	8000b6f4 <_vfprintf_r+0x8b4>
8000b6ee:	32 d8       	mov	r8,45
8000b6f0:	fb 68 06 bb 	st.b	sp[1723],r8
8000b6f4:	4d 18       	lddpc	r8,8000b838 <_vfprintf_r+0x9f8>
8000b6f6:	4d 26       	lddpc	r6,8000b83c <_vfprintf_r+0x9fc>
8000b6f8:	a7 d5       	cbr	r5,0x7
8000b6fa:	e0 40 00 47 	cp.w	r0,71
8000b6fe:	f0 06 17 a0 	movle	r6,r8
8000b702:	30 32       	mov	r2,3
8000b704:	e0 8f 06 d4 	bral	8000c4ac <_vfprintf_r+0x166c>
8000b708:	40 5b       	lddsp	r11,sp[0x14]
8000b70a:	40 7a       	lddsp	r10,sp[0x1c]
8000b70c:	e0 a0 19 5f 	rcall	8000e9ca <__isnand>
8000b710:	c0 c0       	breq	8000b728 <_vfprintf_r+0x8e8>
8000b712:	50 26       	stdsp	sp[0x8],r6
8000b714:	4c b8       	lddpc	r8,8000b840 <_vfprintf_r+0xa00>
8000b716:	4c c6       	lddpc	r6,8000b844 <_vfprintf_r+0xa04>
8000b718:	a7 d5       	cbr	r5,0x7
8000b71a:	e0 40 00 47 	cp.w	r0,71
8000b71e:	f0 06 17 a0 	movle	r6,r8
8000b722:	30 32       	mov	r2,3
8000b724:	e0 8f 06 ca 	bral	8000c4b8 <_vfprintf_r+0x1678>
8000b728:	40 2a       	lddsp	r10,sp[0x8]
8000b72a:	5b fa       	cp.w	r10,-1
8000b72c:	c0 41       	brne	8000b734 <_vfprintf_r+0x8f4>
8000b72e:	30 69       	mov	r9,6
8000b730:	50 29       	stdsp	sp[0x8],r9
8000b732:	c1 18       	rjmp	8000b754 <_vfprintf_r+0x914>
8000b734:	e0 40 00 47 	cp.w	r0,71
8000b738:	5f 09       	sreq	r9
8000b73a:	e0 40 00 67 	cp.w	r0,103
8000b73e:	5f 08       	sreq	r8
8000b740:	f3 e8 10 08 	or	r8,r9,r8
8000b744:	f8 08 18 00 	cp.b	r8,r12
8000b748:	c0 60       	breq	8000b754 <_vfprintf_r+0x914>
8000b74a:	40 28       	lddsp	r8,sp[0x8]
8000b74c:	58 08       	cp.w	r8,0
8000b74e:	f9 b8 00 01 	moveq	r8,1
8000b752:	50 28       	stdsp	sp[0x8],r8
8000b754:	40 78       	lddsp	r8,sp[0x1c]
8000b756:	40 59       	lddsp	r9,sp[0x14]
8000b758:	fa e9 06 94 	st.d	sp[1684],r8
8000b75c:	a9 a5       	sbr	r5,0x8
8000b75e:	fa f8 06 94 	ld.w	r8,sp[1684]
8000b762:	58 08       	cp.w	r8,0
8000b764:	c0 65       	brlt	8000b770 <_vfprintf_r+0x930>
8000b766:	40 5e       	lddsp	lr,sp[0x14]
8000b768:	30 0c       	mov	r12,0
8000b76a:	50 6e       	stdsp	sp[0x18],lr
8000b76c:	50 9c       	stdsp	sp[0x24],r12
8000b76e:	c0 78       	rjmp	8000b77c <_vfprintf_r+0x93c>
8000b770:	40 5b       	lddsp	r11,sp[0x14]
8000b772:	32 da       	mov	r10,45
8000b774:	ee 1b 80 00 	eorh	r11,0x8000
8000b778:	50 9a       	stdsp	sp[0x24],r10
8000b77a:	50 6b       	stdsp	sp[0x18],r11
8000b77c:	e0 40 00 46 	cp.w	r0,70
8000b780:	5f 09       	sreq	r9
8000b782:	e0 40 00 66 	cp.w	r0,102
8000b786:	5f 08       	sreq	r8
8000b788:	f3 e8 10 08 	or	r8,r9,r8
8000b78c:	50 48       	stdsp	sp[0x10],r8
8000b78e:	c0 40       	breq	8000b796 <_vfprintf_r+0x956>
8000b790:	40 22       	lddsp	r2,sp[0x8]
8000b792:	30 39       	mov	r9,3
8000b794:	c1 08       	rjmp	8000b7b4 <_vfprintf_r+0x974>
8000b796:	e0 40 00 45 	cp.w	r0,69
8000b79a:	5f 09       	sreq	r9
8000b79c:	e0 40 00 65 	cp.w	r0,101
8000b7a0:	5f 08       	sreq	r8
8000b7a2:	40 22       	lddsp	r2,sp[0x8]
8000b7a4:	10 49       	or	r9,r8
8000b7a6:	2f f2       	sub	r2,-1
8000b7a8:	40 46       	lddsp	r6,sp[0x10]
8000b7aa:	ec 09 18 00 	cp.b	r9,r6
8000b7ae:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000b7b2:	30 29       	mov	r9,2
8000b7b4:	fa c8 f9 5c 	sub	r8,sp,-1700
8000b7b8:	1a d8       	st.w	--sp,r8
8000b7ba:	fa c8 f9 54 	sub	r8,sp,-1708
8000b7be:	1a d8       	st.w	--sp,r8
8000b7c0:	fa c8 f9 4c 	sub	r8,sp,-1716
8000b7c4:	08 9c       	mov	r12,r4
8000b7c6:	1a d8       	st.w	--sp,r8
8000b7c8:	04 98       	mov	r8,r2
8000b7ca:	40 9b       	lddsp	r11,sp[0x24]
8000b7cc:	40 aa       	lddsp	r10,sp[0x28]
8000b7ce:	e0 a0 0b cf 	rcall	8000cf6c <_dtoa_r>
8000b7d2:	e0 40 00 47 	cp.w	r0,71
8000b7d6:	5f 19       	srne	r9
8000b7d8:	e0 40 00 67 	cp.w	r0,103
8000b7dc:	5f 18       	srne	r8
8000b7de:	18 96       	mov	r6,r12
8000b7e0:	2f dd       	sub	sp,-12
8000b7e2:	f3 e8 00 08 	and	r8,r9,r8
8000b7e6:	c0 41       	brne	8000b7ee <_vfprintf_r+0x9ae>
8000b7e8:	ed b5 00 00 	bld	r5,0x0
8000b7ec:	c3 81       	brne	8000b85c <_vfprintf_r+0xa1c>
8000b7ee:	ec 02 00 0e 	add	lr,r6,r2
8000b7f2:	50 3e       	stdsp	sp[0xc],lr
8000b7f4:	40 4c       	lddsp	r12,sp[0x10]
8000b7f6:	58 0c       	cp.w	r12,0
8000b7f8:	c1 50       	breq	8000b822 <_vfprintf_r+0x9e2>
8000b7fa:	0d 89       	ld.ub	r9,r6[0x0]
8000b7fc:	33 08       	mov	r8,48
8000b7fe:	f0 09 18 00 	cp.b	r9,r8
8000b802:	c0 b1       	brne	8000b818 <_vfprintf_r+0x9d8>
8000b804:	30 08       	mov	r8,0
8000b806:	30 09       	mov	r9,0
8000b808:	40 6b       	lddsp	r11,sp[0x18]
8000b80a:	40 7a       	lddsp	r10,sp[0x1c]
8000b80c:	e0 a0 1c e1 	rcall	8000f1ce <__avr32_f64_cmp_eq>
8000b810:	fb b2 00 01 	rsubeq	r2,1
8000b814:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
8000b818:	40 3b       	lddsp	r11,sp[0xc]
8000b81a:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000b81e:	10 0b       	add	r11,r8
8000b820:	50 3b       	stdsp	sp[0xc],r11
8000b822:	40 6b       	lddsp	r11,sp[0x18]
8000b824:	30 08       	mov	r8,0
8000b826:	30 09       	mov	r9,0
8000b828:	40 7a       	lddsp	r10,sp[0x1c]
8000b82a:	e0 a0 1c d2 	rcall	8000f1ce <__avr32_f64_cmp_eq>
8000b82e:	c1 10       	breq	8000b850 <_vfprintf_r+0xa10>
8000b830:	40 3a       	lddsp	r10,sp[0xc]
8000b832:	fb 4a 06 a4 	st.w	sp[1700],r10
8000b836:	c0 d8       	rjmp	8000b850 <_vfprintf_r+0xa10>
8000b838:	80 01       	ld.sh	r1,r0[0x0]
8000b83a:	91 78       	st.w	r8[0x1c],r8
8000b83c:	80 01       	ld.sh	r1,r0[0x0]
8000b83e:	91 7c       	st.w	r8[0x1c],r12
8000b840:	80 01       	ld.sh	r1,r0[0x0]
8000b842:	91 80       	st.w	r8[0x20],r0
8000b844:	80 01       	ld.sh	r1,r0[0x0]
8000b846:	91 84       	st.w	r8[0x20],r4
8000b848:	10 c9       	st.b	r8++,r9
8000b84a:	fb 48 06 a4 	st.w	sp[1700],r8
8000b84e:	c0 28       	rjmp	8000b852 <_vfprintf_r+0xa12>
8000b850:	33 09       	mov	r9,48
8000b852:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000b856:	40 3e       	lddsp	lr,sp[0xc]
8000b858:	1c 38       	cp.w	r8,lr
8000b85a:	cf 73       	brcs	8000b848 <_vfprintf_r+0xa08>
8000b85c:	e0 40 00 47 	cp.w	r0,71
8000b860:	5f 09       	sreq	r9
8000b862:	e0 40 00 67 	cp.w	r0,103
8000b866:	5f 08       	sreq	r8
8000b868:	f3 e8 10 08 	or	r8,r9,r8
8000b86c:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000b870:	0c 19       	sub	r9,r6
8000b872:	50 69       	stdsp	sp[0x18],r9
8000b874:	58 08       	cp.w	r8,0
8000b876:	c0 b0       	breq	8000b88c <_vfprintf_r+0xa4c>
8000b878:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000b87c:	5b d8       	cp.w	r8,-3
8000b87e:	c0 55       	brlt	8000b888 <_vfprintf_r+0xa48>
8000b880:	40 2c       	lddsp	r12,sp[0x8]
8000b882:	18 38       	cp.w	r8,r12
8000b884:	e0 8a 00 6a 	brle	8000b958 <_vfprintf_r+0xb18>
8000b888:	20 20       	sub	r0,2
8000b88a:	c0 58       	rjmp	8000b894 <_vfprintf_r+0xa54>
8000b88c:	e0 40 00 65 	cp.w	r0,101
8000b890:	e0 89 00 46 	brgt	8000b91c <_vfprintf_r+0xadc>
8000b894:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000b898:	fb 60 06 9c 	st.b	sp[1692],r0
8000b89c:	20 1b       	sub	r11,1
8000b89e:	fb 4b 06 ac 	st.w	sp[1708],r11
8000b8a2:	c0 47       	brpl	8000b8aa <_vfprintf_r+0xa6a>
8000b8a4:	5c 3b       	neg	r11
8000b8a6:	32 d8       	mov	r8,45
8000b8a8:	c0 28       	rjmp	8000b8ac <_vfprintf_r+0xa6c>
8000b8aa:	32 b8       	mov	r8,43
8000b8ac:	fb 68 06 9d 	st.b	sp[1693],r8
8000b8b0:	58 9b       	cp.w	r11,9
8000b8b2:	e0 8a 00 1d 	brle	8000b8ec <_vfprintf_r+0xaac>
8000b8b6:	fa c9 fa 35 	sub	r9,sp,-1483
8000b8ba:	30 aa       	mov	r10,10
8000b8bc:	12 98       	mov	r8,r9
8000b8be:	0e 9c       	mov	r12,r7
8000b8c0:	0c 92       	mov	r2,r6
8000b8c2:	f6 0a 0c 06 	divs	r6,r11,r10
8000b8c6:	0e 9b       	mov	r11,r7
8000b8c8:	2d 0b       	sub	r11,-48
8000b8ca:	10 fb       	st.b	--r8,r11
8000b8cc:	0c 9b       	mov	r11,r6
8000b8ce:	58 96       	cp.w	r6,9
8000b8d0:	fe 99 ff f9 	brgt	8000b8c2 <_vfprintf_r+0xa82>
8000b8d4:	2d 0b       	sub	r11,-48
8000b8d6:	18 97       	mov	r7,r12
8000b8d8:	04 96       	mov	r6,r2
8000b8da:	10 fb       	st.b	--r8,r11
8000b8dc:	fa ca f9 62 	sub	r10,sp,-1694
8000b8e0:	c0 38       	rjmp	8000b8e6 <_vfprintf_r+0xaa6>
8000b8e2:	11 3b       	ld.ub	r11,r8++
8000b8e4:	14 cb       	st.b	r10++,r11
8000b8e6:	12 38       	cp.w	r8,r9
8000b8e8:	cf d3       	brcs	8000b8e2 <_vfprintf_r+0xaa2>
8000b8ea:	c0 98       	rjmp	8000b8fc <_vfprintf_r+0xabc>
8000b8ec:	2d 0b       	sub	r11,-48
8000b8ee:	33 08       	mov	r8,48
8000b8f0:	fb 6b 06 9f 	st.b	sp[1695],r11
8000b8f4:	fb 68 06 9e 	st.b	sp[1694],r8
8000b8f8:	fa ca f9 60 	sub	r10,sp,-1696
8000b8fc:	fa c8 f9 64 	sub	r8,sp,-1692
8000b900:	f4 08 01 08 	sub	r8,r10,r8
8000b904:	50 e8       	stdsp	sp[0x38],r8
8000b906:	10 92       	mov	r2,r8
8000b908:	40 6b       	lddsp	r11,sp[0x18]
8000b90a:	16 02       	add	r2,r11
8000b90c:	58 1b       	cp.w	r11,1
8000b90e:	e0 89 00 05 	brgt	8000b918 <_vfprintf_r+0xad8>
8000b912:	ed b5 00 00 	bld	r5,0x0
8000b916:	c3 51       	brne	8000b980 <_vfprintf_r+0xb40>
8000b918:	2f f2       	sub	r2,-1
8000b91a:	c3 38       	rjmp	8000b980 <_vfprintf_r+0xb40>
8000b91c:	e0 40 00 66 	cp.w	r0,102
8000b920:	c1 c1       	brne	8000b958 <_vfprintf_r+0xb18>
8000b922:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000b926:	58 02       	cp.w	r2,0
8000b928:	e0 8a 00 0c 	brle	8000b940 <_vfprintf_r+0xb00>
8000b92c:	40 2a       	lddsp	r10,sp[0x8]
8000b92e:	58 0a       	cp.w	r10,0
8000b930:	c0 41       	brne	8000b938 <_vfprintf_r+0xaf8>
8000b932:	ed b5 00 00 	bld	r5,0x0
8000b936:	c2 51       	brne	8000b980 <_vfprintf_r+0xb40>
8000b938:	2f f2       	sub	r2,-1
8000b93a:	40 29       	lddsp	r9,sp[0x8]
8000b93c:	12 02       	add	r2,r9
8000b93e:	c0 b8       	rjmp	8000b954 <_vfprintf_r+0xb14>
8000b940:	40 28       	lddsp	r8,sp[0x8]
8000b942:	58 08       	cp.w	r8,0
8000b944:	c0 61       	brne	8000b950 <_vfprintf_r+0xb10>
8000b946:	ed b5 00 00 	bld	r5,0x0
8000b94a:	c0 30       	breq	8000b950 <_vfprintf_r+0xb10>
8000b94c:	30 12       	mov	r2,1
8000b94e:	c1 98       	rjmp	8000b980 <_vfprintf_r+0xb40>
8000b950:	40 22       	lddsp	r2,sp[0x8]
8000b952:	2f e2       	sub	r2,-2
8000b954:	36 60       	mov	r0,102
8000b956:	c1 58       	rjmp	8000b980 <_vfprintf_r+0xb40>
8000b958:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000b95c:	40 6e       	lddsp	lr,sp[0x18]
8000b95e:	1c 32       	cp.w	r2,lr
8000b960:	c0 65       	brlt	8000b96c <_vfprintf_r+0xb2c>
8000b962:	ed b5 00 00 	bld	r5,0x0
8000b966:	f7 b2 00 ff 	subeq	r2,-1
8000b96a:	c0 a8       	rjmp	8000b97e <_vfprintf_r+0xb3e>
8000b96c:	e4 08 11 02 	rsub	r8,r2,2
8000b970:	40 6c       	lddsp	r12,sp[0x18]
8000b972:	58 02       	cp.w	r2,0
8000b974:	f0 02 17 a0 	movle	r2,r8
8000b978:	f9 b2 09 01 	movgt	r2,1
8000b97c:	18 02       	add	r2,r12
8000b97e:	36 70       	mov	r0,103
8000b980:	40 9b       	lddsp	r11,sp[0x24]
8000b982:	58 0b       	cp.w	r11,0
8000b984:	e0 80 05 94 	breq	8000c4ac <_vfprintf_r+0x166c>
8000b988:	32 d8       	mov	r8,45
8000b98a:	fb 68 06 bb 	st.b	sp[1723],r8
8000b98e:	e0 8f 05 93 	bral	8000c4b4 <_vfprintf_r+0x1674>
8000b992:	50 a7       	stdsp	sp[0x28],r7
8000b994:	04 94       	mov	r4,r2
8000b996:	0c 97       	mov	r7,r6
8000b998:	02 92       	mov	r2,r1
8000b99a:	06 96       	mov	r6,r3
8000b99c:	40 41       	lddsp	r1,sp[0x10]
8000b99e:	40 93       	lddsp	r3,sp[0x24]
8000b9a0:	0e 99       	mov	r9,r7
8000b9a2:	ed b5 00 05 	bld	r5,0x5
8000b9a6:	c4 81       	brne	8000ba36 <_vfprintf_r+0xbf6>
8000b9a8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b9ac:	40 3e       	lddsp	lr,sp[0xc]
8000b9ae:	58 0e       	cp.w	lr,0
8000b9b0:	c1 d0       	breq	8000b9ea <_vfprintf_r+0xbaa>
8000b9b2:	10 36       	cp.w	r6,r8
8000b9b4:	c0 64       	brge	8000b9c0 <_vfprintf_r+0xb80>
8000b9b6:	fa cc f9 44 	sub	r12,sp,-1724
8000b9ba:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000b9be:	c1 d8       	rjmp	8000b9f8 <_vfprintf_r+0xbb8>
8000b9c0:	fa c8 f9 50 	sub	r8,sp,-1712
8000b9c4:	1a d8       	st.w	--sp,r8
8000b9c6:	fa c8 fa b8 	sub	r8,sp,-1352
8000b9ca:	04 9a       	mov	r10,r2
8000b9cc:	1a d8       	st.w	--sp,r8
8000b9ce:	fa c8 fb b4 	sub	r8,sp,-1100
8000b9d2:	0c 9b       	mov	r11,r6
8000b9d4:	1a d8       	st.w	--sp,r8
8000b9d6:	08 9c       	mov	r12,r4
8000b9d8:	fa c8 f9 40 	sub	r8,sp,-1728
8000b9dc:	fa c9 ff b4 	sub	r9,sp,-76
8000b9e0:	fe b0 f8 92 	rcall	8000ab04 <get_arg>
8000b9e4:	2f dd       	sub	sp,-12
8000b9e6:	78 0a       	ld.w	r10,r12[0x0]
8000b9e8:	c2 08       	rjmp	8000ba28 <_vfprintf_r+0xbe8>
8000b9ea:	2f f7       	sub	r7,-1
8000b9ec:	10 39       	cp.w	r9,r8
8000b9ee:	c0 84       	brge	8000b9fe <_vfprintf_r+0xbbe>
8000b9f0:	fa cb f9 44 	sub	r11,sp,-1724
8000b9f4:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b9f8:	ec fa fd 88 	ld.w	r10,r6[-632]
8000b9fc:	c1 68       	rjmp	8000ba28 <_vfprintf_r+0xbe8>
8000b9fe:	41 09       	lddsp	r9,sp[0x40]
8000ba00:	59 f8       	cp.w	r8,31
8000ba02:	e0 89 00 10 	brgt	8000ba22 <_vfprintf_r+0xbe2>
8000ba06:	f2 ca ff fc 	sub	r10,r9,-4
8000ba0a:	51 0a       	stdsp	sp[0x40],r10
8000ba0c:	fa c6 f9 44 	sub	r6,sp,-1724
8000ba10:	72 0a       	ld.w	r10,r9[0x0]
8000ba12:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000ba16:	f3 4a fd 88 	st.w	r9[-632],r10
8000ba1a:	2f f8       	sub	r8,-1
8000ba1c:	fb 48 06 b4 	st.w	sp[1716],r8
8000ba20:	c0 48       	rjmp	8000ba28 <_vfprintf_r+0xbe8>
8000ba22:	72 0a       	ld.w	r10,r9[0x0]
8000ba24:	2f c9       	sub	r9,-4
8000ba26:	51 09       	stdsp	sp[0x40],r9
8000ba28:	40 be       	lddsp	lr,sp[0x2c]
8000ba2a:	1c 98       	mov	r8,lr
8000ba2c:	95 1e       	st.w	r10[0x4],lr
8000ba2e:	bf 58       	asr	r8,0x1f
8000ba30:	95 08       	st.w	r10[0x0],r8
8000ba32:	fe 9f fa 92 	bral	8000af56 <_vfprintf_r+0x116>
8000ba36:	ed b5 00 04 	bld	r5,0x4
8000ba3a:	c4 80       	breq	8000baca <_vfprintf_r+0xc8a>
8000ba3c:	e2 15 00 40 	andl	r5,0x40,COH
8000ba40:	c4 50       	breq	8000baca <_vfprintf_r+0xc8a>
8000ba42:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ba46:	40 3c       	lddsp	r12,sp[0xc]
8000ba48:	58 0c       	cp.w	r12,0
8000ba4a:	c1 d0       	breq	8000ba84 <_vfprintf_r+0xc44>
8000ba4c:	10 36       	cp.w	r6,r8
8000ba4e:	c0 64       	brge	8000ba5a <_vfprintf_r+0xc1a>
8000ba50:	fa cb f9 44 	sub	r11,sp,-1724
8000ba54:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000ba58:	c1 d8       	rjmp	8000ba92 <_vfprintf_r+0xc52>
8000ba5a:	fa c8 f9 50 	sub	r8,sp,-1712
8000ba5e:	1a d8       	st.w	--sp,r8
8000ba60:	fa c8 fa b8 	sub	r8,sp,-1352
8000ba64:	04 9a       	mov	r10,r2
8000ba66:	1a d8       	st.w	--sp,r8
8000ba68:	fa c8 fb b4 	sub	r8,sp,-1100
8000ba6c:	0c 9b       	mov	r11,r6
8000ba6e:	1a d8       	st.w	--sp,r8
8000ba70:	08 9c       	mov	r12,r4
8000ba72:	fa c8 f9 40 	sub	r8,sp,-1728
8000ba76:	fa c9 ff b4 	sub	r9,sp,-76
8000ba7a:	fe b0 f8 45 	rcall	8000ab04 <get_arg>
8000ba7e:	2f dd       	sub	sp,-12
8000ba80:	78 0a       	ld.w	r10,r12[0x0]
8000ba82:	c2 08       	rjmp	8000bac2 <_vfprintf_r+0xc82>
8000ba84:	2f f7       	sub	r7,-1
8000ba86:	10 39       	cp.w	r9,r8
8000ba88:	c0 84       	brge	8000ba98 <_vfprintf_r+0xc58>
8000ba8a:	fa ca f9 44 	sub	r10,sp,-1724
8000ba8e:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000ba92:	ec fa fd 88 	ld.w	r10,r6[-632]
8000ba96:	c1 68       	rjmp	8000bac2 <_vfprintf_r+0xc82>
8000ba98:	41 09       	lddsp	r9,sp[0x40]
8000ba9a:	59 f8       	cp.w	r8,31
8000ba9c:	e0 89 00 10 	brgt	8000babc <_vfprintf_r+0xc7c>
8000baa0:	f2 ca ff fc 	sub	r10,r9,-4
8000baa4:	51 0a       	stdsp	sp[0x40],r10
8000baa6:	fa c6 f9 44 	sub	r6,sp,-1724
8000baaa:	72 0a       	ld.w	r10,r9[0x0]
8000baac:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bab0:	f3 4a fd 88 	st.w	r9[-632],r10
8000bab4:	2f f8       	sub	r8,-1
8000bab6:	fb 48 06 b4 	st.w	sp[1716],r8
8000baba:	c0 48       	rjmp	8000bac2 <_vfprintf_r+0xc82>
8000babc:	72 0a       	ld.w	r10,r9[0x0]
8000babe:	2f c9       	sub	r9,-4
8000bac0:	51 09       	stdsp	sp[0x40],r9
8000bac2:	40 be       	lddsp	lr,sp[0x2c]
8000bac4:	b4 0e       	st.h	r10[0x0],lr
8000bac6:	fe 9f fa 48 	bral	8000af56 <_vfprintf_r+0x116>
8000baca:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bace:	40 3c       	lddsp	r12,sp[0xc]
8000bad0:	58 0c       	cp.w	r12,0
8000bad2:	c1 d0       	breq	8000bb0c <_vfprintf_r+0xccc>
8000bad4:	10 36       	cp.w	r6,r8
8000bad6:	c0 64       	brge	8000bae2 <_vfprintf_r+0xca2>
8000bad8:	fa cb f9 44 	sub	r11,sp,-1724
8000badc:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bae0:	c1 d8       	rjmp	8000bb1a <_vfprintf_r+0xcda>
8000bae2:	fa c8 f9 50 	sub	r8,sp,-1712
8000bae6:	1a d8       	st.w	--sp,r8
8000bae8:	fa c8 fa b8 	sub	r8,sp,-1352
8000baec:	04 9a       	mov	r10,r2
8000baee:	1a d8       	st.w	--sp,r8
8000baf0:	fa c8 fb b4 	sub	r8,sp,-1100
8000baf4:	0c 9b       	mov	r11,r6
8000baf6:	1a d8       	st.w	--sp,r8
8000baf8:	08 9c       	mov	r12,r4
8000bafa:	fa c8 f9 40 	sub	r8,sp,-1728
8000bafe:	fa c9 ff b4 	sub	r9,sp,-76
8000bb02:	fe b0 f8 01 	rcall	8000ab04 <get_arg>
8000bb06:	2f dd       	sub	sp,-12
8000bb08:	78 0a       	ld.w	r10,r12[0x0]
8000bb0a:	c2 08       	rjmp	8000bb4a <_vfprintf_r+0xd0a>
8000bb0c:	2f f7       	sub	r7,-1
8000bb0e:	10 39       	cp.w	r9,r8
8000bb10:	c0 84       	brge	8000bb20 <_vfprintf_r+0xce0>
8000bb12:	fa ca f9 44 	sub	r10,sp,-1724
8000bb16:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000bb1a:	ec fa fd 88 	ld.w	r10,r6[-632]
8000bb1e:	c1 68       	rjmp	8000bb4a <_vfprintf_r+0xd0a>
8000bb20:	41 09       	lddsp	r9,sp[0x40]
8000bb22:	59 f8       	cp.w	r8,31
8000bb24:	e0 89 00 10 	brgt	8000bb44 <_vfprintf_r+0xd04>
8000bb28:	f2 ca ff fc 	sub	r10,r9,-4
8000bb2c:	51 0a       	stdsp	sp[0x40],r10
8000bb2e:	fa c6 f9 44 	sub	r6,sp,-1724
8000bb32:	72 0a       	ld.w	r10,r9[0x0]
8000bb34:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bb38:	f3 4a fd 88 	st.w	r9[-632],r10
8000bb3c:	2f f8       	sub	r8,-1
8000bb3e:	fb 48 06 b4 	st.w	sp[1716],r8
8000bb42:	c0 48       	rjmp	8000bb4a <_vfprintf_r+0xd0a>
8000bb44:	72 0a       	ld.w	r10,r9[0x0]
8000bb46:	2f c9       	sub	r9,-4
8000bb48:	51 09       	stdsp	sp[0x40],r9
8000bb4a:	40 be       	lddsp	lr,sp[0x2c]
8000bb4c:	95 0e       	st.w	r10[0x0],lr
8000bb4e:	fe 9f fa 04 	bral	8000af56 <_vfprintf_r+0x116>
8000bb52:	50 a7       	stdsp	sp[0x28],r7
8000bb54:	50 80       	stdsp	sp[0x20],r0
8000bb56:	0c 97       	mov	r7,r6
8000bb58:	04 94       	mov	r4,r2
8000bb5a:	06 96       	mov	r6,r3
8000bb5c:	02 92       	mov	r2,r1
8000bb5e:	40 93       	lddsp	r3,sp[0x24]
8000bb60:	10 90       	mov	r0,r8
8000bb62:	40 41       	lddsp	r1,sp[0x10]
8000bb64:	a5 a5       	sbr	r5,0x4
8000bb66:	c0 a8       	rjmp	8000bb7a <_vfprintf_r+0xd3a>
8000bb68:	50 a7       	stdsp	sp[0x28],r7
8000bb6a:	50 80       	stdsp	sp[0x20],r0
8000bb6c:	0c 97       	mov	r7,r6
8000bb6e:	04 94       	mov	r4,r2
8000bb70:	06 96       	mov	r6,r3
8000bb72:	02 92       	mov	r2,r1
8000bb74:	40 93       	lddsp	r3,sp[0x24]
8000bb76:	10 90       	mov	r0,r8
8000bb78:	40 41       	lddsp	r1,sp[0x10]
8000bb7a:	ed b5 00 05 	bld	r5,0x5
8000bb7e:	c5 d1       	brne	8000bc38 <_vfprintf_r+0xdf8>
8000bb80:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bb84:	40 3c       	lddsp	r12,sp[0xc]
8000bb86:	58 0c       	cp.w	r12,0
8000bb88:	c2 60       	breq	8000bbd4 <_vfprintf_r+0xd94>
8000bb8a:	10 36       	cp.w	r6,r8
8000bb8c:	c0 a4       	brge	8000bba0 <_vfprintf_r+0xd60>
8000bb8e:	fa cb f9 44 	sub	r11,sp,-1724
8000bb92:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bb96:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000bb9a:	fa e9 00 00 	st.d	sp[0],r8
8000bb9e:	c1 88       	rjmp	8000bbce <_vfprintf_r+0xd8e>
8000bba0:	fa c8 f9 50 	sub	r8,sp,-1712
8000bba4:	1a d8       	st.w	--sp,r8
8000bba6:	fa c8 fa b8 	sub	r8,sp,-1352
8000bbaa:	04 9a       	mov	r10,r2
8000bbac:	1a d8       	st.w	--sp,r8
8000bbae:	0c 9b       	mov	r11,r6
8000bbb0:	fa c8 fb b4 	sub	r8,sp,-1100
8000bbb4:	08 9c       	mov	r12,r4
8000bbb6:	1a d8       	st.w	--sp,r8
8000bbb8:	fa c8 f9 40 	sub	r8,sp,-1728
8000bbbc:	fa c9 ff b4 	sub	r9,sp,-76
8000bbc0:	fe b0 f7 a2 	rcall	8000ab04 <get_arg>
8000bbc4:	2f dd       	sub	sp,-12
8000bbc6:	f8 ea 00 00 	ld.d	r10,r12[0]
8000bbca:	fa eb 00 00 	st.d	sp[0],r10
8000bbce:	30 08       	mov	r8,0
8000bbd0:	e0 8f 03 de 	bral	8000c38c <_vfprintf_r+0x154c>
8000bbd4:	ee ca ff ff 	sub	r10,r7,-1
8000bbd8:	10 37       	cp.w	r7,r8
8000bbda:	c0 b4       	brge	8000bbf0 <_vfprintf_r+0xdb0>
8000bbdc:	fa c9 f9 44 	sub	r9,sp,-1724
8000bbe0:	14 97       	mov	r7,r10
8000bbe2:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bbe6:	ec ea fd 88 	ld.d	r10,r6[-632]
8000bbea:	fa eb 00 00 	st.d	sp[0],r10
8000bbee:	c1 88       	rjmp	8000bc1e <_vfprintf_r+0xdde>
8000bbf0:	41 09       	lddsp	r9,sp[0x40]
8000bbf2:	59 f8       	cp.w	r8,31
8000bbf4:	e0 89 00 18 	brgt	8000bc24 <_vfprintf_r+0xde4>
8000bbf8:	f2 e6 00 00 	ld.d	r6,r9[0]
8000bbfc:	f2 cb ff f8 	sub	r11,r9,-8
8000bc00:	fa e7 00 00 	st.d	sp[0],r6
8000bc04:	51 0b       	stdsp	sp[0x40],r11
8000bc06:	fa c6 f9 44 	sub	r6,sp,-1724
8000bc0a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bc0e:	fa e6 00 00 	ld.d	r6,sp[0]
8000bc12:	f2 e7 fd 88 	st.d	r9[-632],r6
8000bc16:	2f f8       	sub	r8,-1
8000bc18:	14 97       	mov	r7,r10
8000bc1a:	fb 48 06 b4 	st.w	sp[1716],r8
8000bc1e:	40 38       	lddsp	r8,sp[0xc]
8000bc20:	e0 8f 03 b6 	bral	8000c38c <_vfprintf_r+0x154c>
8000bc24:	f2 e6 00 00 	ld.d	r6,r9[0]
8000bc28:	40 38       	lddsp	r8,sp[0xc]
8000bc2a:	fa e7 00 00 	st.d	sp[0],r6
8000bc2e:	2f 89       	sub	r9,-8
8000bc30:	14 97       	mov	r7,r10
8000bc32:	51 09       	stdsp	sp[0x40],r9
8000bc34:	e0 8f 03 ac 	bral	8000c38c <_vfprintf_r+0x154c>
8000bc38:	ed b5 00 04 	bld	r5,0x4
8000bc3c:	c1 61       	brne	8000bc68 <_vfprintf_r+0xe28>
8000bc3e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bc42:	40 3e       	lddsp	lr,sp[0xc]
8000bc44:	58 0e       	cp.w	lr,0
8000bc46:	c0 80       	breq	8000bc56 <_vfprintf_r+0xe16>
8000bc48:	10 36       	cp.w	r6,r8
8000bc4a:	c6 74       	brge	8000bd18 <_vfprintf_r+0xed8>
8000bc4c:	fa cc f9 44 	sub	r12,sp,-1724
8000bc50:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000bc54:	c8 08       	rjmp	8000bd54 <_vfprintf_r+0xf14>
8000bc56:	ee ca ff ff 	sub	r10,r7,-1
8000bc5a:	10 37       	cp.w	r7,r8
8000bc5c:	c7 f4       	brge	8000bd5a <_vfprintf_r+0xf1a>
8000bc5e:	fa cb f9 44 	sub	r11,sp,-1724
8000bc62:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bc66:	c7 68       	rjmp	8000bd52 <_vfprintf_r+0xf12>
8000bc68:	ed b5 00 06 	bld	r5,0x6
8000bc6c:	c4 a1       	brne	8000bd00 <_vfprintf_r+0xec0>
8000bc6e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bc72:	40 3c       	lddsp	r12,sp[0xc]
8000bc74:	58 0c       	cp.w	r12,0
8000bc76:	c1 d0       	breq	8000bcb0 <_vfprintf_r+0xe70>
8000bc78:	10 36       	cp.w	r6,r8
8000bc7a:	c0 64       	brge	8000bc86 <_vfprintf_r+0xe46>
8000bc7c:	fa cb f9 44 	sub	r11,sp,-1724
8000bc80:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bc84:	c1 f8       	rjmp	8000bcc2 <_vfprintf_r+0xe82>
8000bc86:	fa c8 f9 50 	sub	r8,sp,-1712
8000bc8a:	1a d8       	st.w	--sp,r8
8000bc8c:	fa c8 fa b8 	sub	r8,sp,-1352
8000bc90:	1a d8       	st.w	--sp,r8
8000bc92:	fa c8 fb b4 	sub	r8,sp,-1100
8000bc96:	1a d8       	st.w	--sp,r8
8000bc98:	fa c8 f9 40 	sub	r8,sp,-1728
8000bc9c:	fa c9 ff b4 	sub	r9,sp,-76
8000bca0:	04 9a       	mov	r10,r2
8000bca2:	0c 9b       	mov	r11,r6
8000bca4:	08 9c       	mov	r12,r4
8000bca6:	fe b0 f7 2f 	rcall	8000ab04 <get_arg>
8000bcaa:	2f dd       	sub	sp,-12
8000bcac:	98 18       	ld.sh	r8,r12[0x2]
8000bcae:	c2 68       	rjmp	8000bcfa <_vfprintf_r+0xeba>
8000bcb0:	ee ca ff ff 	sub	r10,r7,-1
8000bcb4:	10 37       	cp.w	r7,r8
8000bcb6:	c0 94       	brge	8000bcc8 <_vfprintf_r+0xe88>
8000bcb8:	fa c9 f9 44 	sub	r9,sp,-1724
8000bcbc:	14 97       	mov	r7,r10
8000bcbe:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bcc2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000bcc6:	c1 a8       	rjmp	8000bcfa <_vfprintf_r+0xeba>
8000bcc8:	41 09       	lddsp	r9,sp[0x40]
8000bcca:	59 f8       	cp.w	r8,31
8000bccc:	e0 89 00 13 	brgt	8000bcf2 <_vfprintf_r+0xeb2>
8000bcd0:	f2 cb ff fc 	sub	r11,r9,-4
8000bcd4:	51 0b       	stdsp	sp[0x40],r11
8000bcd6:	72 09       	ld.w	r9,r9[0x0]
8000bcd8:	fa c6 f9 44 	sub	r6,sp,-1724
8000bcdc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000bce0:	2f f8       	sub	r8,-1
8000bce2:	f7 49 fd 88 	st.w	r11[-632],r9
8000bce6:	fb 48 06 b4 	st.w	sp[1716],r8
8000bcea:	14 97       	mov	r7,r10
8000bcec:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000bcf0:	c0 58       	rjmp	8000bcfa <_vfprintf_r+0xeba>
8000bcf2:	92 18       	ld.sh	r8,r9[0x2]
8000bcf4:	14 97       	mov	r7,r10
8000bcf6:	2f c9       	sub	r9,-4
8000bcf8:	51 09       	stdsp	sp[0x40],r9
8000bcfa:	5c 78       	castu.h	r8
8000bcfc:	50 18       	stdsp	sp[0x4],r8
8000bcfe:	c4 68       	rjmp	8000bd8a <_vfprintf_r+0xf4a>
8000bd00:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bd04:	40 3c       	lddsp	r12,sp[0xc]
8000bd06:	58 0c       	cp.w	r12,0
8000bd08:	c1 d0       	breq	8000bd42 <_vfprintf_r+0xf02>
8000bd0a:	10 36       	cp.w	r6,r8
8000bd0c:	c0 64       	brge	8000bd18 <_vfprintf_r+0xed8>
8000bd0e:	fa cb f9 44 	sub	r11,sp,-1724
8000bd12:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bd16:	c1 f8       	rjmp	8000bd54 <_vfprintf_r+0xf14>
8000bd18:	fa c8 f9 50 	sub	r8,sp,-1712
8000bd1c:	1a d8       	st.w	--sp,r8
8000bd1e:	fa c8 fa b8 	sub	r8,sp,-1352
8000bd22:	0c 9b       	mov	r11,r6
8000bd24:	1a d8       	st.w	--sp,r8
8000bd26:	fa c8 fb b4 	sub	r8,sp,-1100
8000bd2a:	04 9a       	mov	r10,r2
8000bd2c:	1a d8       	st.w	--sp,r8
8000bd2e:	08 9c       	mov	r12,r4
8000bd30:	fa c8 f9 40 	sub	r8,sp,-1728
8000bd34:	fa c9 ff b4 	sub	r9,sp,-76
8000bd38:	fe b0 f6 e6 	rcall	8000ab04 <get_arg>
8000bd3c:	2f dd       	sub	sp,-12
8000bd3e:	78 0b       	ld.w	r11,r12[0x0]
8000bd40:	c2 48       	rjmp	8000bd88 <_vfprintf_r+0xf48>
8000bd42:	ee ca ff ff 	sub	r10,r7,-1
8000bd46:	10 37       	cp.w	r7,r8
8000bd48:	c0 94       	brge	8000bd5a <_vfprintf_r+0xf1a>
8000bd4a:	fa c9 f9 44 	sub	r9,sp,-1724
8000bd4e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bd52:	14 97       	mov	r7,r10
8000bd54:	ec fb fd 88 	ld.w	r11,r6[-632]
8000bd58:	c1 88       	rjmp	8000bd88 <_vfprintf_r+0xf48>
8000bd5a:	41 09       	lddsp	r9,sp[0x40]
8000bd5c:	59 f8       	cp.w	r8,31
8000bd5e:	e0 89 00 11 	brgt	8000bd80 <_vfprintf_r+0xf40>
8000bd62:	f2 cb ff fc 	sub	r11,r9,-4
8000bd66:	51 0b       	stdsp	sp[0x40],r11
8000bd68:	fa c6 f9 44 	sub	r6,sp,-1724
8000bd6c:	72 0b       	ld.w	r11,r9[0x0]
8000bd6e:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bd72:	f3 4b fd 88 	st.w	r9[-632],r11
8000bd76:	2f f8       	sub	r8,-1
8000bd78:	14 97       	mov	r7,r10
8000bd7a:	fb 48 06 b4 	st.w	sp[1716],r8
8000bd7e:	c0 58       	rjmp	8000bd88 <_vfprintf_r+0xf48>
8000bd80:	72 0b       	ld.w	r11,r9[0x0]
8000bd82:	14 97       	mov	r7,r10
8000bd84:	2f c9       	sub	r9,-4
8000bd86:	51 09       	stdsp	sp[0x40],r9
8000bd88:	50 1b       	stdsp	sp[0x4],r11
8000bd8a:	30 0e       	mov	lr,0
8000bd8c:	50 0e       	stdsp	sp[0x0],lr
8000bd8e:	1c 98       	mov	r8,lr
8000bd90:	e0 8f 02 fe 	bral	8000c38c <_vfprintf_r+0x154c>
8000bd94:	50 a7       	stdsp	sp[0x28],r7
8000bd96:	50 80       	stdsp	sp[0x20],r0
8000bd98:	0c 97       	mov	r7,r6
8000bd9a:	04 94       	mov	r4,r2
8000bd9c:	06 96       	mov	r6,r3
8000bd9e:	02 92       	mov	r2,r1
8000bda0:	40 93       	lddsp	r3,sp[0x24]
8000bda2:	40 41       	lddsp	r1,sp[0x10]
8000bda4:	0e 99       	mov	r9,r7
8000bda6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bdaa:	40 3c       	lddsp	r12,sp[0xc]
8000bdac:	58 0c       	cp.w	r12,0
8000bdae:	c1 d0       	breq	8000bde8 <_vfprintf_r+0xfa8>
8000bdb0:	10 36       	cp.w	r6,r8
8000bdb2:	c0 64       	brge	8000bdbe <_vfprintf_r+0xf7e>
8000bdb4:	fa cb f9 44 	sub	r11,sp,-1724
8000bdb8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bdbc:	c1 d8       	rjmp	8000bdf6 <_vfprintf_r+0xfb6>
8000bdbe:	fa c8 f9 50 	sub	r8,sp,-1712
8000bdc2:	1a d8       	st.w	--sp,r8
8000bdc4:	fa c8 fa b8 	sub	r8,sp,-1352
8000bdc8:	1a d8       	st.w	--sp,r8
8000bdca:	fa c8 fb b4 	sub	r8,sp,-1100
8000bdce:	1a d8       	st.w	--sp,r8
8000bdd0:	fa c9 ff b4 	sub	r9,sp,-76
8000bdd4:	fa c8 f9 40 	sub	r8,sp,-1728
8000bdd8:	04 9a       	mov	r10,r2
8000bdda:	0c 9b       	mov	r11,r6
8000bddc:	08 9c       	mov	r12,r4
8000bdde:	fe b0 f6 93 	rcall	8000ab04 <get_arg>
8000bde2:	2f dd       	sub	sp,-12
8000bde4:	78 09       	ld.w	r9,r12[0x0]
8000bde6:	c2 18       	rjmp	8000be28 <_vfprintf_r+0xfe8>
8000bde8:	2f f7       	sub	r7,-1
8000bdea:	10 39       	cp.w	r9,r8
8000bdec:	c0 84       	brge	8000bdfc <_vfprintf_r+0xfbc>
8000bdee:	fa ca f9 44 	sub	r10,sp,-1724
8000bdf2:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000bdf6:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000bdfa:	c1 78       	rjmp	8000be28 <_vfprintf_r+0xfe8>
8000bdfc:	41 09       	lddsp	r9,sp[0x40]
8000bdfe:	59 f8       	cp.w	r8,31
8000be00:	e0 89 00 10 	brgt	8000be20 <_vfprintf_r+0xfe0>
8000be04:	f2 ca ff fc 	sub	r10,r9,-4
8000be08:	51 0a       	stdsp	sp[0x40],r10
8000be0a:	fa c6 f9 44 	sub	r6,sp,-1724
8000be0e:	72 09       	ld.w	r9,r9[0x0]
8000be10:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000be14:	f5 49 fd 88 	st.w	r10[-632],r9
8000be18:	2f f8       	sub	r8,-1
8000be1a:	fb 48 06 b4 	st.w	sp[1716],r8
8000be1e:	c0 58       	rjmp	8000be28 <_vfprintf_r+0xfe8>
8000be20:	f2 c8 ff fc 	sub	r8,r9,-4
8000be24:	51 08       	stdsp	sp[0x40],r8
8000be26:	72 09       	ld.w	r9,r9[0x0]
8000be28:	33 08       	mov	r8,48
8000be2a:	fb 68 06 b8 	st.b	sp[1720],r8
8000be2e:	37 88       	mov	r8,120
8000be30:	30 0e       	mov	lr,0
8000be32:	fb 68 06 b9 	st.b	sp[1721],r8
8000be36:	4c ac       	lddpc	r12,8000bf5c <_vfprintf_r+0x111c>
8000be38:	50 19       	stdsp	sp[0x4],r9
8000be3a:	a1 b5       	sbr	r5,0x1
8000be3c:	50 0e       	stdsp	sp[0x0],lr
8000be3e:	50 dc       	stdsp	sp[0x34],r12
8000be40:	30 28       	mov	r8,2
8000be42:	37 80       	mov	r0,120
8000be44:	e0 8f 02 a4 	bral	8000c38c <_vfprintf_r+0x154c>
8000be48:	50 a7       	stdsp	sp[0x28],r7
8000be4a:	50 80       	stdsp	sp[0x20],r0
8000be4c:	10 90       	mov	r0,r8
8000be4e:	30 08       	mov	r8,0
8000be50:	fb 68 06 bb 	st.b	sp[1723],r8
8000be54:	0c 97       	mov	r7,r6
8000be56:	04 94       	mov	r4,r2
8000be58:	06 96       	mov	r6,r3
8000be5a:	02 92       	mov	r2,r1
8000be5c:	40 93       	lddsp	r3,sp[0x24]
8000be5e:	40 41       	lddsp	r1,sp[0x10]
8000be60:	0e 99       	mov	r9,r7
8000be62:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000be66:	40 3b       	lddsp	r11,sp[0xc]
8000be68:	58 0b       	cp.w	r11,0
8000be6a:	c1 d0       	breq	8000bea4 <_vfprintf_r+0x1064>
8000be6c:	10 36       	cp.w	r6,r8
8000be6e:	c0 64       	brge	8000be7a <_vfprintf_r+0x103a>
8000be70:	fa ca f9 44 	sub	r10,sp,-1724
8000be74:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000be78:	c1 d8       	rjmp	8000beb2 <_vfprintf_r+0x1072>
8000be7a:	fa c8 f9 50 	sub	r8,sp,-1712
8000be7e:	1a d8       	st.w	--sp,r8
8000be80:	fa c8 fa b8 	sub	r8,sp,-1352
8000be84:	1a d8       	st.w	--sp,r8
8000be86:	fa c8 fb b4 	sub	r8,sp,-1100
8000be8a:	0c 9b       	mov	r11,r6
8000be8c:	1a d8       	st.w	--sp,r8
8000be8e:	04 9a       	mov	r10,r2
8000be90:	fa c8 f9 40 	sub	r8,sp,-1728
8000be94:	fa c9 ff b4 	sub	r9,sp,-76
8000be98:	08 9c       	mov	r12,r4
8000be9a:	fe b0 f6 35 	rcall	8000ab04 <get_arg>
8000be9e:	2f dd       	sub	sp,-12
8000bea0:	78 06       	ld.w	r6,r12[0x0]
8000bea2:	c2 08       	rjmp	8000bee2 <_vfprintf_r+0x10a2>
8000bea4:	2f f7       	sub	r7,-1
8000bea6:	10 39       	cp.w	r9,r8
8000bea8:	c0 84       	brge	8000beb8 <_vfprintf_r+0x1078>
8000beaa:	fa c9 f9 44 	sub	r9,sp,-1724
8000beae:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000beb2:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000beb6:	c1 68       	rjmp	8000bee2 <_vfprintf_r+0x10a2>
8000beb8:	41 09       	lddsp	r9,sp[0x40]
8000beba:	59 f8       	cp.w	r8,31
8000bebc:	e0 89 00 10 	brgt	8000bedc <_vfprintf_r+0x109c>
8000bec0:	f2 ca ff fc 	sub	r10,r9,-4
8000bec4:	51 0a       	stdsp	sp[0x40],r10
8000bec6:	72 06       	ld.w	r6,r9[0x0]
8000bec8:	fa ce f9 44 	sub	lr,sp,-1724
8000becc:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000bed0:	f3 46 fd 88 	st.w	r9[-632],r6
8000bed4:	2f f8       	sub	r8,-1
8000bed6:	fb 48 06 b4 	st.w	sp[1716],r8
8000beda:	c0 48       	rjmp	8000bee2 <_vfprintf_r+0x10a2>
8000bedc:	72 06       	ld.w	r6,r9[0x0]
8000bede:	2f c9       	sub	r9,-4
8000bee0:	51 09       	stdsp	sp[0x40],r9
8000bee2:	40 2c       	lddsp	r12,sp[0x8]
8000bee4:	58 0c       	cp.w	r12,0
8000bee6:	c1 05       	brlt	8000bf06 <_vfprintf_r+0x10c6>
8000bee8:	18 9a       	mov	r10,r12
8000beea:	30 0b       	mov	r11,0
8000beec:	0c 9c       	mov	r12,r6
8000beee:	e0 a0 12 43 	rcall	8000e374 <memchr>
8000bef2:	e0 80 02 e0 	breq	8000c4b2 <_vfprintf_r+0x1672>
8000bef6:	f8 06 01 02 	sub	r2,r12,r6
8000befa:	40 2b       	lddsp	r11,sp[0x8]
8000befc:	16 32       	cp.w	r2,r11
8000befe:	e0 89 02 da 	brgt	8000c4b2 <_vfprintf_r+0x1672>
8000bf02:	e0 8f 02 d5 	bral	8000c4ac <_vfprintf_r+0x166c>
8000bf06:	30 0a       	mov	r10,0
8000bf08:	0c 9c       	mov	r12,r6
8000bf0a:	50 2a       	stdsp	sp[0x8],r10
8000bf0c:	fe b0 f4 ff 	rcall	8000a90a <strlen>
8000bf10:	18 92       	mov	r2,r12
8000bf12:	e0 8f 02 d3 	bral	8000c4b8 <_vfprintf_r+0x1678>
8000bf16:	50 a7       	stdsp	sp[0x28],r7
8000bf18:	50 80       	stdsp	sp[0x20],r0
8000bf1a:	0c 97       	mov	r7,r6
8000bf1c:	04 94       	mov	r4,r2
8000bf1e:	06 96       	mov	r6,r3
8000bf20:	02 92       	mov	r2,r1
8000bf22:	40 93       	lddsp	r3,sp[0x24]
8000bf24:	10 90       	mov	r0,r8
8000bf26:	40 41       	lddsp	r1,sp[0x10]
8000bf28:	a5 a5       	sbr	r5,0x4
8000bf2a:	c0 a8       	rjmp	8000bf3e <_vfprintf_r+0x10fe>
8000bf2c:	50 a7       	stdsp	sp[0x28],r7
8000bf2e:	50 80       	stdsp	sp[0x20],r0
8000bf30:	0c 97       	mov	r7,r6
8000bf32:	04 94       	mov	r4,r2
8000bf34:	06 96       	mov	r6,r3
8000bf36:	02 92       	mov	r2,r1
8000bf38:	40 93       	lddsp	r3,sp[0x24]
8000bf3a:	10 90       	mov	r0,r8
8000bf3c:	40 41       	lddsp	r1,sp[0x10]
8000bf3e:	ed b5 00 05 	bld	r5,0x5
8000bf42:	c5 71       	brne	8000bff0 <_vfprintf_r+0x11b0>
8000bf44:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bf48:	40 39       	lddsp	r9,sp[0xc]
8000bf4a:	58 09       	cp.w	r9,0
8000bf4c:	c2 20       	breq	8000bf90 <_vfprintf_r+0x1150>
8000bf4e:	10 36       	cp.w	r6,r8
8000bf50:	c0 84       	brge	8000bf60 <_vfprintf_r+0x1120>
8000bf52:	fa c8 f9 44 	sub	r8,sp,-1724
8000bf56:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000bf5a:	c2 48       	rjmp	8000bfa2 <_vfprintf_r+0x1162>
8000bf5c:	80 01       	ld.sh	r1,r0[0x0]
8000bf5e:	91 88       	st.w	r8[0x20],r8
8000bf60:	fa c8 f9 50 	sub	r8,sp,-1712
8000bf64:	1a d8       	st.w	--sp,r8
8000bf66:	fa c8 fa b8 	sub	r8,sp,-1352
8000bf6a:	1a d8       	st.w	--sp,r8
8000bf6c:	fa c8 fb b4 	sub	r8,sp,-1100
8000bf70:	1a d8       	st.w	--sp,r8
8000bf72:	fa c8 f9 40 	sub	r8,sp,-1728
8000bf76:	fa c9 ff b4 	sub	r9,sp,-76
8000bf7a:	04 9a       	mov	r10,r2
8000bf7c:	0c 9b       	mov	r11,r6
8000bf7e:	08 9c       	mov	r12,r4
8000bf80:	fe b0 f5 c2 	rcall	8000ab04 <get_arg>
8000bf84:	2f dd       	sub	sp,-12
8000bf86:	f8 e8 00 00 	ld.d	r8,r12[0]
8000bf8a:	fa e9 00 00 	st.d	sp[0],r8
8000bf8e:	c2 e8       	rjmp	8000bfea <_vfprintf_r+0x11aa>
8000bf90:	ee ca ff ff 	sub	r10,r7,-1
8000bf94:	10 37       	cp.w	r7,r8
8000bf96:	c0 b4       	brge	8000bfac <_vfprintf_r+0x116c>
8000bf98:	fa c8 f9 44 	sub	r8,sp,-1724
8000bf9c:	14 97       	mov	r7,r10
8000bf9e:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000bfa2:	ec ea fd 88 	ld.d	r10,r6[-632]
8000bfa6:	fa eb 00 00 	st.d	sp[0],r10
8000bfaa:	c2 08       	rjmp	8000bfea <_vfprintf_r+0x11aa>
8000bfac:	41 09       	lddsp	r9,sp[0x40]
8000bfae:	59 f8       	cp.w	r8,31
8000bfb0:	e0 89 00 16 	brgt	8000bfdc <_vfprintf_r+0x119c>
8000bfb4:	f2 e6 00 00 	ld.d	r6,r9[0]
8000bfb8:	f2 cb ff f8 	sub	r11,r9,-8
8000bfbc:	fa e7 00 00 	st.d	sp[0],r6
8000bfc0:	51 0b       	stdsp	sp[0x40],r11
8000bfc2:	fa c6 f9 44 	sub	r6,sp,-1724
8000bfc6:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bfca:	fa e6 00 00 	ld.d	r6,sp[0]
8000bfce:	f2 e7 fd 88 	st.d	r9[-632],r6
8000bfd2:	2f f8       	sub	r8,-1
8000bfd4:	14 97       	mov	r7,r10
8000bfd6:	fb 48 06 b4 	st.w	sp[1716],r8
8000bfda:	c0 88       	rjmp	8000bfea <_vfprintf_r+0x11aa>
8000bfdc:	f2 e6 00 00 	ld.d	r6,r9[0]
8000bfe0:	2f 89       	sub	r9,-8
8000bfe2:	fa e7 00 00 	st.d	sp[0],r6
8000bfe6:	51 09       	stdsp	sp[0x40],r9
8000bfe8:	14 97       	mov	r7,r10
8000bfea:	30 18       	mov	r8,1
8000bfec:	e0 8f 01 d0 	bral	8000c38c <_vfprintf_r+0x154c>
8000bff0:	ed b5 00 04 	bld	r5,0x4
8000bff4:	c1 61       	brne	8000c020 <_vfprintf_r+0x11e0>
8000bff6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bffa:	40 3e       	lddsp	lr,sp[0xc]
8000bffc:	58 0e       	cp.w	lr,0
8000bffe:	c0 80       	breq	8000c00e <_vfprintf_r+0x11ce>
8000c000:	10 36       	cp.w	r6,r8
8000c002:	c6 74       	brge	8000c0d0 <_vfprintf_r+0x1290>
8000c004:	fa cc f9 44 	sub	r12,sp,-1724
8000c008:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c00c:	c8 08       	rjmp	8000c10c <_vfprintf_r+0x12cc>
8000c00e:	ee ca ff ff 	sub	r10,r7,-1
8000c012:	10 37       	cp.w	r7,r8
8000c014:	c7 f4       	brge	8000c112 <_vfprintf_r+0x12d2>
8000c016:	fa cb f9 44 	sub	r11,sp,-1724
8000c01a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c01e:	c7 68       	rjmp	8000c10a <_vfprintf_r+0x12ca>
8000c020:	ed b5 00 06 	bld	r5,0x6
8000c024:	c4 a1       	brne	8000c0b8 <_vfprintf_r+0x1278>
8000c026:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c02a:	40 3c       	lddsp	r12,sp[0xc]
8000c02c:	58 0c       	cp.w	r12,0
8000c02e:	c1 d0       	breq	8000c068 <_vfprintf_r+0x1228>
8000c030:	10 36       	cp.w	r6,r8
8000c032:	c0 64       	brge	8000c03e <_vfprintf_r+0x11fe>
8000c034:	fa cb f9 44 	sub	r11,sp,-1724
8000c038:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c03c:	c1 f8       	rjmp	8000c07a <_vfprintf_r+0x123a>
8000c03e:	fa c8 f9 50 	sub	r8,sp,-1712
8000c042:	1a d8       	st.w	--sp,r8
8000c044:	fa c8 fa b8 	sub	r8,sp,-1352
8000c048:	1a d8       	st.w	--sp,r8
8000c04a:	fa c8 fb b4 	sub	r8,sp,-1100
8000c04e:	1a d8       	st.w	--sp,r8
8000c050:	fa c8 f9 40 	sub	r8,sp,-1728
8000c054:	fa c9 ff b4 	sub	r9,sp,-76
8000c058:	04 9a       	mov	r10,r2
8000c05a:	0c 9b       	mov	r11,r6
8000c05c:	08 9c       	mov	r12,r4
8000c05e:	fe b0 f5 53 	rcall	8000ab04 <get_arg>
8000c062:	2f dd       	sub	sp,-12
8000c064:	98 18       	ld.sh	r8,r12[0x2]
8000c066:	c2 68       	rjmp	8000c0b2 <_vfprintf_r+0x1272>
8000c068:	ee ca ff ff 	sub	r10,r7,-1
8000c06c:	10 37       	cp.w	r7,r8
8000c06e:	c0 94       	brge	8000c080 <_vfprintf_r+0x1240>
8000c070:	fa c9 f9 44 	sub	r9,sp,-1724
8000c074:	14 97       	mov	r7,r10
8000c076:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c07a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c07e:	c1 a8       	rjmp	8000c0b2 <_vfprintf_r+0x1272>
8000c080:	41 09       	lddsp	r9,sp[0x40]
8000c082:	59 f8       	cp.w	r8,31
8000c084:	e0 89 00 13 	brgt	8000c0aa <_vfprintf_r+0x126a>
8000c088:	f2 cb ff fc 	sub	r11,r9,-4
8000c08c:	51 0b       	stdsp	sp[0x40],r11
8000c08e:	72 09       	ld.w	r9,r9[0x0]
8000c090:	fa c6 f9 44 	sub	r6,sp,-1724
8000c094:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c098:	2f f8       	sub	r8,-1
8000c09a:	f7 49 fd 88 	st.w	r11[-632],r9
8000c09e:	fb 48 06 b4 	st.w	sp[1716],r8
8000c0a2:	14 97       	mov	r7,r10
8000c0a4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c0a8:	c0 58       	rjmp	8000c0b2 <_vfprintf_r+0x1272>
8000c0aa:	92 18       	ld.sh	r8,r9[0x2]
8000c0ac:	14 97       	mov	r7,r10
8000c0ae:	2f c9       	sub	r9,-4
8000c0b0:	51 09       	stdsp	sp[0x40],r9
8000c0b2:	5c 78       	castu.h	r8
8000c0b4:	50 18       	stdsp	sp[0x4],r8
8000c0b6:	c4 68       	rjmp	8000c142 <_vfprintf_r+0x1302>
8000c0b8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c0bc:	40 3c       	lddsp	r12,sp[0xc]
8000c0be:	58 0c       	cp.w	r12,0
8000c0c0:	c1 d0       	breq	8000c0fa <_vfprintf_r+0x12ba>
8000c0c2:	10 36       	cp.w	r6,r8
8000c0c4:	c0 64       	brge	8000c0d0 <_vfprintf_r+0x1290>
8000c0c6:	fa cb f9 44 	sub	r11,sp,-1724
8000c0ca:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c0ce:	c1 f8       	rjmp	8000c10c <_vfprintf_r+0x12cc>
8000c0d0:	fa c8 f9 50 	sub	r8,sp,-1712
8000c0d4:	1a d8       	st.w	--sp,r8
8000c0d6:	fa c8 fa b8 	sub	r8,sp,-1352
8000c0da:	0c 9b       	mov	r11,r6
8000c0dc:	1a d8       	st.w	--sp,r8
8000c0de:	fa c8 fb b4 	sub	r8,sp,-1100
8000c0e2:	04 9a       	mov	r10,r2
8000c0e4:	1a d8       	st.w	--sp,r8
8000c0e6:	08 9c       	mov	r12,r4
8000c0e8:	fa c8 f9 40 	sub	r8,sp,-1728
8000c0ec:	fa c9 ff b4 	sub	r9,sp,-76
8000c0f0:	fe b0 f5 0a 	rcall	8000ab04 <get_arg>
8000c0f4:	2f dd       	sub	sp,-12
8000c0f6:	78 0b       	ld.w	r11,r12[0x0]
8000c0f8:	c2 48       	rjmp	8000c140 <_vfprintf_r+0x1300>
8000c0fa:	ee ca ff ff 	sub	r10,r7,-1
8000c0fe:	10 37       	cp.w	r7,r8
8000c100:	c0 94       	brge	8000c112 <_vfprintf_r+0x12d2>
8000c102:	fa c9 f9 44 	sub	r9,sp,-1724
8000c106:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c10a:	14 97       	mov	r7,r10
8000c10c:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c110:	c1 88       	rjmp	8000c140 <_vfprintf_r+0x1300>
8000c112:	41 09       	lddsp	r9,sp[0x40]
8000c114:	59 f8       	cp.w	r8,31
8000c116:	e0 89 00 11 	brgt	8000c138 <_vfprintf_r+0x12f8>
8000c11a:	f2 cb ff fc 	sub	r11,r9,-4
8000c11e:	51 0b       	stdsp	sp[0x40],r11
8000c120:	fa c6 f9 44 	sub	r6,sp,-1724
8000c124:	72 0b       	ld.w	r11,r9[0x0]
8000c126:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c12a:	f3 4b fd 88 	st.w	r9[-632],r11
8000c12e:	2f f8       	sub	r8,-1
8000c130:	14 97       	mov	r7,r10
8000c132:	fb 48 06 b4 	st.w	sp[1716],r8
8000c136:	c0 58       	rjmp	8000c140 <_vfprintf_r+0x1300>
8000c138:	72 0b       	ld.w	r11,r9[0x0]
8000c13a:	14 97       	mov	r7,r10
8000c13c:	2f c9       	sub	r9,-4
8000c13e:	51 09       	stdsp	sp[0x40],r9
8000c140:	50 1b       	stdsp	sp[0x4],r11
8000c142:	30 0e       	mov	lr,0
8000c144:	30 18       	mov	r8,1
8000c146:	50 0e       	stdsp	sp[0x0],lr
8000c148:	c2 29       	rjmp	8000c38c <_vfprintf_r+0x154c>
8000c14a:	50 a7       	stdsp	sp[0x28],r7
8000c14c:	50 80       	stdsp	sp[0x20],r0
8000c14e:	0c 97       	mov	r7,r6
8000c150:	04 94       	mov	r4,r2
8000c152:	06 96       	mov	r6,r3
8000c154:	02 92       	mov	r2,r1
8000c156:	4d 3c       	lddpc	r12,8000c2a0 <_vfprintf_r+0x1460>
8000c158:	40 93       	lddsp	r3,sp[0x24]
8000c15a:	10 90       	mov	r0,r8
8000c15c:	40 41       	lddsp	r1,sp[0x10]
8000c15e:	50 dc       	stdsp	sp[0x34],r12
8000c160:	ed b5 00 05 	bld	r5,0x5
8000c164:	c5 51       	brne	8000c20e <_vfprintf_r+0x13ce>
8000c166:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c16a:	40 3b       	lddsp	r11,sp[0xc]
8000c16c:	58 0b       	cp.w	r11,0
8000c16e:	c2 20       	breq	8000c1b2 <_vfprintf_r+0x1372>
8000c170:	10 36       	cp.w	r6,r8
8000c172:	c0 a4       	brge	8000c186 <_vfprintf_r+0x1346>
8000c174:	fa ca f9 44 	sub	r10,sp,-1724
8000c178:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c17c:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000c180:	fa e9 00 00 	st.d	sp[0],r8
8000c184:	cf 38       	rjmp	8000c36a <_vfprintf_r+0x152a>
8000c186:	fa c8 f9 50 	sub	r8,sp,-1712
8000c18a:	1a d8       	st.w	--sp,r8
8000c18c:	fa c8 fa b8 	sub	r8,sp,-1352
8000c190:	04 9a       	mov	r10,r2
8000c192:	1a d8       	st.w	--sp,r8
8000c194:	0c 9b       	mov	r11,r6
8000c196:	fa c8 fb b4 	sub	r8,sp,-1100
8000c19a:	08 9c       	mov	r12,r4
8000c19c:	1a d8       	st.w	--sp,r8
8000c19e:	fa c8 f9 40 	sub	r8,sp,-1728
8000c1a2:	fa c9 ff b4 	sub	r9,sp,-76
8000c1a6:	fe b0 f4 af 	rcall	8000ab04 <get_arg>
8000c1aa:	2f dd       	sub	sp,-12
8000c1ac:	f8 ea 00 00 	ld.d	r10,r12[0]
8000c1b0:	c0 c8       	rjmp	8000c1c8 <_vfprintf_r+0x1388>
8000c1b2:	ee ca ff ff 	sub	r10,r7,-1
8000c1b6:	10 37       	cp.w	r7,r8
8000c1b8:	c0 b4       	brge	8000c1ce <_vfprintf_r+0x138e>
8000c1ba:	fa c9 f9 44 	sub	r9,sp,-1724
8000c1be:	14 97       	mov	r7,r10
8000c1c0:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c1c4:	ec ea fd 88 	ld.d	r10,r6[-632]
8000c1c8:	fa eb 00 00 	st.d	sp[0],r10
8000c1cc:	cc f8       	rjmp	8000c36a <_vfprintf_r+0x152a>
8000c1ce:	41 09       	lddsp	r9,sp[0x40]
8000c1d0:	59 f8       	cp.w	r8,31
8000c1d2:	e0 89 00 16 	brgt	8000c1fe <_vfprintf_r+0x13be>
8000c1d6:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c1da:	f2 cb ff f8 	sub	r11,r9,-8
8000c1de:	fa e7 00 00 	st.d	sp[0],r6
8000c1e2:	51 0b       	stdsp	sp[0x40],r11
8000c1e4:	fa c6 f9 44 	sub	r6,sp,-1724
8000c1e8:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c1ec:	fa e6 00 00 	ld.d	r6,sp[0]
8000c1f0:	f2 e7 fd 88 	st.d	r9[-632],r6
8000c1f4:	2f f8       	sub	r8,-1
8000c1f6:	14 97       	mov	r7,r10
8000c1f8:	fb 48 06 b4 	st.w	sp[1716],r8
8000c1fc:	cb 78       	rjmp	8000c36a <_vfprintf_r+0x152a>
8000c1fe:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c202:	2f 89       	sub	r9,-8
8000c204:	fa e7 00 00 	st.d	sp[0],r6
8000c208:	51 09       	stdsp	sp[0x40],r9
8000c20a:	14 97       	mov	r7,r10
8000c20c:	ca f8       	rjmp	8000c36a <_vfprintf_r+0x152a>
8000c20e:	ed b5 00 04 	bld	r5,0x4
8000c212:	c1 71       	brne	8000c240 <_vfprintf_r+0x1400>
8000c214:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c218:	40 3e       	lddsp	lr,sp[0xc]
8000c21a:	58 0e       	cp.w	lr,0
8000c21c:	c0 80       	breq	8000c22c <_vfprintf_r+0x13ec>
8000c21e:	10 36       	cp.w	r6,r8
8000c220:	c6 a4       	brge	8000c2f4 <_vfprintf_r+0x14b4>
8000c222:	fa cc f9 44 	sub	r12,sp,-1724
8000c226:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c22a:	c8 38       	rjmp	8000c330 <_vfprintf_r+0x14f0>
8000c22c:	ee ca ff ff 	sub	r10,r7,-1
8000c230:	10 37       	cp.w	r7,r8
8000c232:	e0 84 00 82 	brge	8000c336 <_vfprintf_r+0x14f6>
8000c236:	fa cb f9 44 	sub	r11,sp,-1724
8000c23a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c23e:	c7 88       	rjmp	8000c32e <_vfprintf_r+0x14ee>
8000c240:	ed b5 00 06 	bld	r5,0x6
8000c244:	c4 c1       	brne	8000c2dc <_vfprintf_r+0x149c>
8000c246:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c24a:	40 3c       	lddsp	r12,sp[0xc]
8000c24c:	58 0c       	cp.w	r12,0
8000c24e:	c1 d0       	breq	8000c288 <_vfprintf_r+0x1448>
8000c250:	10 36       	cp.w	r6,r8
8000c252:	c0 64       	brge	8000c25e <_vfprintf_r+0x141e>
8000c254:	fa cb f9 44 	sub	r11,sp,-1724
8000c258:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c25c:	c1 f8       	rjmp	8000c29a <_vfprintf_r+0x145a>
8000c25e:	fa c8 f9 50 	sub	r8,sp,-1712
8000c262:	1a d8       	st.w	--sp,r8
8000c264:	fa c8 fa b8 	sub	r8,sp,-1352
8000c268:	1a d8       	st.w	--sp,r8
8000c26a:	fa c8 fb b4 	sub	r8,sp,-1100
8000c26e:	1a d8       	st.w	--sp,r8
8000c270:	fa c8 f9 40 	sub	r8,sp,-1728
8000c274:	fa c9 ff b4 	sub	r9,sp,-76
8000c278:	04 9a       	mov	r10,r2
8000c27a:	0c 9b       	mov	r11,r6
8000c27c:	08 9c       	mov	r12,r4
8000c27e:	fe b0 f4 43 	rcall	8000ab04 <get_arg>
8000c282:	2f dd       	sub	sp,-12
8000c284:	98 18       	ld.sh	r8,r12[0x2]
8000c286:	c2 88       	rjmp	8000c2d6 <_vfprintf_r+0x1496>
8000c288:	ee ca ff ff 	sub	r10,r7,-1
8000c28c:	10 37       	cp.w	r7,r8
8000c28e:	c0 b4       	brge	8000c2a4 <_vfprintf_r+0x1464>
8000c290:	fa c9 f9 44 	sub	r9,sp,-1724
8000c294:	14 97       	mov	r7,r10
8000c296:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c29a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c29e:	c1 c8       	rjmp	8000c2d6 <_vfprintf_r+0x1496>
8000c2a0:	80 01       	ld.sh	r1,r0[0x0]
8000c2a2:	91 88       	st.w	r8[0x20],r8
8000c2a4:	41 09       	lddsp	r9,sp[0x40]
8000c2a6:	59 f8       	cp.w	r8,31
8000c2a8:	e0 89 00 13 	brgt	8000c2ce <_vfprintf_r+0x148e>
8000c2ac:	f2 cb ff fc 	sub	r11,r9,-4
8000c2b0:	51 0b       	stdsp	sp[0x40],r11
8000c2b2:	72 09       	ld.w	r9,r9[0x0]
8000c2b4:	fa c6 f9 44 	sub	r6,sp,-1724
8000c2b8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c2bc:	2f f8       	sub	r8,-1
8000c2be:	f7 49 fd 88 	st.w	r11[-632],r9
8000c2c2:	fb 48 06 b4 	st.w	sp[1716],r8
8000c2c6:	14 97       	mov	r7,r10
8000c2c8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c2cc:	c0 58       	rjmp	8000c2d6 <_vfprintf_r+0x1496>
8000c2ce:	92 18       	ld.sh	r8,r9[0x2]
8000c2d0:	14 97       	mov	r7,r10
8000c2d2:	2f c9       	sub	r9,-4
8000c2d4:	51 09       	stdsp	sp[0x40],r9
8000c2d6:	5c 78       	castu.h	r8
8000c2d8:	50 18       	stdsp	sp[0x4],r8
8000c2da:	c4 68       	rjmp	8000c366 <_vfprintf_r+0x1526>
8000c2dc:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c2e0:	40 3c       	lddsp	r12,sp[0xc]
8000c2e2:	58 0c       	cp.w	r12,0
8000c2e4:	c1 d0       	breq	8000c31e <_vfprintf_r+0x14de>
8000c2e6:	10 36       	cp.w	r6,r8
8000c2e8:	c0 64       	brge	8000c2f4 <_vfprintf_r+0x14b4>
8000c2ea:	fa cb f9 44 	sub	r11,sp,-1724
8000c2ee:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c2f2:	c1 f8       	rjmp	8000c330 <_vfprintf_r+0x14f0>
8000c2f4:	fa c8 f9 50 	sub	r8,sp,-1712
8000c2f8:	1a d8       	st.w	--sp,r8
8000c2fa:	fa c8 fa b8 	sub	r8,sp,-1352
8000c2fe:	0c 9b       	mov	r11,r6
8000c300:	1a d8       	st.w	--sp,r8
8000c302:	fa c8 fb b4 	sub	r8,sp,-1100
8000c306:	04 9a       	mov	r10,r2
8000c308:	1a d8       	st.w	--sp,r8
8000c30a:	08 9c       	mov	r12,r4
8000c30c:	fa c8 f9 40 	sub	r8,sp,-1728
8000c310:	fa c9 ff b4 	sub	r9,sp,-76
8000c314:	fe b0 f3 f8 	rcall	8000ab04 <get_arg>
8000c318:	2f dd       	sub	sp,-12
8000c31a:	78 0b       	ld.w	r11,r12[0x0]
8000c31c:	c2 48       	rjmp	8000c364 <_vfprintf_r+0x1524>
8000c31e:	ee ca ff ff 	sub	r10,r7,-1
8000c322:	10 37       	cp.w	r7,r8
8000c324:	c0 94       	brge	8000c336 <_vfprintf_r+0x14f6>
8000c326:	fa c9 f9 44 	sub	r9,sp,-1724
8000c32a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c32e:	14 97       	mov	r7,r10
8000c330:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c334:	c1 88       	rjmp	8000c364 <_vfprintf_r+0x1524>
8000c336:	41 09       	lddsp	r9,sp[0x40]
8000c338:	59 f8       	cp.w	r8,31
8000c33a:	e0 89 00 11 	brgt	8000c35c <_vfprintf_r+0x151c>
8000c33e:	f2 cb ff fc 	sub	r11,r9,-4
8000c342:	51 0b       	stdsp	sp[0x40],r11
8000c344:	fa c6 f9 44 	sub	r6,sp,-1724
8000c348:	72 0b       	ld.w	r11,r9[0x0]
8000c34a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c34e:	f3 4b fd 88 	st.w	r9[-632],r11
8000c352:	2f f8       	sub	r8,-1
8000c354:	14 97       	mov	r7,r10
8000c356:	fb 48 06 b4 	st.w	sp[1716],r8
8000c35a:	c0 58       	rjmp	8000c364 <_vfprintf_r+0x1524>
8000c35c:	72 0b       	ld.w	r11,r9[0x0]
8000c35e:	14 97       	mov	r7,r10
8000c360:	2f c9       	sub	r9,-4
8000c362:	51 09       	stdsp	sp[0x40],r9
8000c364:	50 1b       	stdsp	sp[0x4],r11
8000c366:	30 0e       	mov	lr,0
8000c368:	50 0e       	stdsp	sp[0x0],lr
8000c36a:	40 08       	lddsp	r8,sp[0x0]
8000c36c:	40 1c       	lddsp	r12,sp[0x4]
8000c36e:	18 48       	or	r8,r12
8000c370:	5f 19       	srne	r9
8000c372:	0a 98       	mov	r8,r5
8000c374:	eb e9 00 09 	and	r9,r5,r9
8000c378:	a1 b8       	sbr	r8,0x1
8000c37a:	58 09       	cp.w	r9,0
8000c37c:	c0 70       	breq	8000c38a <_vfprintf_r+0x154a>
8000c37e:	10 95       	mov	r5,r8
8000c380:	fb 60 06 b9 	st.b	sp[1721],r0
8000c384:	33 08       	mov	r8,48
8000c386:	fb 68 06 b8 	st.b	sp[1720],r8
8000c38a:	30 28       	mov	r8,2
8000c38c:	30 09       	mov	r9,0
8000c38e:	fb 69 06 bb 	st.b	sp[1723],r9
8000c392:	0a 99       	mov	r9,r5
8000c394:	a7 d9       	cbr	r9,0x7
8000c396:	40 2b       	lddsp	r11,sp[0x8]
8000c398:	40 16       	lddsp	r6,sp[0x4]
8000c39a:	58 0b       	cp.w	r11,0
8000c39c:	5f 1a       	srne	r10
8000c39e:	f2 05 17 40 	movge	r5,r9
8000c3a2:	fa c2 f9 78 	sub	r2,sp,-1672
8000c3a6:	40 09       	lddsp	r9,sp[0x0]
8000c3a8:	0c 49       	or	r9,r6
8000c3aa:	5f 19       	srne	r9
8000c3ac:	f5 e9 10 09 	or	r9,r10,r9
8000c3b0:	c5 c0       	breq	8000c468 <_vfprintf_r+0x1628>
8000c3b2:	30 19       	mov	r9,1
8000c3b4:	f2 08 18 00 	cp.b	r8,r9
8000c3b8:	c0 60       	breq	8000c3c4 <_vfprintf_r+0x1584>
8000c3ba:	30 29       	mov	r9,2
8000c3bc:	f2 08 18 00 	cp.b	r8,r9
8000c3c0:	c0 41       	brne	8000c3c8 <_vfprintf_r+0x1588>
8000c3c2:	c3 c8       	rjmp	8000c43a <_vfprintf_r+0x15fa>
8000c3c4:	04 96       	mov	r6,r2
8000c3c6:	c3 08       	rjmp	8000c426 <_vfprintf_r+0x15e6>
8000c3c8:	04 96       	mov	r6,r2
8000c3ca:	fa e8 00 00 	ld.d	r8,sp[0]
8000c3ce:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000c3d2:	2d 0a       	sub	r10,-48
8000c3d4:	0c fa       	st.b	--r6,r10
8000c3d6:	f0 0b 16 03 	lsr	r11,r8,0x3
8000c3da:	f2 0c 16 03 	lsr	r12,r9,0x3
8000c3de:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000c3e2:	18 99       	mov	r9,r12
8000c3e4:	16 98       	mov	r8,r11
8000c3e6:	58 08       	cp.w	r8,0
8000c3e8:	5c 29       	cpc	r9
8000c3ea:	cf 21       	brne	8000c3ce <_vfprintf_r+0x158e>
8000c3ec:	fa e9 00 00 	st.d	sp[0],r8
8000c3f0:	ed b5 00 00 	bld	r5,0x0
8000c3f4:	c4 51       	brne	8000c47e <_vfprintf_r+0x163e>
8000c3f6:	33 09       	mov	r9,48
8000c3f8:	f2 0a 18 00 	cp.b	r10,r9
8000c3fc:	c4 10       	breq	8000c47e <_vfprintf_r+0x163e>
8000c3fe:	0c f9       	st.b	--r6,r9
8000c400:	c3 f8       	rjmp	8000c47e <_vfprintf_r+0x163e>
8000c402:	fa ea 00 00 	ld.d	r10,sp[0]
8000c406:	30 a8       	mov	r8,10
8000c408:	30 09       	mov	r9,0
8000c40a:	e0 a0 1a 1b 	rcall	8000f840 <__avr32_umod64>
8000c40e:	30 a8       	mov	r8,10
8000c410:	2d 0a       	sub	r10,-48
8000c412:	30 09       	mov	r9,0
8000c414:	ac 8a       	st.b	r6[0x0],r10
8000c416:	fa ea 00 00 	ld.d	r10,sp[0]
8000c41a:	e0 a0 18 e1 	rcall	8000f5dc <__avr32_udiv64>
8000c41e:	16 99       	mov	r9,r11
8000c420:	14 98       	mov	r8,r10
8000c422:	fa e9 00 00 	st.d	sp[0],r8
8000c426:	20 16       	sub	r6,1
8000c428:	fa ea 00 00 	ld.d	r10,sp[0]
8000c42c:	58 9a       	cp.w	r10,9
8000c42e:	5c 2b       	cpc	r11
8000c430:	fe 9b ff e9 	brhi	8000c402 <_vfprintf_r+0x15c2>
8000c434:	1b f8       	ld.ub	r8,sp[0x7]
8000c436:	2d 08       	sub	r8,-48
8000c438:	c2 08       	rjmp	8000c478 <_vfprintf_r+0x1638>
8000c43a:	04 96       	mov	r6,r2
8000c43c:	fa e8 00 00 	ld.d	r8,sp[0]
8000c440:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000c444:	40 de       	lddsp	lr,sp[0x34]
8000c446:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000c44a:	0c fa       	st.b	--r6,r10
8000c44c:	f2 0b 16 04 	lsr	r11,r9,0x4
8000c450:	f0 0a 16 04 	lsr	r10,r8,0x4
8000c454:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000c458:	16 99       	mov	r9,r11
8000c45a:	14 98       	mov	r8,r10
8000c45c:	58 08       	cp.w	r8,0
8000c45e:	5c 29       	cpc	r9
8000c460:	cf 01       	brne	8000c440 <_vfprintf_r+0x1600>
8000c462:	fa e9 00 00 	st.d	sp[0],r8
8000c466:	c0 c8       	rjmp	8000c47e <_vfprintf_r+0x163e>
8000c468:	58 08       	cp.w	r8,0
8000c46a:	c0 91       	brne	8000c47c <_vfprintf_r+0x163c>
8000c46c:	ed b5 00 00 	bld	r5,0x0
8000c470:	c0 61       	brne	8000c47c <_vfprintf_r+0x163c>
8000c472:	fa c6 f9 79 	sub	r6,sp,-1671
8000c476:	33 08       	mov	r8,48
8000c478:	ac 88       	st.b	r6[0x0],r8
8000c47a:	c0 28       	rjmp	8000c47e <_vfprintf_r+0x163e>
8000c47c:	04 96       	mov	r6,r2
8000c47e:	0c 12       	sub	r2,r6
8000c480:	c1 c8       	rjmp	8000c4b8 <_vfprintf_r+0x1678>
8000c482:	50 a7       	stdsp	sp[0x28],r7
8000c484:	50 80       	stdsp	sp[0x20],r0
8000c486:	40 93       	lddsp	r3,sp[0x24]
8000c488:	0c 97       	mov	r7,r6
8000c48a:	10 90       	mov	r0,r8
8000c48c:	04 94       	mov	r4,r2
8000c48e:	40 41       	lddsp	r1,sp[0x10]
8000c490:	58 08       	cp.w	r8,0
8000c492:	e0 80 04 51 	breq	8000cd34 <_vfprintf_r+0x1ef4>
8000c496:	fb 68 06 60 	st.b	sp[1632],r8
8000c49a:	30 0c       	mov	r12,0
8000c49c:	30 08       	mov	r8,0
8000c49e:	30 12       	mov	r2,1
8000c4a0:	fb 68 06 bb 	st.b	sp[1723],r8
8000c4a4:	50 2c       	stdsp	sp[0x8],r12
8000c4a6:	fa c6 f9 a0 	sub	r6,sp,-1632
8000c4aa:	c0 78       	rjmp	8000c4b8 <_vfprintf_r+0x1678>
8000c4ac:	30 0b       	mov	r11,0
8000c4ae:	50 2b       	stdsp	sp[0x8],r11
8000c4b0:	c0 48       	rjmp	8000c4b8 <_vfprintf_r+0x1678>
8000c4b2:	40 22       	lddsp	r2,sp[0x8]
8000c4b4:	30 0a       	mov	r10,0
8000c4b6:	50 2a       	stdsp	sp[0x8],r10
8000c4b8:	40 29       	lddsp	r9,sp[0x8]
8000c4ba:	e4 09 0c 49 	max	r9,r2,r9
8000c4be:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000c4c2:	50 39       	stdsp	sp[0xc],r9
8000c4c4:	0a 9e       	mov	lr,r5
8000c4c6:	30 09       	mov	r9,0
8000c4c8:	e2 1e 00 02 	andl	lr,0x2,COH
8000c4cc:	f2 08 18 00 	cp.b	r8,r9
8000c4d0:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000c4d4:	f7 b8 01 ff 	subne	r8,-1
8000c4d8:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000c4dc:	0a 9b       	mov	r11,r5
8000c4de:	58 0e       	cp.w	lr,0
8000c4e0:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000c4e4:	f7 bc 01 fe 	subne	r12,-2
8000c4e8:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000c4ec:	e2 1b 00 84 	andl	r11,0x84,COH
8000c4f0:	50 fe       	stdsp	sp[0x3c],lr
8000c4f2:	50 9b       	stdsp	sp[0x24],r11
8000c4f4:	c4 51       	brne	8000c57e <_vfprintf_r+0x173e>
8000c4f6:	40 8a       	lddsp	r10,sp[0x20]
8000c4f8:	40 39       	lddsp	r9,sp[0xc]
8000c4fa:	12 1a       	sub	r10,r9
8000c4fc:	50 4a       	stdsp	sp[0x10],r10
8000c4fe:	58 0a       	cp.w	r10,0
8000c500:	e0 89 00 1f 	brgt	8000c53e <_vfprintf_r+0x16fe>
8000c504:	c3 d8       	rjmp	8000c57e <_vfprintf_r+0x173e>
8000c506:	2f 09       	sub	r9,-16
8000c508:	2f f8       	sub	r8,-1
8000c50a:	4c ee       	lddpc	lr,8000c640 <_vfprintf_r+0x1800>
8000c50c:	31 0c       	mov	r12,16
8000c50e:	fb 49 06 90 	st.w	sp[1680],r9
8000c512:	87 0e       	st.w	r3[0x0],lr
8000c514:	87 1c       	st.w	r3[0x4],r12
8000c516:	fb 48 06 8c 	st.w	sp[1676],r8
8000c51a:	58 78       	cp.w	r8,7
8000c51c:	e0 89 00 04 	brgt	8000c524 <_vfprintf_r+0x16e4>
8000c520:	2f 83       	sub	r3,-8
8000c522:	c0 b8       	rjmp	8000c538 <_vfprintf_r+0x16f8>
8000c524:	fa ca f9 78 	sub	r10,sp,-1672
8000c528:	02 9b       	mov	r11,r1
8000c52a:	08 9c       	mov	r12,r4
8000c52c:	fe b0 f4 7c 	rcall	8000ae24 <__sprint_r>
8000c530:	e0 81 04 13 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000c534:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c538:	40 4b       	lddsp	r11,sp[0x10]
8000c53a:	21 0b       	sub	r11,16
8000c53c:	50 4b       	stdsp	sp[0x10],r11
8000c53e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c542:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c546:	4b fa       	lddpc	r10,8000c640 <_vfprintf_r+0x1800>
8000c548:	40 4e       	lddsp	lr,sp[0x10]
8000c54a:	59 0e       	cp.w	lr,16
8000c54c:	fe 99 ff dd 	brgt	8000c506 <_vfprintf_r+0x16c6>
8000c550:	1c 09       	add	r9,lr
8000c552:	2f f8       	sub	r8,-1
8000c554:	87 0a       	st.w	r3[0x0],r10
8000c556:	fb 49 06 90 	st.w	sp[1680],r9
8000c55a:	87 1e       	st.w	r3[0x4],lr
8000c55c:	fb 48 06 8c 	st.w	sp[1676],r8
8000c560:	58 78       	cp.w	r8,7
8000c562:	e0 89 00 04 	brgt	8000c56a <_vfprintf_r+0x172a>
8000c566:	2f 83       	sub	r3,-8
8000c568:	c0 b8       	rjmp	8000c57e <_vfprintf_r+0x173e>
8000c56a:	fa ca f9 78 	sub	r10,sp,-1672
8000c56e:	02 9b       	mov	r11,r1
8000c570:	08 9c       	mov	r12,r4
8000c572:	fe b0 f4 59 	rcall	8000ae24 <__sprint_r>
8000c576:	e0 81 03 f0 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000c57a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c57e:	30 09       	mov	r9,0
8000c580:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000c584:	f2 08 18 00 	cp.b	r8,r9
8000c588:	c1 f0       	breq	8000c5c6 <_vfprintf_r+0x1786>
8000c58a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c58e:	fa c9 f9 45 	sub	r9,sp,-1723
8000c592:	2f f8       	sub	r8,-1
8000c594:	87 09       	st.w	r3[0x0],r9
8000c596:	fb 48 06 90 	st.w	sp[1680],r8
8000c59a:	30 19       	mov	r9,1
8000c59c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c5a0:	87 19       	st.w	r3[0x4],r9
8000c5a2:	2f f8       	sub	r8,-1
8000c5a4:	fb 48 06 8c 	st.w	sp[1676],r8
8000c5a8:	58 78       	cp.w	r8,7
8000c5aa:	e0 89 00 04 	brgt	8000c5b2 <_vfprintf_r+0x1772>
8000c5ae:	2f 83       	sub	r3,-8
8000c5b0:	c0 b8       	rjmp	8000c5c6 <_vfprintf_r+0x1786>
8000c5b2:	fa ca f9 78 	sub	r10,sp,-1672
8000c5b6:	02 9b       	mov	r11,r1
8000c5b8:	08 9c       	mov	r12,r4
8000c5ba:	fe b0 f4 35 	rcall	8000ae24 <__sprint_r>
8000c5be:	e0 81 03 cc 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000c5c2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c5c6:	40 fc       	lddsp	r12,sp[0x3c]
8000c5c8:	58 0c       	cp.w	r12,0
8000c5ca:	c1 f0       	breq	8000c608 <_vfprintf_r+0x17c8>
8000c5cc:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c5d0:	fa c9 f9 48 	sub	r9,sp,-1720
8000c5d4:	2f e8       	sub	r8,-2
8000c5d6:	87 09       	st.w	r3[0x0],r9
8000c5d8:	fb 48 06 90 	st.w	sp[1680],r8
8000c5dc:	30 29       	mov	r9,2
8000c5de:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c5e2:	87 19       	st.w	r3[0x4],r9
8000c5e4:	2f f8       	sub	r8,-1
8000c5e6:	fb 48 06 8c 	st.w	sp[1676],r8
8000c5ea:	58 78       	cp.w	r8,7
8000c5ec:	e0 89 00 04 	brgt	8000c5f4 <_vfprintf_r+0x17b4>
8000c5f0:	2f 83       	sub	r3,-8
8000c5f2:	c0 b8       	rjmp	8000c608 <_vfprintf_r+0x17c8>
8000c5f4:	fa ca f9 78 	sub	r10,sp,-1672
8000c5f8:	02 9b       	mov	r11,r1
8000c5fa:	08 9c       	mov	r12,r4
8000c5fc:	fe b0 f4 14 	rcall	8000ae24 <__sprint_r>
8000c600:	e0 81 03 ab 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000c604:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c608:	40 9b       	lddsp	r11,sp[0x24]
8000c60a:	e0 4b 00 80 	cp.w	r11,128
8000c60e:	c4 a1       	brne	8000c6a2 <_vfprintf_r+0x1862>
8000c610:	40 8a       	lddsp	r10,sp[0x20]
8000c612:	40 39       	lddsp	r9,sp[0xc]
8000c614:	12 1a       	sub	r10,r9
8000c616:	50 4a       	stdsp	sp[0x10],r10
8000c618:	58 0a       	cp.w	r10,0
8000c61a:	e0 89 00 24 	brgt	8000c662 <_vfprintf_r+0x1822>
8000c61e:	c4 28       	rjmp	8000c6a2 <_vfprintf_r+0x1862>
8000c620:	2f 09       	sub	r9,-16
8000c622:	2f f8       	sub	r8,-1
8000c624:	48 8e       	lddpc	lr,8000c644 <_vfprintf_r+0x1804>
8000c626:	31 0c       	mov	r12,16
8000c628:	fb 49 06 90 	st.w	sp[1680],r9
8000c62c:	87 0e       	st.w	r3[0x0],lr
8000c62e:	87 1c       	st.w	r3[0x4],r12
8000c630:	fb 48 06 8c 	st.w	sp[1676],r8
8000c634:	58 78       	cp.w	r8,7
8000c636:	e0 89 00 09 	brgt	8000c648 <_vfprintf_r+0x1808>
8000c63a:	2f 83       	sub	r3,-8
8000c63c:	c1 08       	rjmp	8000c65c <_vfprintf_r+0x181c>
8000c63e:	d7 03       	nop
8000c640:	80 01       	ld.sh	r1,r0[0x0]
8000c642:	91 a0       	st.w	r8[0x28],r0
8000c644:	80 01       	ld.sh	r1,r0[0x0]
8000c646:	91 b0       	st.w	r8[0x2c],r0
8000c648:	fa ca f9 78 	sub	r10,sp,-1672
8000c64c:	02 9b       	mov	r11,r1
8000c64e:	08 9c       	mov	r12,r4
8000c650:	fe b0 f3 ea 	rcall	8000ae24 <__sprint_r>
8000c654:	e0 81 03 81 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000c658:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c65c:	40 4b       	lddsp	r11,sp[0x10]
8000c65e:	21 0b       	sub	r11,16
8000c660:	50 4b       	stdsp	sp[0x10],r11
8000c662:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c666:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c66a:	4c 6a       	lddpc	r10,8000c780 <_vfprintf_r+0x1940>
8000c66c:	40 4e       	lddsp	lr,sp[0x10]
8000c66e:	59 0e       	cp.w	lr,16
8000c670:	fe 99 ff d8 	brgt	8000c620 <_vfprintf_r+0x17e0>
8000c674:	1c 09       	add	r9,lr
8000c676:	2f f8       	sub	r8,-1
8000c678:	87 0a       	st.w	r3[0x0],r10
8000c67a:	fb 49 06 90 	st.w	sp[1680],r9
8000c67e:	87 1e       	st.w	r3[0x4],lr
8000c680:	fb 48 06 8c 	st.w	sp[1676],r8
8000c684:	58 78       	cp.w	r8,7
8000c686:	e0 89 00 04 	brgt	8000c68e <_vfprintf_r+0x184e>
8000c68a:	2f 83       	sub	r3,-8
8000c68c:	c0 b8       	rjmp	8000c6a2 <_vfprintf_r+0x1862>
8000c68e:	fa ca f9 78 	sub	r10,sp,-1672
8000c692:	02 9b       	mov	r11,r1
8000c694:	08 9c       	mov	r12,r4
8000c696:	fe b0 f3 c7 	rcall	8000ae24 <__sprint_r>
8000c69a:	e0 81 03 5e 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000c69e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c6a2:	40 2c       	lddsp	r12,sp[0x8]
8000c6a4:	04 1c       	sub	r12,r2
8000c6a6:	50 2c       	stdsp	sp[0x8],r12
8000c6a8:	58 0c       	cp.w	r12,0
8000c6aa:	e0 89 00 1f 	brgt	8000c6e8 <_vfprintf_r+0x18a8>
8000c6ae:	c3 d8       	rjmp	8000c728 <_vfprintf_r+0x18e8>
8000c6b0:	2f 09       	sub	r9,-16
8000c6b2:	2f f8       	sub	r8,-1
8000c6b4:	4b 3b       	lddpc	r11,8000c780 <_vfprintf_r+0x1940>
8000c6b6:	31 0a       	mov	r10,16
8000c6b8:	fb 49 06 90 	st.w	sp[1680],r9
8000c6bc:	87 0b       	st.w	r3[0x0],r11
8000c6be:	87 1a       	st.w	r3[0x4],r10
8000c6c0:	fb 48 06 8c 	st.w	sp[1676],r8
8000c6c4:	58 78       	cp.w	r8,7
8000c6c6:	e0 89 00 04 	brgt	8000c6ce <_vfprintf_r+0x188e>
8000c6ca:	2f 83       	sub	r3,-8
8000c6cc:	c0 b8       	rjmp	8000c6e2 <_vfprintf_r+0x18a2>
8000c6ce:	fa ca f9 78 	sub	r10,sp,-1672
8000c6d2:	02 9b       	mov	r11,r1
8000c6d4:	08 9c       	mov	r12,r4
8000c6d6:	fe b0 f3 a7 	rcall	8000ae24 <__sprint_r>
8000c6da:	e0 81 03 3e 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000c6de:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c6e2:	40 29       	lddsp	r9,sp[0x8]
8000c6e4:	21 09       	sub	r9,16
8000c6e6:	50 29       	stdsp	sp[0x8],r9
8000c6e8:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c6ec:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c6f0:	4a 4a       	lddpc	r10,8000c780 <_vfprintf_r+0x1940>
8000c6f2:	40 2e       	lddsp	lr,sp[0x8]
8000c6f4:	59 0e       	cp.w	lr,16
8000c6f6:	fe 99 ff dd 	brgt	8000c6b0 <_vfprintf_r+0x1870>
8000c6fa:	1c 09       	add	r9,lr
8000c6fc:	2f f8       	sub	r8,-1
8000c6fe:	87 0a       	st.w	r3[0x0],r10
8000c700:	fb 49 06 90 	st.w	sp[1680],r9
8000c704:	87 1e       	st.w	r3[0x4],lr
8000c706:	fb 48 06 8c 	st.w	sp[1676],r8
8000c70a:	58 78       	cp.w	r8,7
8000c70c:	e0 89 00 04 	brgt	8000c714 <_vfprintf_r+0x18d4>
8000c710:	2f 83       	sub	r3,-8
8000c712:	c0 b8       	rjmp	8000c728 <_vfprintf_r+0x18e8>
8000c714:	fa ca f9 78 	sub	r10,sp,-1672
8000c718:	02 9b       	mov	r11,r1
8000c71a:	08 9c       	mov	r12,r4
8000c71c:	fe b0 f3 84 	rcall	8000ae24 <__sprint_r>
8000c720:	e0 81 03 1b 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000c724:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c728:	ed b5 00 08 	bld	r5,0x8
8000c72c:	c0 b0       	breq	8000c742 <_vfprintf_r+0x1902>
8000c72e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c732:	87 12       	st.w	r3[0x4],r2
8000c734:	87 06       	st.w	r3[0x0],r6
8000c736:	f0 02 00 02 	add	r2,r8,r2
8000c73a:	fb 42 06 90 	st.w	sp[1680],r2
8000c73e:	e0 8f 01 d5 	bral	8000cae8 <_vfprintf_r+0x1ca8>
8000c742:	e0 40 00 65 	cp.w	r0,101
8000c746:	e0 8a 01 d7 	brle	8000caf4 <_vfprintf_r+0x1cb4>
8000c74a:	30 08       	mov	r8,0
8000c74c:	30 09       	mov	r9,0
8000c74e:	40 5b       	lddsp	r11,sp[0x14]
8000c750:	40 7a       	lddsp	r10,sp[0x1c]
8000c752:	e0 a0 15 3e 	rcall	8000f1ce <__avr32_f64_cmp_eq>
8000c756:	c7 a0       	breq	8000c84a <_vfprintf_r+0x1a0a>
8000c758:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c75c:	48 a9       	lddpc	r9,8000c784 <_vfprintf_r+0x1944>
8000c75e:	2f f8       	sub	r8,-1
8000c760:	87 09       	st.w	r3[0x0],r9
8000c762:	fb 48 06 90 	st.w	sp[1680],r8
8000c766:	30 19       	mov	r9,1
8000c768:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c76c:	87 19       	st.w	r3[0x4],r9
8000c76e:	2f f8       	sub	r8,-1
8000c770:	fb 48 06 8c 	st.w	sp[1676],r8
8000c774:	58 78       	cp.w	r8,7
8000c776:	e0 89 00 09 	brgt	8000c788 <_vfprintf_r+0x1948>
8000c77a:	2f 83       	sub	r3,-8
8000c77c:	c1 08       	rjmp	8000c79c <_vfprintf_r+0x195c>
8000c77e:	d7 03       	nop
8000c780:	80 01       	ld.sh	r1,r0[0x0]
8000c782:	91 b0       	st.w	r8[0x2c],r0
8000c784:	80 01       	ld.sh	r1,r0[0x0]
8000c786:	91 9c       	st.w	r8[0x24],r12
8000c788:	fa ca f9 78 	sub	r10,sp,-1672
8000c78c:	02 9b       	mov	r11,r1
8000c78e:	08 9c       	mov	r12,r4
8000c790:	fe b0 f3 4a 	rcall	8000ae24 <__sprint_r>
8000c794:	e0 81 02 e1 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000c798:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c79c:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000c7a0:	40 6c       	lddsp	r12,sp[0x18]
8000c7a2:	18 38       	cp.w	r8,r12
8000c7a4:	c0 55       	brlt	8000c7ae <_vfprintf_r+0x196e>
8000c7a6:	ed b5 00 00 	bld	r5,0x0
8000c7aa:	e0 81 02 69 	brne	8000cc7c <_vfprintf_r+0x1e3c>
8000c7ae:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c7b2:	2f f8       	sub	r8,-1
8000c7b4:	40 cb       	lddsp	r11,sp[0x30]
8000c7b6:	fb 48 06 90 	st.w	sp[1680],r8
8000c7ba:	30 19       	mov	r9,1
8000c7bc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c7c0:	87 0b       	st.w	r3[0x0],r11
8000c7c2:	2f f8       	sub	r8,-1
8000c7c4:	87 19       	st.w	r3[0x4],r9
8000c7c6:	fb 48 06 8c 	st.w	sp[1676],r8
8000c7ca:	58 78       	cp.w	r8,7
8000c7cc:	e0 89 00 04 	brgt	8000c7d4 <_vfprintf_r+0x1994>
8000c7d0:	2f 83       	sub	r3,-8
8000c7d2:	c0 b8       	rjmp	8000c7e8 <_vfprintf_r+0x19a8>
8000c7d4:	fa ca f9 78 	sub	r10,sp,-1672
8000c7d8:	02 9b       	mov	r11,r1
8000c7da:	08 9c       	mov	r12,r4
8000c7dc:	fe b0 f3 24 	rcall	8000ae24 <__sprint_r>
8000c7e0:	e0 81 02 bb 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000c7e4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c7e8:	40 66       	lddsp	r6,sp[0x18]
8000c7ea:	20 16       	sub	r6,1
8000c7ec:	58 06       	cp.w	r6,0
8000c7ee:	e0 89 00 1d 	brgt	8000c828 <_vfprintf_r+0x19e8>
8000c7f2:	e0 8f 02 45 	bral	8000cc7c <_vfprintf_r+0x1e3c>
8000c7f6:	2f 09       	sub	r9,-16
8000c7f8:	2f f8       	sub	r8,-1
8000c7fa:	fb 49 06 90 	st.w	sp[1680],r9
8000c7fe:	87 02       	st.w	r3[0x0],r2
8000c800:	87 10       	st.w	r3[0x4],r0
8000c802:	fb 48 06 8c 	st.w	sp[1676],r8
8000c806:	58 78       	cp.w	r8,7
8000c808:	e0 89 00 04 	brgt	8000c810 <_vfprintf_r+0x19d0>
8000c80c:	2f 83       	sub	r3,-8
8000c80e:	c0 b8       	rjmp	8000c824 <_vfprintf_r+0x19e4>
8000c810:	fa ca f9 78 	sub	r10,sp,-1672
8000c814:	02 9b       	mov	r11,r1
8000c816:	08 9c       	mov	r12,r4
8000c818:	fe b0 f3 06 	rcall	8000ae24 <__sprint_r>
8000c81c:	e0 81 02 9d 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000c820:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c824:	21 06       	sub	r6,16
8000c826:	c0 38       	rjmp	8000c82c <_vfprintf_r+0x19ec>
8000c828:	4d 22       	lddpc	r2,8000c970 <_vfprintf_r+0x1b30>
8000c82a:	31 00       	mov	r0,16
8000c82c:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c830:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c834:	4c fa       	lddpc	r10,8000c970 <_vfprintf_r+0x1b30>
8000c836:	59 06       	cp.w	r6,16
8000c838:	fe 99 ff df 	brgt	8000c7f6 <_vfprintf_r+0x19b6>
8000c83c:	0c 09       	add	r9,r6
8000c83e:	87 0a       	st.w	r3[0x0],r10
8000c840:	fb 49 06 90 	st.w	sp[1680],r9
8000c844:	2f f8       	sub	r8,-1
8000c846:	87 16       	st.w	r3[0x4],r6
8000c848:	c5 39       	rjmp	8000caee <_vfprintf_r+0x1cae>
8000c84a:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000c84e:	58 0a       	cp.w	r10,0
8000c850:	e0 89 00 94 	brgt	8000c978 <_vfprintf_r+0x1b38>
8000c854:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c858:	4c 79       	lddpc	r9,8000c974 <_vfprintf_r+0x1b34>
8000c85a:	2f f8       	sub	r8,-1
8000c85c:	87 09       	st.w	r3[0x0],r9
8000c85e:	fb 48 06 90 	st.w	sp[1680],r8
8000c862:	30 19       	mov	r9,1
8000c864:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c868:	87 19       	st.w	r3[0x4],r9
8000c86a:	2f f8       	sub	r8,-1
8000c86c:	fb 48 06 8c 	st.w	sp[1676],r8
8000c870:	58 78       	cp.w	r8,7
8000c872:	e0 89 00 04 	brgt	8000c87a <_vfprintf_r+0x1a3a>
8000c876:	2f 83       	sub	r3,-8
8000c878:	c0 b8       	rjmp	8000c88e <_vfprintf_r+0x1a4e>
8000c87a:	fa ca f9 78 	sub	r10,sp,-1672
8000c87e:	02 9b       	mov	r11,r1
8000c880:	08 9c       	mov	r12,r4
8000c882:	fe b0 f2 d1 	rcall	8000ae24 <__sprint_r>
8000c886:	e0 81 02 68 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000c88a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c88e:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000c892:	58 08       	cp.w	r8,0
8000c894:	c0 81       	brne	8000c8a4 <_vfprintf_r+0x1a64>
8000c896:	40 6a       	lddsp	r10,sp[0x18]
8000c898:	58 0a       	cp.w	r10,0
8000c89a:	c0 51       	brne	8000c8a4 <_vfprintf_r+0x1a64>
8000c89c:	ed b5 00 00 	bld	r5,0x0
8000c8a0:	e0 81 01 ee 	brne	8000cc7c <_vfprintf_r+0x1e3c>
8000c8a4:	40 c9       	lddsp	r9,sp[0x30]
8000c8a6:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c8aa:	2f f8       	sub	r8,-1
8000c8ac:	87 09       	st.w	r3[0x0],r9
8000c8ae:	fb 48 06 90 	st.w	sp[1680],r8
8000c8b2:	30 19       	mov	r9,1
8000c8b4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c8b8:	87 19       	st.w	r3[0x4],r9
8000c8ba:	2f f8       	sub	r8,-1
8000c8bc:	fb 48 06 8c 	st.w	sp[1676],r8
8000c8c0:	58 78       	cp.w	r8,7
8000c8c2:	e0 89 00 04 	brgt	8000c8ca <_vfprintf_r+0x1a8a>
8000c8c6:	2f 83       	sub	r3,-8
8000c8c8:	c0 b8       	rjmp	8000c8de <_vfprintf_r+0x1a9e>
8000c8ca:	fa ca f9 78 	sub	r10,sp,-1672
8000c8ce:	02 9b       	mov	r11,r1
8000c8d0:	08 9c       	mov	r12,r4
8000c8d2:	fe b0 f2 a9 	rcall	8000ae24 <__sprint_r>
8000c8d6:	e0 81 02 40 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000c8da:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c8de:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000c8e2:	5c 32       	neg	r2
8000c8e4:	58 02       	cp.w	r2,0
8000c8e6:	e0 89 00 1d 	brgt	8000c920 <_vfprintf_r+0x1ae0>
8000c8ea:	c3 b8       	rjmp	8000c960 <_vfprintf_r+0x1b20>
8000c8ec:	2f 09       	sub	r9,-16
8000c8ee:	2f f8       	sub	r8,-1
8000c8f0:	31 0e       	mov	lr,16
8000c8f2:	fb 49 06 90 	st.w	sp[1680],r9
8000c8f6:	87 00       	st.w	r3[0x0],r0
8000c8f8:	87 1e       	st.w	r3[0x4],lr
8000c8fa:	fb 48 06 8c 	st.w	sp[1676],r8
8000c8fe:	58 78       	cp.w	r8,7
8000c900:	e0 89 00 04 	brgt	8000c908 <_vfprintf_r+0x1ac8>
8000c904:	2f 83       	sub	r3,-8
8000c906:	c0 b8       	rjmp	8000c91c <_vfprintf_r+0x1adc>
8000c908:	fa ca f9 78 	sub	r10,sp,-1672
8000c90c:	02 9b       	mov	r11,r1
8000c90e:	08 9c       	mov	r12,r4
8000c910:	fe b0 f2 8a 	rcall	8000ae24 <__sprint_r>
8000c914:	e0 81 02 21 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000c918:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c91c:	21 02       	sub	r2,16
8000c91e:	c0 28       	rjmp	8000c922 <_vfprintf_r+0x1ae2>
8000c920:	49 40       	lddpc	r0,8000c970 <_vfprintf_r+0x1b30>
8000c922:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c926:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c92a:	49 2a       	lddpc	r10,8000c970 <_vfprintf_r+0x1b30>
8000c92c:	59 02       	cp.w	r2,16
8000c92e:	fe 99 ff df 	brgt	8000c8ec <_vfprintf_r+0x1aac>
8000c932:	04 09       	add	r9,r2
8000c934:	2f f8       	sub	r8,-1
8000c936:	87 0a       	st.w	r3[0x0],r10
8000c938:	fb 49 06 90 	st.w	sp[1680],r9
8000c93c:	87 12       	st.w	r3[0x4],r2
8000c93e:	fb 48 06 8c 	st.w	sp[1676],r8
8000c942:	58 78       	cp.w	r8,7
8000c944:	e0 89 00 04 	brgt	8000c94c <_vfprintf_r+0x1b0c>
8000c948:	2f 83       	sub	r3,-8
8000c94a:	c0 b8       	rjmp	8000c960 <_vfprintf_r+0x1b20>
8000c94c:	fa ca f9 78 	sub	r10,sp,-1672
8000c950:	02 9b       	mov	r11,r1
8000c952:	08 9c       	mov	r12,r4
8000c954:	fe b0 f2 68 	rcall	8000ae24 <__sprint_r>
8000c958:	e0 81 01 ff 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000c95c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c960:	40 6c       	lddsp	r12,sp[0x18]
8000c962:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c966:	87 06       	st.w	r3[0x0],r6
8000c968:	87 1c       	st.w	r3[0x4],r12
8000c96a:	18 08       	add	r8,r12
8000c96c:	cb c8       	rjmp	8000cae4 <_vfprintf_r+0x1ca4>
8000c96e:	d7 03       	nop
8000c970:	80 01       	ld.sh	r1,r0[0x0]
8000c972:	91 b0       	st.w	r8[0x2c],r0
8000c974:	80 01       	ld.sh	r1,r0[0x0]
8000c976:	91 9c       	st.w	r8[0x24],r12
8000c978:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c97c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c980:	40 6b       	lddsp	r11,sp[0x18]
8000c982:	16 3a       	cp.w	r10,r11
8000c984:	c6 d5       	brlt	8000ca5e <_vfprintf_r+0x1c1e>
8000c986:	16 09       	add	r9,r11
8000c988:	2f f8       	sub	r8,-1
8000c98a:	87 06       	st.w	r3[0x0],r6
8000c98c:	fb 49 06 90 	st.w	sp[1680],r9
8000c990:	87 1b       	st.w	r3[0x4],r11
8000c992:	fb 48 06 8c 	st.w	sp[1676],r8
8000c996:	58 78       	cp.w	r8,7
8000c998:	e0 89 00 04 	brgt	8000c9a0 <_vfprintf_r+0x1b60>
8000c99c:	2f 83       	sub	r3,-8
8000c99e:	c0 b8       	rjmp	8000c9b4 <_vfprintf_r+0x1b74>
8000c9a0:	fa ca f9 78 	sub	r10,sp,-1672
8000c9a4:	02 9b       	mov	r11,r1
8000c9a6:	08 9c       	mov	r12,r4
8000c9a8:	fe b0 f2 3e 	rcall	8000ae24 <__sprint_r>
8000c9ac:	e0 81 01 d5 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000c9b0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c9b4:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000c9b8:	40 6a       	lddsp	r10,sp[0x18]
8000c9ba:	14 16       	sub	r6,r10
8000c9bc:	58 06       	cp.w	r6,0
8000c9be:	e0 89 00 1c 	brgt	8000c9f6 <_vfprintf_r+0x1bb6>
8000c9c2:	c3 b8       	rjmp	8000ca38 <_vfprintf_r+0x1bf8>
8000c9c4:	2f 09       	sub	r9,-16
8000c9c6:	2f f8       	sub	r8,-1
8000c9c8:	fb 49 06 90 	st.w	sp[1680],r9
8000c9cc:	87 02       	st.w	r3[0x0],r2
8000c9ce:	87 10       	st.w	r3[0x4],r0
8000c9d0:	fb 48 06 8c 	st.w	sp[1676],r8
8000c9d4:	58 78       	cp.w	r8,7
8000c9d6:	e0 89 00 04 	brgt	8000c9de <_vfprintf_r+0x1b9e>
8000c9da:	2f 83       	sub	r3,-8
8000c9dc:	c0 b8       	rjmp	8000c9f2 <_vfprintf_r+0x1bb2>
8000c9de:	fa ca f9 78 	sub	r10,sp,-1672
8000c9e2:	02 9b       	mov	r11,r1
8000c9e4:	08 9c       	mov	r12,r4
8000c9e6:	fe b0 f2 1f 	rcall	8000ae24 <__sprint_r>
8000c9ea:	e0 81 01 b6 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000c9ee:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c9f2:	21 06       	sub	r6,16
8000c9f4:	c0 38       	rjmp	8000c9fa <_vfprintf_r+0x1bba>
8000c9f6:	4d c2       	lddpc	r2,8000cb64 <_vfprintf_r+0x1d24>
8000c9f8:	31 00       	mov	r0,16
8000c9fa:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c9fe:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ca02:	4d 9a       	lddpc	r10,8000cb64 <_vfprintf_r+0x1d24>
8000ca04:	59 06       	cp.w	r6,16
8000ca06:	fe 99 ff df 	brgt	8000c9c4 <_vfprintf_r+0x1b84>
8000ca0a:	0c 09       	add	r9,r6
8000ca0c:	2f f8       	sub	r8,-1
8000ca0e:	87 0a       	st.w	r3[0x0],r10
8000ca10:	fb 49 06 90 	st.w	sp[1680],r9
8000ca14:	87 16       	st.w	r3[0x4],r6
8000ca16:	fb 48 06 8c 	st.w	sp[1676],r8
8000ca1a:	58 78       	cp.w	r8,7
8000ca1c:	e0 89 00 04 	brgt	8000ca24 <_vfprintf_r+0x1be4>
8000ca20:	2f 83       	sub	r3,-8
8000ca22:	c0 b8       	rjmp	8000ca38 <_vfprintf_r+0x1bf8>
8000ca24:	fa ca f9 78 	sub	r10,sp,-1672
8000ca28:	02 9b       	mov	r11,r1
8000ca2a:	08 9c       	mov	r12,r4
8000ca2c:	fe b0 f1 fc 	rcall	8000ae24 <__sprint_r>
8000ca30:	e0 81 01 93 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000ca34:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ca38:	ed b5 00 00 	bld	r5,0x0
8000ca3c:	e0 81 01 20 	brne	8000cc7c <_vfprintf_r+0x1e3c>
8000ca40:	40 c9       	lddsp	r9,sp[0x30]
8000ca42:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ca46:	2f f8       	sub	r8,-1
8000ca48:	87 09       	st.w	r3[0x0],r9
8000ca4a:	fb 48 06 90 	st.w	sp[1680],r8
8000ca4e:	30 19       	mov	r9,1
8000ca50:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ca54:	87 19       	st.w	r3[0x4],r9
8000ca56:	2f f8       	sub	r8,-1
8000ca58:	fb 48 06 8c 	st.w	sp[1676],r8
8000ca5c:	c0 29       	rjmp	8000cc60 <_vfprintf_r+0x1e20>
8000ca5e:	14 09       	add	r9,r10
8000ca60:	2f f8       	sub	r8,-1
8000ca62:	fb 49 06 90 	st.w	sp[1680],r9
8000ca66:	87 06       	st.w	r3[0x0],r6
8000ca68:	87 1a       	st.w	r3[0x4],r10
8000ca6a:	fb 48 06 8c 	st.w	sp[1676],r8
8000ca6e:	58 78       	cp.w	r8,7
8000ca70:	e0 89 00 04 	brgt	8000ca78 <_vfprintf_r+0x1c38>
8000ca74:	2f 83       	sub	r3,-8
8000ca76:	c0 b8       	rjmp	8000ca8c <_vfprintf_r+0x1c4c>
8000ca78:	fa ca f9 78 	sub	r10,sp,-1672
8000ca7c:	02 9b       	mov	r11,r1
8000ca7e:	08 9c       	mov	r12,r4
8000ca80:	fe b0 f1 d2 	rcall	8000ae24 <__sprint_r>
8000ca84:	e0 81 01 69 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000ca88:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ca8c:	40 c8       	lddsp	r8,sp[0x30]
8000ca8e:	87 08       	st.w	r3[0x0],r8
8000ca90:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ca94:	2f f8       	sub	r8,-1
8000ca96:	30 19       	mov	r9,1
8000ca98:	fb 48 06 90 	st.w	sp[1680],r8
8000ca9c:	87 19       	st.w	r3[0x4],r9
8000ca9e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000caa2:	2f f8       	sub	r8,-1
8000caa4:	fb 48 06 8c 	st.w	sp[1676],r8
8000caa8:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000caac:	58 78       	cp.w	r8,7
8000caae:	e0 89 00 04 	brgt	8000cab6 <_vfprintf_r+0x1c76>
8000cab2:	2f 83       	sub	r3,-8
8000cab4:	c0 b8       	rjmp	8000caca <_vfprintf_r+0x1c8a>
8000cab6:	fa ca f9 78 	sub	r10,sp,-1672
8000caba:	02 9b       	mov	r11,r1
8000cabc:	08 9c       	mov	r12,r4
8000cabe:	fe b0 f1 b3 	rcall	8000ae24 <__sprint_r>
8000cac2:	e0 81 01 4a 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000cac6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000caca:	04 06       	add	r6,r2
8000cacc:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000cad0:	87 06       	st.w	r3[0x0],r6
8000cad2:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cad6:	40 66       	lddsp	r6,sp[0x18]
8000cad8:	40 6e       	lddsp	lr,sp[0x18]
8000cada:	10 16       	sub	r6,r8
8000cadc:	f2 08 01 08 	sub	r8,r9,r8
8000cae0:	87 16       	st.w	r3[0x4],r6
8000cae2:	1c 08       	add	r8,lr
8000cae4:	fb 48 06 90 	st.w	sp[1680],r8
8000cae8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000caec:	2f f8       	sub	r8,-1
8000caee:	fb 48 06 8c 	st.w	sp[1676],r8
8000caf2:	cb 78       	rjmp	8000cc60 <_vfprintf_r+0x1e20>
8000caf4:	40 6c       	lddsp	r12,sp[0x18]
8000caf6:	58 1c       	cp.w	r12,1
8000caf8:	e0 89 00 06 	brgt	8000cb04 <_vfprintf_r+0x1cc4>
8000cafc:	ed b5 00 00 	bld	r5,0x0
8000cb00:	e0 81 00 85 	brne	8000cc0a <_vfprintf_r+0x1dca>
8000cb04:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cb08:	2f f8       	sub	r8,-1
8000cb0a:	30 19       	mov	r9,1
8000cb0c:	fb 48 06 90 	st.w	sp[1680],r8
8000cb10:	87 06       	st.w	r3[0x0],r6
8000cb12:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cb16:	87 19       	st.w	r3[0x4],r9
8000cb18:	2f f8       	sub	r8,-1
8000cb1a:	fb 48 06 8c 	st.w	sp[1676],r8
8000cb1e:	58 78       	cp.w	r8,7
8000cb20:	e0 89 00 04 	brgt	8000cb28 <_vfprintf_r+0x1ce8>
8000cb24:	2f 83       	sub	r3,-8
8000cb26:	c0 b8       	rjmp	8000cb3c <_vfprintf_r+0x1cfc>
8000cb28:	fa ca f9 78 	sub	r10,sp,-1672
8000cb2c:	02 9b       	mov	r11,r1
8000cb2e:	08 9c       	mov	r12,r4
8000cb30:	fe b0 f1 7a 	rcall	8000ae24 <__sprint_r>
8000cb34:	e0 81 01 11 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000cb38:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cb3c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cb40:	2f f8       	sub	r8,-1
8000cb42:	40 cb       	lddsp	r11,sp[0x30]
8000cb44:	fb 48 06 90 	st.w	sp[1680],r8
8000cb48:	30 19       	mov	r9,1
8000cb4a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cb4e:	87 0b       	st.w	r3[0x0],r11
8000cb50:	2f f8       	sub	r8,-1
8000cb52:	87 19       	st.w	r3[0x4],r9
8000cb54:	fb 48 06 8c 	st.w	sp[1676],r8
8000cb58:	58 78       	cp.w	r8,7
8000cb5a:	e0 89 00 07 	brgt	8000cb68 <_vfprintf_r+0x1d28>
8000cb5e:	2f 83       	sub	r3,-8
8000cb60:	c0 e8       	rjmp	8000cb7c <_vfprintf_r+0x1d3c>
8000cb62:	d7 03       	nop
8000cb64:	80 01       	ld.sh	r1,r0[0x0]
8000cb66:	91 b0       	st.w	r8[0x2c],r0
8000cb68:	fa ca f9 78 	sub	r10,sp,-1672
8000cb6c:	02 9b       	mov	r11,r1
8000cb6e:	08 9c       	mov	r12,r4
8000cb70:	fe b0 f1 5a 	rcall	8000ae24 <__sprint_r>
8000cb74:	e0 81 00 f1 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000cb78:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cb7c:	30 08       	mov	r8,0
8000cb7e:	30 09       	mov	r9,0
8000cb80:	40 5b       	lddsp	r11,sp[0x14]
8000cb82:	40 7a       	lddsp	r10,sp[0x1c]
8000cb84:	e0 a0 13 25 	rcall	8000f1ce <__avr32_f64_cmp_eq>
8000cb88:	40 68       	lddsp	r8,sp[0x18]
8000cb8a:	20 18       	sub	r8,1
8000cb8c:	58 0c       	cp.w	r12,0
8000cb8e:	c0 d1       	brne	8000cba8 <_vfprintf_r+0x1d68>
8000cb90:	2f f6       	sub	r6,-1
8000cb92:	87 18       	st.w	r3[0x4],r8
8000cb94:	87 06       	st.w	r3[0x0],r6
8000cb96:	fa f6 06 90 	ld.w	r6,sp[1680]
8000cb9a:	10 06       	add	r6,r8
8000cb9c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cba0:	fb 46 06 90 	st.w	sp[1680],r6
8000cba4:	2f f8       	sub	r8,-1
8000cba6:	c2 f8       	rjmp	8000cc04 <_vfprintf_r+0x1dc4>
8000cba8:	10 96       	mov	r6,r8
8000cbaa:	58 08       	cp.w	r8,0
8000cbac:	e0 89 00 1c 	brgt	8000cbe4 <_vfprintf_r+0x1da4>
8000cbb0:	c4 98       	rjmp	8000cc42 <_vfprintf_r+0x1e02>
8000cbb2:	2f 09       	sub	r9,-16
8000cbb4:	2f f8       	sub	r8,-1
8000cbb6:	fb 49 06 90 	st.w	sp[1680],r9
8000cbba:	87 02       	st.w	r3[0x0],r2
8000cbbc:	87 10       	st.w	r3[0x4],r0
8000cbbe:	fb 48 06 8c 	st.w	sp[1676],r8
8000cbc2:	58 78       	cp.w	r8,7
8000cbc4:	e0 89 00 04 	brgt	8000cbcc <_vfprintf_r+0x1d8c>
8000cbc8:	2f 83       	sub	r3,-8
8000cbca:	c0 b8       	rjmp	8000cbe0 <_vfprintf_r+0x1da0>
8000cbcc:	fa ca f9 78 	sub	r10,sp,-1672
8000cbd0:	02 9b       	mov	r11,r1
8000cbd2:	08 9c       	mov	r12,r4
8000cbd4:	fe b0 f1 28 	rcall	8000ae24 <__sprint_r>
8000cbd8:	e0 81 00 bf 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000cbdc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cbe0:	21 06       	sub	r6,16
8000cbe2:	c0 38       	rjmp	8000cbe8 <_vfprintf_r+0x1da8>
8000cbe4:	4d 22       	lddpc	r2,8000cd2c <_vfprintf_r+0x1eec>
8000cbe6:	31 00       	mov	r0,16
8000cbe8:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cbec:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cbf0:	4c fa       	lddpc	r10,8000cd2c <_vfprintf_r+0x1eec>
8000cbf2:	59 06       	cp.w	r6,16
8000cbf4:	fe 99 ff df 	brgt	8000cbb2 <_vfprintf_r+0x1d72>
8000cbf8:	0c 09       	add	r9,r6
8000cbfa:	87 0a       	st.w	r3[0x0],r10
8000cbfc:	fb 49 06 90 	st.w	sp[1680],r9
8000cc00:	2f f8       	sub	r8,-1
8000cc02:	87 16       	st.w	r3[0x4],r6
8000cc04:	fb 48 06 8c 	st.w	sp[1676],r8
8000cc08:	c0 e8       	rjmp	8000cc24 <_vfprintf_r+0x1de4>
8000cc0a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cc0e:	2f f8       	sub	r8,-1
8000cc10:	30 19       	mov	r9,1
8000cc12:	fb 48 06 90 	st.w	sp[1680],r8
8000cc16:	87 06       	st.w	r3[0x0],r6
8000cc18:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cc1c:	87 19       	st.w	r3[0x4],r9
8000cc1e:	2f f8       	sub	r8,-1
8000cc20:	fb 48 06 8c 	st.w	sp[1676],r8
8000cc24:	58 78       	cp.w	r8,7
8000cc26:	e0 89 00 04 	brgt	8000cc2e <_vfprintf_r+0x1dee>
8000cc2a:	2f 83       	sub	r3,-8
8000cc2c:	c0 b8       	rjmp	8000cc42 <_vfprintf_r+0x1e02>
8000cc2e:	fa ca f9 78 	sub	r10,sp,-1672
8000cc32:	02 9b       	mov	r11,r1
8000cc34:	08 9c       	mov	r12,r4
8000cc36:	fe b0 f0 f7 	rcall	8000ae24 <__sprint_r>
8000cc3a:	e0 81 00 8e 	brne	8000cd56 <_vfprintf_r+0x1f16>
8000cc3e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cc42:	40 ea       	lddsp	r10,sp[0x38]
8000cc44:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cc48:	14 08       	add	r8,r10
8000cc4a:	fa c9 f9 64 	sub	r9,sp,-1692
8000cc4e:	fb 48 06 90 	st.w	sp[1680],r8
8000cc52:	87 1a       	st.w	r3[0x4],r10
8000cc54:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cc58:	87 09       	st.w	r3[0x0],r9
8000cc5a:	2f f8       	sub	r8,-1
8000cc5c:	fb 48 06 8c 	st.w	sp[1676],r8
8000cc60:	58 78       	cp.w	r8,7
8000cc62:	e0 89 00 04 	brgt	8000cc6a <_vfprintf_r+0x1e2a>
8000cc66:	2f 83       	sub	r3,-8
8000cc68:	c0 a8       	rjmp	8000cc7c <_vfprintf_r+0x1e3c>
8000cc6a:	fa ca f9 78 	sub	r10,sp,-1672
8000cc6e:	02 9b       	mov	r11,r1
8000cc70:	08 9c       	mov	r12,r4
8000cc72:	fe b0 f0 d9 	rcall	8000ae24 <__sprint_r>
8000cc76:	c7 01       	brne	8000cd56 <_vfprintf_r+0x1f16>
8000cc78:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cc7c:	e2 15 00 04 	andl	r5,0x4,COH
8000cc80:	c3 d0       	breq	8000ccfa <_vfprintf_r+0x1eba>
8000cc82:	40 86       	lddsp	r6,sp[0x20]
8000cc84:	40 39       	lddsp	r9,sp[0xc]
8000cc86:	12 16       	sub	r6,r9
8000cc88:	58 06       	cp.w	r6,0
8000cc8a:	e0 89 00 1a 	brgt	8000ccbe <_vfprintf_r+0x1e7e>
8000cc8e:	c3 68       	rjmp	8000ccfa <_vfprintf_r+0x1eba>
8000cc90:	2f 09       	sub	r9,-16
8000cc92:	2f f8       	sub	r8,-1
8000cc94:	fb 49 06 90 	st.w	sp[1680],r9
8000cc98:	87 05       	st.w	r3[0x0],r5
8000cc9a:	87 12       	st.w	r3[0x4],r2
8000cc9c:	fb 48 06 8c 	st.w	sp[1676],r8
8000cca0:	58 78       	cp.w	r8,7
8000cca2:	e0 89 00 04 	brgt	8000ccaa <_vfprintf_r+0x1e6a>
8000cca6:	2f 83       	sub	r3,-8
8000cca8:	c0 98       	rjmp	8000ccba <_vfprintf_r+0x1e7a>
8000ccaa:	00 9a       	mov	r10,r0
8000ccac:	02 9b       	mov	r11,r1
8000ccae:	08 9c       	mov	r12,r4
8000ccb0:	fe b0 f0 ba 	rcall	8000ae24 <__sprint_r>
8000ccb4:	c5 11       	brne	8000cd56 <_vfprintf_r+0x1f16>
8000ccb6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ccba:	21 06       	sub	r6,16
8000ccbc:	c0 58       	rjmp	8000ccc6 <_vfprintf_r+0x1e86>
8000ccbe:	49 d5       	lddpc	r5,8000cd30 <_vfprintf_r+0x1ef0>
8000ccc0:	31 02       	mov	r2,16
8000ccc2:	fa c0 f9 78 	sub	r0,sp,-1672
8000ccc6:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ccca:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ccce:	49 9a       	lddpc	r10,8000cd30 <_vfprintf_r+0x1ef0>
8000ccd0:	59 06       	cp.w	r6,16
8000ccd2:	fe 99 ff df 	brgt	8000cc90 <_vfprintf_r+0x1e50>
8000ccd6:	0c 09       	add	r9,r6
8000ccd8:	2f f8       	sub	r8,-1
8000ccda:	87 0a       	st.w	r3[0x0],r10
8000ccdc:	87 16       	st.w	r3[0x4],r6
8000ccde:	fb 49 06 90 	st.w	sp[1680],r9
8000cce2:	fb 48 06 8c 	st.w	sp[1676],r8
8000cce6:	58 78       	cp.w	r8,7
8000cce8:	e0 8a 00 09 	brle	8000ccfa <_vfprintf_r+0x1eba>
8000ccec:	fa ca f9 78 	sub	r10,sp,-1672
8000ccf0:	02 9b       	mov	r11,r1
8000ccf2:	08 9c       	mov	r12,r4
8000ccf4:	fe b0 f0 98 	rcall	8000ae24 <__sprint_r>
8000ccf8:	c2 f1       	brne	8000cd56 <_vfprintf_r+0x1f16>
8000ccfa:	40 bc       	lddsp	r12,sp[0x2c]
8000ccfc:	40 36       	lddsp	r6,sp[0xc]
8000ccfe:	40 8e       	lddsp	lr,sp[0x20]
8000cd00:	ec 0e 0c 48 	max	r8,r6,lr
8000cd04:	10 0c       	add	r12,r8
8000cd06:	50 bc       	stdsp	sp[0x2c],r12
8000cd08:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cd0c:	58 08       	cp.w	r8,0
8000cd0e:	c0 80       	breq	8000cd1e <_vfprintf_r+0x1ede>
8000cd10:	fa ca f9 78 	sub	r10,sp,-1672
8000cd14:	02 9b       	mov	r11,r1
8000cd16:	08 9c       	mov	r12,r4
8000cd18:	fe b0 f0 86 	rcall	8000ae24 <__sprint_r>
8000cd1c:	c1 d1       	brne	8000cd56 <_vfprintf_r+0x1f16>
8000cd1e:	30 0b       	mov	r11,0
8000cd20:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cd24:	fb 4b 06 8c 	st.w	sp[1676],r11
8000cd28:	fe 9f f1 17 	bral	8000af56 <_vfprintf_r+0x116>
8000cd2c:	80 01       	ld.sh	r1,r0[0x0]
8000cd2e:	91 b0       	st.w	r8[0x2c],r0
8000cd30:	80 01       	ld.sh	r1,r0[0x0]
8000cd32:	91 a0       	st.w	r8[0x28],r0
8000cd34:	08 95       	mov	r5,r4
8000cd36:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cd3a:	58 08       	cp.w	r8,0
8000cd3c:	c0 80       	breq	8000cd4c <_vfprintf_r+0x1f0c>
8000cd3e:	08 9c       	mov	r12,r4
8000cd40:	fa ca f9 78 	sub	r10,sp,-1672
8000cd44:	02 9b       	mov	r11,r1
8000cd46:	fe b0 f0 6f 	rcall	8000ae24 <__sprint_r>
8000cd4a:	c0 61       	brne	8000cd56 <_vfprintf_r+0x1f16>
8000cd4c:	30 08       	mov	r8,0
8000cd4e:	fb 48 06 8c 	st.w	sp[1676],r8
8000cd52:	c0 28       	rjmp	8000cd56 <_vfprintf_r+0x1f16>
8000cd54:	40 41       	lddsp	r1,sp[0x10]
8000cd56:	82 68       	ld.sh	r8,r1[0xc]
8000cd58:	ed b8 00 06 	bld	r8,0x6
8000cd5c:	c0 31       	brne	8000cd62 <_vfprintf_r+0x1f22>
8000cd5e:	3f fa       	mov	r10,-1
8000cd60:	50 ba       	stdsp	sp[0x2c],r10
8000cd62:	40 bc       	lddsp	r12,sp[0x2c]
8000cd64:	fe 3d f9 44 	sub	sp,-1724
8000cd68:	d8 32       	popm	r0-r7,pc
8000cd6a:	d7 03       	nop

8000cd6c <__swsetup_r>:
8000cd6c:	d4 21       	pushm	r4-r7,lr
8000cd6e:	e0 68 0a 38 	mov	r8,2616
8000cd72:	18 96       	mov	r6,r12
8000cd74:	16 97       	mov	r7,r11
8000cd76:	70 0c       	ld.w	r12,r8[0x0]
8000cd78:	58 0c       	cp.w	r12,0
8000cd7a:	c0 60       	breq	8000cd86 <__swsetup_r+0x1a>
8000cd7c:	78 68       	ld.w	r8,r12[0x18]
8000cd7e:	58 08       	cp.w	r8,0
8000cd80:	c0 31       	brne	8000cd86 <__swsetup_r+0x1a>
8000cd82:	e0 a0 07 c7 	rcall	8000dd10 <__sinit>
8000cd86:	4a f8       	lddpc	r8,8000ce40 <__swsetup_r+0xd4>
8000cd88:	10 37       	cp.w	r7,r8
8000cd8a:	c0 61       	brne	8000cd96 <__swsetup_r+0x2a>
8000cd8c:	e0 68 0a 38 	mov	r8,2616
8000cd90:	70 08       	ld.w	r8,r8[0x0]
8000cd92:	70 07       	ld.w	r7,r8[0x0]
8000cd94:	c1 08       	rjmp	8000cdb4 <__swsetup_r+0x48>
8000cd96:	4a c8       	lddpc	r8,8000ce44 <__swsetup_r+0xd8>
8000cd98:	10 37       	cp.w	r7,r8
8000cd9a:	c0 61       	brne	8000cda6 <__swsetup_r+0x3a>
8000cd9c:	e0 68 0a 38 	mov	r8,2616
8000cda0:	70 08       	ld.w	r8,r8[0x0]
8000cda2:	70 17       	ld.w	r7,r8[0x4]
8000cda4:	c0 88       	rjmp	8000cdb4 <__swsetup_r+0x48>
8000cda6:	4a 98       	lddpc	r8,8000ce48 <__swsetup_r+0xdc>
8000cda8:	10 37       	cp.w	r7,r8
8000cdaa:	c0 51       	brne	8000cdb4 <__swsetup_r+0x48>
8000cdac:	e0 68 0a 38 	mov	r8,2616
8000cdb0:	70 08       	ld.w	r8,r8[0x0]
8000cdb2:	70 27       	ld.w	r7,r8[0x8]
8000cdb4:	8e 68       	ld.sh	r8,r7[0xc]
8000cdb6:	ed b8 00 03 	bld	r8,0x3
8000cdba:	c1 e0       	breq	8000cdf6 <__swsetup_r+0x8a>
8000cdbc:	ed b8 00 04 	bld	r8,0x4
8000cdc0:	c3 e1       	brne	8000ce3c <__swsetup_r+0xd0>
8000cdc2:	ed b8 00 02 	bld	r8,0x2
8000cdc6:	c1 51       	brne	8000cdf0 <__swsetup_r+0x84>
8000cdc8:	6e db       	ld.w	r11,r7[0x34]
8000cdca:	58 0b       	cp.w	r11,0
8000cdcc:	c0 a0       	breq	8000cde0 <__swsetup_r+0x74>
8000cdce:	ee c8 ff bc 	sub	r8,r7,-68
8000cdd2:	10 3b       	cp.w	r11,r8
8000cdd4:	c0 40       	breq	8000cddc <__swsetup_r+0x70>
8000cdd6:	0c 9c       	mov	r12,r6
8000cdd8:	e0 a0 08 36 	rcall	8000de44 <_free_r>
8000cddc:	30 08       	mov	r8,0
8000cdde:	8f d8       	st.w	r7[0x34],r8
8000cde0:	8e 68       	ld.sh	r8,r7[0xc]
8000cde2:	e0 18 ff db 	andl	r8,0xffdb
8000cde6:	ae 68       	st.h	r7[0xc],r8
8000cde8:	30 08       	mov	r8,0
8000cdea:	8f 18       	st.w	r7[0x4],r8
8000cdec:	6e 48       	ld.w	r8,r7[0x10]
8000cdee:	8f 08       	st.w	r7[0x0],r8
8000cdf0:	8e 68       	ld.sh	r8,r7[0xc]
8000cdf2:	a3 b8       	sbr	r8,0x3
8000cdf4:	ae 68       	st.h	r7[0xc],r8
8000cdf6:	6e 48       	ld.w	r8,r7[0x10]
8000cdf8:	58 08       	cp.w	r8,0
8000cdfa:	c0 b1       	brne	8000ce10 <__swsetup_r+0xa4>
8000cdfc:	8e 68       	ld.sh	r8,r7[0xc]
8000cdfe:	e2 18 02 80 	andl	r8,0x280,COH
8000ce02:	e0 48 02 00 	cp.w	r8,512
8000ce06:	c0 50       	breq	8000ce10 <__swsetup_r+0xa4>
8000ce08:	0c 9c       	mov	r12,r6
8000ce0a:	0e 9b       	mov	r11,r7
8000ce0c:	e0 a0 0a 56 	rcall	8000e2b8 <__smakebuf_r>
8000ce10:	8e 69       	ld.sh	r9,r7[0xc]
8000ce12:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000ce16:	c0 70       	breq	8000ce24 <__swsetup_r+0xb8>
8000ce18:	30 08       	mov	r8,0
8000ce1a:	8f 28       	st.w	r7[0x8],r8
8000ce1c:	6e 58       	ld.w	r8,r7[0x14]
8000ce1e:	5c 38       	neg	r8
8000ce20:	8f 68       	st.w	r7[0x18],r8
8000ce22:	c0 68       	rjmp	8000ce2e <__swsetup_r+0xc2>
8000ce24:	ed b9 00 01 	bld	r9,0x1
8000ce28:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000ce2c:	8f 28       	st.w	r7[0x8],r8
8000ce2e:	6e 48       	ld.w	r8,r7[0x10]
8000ce30:	58 08       	cp.w	r8,0
8000ce32:	c0 61       	brne	8000ce3e <__swsetup_r+0xd2>
8000ce34:	8e 68       	ld.sh	r8,r7[0xc]
8000ce36:	ed b8 00 07 	bld	r8,0x7
8000ce3a:	c0 21       	brne	8000ce3e <__swsetup_r+0xd2>
8000ce3c:	dc 2a       	popm	r4-r7,pc,r12=-1
8000ce3e:	d8 2a       	popm	r4-r7,pc,r12=0
8000ce40:	80 01       	ld.sh	r1,r0[0x0]
8000ce42:	92 d0       	ld.uh	r0,r9[0xa]
8000ce44:	80 01       	ld.sh	r1,r0[0x0]
8000ce46:	92 f0       	ld.uh	r0,r9[0xe]
8000ce48:	80 01       	ld.sh	r1,r0[0x0]
8000ce4a:	93 10       	st.w	r9[0x4],r0

8000ce4c <quorem>:
8000ce4c:	d4 31       	pushm	r0-r7,lr
8000ce4e:	20 2d       	sub	sp,8
8000ce50:	18 97       	mov	r7,r12
8000ce52:	78 48       	ld.w	r8,r12[0x10]
8000ce54:	76 46       	ld.w	r6,r11[0x10]
8000ce56:	0c 38       	cp.w	r8,r6
8000ce58:	c0 34       	brge	8000ce5e <quorem+0x12>
8000ce5a:	30 0c       	mov	r12,0
8000ce5c:	c8 58       	rjmp	8000cf66 <quorem+0x11a>
8000ce5e:	ec c2 ff fc 	sub	r2,r6,-4
8000ce62:	f6 c3 ff ec 	sub	r3,r11,-20
8000ce66:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000ce6a:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000ce6e:	2f f9       	sub	r9,-1
8000ce70:	20 16       	sub	r6,1
8000ce72:	f8 09 0d 08 	divu	r8,r12,r9
8000ce76:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000ce7a:	ee c4 ff ec 	sub	r4,r7,-20
8000ce7e:	10 95       	mov	r5,r8
8000ce80:	58 08       	cp.w	r8,0
8000ce82:	c4 10       	breq	8000cf04 <quorem+0xb8>
8000ce84:	30 09       	mov	r9,0
8000ce86:	06 9a       	mov	r10,r3
8000ce88:	08 98       	mov	r8,r4
8000ce8a:	12 91       	mov	r1,r9
8000ce8c:	50 0b       	stdsp	sp[0x0],r11
8000ce8e:	70 0e       	ld.w	lr,r8[0x0]
8000ce90:	b1 8e       	lsr	lr,0x10
8000ce92:	50 1e       	stdsp	sp[0x4],lr
8000ce94:	15 0e       	ld.w	lr,r10++
8000ce96:	fc 00 16 10 	lsr	r0,lr,0x10
8000ce9a:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000ce9e:	ea 0e 03 41 	mac	r1,r5,lr
8000cea2:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000cea6:	b1 81       	lsr	r1,0x10
8000cea8:	40 1b       	lddsp	r11,sp[0x4]
8000ceaa:	ea 00 02 40 	mul	r0,r5,r0
8000ceae:	e2 00 00 00 	add	r0,r1,r0
8000ceb2:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000ceb6:	02 1b       	sub	r11,r1
8000ceb8:	50 1b       	stdsp	sp[0x4],r11
8000ceba:	70 0b       	ld.w	r11,r8[0x0]
8000cebc:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000cec0:	02 09       	add	r9,r1
8000cec2:	f2 0e 01 0e 	sub	lr,r9,lr
8000cec6:	b0 1e       	st.h	r8[0x2],lr
8000cec8:	fc 09 14 10 	asr	r9,lr,0x10
8000cecc:	40 1e       	lddsp	lr,sp[0x4]
8000cece:	fc 09 00 09 	add	r9,lr,r9
8000ced2:	b0 09       	st.h	r8[0x0],r9
8000ced4:	e0 01 16 10 	lsr	r1,r0,0x10
8000ced8:	2f c8       	sub	r8,-4
8000ceda:	b1 49       	asr	r9,0x10
8000cedc:	04 3a       	cp.w	r10,r2
8000cede:	fe 98 ff d8 	brls	8000ce8e <quorem+0x42>
8000cee2:	40 0b       	lddsp	r11,sp[0x0]
8000cee4:	58 0c       	cp.w	r12,0
8000cee6:	c0 f1       	brne	8000cf04 <quorem+0xb8>
8000cee8:	ec c8 ff fb 	sub	r8,r6,-5
8000ceec:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000cef0:	c0 28       	rjmp	8000cef4 <quorem+0xa8>
8000cef2:	20 16       	sub	r6,1
8000cef4:	20 48       	sub	r8,4
8000cef6:	08 38       	cp.w	r8,r4
8000cef8:	e0 88 00 05 	brls	8000cf02 <quorem+0xb6>
8000cefc:	70 09       	ld.w	r9,r8[0x0]
8000cefe:	58 09       	cp.w	r9,0
8000cf00:	cf 90       	breq	8000cef2 <quorem+0xa6>
8000cf02:	8f 46       	st.w	r7[0x10],r6
8000cf04:	0e 9c       	mov	r12,r7
8000cf06:	e0 a0 0a d8 	rcall	8000e4b6 <__mcmp>
8000cf0a:	c2 d5       	brlt	8000cf64 <quorem+0x118>
8000cf0c:	2f f5       	sub	r5,-1
8000cf0e:	08 98       	mov	r8,r4
8000cf10:	30 09       	mov	r9,0
8000cf12:	07 0b       	ld.w	r11,r3++
8000cf14:	f6 0a 16 10 	lsr	r10,r11,0x10
8000cf18:	70 0c       	ld.w	r12,r8[0x0]
8000cf1a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000cf1e:	f8 0e 16 10 	lsr	lr,r12,0x10
8000cf22:	14 1e       	sub	lr,r10
8000cf24:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000cf28:	16 1a       	sub	r10,r11
8000cf2a:	12 0a       	add	r10,r9
8000cf2c:	b0 1a       	st.h	r8[0x2],r10
8000cf2e:	b1 4a       	asr	r10,0x10
8000cf30:	fc 0a 00 09 	add	r9,lr,r10
8000cf34:	b0 09       	st.h	r8[0x0],r9
8000cf36:	2f c8       	sub	r8,-4
8000cf38:	b1 49       	asr	r9,0x10
8000cf3a:	04 33       	cp.w	r3,r2
8000cf3c:	fe 98 ff eb 	brls	8000cf12 <quorem+0xc6>
8000cf40:	ec c8 ff fb 	sub	r8,r6,-5
8000cf44:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000cf48:	58 09       	cp.w	r9,0
8000cf4a:	c0 d1       	brne	8000cf64 <quorem+0x118>
8000cf4c:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000cf50:	c0 28       	rjmp	8000cf54 <quorem+0x108>
8000cf52:	20 16       	sub	r6,1
8000cf54:	20 48       	sub	r8,4
8000cf56:	08 38       	cp.w	r8,r4
8000cf58:	e0 88 00 05 	brls	8000cf62 <quorem+0x116>
8000cf5c:	70 09       	ld.w	r9,r8[0x0]
8000cf5e:	58 09       	cp.w	r9,0
8000cf60:	cf 90       	breq	8000cf52 <quorem+0x106>
8000cf62:	8f 46       	st.w	r7[0x10],r6
8000cf64:	0a 9c       	mov	r12,r5
8000cf66:	2f ed       	sub	sp,-8
8000cf68:	d8 32       	popm	r0-r7,pc
8000cf6a:	d7 03       	nop

8000cf6c <_dtoa_r>:
8000cf6c:	d4 31       	pushm	r0-r7,lr
8000cf6e:	21 ad       	sub	sp,104
8000cf70:	fa c4 ff 74 	sub	r4,sp,-140
8000cf74:	18 97       	mov	r7,r12
8000cf76:	16 95       	mov	r5,r11
8000cf78:	68 2c       	ld.w	r12,r4[0x8]
8000cf7a:	50 c9       	stdsp	sp[0x30],r9
8000cf7c:	68 16       	ld.w	r6,r4[0x4]
8000cf7e:	68 09       	ld.w	r9,r4[0x0]
8000cf80:	50 e8       	stdsp	sp[0x38],r8
8000cf82:	14 94       	mov	r4,r10
8000cf84:	51 2c       	stdsp	sp[0x48],r12
8000cf86:	fa e5 00 08 	st.d	sp[8],r4
8000cf8a:	51 59       	stdsp	sp[0x54],r9
8000cf8c:	6e 95       	ld.w	r5,r7[0x24]
8000cf8e:	58 05       	cp.w	r5,0
8000cf90:	c0 91       	brne	8000cfa2 <_dtoa_r+0x36>
8000cf92:	31 0c       	mov	r12,16
8000cf94:	fe b0 e8 42 	rcall	8000a018 <malloc>
8000cf98:	99 35       	st.w	r12[0xc],r5
8000cf9a:	8f 9c       	st.w	r7[0x24],r12
8000cf9c:	99 15       	st.w	r12[0x4],r5
8000cf9e:	99 25       	st.w	r12[0x8],r5
8000cfa0:	99 05       	st.w	r12[0x0],r5
8000cfa2:	6e 99       	ld.w	r9,r7[0x24]
8000cfa4:	72 08       	ld.w	r8,r9[0x0]
8000cfa6:	58 08       	cp.w	r8,0
8000cfa8:	c0 f0       	breq	8000cfc6 <_dtoa_r+0x5a>
8000cfaa:	72 1a       	ld.w	r10,r9[0x4]
8000cfac:	91 1a       	st.w	r8[0x4],r10
8000cfae:	30 1a       	mov	r10,1
8000cfb0:	72 19       	ld.w	r9,r9[0x4]
8000cfb2:	f4 09 09 49 	lsl	r9,r10,r9
8000cfb6:	10 9b       	mov	r11,r8
8000cfb8:	91 29       	st.w	r8[0x8],r9
8000cfba:	0e 9c       	mov	r12,r7
8000cfbc:	e0 a0 0a 96 	rcall	8000e4e8 <_Bfree>
8000cfc0:	6e 98       	ld.w	r8,r7[0x24]
8000cfc2:	30 09       	mov	r9,0
8000cfc4:	91 09       	st.w	r8[0x0],r9
8000cfc6:	40 28       	lddsp	r8,sp[0x8]
8000cfc8:	10 94       	mov	r4,r8
8000cfca:	58 08       	cp.w	r8,0
8000cfcc:	c0 64       	brge	8000cfd8 <_dtoa_r+0x6c>
8000cfce:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000cfd2:	50 28       	stdsp	sp[0x8],r8
8000cfd4:	30 18       	mov	r8,1
8000cfd6:	c0 28       	rjmp	8000cfda <_dtoa_r+0x6e>
8000cfd8:	30 08       	mov	r8,0
8000cfda:	8d 08       	st.w	r6[0x0],r8
8000cfdc:	fc 1c 7f f0 	movh	r12,0x7ff0
8000cfe0:	40 26       	lddsp	r6,sp[0x8]
8000cfe2:	0c 98       	mov	r8,r6
8000cfe4:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000cfe8:	18 38       	cp.w	r8,r12
8000cfea:	c1 e1       	brne	8000d026 <_dtoa_r+0xba>
8000cfec:	e0 68 27 0f 	mov	r8,9999
8000cff0:	41 5b       	lddsp	r11,sp[0x54]
8000cff2:	97 08       	st.w	r11[0x0],r8
8000cff4:	40 3a       	lddsp	r10,sp[0xc]
8000cff6:	58 0a       	cp.w	r10,0
8000cff8:	c0 61       	brne	8000d004 <_dtoa_r+0x98>
8000cffa:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000cffe:	c0 31       	brne	8000d004 <_dtoa_r+0x98>
8000d000:	4a cc       	lddpc	r12,8000d0b0 <_dtoa_r+0x144>
8000d002:	c0 28       	rjmp	8000d006 <_dtoa_r+0x9a>
8000d004:	4a cc       	lddpc	r12,8000d0b4 <_dtoa_r+0x148>
8000d006:	41 29       	lddsp	r9,sp[0x48]
8000d008:	58 09       	cp.w	r9,0
8000d00a:	e0 80 05 9e 	breq	8000db46 <_dtoa_r+0xbda>
8000d00e:	f8 c8 ff fd 	sub	r8,r12,-3
8000d012:	f8 c9 ff f8 	sub	r9,r12,-8
8000d016:	11 8b       	ld.ub	r11,r8[0x0]
8000d018:	30 0a       	mov	r10,0
8000d01a:	41 25       	lddsp	r5,sp[0x48]
8000d01c:	f4 0b 18 00 	cp.b	r11,r10
8000d020:	f2 08 17 10 	movne	r8,r9
8000d024:	c1 58       	rjmp	8000d04e <_dtoa_r+0xe2>
8000d026:	fa ea 00 08 	ld.d	r10,sp[8]
8000d02a:	30 08       	mov	r8,0
8000d02c:	fa eb 00 3c 	st.d	sp[60],r10
8000d030:	30 09       	mov	r9,0
8000d032:	e0 a0 10 ce 	rcall	8000f1ce <__avr32_f64_cmp_eq>
8000d036:	c0 f0       	breq	8000d054 <_dtoa_r+0xe8>
8000d038:	30 18       	mov	r8,1
8000d03a:	41 5a       	lddsp	r10,sp[0x54]
8000d03c:	95 08       	st.w	r10[0x0],r8
8000d03e:	49 fc       	lddpc	r12,8000d0b8 <_dtoa_r+0x14c>
8000d040:	41 29       	lddsp	r9,sp[0x48]
8000d042:	f8 08 00 08 	add	r8,r12,r8
8000d046:	58 09       	cp.w	r9,0
8000d048:	e0 80 05 7f 	breq	8000db46 <_dtoa_r+0xbda>
8000d04c:	12 95       	mov	r5,r9
8000d04e:	8b 08       	st.w	r5[0x0],r8
8000d050:	e0 8f 05 7b 	bral	8000db46 <_dtoa_r+0xbda>
8000d054:	fa c8 ff 9c 	sub	r8,sp,-100
8000d058:	fa c9 ff a0 	sub	r9,sp,-96
8000d05c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d060:	0e 9c       	mov	r12,r7
8000d062:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000d066:	e0 a0 0a 93 	rcall	8000e58c <__d2b>
8000d06a:	18 93       	mov	r3,r12
8000d06c:	58 05       	cp.w	r5,0
8000d06e:	c0 d0       	breq	8000d088 <_dtoa_r+0x11c>
8000d070:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d074:	30 04       	mov	r4,0
8000d076:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000d07a:	ea c5 03 ff 	sub	r5,r5,1023
8000d07e:	10 9b       	mov	r11,r8
8000d080:	51 74       	stdsp	sp[0x5c],r4
8000d082:	ea 1b 3f f0 	orh	r11,0x3ff0
8000d086:	c2 a8       	rjmp	8000d0da <_dtoa_r+0x16e>
8000d088:	41 88       	lddsp	r8,sp[0x60]
8000d08a:	41 9c       	lddsp	r12,sp[0x64]
8000d08c:	10 0c       	add	r12,r8
8000d08e:	f8 c5 fb ce 	sub	r5,r12,-1074
8000d092:	e0 45 00 20 	cp.w	r5,32
8000d096:	e0 8a 00 13 	brle	8000d0bc <_dtoa_r+0x150>
8000d09a:	f8 cc fb ee 	sub	r12,r12,-1042
8000d09e:	40 3b       	lddsp	r11,sp[0xc]
8000d0a0:	ea 08 11 40 	rsub	r8,r5,64
8000d0a4:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000d0a8:	ec 08 09 46 	lsl	r6,r6,r8
8000d0ac:	0c 4c       	or	r12,r6
8000d0ae:	c0 c8       	rjmp	8000d0c6 <_dtoa_r+0x15a>
8000d0b0:	80 01       	ld.sh	r1,r0[0x0]
8000d0b2:	92 c0       	ld.uh	r0,r9[0x8]
8000d0b4:	80 01       	ld.sh	r1,r0[0x0]
8000d0b6:	92 cc       	ld.uh	r12,r9[0x8]
8000d0b8:	80 01       	ld.sh	r1,r0[0x0]
8000d0ba:	91 9c       	st.w	r8[0x24],r12
8000d0bc:	ea 0c 11 20 	rsub	r12,r5,32
8000d0c0:	40 3a       	lddsp	r10,sp[0xc]
8000d0c2:	f4 0c 09 4c 	lsl	r12,r10,r12
8000d0c6:	e0 a0 10 10 	rcall	8000f0e6 <__avr32_u32_to_f64>
8000d0ca:	fc 18 fe 10 	movh	r8,0xfe10
8000d0ce:	30 19       	mov	r9,1
8000d0d0:	ea c5 04 33 	sub	r5,r5,1075
8000d0d4:	f0 0b 00 0b 	add	r11,r8,r11
8000d0d8:	51 79       	stdsp	sp[0x5c],r9
8000d0da:	30 08       	mov	r8,0
8000d0dc:	fc 19 3f f8 	movh	r9,0x3ff8
8000d0e0:	e0 a0 0e 98 	rcall	8000ee10 <__avr32_f64_sub>
8000d0e4:	e0 68 43 61 	mov	r8,17249
8000d0e8:	ea 18 63 6f 	orh	r8,0x636f
8000d0ec:	e0 69 87 a7 	mov	r9,34727
8000d0f0:	ea 19 3f d2 	orh	r9,0x3fd2
8000d0f4:	e0 a0 0d a2 	rcall	8000ec38 <__avr32_f64_mul>
8000d0f8:	e0 68 c8 b3 	mov	r8,51379
8000d0fc:	ea 18 8b 60 	orh	r8,0x8b60
8000d100:	e0 69 8a 28 	mov	r9,35368
8000d104:	ea 19 3f c6 	orh	r9,0x3fc6
8000d108:	e0 a0 0f 52 	rcall	8000efac <__avr32_f64_add>
8000d10c:	0a 9c       	mov	r12,r5
8000d10e:	14 90       	mov	r0,r10
8000d110:	16 91       	mov	r1,r11
8000d112:	e0 a0 0f ee 	rcall	8000f0ee <__avr32_s32_to_f64>
8000d116:	e0 68 79 fb 	mov	r8,31227
8000d11a:	ea 18 50 9f 	orh	r8,0x509f
8000d11e:	e0 69 44 13 	mov	r9,17427
8000d122:	ea 19 3f d3 	orh	r9,0x3fd3
8000d126:	e0 a0 0d 89 	rcall	8000ec38 <__avr32_f64_mul>
8000d12a:	14 98       	mov	r8,r10
8000d12c:	16 99       	mov	r9,r11
8000d12e:	00 9a       	mov	r10,r0
8000d130:	02 9b       	mov	r11,r1
8000d132:	e0 a0 0f 3d 	rcall	8000efac <__avr32_f64_add>
8000d136:	14 90       	mov	r0,r10
8000d138:	16 91       	mov	r1,r11
8000d13a:	e0 a0 0f c3 	rcall	8000f0c0 <__avr32_f64_to_s32>
8000d13e:	30 08       	mov	r8,0
8000d140:	18 96       	mov	r6,r12
8000d142:	30 09       	mov	r9,0
8000d144:	00 9a       	mov	r10,r0
8000d146:	02 9b       	mov	r11,r1
8000d148:	e0 a0 10 8a 	rcall	8000f25c <__avr32_f64_cmp_lt>
8000d14c:	c0 c0       	breq	8000d164 <_dtoa_r+0x1f8>
8000d14e:	0c 9c       	mov	r12,r6
8000d150:	e0 a0 0f cf 	rcall	8000f0ee <__avr32_s32_to_f64>
8000d154:	14 98       	mov	r8,r10
8000d156:	16 99       	mov	r9,r11
8000d158:	00 9a       	mov	r10,r0
8000d15a:	02 9b       	mov	r11,r1
8000d15c:	e0 a0 10 39 	rcall	8000f1ce <__avr32_f64_cmp_eq>
8000d160:	f7 b6 00 01 	subeq	r6,1
8000d164:	59 66       	cp.w	r6,22
8000d166:	e0 88 00 05 	brls	8000d170 <_dtoa_r+0x204>
8000d16a:	30 18       	mov	r8,1
8000d16c:	51 48       	stdsp	sp[0x50],r8
8000d16e:	c1 28       	rjmp	8000d192 <_dtoa_r+0x226>
8000d170:	4c 08       	lddpc	r8,8000d270 <_dtoa_r+0x304>
8000d172:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d176:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000d17a:	e0 a0 10 71 	rcall	8000f25c <__avr32_f64_cmp_lt>
8000d17e:	f9 b4 00 00 	moveq	r4,0
8000d182:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000d186:	f7 b6 01 01 	subne	r6,1
8000d18a:	f9 bc 01 00 	movne	r12,0
8000d18e:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000d192:	41 90       	lddsp	r0,sp[0x64]
8000d194:	20 10       	sub	r0,1
8000d196:	0a 10       	sub	r0,r5
8000d198:	c0 46       	brmi	8000d1a0 <_dtoa_r+0x234>
8000d19a:	50 40       	stdsp	sp[0x10],r0
8000d19c:	30 00       	mov	r0,0
8000d19e:	c0 48       	rjmp	8000d1a6 <_dtoa_r+0x23a>
8000d1a0:	30 0b       	mov	r11,0
8000d1a2:	5c 30       	neg	r0
8000d1a4:	50 4b       	stdsp	sp[0x10],r11
8000d1a6:	ec 02 11 00 	rsub	r2,r6,0
8000d1aa:	58 06       	cp.w	r6,0
8000d1ac:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000d1b0:	f5 d6 e4 0a 	addge	r10,r10,r6
8000d1b4:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000d1b8:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000d1bc:	f9 b2 04 00 	movge	r2,0
8000d1c0:	e1 d6 e5 10 	sublt	r0,r0,r6
8000d1c4:	f9 b9 05 00 	movlt	r9,0
8000d1c8:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000d1cc:	40 c8       	lddsp	r8,sp[0x30]
8000d1ce:	58 98       	cp.w	r8,9
8000d1d0:	e0 8b 00 20 	brhi	8000d210 <_dtoa_r+0x2a4>
8000d1d4:	58 58       	cp.w	r8,5
8000d1d6:	f9 b4 0a 01 	movle	r4,1
8000d1da:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000d1de:	f7 b5 09 04 	subgt	r5,4
8000d1e2:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000d1e6:	f9 b4 09 00 	movgt	r4,0
8000d1ea:	40 cc       	lddsp	r12,sp[0x30]
8000d1ec:	58 3c       	cp.w	r12,3
8000d1ee:	c2 d0       	breq	8000d248 <_dtoa_r+0x2dc>
8000d1f0:	e0 89 00 05 	brgt	8000d1fa <_dtoa_r+0x28e>
8000d1f4:	58 2c       	cp.w	r12,2
8000d1f6:	c1 01       	brne	8000d216 <_dtoa_r+0x2aa>
8000d1f8:	c1 88       	rjmp	8000d228 <_dtoa_r+0x2bc>
8000d1fa:	40 cb       	lddsp	r11,sp[0x30]
8000d1fc:	58 4b       	cp.w	r11,4
8000d1fe:	c0 60       	breq	8000d20a <_dtoa_r+0x29e>
8000d200:	58 5b       	cp.w	r11,5
8000d202:	c0 a1       	brne	8000d216 <_dtoa_r+0x2aa>
8000d204:	30 1a       	mov	r10,1
8000d206:	50 da       	stdsp	sp[0x34],r10
8000d208:	c2 28       	rjmp	8000d24c <_dtoa_r+0x2e0>
8000d20a:	30 19       	mov	r9,1
8000d20c:	50 d9       	stdsp	sp[0x34],r9
8000d20e:	c0 f8       	rjmp	8000d22c <_dtoa_r+0x2c0>
8000d210:	30 08       	mov	r8,0
8000d212:	30 14       	mov	r4,1
8000d214:	50 c8       	stdsp	sp[0x30],r8
8000d216:	3f f5       	mov	r5,-1
8000d218:	30 1c       	mov	r12,1
8000d21a:	30 0b       	mov	r11,0
8000d21c:	50 95       	stdsp	sp[0x24],r5
8000d21e:	50 dc       	stdsp	sp[0x34],r12
8000d220:	0a 91       	mov	r1,r5
8000d222:	31 28       	mov	r8,18
8000d224:	50 eb       	stdsp	sp[0x38],r11
8000d226:	c2 08       	rjmp	8000d266 <_dtoa_r+0x2fa>
8000d228:	30 0a       	mov	r10,0
8000d22a:	50 da       	stdsp	sp[0x34],r10
8000d22c:	40 e9       	lddsp	r9,sp[0x38]
8000d22e:	58 09       	cp.w	r9,0
8000d230:	e0 89 00 07 	brgt	8000d23e <_dtoa_r+0x2d2>
8000d234:	30 18       	mov	r8,1
8000d236:	50 98       	stdsp	sp[0x24],r8
8000d238:	10 91       	mov	r1,r8
8000d23a:	50 e8       	stdsp	sp[0x38],r8
8000d23c:	c1 58       	rjmp	8000d266 <_dtoa_r+0x2fa>
8000d23e:	40 e5       	lddsp	r5,sp[0x38]
8000d240:	50 95       	stdsp	sp[0x24],r5
8000d242:	0a 91       	mov	r1,r5
8000d244:	0a 98       	mov	r8,r5
8000d246:	c1 08       	rjmp	8000d266 <_dtoa_r+0x2fa>
8000d248:	30 0c       	mov	r12,0
8000d24a:	50 dc       	stdsp	sp[0x34],r12
8000d24c:	40 eb       	lddsp	r11,sp[0x38]
8000d24e:	ec 0b 00 0b 	add	r11,r6,r11
8000d252:	50 9b       	stdsp	sp[0x24],r11
8000d254:	16 98       	mov	r8,r11
8000d256:	2f f8       	sub	r8,-1
8000d258:	58 08       	cp.w	r8,0
8000d25a:	e0 89 00 05 	brgt	8000d264 <_dtoa_r+0x2f8>
8000d25e:	10 91       	mov	r1,r8
8000d260:	30 18       	mov	r8,1
8000d262:	c0 28       	rjmp	8000d266 <_dtoa_r+0x2fa>
8000d264:	10 91       	mov	r1,r8
8000d266:	30 09       	mov	r9,0
8000d268:	6e 9a       	ld.w	r10,r7[0x24]
8000d26a:	95 19       	st.w	r10[0x4],r9
8000d26c:	30 49       	mov	r9,4
8000d26e:	c0 78       	rjmp	8000d27c <_dtoa_r+0x310>
8000d270:	80 01       	ld.sh	r1,r0[0x0]
8000d272:	93 80       	st.w	r9[0x20],r0
8000d274:	6a 1a       	ld.w	r10,r5[0x4]
8000d276:	a1 79       	lsl	r9,0x1
8000d278:	2f fa       	sub	r10,-1
8000d27a:	8b 1a       	st.w	r5[0x4],r10
8000d27c:	6e 95       	ld.w	r5,r7[0x24]
8000d27e:	f2 ca ff ec 	sub	r10,r9,-20
8000d282:	10 3a       	cp.w	r10,r8
8000d284:	fe 98 ff f8 	brls	8000d274 <_dtoa_r+0x308>
8000d288:	6a 1b       	ld.w	r11,r5[0x4]
8000d28a:	0e 9c       	mov	r12,r7
8000d28c:	e0 a0 09 48 	rcall	8000e51c <_Balloc>
8000d290:	58 e1       	cp.w	r1,14
8000d292:	5f 88       	srls	r8
8000d294:	8b 0c       	st.w	r5[0x0],r12
8000d296:	f1 e4 00 04 	and	r4,r8,r4
8000d29a:	6e 98       	ld.w	r8,r7[0x24]
8000d29c:	70 08       	ld.w	r8,r8[0x0]
8000d29e:	50 88       	stdsp	sp[0x20],r8
8000d2a0:	e0 80 01 82 	breq	8000d5a4 <_dtoa_r+0x638>
8000d2a4:	58 06       	cp.w	r6,0
8000d2a6:	e0 8a 00 40 	brle	8000d326 <_dtoa_r+0x3ba>
8000d2aa:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000d2ae:	4c b8       	lddpc	r8,8000d3d8 <_dtoa_r+0x46c>
8000d2b0:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000d2b4:	fa e5 00 18 	st.d	sp[24],r4
8000d2b8:	ec 04 14 04 	asr	r4,r6,0x4
8000d2bc:	ed b4 00 04 	bld	r4,0x4
8000d2c0:	c0 30       	breq	8000d2c6 <_dtoa_r+0x35a>
8000d2c2:	30 25       	mov	r5,2
8000d2c4:	c0 f8       	rjmp	8000d2e2 <_dtoa_r+0x376>
8000d2c6:	4c 68       	lddpc	r8,8000d3dc <_dtoa_r+0x470>
8000d2c8:	f0 e8 00 20 	ld.d	r8,r8[32]
8000d2cc:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d2d0:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000d2d4:	e0 a0 0f f8 	rcall	8000f2c4 <__avr32_f64_div>
8000d2d8:	30 35       	mov	r5,3
8000d2da:	14 98       	mov	r8,r10
8000d2dc:	16 99       	mov	r9,r11
8000d2de:	fa e9 00 08 	st.d	sp[8],r8
8000d2e2:	4b fc       	lddpc	r12,8000d3dc <_dtoa_r+0x470>
8000d2e4:	50 a3       	stdsp	sp[0x28],r3
8000d2e6:	0c 93       	mov	r3,r6
8000d2e8:	18 96       	mov	r6,r12
8000d2ea:	c0 f8       	rjmp	8000d308 <_dtoa_r+0x39c>
8000d2ec:	fa ea 00 18 	ld.d	r10,sp[24]
8000d2f0:	ed b4 00 00 	bld	r4,0x0
8000d2f4:	c0 81       	brne	8000d304 <_dtoa_r+0x398>
8000d2f6:	ec e8 00 00 	ld.d	r8,r6[0]
8000d2fa:	2f f5       	sub	r5,-1
8000d2fc:	e0 a0 0c 9e 	rcall	8000ec38 <__avr32_f64_mul>
8000d300:	fa eb 00 18 	st.d	sp[24],r10
8000d304:	a1 54       	asr	r4,0x1
8000d306:	2f 86       	sub	r6,-8
8000d308:	58 04       	cp.w	r4,0
8000d30a:	cf 11       	brne	8000d2ec <_dtoa_r+0x380>
8000d30c:	fa e8 00 18 	ld.d	r8,sp[24]
8000d310:	fa ea 00 08 	ld.d	r10,sp[8]
8000d314:	06 96       	mov	r6,r3
8000d316:	e0 a0 0f d7 	rcall	8000f2c4 <__avr32_f64_div>
8000d31a:	40 a3       	lddsp	r3,sp[0x28]
8000d31c:	14 98       	mov	r8,r10
8000d31e:	16 99       	mov	r9,r11
8000d320:	fa e9 00 08 	st.d	sp[8],r8
8000d324:	c2 d8       	rjmp	8000d37e <_dtoa_r+0x412>
8000d326:	ec 08 11 00 	rsub	r8,r6,0
8000d32a:	c0 31       	brne	8000d330 <_dtoa_r+0x3c4>
8000d32c:	30 25       	mov	r5,2
8000d32e:	c2 88       	rjmp	8000d37e <_dtoa_r+0x412>
8000d330:	4a bc       	lddpc	r12,8000d3dc <_dtoa_r+0x470>
8000d332:	f0 04 14 04 	asr	r4,r8,0x4
8000d336:	50 1c       	stdsp	sp[0x4],r12
8000d338:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000d33c:	4a 79       	lddpc	r9,8000d3d8 <_dtoa_r+0x46c>
8000d33e:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d342:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000d346:	e0 a0 0c 79 	rcall	8000ec38 <__avr32_f64_mul>
8000d34a:	40 1c       	lddsp	r12,sp[0x4]
8000d34c:	50 63       	stdsp	sp[0x18],r3
8000d34e:	30 25       	mov	r5,2
8000d350:	0c 93       	mov	r3,r6
8000d352:	fa eb 00 08 	st.d	sp[8],r10
8000d356:	18 96       	mov	r6,r12
8000d358:	c0 f8       	rjmp	8000d376 <_dtoa_r+0x40a>
8000d35a:	fa ea 00 08 	ld.d	r10,sp[8]
8000d35e:	ed b4 00 00 	bld	r4,0x0
8000d362:	c0 81       	brne	8000d372 <_dtoa_r+0x406>
8000d364:	ec e8 00 00 	ld.d	r8,r6[0]
8000d368:	2f f5       	sub	r5,-1
8000d36a:	e0 a0 0c 67 	rcall	8000ec38 <__avr32_f64_mul>
8000d36e:	fa eb 00 08 	st.d	sp[8],r10
8000d372:	a1 54       	asr	r4,0x1
8000d374:	2f 86       	sub	r6,-8
8000d376:	58 04       	cp.w	r4,0
8000d378:	cf 11       	brne	8000d35a <_dtoa_r+0x3ee>
8000d37a:	06 96       	mov	r6,r3
8000d37c:	40 63       	lddsp	r3,sp[0x18]
8000d37e:	41 4a       	lddsp	r10,sp[0x50]
8000d380:	58 0a       	cp.w	r10,0
8000d382:	c2 f0       	breq	8000d3e0 <_dtoa_r+0x474>
8000d384:	fa e8 00 08 	ld.d	r8,sp[8]
8000d388:	58 01       	cp.w	r1,0
8000d38a:	5f 94       	srgt	r4
8000d38c:	fa e9 00 18 	st.d	sp[24],r8
8000d390:	30 08       	mov	r8,0
8000d392:	fc 19 3f f0 	movh	r9,0x3ff0
8000d396:	fa ea 00 18 	ld.d	r10,sp[24]
8000d39a:	e0 a0 0f 61 	rcall	8000f25c <__avr32_f64_cmp_lt>
8000d39e:	f9 bc 00 00 	moveq	r12,0
8000d3a2:	f9 bc 01 01 	movne	r12,1
8000d3a6:	e9 ec 00 0c 	and	r12,r4,r12
8000d3aa:	c1 b0       	breq	8000d3e0 <_dtoa_r+0x474>
8000d3ac:	40 98       	lddsp	r8,sp[0x24]
8000d3ae:	58 08       	cp.w	r8,0
8000d3b0:	e0 8a 00 f6 	brle	8000d59c <_dtoa_r+0x630>
8000d3b4:	30 08       	mov	r8,0
8000d3b6:	fc 19 40 24 	movh	r9,0x4024
8000d3ba:	ec c4 00 01 	sub	r4,r6,1
8000d3be:	fa ea 00 18 	ld.d	r10,sp[24]
8000d3c2:	2f f5       	sub	r5,-1
8000d3c4:	50 64       	stdsp	sp[0x18],r4
8000d3c6:	e0 a0 0c 39 	rcall	8000ec38 <__avr32_f64_mul>
8000d3ca:	40 94       	lddsp	r4,sp[0x24]
8000d3cc:	14 98       	mov	r8,r10
8000d3ce:	16 99       	mov	r9,r11
8000d3d0:	fa e9 00 08 	st.d	sp[8],r8
8000d3d4:	c0 88       	rjmp	8000d3e4 <_dtoa_r+0x478>
8000d3d6:	d7 03       	nop
8000d3d8:	80 01       	ld.sh	r1,r0[0x0]
8000d3da:	93 80       	st.w	r9[0x20],r0
8000d3dc:	80 01       	ld.sh	r1,r0[0x0]
8000d3de:	94 48       	ld.sh	r8,r10[0x8]
8000d3e0:	50 66       	stdsp	sp[0x18],r6
8000d3e2:	02 94       	mov	r4,r1
8000d3e4:	0a 9c       	mov	r12,r5
8000d3e6:	e0 a0 0e 84 	rcall	8000f0ee <__avr32_s32_to_f64>
8000d3ea:	fa e8 00 08 	ld.d	r8,sp[8]
8000d3ee:	e0 a0 0c 25 	rcall	8000ec38 <__avr32_f64_mul>
8000d3f2:	30 08       	mov	r8,0
8000d3f4:	fc 19 40 1c 	movh	r9,0x401c
8000d3f8:	e0 a0 0d da 	rcall	8000efac <__avr32_f64_add>
8000d3fc:	14 98       	mov	r8,r10
8000d3fe:	16 99       	mov	r9,r11
8000d400:	fa e9 00 28 	st.d	sp[40],r8
8000d404:	fc 18 fc c0 	movh	r8,0xfcc0
8000d408:	40 a5       	lddsp	r5,sp[0x28]
8000d40a:	10 05       	add	r5,r8
8000d40c:	50 a5       	stdsp	sp[0x28],r5
8000d40e:	58 04       	cp.w	r4,0
8000d410:	c2 11       	brne	8000d452 <_dtoa_r+0x4e6>
8000d412:	fa ea 00 08 	ld.d	r10,sp[8]
8000d416:	30 08       	mov	r8,0
8000d418:	fc 19 40 14 	movh	r9,0x4014
8000d41c:	e0 a0 0c fa 	rcall	8000ee10 <__avr32_f64_sub>
8000d420:	40 bc       	lddsp	r12,sp[0x2c]
8000d422:	fa eb 00 08 	st.d	sp[8],r10
8000d426:	14 98       	mov	r8,r10
8000d428:	16 99       	mov	r9,r11
8000d42a:	18 9a       	mov	r10,r12
8000d42c:	0a 9b       	mov	r11,r5
8000d42e:	e0 a0 0f 17 	rcall	8000f25c <__avr32_f64_cmp_lt>
8000d432:	e0 81 02 54 	brne	8000d8da <_dtoa_r+0x96e>
8000d436:	0a 98       	mov	r8,r5
8000d438:	40 b9       	lddsp	r9,sp[0x2c]
8000d43a:	ee 18 80 00 	eorh	r8,0x8000
8000d43e:	fa ea 00 08 	ld.d	r10,sp[8]
8000d442:	10 95       	mov	r5,r8
8000d444:	12 98       	mov	r8,r9
8000d446:	0a 99       	mov	r9,r5
8000d448:	e0 a0 0f 0a 	rcall	8000f25c <__avr32_f64_cmp_lt>
8000d44c:	e0 81 02 3e 	brne	8000d8c8 <_dtoa_r+0x95c>
8000d450:	ca 68       	rjmp	8000d59c <_dtoa_r+0x630>
8000d452:	4c e9       	lddpc	r9,8000d588 <_dtoa_r+0x61c>
8000d454:	e8 c8 00 01 	sub	r8,r4,1
8000d458:	40 d5       	lddsp	r5,sp[0x34]
8000d45a:	58 05       	cp.w	r5,0
8000d45c:	c4 f0       	breq	8000d4fa <_dtoa_r+0x58e>
8000d45e:	30 0c       	mov	r12,0
8000d460:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000d464:	51 3c       	stdsp	sp[0x4c],r12
8000d466:	30 0a       	mov	r10,0
8000d468:	fc 1b 3f e0 	movh	r11,0x3fe0
8000d46c:	e0 a0 0f 2c 	rcall	8000f2c4 <__avr32_f64_div>
8000d470:	fa e8 00 28 	ld.d	r8,sp[40]
8000d474:	40 85       	lddsp	r5,sp[0x20]
8000d476:	e0 a0 0c cd 	rcall	8000ee10 <__avr32_f64_sub>
8000d47a:	fa eb 00 28 	st.d	sp[40],r10
8000d47e:	fa ea 00 08 	ld.d	r10,sp[8]
8000d482:	e0 a0 0e 1f 	rcall	8000f0c0 <__avr32_f64_to_s32>
8000d486:	51 6c       	stdsp	sp[0x58],r12
8000d488:	e0 a0 0e 33 	rcall	8000f0ee <__avr32_s32_to_f64>
8000d48c:	14 98       	mov	r8,r10
8000d48e:	16 99       	mov	r9,r11
8000d490:	fa ea 00 08 	ld.d	r10,sp[8]
8000d494:	e0 a0 0c be 	rcall	8000ee10 <__avr32_f64_sub>
8000d498:	fa eb 00 08 	st.d	sp[8],r10
8000d49c:	41 68       	lddsp	r8,sp[0x58]
8000d49e:	2d 08       	sub	r8,-48
8000d4a0:	0a c8       	st.b	r5++,r8
8000d4a2:	41 39       	lddsp	r9,sp[0x4c]
8000d4a4:	2f f9       	sub	r9,-1
8000d4a6:	51 39       	stdsp	sp[0x4c],r9
8000d4a8:	fa e8 00 28 	ld.d	r8,sp[40]
8000d4ac:	e0 a0 0e d8 	rcall	8000f25c <__avr32_f64_cmp_lt>
8000d4b0:	e0 81 03 3a 	brne	8000db24 <_dtoa_r+0xbb8>
8000d4b4:	fa e8 00 08 	ld.d	r8,sp[8]
8000d4b8:	30 0a       	mov	r10,0
8000d4ba:	fc 1b 3f f0 	movh	r11,0x3ff0
8000d4be:	e0 a0 0c a9 	rcall	8000ee10 <__avr32_f64_sub>
8000d4c2:	fa e8 00 28 	ld.d	r8,sp[40]
8000d4c6:	e0 a0 0e cb 	rcall	8000f25c <__avr32_f64_cmp_lt>
8000d4ca:	fa ea 00 28 	ld.d	r10,sp[40]
8000d4ce:	30 08       	mov	r8,0
8000d4d0:	fc 19 40 24 	movh	r9,0x4024
8000d4d4:	e0 81 00 da 	brne	8000d688 <_dtoa_r+0x71c>
8000d4d8:	41 3c       	lddsp	r12,sp[0x4c]
8000d4da:	08 3c       	cp.w	r12,r4
8000d4dc:	c6 04       	brge	8000d59c <_dtoa_r+0x630>
8000d4de:	e0 a0 0b ad 	rcall	8000ec38 <__avr32_f64_mul>
8000d4e2:	30 08       	mov	r8,0
8000d4e4:	fa eb 00 28 	st.d	sp[40],r10
8000d4e8:	fc 19 40 24 	movh	r9,0x4024
8000d4ec:	fa ea 00 08 	ld.d	r10,sp[8]
8000d4f0:	e0 a0 0b a4 	rcall	8000ec38 <__avr32_f64_mul>
8000d4f4:	fa eb 00 08 	st.d	sp[8],r10
8000d4f8:	cc 3b       	rjmp	8000d47e <_dtoa_r+0x512>
8000d4fa:	40 85       	lddsp	r5,sp[0x20]
8000d4fc:	08 05       	add	r5,r4
8000d4fe:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000d502:	51 35       	stdsp	sp[0x4c],r5
8000d504:	fa e8 00 28 	ld.d	r8,sp[40]
8000d508:	40 85       	lddsp	r5,sp[0x20]
8000d50a:	e0 a0 0b 97 	rcall	8000ec38 <__avr32_f64_mul>
8000d50e:	fa eb 00 28 	st.d	sp[40],r10
8000d512:	fa ea 00 08 	ld.d	r10,sp[8]
8000d516:	e0 a0 0d d5 	rcall	8000f0c0 <__avr32_f64_to_s32>
8000d51a:	51 6c       	stdsp	sp[0x58],r12
8000d51c:	e0 a0 0d e9 	rcall	8000f0ee <__avr32_s32_to_f64>
8000d520:	14 98       	mov	r8,r10
8000d522:	16 99       	mov	r9,r11
8000d524:	fa ea 00 08 	ld.d	r10,sp[8]
8000d528:	e0 a0 0c 74 	rcall	8000ee10 <__avr32_f64_sub>
8000d52c:	fa eb 00 08 	st.d	sp[8],r10
8000d530:	41 68       	lddsp	r8,sp[0x58]
8000d532:	2d 08       	sub	r8,-48
8000d534:	0a c8       	st.b	r5++,r8
8000d536:	41 3c       	lddsp	r12,sp[0x4c]
8000d538:	18 35       	cp.w	r5,r12
8000d53a:	c2 91       	brne	8000d58c <_dtoa_r+0x620>
8000d53c:	30 08       	mov	r8,0
8000d53e:	fc 19 3f e0 	movh	r9,0x3fe0
8000d542:	fa ea 00 28 	ld.d	r10,sp[40]
8000d546:	e0 a0 0d 33 	rcall	8000efac <__avr32_f64_add>
8000d54a:	40 85       	lddsp	r5,sp[0x20]
8000d54c:	fa e8 00 08 	ld.d	r8,sp[8]
8000d550:	08 05       	add	r5,r4
8000d552:	e0 a0 0e 85 	rcall	8000f25c <__avr32_f64_cmp_lt>
8000d556:	e0 81 00 99 	brne	8000d688 <_dtoa_r+0x71c>
8000d55a:	fa e8 00 28 	ld.d	r8,sp[40]
8000d55e:	30 0a       	mov	r10,0
8000d560:	fc 1b 3f e0 	movh	r11,0x3fe0
8000d564:	e0 a0 0c 56 	rcall	8000ee10 <__avr32_f64_sub>
8000d568:	14 98       	mov	r8,r10
8000d56a:	16 99       	mov	r9,r11
8000d56c:	fa ea 00 08 	ld.d	r10,sp[8]
8000d570:	e0 a0 0e 76 	rcall	8000f25c <__avr32_f64_cmp_lt>
8000d574:	c1 40       	breq	8000d59c <_dtoa_r+0x630>
8000d576:	33 09       	mov	r9,48
8000d578:	0a 98       	mov	r8,r5
8000d57a:	11 7a       	ld.ub	r10,--r8
8000d57c:	f2 0a 18 00 	cp.b	r10,r9
8000d580:	e0 81 02 d2 	brne	8000db24 <_dtoa_r+0xbb8>
8000d584:	10 95       	mov	r5,r8
8000d586:	cf 9b       	rjmp	8000d578 <_dtoa_r+0x60c>
8000d588:	80 01       	ld.sh	r1,r0[0x0]
8000d58a:	93 80       	st.w	r9[0x20],r0
8000d58c:	30 08       	mov	r8,0
8000d58e:	fc 19 40 24 	movh	r9,0x4024
8000d592:	e0 a0 0b 53 	rcall	8000ec38 <__avr32_f64_mul>
8000d596:	fa eb 00 08 	st.d	sp[8],r10
8000d59a:	cb cb       	rjmp	8000d512 <_dtoa_r+0x5a6>
8000d59c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d5a0:	fa eb 00 08 	st.d	sp[8],r10
8000d5a4:	58 e6       	cp.w	r6,14
8000d5a6:	5f ab       	srle	r11
8000d5a8:	41 8a       	lddsp	r10,sp[0x60]
8000d5aa:	30 08       	mov	r8,0
8000d5ac:	f4 09 11 ff 	rsub	r9,r10,-1
8000d5b0:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000d5b4:	f0 09 18 00 	cp.b	r9,r8
8000d5b8:	e0 80 00 81 	breq	8000d6ba <_dtoa_r+0x74e>
8000d5bc:	40 ea       	lddsp	r10,sp[0x38]
8000d5be:	58 01       	cp.w	r1,0
8000d5c0:	5f a9       	srle	r9
8000d5c2:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000d5c6:	4c 9a       	lddpc	r10,8000d6e8 <_dtoa_r+0x77c>
8000d5c8:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000d5cc:	fa e5 00 10 	st.d	sp[16],r4
8000d5d0:	f0 09 18 00 	cp.b	r9,r8
8000d5d4:	c1 40       	breq	8000d5fc <_dtoa_r+0x690>
8000d5d6:	58 01       	cp.w	r1,0
8000d5d8:	e0 81 01 78 	brne	8000d8c8 <_dtoa_r+0x95c>
8000d5dc:	30 08       	mov	r8,0
8000d5de:	fc 19 40 14 	movh	r9,0x4014
8000d5e2:	08 9a       	mov	r10,r4
8000d5e4:	0a 9b       	mov	r11,r5
8000d5e6:	e0 a0 0b 29 	rcall	8000ec38 <__avr32_f64_mul>
8000d5ea:	fa e8 00 08 	ld.d	r8,sp[8]
8000d5ee:	e0 a0 0e 03 	rcall	8000f1f4 <__avr32_f64_cmp_ge>
8000d5f2:	e0 81 01 6b 	brne	8000d8c8 <_dtoa_r+0x95c>
8000d5f6:	02 92       	mov	r2,r1
8000d5f8:	e0 8f 01 73 	bral	8000d8de <_dtoa_r+0x972>
8000d5fc:	40 85       	lddsp	r5,sp[0x20]
8000d5fe:	30 14       	mov	r4,1
8000d600:	fa e8 00 10 	ld.d	r8,sp[16]
8000d604:	fa ea 00 08 	ld.d	r10,sp[8]
8000d608:	e0 a0 0e 5e 	rcall	8000f2c4 <__avr32_f64_div>
8000d60c:	e0 a0 0d 5a 	rcall	8000f0c0 <__avr32_f64_to_s32>
8000d610:	18 92       	mov	r2,r12
8000d612:	e0 a0 0d 6e 	rcall	8000f0ee <__avr32_s32_to_f64>
8000d616:	fa e8 00 10 	ld.d	r8,sp[16]
8000d61a:	e0 a0 0b 0f 	rcall	8000ec38 <__avr32_f64_mul>
8000d61e:	14 98       	mov	r8,r10
8000d620:	16 99       	mov	r9,r11
8000d622:	fa ea 00 08 	ld.d	r10,sp[8]
8000d626:	e0 a0 0b f5 	rcall	8000ee10 <__avr32_f64_sub>
8000d62a:	fa eb 00 08 	st.d	sp[8],r10
8000d62e:	e4 c8 ff d0 	sub	r8,r2,-48
8000d632:	0a c8       	st.b	r5++,r8
8000d634:	fc 19 40 24 	movh	r9,0x4024
8000d638:	30 08       	mov	r8,0
8000d63a:	02 34       	cp.w	r4,r1
8000d63c:	c3 31       	brne	8000d6a2 <_dtoa_r+0x736>
8000d63e:	fa e8 00 08 	ld.d	r8,sp[8]
8000d642:	e0 a0 0c b5 	rcall	8000efac <__avr32_f64_add>
8000d646:	16 91       	mov	r1,r11
8000d648:	14 90       	mov	r0,r10
8000d64a:	14 98       	mov	r8,r10
8000d64c:	02 99       	mov	r9,r1
8000d64e:	fa ea 00 10 	ld.d	r10,sp[16]
8000d652:	e0 a0 0e 05 	rcall	8000f25c <__avr32_f64_cmp_lt>
8000d656:	c1 a1       	brne	8000d68a <_dtoa_r+0x71e>
8000d658:	fa e8 00 10 	ld.d	r8,sp[16]
8000d65c:	00 9a       	mov	r10,r0
8000d65e:	02 9b       	mov	r11,r1
8000d660:	e0 a0 0d b7 	rcall	8000f1ce <__avr32_f64_cmp_eq>
8000d664:	e0 80 02 5f 	breq	8000db22 <_dtoa_r+0xbb6>
8000d668:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000d66c:	c0 f1       	brne	8000d68a <_dtoa_r+0x71e>
8000d66e:	e0 8f 02 5a 	bral	8000db22 <_dtoa_r+0xbb6>
8000d672:	40 8a       	lddsp	r10,sp[0x20]
8000d674:	14 38       	cp.w	r8,r10
8000d676:	c0 30       	breq	8000d67c <_dtoa_r+0x710>
8000d678:	10 95       	mov	r5,r8
8000d67a:	c0 98       	rjmp	8000d68c <_dtoa_r+0x720>
8000d67c:	33 08       	mov	r8,48
8000d67e:	40 89       	lddsp	r9,sp[0x20]
8000d680:	2f f6       	sub	r6,-1
8000d682:	b2 88       	st.b	r9[0x0],r8
8000d684:	40 88       	lddsp	r8,sp[0x20]
8000d686:	c0 88       	rjmp	8000d696 <_dtoa_r+0x72a>
8000d688:	40 66       	lddsp	r6,sp[0x18]
8000d68a:	33 99       	mov	r9,57
8000d68c:	0a 98       	mov	r8,r5
8000d68e:	11 7a       	ld.ub	r10,--r8
8000d690:	f2 0a 18 00 	cp.b	r10,r9
8000d694:	ce f0       	breq	8000d672 <_dtoa_r+0x706>
8000d696:	50 66       	stdsp	sp[0x18],r6
8000d698:	11 89       	ld.ub	r9,r8[0x0]
8000d69a:	2f f9       	sub	r9,-1
8000d69c:	b0 89       	st.b	r8[0x0],r9
8000d69e:	e0 8f 02 43 	bral	8000db24 <_dtoa_r+0xbb8>
8000d6a2:	e0 a0 0a cb 	rcall	8000ec38 <__avr32_f64_mul>
8000d6a6:	2f f4       	sub	r4,-1
8000d6a8:	fa eb 00 08 	st.d	sp[8],r10
8000d6ac:	30 08       	mov	r8,0
8000d6ae:	30 09       	mov	r9,0
8000d6b0:	e0 a0 0d 8f 	rcall	8000f1ce <__avr32_f64_cmp_eq>
8000d6b4:	ca 60       	breq	8000d600 <_dtoa_r+0x694>
8000d6b6:	e0 8f 02 36 	bral	8000db22 <_dtoa_r+0xbb6>
8000d6ba:	40 d8       	lddsp	r8,sp[0x34]
8000d6bc:	58 08       	cp.w	r8,0
8000d6be:	c0 51       	brne	8000d6c8 <_dtoa_r+0x75c>
8000d6c0:	04 98       	mov	r8,r2
8000d6c2:	00 95       	mov	r5,r0
8000d6c4:	40 d4       	lddsp	r4,sp[0x34]
8000d6c6:	c3 88       	rjmp	8000d736 <_dtoa_r+0x7ca>
8000d6c8:	40 c5       	lddsp	r5,sp[0x30]
8000d6ca:	58 15       	cp.w	r5,1
8000d6cc:	e0 89 00 10 	brgt	8000d6ec <_dtoa_r+0x780>
8000d6d0:	41 74       	lddsp	r4,sp[0x5c]
8000d6d2:	58 04       	cp.w	r4,0
8000d6d4:	c0 40       	breq	8000d6dc <_dtoa_r+0x770>
8000d6d6:	f4 c9 fb cd 	sub	r9,r10,-1075
8000d6da:	c0 48       	rjmp	8000d6e2 <_dtoa_r+0x776>
8000d6dc:	41 99       	lddsp	r9,sp[0x64]
8000d6de:	f2 09 11 36 	rsub	r9,r9,54
8000d6e2:	04 98       	mov	r8,r2
8000d6e4:	00 95       	mov	r5,r0
8000d6e6:	c1 d8       	rjmp	8000d720 <_dtoa_r+0x7b4>
8000d6e8:	80 01       	ld.sh	r1,r0[0x0]
8000d6ea:	93 80       	st.w	r9[0x20],r0
8000d6ec:	e2 c8 00 01 	sub	r8,r1,1
8000d6f0:	58 01       	cp.w	r1,0
8000d6f2:	e0 05 17 40 	movge	r5,r0
8000d6f6:	e2 09 17 40 	movge	r9,r1
8000d6fa:	e1 d1 e5 15 	sublt	r5,r0,r1
8000d6fe:	f9 b9 05 00 	movlt	r9,0
8000d702:	10 32       	cp.w	r2,r8
8000d704:	e5 d8 e4 18 	subge	r8,r2,r8
8000d708:	f1 d2 e5 18 	sublt	r8,r8,r2
8000d70c:	e5 d8 e5 02 	addlt	r2,r2,r8
8000d710:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000d714:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000d718:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000d71c:	f9 b8 05 00 	movlt	r8,0
8000d720:	40 4b       	lddsp	r11,sp[0x10]
8000d722:	12 0b       	add	r11,r9
8000d724:	50 08       	stdsp	sp[0x0],r8
8000d726:	50 4b       	stdsp	sp[0x10],r11
8000d728:	12 00       	add	r0,r9
8000d72a:	30 1b       	mov	r11,1
8000d72c:	0e 9c       	mov	r12,r7
8000d72e:	e0 a0 08 ab 	rcall	8000e884 <__i2b>
8000d732:	40 08       	lddsp	r8,sp[0x0]
8000d734:	18 94       	mov	r4,r12
8000d736:	40 4a       	lddsp	r10,sp[0x10]
8000d738:	58 05       	cp.w	r5,0
8000d73a:	5f 99       	srgt	r9
8000d73c:	58 0a       	cp.w	r10,0
8000d73e:	5f 9a       	srgt	r10
8000d740:	f5 e9 00 09 	and	r9,r10,r9
8000d744:	c0 80       	breq	8000d754 <_dtoa_r+0x7e8>
8000d746:	40 4c       	lddsp	r12,sp[0x10]
8000d748:	f8 05 0d 49 	min	r9,r12,r5
8000d74c:	12 1c       	sub	r12,r9
8000d74e:	12 10       	sub	r0,r9
8000d750:	50 4c       	stdsp	sp[0x10],r12
8000d752:	12 15       	sub	r5,r9
8000d754:	58 02       	cp.w	r2,0
8000d756:	e0 8a 00 27 	brle	8000d7a4 <_dtoa_r+0x838>
8000d75a:	40 db       	lddsp	r11,sp[0x34]
8000d75c:	58 0b       	cp.w	r11,0
8000d75e:	c1 d0       	breq	8000d798 <_dtoa_r+0x82c>
8000d760:	58 08       	cp.w	r8,0
8000d762:	e0 8a 00 17 	brle	8000d790 <_dtoa_r+0x824>
8000d766:	10 9a       	mov	r10,r8
8000d768:	50 08       	stdsp	sp[0x0],r8
8000d76a:	08 9b       	mov	r11,r4
8000d76c:	0e 9c       	mov	r12,r7
8000d76e:	e0 a0 08 d1 	rcall	8000e910 <__pow5mult>
8000d772:	06 9a       	mov	r10,r3
8000d774:	18 9b       	mov	r11,r12
8000d776:	18 94       	mov	r4,r12
8000d778:	0e 9c       	mov	r12,r7
8000d77a:	e0 a0 08 05 	rcall	8000e784 <__multiply>
8000d77e:	18 99       	mov	r9,r12
8000d780:	06 9b       	mov	r11,r3
8000d782:	50 19       	stdsp	sp[0x4],r9
8000d784:	0e 9c       	mov	r12,r7
8000d786:	e0 a0 06 b1 	rcall	8000e4e8 <_Bfree>
8000d78a:	40 19       	lddsp	r9,sp[0x4]
8000d78c:	40 08       	lddsp	r8,sp[0x0]
8000d78e:	12 93       	mov	r3,r9
8000d790:	e4 08 01 0a 	sub	r10,r2,r8
8000d794:	c0 80       	breq	8000d7a4 <_dtoa_r+0x838>
8000d796:	c0 28       	rjmp	8000d79a <_dtoa_r+0x82e>
8000d798:	04 9a       	mov	r10,r2
8000d79a:	06 9b       	mov	r11,r3
8000d79c:	0e 9c       	mov	r12,r7
8000d79e:	e0 a0 08 b9 	rcall	8000e910 <__pow5mult>
8000d7a2:	18 93       	mov	r3,r12
8000d7a4:	30 1b       	mov	r11,1
8000d7a6:	0e 9c       	mov	r12,r7
8000d7a8:	e0 a0 08 6e 	rcall	8000e884 <__i2b>
8000d7ac:	41 1a       	lddsp	r10,sp[0x44]
8000d7ae:	18 92       	mov	r2,r12
8000d7b0:	58 0a       	cp.w	r10,0
8000d7b2:	e0 8a 00 07 	brle	8000d7c0 <_dtoa_r+0x854>
8000d7b6:	18 9b       	mov	r11,r12
8000d7b8:	0e 9c       	mov	r12,r7
8000d7ba:	e0 a0 08 ab 	rcall	8000e910 <__pow5mult>
8000d7be:	18 92       	mov	r2,r12
8000d7c0:	40 c9       	lddsp	r9,sp[0x30]
8000d7c2:	58 19       	cp.w	r9,1
8000d7c4:	e0 89 00 14 	brgt	8000d7ec <_dtoa_r+0x880>
8000d7c8:	40 38       	lddsp	r8,sp[0xc]
8000d7ca:	58 08       	cp.w	r8,0
8000d7cc:	c1 01       	brne	8000d7ec <_dtoa_r+0x880>
8000d7ce:	40 29       	lddsp	r9,sp[0x8]
8000d7d0:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000d7d4:	c0 c1       	brne	8000d7ec <_dtoa_r+0x880>
8000d7d6:	12 98       	mov	r8,r9
8000d7d8:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000d7dc:	c0 80       	breq	8000d7ec <_dtoa_r+0x880>
8000d7de:	40 4c       	lddsp	r12,sp[0x10]
8000d7e0:	30 1b       	mov	r11,1
8000d7e2:	2f fc       	sub	r12,-1
8000d7e4:	2f f0       	sub	r0,-1
8000d7e6:	50 4c       	stdsp	sp[0x10],r12
8000d7e8:	50 6b       	stdsp	sp[0x18],r11
8000d7ea:	c0 38       	rjmp	8000d7f0 <_dtoa_r+0x884>
8000d7ec:	30 0a       	mov	r10,0
8000d7ee:	50 6a       	stdsp	sp[0x18],r10
8000d7f0:	41 19       	lddsp	r9,sp[0x44]
8000d7f2:	58 09       	cp.w	r9,0
8000d7f4:	c0 31       	brne	8000d7fa <_dtoa_r+0x88e>
8000d7f6:	30 1c       	mov	r12,1
8000d7f8:	c0 98       	rjmp	8000d80a <_dtoa_r+0x89e>
8000d7fa:	64 48       	ld.w	r8,r2[0x10]
8000d7fc:	2f c8       	sub	r8,-4
8000d7fe:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000d802:	e0 a0 05 e3 	rcall	8000e3c8 <__hi0bits>
8000d806:	f8 0c 11 20 	rsub	r12,r12,32
8000d80a:	40 4b       	lddsp	r11,sp[0x10]
8000d80c:	f8 0b 00 08 	add	r8,r12,r11
8000d810:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000d814:	c0 c0       	breq	8000d82c <_dtoa_r+0x8c0>
8000d816:	f0 08 11 20 	rsub	r8,r8,32
8000d81a:	58 48       	cp.w	r8,4
8000d81c:	e0 8a 00 06 	brle	8000d828 <_dtoa_r+0x8bc>
8000d820:	20 48       	sub	r8,4
8000d822:	10 0b       	add	r11,r8
8000d824:	50 4b       	stdsp	sp[0x10],r11
8000d826:	c0 78       	rjmp	8000d834 <_dtoa_r+0x8c8>
8000d828:	58 48       	cp.w	r8,4
8000d82a:	c0 70       	breq	8000d838 <_dtoa_r+0x8cc>
8000d82c:	40 4a       	lddsp	r10,sp[0x10]
8000d82e:	2e 48       	sub	r8,-28
8000d830:	10 0a       	add	r10,r8
8000d832:	50 4a       	stdsp	sp[0x10],r10
8000d834:	10 00       	add	r0,r8
8000d836:	10 05       	add	r5,r8
8000d838:	58 00       	cp.w	r0,0
8000d83a:	e0 8a 00 08 	brle	8000d84a <_dtoa_r+0x8de>
8000d83e:	06 9b       	mov	r11,r3
8000d840:	00 9a       	mov	r10,r0
8000d842:	0e 9c       	mov	r12,r7
8000d844:	e0 a0 07 5c 	rcall	8000e6fc <__lshift>
8000d848:	18 93       	mov	r3,r12
8000d84a:	40 49       	lddsp	r9,sp[0x10]
8000d84c:	58 09       	cp.w	r9,0
8000d84e:	e0 8a 00 08 	brle	8000d85e <_dtoa_r+0x8f2>
8000d852:	04 9b       	mov	r11,r2
8000d854:	12 9a       	mov	r10,r9
8000d856:	0e 9c       	mov	r12,r7
8000d858:	e0 a0 07 52 	rcall	8000e6fc <__lshift>
8000d85c:	18 92       	mov	r2,r12
8000d85e:	41 48       	lddsp	r8,sp[0x50]
8000d860:	58 08       	cp.w	r8,0
8000d862:	c1 b0       	breq	8000d898 <_dtoa_r+0x92c>
8000d864:	04 9b       	mov	r11,r2
8000d866:	06 9c       	mov	r12,r3
8000d868:	e0 a0 06 27 	rcall	8000e4b6 <__mcmp>
8000d86c:	c1 64       	brge	8000d898 <_dtoa_r+0x92c>
8000d86e:	06 9b       	mov	r11,r3
8000d870:	30 09       	mov	r9,0
8000d872:	30 aa       	mov	r10,10
8000d874:	0e 9c       	mov	r12,r7
8000d876:	e0 a0 08 0f 	rcall	8000e894 <__multadd>
8000d87a:	20 16       	sub	r6,1
8000d87c:	18 93       	mov	r3,r12
8000d87e:	40 dc       	lddsp	r12,sp[0x34]
8000d880:	58 0c       	cp.w	r12,0
8000d882:	c0 31       	brne	8000d888 <_dtoa_r+0x91c>
8000d884:	40 91       	lddsp	r1,sp[0x24]
8000d886:	c0 98       	rjmp	8000d898 <_dtoa_r+0x92c>
8000d888:	08 9b       	mov	r11,r4
8000d88a:	40 91       	lddsp	r1,sp[0x24]
8000d88c:	30 09       	mov	r9,0
8000d88e:	30 aa       	mov	r10,10
8000d890:	0e 9c       	mov	r12,r7
8000d892:	e0 a0 08 01 	rcall	8000e894 <__multadd>
8000d896:	18 94       	mov	r4,r12
8000d898:	58 01       	cp.w	r1,0
8000d89a:	5f a9       	srle	r9
8000d89c:	40 cb       	lddsp	r11,sp[0x30]
8000d89e:	58 2b       	cp.w	r11,2
8000d8a0:	5f 98       	srgt	r8
8000d8a2:	f3 e8 00 08 	and	r8,r9,r8
8000d8a6:	c2 50       	breq	8000d8f0 <_dtoa_r+0x984>
8000d8a8:	58 01       	cp.w	r1,0
8000d8aa:	c1 11       	brne	8000d8cc <_dtoa_r+0x960>
8000d8ac:	04 9b       	mov	r11,r2
8000d8ae:	02 99       	mov	r9,r1
8000d8b0:	30 5a       	mov	r10,5
8000d8b2:	0e 9c       	mov	r12,r7
8000d8b4:	e0 a0 07 f0 	rcall	8000e894 <__multadd>
8000d8b8:	18 92       	mov	r2,r12
8000d8ba:	18 9b       	mov	r11,r12
8000d8bc:	06 9c       	mov	r12,r3
8000d8be:	e0 a0 05 fc 	rcall	8000e4b6 <__mcmp>
8000d8c2:	e0 89 00 0f 	brgt	8000d8e0 <_dtoa_r+0x974>
8000d8c6:	c0 38       	rjmp	8000d8cc <_dtoa_r+0x960>
8000d8c8:	30 02       	mov	r2,0
8000d8ca:	04 94       	mov	r4,r2
8000d8cc:	40 ea       	lddsp	r10,sp[0x38]
8000d8ce:	30 09       	mov	r9,0
8000d8d0:	5c da       	com	r10
8000d8d2:	40 85       	lddsp	r5,sp[0x20]
8000d8d4:	50 6a       	stdsp	sp[0x18],r10
8000d8d6:	50 49       	stdsp	sp[0x10],r9
8000d8d8:	c0 f9       	rjmp	8000daf6 <_dtoa_r+0xb8a>
8000d8da:	08 92       	mov	r2,r4
8000d8dc:	40 66       	lddsp	r6,sp[0x18]
8000d8de:	04 94       	mov	r4,r2
8000d8e0:	2f f6       	sub	r6,-1
8000d8e2:	50 66       	stdsp	sp[0x18],r6
8000d8e4:	33 18       	mov	r8,49
8000d8e6:	40 85       	lddsp	r5,sp[0x20]
8000d8e8:	0a c8       	st.b	r5++,r8
8000d8ea:	30 08       	mov	r8,0
8000d8ec:	50 48       	stdsp	sp[0x10],r8
8000d8ee:	c0 49       	rjmp	8000daf6 <_dtoa_r+0xb8a>
8000d8f0:	40 dc       	lddsp	r12,sp[0x34]
8000d8f2:	58 0c       	cp.w	r12,0
8000d8f4:	e0 80 00 b5 	breq	8000da5e <_dtoa_r+0xaf2>
8000d8f8:	58 05       	cp.w	r5,0
8000d8fa:	e0 8a 00 08 	brle	8000d90a <_dtoa_r+0x99e>
8000d8fe:	08 9b       	mov	r11,r4
8000d900:	0a 9a       	mov	r10,r5
8000d902:	0e 9c       	mov	r12,r7
8000d904:	e0 a0 06 fc 	rcall	8000e6fc <__lshift>
8000d908:	18 94       	mov	r4,r12
8000d90a:	40 6b       	lddsp	r11,sp[0x18]
8000d90c:	58 0b       	cp.w	r11,0
8000d90e:	c0 31       	brne	8000d914 <_dtoa_r+0x9a8>
8000d910:	08 9c       	mov	r12,r4
8000d912:	c1 38       	rjmp	8000d938 <_dtoa_r+0x9cc>
8000d914:	68 1b       	ld.w	r11,r4[0x4]
8000d916:	0e 9c       	mov	r12,r7
8000d918:	e0 a0 06 02 	rcall	8000e51c <_Balloc>
8000d91c:	68 4a       	ld.w	r10,r4[0x10]
8000d91e:	18 95       	mov	r5,r12
8000d920:	e8 cb ff f4 	sub	r11,r4,-12
8000d924:	2f ea       	sub	r10,-2
8000d926:	2f 4c       	sub	r12,-12
8000d928:	a3 6a       	lsl	r10,0x2
8000d92a:	fe b0 e5 ae 	rcall	8000a486 <memcpy>
8000d92e:	0a 9b       	mov	r11,r5
8000d930:	30 1a       	mov	r10,1
8000d932:	0e 9c       	mov	r12,r7
8000d934:	e0 a0 06 e4 	rcall	8000e6fc <__lshift>
8000d938:	50 44       	stdsp	sp[0x10],r4
8000d93a:	40 3a       	lddsp	r10,sp[0xc]
8000d93c:	30 19       	mov	r9,1
8000d93e:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000d942:	18 94       	mov	r4,r12
8000d944:	50 da       	stdsp	sp[0x34],r10
8000d946:	40 85       	lddsp	r5,sp[0x20]
8000d948:	50 99       	stdsp	sp[0x24],r9
8000d94a:	50 26       	stdsp	sp[0x8],r6
8000d94c:	50 e1       	stdsp	sp[0x38],r1
8000d94e:	04 9b       	mov	r11,r2
8000d950:	06 9c       	mov	r12,r3
8000d952:	fe b0 fa 7d 	rcall	8000ce4c <quorem>
8000d956:	40 4b       	lddsp	r11,sp[0x10]
8000d958:	f8 c0 ff d0 	sub	r0,r12,-48
8000d95c:	06 9c       	mov	r12,r3
8000d95e:	e0 a0 05 ac 	rcall	8000e4b6 <__mcmp>
8000d962:	08 9a       	mov	r10,r4
8000d964:	50 6c       	stdsp	sp[0x18],r12
8000d966:	04 9b       	mov	r11,r2
8000d968:	0e 9c       	mov	r12,r7
8000d96a:	e0 a0 06 61 	rcall	8000e62c <__mdiff>
8000d96e:	18 91       	mov	r1,r12
8000d970:	78 38       	ld.w	r8,r12[0xc]
8000d972:	58 08       	cp.w	r8,0
8000d974:	c0 30       	breq	8000d97a <_dtoa_r+0xa0e>
8000d976:	30 16       	mov	r6,1
8000d978:	c0 68       	rjmp	8000d984 <_dtoa_r+0xa18>
8000d97a:	18 9b       	mov	r11,r12
8000d97c:	06 9c       	mov	r12,r3
8000d97e:	e0 a0 05 9c 	rcall	8000e4b6 <__mcmp>
8000d982:	18 96       	mov	r6,r12
8000d984:	0e 9c       	mov	r12,r7
8000d986:	02 9b       	mov	r11,r1
8000d988:	e0 a0 05 b0 	rcall	8000e4e8 <_Bfree>
8000d98c:	40 cc       	lddsp	r12,sp[0x30]
8000d98e:	ed ec 10 08 	or	r8,r6,r12
8000d992:	c0 d1       	brne	8000d9ac <_dtoa_r+0xa40>
8000d994:	40 db       	lddsp	r11,sp[0x34]
8000d996:	58 0b       	cp.w	r11,0
8000d998:	c0 a1       	brne	8000d9ac <_dtoa_r+0xa40>
8000d99a:	40 26       	lddsp	r6,sp[0x8]
8000d99c:	e0 40 00 39 	cp.w	r0,57
8000d9a0:	c3 00       	breq	8000da00 <_dtoa_r+0xa94>
8000d9a2:	40 6a       	lddsp	r10,sp[0x18]
8000d9a4:	58 0a       	cp.w	r10,0
8000d9a6:	e0 89 00 24 	brgt	8000d9ee <_dtoa_r+0xa82>
8000d9aa:	c2 f8       	rjmp	8000da08 <_dtoa_r+0xa9c>
8000d9ac:	40 69       	lddsp	r9,sp[0x18]
8000d9ae:	58 09       	cp.w	r9,0
8000d9b0:	c0 85       	brlt	8000d9c0 <_dtoa_r+0xa54>
8000d9b2:	12 98       	mov	r8,r9
8000d9b4:	40 cc       	lddsp	r12,sp[0x30]
8000d9b6:	18 48       	or	r8,r12
8000d9b8:	c1 d1       	brne	8000d9f2 <_dtoa_r+0xa86>
8000d9ba:	40 db       	lddsp	r11,sp[0x34]
8000d9bc:	58 0b       	cp.w	r11,0
8000d9be:	c1 a1       	brne	8000d9f2 <_dtoa_r+0xa86>
8000d9c0:	0c 99       	mov	r9,r6
8000d9c2:	40 26       	lddsp	r6,sp[0x8]
8000d9c4:	58 09       	cp.w	r9,0
8000d9c6:	e0 8a 00 21 	brle	8000da08 <_dtoa_r+0xa9c>
8000d9ca:	06 9b       	mov	r11,r3
8000d9cc:	30 1a       	mov	r10,1
8000d9ce:	0e 9c       	mov	r12,r7
8000d9d0:	e0 a0 06 96 	rcall	8000e6fc <__lshift>
8000d9d4:	04 9b       	mov	r11,r2
8000d9d6:	18 93       	mov	r3,r12
8000d9d8:	e0 a0 05 6f 	rcall	8000e4b6 <__mcmp>
8000d9dc:	e0 89 00 06 	brgt	8000d9e8 <_dtoa_r+0xa7c>
8000d9e0:	c1 41       	brne	8000da08 <_dtoa_r+0xa9c>
8000d9e2:	ed b0 00 00 	bld	r0,0x0
8000d9e6:	c1 11       	brne	8000da08 <_dtoa_r+0xa9c>
8000d9e8:	e0 40 00 39 	cp.w	r0,57
8000d9ec:	c0 a0       	breq	8000da00 <_dtoa_r+0xa94>
8000d9ee:	2f f0       	sub	r0,-1
8000d9f0:	c0 c8       	rjmp	8000da08 <_dtoa_r+0xa9c>
8000d9f2:	58 06       	cp.w	r6,0
8000d9f4:	e0 8a 00 0c 	brle	8000da0c <_dtoa_r+0xaa0>
8000d9f8:	40 26       	lddsp	r6,sp[0x8]
8000d9fa:	e0 40 00 39 	cp.w	r0,57
8000d9fe:	c0 41       	brne	8000da06 <_dtoa_r+0xa9a>
8000da00:	33 98       	mov	r8,57
8000da02:	0a c8       	st.b	r5++,r8
8000da04:	c6 78       	rjmp	8000dad2 <_dtoa_r+0xb66>
8000da06:	2f f0       	sub	r0,-1
8000da08:	0a c0       	st.b	r5++,r0
8000da0a:	c7 58       	rjmp	8000daf4 <_dtoa_r+0xb88>
8000da0c:	0a c0       	st.b	r5++,r0
8000da0e:	40 9a       	lddsp	r10,sp[0x24]
8000da10:	40 e9       	lddsp	r9,sp[0x38]
8000da12:	12 3a       	cp.w	r10,r9
8000da14:	c4 30       	breq	8000da9a <_dtoa_r+0xb2e>
8000da16:	06 9b       	mov	r11,r3
8000da18:	30 09       	mov	r9,0
8000da1a:	30 aa       	mov	r10,10
8000da1c:	0e 9c       	mov	r12,r7
8000da1e:	e0 a0 07 3b 	rcall	8000e894 <__multadd>
8000da22:	40 48       	lddsp	r8,sp[0x10]
8000da24:	18 93       	mov	r3,r12
8000da26:	08 38       	cp.w	r8,r4
8000da28:	c0 91       	brne	8000da3a <_dtoa_r+0xace>
8000da2a:	10 9b       	mov	r11,r8
8000da2c:	30 09       	mov	r9,0
8000da2e:	30 aa       	mov	r10,10
8000da30:	0e 9c       	mov	r12,r7
8000da32:	e0 a0 07 31 	rcall	8000e894 <__multadd>
8000da36:	50 4c       	stdsp	sp[0x10],r12
8000da38:	c0 e8       	rjmp	8000da54 <_dtoa_r+0xae8>
8000da3a:	40 4b       	lddsp	r11,sp[0x10]
8000da3c:	30 09       	mov	r9,0
8000da3e:	30 aa       	mov	r10,10
8000da40:	0e 9c       	mov	r12,r7
8000da42:	e0 a0 07 29 	rcall	8000e894 <__multadd>
8000da46:	08 9b       	mov	r11,r4
8000da48:	50 4c       	stdsp	sp[0x10],r12
8000da4a:	30 09       	mov	r9,0
8000da4c:	30 aa       	mov	r10,10
8000da4e:	0e 9c       	mov	r12,r7
8000da50:	e0 a0 07 22 	rcall	8000e894 <__multadd>
8000da54:	18 94       	mov	r4,r12
8000da56:	40 9c       	lddsp	r12,sp[0x24]
8000da58:	2f fc       	sub	r12,-1
8000da5a:	50 9c       	stdsp	sp[0x24],r12
8000da5c:	c7 9b       	rjmp	8000d94e <_dtoa_r+0x9e2>
8000da5e:	30 18       	mov	r8,1
8000da60:	06 90       	mov	r0,r3
8000da62:	40 85       	lddsp	r5,sp[0x20]
8000da64:	08 93       	mov	r3,r4
8000da66:	0c 94       	mov	r4,r6
8000da68:	10 96       	mov	r6,r8
8000da6a:	04 9b       	mov	r11,r2
8000da6c:	00 9c       	mov	r12,r0
8000da6e:	fe b0 f9 ef 	rcall	8000ce4c <quorem>
8000da72:	2d 0c       	sub	r12,-48
8000da74:	0a cc       	st.b	r5++,r12
8000da76:	02 36       	cp.w	r6,r1
8000da78:	c0 a4       	brge	8000da8c <_dtoa_r+0xb20>
8000da7a:	00 9b       	mov	r11,r0
8000da7c:	30 09       	mov	r9,0
8000da7e:	30 aa       	mov	r10,10
8000da80:	0e 9c       	mov	r12,r7
8000da82:	2f f6       	sub	r6,-1
8000da84:	e0 a0 07 08 	rcall	8000e894 <__multadd>
8000da88:	18 90       	mov	r0,r12
8000da8a:	cf 0b       	rjmp	8000da6a <_dtoa_r+0xafe>
8000da8c:	08 96       	mov	r6,r4
8000da8e:	30 0b       	mov	r11,0
8000da90:	06 94       	mov	r4,r3
8000da92:	50 4b       	stdsp	sp[0x10],r11
8000da94:	00 93       	mov	r3,r0
8000da96:	18 90       	mov	r0,r12
8000da98:	c0 28       	rjmp	8000da9c <_dtoa_r+0xb30>
8000da9a:	40 26       	lddsp	r6,sp[0x8]
8000da9c:	06 9b       	mov	r11,r3
8000da9e:	30 1a       	mov	r10,1
8000daa0:	0e 9c       	mov	r12,r7
8000daa2:	e0 a0 06 2d 	rcall	8000e6fc <__lshift>
8000daa6:	04 9b       	mov	r11,r2
8000daa8:	18 93       	mov	r3,r12
8000daaa:	e0 a0 05 06 	rcall	8000e4b6 <__mcmp>
8000daae:	e0 89 00 12 	brgt	8000dad2 <_dtoa_r+0xb66>
8000dab2:	c1 b1       	brne	8000dae8 <_dtoa_r+0xb7c>
8000dab4:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000dab8:	c0 d1       	brne	8000dad2 <_dtoa_r+0xb66>
8000daba:	c1 78       	rjmp	8000dae8 <_dtoa_r+0xb7c>
8000dabc:	40 89       	lddsp	r9,sp[0x20]
8000dabe:	12 38       	cp.w	r8,r9
8000dac0:	c0 30       	breq	8000dac6 <_dtoa_r+0xb5a>
8000dac2:	10 95       	mov	r5,r8
8000dac4:	c0 88       	rjmp	8000dad4 <_dtoa_r+0xb68>
8000dac6:	2f f6       	sub	r6,-1
8000dac8:	50 66       	stdsp	sp[0x18],r6
8000daca:	33 18       	mov	r8,49
8000dacc:	40 8c       	lddsp	r12,sp[0x20]
8000dace:	b8 88       	st.b	r12[0x0],r8
8000dad0:	c1 38       	rjmp	8000daf6 <_dtoa_r+0xb8a>
8000dad2:	33 9a       	mov	r10,57
8000dad4:	0a 98       	mov	r8,r5
8000dad6:	11 79       	ld.ub	r9,--r8
8000dad8:	f4 09 18 00 	cp.b	r9,r10
8000dadc:	cf 00       	breq	8000dabc <_dtoa_r+0xb50>
8000dade:	2f f9       	sub	r9,-1
8000dae0:	b0 89       	st.b	r8[0x0],r9
8000dae2:	c0 98       	rjmp	8000daf4 <_dtoa_r+0xb88>
8000dae4:	10 95       	mov	r5,r8
8000dae6:	c0 28       	rjmp	8000daea <_dtoa_r+0xb7e>
8000dae8:	33 09       	mov	r9,48
8000daea:	0a 98       	mov	r8,r5
8000daec:	11 7a       	ld.ub	r10,--r8
8000daee:	f2 0a 18 00 	cp.b	r10,r9
8000daf2:	cf 90       	breq	8000dae4 <_dtoa_r+0xb78>
8000daf4:	50 66       	stdsp	sp[0x18],r6
8000daf6:	04 9b       	mov	r11,r2
8000daf8:	0e 9c       	mov	r12,r7
8000dafa:	e0 a0 04 f7 	rcall	8000e4e8 <_Bfree>
8000dafe:	58 04       	cp.w	r4,0
8000db00:	c1 20       	breq	8000db24 <_dtoa_r+0xbb8>
8000db02:	40 4b       	lddsp	r11,sp[0x10]
8000db04:	08 3b       	cp.w	r11,r4
8000db06:	5f 19       	srne	r9
8000db08:	58 0b       	cp.w	r11,0
8000db0a:	5f 18       	srne	r8
8000db0c:	f3 e8 00 08 	and	r8,r9,r8
8000db10:	c0 40       	breq	8000db18 <_dtoa_r+0xbac>
8000db12:	0e 9c       	mov	r12,r7
8000db14:	e0 a0 04 ea 	rcall	8000e4e8 <_Bfree>
8000db18:	08 9b       	mov	r11,r4
8000db1a:	0e 9c       	mov	r12,r7
8000db1c:	e0 a0 04 e6 	rcall	8000e4e8 <_Bfree>
8000db20:	c0 28       	rjmp	8000db24 <_dtoa_r+0xbb8>
8000db22:	50 66       	stdsp	sp[0x18],r6
8000db24:	0e 9c       	mov	r12,r7
8000db26:	06 9b       	mov	r11,r3
8000db28:	e0 a0 04 e0 	rcall	8000e4e8 <_Bfree>
8000db2c:	30 08       	mov	r8,0
8000db2e:	aa 88       	st.b	r5[0x0],r8
8000db30:	40 68       	lddsp	r8,sp[0x18]
8000db32:	41 5a       	lddsp	r10,sp[0x54]
8000db34:	2f f8       	sub	r8,-1
8000db36:	41 29       	lddsp	r9,sp[0x48]
8000db38:	95 08       	st.w	r10[0x0],r8
8000db3a:	40 8c       	lddsp	r12,sp[0x20]
8000db3c:	58 09       	cp.w	r9,0
8000db3e:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000db42:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000db46:	2e 6d       	sub	sp,-104
8000db48:	d8 32       	popm	r0-r7,pc
8000db4a:	d7 03       	nop

8000db4c <__errno>:
8000db4c:	e0 68 0a 38 	mov	r8,2616
8000db50:	70 0c       	ld.w	r12,r8[0x0]
8000db52:	2f 4c       	sub	r12,-12
8000db54:	5e fc       	retal	r12
8000db56:	d7 03       	nop

8000db58 <_fflush_r>:
8000db58:	d4 21       	pushm	r4-r7,lr
8000db5a:	16 97       	mov	r7,r11
8000db5c:	18 96       	mov	r6,r12
8000db5e:	76 48       	ld.w	r8,r11[0x10]
8000db60:	58 08       	cp.w	r8,0
8000db62:	c7 c0       	breq	8000dc5a <_fflush_r+0x102>
8000db64:	58 0c       	cp.w	r12,0
8000db66:	c0 50       	breq	8000db70 <_fflush_r+0x18>
8000db68:	78 68       	ld.w	r8,r12[0x18]
8000db6a:	58 08       	cp.w	r8,0
8000db6c:	c0 21       	brne	8000db70 <_fflush_r+0x18>
8000db6e:	cd 1c       	rcall	8000dd10 <__sinit>
8000db70:	4b b8       	lddpc	r8,8000dc5c <_fflush_r+0x104>
8000db72:	10 37       	cp.w	r7,r8
8000db74:	c0 31       	brne	8000db7a <_fflush_r+0x22>
8000db76:	6c 07       	ld.w	r7,r6[0x0]
8000db78:	c0 a8       	rjmp	8000db8c <_fflush_r+0x34>
8000db7a:	4b a8       	lddpc	r8,8000dc60 <_fflush_r+0x108>
8000db7c:	10 37       	cp.w	r7,r8
8000db7e:	c0 31       	brne	8000db84 <_fflush_r+0x2c>
8000db80:	6c 17       	ld.w	r7,r6[0x4]
8000db82:	c0 58       	rjmp	8000db8c <_fflush_r+0x34>
8000db84:	4b 88       	lddpc	r8,8000dc64 <_fflush_r+0x10c>
8000db86:	10 37       	cp.w	r7,r8
8000db88:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000db8c:	8e 6a       	ld.sh	r10,r7[0xc]
8000db8e:	14 98       	mov	r8,r10
8000db90:	ed ba 00 03 	bld	r10,0x3
8000db94:	c4 20       	breq	8000dc18 <_fflush_r+0xc0>
8000db96:	ab ba       	sbr	r10,0xb
8000db98:	ae 6a       	st.h	r7[0xc],r10
8000db9a:	6e 18       	ld.w	r8,r7[0x4]
8000db9c:	58 08       	cp.w	r8,0
8000db9e:	e0 89 00 06 	brgt	8000dbaa <_fflush_r+0x52>
8000dba2:	6f 08       	ld.w	r8,r7[0x40]
8000dba4:	58 08       	cp.w	r8,0
8000dba6:	e0 8a 00 5a 	brle	8000dc5a <_fflush_r+0x102>
8000dbaa:	6e b8       	ld.w	r8,r7[0x2c]
8000dbac:	58 08       	cp.w	r8,0
8000dbae:	c5 60       	breq	8000dc5a <_fflush_r+0x102>
8000dbb0:	e2 1a 10 00 	andl	r10,0x1000,COH
8000dbb4:	c0 30       	breq	8000dbba <_fflush_r+0x62>
8000dbb6:	6f 55       	ld.w	r5,r7[0x54]
8000dbb8:	c0 f8       	rjmp	8000dbd6 <_fflush_r+0x7e>
8000dbba:	30 19       	mov	r9,1
8000dbbc:	6e 8b       	ld.w	r11,r7[0x20]
8000dbbe:	0c 9c       	mov	r12,r6
8000dbc0:	5d 18       	icall	r8
8000dbc2:	18 95       	mov	r5,r12
8000dbc4:	5b fc       	cp.w	r12,-1
8000dbc6:	c0 81       	brne	8000dbd6 <_fflush_r+0x7e>
8000dbc8:	6c 38       	ld.w	r8,r6[0xc]
8000dbca:	59 d8       	cp.w	r8,29
8000dbcc:	c4 70       	breq	8000dc5a <_fflush_r+0x102>
8000dbce:	8e 68       	ld.sh	r8,r7[0xc]
8000dbd0:	a7 a8       	sbr	r8,0x6
8000dbd2:	ae 68       	st.h	r7[0xc],r8
8000dbd4:	d8 22       	popm	r4-r7,pc
8000dbd6:	8e 68       	ld.sh	r8,r7[0xc]
8000dbd8:	ed b8 00 02 	bld	r8,0x2
8000dbdc:	c0 91       	brne	8000dbee <_fflush_r+0x96>
8000dbde:	6e 18       	ld.w	r8,r7[0x4]
8000dbe0:	10 15       	sub	r5,r8
8000dbe2:	6e d8       	ld.w	r8,r7[0x34]
8000dbe4:	58 08       	cp.w	r8,0
8000dbe6:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000dbea:	eb d8 e1 15 	subne	r5,r5,r8
8000dbee:	6e b8       	ld.w	r8,r7[0x2c]
8000dbf0:	0c 9c       	mov	r12,r6
8000dbf2:	30 09       	mov	r9,0
8000dbf4:	0a 9a       	mov	r10,r5
8000dbf6:	6e 8b       	ld.w	r11,r7[0x20]
8000dbf8:	5d 18       	icall	r8
8000dbfa:	8e 68       	ld.sh	r8,r7[0xc]
8000dbfc:	0a 3c       	cp.w	r12,r5
8000dbfe:	c2 61       	brne	8000dc4a <_fflush_r+0xf2>
8000dc00:	ab d8       	cbr	r8,0xb
8000dc02:	30 0c       	mov	r12,0
8000dc04:	6e 49       	ld.w	r9,r7[0x10]
8000dc06:	ae 68       	st.h	r7[0xc],r8
8000dc08:	8f 1c       	st.w	r7[0x4],r12
8000dc0a:	8f 09       	st.w	r7[0x0],r9
8000dc0c:	ed b8 00 0c 	bld	r8,0xc
8000dc10:	c2 51       	brne	8000dc5a <_fflush_r+0x102>
8000dc12:	ef 45 00 54 	st.w	r7[84],r5
8000dc16:	d8 22       	popm	r4-r7,pc
8000dc18:	6e 45       	ld.w	r5,r7[0x10]
8000dc1a:	58 05       	cp.w	r5,0
8000dc1c:	c1 f0       	breq	8000dc5a <_fflush_r+0x102>
8000dc1e:	6e 04       	ld.w	r4,r7[0x0]
8000dc20:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000dc24:	8f 05       	st.w	r7[0x0],r5
8000dc26:	f9 b8 01 00 	movne	r8,0
8000dc2a:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000dc2e:	0a 14       	sub	r4,r5
8000dc30:	8f 28       	st.w	r7[0x8],r8
8000dc32:	c1 18       	rjmp	8000dc54 <_fflush_r+0xfc>
8000dc34:	08 99       	mov	r9,r4
8000dc36:	0a 9a       	mov	r10,r5
8000dc38:	6e a8       	ld.w	r8,r7[0x28]
8000dc3a:	6e 8b       	ld.w	r11,r7[0x20]
8000dc3c:	0c 9c       	mov	r12,r6
8000dc3e:	5d 18       	icall	r8
8000dc40:	18 14       	sub	r4,r12
8000dc42:	58 0c       	cp.w	r12,0
8000dc44:	e0 89 00 07 	brgt	8000dc52 <_fflush_r+0xfa>
8000dc48:	8e 68       	ld.sh	r8,r7[0xc]
8000dc4a:	a7 a8       	sbr	r8,0x6
8000dc4c:	3f fc       	mov	r12,-1
8000dc4e:	ae 68       	st.h	r7[0xc],r8
8000dc50:	d8 22       	popm	r4-r7,pc
8000dc52:	18 05       	add	r5,r12
8000dc54:	58 04       	cp.w	r4,0
8000dc56:	fe 99 ff ef 	brgt	8000dc34 <_fflush_r+0xdc>
8000dc5a:	d8 2a       	popm	r4-r7,pc,r12=0
8000dc5c:	80 01       	ld.sh	r1,r0[0x0]
8000dc5e:	92 d0       	ld.uh	r0,r9[0xa]
8000dc60:	80 01       	ld.sh	r1,r0[0x0]
8000dc62:	92 f0       	ld.uh	r0,r9[0xe]
8000dc64:	80 01       	ld.sh	r1,r0[0x0]
8000dc66:	93 10       	st.w	r9[0x4],r0

8000dc68 <__sfp_lock_acquire>:
8000dc68:	5e fc       	retal	r12

8000dc6a <__sfp_lock_release>:
8000dc6a:	5e fc       	retal	r12

8000dc6c <_cleanup_r>:
8000dc6c:	d4 01       	pushm	lr
8000dc6e:	fe cb f0 ba 	sub	r11,pc,-3910
8000dc72:	e0 a0 02 f9 	rcall	8000e264 <_fwalk>
8000dc76:	d8 02       	popm	pc

8000dc78 <__sfmoreglue>:
8000dc78:	d4 21       	pushm	r4-r7,lr
8000dc7a:	16 95       	mov	r5,r11
8000dc7c:	f6 06 10 5c 	mul	r6,r11,92
8000dc80:	ec cb ff f4 	sub	r11,r6,-12
8000dc84:	fe b0 e1 d2 	rcall	8000a028 <_malloc_r>
8000dc88:	18 97       	mov	r7,r12
8000dc8a:	c0 90       	breq	8000dc9c <__sfmoreglue+0x24>
8000dc8c:	99 15       	st.w	r12[0x4],r5
8000dc8e:	30 0b       	mov	r11,0
8000dc90:	2f 4c       	sub	r12,-12
8000dc92:	0c 9a       	mov	r10,r6
8000dc94:	8f 2c       	st.w	r7[0x8],r12
8000dc96:	8f 0b       	st.w	r7[0x0],r11
8000dc98:	fe b0 e4 9b 	rcall	8000a5ce <memset>
8000dc9c:	0e 9c       	mov	r12,r7
8000dc9e:	d8 22       	popm	r4-r7,pc

8000dca0 <__sfp>:
8000dca0:	d4 21       	pushm	r4-r7,lr
8000dca2:	49 b8       	lddpc	r8,8000dd0c <__sfp+0x6c>
8000dca4:	18 96       	mov	r6,r12
8000dca6:	70 07       	ld.w	r7,r8[0x0]
8000dca8:	6e 68       	ld.w	r8,r7[0x18]
8000dcaa:	58 08       	cp.w	r8,0
8000dcac:	c0 31       	brne	8000dcb2 <__sfp+0x12>
8000dcae:	0e 9c       	mov	r12,r7
8000dcb0:	c3 0c       	rcall	8000dd10 <__sinit>
8000dcb2:	ee c7 ff 28 	sub	r7,r7,-216
8000dcb6:	30 05       	mov	r5,0
8000dcb8:	6e 2c       	ld.w	r12,r7[0x8]
8000dcba:	6e 18       	ld.w	r8,r7[0x4]
8000dcbc:	c0 68       	rjmp	8000dcc8 <__sfp+0x28>
8000dcbe:	98 69       	ld.sh	r9,r12[0xc]
8000dcc0:	ea 09 19 00 	cp.h	r9,r5
8000dcc4:	c1 10       	breq	8000dce6 <__sfp+0x46>
8000dcc6:	2a 4c       	sub	r12,-92
8000dcc8:	20 18       	sub	r8,1
8000dcca:	cf a7       	brpl	8000dcbe <__sfp+0x1e>
8000dccc:	6e 08       	ld.w	r8,r7[0x0]
8000dcce:	58 08       	cp.w	r8,0
8000dcd0:	c0 61       	brne	8000dcdc <__sfp+0x3c>
8000dcd2:	30 4b       	mov	r11,4
8000dcd4:	0c 9c       	mov	r12,r6
8000dcd6:	cd 1f       	rcall	8000dc78 <__sfmoreglue>
8000dcd8:	8f 0c       	st.w	r7[0x0],r12
8000dcda:	c0 30       	breq	8000dce0 <__sfp+0x40>
8000dcdc:	6e 07       	ld.w	r7,r7[0x0]
8000dcde:	ce db       	rjmp	8000dcb8 <__sfp+0x18>
8000dce0:	30 c8       	mov	r8,12
8000dce2:	8d 38       	st.w	r6[0xc],r8
8000dce4:	d8 22       	popm	r4-r7,pc
8000dce6:	30 08       	mov	r8,0
8000dce8:	f9 48 00 4c 	st.w	r12[76],r8
8000dcec:	99 08       	st.w	r12[0x0],r8
8000dcee:	99 28       	st.w	r12[0x8],r8
8000dcf0:	99 18       	st.w	r12[0x4],r8
8000dcf2:	99 48       	st.w	r12[0x10],r8
8000dcf4:	99 58       	st.w	r12[0x14],r8
8000dcf6:	99 68       	st.w	r12[0x18],r8
8000dcf8:	99 d8       	st.w	r12[0x34],r8
8000dcfa:	99 e8       	st.w	r12[0x38],r8
8000dcfc:	f9 48 00 48 	st.w	r12[72],r8
8000dd00:	3f f8       	mov	r8,-1
8000dd02:	b8 78       	st.h	r12[0xe],r8
8000dd04:	30 18       	mov	r8,1
8000dd06:	b8 68       	st.h	r12[0xc],r8
8000dd08:	d8 22       	popm	r4-r7,pc
8000dd0a:	d7 03       	nop
8000dd0c:	80 01       	ld.sh	r1,r0[0x0]
8000dd0e:	93 34       	st.w	r9[0xc],r4

8000dd10 <__sinit>:
8000dd10:	d4 21       	pushm	r4-r7,lr
8000dd12:	18 96       	mov	r6,r12
8000dd14:	78 67       	ld.w	r7,r12[0x18]
8000dd16:	58 07       	cp.w	r7,0
8000dd18:	c4 91       	brne	8000ddaa <__sinit+0x9a>
8000dd1a:	fe c8 00 ae 	sub	r8,pc,174
8000dd1e:	30 15       	mov	r5,1
8000dd20:	99 a8       	st.w	r12[0x28],r8
8000dd22:	f9 47 00 d8 	st.w	r12[216],r7
8000dd26:	f9 47 00 dc 	st.w	r12[220],r7
8000dd2a:	f9 47 00 e0 	st.w	r12[224],r7
8000dd2e:	99 65       	st.w	r12[0x18],r5
8000dd30:	cb 8f       	rcall	8000dca0 <__sfp>
8000dd32:	8d 0c       	st.w	r6[0x0],r12
8000dd34:	0c 9c       	mov	r12,r6
8000dd36:	cb 5f       	rcall	8000dca0 <__sfp>
8000dd38:	8d 1c       	st.w	r6[0x4],r12
8000dd3a:	0c 9c       	mov	r12,r6
8000dd3c:	cb 2f       	rcall	8000dca0 <__sfp>
8000dd3e:	6c 09       	ld.w	r9,r6[0x0]
8000dd40:	30 48       	mov	r8,4
8000dd42:	93 07       	st.w	r9[0x0],r7
8000dd44:	b2 68       	st.h	r9[0xc],r8
8000dd46:	93 17       	st.w	r9[0x4],r7
8000dd48:	93 27       	st.w	r9[0x8],r7
8000dd4a:	6c 18       	ld.w	r8,r6[0x4]
8000dd4c:	b2 77       	st.h	r9[0xe],r7
8000dd4e:	93 47       	st.w	r9[0x10],r7
8000dd50:	93 57       	st.w	r9[0x14],r7
8000dd52:	93 67       	st.w	r9[0x18],r7
8000dd54:	93 89       	st.w	r9[0x20],r9
8000dd56:	91 07       	st.w	r8[0x0],r7
8000dd58:	91 17       	st.w	r8[0x4],r7
8000dd5a:	91 27       	st.w	r8[0x8],r7
8000dd5c:	fe ce f3 20 	sub	lr,pc,-3296
8000dd60:	fe cb f3 50 	sub	r11,pc,-3248
8000dd64:	93 9e       	st.w	r9[0x24],lr
8000dd66:	93 ab       	st.w	r9[0x28],r11
8000dd68:	fe ca f3 78 	sub	r10,pc,-3208
8000dd6c:	fe c4 f3 84 	sub	r4,pc,-3196
8000dd70:	93 ba       	st.w	r9[0x2c],r10
8000dd72:	93 c4       	st.w	r9[0x30],r4
8000dd74:	30 99       	mov	r9,9
8000dd76:	b0 69       	st.h	r8[0xc],r9
8000dd78:	b0 75       	st.h	r8[0xe],r5
8000dd7a:	91 c4       	st.w	r8[0x30],r4
8000dd7c:	91 47       	st.w	r8[0x10],r7
8000dd7e:	91 57       	st.w	r8[0x14],r7
8000dd80:	91 67       	st.w	r8[0x18],r7
8000dd82:	91 88       	st.w	r8[0x20],r8
8000dd84:	91 9e       	st.w	r8[0x24],lr
8000dd86:	91 ab       	st.w	r8[0x28],r11
8000dd88:	91 ba       	st.w	r8[0x2c],r10
8000dd8a:	8d 2c       	st.w	r6[0x8],r12
8000dd8c:	31 28       	mov	r8,18
8000dd8e:	99 07       	st.w	r12[0x0],r7
8000dd90:	b8 68       	st.h	r12[0xc],r8
8000dd92:	99 17       	st.w	r12[0x4],r7
8000dd94:	99 27       	st.w	r12[0x8],r7
8000dd96:	30 28       	mov	r8,2
8000dd98:	b8 78       	st.h	r12[0xe],r8
8000dd9a:	99 c4       	st.w	r12[0x30],r4
8000dd9c:	99 67       	st.w	r12[0x18],r7
8000dd9e:	99 9e       	st.w	r12[0x24],lr
8000dda0:	99 ab       	st.w	r12[0x28],r11
8000dda2:	99 ba       	st.w	r12[0x2c],r10
8000dda4:	99 47       	st.w	r12[0x10],r7
8000dda6:	99 57       	st.w	r12[0x14],r7
8000dda8:	99 8c       	st.w	r12[0x20],r12
8000ddaa:	d8 22       	popm	r4-r7,pc

8000ddac <_malloc_trim_r>:
8000ddac:	d4 21       	pushm	r4-r7,lr
8000ddae:	16 95       	mov	r5,r11
8000ddb0:	18 97       	mov	r7,r12
8000ddb2:	fe b0 d6 87 	rcall	80008ac0 <__malloc_lock>
8000ddb6:	e0 64 05 38 	mov	r4,1336
8000ddba:	68 28       	ld.w	r8,r4[0x8]
8000ddbc:	70 16       	ld.w	r6,r8[0x4]
8000ddbe:	e0 16 ff fc 	andl	r6,0xfffc
8000ddc2:	ec c8 ff 91 	sub	r8,r6,-111
8000ddc6:	f0 05 01 05 	sub	r5,r8,r5
8000ddca:	e0 15 ff 80 	andl	r5,0xff80
8000ddce:	ea c5 00 80 	sub	r5,r5,128
8000ddd2:	e0 45 00 7f 	cp.w	r5,127
8000ddd6:	e0 8a 00 25 	brle	8000de20 <_malloc_trim_r+0x74>
8000ddda:	30 0b       	mov	r11,0
8000dddc:	0e 9c       	mov	r12,r7
8000ddde:	fe b0 e5 5f 	rcall	8000a89c <_sbrk_r>
8000dde2:	68 28       	ld.w	r8,r4[0x8]
8000dde4:	0c 08       	add	r8,r6
8000dde6:	10 3c       	cp.w	r12,r8
8000dde8:	c1 c1       	brne	8000de20 <_malloc_trim_r+0x74>
8000ddea:	ea 0b 11 00 	rsub	r11,r5,0
8000ddee:	0e 9c       	mov	r12,r7
8000ddf0:	fe b0 e5 56 	rcall	8000a89c <_sbrk_r>
8000ddf4:	5b fc       	cp.w	r12,-1
8000ddf6:	c1 91       	brne	8000de28 <_malloc_trim_r+0x7c>
8000ddf8:	30 0b       	mov	r11,0
8000ddfa:	0e 9c       	mov	r12,r7
8000ddfc:	fe b0 e5 50 	rcall	8000a89c <_sbrk_r>
8000de00:	68 28       	ld.w	r8,r4[0x8]
8000de02:	f8 08 01 09 	sub	r9,r12,r8
8000de06:	58 f9       	cp.w	r9,15
8000de08:	e0 8a 00 0c 	brle	8000de20 <_malloc_trim_r+0x74>
8000de0c:	a1 a9       	sbr	r9,0x0
8000de0e:	91 19       	st.w	r8[0x4],r9
8000de10:	e0 68 09 44 	mov	r8,2372
8000de14:	70 09       	ld.w	r9,r8[0x0]
8000de16:	e0 68 12 a0 	mov	r8,4768
8000de1a:	f8 09 01 09 	sub	r9,r12,r9
8000de1e:	91 09       	st.w	r8[0x0],r9
8000de20:	0e 9c       	mov	r12,r7
8000de22:	fe b0 d6 55 	rcall	80008acc <__malloc_unlock>
8000de26:	d8 2a       	popm	r4-r7,pc,r12=0
8000de28:	68 28       	ld.w	r8,r4[0x8]
8000de2a:	0a 16       	sub	r6,r5
8000de2c:	a1 a6       	sbr	r6,0x0
8000de2e:	91 16       	st.w	r8[0x4],r6
8000de30:	e0 68 12 a0 	mov	r8,4768
8000de34:	70 09       	ld.w	r9,r8[0x0]
8000de36:	0a 19       	sub	r9,r5
8000de38:	0e 9c       	mov	r12,r7
8000de3a:	91 09       	st.w	r8[0x0],r9
8000de3c:	fe b0 d6 48 	rcall	80008acc <__malloc_unlock>
8000de40:	da 2a       	popm	r4-r7,pc,r12=1
8000de42:	d7 03       	nop

8000de44 <_free_r>:
8000de44:	d4 21       	pushm	r4-r7,lr
8000de46:	16 96       	mov	r6,r11
8000de48:	18 97       	mov	r7,r12
8000de4a:	58 0b       	cp.w	r11,0
8000de4c:	e0 80 00 c0 	breq	8000dfcc <_free_r+0x188>
8000de50:	fe b0 d6 38 	rcall	80008ac0 <__malloc_lock>
8000de54:	20 86       	sub	r6,8
8000de56:	e0 6a 05 38 	mov	r10,1336
8000de5a:	6c 18       	ld.w	r8,r6[0x4]
8000de5c:	74 2e       	ld.w	lr,r10[0x8]
8000de5e:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000de62:	a1 c8       	cbr	r8,0x0
8000de64:	ec 08 00 09 	add	r9,r6,r8
8000de68:	72 1b       	ld.w	r11,r9[0x4]
8000de6a:	e0 1b ff fc 	andl	r11,0xfffc
8000de6e:	1c 39       	cp.w	r9,lr
8000de70:	c1 e1       	brne	8000deac <_free_r+0x68>
8000de72:	f6 08 00 08 	add	r8,r11,r8
8000de76:	58 0c       	cp.w	r12,0
8000de78:	c0 81       	brne	8000de88 <_free_r+0x44>
8000de7a:	6c 09       	ld.w	r9,r6[0x0]
8000de7c:	12 16       	sub	r6,r9
8000de7e:	12 08       	add	r8,r9
8000de80:	6c 3b       	ld.w	r11,r6[0xc]
8000de82:	6c 29       	ld.w	r9,r6[0x8]
8000de84:	97 29       	st.w	r11[0x8],r9
8000de86:	93 3b       	st.w	r9[0xc],r11
8000de88:	10 99       	mov	r9,r8
8000de8a:	95 26       	st.w	r10[0x8],r6
8000de8c:	a1 a9       	sbr	r9,0x0
8000de8e:	8d 19       	st.w	r6[0x4],r9
8000de90:	e0 69 09 40 	mov	r9,2368
8000de94:	72 09       	ld.w	r9,r9[0x0]
8000de96:	12 38       	cp.w	r8,r9
8000de98:	c0 63       	brcs	8000dea4 <_free_r+0x60>
8000de9a:	e0 68 12 9c 	mov	r8,4764
8000de9e:	0e 9c       	mov	r12,r7
8000dea0:	70 0b       	ld.w	r11,r8[0x0]
8000dea2:	c8 5f       	rcall	8000ddac <_malloc_trim_r>
8000dea4:	0e 9c       	mov	r12,r7
8000dea6:	fe b0 d6 13 	rcall	80008acc <__malloc_unlock>
8000deaa:	d8 22       	popm	r4-r7,pc
8000deac:	93 1b       	st.w	r9[0x4],r11
8000deae:	58 0c       	cp.w	r12,0
8000deb0:	c0 30       	breq	8000deb6 <_free_r+0x72>
8000deb2:	30 0c       	mov	r12,0
8000deb4:	c1 08       	rjmp	8000ded4 <_free_r+0x90>
8000deb6:	6c 0e       	ld.w	lr,r6[0x0]
8000deb8:	f4 c5 ff f8 	sub	r5,r10,-8
8000debc:	1c 16       	sub	r6,lr
8000debe:	1c 08       	add	r8,lr
8000dec0:	6c 2e       	ld.w	lr,r6[0x8]
8000dec2:	0a 3e       	cp.w	lr,r5
8000dec4:	f9 bc 00 01 	moveq	r12,1
8000dec8:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000decc:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000ded0:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000ded4:	f2 0b 00 0e 	add	lr,r9,r11
8000ded8:	7c 1e       	ld.w	lr,lr[0x4]
8000deda:	ed be 00 00 	bld	lr,0x0
8000dede:	c1 40       	breq	8000df06 <_free_r+0xc2>
8000dee0:	16 08       	add	r8,r11
8000dee2:	58 0c       	cp.w	r12,0
8000dee4:	c0 d1       	brne	8000defe <_free_r+0xba>
8000dee6:	e0 6e 05 38 	mov	lr,1336
8000deea:	72 2b       	ld.w	r11,r9[0x8]
8000deec:	2f 8e       	sub	lr,-8
8000deee:	1c 3b       	cp.w	r11,lr
8000def0:	c0 71       	brne	8000defe <_free_r+0xba>
8000def2:	97 36       	st.w	r11[0xc],r6
8000def4:	97 26       	st.w	r11[0x8],r6
8000def6:	8d 2b       	st.w	r6[0x8],r11
8000def8:	8d 3b       	st.w	r6[0xc],r11
8000defa:	30 1c       	mov	r12,1
8000defc:	c0 58       	rjmp	8000df06 <_free_r+0xc2>
8000defe:	72 2b       	ld.w	r11,r9[0x8]
8000df00:	72 39       	ld.w	r9,r9[0xc]
8000df02:	93 2b       	st.w	r9[0x8],r11
8000df04:	97 39       	st.w	r11[0xc],r9
8000df06:	10 99       	mov	r9,r8
8000df08:	ec 08 09 08 	st.w	r6[r8],r8
8000df0c:	a1 a9       	sbr	r9,0x0
8000df0e:	8d 19       	st.w	r6[0x4],r9
8000df10:	58 0c       	cp.w	r12,0
8000df12:	c5 a1       	brne	8000dfc6 <_free_r+0x182>
8000df14:	e0 48 01 ff 	cp.w	r8,511
8000df18:	e0 8b 00 13 	brhi	8000df3e <_free_r+0xfa>
8000df1c:	a3 98       	lsr	r8,0x3
8000df1e:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000df22:	72 2b       	ld.w	r11,r9[0x8]
8000df24:	8d 39       	st.w	r6[0xc],r9
8000df26:	8d 2b       	st.w	r6[0x8],r11
8000df28:	97 36       	st.w	r11[0xc],r6
8000df2a:	93 26       	st.w	r9[0x8],r6
8000df2c:	a3 48       	asr	r8,0x2
8000df2e:	74 19       	ld.w	r9,r10[0x4]
8000df30:	30 1b       	mov	r11,1
8000df32:	f6 08 09 48 	lsl	r8,r11,r8
8000df36:	f3 e8 10 08 	or	r8,r9,r8
8000df3a:	95 18       	st.w	r10[0x4],r8
8000df3c:	c4 58       	rjmp	8000dfc6 <_free_r+0x182>
8000df3e:	f0 0b 16 09 	lsr	r11,r8,0x9
8000df42:	58 4b       	cp.w	r11,4
8000df44:	e0 8b 00 06 	brhi	8000df50 <_free_r+0x10c>
8000df48:	f0 0b 16 06 	lsr	r11,r8,0x6
8000df4c:	2c 8b       	sub	r11,-56
8000df4e:	c2 08       	rjmp	8000df8e <_free_r+0x14a>
8000df50:	59 4b       	cp.w	r11,20
8000df52:	e0 8b 00 04 	brhi	8000df5a <_free_r+0x116>
8000df56:	2a 5b       	sub	r11,-91
8000df58:	c1 b8       	rjmp	8000df8e <_free_r+0x14a>
8000df5a:	e0 4b 00 54 	cp.w	r11,84
8000df5e:	e0 8b 00 06 	brhi	8000df6a <_free_r+0x126>
8000df62:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000df66:	29 2b       	sub	r11,-110
8000df68:	c1 38       	rjmp	8000df8e <_free_r+0x14a>
8000df6a:	e0 4b 01 54 	cp.w	r11,340
8000df6e:	e0 8b 00 06 	brhi	8000df7a <_free_r+0x136>
8000df72:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000df76:	28 9b       	sub	r11,-119
8000df78:	c0 b8       	rjmp	8000df8e <_free_r+0x14a>
8000df7a:	e0 4b 05 54 	cp.w	r11,1364
8000df7e:	e0 88 00 05 	brls	8000df88 <_free_r+0x144>
8000df82:	37 eb       	mov	r11,126
8000df84:	c0 58       	rjmp	8000df8e <_free_r+0x14a>
8000df86:	d7 03       	nop
8000df88:	f0 0b 16 12 	lsr	r11,r8,0x12
8000df8c:	28 4b       	sub	r11,-124
8000df8e:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000df92:	78 29       	ld.w	r9,r12[0x8]
8000df94:	18 39       	cp.w	r9,r12
8000df96:	c0 e1       	brne	8000dfb2 <_free_r+0x16e>
8000df98:	74 18       	ld.w	r8,r10[0x4]
8000df9a:	a3 4b       	asr	r11,0x2
8000df9c:	30 1c       	mov	r12,1
8000df9e:	f8 0b 09 4b 	lsl	r11,r12,r11
8000dfa2:	f1 eb 10 0b 	or	r11,r8,r11
8000dfa6:	12 98       	mov	r8,r9
8000dfa8:	95 1b       	st.w	r10[0x4],r11
8000dfaa:	c0 a8       	rjmp	8000dfbe <_free_r+0x17a>
8000dfac:	72 29       	ld.w	r9,r9[0x8]
8000dfae:	18 39       	cp.w	r9,r12
8000dfb0:	c0 60       	breq	8000dfbc <_free_r+0x178>
8000dfb2:	72 1a       	ld.w	r10,r9[0x4]
8000dfb4:	e0 1a ff fc 	andl	r10,0xfffc
8000dfb8:	14 38       	cp.w	r8,r10
8000dfba:	cf 93       	brcs	8000dfac <_free_r+0x168>
8000dfbc:	72 38       	ld.w	r8,r9[0xc]
8000dfbe:	8d 38       	st.w	r6[0xc],r8
8000dfc0:	8d 29       	st.w	r6[0x8],r9
8000dfc2:	93 36       	st.w	r9[0xc],r6
8000dfc4:	91 26       	st.w	r8[0x8],r6
8000dfc6:	0e 9c       	mov	r12,r7
8000dfc8:	fe b0 d5 82 	rcall	80008acc <__malloc_unlock>
8000dfcc:	d8 22       	popm	r4-r7,pc
8000dfce:	d7 03       	nop

8000dfd0 <__sfvwrite_r>:
8000dfd0:	d4 31       	pushm	r0-r7,lr
8000dfd2:	20 3d       	sub	sp,12
8000dfd4:	14 94       	mov	r4,r10
8000dfd6:	18 95       	mov	r5,r12
8000dfd8:	16 97       	mov	r7,r11
8000dfda:	74 28       	ld.w	r8,r10[0x8]
8000dfdc:	58 08       	cp.w	r8,0
8000dfde:	e0 80 01 40 	breq	8000e25e <__sfvwrite_r+0x28e>
8000dfe2:	96 68       	ld.sh	r8,r11[0xc]
8000dfe4:	ed b8 00 03 	bld	r8,0x3
8000dfe8:	c0 41       	brne	8000dff0 <__sfvwrite_r+0x20>
8000dfea:	76 48       	ld.w	r8,r11[0x10]
8000dfec:	58 08       	cp.w	r8,0
8000dfee:	c0 c1       	brne	8000e006 <__sfvwrite_r+0x36>
8000dff0:	0e 9b       	mov	r11,r7
8000dff2:	0a 9c       	mov	r12,r5
8000dff4:	fe b0 f6 bc 	rcall	8000cd6c <__swsetup_r>
8000dff8:	c0 70       	breq	8000e006 <__sfvwrite_r+0x36>
8000dffa:	8e 68       	ld.sh	r8,r7[0xc]
8000dffc:	a7 a8       	sbr	r8,0x6
8000dffe:	ae 68       	st.h	r7[0xc],r8
8000e000:	30 98       	mov	r8,9
8000e002:	8b 38       	st.w	r5[0xc],r8
8000e004:	c2 b9       	rjmp	8000e25a <__sfvwrite_r+0x28a>
8000e006:	8e 63       	ld.sh	r3,r7[0xc]
8000e008:	68 00       	ld.w	r0,r4[0x0]
8000e00a:	06 96       	mov	r6,r3
8000e00c:	e2 16 00 02 	andl	r6,0x2,COH
8000e010:	c2 10       	breq	8000e052 <__sfvwrite_r+0x82>
8000e012:	30 03       	mov	r3,0
8000e014:	e0 62 04 00 	mov	r2,1024
8000e018:	06 96       	mov	r6,r3
8000e01a:	c0 48       	rjmp	8000e022 <__sfvwrite_r+0x52>
8000e01c:	60 03       	ld.w	r3,r0[0x0]
8000e01e:	60 16       	ld.w	r6,r0[0x4]
8000e020:	2f 80       	sub	r0,-8
8000e022:	58 06       	cp.w	r6,0
8000e024:	cf c0       	breq	8000e01c <__sfvwrite_r+0x4c>
8000e026:	e0 46 04 00 	cp.w	r6,1024
8000e02a:	ec 09 17 80 	movls	r9,r6
8000e02e:	e4 09 17 b0 	movhi	r9,r2
8000e032:	06 9a       	mov	r10,r3
8000e034:	6e a8       	ld.w	r8,r7[0x28]
8000e036:	6e 8b       	ld.w	r11,r7[0x20]
8000e038:	0a 9c       	mov	r12,r5
8000e03a:	5d 18       	icall	r8
8000e03c:	18 16       	sub	r6,r12
8000e03e:	58 0c       	cp.w	r12,0
8000e040:	e0 8a 01 0a 	brle	8000e254 <__sfvwrite_r+0x284>
8000e044:	68 28       	ld.w	r8,r4[0x8]
8000e046:	18 18       	sub	r8,r12
8000e048:	89 28       	st.w	r4[0x8],r8
8000e04a:	e0 80 01 0a 	breq	8000e25e <__sfvwrite_r+0x28e>
8000e04e:	18 03       	add	r3,r12
8000e050:	ce 9b       	rjmp	8000e022 <__sfvwrite_r+0x52>
8000e052:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000e056:	c0 70       	breq	8000e064 <__sfvwrite_r+0x94>
8000e058:	50 06       	stdsp	sp[0x0],r6
8000e05a:	0c 93       	mov	r3,r6
8000e05c:	0c 91       	mov	r1,r6
8000e05e:	50 15       	stdsp	sp[0x4],r5
8000e060:	08 92       	mov	r2,r4
8000e062:	c9 c8       	rjmp	8000e19a <__sfvwrite_r+0x1ca>
8000e064:	06 96       	mov	r6,r3
8000e066:	08 91       	mov	r1,r4
8000e068:	c0 48       	rjmp	8000e070 <__sfvwrite_r+0xa0>
8000e06a:	60 03       	ld.w	r3,r0[0x0]
8000e06c:	60 16       	ld.w	r6,r0[0x4]
8000e06e:	2f 80       	sub	r0,-8
8000e070:	58 06       	cp.w	r6,0
8000e072:	cf c0       	breq	8000e06a <__sfvwrite_r+0x9a>
8000e074:	8e 68       	ld.sh	r8,r7[0xc]
8000e076:	6e 24       	ld.w	r4,r7[0x8]
8000e078:	10 99       	mov	r9,r8
8000e07a:	e2 19 02 00 	andl	r9,0x200,COH
8000e07e:	c5 50       	breq	8000e128 <__sfvwrite_r+0x158>
8000e080:	08 36       	cp.w	r6,r4
8000e082:	c4 43       	brcs	8000e10a <__sfvwrite_r+0x13a>
8000e084:	10 99       	mov	r9,r8
8000e086:	e2 19 04 80 	andl	r9,0x480,COH
8000e08a:	c4 00       	breq	8000e10a <__sfvwrite_r+0x13a>
8000e08c:	6e 4b       	ld.w	r11,r7[0x10]
8000e08e:	6e 09       	ld.w	r9,r7[0x0]
8000e090:	16 19       	sub	r9,r11
8000e092:	50 09       	stdsp	sp[0x0],r9
8000e094:	6e 59       	ld.w	r9,r7[0x14]
8000e096:	10 9c       	mov	r12,r8
8000e098:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000e09c:	30 28       	mov	r8,2
8000e09e:	f4 08 0c 08 	divs	r8,r10,r8
8000e0a2:	fa e9 00 04 	st.d	sp[4],r8
8000e0a6:	10 94       	mov	r4,r8
8000e0a8:	40 09       	lddsp	r9,sp[0x0]
8000e0aa:	e2 1c 04 00 	andl	r12,0x400,COH
8000e0ae:	2f f9       	sub	r9,-1
8000e0b0:	0c 09       	add	r9,r6
8000e0b2:	12 38       	cp.w	r8,r9
8000e0b4:	f2 04 17 30 	movlo	r4,r9
8000e0b8:	58 0c       	cp.w	r12,0
8000e0ba:	c1 10       	breq	8000e0dc <__sfvwrite_r+0x10c>
8000e0bc:	08 9b       	mov	r11,r4
8000e0be:	0a 9c       	mov	r12,r5
8000e0c0:	fe b0 df b4 	rcall	8000a028 <_malloc_r>
8000e0c4:	18 92       	mov	r2,r12
8000e0c6:	c1 40       	breq	8000e0ee <__sfvwrite_r+0x11e>
8000e0c8:	40 0a       	lddsp	r10,sp[0x0]
8000e0ca:	6e 4b       	ld.w	r11,r7[0x10]
8000e0cc:	fe b0 e1 dd 	rcall	8000a486 <memcpy>
8000e0d0:	8e 68       	ld.sh	r8,r7[0xc]
8000e0d2:	e0 18 fb 7f 	andl	r8,0xfb7f
8000e0d6:	a7 b8       	sbr	r8,0x7
8000e0d8:	ae 68       	st.h	r7[0xc],r8
8000e0da:	c0 d8       	rjmp	8000e0f4 <__sfvwrite_r+0x124>
8000e0dc:	08 9a       	mov	r10,r4
8000e0de:	0a 9c       	mov	r12,r5
8000e0e0:	fe b0 e2 7e 	rcall	8000a5dc <_realloc_r>
8000e0e4:	18 92       	mov	r2,r12
8000e0e6:	c0 71       	brne	8000e0f4 <__sfvwrite_r+0x124>
8000e0e8:	6e 4b       	ld.w	r11,r7[0x10]
8000e0ea:	0a 9c       	mov	r12,r5
8000e0ec:	ca ce       	rcall	8000de44 <_free_r>
8000e0ee:	30 c8       	mov	r8,12
8000e0f0:	8b 38       	st.w	r5[0xc],r8
8000e0f2:	cb 18       	rjmp	8000e254 <__sfvwrite_r+0x284>
8000e0f4:	40 0a       	lddsp	r10,sp[0x0]
8000e0f6:	40 09       	lddsp	r9,sp[0x0]
8000e0f8:	e8 0a 01 0a 	sub	r10,r4,r10
8000e0fc:	e4 09 00 08 	add	r8,r2,r9
8000e100:	8f 54       	st.w	r7[0x14],r4
8000e102:	8f 2a       	st.w	r7[0x8],r10
8000e104:	8f 08       	st.w	r7[0x0],r8
8000e106:	8f 42       	st.w	r7[0x10],r2
8000e108:	0c 94       	mov	r4,r6
8000e10a:	08 36       	cp.w	r6,r4
8000e10c:	ec 04 17 30 	movlo	r4,r6
8000e110:	06 9b       	mov	r11,r3
8000e112:	08 9a       	mov	r10,r4
8000e114:	6e 0c       	ld.w	r12,r7[0x0]
8000e116:	c3 ad       	rcall	8000e38a <memmove>
8000e118:	6e 08       	ld.w	r8,r7[0x0]
8000e11a:	08 08       	add	r8,r4
8000e11c:	8f 08       	st.w	r7[0x0],r8
8000e11e:	6e 28       	ld.w	r8,r7[0x8]
8000e120:	08 18       	sub	r8,r4
8000e122:	0c 94       	mov	r4,r6
8000e124:	8f 28       	st.w	r7[0x8],r8
8000e126:	c2 e8       	rjmp	8000e182 <__sfvwrite_r+0x1b2>
8000e128:	08 36       	cp.w	r6,r4
8000e12a:	5f ba       	srhi	r10
8000e12c:	6e 0c       	ld.w	r12,r7[0x0]
8000e12e:	6e 48       	ld.w	r8,r7[0x10]
8000e130:	10 3c       	cp.w	r12,r8
8000e132:	5f b8       	srhi	r8
8000e134:	f5 e8 00 08 	and	r8,r10,r8
8000e138:	f2 08 18 00 	cp.b	r8,r9
8000e13c:	c0 d0       	breq	8000e156 <__sfvwrite_r+0x186>
8000e13e:	06 9b       	mov	r11,r3
8000e140:	08 9a       	mov	r10,r4
8000e142:	c2 4d       	rcall	8000e38a <memmove>
8000e144:	6e 08       	ld.w	r8,r7[0x0]
8000e146:	08 08       	add	r8,r4
8000e148:	0e 9b       	mov	r11,r7
8000e14a:	8f 08       	st.w	r7[0x0],r8
8000e14c:	0a 9c       	mov	r12,r5
8000e14e:	fe b0 fd 05 	rcall	8000db58 <_fflush_r>
8000e152:	c1 80       	breq	8000e182 <__sfvwrite_r+0x1b2>
8000e154:	c8 08       	rjmp	8000e254 <__sfvwrite_r+0x284>
8000e156:	6e 59       	ld.w	r9,r7[0x14]
8000e158:	12 36       	cp.w	r6,r9
8000e15a:	c0 a3       	brcs	8000e16e <__sfvwrite_r+0x19e>
8000e15c:	6e a8       	ld.w	r8,r7[0x28]
8000e15e:	06 9a       	mov	r10,r3
8000e160:	6e 8b       	ld.w	r11,r7[0x20]
8000e162:	0a 9c       	mov	r12,r5
8000e164:	5d 18       	icall	r8
8000e166:	18 94       	mov	r4,r12
8000e168:	e0 89 00 0d 	brgt	8000e182 <__sfvwrite_r+0x1b2>
8000e16c:	c7 48       	rjmp	8000e254 <__sfvwrite_r+0x284>
8000e16e:	0c 9a       	mov	r10,r6
8000e170:	06 9b       	mov	r11,r3
8000e172:	c0 cd       	rcall	8000e38a <memmove>
8000e174:	6e 08       	ld.w	r8,r7[0x0]
8000e176:	0c 08       	add	r8,r6
8000e178:	0c 94       	mov	r4,r6
8000e17a:	8f 08       	st.w	r7[0x0],r8
8000e17c:	6e 28       	ld.w	r8,r7[0x8]
8000e17e:	0c 18       	sub	r8,r6
8000e180:	8f 28       	st.w	r7[0x8],r8
8000e182:	62 28       	ld.w	r8,r1[0x8]
8000e184:	08 18       	sub	r8,r4
8000e186:	83 28       	st.w	r1[0x8],r8
8000e188:	c6 b0       	breq	8000e25e <__sfvwrite_r+0x28e>
8000e18a:	08 16       	sub	r6,r4
8000e18c:	08 03       	add	r3,r4
8000e18e:	c7 1b       	rjmp	8000e070 <__sfvwrite_r+0xa0>
8000e190:	60 03       	ld.w	r3,r0[0x0]
8000e192:	60 11       	ld.w	r1,r0[0x4]
8000e194:	30 08       	mov	r8,0
8000e196:	2f 80       	sub	r0,-8
8000e198:	50 08       	stdsp	sp[0x0],r8
8000e19a:	58 01       	cp.w	r1,0
8000e19c:	cf a0       	breq	8000e190 <__sfvwrite_r+0x1c0>
8000e19e:	40 0a       	lddsp	r10,sp[0x0]
8000e1a0:	58 0a       	cp.w	r10,0
8000e1a2:	c1 41       	brne	8000e1ca <__sfvwrite_r+0x1fa>
8000e1a4:	e2 c6 ff ff 	sub	r6,r1,-1
8000e1a8:	02 9a       	mov	r10,r1
8000e1aa:	30 ab       	mov	r11,10
8000e1ac:	06 9c       	mov	r12,r3
8000e1ae:	ce 3c       	rcall	8000e374 <memchr>
8000e1b0:	f8 c8 ff ff 	sub	r8,r12,-1
8000e1b4:	58 0c       	cp.w	r12,0
8000e1b6:	f1 d3 e1 16 	subne	r6,r8,r3
8000e1ba:	f9 b9 01 01 	movne	r9,1
8000e1be:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000e1c2:	f9 b8 00 01 	moveq	r8,1
8000e1c6:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000e1ca:	02 36       	cp.w	r6,r1
8000e1cc:	ec 04 17 80 	movls	r4,r6
8000e1d0:	e2 04 17 b0 	movhi	r4,r1
8000e1d4:	6e 59       	ld.w	r9,r7[0x14]
8000e1d6:	6e 25       	ld.w	r5,r7[0x8]
8000e1d8:	f2 05 00 05 	add	r5,r9,r5
8000e1dc:	0a 34       	cp.w	r4,r5
8000e1de:	5f 9a       	srgt	r10
8000e1e0:	6e 0c       	ld.w	r12,r7[0x0]
8000e1e2:	6e 48       	ld.w	r8,r7[0x10]
8000e1e4:	10 3c       	cp.w	r12,r8
8000e1e6:	5f b8       	srhi	r8
8000e1e8:	f5 e8 00 08 	and	r8,r10,r8
8000e1ec:	30 0a       	mov	r10,0
8000e1ee:	f4 08 18 00 	cp.b	r8,r10
8000e1f2:	c0 d0       	breq	8000e20c <__sfvwrite_r+0x23c>
8000e1f4:	06 9b       	mov	r11,r3
8000e1f6:	0a 9a       	mov	r10,r5
8000e1f8:	cc 9c       	rcall	8000e38a <memmove>
8000e1fa:	6e 08       	ld.w	r8,r7[0x0]
8000e1fc:	0a 08       	add	r8,r5
8000e1fe:	0e 9b       	mov	r11,r7
8000e200:	8f 08       	st.w	r7[0x0],r8
8000e202:	40 1c       	lddsp	r12,sp[0x4]
8000e204:	fe b0 fc aa 	rcall	8000db58 <_fflush_r>
8000e208:	c1 70       	breq	8000e236 <__sfvwrite_r+0x266>
8000e20a:	c2 58       	rjmp	8000e254 <__sfvwrite_r+0x284>
8000e20c:	12 34       	cp.w	r4,r9
8000e20e:	c0 a5       	brlt	8000e222 <__sfvwrite_r+0x252>
8000e210:	6e a8       	ld.w	r8,r7[0x28]
8000e212:	06 9a       	mov	r10,r3
8000e214:	6e 8b       	ld.w	r11,r7[0x20]
8000e216:	40 1c       	lddsp	r12,sp[0x4]
8000e218:	5d 18       	icall	r8
8000e21a:	18 95       	mov	r5,r12
8000e21c:	e0 89 00 0d 	brgt	8000e236 <__sfvwrite_r+0x266>
8000e220:	c1 a8       	rjmp	8000e254 <__sfvwrite_r+0x284>
8000e222:	08 9a       	mov	r10,r4
8000e224:	06 9b       	mov	r11,r3
8000e226:	cb 2c       	rcall	8000e38a <memmove>
8000e228:	6e 08       	ld.w	r8,r7[0x0]
8000e22a:	08 08       	add	r8,r4
8000e22c:	08 95       	mov	r5,r4
8000e22e:	8f 08       	st.w	r7[0x0],r8
8000e230:	6e 28       	ld.w	r8,r7[0x8]
8000e232:	08 18       	sub	r8,r4
8000e234:	8f 28       	st.w	r7[0x8],r8
8000e236:	0a 16       	sub	r6,r5
8000e238:	c0 71       	brne	8000e246 <__sfvwrite_r+0x276>
8000e23a:	0e 9b       	mov	r11,r7
8000e23c:	40 1c       	lddsp	r12,sp[0x4]
8000e23e:	fe b0 fc 8d 	rcall	8000db58 <_fflush_r>
8000e242:	c0 91       	brne	8000e254 <__sfvwrite_r+0x284>
8000e244:	50 06       	stdsp	sp[0x0],r6
8000e246:	64 28       	ld.w	r8,r2[0x8]
8000e248:	0a 18       	sub	r8,r5
8000e24a:	85 28       	st.w	r2[0x8],r8
8000e24c:	c0 90       	breq	8000e25e <__sfvwrite_r+0x28e>
8000e24e:	0a 11       	sub	r1,r5
8000e250:	0a 03       	add	r3,r5
8000e252:	ca 4b       	rjmp	8000e19a <__sfvwrite_r+0x1ca>
8000e254:	8e 68       	ld.sh	r8,r7[0xc]
8000e256:	a7 a8       	sbr	r8,0x6
8000e258:	ae 68       	st.h	r7[0xc],r8
8000e25a:	3f fc       	mov	r12,-1
8000e25c:	c0 28       	rjmp	8000e260 <__sfvwrite_r+0x290>
8000e25e:	30 0c       	mov	r12,0
8000e260:	2f dd       	sub	sp,-12
8000e262:	d8 32       	popm	r0-r7,pc

8000e264 <_fwalk>:
8000e264:	d4 31       	pushm	r0-r7,lr
8000e266:	30 05       	mov	r5,0
8000e268:	16 91       	mov	r1,r11
8000e26a:	f8 c7 ff 28 	sub	r7,r12,-216
8000e26e:	0a 92       	mov	r2,r5
8000e270:	fe b0 fc fc 	rcall	8000dc68 <__sfp_lock_acquire>
8000e274:	3f f3       	mov	r3,-1
8000e276:	c1 68       	rjmp	8000e2a2 <_fwalk+0x3e>
8000e278:	6e 26       	ld.w	r6,r7[0x8]
8000e27a:	6e 14       	ld.w	r4,r7[0x4]
8000e27c:	2f 46       	sub	r6,-12
8000e27e:	c0 c8       	rjmp	8000e296 <_fwalk+0x32>
8000e280:	8c 08       	ld.sh	r8,r6[0x0]
8000e282:	e4 08 19 00 	cp.h	r8,r2
8000e286:	c0 70       	breq	8000e294 <_fwalk+0x30>
8000e288:	8c 18       	ld.sh	r8,r6[0x2]
8000e28a:	e6 08 19 00 	cp.h	r8,r3
8000e28e:	c0 30       	breq	8000e294 <_fwalk+0x30>
8000e290:	5d 11       	icall	r1
8000e292:	18 45       	or	r5,r12
8000e294:	2a 46       	sub	r6,-92
8000e296:	20 14       	sub	r4,1
8000e298:	ec cc 00 0c 	sub	r12,r6,12
8000e29c:	58 04       	cp.w	r4,0
8000e29e:	cf 14       	brge	8000e280 <_fwalk+0x1c>
8000e2a0:	6e 07       	ld.w	r7,r7[0x0]
8000e2a2:	58 07       	cp.w	r7,0
8000e2a4:	ce a1       	brne	8000e278 <_fwalk+0x14>
8000e2a6:	fe b0 fc e2 	rcall	8000dc6a <__sfp_lock_release>
8000e2aa:	0a 9c       	mov	r12,r5
8000e2ac:	d8 32       	popm	r0-r7,pc
8000e2ae:	d7 03       	nop

8000e2b0 <_localeconv_r>:
8000e2b0:	48 1c       	lddpc	r12,8000e2b4 <_localeconv_r+0x4>
8000e2b2:	5e fc       	retal	r12
8000e2b4:	80 01       	ld.sh	r1,r0[0x0]
8000e2b6:	93 38       	st.w	r9[0xc],r8

8000e2b8 <__smakebuf_r>:
8000e2b8:	d4 21       	pushm	r4-r7,lr
8000e2ba:	20 fd       	sub	sp,60
8000e2bc:	96 68       	ld.sh	r8,r11[0xc]
8000e2be:	16 97       	mov	r7,r11
8000e2c0:	18 96       	mov	r6,r12
8000e2c2:	e2 18 00 02 	andl	r8,0x2,COH
8000e2c6:	c3 d1       	brne	8000e340 <__smakebuf_r+0x88>
8000e2c8:	96 7b       	ld.sh	r11,r11[0xe]
8000e2ca:	f0 0b 19 00 	cp.h	r11,r8
8000e2ce:	c0 55       	brlt	8000e2d8 <__smakebuf_r+0x20>
8000e2d0:	1a 9a       	mov	r10,sp
8000e2d2:	e0 a0 04 79 	rcall	8000ebc4 <_fstat_r>
8000e2d6:	c0 f4       	brge	8000e2f4 <__smakebuf_r+0x3c>
8000e2d8:	8e 65       	ld.sh	r5,r7[0xc]
8000e2da:	0a 98       	mov	r8,r5
8000e2dc:	ab b8       	sbr	r8,0xb
8000e2de:	e2 15 00 80 	andl	r5,0x80,COH
8000e2e2:	ae 68       	st.h	r7[0xc],r8
8000e2e4:	30 04       	mov	r4,0
8000e2e6:	e0 68 04 00 	mov	r8,1024
8000e2ea:	f9 b5 01 40 	movne	r5,64
8000e2ee:	f0 05 17 00 	moveq	r5,r8
8000e2f2:	c1 c8       	rjmp	8000e32a <__smakebuf_r+0x72>
8000e2f4:	40 18       	lddsp	r8,sp[0x4]
8000e2f6:	e2 18 f0 00 	andl	r8,0xf000,COH
8000e2fa:	e0 48 20 00 	cp.w	r8,8192
8000e2fe:	5f 04       	sreq	r4
8000e300:	e0 48 80 00 	cp.w	r8,32768
8000e304:	c0 e1       	brne	8000e320 <__smakebuf_r+0x68>
8000e306:	6e b9       	ld.w	r9,r7[0x2c]
8000e308:	fe c8 f9 18 	sub	r8,pc,-1768
8000e30c:	10 39       	cp.w	r9,r8
8000e30e:	c0 91       	brne	8000e320 <__smakebuf_r+0x68>
8000e310:	8e 68       	ld.sh	r8,r7[0xc]
8000e312:	e0 65 04 00 	mov	r5,1024
8000e316:	ab a8       	sbr	r8,0xa
8000e318:	ef 45 00 50 	st.w	r7[80],r5
8000e31c:	ae 68       	st.h	r7[0xc],r8
8000e31e:	c0 68       	rjmp	8000e32a <__smakebuf_r+0x72>
8000e320:	8e 68       	ld.sh	r8,r7[0xc]
8000e322:	e0 65 04 00 	mov	r5,1024
8000e326:	ab b8       	sbr	r8,0xb
8000e328:	ae 68       	st.h	r7[0xc],r8
8000e32a:	0a 9b       	mov	r11,r5
8000e32c:	0c 9c       	mov	r12,r6
8000e32e:	fe b0 de 7d 	rcall	8000a028 <_malloc_r>
8000e332:	8e 68       	ld.sh	r8,r7[0xc]
8000e334:	c0 d1       	brne	8000e34e <__smakebuf_r+0x96>
8000e336:	ed b8 00 09 	bld	r8,0x9
8000e33a:	c1 b0       	breq	8000e370 <__smakebuf_r+0xb8>
8000e33c:	a1 b8       	sbr	r8,0x1
8000e33e:	ae 68       	st.h	r7[0xc],r8
8000e340:	ee c8 ff b9 	sub	r8,r7,-71
8000e344:	8f 48       	st.w	r7[0x10],r8
8000e346:	8f 08       	st.w	r7[0x0],r8
8000e348:	30 18       	mov	r8,1
8000e34a:	8f 58       	st.w	r7[0x14],r8
8000e34c:	c1 28       	rjmp	8000e370 <__smakebuf_r+0xb8>
8000e34e:	a7 b8       	sbr	r8,0x7
8000e350:	8f 4c       	st.w	r7[0x10],r12
8000e352:	ae 68       	st.h	r7[0xc],r8
8000e354:	8f 55       	st.w	r7[0x14],r5
8000e356:	fe c8 06 ea 	sub	r8,pc,1770
8000e35a:	8f 0c       	st.w	r7[0x0],r12
8000e35c:	8d a8       	st.w	r6[0x28],r8
8000e35e:	58 04       	cp.w	r4,0
8000e360:	c0 80       	breq	8000e370 <__smakebuf_r+0xb8>
8000e362:	8e 7c       	ld.sh	r12,r7[0xe]
8000e364:	fe b0 e3 7a 	rcall	8000aa58 <isatty>
8000e368:	c0 40       	breq	8000e370 <__smakebuf_r+0xb8>
8000e36a:	8e 68       	ld.sh	r8,r7[0xc]
8000e36c:	a1 a8       	sbr	r8,0x0
8000e36e:	ae 68       	st.h	r7[0xc],r8
8000e370:	2f 1d       	sub	sp,-60
8000e372:	d8 22       	popm	r4-r7,pc

8000e374 <memchr>:
8000e374:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000e378:	c0 68       	rjmp	8000e384 <memchr+0x10>
8000e37a:	20 1a       	sub	r10,1
8000e37c:	19 88       	ld.ub	r8,r12[0x0]
8000e37e:	16 38       	cp.w	r8,r11
8000e380:	5e 0c       	reteq	r12
8000e382:	2f fc       	sub	r12,-1
8000e384:	58 0a       	cp.w	r10,0
8000e386:	cf a1       	brne	8000e37a <memchr+0x6>
8000e388:	5e fa       	retal	r10

8000e38a <memmove>:
8000e38a:	d4 01       	pushm	lr
8000e38c:	18 3b       	cp.w	r11,r12
8000e38e:	c1 92       	brcc	8000e3c0 <memmove+0x36>
8000e390:	f6 0a 00 09 	add	r9,r11,r10
8000e394:	12 3c       	cp.w	r12,r9
8000e396:	c1 52       	brcc	8000e3c0 <memmove+0x36>
8000e398:	f8 0a 00 0b 	add	r11,r12,r10
8000e39c:	30 08       	mov	r8,0
8000e39e:	c0 68       	rjmp	8000e3aa <memmove+0x20>
8000e3a0:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000e3a4:	20 1a       	sub	r10,1
8000e3a6:	f6 08 0b 0e 	st.b	r11[r8],lr
8000e3aa:	20 18       	sub	r8,1
8000e3ac:	58 0a       	cp.w	r10,0
8000e3ae:	cf 91       	brne	8000e3a0 <memmove+0x16>
8000e3b0:	d8 02       	popm	pc
8000e3b2:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000e3b6:	20 1a       	sub	r10,1
8000e3b8:	f8 08 0b 09 	st.b	r12[r8],r9
8000e3bc:	2f f8       	sub	r8,-1
8000e3be:	c0 28       	rjmp	8000e3c2 <memmove+0x38>
8000e3c0:	30 08       	mov	r8,0
8000e3c2:	58 0a       	cp.w	r10,0
8000e3c4:	cf 71       	brne	8000e3b2 <memmove+0x28>
8000e3c6:	d8 02       	popm	pc

8000e3c8 <__hi0bits>:
8000e3c8:	18 98       	mov	r8,r12
8000e3ca:	e0 1c 00 00 	andl	r12,0x0
8000e3ce:	f0 09 15 10 	lsl	r9,r8,0x10
8000e3d2:	58 0c       	cp.w	r12,0
8000e3d4:	f2 08 17 00 	moveq	r8,r9
8000e3d8:	f9 bc 00 10 	moveq	r12,16
8000e3dc:	f9 bc 01 00 	movne	r12,0
8000e3e0:	10 9a       	mov	r10,r8
8000e3e2:	f0 09 15 08 	lsl	r9,r8,0x8
8000e3e6:	e6 1a ff 00 	andh	r10,0xff00,COH
8000e3ea:	f7 bc 00 f8 	subeq	r12,-8
8000e3ee:	f2 08 17 00 	moveq	r8,r9
8000e3f2:	10 9a       	mov	r10,r8
8000e3f4:	f0 09 15 04 	lsl	r9,r8,0x4
8000e3f8:	e6 1a f0 00 	andh	r10,0xf000,COH
8000e3fc:	f7 bc 00 fc 	subeq	r12,-4
8000e400:	f2 08 17 00 	moveq	r8,r9
8000e404:	10 9a       	mov	r10,r8
8000e406:	f0 09 15 02 	lsl	r9,r8,0x2
8000e40a:	e6 1a c0 00 	andh	r10,0xc000,COH
8000e40e:	f7 bc 00 fe 	subeq	r12,-2
8000e412:	f2 08 17 00 	moveq	r8,r9
8000e416:	58 08       	cp.w	r8,0
8000e418:	5e 5c       	retlt	r12
8000e41a:	ed b8 00 1e 	bld	r8,0x1e
8000e41e:	f9 bc 01 20 	movne	r12,32
8000e422:	f7 bc 00 ff 	subeq	r12,-1
8000e426:	5e fc       	retal	r12

8000e428 <__lo0bits>:
8000e428:	18 99       	mov	r9,r12
8000e42a:	78 08       	ld.w	r8,r12[0x0]
8000e42c:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000e430:	c1 50       	breq	8000e45a <__lo0bits+0x32>
8000e432:	ed b8 00 00 	bld	r8,0x0
8000e436:	c0 21       	brne	8000e43a <__lo0bits+0x12>
8000e438:	5e fd       	retal	0
8000e43a:	10 9b       	mov	r11,r8
8000e43c:	f0 0a 16 01 	lsr	r10,r8,0x1
8000e440:	e2 1b 00 02 	andl	r11,0x2,COH
8000e444:	a3 88       	lsr	r8,0x2
8000e446:	58 0b       	cp.w	r11,0
8000e448:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000e44c:	f9 bc 01 01 	movne	r12,1
8000e450:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000e454:	f9 bc 00 02 	moveq	r12,2
8000e458:	5e fc       	retal	r12
8000e45a:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000e45e:	f0 0b 16 10 	lsr	r11,r8,0x10
8000e462:	58 0a       	cp.w	r10,0
8000e464:	f6 08 17 00 	moveq	r8,r11
8000e468:	f9 bc 00 10 	moveq	r12,16
8000e46c:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000e470:	f0 0a 16 08 	lsr	r10,r8,0x8
8000e474:	58 0b       	cp.w	r11,0
8000e476:	f7 bc 00 f8 	subeq	r12,-8
8000e47a:	f4 08 17 00 	moveq	r8,r10
8000e47e:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000e482:	f0 0a 16 04 	lsr	r10,r8,0x4
8000e486:	58 0b       	cp.w	r11,0
8000e488:	f7 bc 00 fc 	subeq	r12,-4
8000e48c:	f4 08 17 00 	moveq	r8,r10
8000e490:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000e494:	f0 0a 16 02 	lsr	r10,r8,0x2
8000e498:	58 0b       	cp.w	r11,0
8000e49a:	f7 bc 00 fe 	subeq	r12,-2
8000e49e:	f4 08 17 00 	moveq	r8,r10
8000e4a2:	ed b8 00 00 	bld	r8,0x0
8000e4a6:	c0 60       	breq	8000e4b2 <__lo0bits+0x8a>
8000e4a8:	a1 98       	lsr	r8,0x1
8000e4aa:	c0 31       	brne	8000e4b0 <__lo0bits+0x88>
8000e4ac:	32 0c       	mov	r12,32
8000e4ae:	5e fc       	retal	r12
8000e4b0:	2f fc       	sub	r12,-1
8000e4b2:	93 08       	st.w	r9[0x0],r8
8000e4b4:	5e fc       	retal	r12

8000e4b6 <__mcmp>:
8000e4b6:	d4 01       	pushm	lr
8000e4b8:	18 98       	mov	r8,r12
8000e4ba:	76 49       	ld.w	r9,r11[0x10]
8000e4bc:	78 4c       	ld.w	r12,r12[0x10]
8000e4be:	12 1c       	sub	r12,r9
8000e4c0:	c1 31       	brne	8000e4e6 <__mcmp+0x30>
8000e4c2:	2f b9       	sub	r9,-5
8000e4c4:	a3 69       	lsl	r9,0x2
8000e4c6:	12 0b       	add	r11,r9
8000e4c8:	f0 09 00 09 	add	r9,r8,r9
8000e4cc:	2e c8       	sub	r8,-20
8000e4ce:	13 4e       	ld.w	lr,--r9
8000e4d0:	17 4a       	ld.w	r10,--r11
8000e4d2:	14 3e       	cp.w	lr,r10
8000e4d4:	c0 60       	breq	8000e4e0 <__mcmp+0x2a>
8000e4d6:	f9 bc 03 ff 	movlo	r12,-1
8000e4da:	f9 bc 02 01 	movhs	r12,1
8000e4de:	d8 02       	popm	pc
8000e4e0:	10 39       	cp.w	r9,r8
8000e4e2:	fe 9b ff f6 	brhi	8000e4ce <__mcmp+0x18>
8000e4e6:	d8 02       	popm	pc

8000e4e8 <_Bfree>:
8000e4e8:	d4 21       	pushm	r4-r7,lr
8000e4ea:	18 97       	mov	r7,r12
8000e4ec:	16 95       	mov	r5,r11
8000e4ee:	78 96       	ld.w	r6,r12[0x24]
8000e4f0:	58 06       	cp.w	r6,0
8000e4f2:	c0 91       	brne	8000e504 <_Bfree+0x1c>
8000e4f4:	31 0c       	mov	r12,16
8000e4f6:	fe b0 dd 91 	rcall	8000a018 <malloc>
8000e4fa:	99 36       	st.w	r12[0xc],r6
8000e4fc:	8f 9c       	st.w	r7[0x24],r12
8000e4fe:	99 16       	st.w	r12[0x4],r6
8000e500:	99 26       	st.w	r12[0x8],r6
8000e502:	99 06       	st.w	r12[0x0],r6
8000e504:	58 05       	cp.w	r5,0
8000e506:	c0 90       	breq	8000e518 <_Bfree+0x30>
8000e508:	6a 19       	ld.w	r9,r5[0x4]
8000e50a:	6e 98       	ld.w	r8,r7[0x24]
8000e50c:	70 38       	ld.w	r8,r8[0xc]
8000e50e:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000e512:	8b 0a       	st.w	r5[0x0],r10
8000e514:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000e518:	d8 22       	popm	r4-r7,pc
8000e51a:	d7 03       	nop

8000e51c <_Balloc>:
8000e51c:	d4 21       	pushm	r4-r7,lr
8000e51e:	18 97       	mov	r7,r12
8000e520:	16 96       	mov	r6,r11
8000e522:	78 95       	ld.w	r5,r12[0x24]
8000e524:	58 05       	cp.w	r5,0
8000e526:	c0 91       	brne	8000e538 <_Balloc+0x1c>
8000e528:	31 0c       	mov	r12,16
8000e52a:	fe b0 dd 77 	rcall	8000a018 <malloc>
8000e52e:	99 35       	st.w	r12[0xc],r5
8000e530:	8f 9c       	st.w	r7[0x24],r12
8000e532:	99 15       	st.w	r12[0x4],r5
8000e534:	99 25       	st.w	r12[0x8],r5
8000e536:	99 05       	st.w	r12[0x0],r5
8000e538:	6e 95       	ld.w	r5,r7[0x24]
8000e53a:	6a 38       	ld.w	r8,r5[0xc]
8000e53c:	58 08       	cp.w	r8,0
8000e53e:	c0 b1       	brne	8000e554 <_Balloc+0x38>
8000e540:	31 0a       	mov	r10,16
8000e542:	30 4b       	mov	r11,4
8000e544:	0e 9c       	mov	r12,r7
8000e546:	e0 a0 02 9d 	rcall	8000ea80 <_calloc_r>
8000e54a:	8b 3c       	st.w	r5[0xc],r12
8000e54c:	6e 98       	ld.w	r8,r7[0x24]
8000e54e:	70 3c       	ld.w	r12,r8[0xc]
8000e550:	58 0c       	cp.w	r12,0
8000e552:	c1 b0       	breq	8000e588 <_Balloc+0x6c>
8000e554:	6e 98       	ld.w	r8,r7[0x24]
8000e556:	70 38       	ld.w	r8,r8[0xc]
8000e558:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000e55c:	70 0c       	ld.w	r12,r8[0x0]
8000e55e:	58 0c       	cp.w	r12,0
8000e560:	c0 40       	breq	8000e568 <_Balloc+0x4c>
8000e562:	78 09       	ld.w	r9,r12[0x0]
8000e564:	91 09       	st.w	r8[0x0],r9
8000e566:	c0 e8       	rjmp	8000e582 <_Balloc+0x66>
8000e568:	0e 9c       	mov	r12,r7
8000e56a:	30 17       	mov	r7,1
8000e56c:	0e 9b       	mov	r11,r7
8000e56e:	ee 06 09 47 	lsl	r7,r7,r6
8000e572:	ee ca ff fb 	sub	r10,r7,-5
8000e576:	a3 6a       	lsl	r10,0x2
8000e578:	e0 a0 02 84 	rcall	8000ea80 <_calloc_r>
8000e57c:	c0 60       	breq	8000e588 <_Balloc+0x6c>
8000e57e:	99 16       	st.w	r12[0x4],r6
8000e580:	99 27       	st.w	r12[0x8],r7
8000e582:	30 08       	mov	r8,0
8000e584:	99 38       	st.w	r12[0xc],r8
8000e586:	99 48       	st.w	r12[0x10],r8
8000e588:	d8 22       	popm	r4-r7,pc
8000e58a:	d7 03       	nop

8000e58c <__d2b>:
8000e58c:	d4 31       	pushm	r0-r7,lr
8000e58e:	20 2d       	sub	sp,8
8000e590:	16 93       	mov	r3,r11
8000e592:	12 96       	mov	r6,r9
8000e594:	10 95       	mov	r5,r8
8000e596:	14 92       	mov	r2,r10
8000e598:	30 1b       	mov	r11,1
8000e59a:	cc 1f       	rcall	8000e51c <_Balloc>
8000e59c:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000e5a0:	50 09       	stdsp	sp[0x0],r9
8000e5a2:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000e5a6:	b5 a9       	sbr	r9,0x14
8000e5a8:	f0 01 16 14 	lsr	r1,r8,0x14
8000e5ac:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000e5b0:	18 94       	mov	r4,r12
8000e5b2:	58 02       	cp.w	r2,0
8000e5b4:	c1 d0       	breq	8000e5ee <__d2b+0x62>
8000e5b6:	fa cc ff f8 	sub	r12,sp,-8
8000e5ba:	18 d2       	st.w	--r12,r2
8000e5bc:	c3 6f       	rcall	8000e428 <__lo0bits>
8000e5be:	40 18       	lddsp	r8,sp[0x4]
8000e5c0:	c0 d0       	breq	8000e5da <__d2b+0x4e>
8000e5c2:	40 09       	lddsp	r9,sp[0x0]
8000e5c4:	f8 0a 11 20 	rsub	r10,r12,32
8000e5c8:	f2 0a 09 4a 	lsl	r10,r9,r10
8000e5cc:	f5 e8 10 08 	or	r8,r10,r8
8000e5d0:	89 58       	st.w	r4[0x14],r8
8000e5d2:	f2 0c 0a 49 	lsr	r9,r9,r12
8000e5d6:	50 09       	stdsp	sp[0x0],r9
8000e5d8:	c0 28       	rjmp	8000e5dc <__d2b+0x50>
8000e5da:	89 58       	st.w	r4[0x14],r8
8000e5dc:	40 08       	lddsp	r8,sp[0x0]
8000e5de:	58 08       	cp.w	r8,0
8000e5e0:	f9 b3 01 02 	movne	r3,2
8000e5e4:	f9 b3 00 01 	moveq	r3,1
8000e5e8:	89 68       	st.w	r4[0x18],r8
8000e5ea:	89 43       	st.w	r4[0x10],r3
8000e5ec:	c0 88       	rjmp	8000e5fc <__d2b+0x70>
8000e5ee:	1a 9c       	mov	r12,sp
8000e5f0:	c1 cf       	rcall	8000e428 <__lo0bits>
8000e5f2:	30 13       	mov	r3,1
8000e5f4:	40 08       	lddsp	r8,sp[0x0]
8000e5f6:	2e 0c       	sub	r12,-32
8000e5f8:	89 43       	st.w	r4[0x10],r3
8000e5fa:	89 58       	st.w	r4[0x14],r8
8000e5fc:	58 01       	cp.w	r1,0
8000e5fe:	c0 90       	breq	8000e610 <__d2b+0x84>
8000e600:	e2 c1 04 33 	sub	r1,r1,1075
8000e604:	18 01       	add	r1,r12
8000e606:	8d 01       	st.w	r6[0x0],r1
8000e608:	f8 0c 11 35 	rsub	r12,r12,53
8000e60c:	8b 0c       	st.w	r5[0x0],r12
8000e60e:	c0 c8       	rjmp	8000e626 <__d2b+0x9a>
8000e610:	e6 c8 ff fc 	sub	r8,r3,-4
8000e614:	f8 cc 04 32 	sub	r12,r12,1074
8000e618:	a5 73       	lsl	r3,0x5
8000e61a:	8d 0c       	st.w	r6[0x0],r12
8000e61c:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000e620:	cd 4e       	rcall	8000e3c8 <__hi0bits>
8000e622:	18 13       	sub	r3,r12
8000e624:	8b 03       	st.w	r5[0x0],r3
8000e626:	08 9c       	mov	r12,r4
8000e628:	2f ed       	sub	sp,-8
8000e62a:	d8 32       	popm	r0-r7,pc

8000e62c <__mdiff>:
8000e62c:	d4 31       	pushm	r0-r7,lr
8000e62e:	74 48       	ld.w	r8,r10[0x10]
8000e630:	76 45       	ld.w	r5,r11[0x10]
8000e632:	16 97       	mov	r7,r11
8000e634:	14 96       	mov	r6,r10
8000e636:	10 15       	sub	r5,r8
8000e638:	c1 31       	brne	8000e65e <__mdiff+0x32>
8000e63a:	2f b8       	sub	r8,-5
8000e63c:	ee ce ff ec 	sub	lr,r7,-20
8000e640:	a3 68       	lsl	r8,0x2
8000e642:	f4 08 00 0b 	add	r11,r10,r8
8000e646:	ee 08 00 08 	add	r8,r7,r8
8000e64a:	11 4a       	ld.w	r10,--r8
8000e64c:	17 49       	ld.w	r9,--r11
8000e64e:	12 3a       	cp.w	r10,r9
8000e650:	c0 30       	breq	8000e656 <__mdiff+0x2a>
8000e652:	c0 e2       	brcc	8000e66e <__mdiff+0x42>
8000e654:	c0 78       	rjmp	8000e662 <__mdiff+0x36>
8000e656:	1c 38       	cp.w	r8,lr
8000e658:	fe 9b ff f9 	brhi	8000e64a <__mdiff+0x1e>
8000e65c:	c4 98       	rjmp	8000e6ee <__mdiff+0xc2>
8000e65e:	58 05       	cp.w	r5,0
8000e660:	c0 64       	brge	8000e66c <__mdiff+0x40>
8000e662:	0e 98       	mov	r8,r7
8000e664:	30 15       	mov	r5,1
8000e666:	0c 97       	mov	r7,r6
8000e668:	10 96       	mov	r6,r8
8000e66a:	c0 28       	rjmp	8000e66e <__mdiff+0x42>
8000e66c:	30 05       	mov	r5,0
8000e66e:	6e 1b       	ld.w	r11,r7[0x4]
8000e670:	c5 6f       	rcall	8000e51c <_Balloc>
8000e672:	6e 49       	ld.w	r9,r7[0x10]
8000e674:	6c 44       	ld.w	r4,r6[0x10]
8000e676:	99 35       	st.w	r12[0xc],r5
8000e678:	2f b4       	sub	r4,-5
8000e67a:	f2 c5 ff fb 	sub	r5,r9,-5
8000e67e:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000e682:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000e686:	2e c6       	sub	r6,-20
8000e688:	2e c7       	sub	r7,-20
8000e68a:	f8 c8 ff ec 	sub	r8,r12,-20
8000e68e:	30 0a       	mov	r10,0
8000e690:	0f 0e       	ld.w	lr,r7++
8000e692:	0d 0b       	ld.w	r11,r6++
8000e694:	fc 02 16 10 	lsr	r2,lr,0x10
8000e698:	f6 03 16 10 	lsr	r3,r11,0x10
8000e69c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000e6a0:	e4 03 01 03 	sub	r3,r2,r3
8000e6a4:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000e6a8:	fc 0b 01 0b 	sub	r11,lr,r11
8000e6ac:	f6 0a 00 0a 	add	r10,r11,r10
8000e6b0:	b0 1a       	st.h	r8[0x2],r10
8000e6b2:	b1 4a       	asr	r10,0x10
8000e6b4:	e6 0a 00 0a 	add	r10,r3,r10
8000e6b8:	b0 0a       	st.h	r8[0x0],r10
8000e6ba:	2f c8       	sub	r8,-4
8000e6bc:	b1 4a       	asr	r10,0x10
8000e6be:	08 36       	cp.w	r6,r4
8000e6c0:	ce 83       	brcs	8000e690 <__mdiff+0x64>
8000e6c2:	c0 d8       	rjmp	8000e6dc <__mdiff+0xb0>
8000e6c4:	0f 0b       	ld.w	r11,r7++
8000e6c6:	f6 0e 16 10 	lsr	lr,r11,0x10
8000e6ca:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000e6ce:	16 0a       	add	r10,r11
8000e6d0:	b0 1a       	st.h	r8[0x2],r10
8000e6d2:	b1 4a       	asr	r10,0x10
8000e6d4:	1c 0a       	add	r10,lr
8000e6d6:	b0 0a       	st.h	r8[0x0],r10
8000e6d8:	2f c8       	sub	r8,-4
8000e6da:	b1 4a       	asr	r10,0x10
8000e6dc:	0a 37       	cp.w	r7,r5
8000e6de:	cf 33       	brcs	8000e6c4 <__mdiff+0x98>
8000e6e0:	c0 28       	rjmp	8000e6e4 <__mdiff+0xb8>
8000e6e2:	20 19       	sub	r9,1
8000e6e4:	11 4a       	ld.w	r10,--r8
8000e6e6:	58 0a       	cp.w	r10,0
8000e6e8:	cf d0       	breq	8000e6e2 <__mdiff+0xb6>
8000e6ea:	99 49       	st.w	r12[0x10],r9
8000e6ec:	d8 32       	popm	r0-r7,pc
8000e6ee:	30 0b       	mov	r11,0
8000e6f0:	c1 6f       	rcall	8000e51c <_Balloc>
8000e6f2:	30 18       	mov	r8,1
8000e6f4:	99 48       	st.w	r12[0x10],r8
8000e6f6:	30 08       	mov	r8,0
8000e6f8:	99 58       	st.w	r12[0x14],r8
8000e6fa:	d8 32       	popm	r0-r7,pc

8000e6fc <__lshift>:
8000e6fc:	d4 31       	pushm	r0-r7,lr
8000e6fe:	16 97       	mov	r7,r11
8000e700:	76 46       	ld.w	r6,r11[0x10]
8000e702:	f4 02 14 05 	asr	r2,r10,0x5
8000e706:	2f f6       	sub	r6,-1
8000e708:	14 93       	mov	r3,r10
8000e70a:	18 94       	mov	r4,r12
8000e70c:	04 06       	add	r6,r2
8000e70e:	76 1b       	ld.w	r11,r11[0x4]
8000e710:	6e 28       	ld.w	r8,r7[0x8]
8000e712:	c0 38       	rjmp	8000e718 <__lshift+0x1c>
8000e714:	2f fb       	sub	r11,-1
8000e716:	a1 78       	lsl	r8,0x1
8000e718:	10 36       	cp.w	r6,r8
8000e71a:	fe 99 ff fd 	brgt	8000e714 <__lshift+0x18>
8000e71e:	08 9c       	mov	r12,r4
8000e720:	cf ee       	rcall	8000e51c <_Balloc>
8000e722:	30 09       	mov	r9,0
8000e724:	18 95       	mov	r5,r12
8000e726:	f8 c8 ff ec 	sub	r8,r12,-20
8000e72a:	12 9a       	mov	r10,r9
8000e72c:	c0 38       	rjmp	8000e732 <__lshift+0x36>
8000e72e:	10 aa       	st.w	r8++,r10
8000e730:	2f f9       	sub	r9,-1
8000e732:	04 39       	cp.w	r9,r2
8000e734:	cf d5       	brlt	8000e72e <__lshift+0x32>
8000e736:	6e 4b       	ld.w	r11,r7[0x10]
8000e738:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000e73c:	2f bb       	sub	r11,-5
8000e73e:	ee c9 ff ec 	sub	r9,r7,-20
8000e742:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000e746:	58 03       	cp.w	r3,0
8000e748:	c1 30       	breq	8000e76e <__lshift+0x72>
8000e74a:	e6 0c 11 20 	rsub	r12,r3,32
8000e74e:	30 0a       	mov	r10,0
8000e750:	72 02       	ld.w	r2,r9[0x0]
8000e752:	e4 03 09 42 	lsl	r2,r2,r3
8000e756:	04 4a       	or	r10,r2
8000e758:	10 aa       	st.w	r8++,r10
8000e75a:	13 0a       	ld.w	r10,r9++
8000e75c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000e760:	16 39       	cp.w	r9,r11
8000e762:	cf 73       	brcs	8000e750 <__lshift+0x54>
8000e764:	91 0a       	st.w	r8[0x0],r10
8000e766:	58 0a       	cp.w	r10,0
8000e768:	c0 70       	breq	8000e776 <__lshift+0x7a>
8000e76a:	2f f6       	sub	r6,-1
8000e76c:	c0 58       	rjmp	8000e776 <__lshift+0x7a>
8000e76e:	13 0a       	ld.w	r10,r9++
8000e770:	10 aa       	st.w	r8++,r10
8000e772:	16 39       	cp.w	r9,r11
8000e774:	cf d3       	brcs	8000e76e <__lshift+0x72>
8000e776:	08 9c       	mov	r12,r4
8000e778:	20 16       	sub	r6,1
8000e77a:	0e 9b       	mov	r11,r7
8000e77c:	8b 46       	st.w	r5[0x10],r6
8000e77e:	cb 5e       	rcall	8000e4e8 <_Bfree>
8000e780:	0a 9c       	mov	r12,r5
8000e782:	d8 32       	popm	r0-r7,pc

8000e784 <__multiply>:
8000e784:	d4 31       	pushm	r0-r7,lr
8000e786:	20 2d       	sub	sp,8
8000e788:	76 49       	ld.w	r9,r11[0x10]
8000e78a:	74 48       	ld.w	r8,r10[0x10]
8000e78c:	16 96       	mov	r6,r11
8000e78e:	14 95       	mov	r5,r10
8000e790:	10 39       	cp.w	r9,r8
8000e792:	ec 08 17 50 	movlt	r8,r6
8000e796:	ea 06 17 50 	movlt	r6,r5
8000e79a:	f0 05 17 50 	movlt	r5,r8
8000e79e:	6c 28       	ld.w	r8,r6[0x8]
8000e7a0:	76 43       	ld.w	r3,r11[0x10]
8000e7a2:	74 42       	ld.w	r2,r10[0x10]
8000e7a4:	76 1b       	ld.w	r11,r11[0x4]
8000e7a6:	e4 03 00 07 	add	r7,r2,r3
8000e7aa:	10 37       	cp.w	r7,r8
8000e7ac:	f7 bb 09 ff 	subgt	r11,-1
8000e7b0:	cb 6e       	rcall	8000e51c <_Balloc>
8000e7b2:	ee c4 ff fb 	sub	r4,r7,-5
8000e7b6:	f8 c9 ff ec 	sub	r9,r12,-20
8000e7ba:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000e7be:	30 0a       	mov	r10,0
8000e7c0:	12 98       	mov	r8,r9
8000e7c2:	c0 28       	rjmp	8000e7c6 <__multiply+0x42>
8000e7c4:	10 aa       	st.w	r8++,r10
8000e7c6:	08 38       	cp.w	r8,r4
8000e7c8:	cf e3       	brcs	8000e7c4 <__multiply+0x40>
8000e7ca:	2f b3       	sub	r3,-5
8000e7cc:	2f b2       	sub	r2,-5
8000e7ce:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000e7d2:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000e7d6:	ec cb ff ec 	sub	r11,r6,-20
8000e7da:	50 12       	stdsp	sp[0x4],r2
8000e7dc:	ea ca ff ec 	sub	r10,r5,-20
8000e7e0:	c4 48       	rjmp	8000e868 <__multiply+0xe4>
8000e7e2:	94 95       	ld.uh	r5,r10[0x2]
8000e7e4:	58 05       	cp.w	r5,0
8000e7e6:	c2 00       	breq	8000e826 <__multiply+0xa2>
8000e7e8:	12 98       	mov	r8,r9
8000e7ea:	16 96       	mov	r6,r11
8000e7ec:	30 0e       	mov	lr,0
8000e7ee:	50 09       	stdsp	sp[0x0],r9
8000e7f0:	0d 02       	ld.w	r2,r6++
8000e7f2:	e4 00 16 10 	lsr	r0,r2,0x10
8000e7f6:	70 01       	ld.w	r1,r8[0x0]
8000e7f8:	70 09       	ld.w	r9,r8[0x0]
8000e7fa:	b1 81       	lsr	r1,0x10
8000e7fc:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000e800:	e0 05 03 41 	mac	r1,r0,r5
8000e804:	ab 32       	mul	r2,r5
8000e806:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000e80a:	00 02       	add	r2,r0
8000e80c:	e4 0e 00 0e 	add	lr,r2,lr
8000e810:	b0 1e       	st.h	r8[0x2],lr
8000e812:	b1 8e       	lsr	lr,0x10
8000e814:	1c 01       	add	r1,lr
8000e816:	b0 01       	st.h	r8[0x0],r1
8000e818:	e2 0e 16 10 	lsr	lr,r1,0x10
8000e81c:	2f c8       	sub	r8,-4
8000e81e:	06 36       	cp.w	r6,r3
8000e820:	ce 83       	brcs	8000e7f0 <__multiply+0x6c>
8000e822:	40 09       	lddsp	r9,sp[0x0]
8000e824:	91 0e       	st.w	r8[0x0],lr
8000e826:	94 86       	ld.uh	r6,r10[0x0]
8000e828:	58 06       	cp.w	r6,0
8000e82a:	c1 d0       	breq	8000e864 <__multiply+0xe0>
8000e82c:	72 02       	ld.w	r2,r9[0x0]
8000e82e:	12 98       	mov	r8,r9
8000e830:	16 9e       	mov	lr,r11
8000e832:	30 05       	mov	r5,0
8000e834:	b0 12       	st.h	r8[0x2],r2
8000e836:	1d 01       	ld.w	r1,lr++
8000e838:	90 82       	ld.uh	r2,r8[0x0]
8000e83a:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000e83e:	ad 30       	mul	r0,r6
8000e840:	e0 02 00 02 	add	r2,r0,r2
8000e844:	e4 05 00 05 	add	r5,r2,r5
8000e848:	b0 05       	st.h	r8[0x0],r5
8000e84a:	b1 85       	lsr	r5,0x10
8000e84c:	b1 81       	lsr	r1,0x10
8000e84e:	2f c8       	sub	r8,-4
8000e850:	ad 31       	mul	r1,r6
8000e852:	90 92       	ld.uh	r2,r8[0x2]
8000e854:	e2 02 00 02 	add	r2,r1,r2
8000e858:	0a 02       	add	r2,r5
8000e85a:	e4 05 16 10 	lsr	r5,r2,0x10
8000e85e:	06 3e       	cp.w	lr,r3
8000e860:	ce a3       	brcs	8000e834 <__multiply+0xb0>
8000e862:	91 02       	st.w	r8[0x0],r2
8000e864:	2f ca       	sub	r10,-4
8000e866:	2f c9       	sub	r9,-4
8000e868:	40 18       	lddsp	r8,sp[0x4]
8000e86a:	10 3a       	cp.w	r10,r8
8000e86c:	cb b3       	brcs	8000e7e2 <__multiply+0x5e>
8000e86e:	c0 28       	rjmp	8000e872 <__multiply+0xee>
8000e870:	20 17       	sub	r7,1
8000e872:	58 07       	cp.w	r7,0
8000e874:	e0 8a 00 05 	brle	8000e87e <__multiply+0xfa>
8000e878:	09 48       	ld.w	r8,--r4
8000e87a:	58 08       	cp.w	r8,0
8000e87c:	cf a0       	breq	8000e870 <__multiply+0xec>
8000e87e:	99 47       	st.w	r12[0x10],r7
8000e880:	2f ed       	sub	sp,-8
8000e882:	d8 32       	popm	r0-r7,pc

8000e884 <__i2b>:
8000e884:	d4 21       	pushm	r4-r7,lr
8000e886:	16 97       	mov	r7,r11
8000e888:	30 1b       	mov	r11,1
8000e88a:	c4 9e       	rcall	8000e51c <_Balloc>
8000e88c:	30 19       	mov	r9,1
8000e88e:	99 57       	st.w	r12[0x14],r7
8000e890:	99 49       	st.w	r12[0x10],r9
8000e892:	d8 22       	popm	r4-r7,pc

8000e894 <__multadd>:
8000e894:	d4 31       	pushm	r0-r7,lr
8000e896:	30 08       	mov	r8,0
8000e898:	12 95       	mov	r5,r9
8000e89a:	16 97       	mov	r7,r11
8000e89c:	18 96       	mov	r6,r12
8000e89e:	76 44       	ld.w	r4,r11[0x10]
8000e8a0:	f6 c9 ff ec 	sub	r9,r11,-20
8000e8a4:	72 0b       	ld.w	r11,r9[0x0]
8000e8a6:	f6 0c 16 10 	lsr	r12,r11,0x10
8000e8aa:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000e8ae:	f4 0c 02 4c 	mul	r12,r10,r12
8000e8b2:	f4 0b 03 45 	mac	r5,r10,r11
8000e8b6:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000e8ba:	b1 85       	lsr	r5,0x10
8000e8bc:	18 05       	add	r5,r12
8000e8be:	ea 0c 15 10 	lsl	r12,r5,0x10
8000e8c2:	f8 0b 00 0b 	add	r11,r12,r11
8000e8c6:	12 ab       	st.w	r9++,r11
8000e8c8:	2f f8       	sub	r8,-1
8000e8ca:	b1 85       	lsr	r5,0x10
8000e8cc:	08 38       	cp.w	r8,r4
8000e8ce:	ce b5       	brlt	8000e8a4 <__multadd+0x10>
8000e8d0:	58 05       	cp.w	r5,0
8000e8d2:	c1 c0       	breq	8000e90a <__multadd+0x76>
8000e8d4:	6e 28       	ld.w	r8,r7[0x8]
8000e8d6:	10 34       	cp.w	r4,r8
8000e8d8:	c1 35       	brlt	8000e8fe <__multadd+0x6a>
8000e8da:	6e 1b       	ld.w	r11,r7[0x4]
8000e8dc:	0c 9c       	mov	r12,r6
8000e8de:	2f fb       	sub	r11,-1
8000e8e0:	c1 ee       	rcall	8000e51c <_Balloc>
8000e8e2:	6e 4a       	ld.w	r10,r7[0x10]
8000e8e4:	ee cb ff f4 	sub	r11,r7,-12
8000e8e8:	18 93       	mov	r3,r12
8000e8ea:	2f ea       	sub	r10,-2
8000e8ec:	2f 4c       	sub	r12,-12
8000e8ee:	a3 6a       	lsl	r10,0x2
8000e8f0:	fe b0 dd cb 	rcall	8000a486 <memcpy>
8000e8f4:	0e 9b       	mov	r11,r7
8000e8f6:	0c 9c       	mov	r12,r6
8000e8f8:	fe b0 fd f8 	rcall	8000e4e8 <_Bfree>
8000e8fc:	06 97       	mov	r7,r3
8000e8fe:	e8 c8 ff ff 	sub	r8,r4,-1
8000e902:	2f b4       	sub	r4,-5
8000e904:	8f 48       	st.w	r7[0x10],r8
8000e906:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000e90a:	0e 9c       	mov	r12,r7
8000e90c:	d8 32       	popm	r0-r7,pc
8000e90e:	d7 03       	nop

8000e910 <__pow5mult>:
8000e910:	d4 31       	pushm	r0-r7,lr
8000e912:	14 96       	mov	r6,r10
8000e914:	18 97       	mov	r7,r12
8000e916:	16 94       	mov	r4,r11
8000e918:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000e91c:	c0 80       	breq	8000e92c <__pow5mult+0x1c>
8000e91e:	20 18       	sub	r8,1
8000e920:	49 f9       	lddpc	r9,8000e99c <__pow5mult+0x8c>
8000e922:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000e926:	30 09       	mov	r9,0
8000e928:	cb 6f       	rcall	8000e894 <__multadd>
8000e92a:	18 94       	mov	r4,r12
8000e92c:	a3 46       	asr	r6,0x2
8000e92e:	c3 40       	breq	8000e996 <__pow5mult+0x86>
8000e930:	6e 95       	ld.w	r5,r7[0x24]
8000e932:	58 05       	cp.w	r5,0
8000e934:	c0 91       	brne	8000e946 <__pow5mult+0x36>
8000e936:	31 0c       	mov	r12,16
8000e938:	fe b0 db 70 	rcall	8000a018 <malloc>
8000e93c:	99 35       	st.w	r12[0xc],r5
8000e93e:	8f 9c       	st.w	r7[0x24],r12
8000e940:	99 15       	st.w	r12[0x4],r5
8000e942:	99 25       	st.w	r12[0x8],r5
8000e944:	99 05       	st.w	r12[0x0],r5
8000e946:	6e 93       	ld.w	r3,r7[0x24]
8000e948:	66 25       	ld.w	r5,r3[0x8]
8000e94a:	58 05       	cp.w	r5,0
8000e94c:	c0 c1       	brne	8000e964 <__pow5mult+0x54>
8000e94e:	e0 6b 02 71 	mov	r11,625
8000e952:	0e 9c       	mov	r12,r7
8000e954:	c9 8f       	rcall	8000e884 <__i2b>
8000e956:	87 2c       	st.w	r3[0x8],r12
8000e958:	30 08       	mov	r8,0
8000e95a:	18 95       	mov	r5,r12
8000e95c:	99 08       	st.w	r12[0x0],r8
8000e95e:	c0 38       	rjmp	8000e964 <__pow5mult+0x54>
8000e960:	06 9c       	mov	r12,r3
8000e962:	18 95       	mov	r5,r12
8000e964:	ed b6 00 00 	bld	r6,0x0
8000e968:	c0 b1       	brne	8000e97e <__pow5mult+0x6e>
8000e96a:	08 9b       	mov	r11,r4
8000e96c:	0a 9a       	mov	r10,r5
8000e96e:	0e 9c       	mov	r12,r7
8000e970:	c0 af       	rcall	8000e784 <__multiply>
8000e972:	08 9b       	mov	r11,r4
8000e974:	18 93       	mov	r3,r12
8000e976:	0e 9c       	mov	r12,r7
8000e978:	06 94       	mov	r4,r3
8000e97a:	fe b0 fd b7 	rcall	8000e4e8 <_Bfree>
8000e97e:	a1 56       	asr	r6,0x1
8000e980:	c0 b0       	breq	8000e996 <__pow5mult+0x86>
8000e982:	6a 03       	ld.w	r3,r5[0x0]
8000e984:	58 03       	cp.w	r3,0
8000e986:	ce d1       	brne	8000e960 <__pow5mult+0x50>
8000e988:	0a 9a       	mov	r10,r5
8000e98a:	0a 9b       	mov	r11,r5
8000e98c:	0e 9c       	mov	r12,r7
8000e98e:	cf be       	rcall	8000e784 <__multiply>
8000e990:	8b 0c       	st.w	r5[0x0],r12
8000e992:	99 03       	st.w	r12[0x0],r3
8000e994:	ce 7b       	rjmp	8000e962 <__pow5mult+0x52>
8000e996:	08 9c       	mov	r12,r4
8000e998:	d8 32       	popm	r0-r7,pc
8000e99a:	d7 03       	nop
8000e99c:	80 01       	ld.sh	r1,r0[0x0]
8000e99e:	93 74       	st.w	r9[0x1c],r4

8000e9a0 <__isinfd>:
8000e9a0:	14 98       	mov	r8,r10
8000e9a2:	fc 19 7f f0 	movh	r9,0x7ff0
8000e9a6:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000e9aa:	f0 0b 11 00 	rsub	r11,r8,0
8000e9ae:	f7 e8 10 08 	or	r8,r11,r8
8000e9b2:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000e9b6:	f2 08 01 08 	sub	r8,r9,r8
8000e9ba:	f0 0c 11 00 	rsub	r12,r8,0
8000e9be:	f9 e8 10 08 	or	r8,r12,r8
8000e9c2:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000e9c6:	2f fc       	sub	r12,-1
8000e9c8:	5e fc       	retal	r12

8000e9ca <__isnand>:
8000e9ca:	14 98       	mov	r8,r10
8000e9cc:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000e9d0:	f0 0c 11 00 	rsub	r12,r8,0
8000e9d4:	10 4c       	or	r12,r8
8000e9d6:	fc 18 7f f0 	movh	r8,0x7ff0
8000e9da:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000e9de:	f0 0c 01 0c 	sub	r12,r8,r12
8000e9e2:	bf 9c       	lsr	r12,0x1f
8000e9e4:	5e fc       	retal	r12
8000e9e6:	d7 03       	nop

8000e9e8 <__sclose>:
8000e9e8:	d4 01       	pushm	lr
8000e9ea:	96 7b       	ld.sh	r11,r11[0xe]
8000e9ec:	c7 6c       	rcall	8000ead8 <_close_r>
8000e9ee:	d8 02       	popm	pc

8000e9f0 <__sseek>:
8000e9f0:	d4 21       	pushm	r4-r7,lr
8000e9f2:	16 97       	mov	r7,r11
8000e9f4:	96 7b       	ld.sh	r11,r11[0xe]
8000e9f6:	cf 9c       	rcall	8000ebe8 <_lseek_r>
8000e9f8:	8e 68       	ld.sh	r8,r7[0xc]
8000e9fa:	10 99       	mov	r9,r8
8000e9fc:	ad c8       	cbr	r8,0xc
8000e9fe:	ad a9       	sbr	r9,0xc
8000ea00:	5b fc       	cp.w	r12,-1
8000ea02:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000ea06:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000ea0a:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000ea0e:	d8 22       	popm	r4-r7,pc

8000ea10 <__swrite>:
8000ea10:	d4 21       	pushm	r4-r7,lr
8000ea12:	96 68       	ld.sh	r8,r11[0xc]
8000ea14:	16 97       	mov	r7,r11
8000ea16:	14 95       	mov	r5,r10
8000ea18:	12 94       	mov	r4,r9
8000ea1a:	e2 18 01 00 	andl	r8,0x100,COH
8000ea1e:	18 96       	mov	r6,r12
8000ea20:	c0 50       	breq	8000ea2a <__swrite+0x1a>
8000ea22:	30 29       	mov	r9,2
8000ea24:	30 0a       	mov	r10,0
8000ea26:	96 7b       	ld.sh	r11,r11[0xe]
8000ea28:	ce 0c       	rcall	8000ebe8 <_lseek_r>
8000ea2a:	8e 68       	ld.sh	r8,r7[0xc]
8000ea2c:	ad c8       	cbr	r8,0xc
8000ea2e:	08 99       	mov	r9,r4
8000ea30:	0a 9a       	mov	r10,r5
8000ea32:	8e 7b       	ld.sh	r11,r7[0xe]
8000ea34:	0c 9c       	mov	r12,r6
8000ea36:	ae 68       	st.h	r7[0xc],r8
8000ea38:	c1 0c       	rcall	8000ea58 <_write_r>
8000ea3a:	d8 22       	popm	r4-r7,pc

8000ea3c <__sread>:
8000ea3c:	d4 21       	pushm	r4-r7,lr
8000ea3e:	16 97       	mov	r7,r11
8000ea40:	96 7b       	ld.sh	r11,r11[0xe]
8000ea42:	ce 7c       	rcall	8000ec10 <_read_r>
8000ea44:	c0 65       	brlt	8000ea50 <__sread+0x14>
8000ea46:	6f 58       	ld.w	r8,r7[0x54]
8000ea48:	18 08       	add	r8,r12
8000ea4a:	ef 48 00 54 	st.w	r7[84],r8
8000ea4e:	d8 22       	popm	r4-r7,pc
8000ea50:	8e 68       	ld.sh	r8,r7[0xc]
8000ea52:	ad c8       	cbr	r8,0xc
8000ea54:	ae 68       	st.h	r7[0xc],r8
8000ea56:	d8 22       	popm	r4-r7,pc

8000ea58 <_write_r>:
8000ea58:	d4 21       	pushm	r4-r7,lr
8000ea5a:	16 98       	mov	r8,r11
8000ea5c:	18 97       	mov	r7,r12
8000ea5e:	10 9c       	mov	r12,r8
8000ea60:	30 08       	mov	r8,0
8000ea62:	14 9b       	mov	r11,r10
8000ea64:	e0 66 46 28 	mov	r6,17960
8000ea68:	12 9a       	mov	r10,r9
8000ea6a:	8d 08       	st.w	r6[0x0],r8
8000ea6c:	fe b0 d0 56 	rcall	80008b18 <_write>
8000ea70:	5b fc       	cp.w	r12,-1
8000ea72:	c0 51       	brne	8000ea7c <_write_r+0x24>
8000ea74:	6c 08       	ld.w	r8,r6[0x0]
8000ea76:	58 08       	cp.w	r8,0
8000ea78:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ea7c:	d8 22       	popm	r4-r7,pc
8000ea7e:	d7 03       	nop

8000ea80 <_calloc_r>:
8000ea80:	d4 21       	pushm	r4-r7,lr
8000ea82:	f4 0b 02 4b 	mul	r11,r10,r11
8000ea86:	fe b0 da d1 	rcall	8000a028 <_malloc_r>
8000ea8a:	18 97       	mov	r7,r12
8000ea8c:	c2 30       	breq	8000ead2 <_calloc_r+0x52>
8000ea8e:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000ea92:	e0 1a ff fc 	andl	r10,0xfffc
8000ea96:	20 4a       	sub	r10,4
8000ea98:	e0 4a 00 24 	cp.w	r10,36
8000ea9c:	e0 8b 00 18 	brhi	8000eacc <_calloc_r+0x4c>
8000eaa0:	18 98       	mov	r8,r12
8000eaa2:	59 3a       	cp.w	r10,19
8000eaa4:	e0 88 00 0f 	brls	8000eac2 <_calloc_r+0x42>
8000eaa8:	30 09       	mov	r9,0
8000eaaa:	10 a9       	st.w	r8++,r9
8000eaac:	10 a9       	st.w	r8++,r9
8000eaae:	59 ba       	cp.w	r10,27
8000eab0:	e0 88 00 09 	brls	8000eac2 <_calloc_r+0x42>
8000eab4:	10 a9       	st.w	r8++,r9
8000eab6:	10 a9       	st.w	r8++,r9
8000eab8:	e0 4a 00 24 	cp.w	r10,36
8000eabc:	c0 31       	brne	8000eac2 <_calloc_r+0x42>
8000eabe:	10 a9       	st.w	r8++,r9
8000eac0:	10 a9       	st.w	r8++,r9
8000eac2:	30 09       	mov	r9,0
8000eac4:	10 a9       	st.w	r8++,r9
8000eac6:	91 19       	st.w	r8[0x4],r9
8000eac8:	91 09       	st.w	r8[0x0],r9
8000eaca:	c0 48       	rjmp	8000ead2 <_calloc_r+0x52>
8000eacc:	30 0b       	mov	r11,0
8000eace:	fe b0 dd 80 	rcall	8000a5ce <memset>
8000ead2:	0e 9c       	mov	r12,r7
8000ead4:	d8 22       	popm	r4-r7,pc
8000ead6:	d7 03       	nop

8000ead8 <_close_r>:
8000ead8:	d4 21       	pushm	r4-r7,lr
8000eada:	30 08       	mov	r8,0
8000eadc:	18 97       	mov	r7,r12
8000eade:	e0 66 46 28 	mov	r6,17960
8000eae2:	16 9c       	mov	r12,r11
8000eae4:	8d 08       	st.w	r6[0x0],r8
8000eae6:	fe b0 df a5 	rcall	8000aa30 <_close>
8000eaea:	5b fc       	cp.w	r12,-1
8000eaec:	c0 51       	brne	8000eaf6 <_close_r+0x1e>
8000eaee:	6c 08       	ld.w	r8,r6[0x0]
8000eaf0:	58 08       	cp.w	r8,0
8000eaf2:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000eaf6:	d8 22       	popm	r4-r7,pc

8000eaf8 <_fclose_r>:
8000eaf8:	d4 21       	pushm	r4-r7,lr
8000eafa:	18 96       	mov	r6,r12
8000eafc:	16 97       	mov	r7,r11
8000eafe:	58 0b       	cp.w	r11,0
8000eb00:	c0 31       	brne	8000eb06 <_fclose_r+0xe>
8000eb02:	16 95       	mov	r5,r11
8000eb04:	c5 08       	rjmp	8000eba4 <_fclose_r+0xac>
8000eb06:	fe b0 f8 b1 	rcall	8000dc68 <__sfp_lock_acquire>
8000eb0a:	58 06       	cp.w	r6,0
8000eb0c:	c0 70       	breq	8000eb1a <_fclose_r+0x22>
8000eb0e:	6c 68       	ld.w	r8,r6[0x18]
8000eb10:	58 08       	cp.w	r8,0
8000eb12:	c0 41       	brne	8000eb1a <_fclose_r+0x22>
8000eb14:	0c 9c       	mov	r12,r6
8000eb16:	fe b0 f8 fd 	rcall	8000dd10 <__sinit>
8000eb1a:	4a 48       	lddpc	r8,8000eba8 <_fclose_r+0xb0>
8000eb1c:	10 37       	cp.w	r7,r8
8000eb1e:	c0 31       	brne	8000eb24 <_fclose_r+0x2c>
8000eb20:	6c 07       	ld.w	r7,r6[0x0]
8000eb22:	c0 a8       	rjmp	8000eb36 <_fclose_r+0x3e>
8000eb24:	4a 28       	lddpc	r8,8000ebac <_fclose_r+0xb4>
8000eb26:	10 37       	cp.w	r7,r8
8000eb28:	c0 31       	brne	8000eb2e <_fclose_r+0x36>
8000eb2a:	6c 17       	ld.w	r7,r6[0x4]
8000eb2c:	c0 58       	rjmp	8000eb36 <_fclose_r+0x3e>
8000eb2e:	4a 18       	lddpc	r8,8000ebb0 <_fclose_r+0xb8>
8000eb30:	10 37       	cp.w	r7,r8
8000eb32:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000eb36:	8e 69       	ld.sh	r9,r7[0xc]
8000eb38:	30 08       	mov	r8,0
8000eb3a:	f0 09 19 00 	cp.h	r9,r8
8000eb3e:	c0 51       	brne	8000eb48 <_fclose_r+0x50>
8000eb40:	fe b0 f8 95 	rcall	8000dc6a <__sfp_lock_release>
8000eb44:	30 05       	mov	r5,0
8000eb46:	c2 f8       	rjmp	8000eba4 <_fclose_r+0xac>
8000eb48:	0e 9b       	mov	r11,r7
8000eb4a:	0c 9c       	mov	r12,r6
8000eb4c:	fe b0 f8 06 	rcall	8000db58 <_fflush_r>
8000eb50:	6e c8       	ld.w	r8,r7[0x30]
8000eb52:	18 95       	mov	r5,r12
8000eb54:	58 08       	cp.w	r8,0
8000eb56:	c0 60       	breq	8000eb62 <_fclose_r+0x6a>
8000eb58:	6e 8b       	ld.w	r11,r7[0x20]
8000eb5a:	0c 9c       	mov	r12,r6
8000eb5c:	5d 18       	icall	r8
8000eb5e:	f9 b5 05 ff 	movlt	r5,-1
8000eb62:	8e 68       	ld.sh	r8,r7[0xc]
8000eb64:	ed b8 00 07 	bld	r8,0x7
8000eb68:	c0 51       	brne	8000eb72 <_fclose_r+0x7a>
8000eb6a:	6e 4b       	ld.w	r11,r7[0x10]
8000eb6c:	0c 9c       	mov	r12,r6
8000eb6e:	fe b0 f9 6b 	rcall	8000de44 <_free_r>
8000eb72:	6e db       	ld.w	r11,r7[0x34]
8000eb74:	58 0b       	cp.w	r11,0
8000eb76:	c0 a0       	breq	8000eb8a <_fclose_r+0x92>
8000eb78:	ee c8 ff bc 	sub	r8,r7,-68
8000eb7c:	10 3b       	cp.w	r11,r8
8000eb7e:	c0 40       	breq	8000eb86 <_fclose_r+0x8e>
8000eb80:	0c 9c       	mov	r12,r6
8000eb82:	fe b0 f9 61 	rcall	8000de44 <_free_r>
8000eb86:	30 08       	mov	r8,0
8000eb88:	8f d8       	st.w	r7[0x34],r8
8000eb8a:	6f 2b       	ld.w	r11,r7[0x48]
8000eb8c:	58 0b       	cp.w	r11,0
8000eb8e:	c0 70       	breq	8000eb9c <_fclose_r+0xa4>
8000eb90:	0c 9c       	mov	r12,r6
8000eb92:	fe b0 f9 59 	rcall	8000de44 <_free_r>
8000eb96:	30 08       	mov	r8,0
8000eb98:	ef 48 00 48 	st.w	r7[72],r8
8000eb9c:	30 08       	mov	r8,0
8000eb9e:	ae 68       	st.h	r7[0xc],r8
8000eba0:	fe b0 f8 65 	rcall	8000dc6a <__sfp_lock_release>
8000eba4:	0a 9c       	mov	r12,r5
8000eba6:	d8 22       	popm	r4-r7,pc
8000eba8:	80 01       	ld.sh	r1,r0[0x0]
8000ebaa:	92 d0       	ld.uh	r0,r9[0xa]
8000ebac:	80 01       	ld.sh	r1,r0[0x0]
8000ebae:	92 f0       	ld.uh	r0,r9[0xe]
8000ebb0:	80 01       	ld.sh	r1,r0[0x0]
8000ebb2:	93 10       	st.w	r9[0x4],r0

8000ebb4 <fclose>:
8000ebb4:	d4 01       	pushm	lr
8000ebb6:	e0 68 0a 38 	mov	r8,2616
8000ebba:	18 9b       	mov	r11,r12
8000ebbc:	70 0c       	ld.w	r12,r8[0x0]
8000ebbe:	c9 df       	rcall	8000eaf8 <_fclose_r>
8000ebc0:	d8 02       	popm	pc
8000ebc2:	d7 03       	nop

8000ebc4 <_fstat_r>:
8000ebc4:	d4 21       	pushm	r4-r7,lr
8000ebc6:	16 98       	mov	r8,r11
8000ebc8:	18 97       	mov	r7,r12
8000ebca:	10 9c       	mov	r12,r8
8000ebcc:	30 08       	mov	r8,0
8000ebce:	e0 66 46 28 	mov	r6,17960
8000ebd2:	14 9b       	mov	r11,r10
8000ebd4:	8d 08       	st.w	r6[0x0],r8
8000ebd6:	fe b0 df 55 	rcall	8000aa80 <_fstat>
8000ebda:	5b fc       	cp.w	r12,-1
8000ebdc:	c0 51       	brne	8000ebe6 <_fstat_r+0x22>
8000ebde:	6c 08       	ld.w	r8,r6[0x0]
8000ebe0:	58 08       	cp.w	r8,0
8000ebe2:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ebe6:	d8 22       	popm	r4-r7,pc

8000ebe8 <_lseek_r>:
8000ebe8:	d4 21       	pushm	r4-r7,lr
8000ebea:	16 98       	mov	r8,r11
8000ebec:	18 97       	mov	r7,r12
8000ebee:	10 9c       	mov	r12,r8
8000ebf0:	30 08       	mov	r8,0
8000ebf2:	14 9b       	mov	r11,r10
8000ebf4:	e0 66 46 28 	mov	r6,17960
8000ebf8:	12 9a       	mov	r10,r9
8000ebfa:	8d 08       	st.w	r6[0x0],r8
8000ebfc:	fe b0 df 24 	rcall	8000aa44 <_lseek>
8000ec00:	5b fc       	cp.w	r12,-1
8000ec02:	c0 51       	brne	8000ec0c <_lseek_r+0x24>
8000ec04:	6c 08       	ld.w	r8,r6[0x0]
8000ec06:	58 08       	cp.w	r8,0
8000ec08:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ec0c:	d8 22       	popm	r4-r7,pc
8000ec0e:	d7 03       	nop

8000ec10 <_read_r>:
8000ec10:	d4 21       	pushm	r4-r7,lr
8000ec12:	16 98       	mov	r8,r11
8000ec14:	18 97       	mov	r7,r12
8000ec16:	10 9c       	mov	r12,r8
8000ec18:	30 08       	mov	r8,0
8000ec1a:	14 9b       	mov	r11,r10
8000ec1c:	e0 66 46 28 	mov	r6,17960
8000ec20:	12 9a       	mov	r10,r9
8000ec22:	8d 08       	st.w	r6[0x0],r8
8000ec24:	fe b0 cf 5a 	rcall	80008ad8 <_read>
8000ec28:	5b fc       	cp.w	r12,-1
8000ec2a:	c0 51       	brne	8000ec34 <_read_r+0x24>
8000ec2c:	6c 08       	ld.w	r8,r6[0x0]
8000ec2e:	58 08       	cp.w	r8,0
8000ec30:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ec34:	d8 22       	popm	r4-r7,pc
8000ec36:	d7 03       	nop

8000ec38 <__avr32_f64_mul>:
8000ec38:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000ec3c:	e0 80 00 dc 	breq	8000edf4 <__avr32_f64_mul_op1_zero>
8000ec40:	d4 21       	pushm	r4-r7,lr
8000ec42:	f7 e9 20 0e 	eor	lr,r11,r9
8000ec46:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ec4a:	30 15       	mov	r5,1
8000ec4c:	c4 30       	breq	8000ecd2 <__avr32_f64_mul_op1_subnormal>
8000ec4e:	ab 6b       	lsl	r11,0xa
8000ec50:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000ec54:	ab 6a       	lsl	r10,0xa
8000ec56:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000ec5a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ec5e:	c5 c0       	breq	8000ed16 <__avr32_f64_mul_op2_subnormal>
8000ec60:	a1 78       	lsl	r8,0x1
8000ec62:	5c f9       	rol	r9
8000ec64:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000ec68:	e0 47 07 ff 	cp.w	r7,2047
8000ec6c:	c7 70       	breq	8000ed5a <__avr32_f64_mul_op_nan_or_inf>
8000ec6e:	e0 46 07 ff 	cp.w	r6,2047
8000ec72:	c7 40       	breq	8000ed5a <__avr32_f64_mul_op_nan_or_inf>
8000ec74:	ee 06 00 0c 	add	r12,r7,r6
8000ec78:	e0 2c 03 fe 	sub	r12,1022
8000ec7c:	f6 08 06 44 	mulu.d	r4,r11,r8
8000ec80:	f4 09 07 44 	macu.d	r4,r10,r9
8000ec84:	f4 08 06 46 	mulu.d	r6,r10,r8
8000ec88:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000ec8c:	08 07       	add	r7,r4
8000ec8e:	f4 05 00 4a 	adc	r10,r10,r5
8000ec92:	5c 0b       	acr	r11
8000ec94:	ed bb 00 14 	bld	r11,0x14
8000ec98:	c0 50       	breq	8000eca2 <__avr32_f64_mul+0x6a>
8000ec9a:	a1 77       	lsl	r7,0x1
8000ec9c:	5c fa       	rol	r10
8000ec9e:	5c fb       	rol	r11
8000eca0:	20 1c       	sub	r12,1
8000eca2:	58 0c       	cp.w	r12,0
8000eca4:	e0 8a 00 6f 	brle	8000ed82 <__avr32_f64_mul_res_subnormal>
8000eca8:	e0 4c 07 ff 	cp.w	r12,2047
8000ecac:	e0 84 00 9c 	brge	8000ede4 <__avr32_f64_mul_res_inf>
8000ecb0:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000ecb4:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000ecb8:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000ecbc:	ee 17 80 00 	eorh	r7,0x8000
8000ecc0:	f1 b7 04 20 	satu	r7,0x1
8000ecc4:	0e 0a       	add	r10,r7
8000ecc6:	5c 0b       	acr	r11
8000ecc8:	ed be 00 1f 	bld	lr,0x1f
8000eccc:	ef bb 00 1f 	bst	r11,0x1f
8000ecd0:	d8 22       	popm	r4-r7,pc

8000ecd2 <__avr32_f64_mul_op1_subnormal>:
8000ecd2:	e4 1b 00 0f 	andh	r11,0xf
8000ecd6:	f4 0c 12 00 	clz	r12,r10
8000ecda:	f6 06 12 00 	clz	r6,r11
8000ecde:	f7 bc 03 e1 	sublo	r12,-31
8000ece2:	f8 06 17 30 	movlo	r6,r12
8000ece6:	f7 b6 02 01 	subhs	r6,1
8000ecea:	e0 46 00 20 	cp.w	r6,32
8000ecee:	c0 d4       	brge	8000ed08 <__avr32_f64_mul_op1_subnormal+0x36>
8000ecf0:	ec 0c 11 20 	rsub	r12,r6,32
8000ecf4:	f6 06 09 4b 	lsl	r11,r11,r6
8000ecf8:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000ecfc:	18 4b       	or	r11,r12
8000ecfe:	f4 06 09 4a 	lsl	r10,r10,r6
8000ed02:	20 b6       	sub	r6,11
8000ed04:	0c 17       	sub	r7,r6
8000ed06:	ca ab       	rjmp	8000ec5a <__avr32_f64_mul+0x22>
8000ed08:	f4 06 09 4b 	lsl	r11,r10,r6
8000ed0c:	c6 40       	breq	8000edd4 <__avr32_f64_mul_res_zero>
8000ed0e:	30 0a       	mov	r10,0
8000ed10:	20 b6       	sub	r6,11
8000ed12:	0c 17       	sub	r7,r6
8000ed14:	ca 3b       	rjmp	8000ec5a <__avr32_f64_mul+0x22>

8000ed16 <__avr32_f64_mul_op2_subnormal>:
8000ed16:	e4 19 00 0f 	andh	r9,0xf
8000ed1a:	f0 0c 12 00 	clz	r12,r8
8000ed1e:	f2 05 12 00 	clz	r5,r9
8000ed22:	f7 bc 03 ea 	sublo	r12,-22
8000ed26:	f8 05 17 30 	movlo	r5,r12
8000ed2a:	f7 b5 02 0a 	subhs	r5,10
8000ed2e:	e0 45 00 20 	cp.w	r5,32
8000ed32:	c0 d4       	brge	8000ed4c <__avr32_f64_mul_op2_subnormal+0x36>
8000ed34:	ea 0c 11 20 	rsub	r12,r5,32
8000ed38:	f2 05 09 49 	lsl	r9,r9,r5
8000ed3c:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000ed40:	18 49       	or	r9,r12
8000ed42:	f0 05 09 48 	lsl	r8,r8,r5
8000ed46:	20 25       	sub	r5,2
8000ed48:	0a 16       	sub	r6,r5
8000ed4a:	c8 fb       	rjmp	8000ec68 <__avr32_f64_mul+0x30>
8000ed4c:	f0 05 09 49 	lsl	r9,r8,r5
8000ed50:	c4 20       	breq	8000edd4 <__avr32_f64_mul_res_zero>
8000ed52:	30 08       	mov	r8,0
8000ed54:	20 25       	sub	r5,2
8000ed56:	0a 16       	sub	r6,r5
8000ed58:	c8 8b       	rjmp	8000ec68 <__avr32_f64_mul+0x30>

8000ed5a <__avr32_f64_mul_op_nan_or_inf>:
8000ed5a:	e4 19 00 0f 	andh	r9,0xf
8000ed5e:	e4 1b 00 0f 	andh	r11,0xf
8000ed62:	14 4b       	or	r11,r10
8000ed64:	10 49       	or	r9,r8
8000ed66:	e0 47 07 ff 	cp.w	r7,2047
8000ed6a:	c0 91       	brne	8000ed7c <__avr32_f64_mul_op1_not_naninf>
8000ed6c:	58 0b       	cp.w	r11,0
8000ed6e:	c3 81       	brne	8000edde <__avr32_f64_mul_res_nan>
8000ed70:	e0 46 07 ff 	cp.w	r6,2047
8000ed74:	c3 81       	brne	8000ede4 <__avr32_f64_mul_res_inf>
8000ed76:	58 09       	cp.w	r9,0
8000ed78:	c3 60       	breq	8000ede4 <__avr32_f64_mul_res_inf>
8000ed7a:	c3 28       	rjmp	8000edde <__avr32_f64_mul_res_nan>

8000ed7c <__avr32_f64_mul_op1_not_naninf>:
8000ed7c:	58 09       	cp.w	r9,0
8000ed7e:	c3 30       	breq	8000ede4 <__avr32_f64_mul_res_inf>
8000ed80:	c2 f8       	rjmp	8000edde <__avr32_f64_mul_res_nan>

8000ed82 <__avr32_f64_mul_res_subnormal>:
8000ed82:	5c 3c       	neg	r12
8000ed84:	2f fc       	sub	r12,-1
8000ed86:	f1 bc 04 c0 	satu	r12,0x6
8000ed8a:	e0 4c 00 20 	cp.w	r12,32
8000ed8e:	c1 14       	brge	8000edb0 <__avr32_f64_mul_res_subnormal+0x2e>
8000ed90:	f8 08 11 20 	rsub	r8,r12,32
8000ed94:	0e 46       	or	r6,r7
8000ed96:	ee 0c 0a 47 	lsr	r7,r7,r12
8000ed9a:	f4 08 09 49 	lsl	r9,r10,r8
8000ed9e:	12 47       	or	r7,r9
8000eda0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000eda4:	f6 08 09 49 	lsl	r9,r11,r8
8000eda8:	12 4a       	or	r10,r9
8000edaa:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000edae:	c8 3b       	rjmp	8000ecb4 <__avr32_f64_mul+0x7c>
8000edb0:	f8 08 11 20 	rsub	r8,r12,32
8000edb4:	f9 b9 00 00 	moveq	r9,0
8000edb8:	c0 30       	breq	8000edbe <__avr32_f64_mul_res_subnormal+0x3c>
8000edba:	f6 08 09 49 	lsl	r9,r11,r8
8000edbe:	0e 46       	or	r6,r7
8000edc0:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000edc4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000edc8:	f3 ea 10 07 	or	r7,r9,r10
8000edcc:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000edd0:	30 0b       	mov	r11,0
8000edd2:	c7 1b       	rjmp	8000ecb4 <__avr32_f64_mul+0x7c>

8000edd4 <__avr32_f64_mul_res_zero>:
8000edd4:	1c 9b       	mov	r11,lr
8000edd6:	e6 1b 80 00 	andh	r11,0x8000,COH
8000edda:	30 0a       	mov	r10,0
8000eddc:	d8 22       	popm	r4-r7,pc

8000edde <__avr32_f64_mul_res_nan>:
8000edde:	3f fb       	mov	r11,-1
8000ede0:	3f fa       	mov	r10,-1
8000ede2:	d8 22       	popm	r4-r7,pc

8000ede4 <__avr32_f64_mul_res_inf>:
8000ede4:	f0 6b 00 00 	mov	r11,-1048576
8000ede8:	ed be 00 1f 	bld	lr,0x1f
8000edec:	ef bb 00 1f 	bst	r11,0x1f
8000edf0:	30 0a       	mov	r10,0
8000edf2:	d8 22       	popm	r4-r7,pc

8000edf4 <__avr32_f64_mul_op1_zero>:
8000edf4:	f7 e9 20 0b 	eor	r11,r11,r9
8000edf8:	e6 1b 80 00 	andh	r11,0x8000,COH
8000edfc:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000ee00:	e0 4c 07 ff 	cp.w	r12,2047
8000ee04:	5e 1c       	retne	r12
8000ee06:	3f fa       	mov	r10,-1
8000ee08:	3f fb       	mov	r11,-1
8000ee0a:	5e fc       	retal	r12

8000ee0c <__avr32_f64_sub_from_add>:
8000ee0c:	ee 19 80 00 	eorh	r9,0x8000

8000ee10 <__avr32_f64_sub>:
8000ee10:	f7 e9 20 0c 	eor	r12,r11,r9
8000ee14:	e0 86 00 ca 	brmi	8000efa8 <__avr32_f64_add_from_sub>
8000ee18:	eb cd 40 e0 	pushm	r5-r7,lr
8000ee1c:	16 9c       	mov	r12,r11
8000ee1e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ee22:	bf db       	cbr	r11,0x1f
8000ee24:	bf d9       	cbr	r9,0x1f
8000ee26:	10 3a       	cp.w	r10,r8
8000ee28:	f2 0b 13 00 	cpc	r11,r9
8000ee2c:	c0 92       	brcc	8000ee3e <__avr32_f64_sub+0x2e>
8000ee2e:	16 97       	mov	r7,r11
8000ee30:	12 9b       	mov	r11,r9
8000ee32:	0e 99       	mov	r9,r7
8000ee34:	14 97       	mov	r7,r10
8000ee36:	10 9a       	mov	r10,r8
8000ee38:	0e 98       	mov	r8,r7
8000ee3a:	ee 1c 80 00 	eorh	r12,0x8000
8000ee3e:	f6 07 16 14 	lsr	r7,r11,0x14
8000ee42:	ab 7b       	lsl	r11,0xb
8000ee44:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000ee48:	ab 7a       	lsl	r10,0xb
8000ee4a:	bf bb       	sbr	r11,0x1f
8000ee4c:	f2 06 16 14 	lsr	r6,r9,0x14
8000ee50:	c4 40       	breq	8000eed8 <__avr32_f64_sub_opL_subnormal>
8000ee52:	ab 79       	lsl	r9,0xb
8000ee54:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000ee58:	ab 78       	lsl	r8,0xb
8000ee5a:	bf b9       	sbr	r9,0x1f

8000ee5c <__avr32_f64_sub_opL_subnormal_done>:
8000ee5c:	e0 47 07 ff 	cp.w	r7,2047
8000ee60:	c4 f0       	breq	8000eefe <__avr32_f64_sub_opH_nan_or_inf>
8000ee62:	0e 26       	rsub	r6,r7
8000ee64:	c1 20       	breq	8000ee88 <__avr32_f64_sub_shift_done>
8000ee66:	ec 05 11 20 	rsub	r5,r6,32
8000ee6a:	e0 46 00 20 	cp.w	r6,32
8000ee6e:	c7 c2       	brcc	8000ef66 <__avr32_f64_sub_longshift>
8000ee70:	f0 05 09 4e 	lsl	lr,r8,r5
8000ee74:	f2 05 09 45 	lsl	r5,r9,r5
8000ee78:	f0 06 0a 48 	lsr	r8,r8,r6
8000ee7c:	f2 06 0a 49 	lsr	r9,r9,r6
8000ee80:	0a 48       	or	r8,r5
8000ee82:	58 0e       	cp.w	lr,0
8000ee84:	5f 1e       	srne	lr
8000ee86:	1c 48       	or	r8,lr

8000ee88 <__avr32_f64_sub_shift_done>:
8000ee88:	10 1a       	sub	r10,r8
8000ee8a:	f6 09 01 4b 	sbc	r11,r11,r9
8000ee8e:	f6 06 12 00 	clz	r6,r11
8000ee92:	c0 e0       	breq	8000eeae <__avr32_f64_sub_longnormalize_done>
8000ee94:	c7 83       	brcs	8000ef84 <__avr32_f64_sub_longnormalize>
8000ee96:	ec 0e 11 20 	rsub	lr,r6,32
8000ee9a:	f6 06 09 4b 	lsl	r11,r11,r6
8000ee9e:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000eea2:	1c 4b       	or	r11,lr
8000eea4:	f4 06 09 4a 	lsl	r10,r10,r6
8000eea8:	0c 17       	sub	r7,r6
8000eeaa:	e0 8a 00 39 	brle	8000ef1c <__avr32_f64_sub_subnormal_result>

8000eeae <__avr32_f64_sub_longnormalize_done>:
8000eeae:	f4 09 15 15 	lsl	r9,r10,0x15
8000eeb2:	ab 9a       	lsr	r10,0xb
8000eeb4:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000eeb8:	ab 9b       	lsr	r11,0xb
8000eeba:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000eebe:	18 4b       	or	r11,r12

8000eec0 <__avr32_f64_sub_round>:
8000eec0:	fc 17 80 00 	movh	r7,0x8000
8000eec4:	ed ba 00 00 	bld	r10,0x0
8000eec8:	f7 b7 01 ff 	subne	r7,-1
8000eecc:	0e 39       	cp.w	r9,r7
8000eece:	5f 29       	srhs	r9
8000eed0:	12 0a       	add	r10,r9
8000eed2:	5c 0b       	acr	r11
8000eed4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000eed8 <__avr32_f64_sub_opL_subnormal>:
8000eed8:	ab 79       	lsl	r9,0xb
8000eeda:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000eede:	ab 78       	lsl	r8,0xb
8000eee0:	f3 e8 10 0e 	or	lr,r9,r8
8000eee4:	f9 b6 01 01 	movne	r6,1
8000eee8:	ee 0e 11 00 	rsub	lr,r7,0
8000eeec:	f9 b7 00 01 	moveq	r7,1
8000eef0:	ef bb 00 1f 	bst	r11,0x1f
8000eef4:	f7 ea 10 0e 	or	lr,r11,r10
8000eef8:	f9 b7 00 00 	moveq	r7,0
8000eefc:	cb 0b       	rjmp	8000ee5c <__avr32_f64_sub_opL_subnormal_done>

8000eefe <__avr32_f64_sub_opH_nan_or_inf>:
8000eefe:	bf db       	cbr	r11,0x1f
8000ef00:	f7 ea 10 0e 	or	lr,r11,r10
8000ef04:	c0 81       	brne	8000ef14 <__avr32_f64_sub_return_nan>
8000ef06:	e0 46 07 ff 	cp.w	r6,2047
8000ef0a:	c0 50       	breq	8000ef14 <__avr32_f64_sub_return_nan>
8000ef0c:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000ef10:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ef14 <__avr32_f64_sub_return_nan>:
8000ef14:	3f fa       	mov	r10,-1
8000ef16:	3f fb       	mov	r11,-1
8000ef18:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ef1c <__avr32_f64_sub_subnormal_result>:
8000ef1c:	5c 37       	neg	r7
8000ef1e:	2f f7       	sub	r7,-1
8000ef20:	f1 b7 04 c0 	satu	r7,0x6
8000ef24:	e0 47 00 20 	cp.w	r7,32
8000ef28:	c1 14       	brge	8000ef4a <__avr32_f64_sub_subnormal_result+0x2e>
8000ef2a:	ee 08 11 20 	rsub	r8,r7,32
8000ef2e:	f4 08 09 49 	lsl	r9,r10,r8
8000ef32:	5f 16       	srne	r6
8000ef34:	f4 07 0a 4a 	lsr	r10,r10,r7
8000ef38:	0c 4a       	or	r10,r6
8000ef3a:	f6 08 09 49 	lsl	r9,r11,r8
8000ef3e:	f5 e9 10 0a 	or	r10,r10,r9
8000ef42:	f4 07 0a 4b 	lsr	r11,r10,r7
8000ef46:	30 07       	mov	r7,0
8000ef48:	cb 3b       	rjmp	8000eeae <__avr32_f64_sub_longnormalize_done>
8000ef4a:	ee 08 11 40 	rsub	r8,r7,64
8000ef4e:	f6 08 09 49 	lsl	r9,r11,r8
8000ef52:	14 49       	or	r9,r10
8000ef54:	5f 16       	srne	r6
8000ef56:	f6 07 0a 4a 	lsr	r10,r11,r7
8000ef5a:	0c 4a       	or	r10,r6
8000ef5c:	30 0b       	mov	r11,0
8000ef5e:	30 07       	mov	r7,0
8000ef60:	ca 7b       	rjmp	8000eeae <__avr32_f64_sub_longnormalize_done>
8000ef62:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ef66 <__avr32_f64_sub_longshift>:
8000ef66:	f1 b6 04 c0 	satu	r6,0x6
8000ef6a:	f0 0e 17 00 	moveq	lr,r8
8000ef6e:	c0 40       	breq	8000ef76 <__avr32_f64_sub_longshift+0x10>
8000ef70:	f2 05 09 4e 	lsl	lr,r9,r5
8000ef74:	10 4e       	or	lr,r8
8000ef76:	f2 06 0a 48 	lsr	r8,r9,r6
8000ef7a:	30 09       	mov	r9,0
8000ef7c:	58 0e       	cp.w	lr,0
8000ef7e:	5f 1e       	srne	lr
8000ef80:	1c 48       	or	r8,lr
8000ef82:	c8 3b       	rjmp	8000ee88 <__avr32_f64_sub_shift_done>

8000ef84 <__avr32_f64_sub_longnormalize>:
8000ef84:	f4 06 12 00 	clz	r6,r10
8000ef88:	f9 b7 03 00 	movlo	r7,0
8000ef8c:	f9 b6 03 00 	movlo	r6,0
8000ef90:	f9 bc 03 00 	movlo	r12,0
8000ef94:	f7 b6 02 e0 	subhs	r6,-32
8000ef98:	f4 06 09 4b 	lsl	r11,r10,r6
8000ef9c:	30 0a       	mov	r10,0
8000ef9e:	0c 17       	sub	r7,r6
8000efa0:	fe 9a ff be 	brle	8000ef1c <__avr32_f64_sub_subnormal_result>
8000efa4:	c8 5b       	rjmp	8000eeae <__avr32_f64_sub_longnormalize_done>
8000efa6:	d7 03       	nop

8000efa8 <__avr32_f64_add_from_sub>:
8000efa8:	ee 19 80 00 	eorh	r9,0x8000

8000efac <__avr32_f64_add>:
8000efac:	f7 e9 20 0c 	eor	r12,r11,r9
8000efb0:	fe 96 ff 2e 	brmi	8000ee0c <__avr32_f64_sub_from_add>
8000efb4:	eb cd 40 e0 	pushm	r5-r7,lr
8000efb8:	16 9c       	mov	r12,r11
8000efba:	e6 1c 80 00 	andh	r12,0x8000,COH
8000efbe:	bf db       	cbr	r11,0x1f
8000efc0:	bf d9       	cbr	r9,0x1f
8000efc2:	12 3b       	cp.w	r11,r9
8000efc4:	c0 72       	brcc	8000efd2 <__avr32_f64_add+0x26>
8000efc6:	16 97       	mov	r7,r11
8000efc8:	12 9b       	mov	r11,r9
8000efca:	0e 99       	mov	r9,r7
8000efcc:	14 97       	mov	r7,r10
8000efce:	10 9a       	mov	r10,r8
8000efd0:	0e 98       	mov	r8,r7
8000efd2:	30 0e       	mov	lr,0
8000efd4:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000efd8:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000efdc:	b5 ab       	sbr	r11,0x14
8000efde:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000efe2:	c6 20       	breq	8000f0a6 <__avr32_f64_add_op2_subnormal>
8000efe4:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000efe8:	b5 a9       	sbr	r9,0x14
8000efea:	e0 47 07 ff 	cp.w	r7,2047
8000efee:	c2 80       	breq	8000f03e <__avr32_f64_add_opH_nan_or_inf>
8000eff0:	0e 26       	rsub	r6,r7
8000eff2:	c1 20       	breq	8000f016 <__avr32_f64_add_shift_done>
8000eff4:	e0 46 00 36 	cp.w	r6,54
8000eff8:	c1 52       	brcc	8000f022 <__avr32_f64_add_res_of_done>
8000effa:	ec 05 11 20 	rsub	r5,r6,32
8000effe:	e0 46 00 20 	cp.w	r6,32
8000f002:	c3 52       	brcc	8000f06c <__avr32_f64_add_longshift>
8000f004:	f0 05 09 4e 	lsl	lr,r8,r5
8000f008:	f2 05 09 45 	lsl	r5,r9,r5
8000f00c:	f0 06 0a 48 	lsr	r8,r8,r6
8000f010:	f2 06 0a 49 	lsr	r9,r9,r6
8000f014:	0a 48       	or	r8,r5

8000f016 <__avr32_f64_add_shift_done>:
8000f016:	10 0a       	add	r10,r8
8000f018:	f6 09 00 4b 	adc	r11,r11,r9
8000f01c:	ed bb 00 15 	bld	r11,0x15
8000f020:	c3 40       	breq	8000f088 <__avr32_f64_add_res_of>

8000f022 <__avr32_f64_add_res_of_done>:
8000f022:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000f026:	18 4b       	or	r11,r12

8000f028 <__avr32_f64_add_round>:
8000f028:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000f02c:	18 4e       	or	lr,r12
8000f02e:	ee 1e 80 00 	eorh	lr,0x8000
8000f032:	f1 be 04 20 	satu	lr,0x1
8000f036:	1c 0a       	add	r10,lr
8000f038:	5c 0b       	acr	r11
8000f03a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f03e <__avr32_f64_add_opH_nan_or_inf>:
8000f03e:	b5 cb       	cbr	r11,0x14
8000f040:	f7 ea 10 0e 	or	lr,r11,r10
8000f044:	c1 01       	brne	8000f064 <__avr32_f64_add_return_nan>
8000f046:	e0 46 07 ff 	cp.w	r6,2047
8000f04a:	c0 30       	breq	8000f050 <__avr32_f64_add_opL_nan_or_inf>
8000f04c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f050 <__avr32_f64_add_opL_nan_or_inf>:
8000f050:	b5 c9       	cbr	r9,0x14
8000f052:	f3 e8 10 0e 	or	lr,r9,r8
8000f056:	c0 71       	brne	8000f064 <__avr32_f64_add_return_nan>
8000f058:	30 0a       	mov	r10,0
8000f05a:	fc 1b 7f f0 	movh	r11,0x7ff0
8000f05e:	18 4b       	or	r11,r12
8000f060:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f064 <__avr32_f64_add_return_nan>:
8000f064:	3f fa       	mov	r10,-1
8000f066:	3f fb       	mov	r11,-1
8000f068:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f06c <__avr32_f64_add_longshift>:
8000f06c:	f1 b6 04 c0 	satu	r6,0x6
8000f070:	f0 0e 17 00 	moveq	lr,r8
8000f074:	c0 60       	breq	8000f080 <__avr32_f64_add_longshift+0x14>
8000f076:	f2 05 09 4e 	lsl	lr,r9,r5
8000f07a:	58 08       	cp.w	r8,0
8000f07c:	5f 18       	srne	r8
8000f07e:	10 4e       	or	lr,r8
8000f080:	f2 06 0a 48 	lsr	r8,r9,r6
8000f084:	30 09       	mov	r9,0
8000f086:	cc 8b       	rjmp	8000f016 <__avr32_f64_add_shift_done>

8000f088 <__avr32_f64_add_res_of>:
8000f088:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000f08c:	a1 9b       	lsr	r11,0x1
8000f08e:	5d 0a       	ror	r10
8000f090:	5d 0e       	ror	lr
8000f092:	2f f7       	sub	r7,-1
8000f094:	e0 47 07 ff 	cp.w	r7,2047
8000f098:	f9 ba 00 00 	moveq	r10,0
8000f09c:	f9 bb 00 00 	moveq	r11,0
8000f0a0:	f9 be 00 00 	moveq	lr,0
8000f0a4:	cb fb       	rjmp	8000f022 <__avr32_f64_add_res_of_done>

8000f0a6 <__avr32_f64_add_op2_subnormal>:
8000f0a6:	30 16       	mov	r6,1
8000f0a8:	58 07       	cp.w	r7,0
8000f0aa:	ca 01       	brne	8000efea <__avr32_f64_add+0x3e>
8000f0ac:	b5 cb       	cbr	r11,0x14
8000f0ae:	10 0a       	add	r10,r8
8000f0b0:	f6 09 00 4b 	adc	r11,r11,r9
8000f0b4:	18 4b       	or	r11,r12
8000f0b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000f0ba:	d7 03       	nop

8000f0bc <__avr32_f64_to_u32>:
8000f0bc:	58 0b       	cp.w	r11,0
8000f0be:	5e 6d       	retmi	0

8000f0c0 <__avr32_f64_to_s32>:
8000f0c0:	f6 0c 15 01 	lsl	r12,r11,0x1
8000f0c4:	b5 9c       	lsr	r12,0x15
8000f0c6:	e0 2c 03 ff 	sub	r12,1023
8000f0ca:	5e 3d       	retlo	0
8000f0cc:	f8 0c 11 1f 	rsub	r12,r12,31
8000f0d0:	16 99       	mov	r9,r11
8000f0d2:	ab 7b       	lsl	r11,0xb
8000f0d4:	bf bb       	sbr	r11,0x1f
8000f0d6:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000f0da:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000f0de:	a1 79       	lsl	r9,0x1
8000f0e0:	5e 2b       	reths	r11
8000f0e2:	5c 3b       	neg	r11
8000f0e4:	5e fb       	retal	r11

8000f0e6 <__avr32_u32_to_f64>:
8000f0e6:	f8 cb 00 00 	sub	r11,r12,0
8000f0ea:	30 0c       	mov	r12,0
8000f0ec:	c0 38       	rjmp	8000f0f2 <__avr32_s32_to_f64+0x4>

8000f0ee <__avr32_s32_to_f64>:
8000f0ee:	18 9b       	mov	r11,r12
8000f0f0:	5c 4b       	abs	r11
8000f0f2:	30 0a       	mov	r10,0
8000f0f4:	5e 0b       	reteq	r11
8000f0f6:	d4 01       	pushm	lr
8000f0f8:	e0 69 04 1e 	mov	r9,1054
8000f0fc:	f6 08 12 00 	clz	r8,r11
8000f100:	c1 70       	breq	8000f12e <__avr32_s32_to_f64+0x40>
8000f102:	c0 c3       	brcs	8000f11a <__avr32_s32_to_f64+0x2c>
8000f104:	f0 0e 11 20 	rsub	lr,r8,32
8000f108:	f6 08 09 4b 	lsl	r11,r11,r8
8000f10c:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000f110:	1c 4b       	or	r11,lr
8000f112:	f4 08 09 4a 	lsl	r10,r10,r8
8000f116:	10 19       	sub	r9,r8
8000f118:	c0 b8       	rjmp	8000f12e <__avr32_s32_to_f64+0x40>
8000f11a:	f4 08 12 00 	clz	r8,r10
8000f11e:	f9 b8 03 00 	movlo	r8,0
8000f122:	f7 b8 02 e0 	subhs	r8,-32
8000f126:	f4 08 09 4b 	lsl	r11,r10,r8
8000f12a:	30 0a       	mov	r10,0
8000f12c:	10 19       	sub	r9,r8
8000f12e:	58 09       	cp.w	r9,0
8000f130:	e0 89 00 30 	brgt	8000f190 <__avr32_s32_to_f64+0xa2>
8000f134:	5c 39       	neg	r9
8000f136:	2f f9       	sub	r9,-1
8000f138:	e0 49 00 36 	cp.w	r9,54
8000f13c:	c0 43       	brcs	8000f144 <__avr32_s32_to_f64+0x56>
8000f13e:	30 0b       	mov	r11,0
8000f140:	30 0a       	mov	r10,0
8000f142:	c2 68       	rjmp	8000f18e <__avr32_s32_to_f64+0xa0>
8000f144:	2f 69       	sub	r9,-10
8000f146:	f2 08 11 20 	rsub	r8,r9,32
8000f14a:	e0 49 00 20 	cp.w	r9,32
8000f14e:	c0 b2       	brcc	8000f164 <__avr32_s32_to_f64+0x76>
8000f150:	f4 08 09 4e 	lsl	lr,r10,r8
8000f154:	f6 08 09 48 	lsl	r8,r11,r8
8000f158:	f4 09 0a 4a 	lsr	r10,r10,r9
8000f15c:	f6 09 0a 4b 	lsr	r11,r11,r9
8000f160:	10 4b       	or	r11,r8
8000f162:	c0 88       	rjmp	8000f172 <__avr32_s32_to_f64+0x84>
8000f164:	f6 08 09 4e 	lsl	lr,r11,r8
8000f168:	14 4e       	or	lr,r10
8000f16a:	16 9a       	mov	r10,r11
8000f16c:	30 0b       	mov	r11,0
8000f16e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000f172:	ed ba 00 00 	bld	r10,0x0
8000f176:	c0 92       	brcc	8000f188 <__avr32_s32_to_f64+0x9a>
8000f178:	1c 7e       	tst	lr,lr
8000f17a:	c0 41       	brne	8000f182 <__avr32_s32_to_f64+0x94>
8000f17c:	ed ba 00 01 	bld	r10,0x1
8000f180:	c0 42       	brcc	8000f188 <__avr32_s32_to_f64+0x9a>
8000f182:	2f fa       	sub	r10,-1
8000f184:	f7 bb 02 ff 	subhs	r11,-1
8000f188:	5c fc       	rol	r12
8000f18a:	5d 0b       	ror	r11
8000f18c:	5d 0a       	ror	r10
8000f18e:	d8 02       	popm	pc
8000f190:	e0 68 03 ff 	mov	r8,1023
8000f194:	ed ba 00 0b 	bld	r10,0xb
8000f198:	f7 b8 00 ff 	subeq	r8,-1
8000f19c:	10 0a       	add	r10,r8
8000f19e:	5c 0b       	acr	r11
8000f1a0:	f7 b9 03 fe 	sublo	r9,-2
8000f1a4:	e0 49 07 ff 	cp.w	r9,2047
8000f1a8:	c0 55       	brlt	8000f1b2 <__avr32_s32_to_f64+0xc4>
8000f1aa:	30 0a       	mov	r10,0
8000f1ac:	fc 1b ff e0 	movh	r11,0xffe0
8000f1b0:	c0 c8       	rjmp	8000f1c8 <__floatsidf_return_op1>
8000f1b2:	ed bb 00 1f 	bld	r11,0x1f
8000f1b6:	f7 b9 01 01 	subne	r9,1
8000f1ba:	ab 9a       	lsr	r10,0xb
8000f1bc:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000f1c0:	a1 7b       	lsl	r11,0x1
8000f1c2:	ab 9b       	lsr	r11,0xb
8000f1c4:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000f1c8 <__floatsidf_return_op1>:
8000f1c8:	a1 7c       	lsl	r12,0x1
8000f1ca:	5d 0b       	ror	r11
8000f1cc:	d8 02       	popm	pc

8000f1ce <__avr32_f64_cmp_eq>:
8000f1ce:	10 3a       	cp.w	r10,r8
8000f1d0:	f2 0b 13 00 	cpc	r11,r9
8000f1d4:	c0 80       	breq	8000f1e4 <__avr32_f64_cmp_eq+0x16>
8000f1d6:	a1 7b       	lsl	r11,0x1
8000f1d8:	a1 79       	lsl	r9,0x1
8000f1da:	14 4b       	or	r11,r10
8000f1dc:	12 4b       	or	r11,r9
8000f1de:	10 4b       	or	r11,r8
8000f1e0:	5e 0f       	reteq	1
8000f1e2:	5e fd       	retal	0
8000f1e4:	a1 7b       	lsl	r11,0x1
8000f1e6:	fc 1c ff e0 	movh	r12,0xffe0
8000f1ea:	58 0a       	cp.w	r10,0
8000f1ec:	f8 0b 13 00 	cpc	r11,r12
8000f1f0:	5e 8f       	retls	1
8000f1f2:	5e fd       	retal	0

8000f1f4 <__avr32_f64_cmp_ge>:
8000f1f4:	1a de       	st.w	--sp,lr
8000f1f6:	1a d7       	st.w	--sp,r7
8000f1f8:	a1 7b       	lsl	r11,0x1
8000f1fa:	5f 3c       	srlo	r12
8000f1fc:	a1 79       	lsl	r9,0x1
8000f1fe:	5f 37       	srlo	r7
8000f200:	5c fc       	rol	r12
8000f202:	fc 1e ff e0 	movh	lr,0xffe0
8000f206:	58 0a       	cp.w	r10,0
8000f208:	fc 0b 13 00 	cpc	r11,lr
8000f20c:	e0 8b 00 1d 	brhi	8000f246 <__avr32_f64_cmp_ge+0x52>
8000f210:	58 08       	cp.w	r8,0
8000f212:	fc 09 13 00 	cpc	r9,lr
8000f216:	e0 8b 00 18 	brhi	8000f246 <__avr32_f64_cmp_ge+0x52>
8000f21a:	58 0b       	cp.w	r11,0
8000f21c:	f5 ba 00 00 	subfeq	r10,0
8000f220:	c1 50       	breq	8000f24a <__avr32_f64_cmp_ge+0x56>
8000f222:	1b 07       	ld.w	r7,sp++
8000f224:	1b 0e       	ld.w	lr,sp++
8000f226:	58 3c       	cp.w	r12,3
8000f228:	c0 a0       	breq	8000f23c <__avr32_f64_cmp_ge+0x48>
8000f22a:	58 1c       	cp.w	r12,1
8000f22c:	c0 33       	brcs	8000f232 <__avr32_f64_cmp_ge+0x3e>
8000f22e:	5e 0f       	reteq	1
8000f230:	5e 1d       	retne	0
8000f232:	10 3a       	cp.w	r10,r8
8000f234:	f2 0b 13 00 	cpc	r11,r9
8000f238:	5e 2f       	reths	1
8000f23a:	5e 3d       	retlo	0
8000f23c:	14 38       	cp.w	r8,r10
8000f23e:	f6 09 13 00 	cpc	r9,r11
8000f242:	5e 2f       	reths	1
8000f244:	5e 3d       	retlo	0
8000f246:	1b 07       	ld.w	r7,sp++
8000f248:	d8 0a       	popm	pc,r12=0
8000f24a:	58 17       	cp.w	r7,1
8000f24c:	5f 0c       	sreq	r12
8000f24e:	58 09       	cp.w	r9,0
8000f250:	f5 b8 00 00 	subfeq	r8,0
8000f254:	1b 07       	ld.w	r7,sp++
8000f256:	1b 0e       	ld.w	lr,sp++
8000f258:	5e 0f       	reteq	1
8000f25a:	5e fc       	retal	r12

8000f25c <__avr32_f64_cmp_lt>:
8000f25c:	1a de       	st.w	--sp,lr
8000f25e:	1a d7       	st.w	--sp,r7
8000f260:	a1 7b       	lsl	r11,0x1
8000f262:	5f 3c       	srlo	r12
8000f264:	a1 79       	lsl	r9,0x1
8000f266:	5f 37       	srlo	r7
8000f268:	5c fc       	rol	r12
8000f26a:	fc 1e ff e0 	movh	lr,0xffe0
8000f26e:	58 0a       	cp.w	r10,0
8000f270:	fc 0b 13 00 	cpc	r11,lr
8000f274:	e0 8b 00 1d 	brhi	8000f2ae <__avr32_f64_cmp_lt+0x52>
8000f278:	58 08       	cp.w	r8,0
8000f27a:	fc 09 13 00 	cpc	r9,lr
8000f27e:	e0 8b 00 18 	brhi	8000f2ae <__avr32_f64_cmp_lt+0x52>
8000f282:	58 0b       	cp.w	r11,0
8000f284:	f5 ba 00 00 	subfeq	r10,0
8000f288:	c1 50       	breq	8000f2b2 <__avr32_f64_cmp_lt+0x56>
8000f28a:	1b 07       	ld.w	r7,sp++
8000f28c:	1b 0e       	ld.w	lr,sp++
8000f28e:	58 3c       	cp.w	r12,3
8000f290:	c0 a0       	breq	8000f2a4 <__avr32_f64_cmp_lt+0x48>
8000f292:	58 1c       	cp.w	r12,1
8000f294:	c0 33       	brcs	8000f29a <__avr32_f64_cmp_lt+0x3e>
8000f296:	5e 0d       	reteq	0
8000f298:	5e 1f       	retne	1
8000f29a:	10 3a       	cp.w	r10,r8
8000f29c:	f2 0b 13 00 	cpc	r11,r9
8000f2a0:	5e 2d       	reths	0
8000f2a2:	5e 3f       	retlo	1
8000f2a4:	14 38       	cp.w	r8,r10
8000f2a6:	f6 09 13 00 	cpc	r9,r11
8000f2aa:	5e 2d       	reths	0
8000f2ac:	5e 3f       	retlo	1
8000f2ae:	1b 07       	ld.w	r7,sp++
8000f2b0:	d8 0a       	popm	pc,r12=0
8000f2b2:	58 17       	cp.w	r7,1
8000f2b4:	5f 1c       	srne	r12
8000f2b6:	58 09       	cp.w	r9,0
8000f2b8:	f5 b8 00 00 	subfeq	r8,0
8000f2bc:	1b 07       	ld.w	r7,sp++
8000f2be:	1b 0e       	ld.w	lr,sp++
8000f2c0:	5e 0d       	reteq	0
8000f2c2:	5e fc       	retal	r12

8000f2c4 <__avr32_f64_div>:
8000f2c4:	eb cd 40 ff 	pushm	r0-r7,lr
8000f2c8:	f7 e9 20 0e 	eor	lr,r11,r9
8000f2cc:	f6 07 16 14 	lsr	r7,r11,0x14
8000f2d0:	a9 7b       	lsl	r11,0x9
8000f2d2:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000f2d6:	a9 7a       	lsl	r10,0x9
8000f2d8:	bd bb       	sbr	r11,0x1d
8000f2da:	e4 1b 3f ff 	andh	r11,0x3fff
8000f2de:	ab d7       	cbr	r7,0xb
8000f2e0:	e0 80 00 cc 	breq	8000f478 <__avr32_f64_div_round_subnormal+0x54>
8000f2e4:	e0 47 07 ff 	cp.w	r7,2047
8000f2e8:	e0 84 00 b5 	brge	8000f452 <__avr32_f64_div_round_subnormal+0x2e>
8000f2ec:	f2 06 16 14 	lsr	r6,r9,0x14
8000f2f0:	a9 79       	lsl	r9,0x9
8000f2f2:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000f2f6:	a9 78       	lsl	r8,0x9
8000f2f8:	bd b9       	sbr	r9,0x1d
8000f2fa:	e4 19 3f ff 	andh	r9,0x3fff
8000f2fe:	ab d6       	cbr	r6,0xb
8000f300:	e0 80 00 e2 	breq	8000f4c4 <__avr32_f64_div_round_subnormal+0xa0>
8000f304:	e0 46 07 ff 	cp.w	r6,2047
8000f308:	e0 84 00 b2 	brge	8000f46c <__avr32_f64_div_round_subnormal+0x48>
8000f30c:	0c 17       	sub	r7,r6
8000f30e:	fe 37 fc 01 	sub	r7,-1023
8000f312:	fc 1c 80 00 	movh	r12,0x8000
8000f316:	f8 03 16 01 	lsr	r3,r12,0x1
8000f31a:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000f31e:	5c d4       	com	r4
8000f320:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000f324:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f328:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f32c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f330:	ea 03 15 02 	lsl	r3,r5,0x2
8000f334:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f338:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f33c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f340:	ea 03 15 02 	lsl	r3,r5,0x2
8000f344:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f348:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f34c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f350:	ea 03 15 02 	lsl	r3,r5,0x2
8000f354:	e6 08 06 40 	mulu.d	r0,r3,r8
8000f358:	e4 09 07 40 	macu.d	r0,r2,r9
8000f35c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f360:	02 04       	add	r4,r1
8000f362:	5c 05       	acr	r5
8000f364:	a3 65       	lsl	r5,0x2
8000f366:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000f36a:	a3 64       	lsl	r4,0x2
8000f36c:	5c 34       	neg	r4
8000f36e:	f8 05 01 45 	sbc	r5,r12,r5
8000f372:	e6 04 06 40 	mulu.d	r0,r3,r4
8000f376:	e4 05 07 40 	macu.d	r0,r2,r5
8000f37a:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f37e:	02 04       	add	r4,r1
8000f380:	5c 05       	acr	r5
8000f382:	ea 03 15 02 	lsl	r3,r5,0x2
8000f386:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000f38a:	e8 02 15 02 	lsl	r2,r4,0x2
8000f38e:	e6 08 06 40 	mulu.d	r0,r3,r8
8000f392:	e4 09 07 40 	macu.d	r0,r2,r9
8000f396:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f39a:	02 04       	add	r4,r1
8000f39c:	5c 05       	acr	r5
8000f39e:	a3 65       	lsl	r5,0x2
8000f3a0:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000f3a4:	a3 64       	lsl	r4,0x2
8000f3a6:	5c 34       	neg	r4
8000f3a8:	f8 05 01 45 	sbc	r5,r12,r5
8000f3ac:	e6 04 06 40 	mulu.d	r0,r3,r4
8000f3b0:	e4 05 07 40 	macu.d	r0,r2,r5
8000f3b4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f3b8:	02 04       	add	r4,r1
8000f3ba:	5c 05       	acr	r5
8000f3bc:	ea 03 15 02 	lsl	r3,r5,0x2
8000f3c0:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000f3c4:	e8 02 15 02 	lsl	r2,r4,0x2
8000f3c8:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000f3cc:	e4 0b 07 40 	macu.d	r0,r2,r11
8000f3d0:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000f3d4:	02 02       	add	r2,r1
8000f3d6:	5c 03       	acr	r3
8000f3d8:	ed b3 00 1c 	bld	r3,0x1c
8000f3dc:	c0 90       	breq	8000f3ee <__avr32_f64_div+0x12a>
8000f3de:	a1 72       	lsl	r2,0x1
8000f3e0:	5c f3       	rol	r3
8000f3e2:	20 17       	sub	r7,1
8000f3e4:	a3 9a       	lsr	r10,0x3
8000f3e6:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000f3ea:	a3 9b       	lsr	r11,0x3
8000f3ec:	c0 58       	rjmp	8000f3f6 <__avr32_f64_div+0x132>
8000f3ee:	a5 8a       	lsr	r10,0x4
8000f3f0:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000f3f4:	a5 8b       	lsr	r11,0x4
8000f3f6:	58 07       	cp.w	r7,0
8000f3f8:	e0 8a 00 8b 	brle	8000f50e <__avr32_f64_div_res_subnormal>
8000f3fc:	e0 12 ff 00 	andl	r2,0xff00
8000f400:	e8 12 00 80 	orl	r2,0x80
8000f404:	e6 08 06 40 	mulu.d	r0,r3,r8
8000f408:	e4 09 07 40 	macu.d	r0,r2,r9
8000f40c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000f410:	e6 09 06 48 	mulu.d	r8,r3,r9
8000f414:	00 05       	add	r5,r0
8000f416:	f0 01 00 48 	adc	r8,r8,r1
8000f41a:	5c 09       	acr	r9
8000f41c:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000f420:	58 04       	cp.w	r4,0
8000f422:	5c 25       	cpc	r5

8000f424 <__avr32_f64_div_round_subnormal>:
8000f424:	f4 08 13 00 	cpc	r8,r10
8000f428:	f6 09 13 00 	cpc	r9,r11
8000f42c:	5f 36       	srlo	r6
8000f42e:	f8 06 17 00 	moveq	r6,r12
8000f432:	e4 0a 16 08 	lsr	r10,r2,0x8
8000f436:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000f43a:	e6 0b 16 08 	lsr	r11,r3,0x8
8000f43e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000f442:	ed be 00 1f 	bld	lr,0x1f
8000f446:	ef bb 00 1f 	bst	r11,0x1f
8000f44a:	0c 0a       	add	r10,r6
8000f44c:	5c 0b       	acr	r11
8000f44e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000f452:	e4 1b 00 0f 	andh	r11,0xf
8000f456:	14 4b       	or	r11,r10
8000f458:	e0 81 00 a7 	brne	8000f5a6 <__avr32_f64_div_res_subnormal+0x98>
8000f45c:	f2 06 16 14 	lsr	r6,r9,0x14
8000f460:	ab d6       	cbr	r6,0xb
8000f462:	e0 46 07 ff 	cp.w	r6,2047
8000f466:	e0 81 00 a4 	brne	8000f5ae <__avr32_f64_div_res_subnormal+0xa0>
8000f46a:	c9 e8       	rjmp	8000f5a6 <__avr32_f64_div_res_subnormal+0x98>
8000f46c:	e4 19 00 0f 	andh	r9,0xf
8000f470:	10 49       	or	r9,r8
8000f472:	e0 81 00 9a 	brne	8000f5a6 <__avr32_f64_div_res_subnormal+0x98>
8000f476:	c9 28       	rjmp	8000f59a <__avr32_f64_div_res_subnormal+0x8c>
8000f478:	a3 7b       	lsl	r11,0x3
8000f47a:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000f47e:	a3 7a       	lsl	r10,0x3
8000f480:	f5 eb 10 04 	or	r4,r10,r11
8000f484:	e0 80 00 a0 	breq	8000f5c4 <__avr32_f64_div_op1_zero>
8000f488:	f6 04 12 00 	clz	r4,r11
8000f48c:	c1 70       	breq	8000f4ba <__avr32_f64_div_round_subnormal+0x96>
8000f48e:	c0 c3       	brcs	8000f4a6 <__avr32_f64_div_round_subnormal+0x82>
8000f490:	e8 05 11 20 	rsub	r5,r4,32
8000f494:	f6 04 09 4b 	lsl	r11,r11,r4
8000f498:	f4 05 0a 45 	lsr	r5,r10,r5
8000f49c:	0a 4b       	or	r11,r5
8000f49e:	f4 04 09 4a 	lsl	r10,r10,r4
8000f4a2:	08 17       	sub	r7,r4
8000f4a4:	c0 b8       	rjmp	8000f4ba <__avr32_f64_div_round_subnormal+0x96>
8000f4a6:	f4 04 12 00 	clz	r4,r10
8000f4aa:	f9 b4 03 00 	movlo	r4,0
8000f4ae:	f7 b4 02 e0 	subhs	r4,-32
8000f4b2:	f4 04 09 4b 	lsl	r11,r10,r4
8000f4b6:	30 0a       	mov	r10,0
8000f4b8:	08 17       	sub	r7,r4
8000f4ba:	a3 8a       	lsr	r10,0x2
8000f4bc:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000f4c0:	a3 8b       	lsr	r11,0x2
8000f4c2:	c1 1b       	rjmp	8000f2e4 <__avr32_f64_div+0x20>
8000f4c4:	a3 79       	lsl	r9,0x3
8000f4c6:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000f4ca:	a3 78       	lsl	r8,0x3
8000f4cc:	f3 e8 10 04 	or	r4,r9,r8
8000f4d0:	c6 f0       	breq	8000f5ae <__avr32_f64_div_res_subnormal+0xa0>
8000f4d2:	f2 04 12 00 	clz	r4,r9
8000f4d6:	c1 70       	breq	8000f504 <__avr32_f64_div_round_subnormal+0xe0>
8000f4d8:	c0 c3       	brcs	8000f4f0 <__avr32_f64_div_round_subnormal+0xcc>
8000f4da:	e8 05 11 20 	rsub	r5,r4,32
8000f4de:	f2 04 09 49 	lsl	r9,r9,r4
8000f4e2:	f0 05 0a 45 	lsr	r5,r8,r5
8000f4e6:	0a 49       	or	r9,r5
8000f4e8:	f0 04 09 48 	lsl	r8,r8,r4
8000f4ec:	08 16       	sub	r6,r4
8000f4ee:	c0 b8       	rjmp	8000f504 <__avr32_f64_div_round_subnormal+0xe0>
8000f4f0:	f0 04 12 00 	clz	r4,r8
8000f4f4:	f9 b4 03 00 	movlo	r4,0
8000f4f8:	f7 b4 02 e0 	subhs	r4,-32
8000f4fc:	f0 04 09 49 	lsl	r9,r8,r4
8000f500:	30 08       	mov	r8,0
8000f502:	08 16       	sub	r6,r4
8000f504:	a3 88       	lsr	r8,0x2
8000f506:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000f50a:	a3 89       	lsr	r9,0x2
8000f50c:	cf ca       	rjmp	8000f304 <__avr32_f64_div+0x40>

8000f50e <__avr32_f64_div_res_subnormal>:
8000f50e:	5c 37       	neg	r7
8000f510:	2f f7       	sub	r7,-1
8000f512:	f1 b7 04 c0 	satu	r7,0x6
8000f516:	e0 47 00 20 	cp.w	r7,32
8000f51a:	c1 54       	brge	8000f544 <__avr32_f64_div_res_subnormal+0x36>
8000f51c:	ee 06 11 20 	rsub	r6,r7,32
8000f520:	e4 07 0a 42 	lsr	r2,r2,r7
8000f524:	e6 06 09 4c 	lsl	r12,r3,r6
8000f528:	18 42       	or	r2,r12
8000f52a:	e6 07 0a 43 	lsr	r3,r3,r7
8000f52e:	f4 06 09 41 	lsl	r1,r10,r6
8000f532:	f4 07 0a 4a 	lsr	r10,r10,r7
8000f536:	f6 06 09 4c 	lsl	r12,r11,r6
8000f53a:	18 4a       	or	r10,r12
8000f53c:	f6 07 0a 4b 	lsr	r11,r11,r7
8000f540:	30 00       	mov	r0,0
8000f542:	c1 58       	rjmp	8000f56c <__avr32_f64_div_res_subnormal+0x5e>
8000f544:	ee 06 11 20 	rsub	r6,r7,32
8000f548:	f9 b0 00 00 	moveq	r0,0
8000f54c:	f9 bc 00 00 	moveq	r12,0
8000f550:	c0 50       	breq	8000f55a <__avr32_f64_div_res_subnormal+0x4c>
8000f552:	f4 06 09 40 	lsl	r0,r10,r6
8000f556:	f6 06 09 4c 	lsl	r12,r11,r6
8000f55a:	e6 07 0a 42 	lsr	r2,r3,r7
8000f55e:	30 03       	mov	r3,0
8000f560:	f4 07 0a 41 	lsr	r1,r10,r7
8000f564:	18 41       	or	r1,r12
8000f566:	f6 07 0a 4a 	lsr	r10,r11,r7
8000f56a:	30 0b       	mov	r11,0
8000f56c:	e0 12 ff 00 	andl	r2,0xff00
8000f570:	e8 12 00 80 	orl	r2,0x80
8000f574:	e6 08 06 46 	mulu.d	r6,r3,r8
8000f578:	e4 09 07 46 	macu.d	r6,r2,r9
8000f57c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000f580:	e6 09 06 48 	mulu.d	r8,r3,r9
8000f584:	0c 05       	add	r5,r6
8000f586:	f0 07 00 48 	adc	r8,r8,r7
8000f58a:	5c 09       	acr	r9
8000f58c:	30 07       	mov	r7,0
8000f58e:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000f592:	00 34       	cp.w	r4,r0
8000f594:	e2 05 13 00 	cpc	r5,r1
8000f598:	c4 6b       	rjmp	8000f424 <__avr32_f64_div_round_subnormal>
8000f59a:	1c 9b       	mov	r11,lr
8000f59c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f5a0:	30 0a       	mov	r10,0
8000f5a2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000f5a6:	3f fb       	mov	r11,-1
8000f5a8:	30 0a       	mov	r10,0
8000f5aa:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000f5ae:	f5 eb 10 04 	or	r4,r10,r11
8000f5b2:	c0 90       	breq	8000f5c4 <__avr32_f64_div_op1_zero>
8000f5b4:	1c 9b       	mov	r11,lr
8000f5b6:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f5ba:	ea 1b 7f f0 	orh	r11,0x7ff0
8000f5be:	30 0a       	mov	r10,0
8000f5c0:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000f5c4 <__avr32_f64_div_op1_zero>:
8000f5c4:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000f5c8:	ce f0       	breq	8000f5a6 <__avr32_f64_div_res_subnormal+0x98>
8000f5ca:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000f5ce:	e0 44 07 ff 	cp.w	r4,2047
8000f5d2:	ce 41       	brne	8000f59a <__avr32_f64_div_res_subnormal+0x8c>
8000f5d4:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000f5d8:	ce 10       	breq	8000f59a <__avr32_f64_div_res_subnormal+0x8c>
8000f5da:	ce 6b       	rjmp	8000f5a6 <__avr32_f64_div_res_subnormal+0x98>

8000f5dc <__avr32_udiv64>:
8000f5dc:	d4 31       	pushm	r0-r7,lr
8000f5de:	1a 97       	mov	r7,sp
8000f5e0:	20 3d       	sub	sp,12
8000f5e2:	10 9c       	mov	r12,r8
8000f5e4:	12 9e       	mov	lr,r9
8000f5e6:	14 93       	mov	r3,r10
8000f5e8:	58 09       	cp.w	r9,0
8000f5ea:	e0 81 00 bd 	brne	8000f764 <__avr32_udiv64+0x188>
8000f5ee:	16 38       	cp.w	r8,r11
8000f5f0:	e0 88 00 40 	brls	8000f670 <__avr32_udiv64+0x94>
8000f5f4:	f0 08 12 00 	clz	r8,r8
8000f5f8:	c0 d0       	breq	8000f612 <__avr32_udiv64+0x36>
8000f5fa:	f6 08 09 4b 	lsl	r11,r11,r8
8000f5fe:	f0 09 11 20 	rsub	r9,r8,32
8000f602:	f8 08 09 4c 	lsl	r12,r12,r8
8000f606:	f4 09 0a 49 	lsr	r9,r10,r9
8000f60a:	f4 08 09 43 	lsl	r3,r10,r8
8000f60e:	f3 eb 10 0b 	or	r11,r9,r11
8000f612:	f8 0e 16 10 	lsr	lr,r12,0x10
8000f616:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000f61a:	f6 0e 0d 00 	divu	r0,r11,lr
8000f61e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000f622:	00 99       	mov	r9,r0
8000f624:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000f628:	e0 0a 02 48 	mul	r8,r0,r10
8000f62c:	10 3b       	cp.w	r11,r8
8000f62e:	c0 a2       	brcc	8000f642 <__avr32_udiv64+0x66>
8000f630:	20 19       	sub	r9,1
8000f632:	18 0b       	add	r11,r12
8000f634:	18 3b       	cp.w	r11,r12
8000f636:	c0 63       	brcs	8000f642 <__avr32_udiv64+0x66>
8000f638:	10 3b       	cp.w	r11,r8
8000f63a:	f7 b9 03 01 	sublo	r9,1
8000f63e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000f642:	f6 08 01 01 	sub	r1,r11,r8
8000f646:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000f64a:	e2 0e 0d 00 	divu	r0,r1,lr
8000f64e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000f652:	00 98       	mov	r8,r0
8000f654:	e0 0a 02 4a 	mul	r10,r0,r10
8000f658:	14 33       	cp.w	r3,r10
8000f65a:	c0 82       	brcc	8000f66a <__avr32_udiv64+0x8e>
8000f65c:	20 18       	sub	r8,1
8000f65e:	18 03       	add	r3,r12
8000f660:	18 33       	cp.w	r3,r12
8000f662:	c0 43       	brcs	8000f66a <__avr32_udiv64+0x8e>
8000f664:	14 33       	cp.w	r3,r10
8000f666:	f7 b8 03 01 	sublo	r8,1
8000f66a:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000f66e:	cd f8       	rjmp	8000f82c <__avr32_udiv64+0x250>
8000f670:	58 08       	cp.w	r8,0
8000f672:	c0 51       	brne	8000f67c <__avr32_udiv64+0xa0>
8000f674:	30 19       	mov	r9,1
8000f676:	f2 08 0d 08 	divu	r8,r9,r8
8000f67a:	10 9c       	mov	r12,r8
8000f67c:	f8 06 12 00 	clz	r6,r12
8000f680:	c0 41       	brne	8000f688 <__avr32_udiv64+0xac>
8000f682:	18 1b       	sub	r11,r12
8000f684:	30 19       	mov	r9,1
8000f686:	c4 08       	rjmp	8000f706 <__avr32_udiv64+0x12a>
8000f688:	ec 01 11 20 	rsub	r1,r6,32
8000f68c:	f4 01 0a 49 	lsr	r9,r10,r1
8000f690:	f8 06 09 4c 	lsl	r12,r12,r6
8000f694:	f6 06 09 48 	lsl	r8,r11,r6
8000f698:	f6 01 0a 41 	lsr	r1,r11,r1
8000f69c:	f3 e8 10 08 	or	r8,r9,r8
8000f6a0:	f8 03 16 10 	lsr	r3,r12,0x10
8000f6a4:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000f6a8:	e2 03 0d 00 	divu	r0,r1,r3
8000f6ac:	f0 0b 16 10 	lsr	r11,r8,0x10
8000f6b0:	00 9e       	mov	lr,r0
8000f6b2:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000f6b6:	e0 05 02 49 	mul	r9,r0,r5
8000f6ba:	12 3b       	cp.w	r11,r9
8000f6bc:	c0 a2       	brcc	8000f6d0 <__avr32_udiv64+0xf4>
8000f6be:	20 1e       	sub	lr,1
8000f6c0:	18 0b       	add	r11,r12
8000f6c2:	18 3b       	cp.w	r11,r12
8000f6c4:	c0 63       	brcs	8000f6d0 <__avr32_udiv64+0xf4>
8000f6c6:	12 3b       	cp.w	r11,r9
8000f6c8:	f7 be 03 01 	sublo	lr,1
8000f6cc:	f7 dc e3 0b 	addcs	r11,r11,r12
8000f6d0:	12 1b       	sub	r11,r9
8000f6d2:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000f6d6:	f6 03 0d 02 	divu	r2,r11,r3
8000f6da:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000f6de:	04 99       	mov	r9,r2
8000f6e0:	e4 05 02 4b 	mul	r11,r2,r5
8000f6e4:	16 38       	cp.w	r8,r11
8000f6e6:	c0 a2       	brcc	8000f6fa <__avr32_udiv64+0x11e>
8000f6e8:	20 19       	sub	r9,1
8000f6ea:	18 08       	add	r8,r12
8000f6ec:	18 38       	cp.w	r8,r12
8000f6ee:	c0 63       	brcs	8000f6fa <__avr32_udiv64+0x11e>
8000f6f0:	16 38       	cp.w	r8,r11
8000f6f2:	f7 b9 03 01 	sublo	r9,1
8000f6f6:	f1 dc e3 08 	addcs	r8,r8,r12
8000f6fa:	f4 06 09 43 	lsl	r3,r10,r6
8000f6fe:	f0 0b 01 0b 	sub	r11,r8,r11
8000f702:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000f706:	f8 06 16 10 	lsr	r6,r12,0x10
8000f70a:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000f70e:	f6 06 0d 00 	divu	r0,r11,r6
8000f712:	e6 0b 16 10 	lsr	r11,r3,0x10
8000f716:	00 9a       	mov	r10,r0
8000f718:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000f71c:	e0 0e 02 48 	mul	r8,r0,lr
8000f720:	10 3b       	cp.w	r11,r8
8000f722:	c0 a2       	brcc	8000f736 <__avr32_udiv64+0x15a>
8000f724:	20 1a       	sub	r10,1
8000f726:	18 0b       	add	r11,r12
8000f728:	18 3b       	cp.w	r11,r12
8000f72a:	c0 63       	brcs	8000f736 <__avr32_udiv64+0x15a>
8000f72c:	10 3b       	cp.w	r11,r8
8000f72e:	f7 ba 03 01 	sublo	r10,1
8000f732:	f7 dc e3 0b 	addcs	r11,r11,r12
8000f736:	f6 08 01 01 	sub	r1,r11,r8
8000f73a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000f73e:	e2 06 0d 00 	divu	r0,r1,r6
8000f742:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000f746:	00 98       	mov	r8,r0
8000f748:	e0 0e 02 4b 	mul	r11,r0,lr
8000f74c:	16 33       	cp.w	r3,r11
8000f74e:	c0 82       	brcc	8000f75e <__avr32_udiv64+0x182>
8000f750:	20 18       	sub	r8,1
8000f752:	18 03       	add	r3,r12
8000f754:	18 33       	cp.w	r3,r12
8000f756:	c0 43       	brcs	8000f75e <__avr32_udiv64+0x182>
8000f758:	16 33       	cp.w	r3,r11
8000f75a:	f7 b8 03 01 	sublo	r8,1
8000f75e:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000f762:	c6 98       	rjmp	8000f834 <__avr32_udiv64+0x258>
8000f764:	16 39       	cp.w	r9,r11
8000f766:	e0 8b 00 65 	brhi	8000f830 <__avr32_udiv64+0x254>
8000f76a:	f2 09 12 00 	clz	r9,r9
8000f76e:	c0 b1       	brne	8000f784 <__avr32_udiv64+0x1a8>
8000f770:	10 3a       	cp.w	r10,r8
8000f772:	5f 2a       	srhs	r10
8000f774:	1c 3b       	cp.w	r11,lr
8000f776:	5f b8       	srhi	r8
8000f778:	10 4a       	or	r10,r8
8000f77a:	f2 0a 18 00 	cp.b	r10,r9
8000f77e:	c5 90       	breq	8000f830 <__avr32_udiv64+0x254>
8000f780:	30 18       	mov	r8,1
8000f782:	c5 98       	rjmp	8000f834 <__avr32_udiv64+0x258>
8000f784:	f0 09 09 46 	lsl	r6,r8,r9
8000f788:	f2 03 11 20 	rsub	r3,r9,32
8000f78c:	fc 09 09 4e 	lsl	lr,lr,r9
8000f790:	f0 03 0a 48 	lsr	r8,r8,r3
8000f794:	f6 09 09 4c 	lsl	r12,r11,r9
8000f798:	f4 03 0a 42 	lsr	r2,r10,r3
8000f79c:	ef 46 ff f4 	st.w	r7[-12],r6
8000f7a0:	f6 03 0a 43 	lsr	r3,r11,r3
8000f7a4:	18 42       	or	r2,r12
8000f7a6:	f1 ee 10 0c 	or	r12,r8,lr
8000f7aa:	f8 01 16 10 	lsr	r1,r12,0x10
8000f7ae:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000f7b2:	e6 01 0d 04 	divu	r4,r3,r1
8000f7b6:	e4 03 16 10 	lsr	r3,r2,0x10
8000f7ba:	08 9e       	mov	lr,r4
8000f7bc:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000f7c0:	e8 06 02 48 	mul	r8,r4,r6
8000f7c4:	10 33       	cp.w	r3,r8
8000f7c6:	c0 a2       	brcc	8000f7da <__avr32_udiv64+0x1fe>
8000f7c8:	20 1e       	sub	lr,1
8000f7ca:	18 03       	add	r3,r12
8000f7cc:	18 33       	cp.w	r3,r12
8000f7ce:	c0 63       	brcs	8000f7da <__avr32_udiv64+0x1fe>
8000f7d0:	10 33       	cp.w	r3,r8
8000f7d2:	f7 be 03 01 	sublo	lr,1
8000f7d6:	e7 dc e3 03 	addcs	r3,r3,r12
8000f7da:	10 13       	sub	r3,r8
8000f7dc:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000f7e0:	e6 01 0d 00 	divu	r0,r3,r1
8000f7e4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000f7e8:	00 98       	mov	r8,r0
8000f7ea:	e0 06 02 46 	mul	r6,r0,r6
8000f7ee:	0c 3b       	cp.w	r11,r6
8000f7f0:	c0 a2       	brcc	8000f804 <__avr32_udiv64+0x228>
8000f7f2:	20 18       	sub	r8,1
8000f7f4:	18 0b       	add	r11,r12
8000f7f6:	18 3b       	cp.w	r11,r12
8000f7f8:	c0 63       	brcs	8000f804 <__avr32_udiv64+0x228>
8000f7fa:	0c 3b       	cp.w	r11,r6
8000f7fc:	f7 dc e3 0b 	addcs	r11,r11,r12
8000f800:	f7 b8 03 01 	sublo	r8,1
8000f804:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000f808:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000f80c:	0c 1b       	sub	r11,r6
8000f80e:	f0 04 06 42 	mulu.d	r2,r8,r4
8000f812:	06 95       	mov	r5,r3
8000f814:	16 35       	cp.w	r5,r11
8000f816:	e0 8b 00 0a 	brhi	8000f82a <__avr32_udiv64+0x24e>
8000f81a:	5f 0b       	sreq	r11
8000f81c:	f4 09 09 49 	lsl	r9,r10,r9
8000f820:	12 32       	cp.w	r2,r9
8000f822:	5f b9       	srhi	r9
8000f824:	f7 e9 00 09 	and	r9,r11,r9
8000f828:	c0 60       	breq	8000f834 <__avr32_udiv64+0x258>
8000f82a:	20 18       	sub	r8,1
8000f82c:	30 09       	mov	r9,0
8000f82e:	c0 38       	rjmp	8000f834 <__avr32_udiv64+0x258>
8000f830:	30 09       	mov	r9,0
8000f832:	12 98       	mov	r8,r9
8000f834:	10 9a       	mov	r10,r8
8000f836:	12 93       	mov	r3,r9
8000f838:	10 92       	mov	r2,r8
8000f83a:	12 9b       	mov	r11,r9
8000f83c:	2f dd       	sub	sp,-12
8000f83e:	d8 32       	popm	r0-r7,pc

8000f840 <__avr32_umod64>:
8000f840:	d4 31       	pushm	r0-r7,lr
8000f842:	1a 97       	mov	r7,sp
8000f844:	20 3d       	sub	sp,12
8000f846:	10 9c       	mov	r12,r8
8000f848:	12 95       	mov	r5,r9
8000f84a:	14 9e       	mov	lr,r10
8000f84c:	16 91       	mov	r1,r11
8000f84e:	16 96       	mov	r6,r11
8000f850:	58 09       	cp.w	r9,0
8000f852:	e0 81 00 81 	brne	8000f954 <__avr32_umod64+0x114>
8000f856:	16 38       	cp.w	r8,r11
8000f858:	e0 88 00 12 	brls	8000f87c <__avr32_umod64+0x3c>
8000f85c:	f0 08 12 00 	clz	r8,r8
8000f860:	c4 e0       	breq	8000f8fc <__avr32_umod64+0xbc>
8000f862:	f6 08 09 46 	lsl	r6,r11,r8
8000f866:	f8 08 09 4c 	lsl	r12,r12,r8
8000f86a:	f0 0b 11 20 	rsub	r11,r8,32
8000f86e:	f4 08 09 4e 	lsl	lr,r10,r8
8000f872:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000f876:	f7 e6 10 06 	or	r6,r11,r6
8000f87a:	c4 18       	rjmp	8000f8fc <__avr32_umod64+0xbc>
8000f87c:	58 08       	cp.w	r8,0
8000f87e:	c0 51       	brne	8000f888 <__avr32_umod64+0x48>
8000f880:	30 19       	mov	r9,1
8000f882:	f2 08 0d 08 	divu	r8,r9,r8
8000f886:	10 9c       	mov	r12,r8
8000f888:	f8 08 12 00 	clz	r8,r12
8000f88c:	c0 31       	brne	8000f892 <__avr32_umod64+0x52>
8000f88e:	18 16       	sub	r6,r12
8000f890:	c3 68       	rjmp	8000f8fc <__avr32_umod64+0xbc>
8000f892:	f0 03 11 20 	rsub	r3,r8,32
8000f896:	f4 03 0a 4b 	lsr	r11,r10,r3
8000f89a:	f8 08 09 4c 	lsl	r12,r12,r8
8000f89e:	ec 08 09 49 	lsl	r9,r6,r8
8000f8a2:	ec 03 0a 43 	lsr	r3,r6,r3
8000f8a6:	f7 e9 10 09 	or	r9,r11,r9
8000f8aa:	f8 05 16 10 	lsr	r5,r12,0x10
8000f8ae:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000f8b2:	e6 05 0d 02 	divu	r2,r3,r5
8000f8b6:	f2 0e 16 10 	lsr	lr,r9,0x10
8000f8ba:	ec 02 02 4b 	mul	r11,r6,r2
8000f8be:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000f8c2:	16 3e       	cp.w	lr,r11
8000f8c4:	c0 72       	brcc	8000f8d2 <__avr32_umod64+0x92>
8000f8c6:	18 0e       	add	lr,r12
8000f8c8:	18 3e       	cp.w	lr,r12
8000f8ca:	c0 43       	brcs	8000f8d2 <__avr32_umod64+0x92>
8000f8cc:	16 3e       	cp.w	lr,r11
8000f8ce:	fd dc e3 0e 	addcs	lr,lr,r12
8000f8d2:	fc 0b 01 03 	sub	r3,lr,r11
8000f8d6:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000f8da:	e6 05 0d 02 	divu	r2,r3,r5
8000f8de:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000f8e2:	a5 36       	mul	r6,r2
8000f8e4:	0c 39       	cp.w	r9,r6
8000f8e6:	c0 72       	brcc	8000f8f4 <__avr32_umod64+0xb4>
8000f8e8:	18 09       	add	r9,r12
8000f8ea:	18 39       	cp.w	r9,r12
8000f8ec:	c0 43       	brcs	8000f8f4 <__avr32_umod64+0xb4>
8000f8ee:	0c 39       	cp.w	r9,r6
8000f8f0:	f3 dc e3 09 	addcs	r9,r9,r12
8000f8f4:	f2 06 01 06 	sub	r6,r9,r6
8000f8f8:	f4 08 09 4e 	lsl	lr,r10,r8
8000f8fc:	f8 0a 16 10 	lsr	r10,r12,0x10
8000f900:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000f904:	ec 0a 0d 02 	divu	r2,r6,r10
8000f908:	fc 09 16 10 	lsr	r9,lr,0x10
8000f90c:	ea 02 02 4b 	mul	r11,r5,r2
8000f910:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000f914:	16 39       	cp.w	r9,r11
8000f916:	c0 72       	brcc	8000f924 <__avr32_umod64+0xe4>
8000f918:	18 09       	add	r9,r12
8000f91a:	18 39       	cp.w	r9,r12
8000f91c:	c0 43       	brcs	8000f924 <__avr32_umod64+0xe4>
8000f91e:	16 39       	cp.w	r9,r11
8000f920:	f3 dc e3 09 	addcs	r9,r9,r12
8000f924:	f2 0b 01 0b 	sub	r11,r9,r11
8000f928:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000f92c:	f6 0a 0d 0a 	divu	r10,r11,r10
8000f930:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000f934:	ea 0a 02 4a 	mul	r10,r5,r10
8000f938:	14 3e       	cp.w	lr,r10
8000f93a:	c0 72       	brcc	8000f948 <__avr32_umod64+0x108>
8000f93c:	18 0e       	add	lr,r12
8000f93e:	18 3e       	cp.w	lr,r12
8000f940:	c0 43       	brcs	8000f948 <__avr32_umod64+0x108>
8000f942:	14 3e       	cp.w	lr,r10
8000f944:	fd dc e3 0e 	addcs	lr,lr,r12
8000f948:	fc 0a 01 0a 	sub	r10,lr,r10
8000f94c:	30 0b       	mov	r11,0
8000f94e:	f4 08 0a 4a 	lsr	r10,r10,r8
8000f952:	c7 b8       	rjmp	8000fa48 <__avr32_umod64+0x208>
8000f954:	16 39       	cp.w	r9,r11
8000f956:	e0 8b 00 79 	brhi	8000fa48 <__avr32_umod64+0x208>
8000f95a:	f2 09 12 00 	clz	r9,r9
8000f95e:	c1 21       	brne	8000f982 <__avr32_umod64+0x142>
8000f960:	10 3a       	cp.w	r10,r8
8000f962:	5f 2b       	srhs	r11
8000f964:	0a 31       	cp.w	r1,r5
8000f966:	5f ba       	srhi	r10
8000f968:	f7 ea 10 0a 	or	r10,r11,r10
8000f96c:	f2 0a 18 00 	cp.b	r10,r9
8000f970:	c0 60       	breq	8000f97c <__avr32_umod64+0x13c>
8000f972:	fc 08 01 0c 	sub	r12,lr,r8
8000f976:	e2 05 01 46 	sbc	r6,r1,r5
8000f97a:	18 9e       	mov	lr,r12
8000f97c:	0c 9b       	mov	r11,r6
8000f97e:	1c 9a       	mov	r10,lr
8000f980:	c6 48       	rjmp	8000fa48 <__avr32_umod64+0x208>
8000f982:	ea 09 09 4c 	lsl	r12,r5,r9
8000f986:	f2 06 11 20 	rsub	r6,r9,32
8000f98a:	f6 09 09 4b 	lsl	r11,r11,r9
8000f98e:	f0 09 09 42 	lsl	r2,r8,r9
8000f992:	ef 46 ff f4 	st.w	r7[-12],r6
8000f996:	f0 06 0a 48 	lsr	r8,r8,r6
8000f99a:	18 48       	or	r8,r12
8000f99c:	e2 06 0a 4c 	lsr	r12,r1,r6
8000f9a0:	f4 09 09 43 	lsl	r3,r10,r9
8000f9a4:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000f9a8:	f4 06 0a 4a 	lsr	r10,r10,r6
8000f9ac:	16 4a       	or	r10,r11
8000f9ae:	f0 0b 16 10 	lsr	r11,r8,0x10
8000f9b2:	f8 0b 0d 04 	divu	r4,r12,r11
8000f9b6:	f4 0c 16 10 	lsr	r12,r10,0x10
8000f9ba:	08 91       	mov	r1,r4
8000f9bc:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000f9c0:	e8 0e 02 46 	mul	r6,r4,lr
8000f9c4:	0c 3c       	cp.w	r12,r6
8000f9c6:	c0 a2       	brcc	8000f9da <__avr32_umod64+0x19a>
8000f9c8:	20 11       	sub	r1,1
8000f9ca:	10 0c       	add	r12,r8
8000f9cc:	10 3c       	cp.w	r12,r8
8000f9ce:	c0 63       	brcs	8000f9da <__avr32_umod64+0x19a>
8000f9d0:	0c 3c       	cp.w	r12,r6
8000f9d2:	f7 b1 03 01 	sublo	r1,1
8000f9d6:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000f9da:	0c 1c       	sub	r12,r6
8000f9dc:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000f9e0:	f8 0b 0d 04 	divu	r4,r12,r11
8000f9e4:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000f9e8:	08 96       	mov	r6,r4
8000f9ea:	e8 0e 02 4e 	mul	lr,r4,lr
8000f9ee:	1c 3b       	cp.w	r11,lr
8000f9f0:	c0 a2       	brcc	8000fa04 <__avr32_umod64+0x1c4>
8000f9f2:	20 16       	sub	r6,1
8000f9f4:	10 0b       	add	r11,r8
8000f9f6:	10 3b       	cp.w	r11,r8
8000f9f8:	c0 63       	brcs	8000fa04 <__avr32_umod64+0x1c4>
8000f9fa:	1c 3b       	cp.w	r11,lr
8000f9fc:	f7 b6 03 01 	sublo	r6,1
8000fa00:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000fa04:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000fa08:	1c 1b       	sub	r11,lr
8000fa0a:	e2 02 06 40 	mulu.d	r0,r1,r2
8000fa0e:	00 9e       	mov	lr,r0
8000fa10:	02 9c       	mov	r12,r1
8000fa12:	16 3c       	cp.w	r12,r11
8000fa14:	e0 8b 00 08 	brhi	8000fa24 <__avr32_umod64+0x1e4>
8000fa18:	5f 06       	sreq	r6
8000fa1a:	06 30       	cp.w	r0,r3
8000fa1c:	5f ba       	srhi	r10
8000fa1e:	ed ea 00 0a 	and	r10,r6,r10
8000fa22:	c0 60       	breq	8000fa2e <__avr32_umod64+0x1ee>
8000fa24:	fc 02 01 04 	sub	r4,lr,r2
8000fa28:	f8 08 01 4c 	sbc	r12,r12,r8
8000fa2c:	08 9e       	mov	lr,r4
8000fa2e:	e6 0e 01 0a 	sub	r10,r3,lr
8000fa32:	f6 0c 01 4c 	sbc	r12,r11,r12
8000fa36:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000fa3a:	f8 09 0a 4b 	lsr	r11,r12,r9
8000fa3e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000fa42:	f8 01 09 4c 	lsl	r12,r12,r1
8000fa46:	18 4a       	or	r10,r12
8000fa48:	2f dd       	sub	sp,-12
8000fa4a:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000fc00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000fc00:	c0 08       	rjmp	8000fc00 <_evba>
	...

8000fc04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000fc04:	c0 08       	rjmp	8000fc04 <_handle_TLB_Multiple_Hit>
	...

8000fc08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000fc08:	c0 08       	rjmp	8000fc08 <_handle_Bus_Error_Data_Fetch>
	...

8000fc0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000fc0c:	c0 08       	rjmp	8000fc0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000fc10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000fc10:	c0 08       	rjmp	8000fc10 <_handle_NMI>
	...

8000fc14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000fc14:	c0 08       	rjmp	8000fc14 <_handle_Instruction_Address>
	...

8000fc18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000fc18:	c0 08       	rjmp	8000fc18 <_handle_ITLB_Protection>
	...

8000fc1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000fc1c:	c0 08       	rjmp	8000fc1c <_handle_Breakpoint>
	...

8000fc20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000fc20:	c0 08       	rjmp	8000fc20 <_handle_Illegal_Opcode>
	...

8000fc24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000fc24:	c0 08       	rjmp	8000fc24 <_handle_Unimplemented_Instruction>
	...

8000fc28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000fc28:	c0 08       	rjmp	8000fc28 <_handle_Privilege_Violation>
	...

8000fc2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000fc2c:	c0 08       	rjmp	8000fc2c <_handle_Floating_Point>
	...

8000fc30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000fc30:	c0 08       	rjmp	8000fc30 <_handle_Coprocessor_Absent>
	...

8000fc34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000fc34:	c0 08       	rjmp	8000fc34 <_handle_Data_Address_Read>
	...

8000fc38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000fc38:	c0 08       	rjmp	8000fc38 <_handle_Data_Address_Write>
	...

8000fc3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000fc3c:	c0 08       	rjmp	8000fc3c <_handle_DTLB_Protection_Read>
	...

8000fc40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000fc40:	c0 08       	rjmp	8000fc40 <_handle_DTLB_Protection_Write>
	...

8000fc44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000fc44:	c0 08       	rjmp	8000fc44 <_handle_DTLB_Modified>
	...

8000fc50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000fc50:	c0 08       	rjmp	8000fc50 <_handle_ITLB_Miss>
	...

8000fc60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000fc60:	c0 08       	rjmp	8000fc60 <_handle_DTLB_Miss_Read>
	...

8000fc70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000fc70:	c0 08       	rjmp	8000fc70 <_handle_DTLB_Miss_Write>
	...

8000fd00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000fd00:	fe cf 73 88 	sub	pc,pc,29576

8000fd04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000fd04:	30 0c       	mov	r12,0
8000fd06:	fe b0 ae d7 	rcall	80005ab4 <_get_interrupt_handler>
8000fd0a:	58 0c       	cp.w	r12,0
8000fd0c:	f8 0f 17 10 	movne	pc,r12
8000fd10:	d6 03       	rete

8000fd12 <_int1>:
8000fd12:	30 1c       	mov	r12,1
8000fd14:	fe b0 ae d0 	rcall	80005ab4 <_get_interrupt_handler>
8000fd18:	58 0c       	cp.w	r12,0
8000fd1a:	f8 0f 17 10 	movne	pc,r12
8000fd1e:	d6 03       	rete

8000fd20 <_int2>:
8000fd20:	30 2c       	mov	r12,2
8000fd22:	fe b0 ae c9 	rcall	80005ab4 <_get_interrupt_handler>
8000fd26:	58 0c       	cp.w	r12,0
8000fd28:	f8 0f 17 10 	movne	pc,r12
8000fd2c:	d6 03       	rete

8000fd2e <_int3>:
8000fd2e:	30 3c       	mov	r12,3
8000fd30:	fe b0 ae c2 	rcall	80005ab4 <_get_interrupt_handler>
8000fd34:	58 0c       	cp.w	r12,0
8000fd36:	f8 0f 17 10 	movne	pc,r12
8000fd3a:	d6 03       	rete

8000fd3c <ipr_val>:
8000fd3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000fd4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fd5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fd6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fd7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fd8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fd9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fdac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fdbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fdcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fddc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fdec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fdfc:	d7 03 d7 03                                         ....
