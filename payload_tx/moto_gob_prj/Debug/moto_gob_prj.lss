
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00009cb8  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000be00  8000be00  0000c200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00009554  8000c000  8000c000  0000c400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .lalign       00000004  80015554  80015554  00015954  2**0
                  ALLOC
  6 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  7 .data         00000a2c  00000008  80015558  00015c08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .balign       00000004  00000a34  80015f84  00016634  2**0
                  ALLOC
  9 .bss          000036a0  00000a38  00000a38  00000000  2**2
                  ALLOC
 10 .heap         00012f28  000040d8  000040d8  00000000  2**0
                  ALLOC
 11 .comment      00000030  00000000  00000000  00016634  2**0
                  CONTENTS, READONLY
 12 .debug_aranges 00001170  00000000  00000000  00016668  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubnames 000023f3  00000000  00000000  000177d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_info   00027ac2  00000000  00000000  00019bcb  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_abbrev 000067e1  00000000  00000000  0004168d  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_line   0000c1be  00000000  00000000  00047e6e  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_frame  00002db4  00000000  00000000  0005402c  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    00006e0d  00000000  00000000  00056de0  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_loc    0000ca75  00000000  00000000  0005dbed  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 21 .debug_ranges 00001250  00000000  00000000  0006a668  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf 9c b0 	sub	pc,pc,-25424

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf bc b4 	sub	pc,pc,-17228

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d 78       	ld.ub	r8,--r6

8000202c <mic_brdcst_func>:
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	//log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
	//log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
			
	
}
8000202c:	5e fc       	retal	r12

8000202e <TransmitControl_brdcst_func>:
	//log("\n\r  State: %x \n\r ", ptr->State );
	//log("\n\r  State_change_reason: %x \n\r ", ptr->State_change_reason );
	//
	
	
}
8000202e:	5e fc       	retal	r12

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 50       	eor	r0,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	28 30       	sub	r0,-125
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 5c       	sub	r12,-123
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	29 88       	sub	r8,-104
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	3d a4       	mov	r4,-38
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	c0 00       	breq	80002086 <app_init+0x46>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	20 94       	sub	r4,9
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	5a cc       	cp.w	r12,-20
80002090:	00 00       	add	r0,r0
80002092:	0a 48       	or	r8,r5

80002094 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002094:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
80002096:	f0 1f 00 17 	mcall	800020f0 <app_cfg+0x5c>
8000209a:	49 78       	lddpc	r8,800020f4 <app_cfg+0x60>
8000209c:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		//if((++coun) % 200 ==0)
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
8000209e:	49 76       	lddpc	r6,800020f8 <app_cfg+0x64>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
800020a0:	49 74       	lddpc	r4,800020fc <app_cfg+0x68>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020a2:	30 40       	mov	r0,4
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020a4:	30 31       	mov	r1,3
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020a6:	30 22       	mov	r2,2
					//xcmp_unmute_speaker();
					
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020a8:	30 13       	mov	r3,1
			//log("testtime:%d", now->second);
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以2000ms为周期执行。
800020aa:	10 97       	mov	r7,r8
800020ac:	e0 65 0f a0 	mov	r5,4000
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		//if((++coun) % 200 ==0)
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800020b0:	6c 08       	ld.w	r8,r6[0x0]
800020b2:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b6:	58 38       	cp.w	r8,3
800020b8:	c1 71       	brne	800020e6 <app_cfg+0x52>
		{	
			//if((++coun) % 3 ==0)		
			{
				
				// xcmp_audio_route_speaker();
				xcmp_IdleTestTone();
800020ba:	f0 1f 00 12 	mcall	80002100 <app_cfg+0x6c>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
800020be:	68 08       	ld.w	r8,r4[0x0]
800020c0:	58 08       	cp.w	r8,0
800020c2:	c0 31       	brne	800020c8 <app_cfg+0x34>
					//xcmp_unmute_speaker();
					
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020c4:	89 03       	st.w	r4[0x0],r3
800020c6:	c1 08       	rjmp	800020e6 <app_cfg+0x52>
				}
				else if(isAudioRouting == 1)
800020c8:	58 18       	cp.w	r8,1
800020ca:	c0 31       	brne	800020d0 <app_cfg+0x3c>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020cc:	89 02       	st.w	r4[0x0],r2
800020ce:	c0 c8       	rjmp	800020e6 <app_cfg+0x52>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800020d0:	58 28       	cp.w	r8,2
800020d2:	c0 31       	brne	800020d8 <app_cfg+0x44>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020d4:	89 01       	st.w	r4[0x0],r1
800020d6:	c0 88       	rjmp	800020e6 <app_cfg+0x52>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020d8:	58 38       	cp.w	r8,3
800020da:	e9 f0 0a 00 	st.weq	r4[0x0],r0
					
				}
				else
				{
					isAudioRouting++;
800020de:	f7 b8 01 ff 	subne	r8,-1
800020e2:	e9 f8 1a 00 	st.wne	r4[0x0],r8
			//log("testtime:%d", now->second);
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以2000ms为周期执行。
800020e6:	0a 9b       	mov	r11,r5
800020e8:	0e 9c       	mov	r12,r7
800020ea:	f0 1f 00 07 	mcall	80002104 <app_cfg+0x70>
	}
800020ee:	ce 1b       	rjmp	800020b0 <app_cfg+0x1c>
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	58 04       	cp.w	r4,0
800020f4:	00 00       	add	r0,r0
800020f6:	0a 40       	or	r0,r5
800020f8:	00 00       	add	r0,r0
800020fa:	0d 78       	ld.ub	r8,--r6
800020fc:	00 00       	add	r0,r0
800020fe:	0a 38       	cp.w	r8,r5
80002100:	80 00       	ld.sh	r0,r0[0x0]
80002102:	3e a4       	mov	r4,-22
80002104:	80 00       	ld.sh	r0,r0[0x0]
80002106:	59 6c       	cp.w	r12,22

80002108 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002108:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000210a:	48 3c       	lddpc	r12,80002114 <FD_brdcst_func+0xc>
8000210c:	f0 1f 00 03 	mcall	80002118 <FD_brdcst_func+0x10>
	
}
80002110:	d8 02       	popm	pc
80002112:	00 00       	add	r0,r0
80002114:	80 00       	ld.sh	r0,r0[0x0]
80002116:	c0 08       	rjmp	80002116 <FD_brdcst_func+0xe>
80002118:	80 00       	ld.sh	r0,r0[0x0]
8000211a:	5e 90       	retgt	r0

8000211c <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
8000211c:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000211e:	48 3c       	lddpc	r12,80002128 <FD_reply_func+0xc>
80002120:	f0 1f 00 03 	mcall	8000212c <FD_reply_func+0x10>
	
	
}
80002124:	d8 02       	popm	pc
80002126:	00 00       	add	r0,r0
80002128:	80 00       	ld.sh	r0,r0[0x0]
8000212a:	c0 28       	rjmp	8000212e <FD_reply_func+0x12>
8000212c:	80 00       	ld.sh	r0,r0[0x0]
8000212e:	5e 90       	retgt	r0

80002130 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002130:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002132:	48 3c       	lddpc	r12,8000213c <FD_request_func+0xc>
80002134:	f0 1f 00 03 	mcall	80002140 <FD_request_func+0x10>
	
	
}
80002138:	d8 02       	popm	pc
8000213a:	00 00       	add	r0,r0
8000213c:	80 00       	ld.sh	r0,r0[0x0]
8000213e:	c0 44       	brge	80002146 <EnOB_brdcst_func+0x2>
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	5e 90       	retgt	r0

80002144 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002144:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002146:	48 3c       	lddpc	r12,80002150 <EnOB_brdcst_func+0xc>
80002148:	f0 1f 00 03 	mcall	80002154 <EnOB_brdcst_func+0x10>
}
8000214c:	d8 02       	popm	pc
8000214e:	00 00       	add	r0,r0
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	c0 60       	breq	8000215e <EnOB_reply_func+0x6>
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	5e 90       	retgt	r0

80002158 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002158:	eb cd 40 80 	pushm	r7,lr
8000215c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000215e:	19 a9       	ld.ub	r9,r12[0x2]
80002160:	30 08       	mov	r8,0
80002162:	f0 09 18 00 	cp.b	r9,r8
80002166:	c1 91       	brne	80002198 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002168:	19 b8       	ld.ub	r8,r12[0x3]
8000216a:	30 19       	mov	r9,1
8000216c:	f2 08 18 00 	cp.b	r8,r9
80002170:	c0 61       	brne	8000217c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002172:	49 0c       	lddpc	r12,800021b0 <EnOB_reply_func+0x58>
80002174:	f0 1f 00 10 	mcall	800021b4 <EnOB_reply_func+0x5c>
80002178:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000217c:	58 08       	cp.w	r8,0
8000217e:	c0 61       	brne	8000218a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002180:	48 ec       	lddpc	r12,800021b8 <EnOB_reply_func+0x60>
80002182:	f0 1f 00 0d 	mcall	800021b4 <EnOB_reply_func+0x5c>
80002186:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000218a:	1a d8       	st.w	--sp,r8
8000218c:	48 cc       	lddpc	r12,800021bc <EnOB_reply_func+0x64>
8000218e:	f0 1f 00 0a 	mcall	800021b4 <EnOB_reply_func+0x5c>
80002192:	2f fd       	sub	sp,-4
80002194:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002198:	48 ac       	lddpc	r12,800021c0 <EnOB_reply_func+0x68>
8000219a:	f0 1f 00 07 	mcall	800021b4 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000219e:	0f a8       	ld.ub	r8,r7[0x2]
800021a0:	1a d8       	st.w	--sp,r8
800021a2:	48 9c       	lddpc	r12,800021c4 <EnOB_reply_func+0x6c>
800021a4:	f0 1f 00 04 	mcall	800021b4 <EnOB_reply_func+0x5c>
800021a8:	2f fd       	sub	sp,-4
800021aa:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ae:	00 00       	add	r0,r0
800021b0:	80 00       	ld.sh	r0,r0[0x0]
800021b2:	c0 78       	rjmp	800021c0 <EnOB_reply_func+0x68>
800021b4:	80 00       	ld.sh	r0,r0[0x0]
800021b6:	5e 90       	retgt	r0
800021b8:	80 00       	ld.sh	r0,r0[0x0]
800021ba:	c0 90       	breq	800021cc <SingleDetection_brdcst_func+0x4>
800021bc:	80 00       	ld.sh	r0,r0[0x0]
800021be:	c0 a4       	brge	800021d2 <SingleDetection_brdcst_func+0xa>
800021c0:	80 00       	ld.sh	r0,r0[0x0]
800021c2:	c0 bc       	rcall	800021d8 <SingleDetection_brdcst_func+0x10>
800021c4:	80 00       	ld.sh	r0,r0[0x0]
800021c6:	c0 d8       	rjmp	800021e0 <SingleDetection_brdcst_func+0x18>

800021c8 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800021c8:	eb cd 40 80 	pushm	r7,lr
800021cc:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
800021ce:	19 a9       	ld.ub	r9,r12[0x2]
800021d0:	31 18       	mov	r8,17
800021d2:	f0 09 18 00 	cp.b	r9,r8
800021d6:	c0 61       	brne	800021e2 <SingleDetection_brdcst_func+0x1a>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021d8:	48 8c       	lddpc	r12,800021f8 <SingleDetection_brdcst_func+0x30>
800021da:	f0 1f 00 09 	mcall	800021fc <SingleDetection_brdcst_func+0x34>
800021de:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error");
800021e2:	48 8c       	lddpc	r12,80002200 <SingleDetection_brdcst_func+0x38>
800021e4:	f0 1f 00 06 	mcall	800021fc <SingleDetection_brdcst_func+0x34>
		log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
800021e8:	0f a8       	ld.ub	r8,r7[0x2]
800021ea:	1a d8       	st.w	--sp,r8
800021ec:	48 6c       	lddpc	r12,80002204 <SingleDetection_brdcst_func+0x3c>
800021ee:	f0 1f 00 04 	mcall	800021fc <SingleDetection_brdcst_func+0x34>
800021f2:	2f fd       	sub	sp,-4
800021f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800021f8:	80 00       	ld.sh	r0,r0[0x0]
800021fa:	c0 f0       	breq	80002218 <ButtonConfig_brdcst_func+0x10>
800021fc:	80 00       	ld.sh	r0,r0[0x0]
800021fe:	5e 90       	retgt	r0
80002200:	80 00       	ld.sh	r0,r0[0x0]
80002202:	c1 04       	brge	80002222 <ButtonConfig_brdcst_func+0x1a>
80002204:	80 00       	ld.sh	r0,r0[0x0]
80002206:	c1 14       	brge	80002228 <ButtonConfig_brdcst_func+0x20>

80002208 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002208:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
8000220a:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
8000220e:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002210:	4a bc       	lddpc	r12,800022bc <ButtonConfig_brdcst_func+0xb4>
80002212:	f0 1f 00 2c 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80002216:	0f 88       	ld.ub	r8,r7[0x0]
80002218:	1a d8       	st.w	--sp,r8
8000221a:	4a bc       	lddpc	r12,800022c4 <ButtonConfig_brdcst_func+0xbc>
8000221c:	f0 1f 00 29 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002220:	1a d5       	st.w	--sp,r5
80002222:	4a ac       	lddpc	r12,800022c8 <ButtonConfig_brdcst_func+0xc0>
80002224:	f0 1f 00 27 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002228:	0f a8       	ld.ub	r8,r7[0x2]
8000222a:	1a d8       	st.w	--sp,r8
8000222c:	4a 8c       	lddpc	r12,800022cc <ButtonConfig_brdcst_func+0xc4>
8000222e:	f0 1f 00 25 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
80002232:	2f dd       	sub	sp,-12
80002234:	58 05       	cp.w	r5,0
80002236:	c4 10       	breq	800022b8 <ButtonConfig_brdcst_func+0xb0>
80002238:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000223a:	4a 64       	lddpc	r4,800022d0 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000223c:	4a 63       	lddpc	r3,800022d4 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000223e:	4a 72       	lddpc	r2,800022d8 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002240:	4a 71       	lddpc	r1,800022dc <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002242:	4a 80       	lddpc	r0,800022e0 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002244:	0f b9       	ld.ub	r9,r7[0x3]
80002246:	0f c8       	ld.ub	r8,r7[0x4]
80002248:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224c:	1a d8       	st.w	--sp,r8
8000224e:	1a d6       	st.w	--sp,r6
80002250:	08 9c       	mov	r12,r4
80002252:	f0 1f 00 1c 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002256:	0f d9       	ld.ub	r9,r7[0x5]
80002258:	0f e8       	ld.ub	r8,r7[0x6]
8000225a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000225e:	1a d8       	st.w	--sp,r8
80002260:	1a d6       	st.w	--sp,r6
80002262:	06 9c       	mov	r12,r3
80002264:	f0 1f 00 17 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002268:	0f f9       	ld.ub	r9,r7[0x7]
8000226a:	ef 38 00 08 	ld.ub	r8,r7[8]
8000226e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002272:	1a d8       	st.w	--sp,r8
80002274:	1a d6       	st.w	--sp,r6
80002276:	04 9c       	mov	r12,r2
80002278:	f0 1f 00 12 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000227c:	ef 39 00 09 	ld.ub	r9,r7[9]
80002280:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002284:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002288:	1a d8       	st.w	--sp,r8
8000228a:	1a d6       	st.w	--sp,r6
8000228c:	02 9c       	mov	r12,r1
8000228e:	f0 1f 00 0d 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002292:	2f 8d       	sub	sp,-32
80002294:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002298:	ef 38 00 0c 	ld.ub	r8,r7[12]
8000229c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022a0:	1a d8       	st.w	--sp,r8
800022a2:	1a d6       	st.w	--sp,r6
800022a4:	00 9c       	mov	r12,r0
800022a6:	f0 1f 00 07 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
800022aa:	2f f6       	sub	r6,-1
800022ac:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022ae:	2f ed       	sub	sp,-8
800022b0:	ec 05 18 00 	cp.b	r5,r6
800022b4:	fe 9b ff c8 	brhi	80002244 <ButtonConfig_brdcst_func+0x3c>
800022b8:	d8 32       	popm	r0-r7,pc
800022ba:	00 00       	add	r0,r0
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	c1 2c       	rcall	800022e2 <ButtonConfig_brdcst_func+0xda>
800022c0:	80 00       	ld.sh	r0,r0[0x0]
800022c2:	5e 90       	retgt	r0
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	c1 4c       	rcall	800022ee <Phyuserinput_brdcst_func+0xa>
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	c1 60       	breq	800022f6 <Phyuserinput_brdcst_func+0x12>
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	c1 78       	rjmp	800022fc <Phyuserinput_brdcst_func+0x18>
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	c1 98       	rjmp	80002304 <Phyuserinput_brdcst_func+0x20>
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	c1 c0       	breq	8000230e <Phyuserinput_brdcst_func+0x2a>
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	c1 e8       	rjmp	80002316 <Phyuserinput_brdcst_func+0x32>
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	c2 0c       	rcall	8000231e <Phyuserinput_brdcst_func+0x3a>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	c2 34       	brge	80002328 <Phyuserinput_brdcst_func+0x44>

800022e4 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022e4:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
800022e8:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
800022ea:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800022ec:	19 c7       	ld.ub	r7,r12[0x4]
800022ee:	19 d8       	ld.ub	r8,r12[0x5]
800022f0:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
800022f4:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
800022f6:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
800022f8:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
800022fc:	49 0c       	lddpc	r12,8000233c <Phyuserinput_brdcst_func+0x58>
800022fe:	f0 1f 00 11 	mcall	80002340 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
80002302:	1a d6       	st.w	--sp,r6
80002304:	49 0c       	lddpc	r12,80002344 <Phyuserinput_brdcst_func+0x60>
80002306:	f0 1f 00 0f 	mcall	80002340 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
8000230a:	1a d5       	st.w	--sp,r5
8000230c:	48 fc       	lddpc	r12,80002348 <Phyuserinput_brdcst_func+0x64>
8000230e:	f0 1f 00 0d 	mcall	80002340 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
80002312:	5c 77       	castu.h	r7
80002314:	1a d7       	st.w	--sp,r7
80002316:	48 ec       	lddpc	r12,8000234c <Phyuserinput_brdcst_func+0x68>
80002318:	f0 1f 00 0a 	mcall	80002340 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
8000231c:	1a d4       	st.w	--sp,r4
8000231e:	48 dc       	lddpc	r12,80002350 <Phyuserinput_brdcst_func+0x6c>
80002320:	f0 1f 00 08 	mcall	80002340 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
80002324:	1a d3       	st.w	--sp,r3
80002326:	48 cc       	lddpc	r12,80002354 <Phyuserinput_brdcst_func+0x70>
80002328:	f0 1f 00 06 	mcall	80002340 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
8000232c:	1a d2       	st.w	--sp,r2
8000232e:	48 bc       	lddpc	r12,80002358 <Phyuserinput_brdcst_func+0x74>
80002330:	f0 1f 00 04 	mcall	80002340 <Phyuserinput_brdcst_func+0x5c>
80002334:	2f ad       	sub	sp,-24
	
	
	
	
	
}
80002336:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000233a:	00 00       	add	r0,r0
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	c2 58       	rjmp	80002388 <ButtonConfig_reply_func+0x2c>
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	5e 90       	retgt	r0
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	c2 7c       	rcall	80002394 <ButtonConfig_reply_func+0x38>
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	c2 94       	brge	8000239c <ButtonConfig_reply_func+0x40>
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	c2 a8       	rjmp	800023a2 <DataSession_brdcst_func+0x2>
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	c2 bc       	rcall	800023a8 <DataSession_brdcst_func+0x8>
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	c2 d0       	breq	800023b0 <DataSession_brdcst_func+0x10>
80002358:	80 00       	ld.sh	r0,r0[0x0]
8000235a:	c2 f0       	breq	800023b8 <DataSession_brdcst_func+0x18>

8000235c <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
8000235c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002360:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002364:	0f 89       	ld.ub	r9,r7[0x0]
80002366:	30 08       	mov	r8,0
80002368:	f0 09 18 00 	cp.b	r9,r8
8000236c:	c0 c1       	brne	80002384 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000236e:	48 9c       	lddpc	r12,80002390 <ButtonConfig_reply_func+0x34>
80002370:	f0 1f 00 09 	mcall	80002394 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002374:	0f 98       	ld.ub	r8,r7[0x1]
80002376:	1a d8       	st.w	--sp,r8
80002378:	48 8c       	lddpc	r12,80002398 <ButtonConfig_reply_func+0x3c>
8000237a:	f0 1f 00 07 	mcall	80002394 <ButtonConfig_reply_func+0x38>
8000237e:	2f fd       	sub	sp,-4
80002380:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002384:	48 6c       	lddpc	r12,8000239c <ButtonConfig_reply_func+0x40>
80002386:	f0 1f 00 04 	mcall	80002394 <ButtonConfig_reply_func+0x38>
8000238a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000238e:	00 00       	add	r0,r0
80002390:	80 00       	ld.sh	r0,r0[0x0]
80002392:	c3 10       	breq	800023f4 <DataSession_brdcst_func+0x54>
80002394:	80 00       	ld.sh	r0,r0[0x0]
80002396:	5e 90       	retgt	r0
80002398:	80 00       	ld.sh	r0,r0[0x0]
8000239a:	c1 4c       	rcall	800023c2 <DataSession_brdcst_func+0x22>
8000239c:	80 00       	ld.sh	r0,r0[0x0]
8000239e:	c3 28       	rjmp	80002402 <DataSession_brdcst_func+0x62>

800023a0 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800023a0:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800023a2:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
800023a6:	0d 88       	ld.ub	r8,r6[0x0]
800023a8:	32 49       	mov	r9,36
800023aa:	f2 08 18 00 	cp.b	r8,r9
800023ae:	c2 91       	brne	80002400 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800023b0:	49 7c       	lddpc	r12,8000240c <DataSession_brdcst_func+0x6c>
800023b2:	f0 1f 00 18 	mcall	80002410 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023b6:	0d a5       	ld.ub	r5,r6[0x2]
800023b8:	0d b8       	ld.ub	r8,r6[0x3]
800023ba:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800023be:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800023c0:	0d 98       	ld.ub	r8,r6[0x1]
800023c2:	1a d8       	st.w	--sp,r8
800023c4:	49 4c       	lddpc	r12,80002414 <DataSession_brdcst_func+0x74>
800023c6:	f0 1f 00 13 	mcall	80002410 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023ca:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800023ce:	1a d8       	st.w	--sp,r8
800023d0:	49 2c       	lddpc	r12,80002418 <DataSession_brdcst_func+0x78>
800023d2:	f0 1f 00 10 	mcall	80002410 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
800023d6:	2f ed       	sub	sp,-8
800023d8:	58 05       	cp.w	r5,0
800023da:	c1 80       	breq	8000240a <DataSession_brdcst_func+0x6a>
800023dc:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800023de:	49 04       	lddpc	r4,8000241c <DataSession_brdcst_func+0x7c>
800023e0:	ec 07 00 08 	add	r8,r6,r7
800023e4:	11 c8       	ld.ub	r8,r8[0x4]
800023e6:	1a d8       	st.w	--sp,r8
800023e8:	1a d7       	st.w	--sp,r7
800023ea:	08 9c       	mov	r12,r4
800023ec:	f0 1f 00 09 	mcall	80002410 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800023f0:	2f f7       	sub	r7,-1
800023f2:	5c 57       	castu.b	r7
800023f4:	2f ed       	sub	sp,-8
800023f6:	ee 05 19 00 	cp.h	r5,r7
800023fa:	fe 9b ff f3 	brhi	800023e0 <DataSession_brdcst_func+0x40>
800023fe:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002400:	1a d8       	st.w	--sp,r8
80002402:	48 8c       	lddpc	r12,80002420 <DataSession_brdcst_func+0x80>
80002404:	f0 1f 00 03 	mcall	80002410 <DataSession_brdcst_func+0x70>
80002408:	2f fd       	sub	sp,-4
8000240a:	d8 22       	popm	r4-r7,pc
8000240c:	80 00       	ld.sh	r0,r0[0x0]
8000240e:	c3 44       	brge	80002476 <DataSession_reply_func+0x52>
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	5e 90       	retgt	r0
80002414:	80 00       	ld.sh	r0,r0[0x0]
80002416:	c3 58       	rjmp	80002480 <TransmitControl_reply_func+0x4>
80002418:	80 00       	ld.sh	r0,r0[0x0]
8000241a:	c3 70       	breq	80002488 <TransmitControl_reply_func+0xc>
8000241c:	80 00       	ld.sh	r0,r0[0x0]
8000241e:	c3 8c       	rcall	8000248e <TransmitControl_reply_func+0x12>
80002420:	80 00       	ld.sh	r0,r0[0x0]
80002422:	c3 a4       	brge	80002496 <TransmitControl_reply_func+0x1a>

80002424 <DataSession_reply_func>:
	
}


void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002424:	eb cd 40 80 	pushm	r7,lr
80002428:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000242a:	19 a8       	ld.ub	r8,r12[0x2]
8000242c:	58 08       	cp.w	r8,0
8000242e:	c0 61       	brne	8000243a <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
80002430:	48 dc       	lddpc	r12,80002464 <DataSession_reply_func+0x40>
80002432:	f0 1f 00 0e 	mcall	80002468 <DataSession_reply_func+0x44>
80002436:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
8000243a:	1a d8       	st.w	--sp,r8
8000243c:	48 cc       	lddpc	r12,8000246c <DataSession_reply_func+0x48>
8000243e:	f0 1f 00 0b 	mcall	80002468 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
80002442:	48 cc       	lddpc	r12,80002470 <DataSession_reply_func+0x4c>
80002444:	f0 1f 00 09 	mcall	80002468 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
80002448:	0f b8       	ld.ub	r8,r7[0x3]
8000244a:	1a d8       	st.w	--sp,r8
8000244c:	48 ac       	lddpc	r12,80002474 <DataSession_reply_func+0x50>
8000244e:	f0 1f 00 07 	mcall	80002468 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
80002452:	0f c8       	ld.ub	r8,r7[0x4]
80002454:	1a d8       	st.w	--sp,r8
80002456:	48 9c       	lddpc	r12,80002478 <DataSession_reply_func+0x54>
80002458:	f0 1f 00 04 	mcall	80002468 <DataSession_reply_func+0x44>
8000245c:	2f dd       	sub	sp,-12
8000245e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002462:	00 00       	add	r0,r0
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	c3 b8       	rjmp	800024dc <TransmitControl_reply_func+0x60>
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	5e 90       	retgt	r0
8000246c:	80 00       	ld.sh	r0,r0[0x0]
8000246e:	c3 cc       	rcall	800024e6 <TransmitControl_reply_func+0x6a>
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	c3 e0       	breq	800024ee <TransmitControl_reply_func+0x72>
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	c3 f4       	brge	800024f4 <TransmitControl_reply_func+0x78>
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	c4 04       	brge	800024fa <AudioRoutingControl_brdcst_func+0x2>

8000247c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000247c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002480:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002484:	0f 89       	ld.ub	r9,r7[0x0]
80002486:	30 08       	mov	r8,0
80002488:	f0 09 18 00 	cp.b	r9,r8
8000248c:	c2 21       	brne	800024d0 <TransmitControl_reply_func+0x54>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000248e:	49 4c       	lddpc	r12,800024dc <TransmitControl_reply_func+0x60>
80002490:	f0 1f 00 14 	mcall	800024e0 <TransmitControl_reply_func+0x64>
		log("\n\r Function: %x \n\r", ptr->Function);
80002494:	0f 98       	ld.ub	r8,r7[0x1]
80002496:	1a d8       	st.w	--sp,r8
80002498:	49 3c       	lddpc	r12,800024e4 <TransmitControl_reply_func+0x68>
8000249a:	f0 1f 00 12 	mcall	800024e0 <TransmitControl_reply_func+0x64>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000249e:	0f a8       	ld.ub	r8,r7[0x2]
800024a0:	1a d8       	st.w	--sp,r8
800024a2:	49 2c       	lddpc	r12,800024e8 <TransmitControl_reply_func+0x6c>
800024a4:	f0 1f 00 0f 	mcall	800024e0 <TransmitControl_reply_func+0x64>
		log("\n\r State: %x \n\r", ptr->State);
800024a8:	0f b8       	ld.ub	r8,r7[0x3]
800024aa:	1a d8       	st.w	--sp,r8
800024ac:	49 0c       	lddpc	r12,800024ec <TransmitControl_reply_func+0x70>
800024ae:	f0 1f 00 0d 	mcall	800024e0 <TransmitControl_reply_func+0x64>
		
		if (ptr->Function == KEY_UP)
800024b2:	0f 98       	ld.ub	r8,r7[0x1]
800024b4:	2f dd       	sub	sp,-12
800024b6:	30 19       	mov	r9,1
800024b8:	f2 08 18 00 	cp.b	r8,r9
800024bc:	c0 d0       	breq	800024d6 <TransmitControl_reply_func+0x5a>
		{
			//is_unmute = 1;
		}
		else if (ptr->Function ==DE_KEY)
800024be:	30 29       	mov	r9,2
800024c0:	f2 08 18 00 	cp.b	r8,r9
800024c4:	c0 91       	brne	800024d6 <TransmitControl_reply_func+0x5a>
		{
			is_unmute = 0;
800024c6:	30 09       	mov	r9,0
800024c8:	48 a8       	lddpc	r8,800024f0 <TransmitControl_reply_func+0x74>
800024ca:	b0 89       	st.b	r8[0x0],r9
800024cc:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800024d0:	48 9c       	lddpc	r12,800024f4 <TransmitControl_reply_func+0x78>
800024d2:	f0 1f 00 04 	mcall	800024e0 <TransmitControl_reply_func+0x64>
800024d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800024da:	00 00       	add	r0,r0
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	c4 14       	brge	80002560 <AudioRoutingControl_brdcst_func+0x68>
800024e0:	80 00       	ld.sh	r0,r0[0x0]
800024e2:	5e 90       	retgt	r0
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	c4 30       	breq	8000256c <AudioRoutingControl_brdcst_func+0x74>
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	c4 44       	brge	80002572 <AudioRoutingControl_brdcst_func+0x7a>
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	c4 60       	breq	8000257a <AudioRoutingControl_reply_func+0x2>
800024f0:	00 00       	add	r0,r0
800024f2:	0a 45       	or	r5,r5
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	c4 70       	breq	80002584 <AudioRoutingControl_reply_func+0xc>

800024f8 <AudioRoutingControl_brdcst_func>:
	}
}


void AudioRoutingControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024f8:	eb cd 40 f8 	pushm	r3-r7,lr
800024fc:	18 96       	mov	r6,r12
	
	U16 num_routings = 0;
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
800024fe:	19 a5       	ld.ub	r5,r12[0x2]
80002500:	19 b8       	ld.ub	r8,r12[0x3]
80002502:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002506:	5c 85       	casts.h	r5
	log("\n\r num_routings: %d \n\r", num_routings);
80002508:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000250c:	1a d8       	st.w	--sp,r8
8000250e:	49 6c       	lddpc	r12,80002564 <AudioRoutingControl_brdcst_func+0x6c>
80002510:	f0 1f 00 16 	mcall	80002568 <AudioRoutingControl_brdcst_func+0x70>
	
	for(j = 0; j< num_routings ; j++ )
80002514:	2f fd       	sub	sp,-4
80002516:	58 05       	cp.w	r5,0
80002518:	c0 31       	brne	8000251e <AudioRoutingControl_brdcst_func+0x26>
8000251a:	30 07       	mov	r7,0
8000251c:	c1 98       	rjmp	8000254e <AudioRoutingControl_brdcst_func+0x56>
8000251e:	30 07       	mov	r7,0
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
80002520:	49 34       	lddpc	r4,8000256c <AudioRoutingControl_brdcst_func+0x74>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
80002522:	49 43       	lddpc	r3,80002570 <AudioRoutingControl_brdcst_func+0x78>
	
	for(j = 0; j< num_routings ; j++ )
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
80002524:	ec 07 00 18 	add	r8,r6,r7<<0x1
80002528:	11 c8       	ld.ub	r8,r8[0x4]
8000252a:	1a d8       	st.w	--sp,r8
8000252c:	08 9c       	mov	r12,r4
8000252e:	f0 1f 00 0f 	mcall	80002568 <AudioRoutingControl_brdcst_func+0x70>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
80002532:	ec 07 00 18 	add	r8,r6,r7<<0x1
80002536:	11 d8       	ld.ub	r8,r8[0x5]
80002538:	1a d8       	st.w	--sp,r8
8000253a:	06 9c       	mov	r12,r3
8000253c:	f0 1f 00 0b 	mcall	80002568 <AudioRoutingControl_brdcst_func+0x70>
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
	log("\n\r num_routings: %d \n\r", num_routings);
	
	for(j = 0; j< num_routings ; j++ )
80002540:	2f f7       	sub	r7,-1
80002542:	5c 57       	castu.b	r7
80002544:	2f ed       	sub	sp,-8
80002546:	ee 05 19 00 	cp.h	r5,r7
8000254a:	fe 9b ff ed 	brhi	80002524 <AudioRoutingControl_brdcst_func+0x2c>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
		
		
	}
	
	log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
8000254e:	ec 07 00 17 	add	r7,r6,r7<<0x1
80002552:	0f c8       	ld.ub	r8,r7[0x4]
80002554:	1a d8       	st.w	--sp,r8
80002556:	48 8c       	lddpc	r12,80002574 <AudioRoutingControl_brdcst_func+0x7c>
80002558:	f0 1f 00 04 	mcall	80002568 <AudioRoutingControl_brdcst_func+0x70>
8000255c:	2f fd       	sub	sp,-4
	
	
	
}
8000255e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002562:	00 00       	add	r0,r0
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	c4 88       	rjmp	800025f6 <Volume_reply_func+0xa>
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	5e 90       	retgt	r0
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	c4 a0       	breq	80002602 <Volume_reply_func+0x16>
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	c4 b8       	rjmp	80002608 <Volume_reply_func+0x1c>
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	c4 d0       	breq	80002610 <Volume_reply_func+0x24>

80002578 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002578:	eb cd 40 80 	pushm	r7,lr
8000257c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000257e:	19 a9       	ld.ub	r9,r12[0x2]
80002580:	30 08       	mov	r8,0
80002582:	f0 09 18 00 	cp.b	r9,r8
80002586:	c0 61       	brne	80002592 <AudioRoutingControl_reply_func+0x1a>
	{
		log("AudioRouting OK");
80002588:	48 8c       	lddpc	r12,800025a8 <AudioRoutingControl_reply_func+0x30>
8000258a:	f0 1f 00 09 	mcall	800025ac <AudioRoutingControl_reply_func+0x34>
8000258e:	e3 cd 80 80 	ldm	sp++,r7,pc
		//is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002592:	48 8c       	lddpc	r12,800025b0 <AudioRoutingControl_reply_func+0x38>
80002594:	f0 1f 00 06 	mcall	800025ac <AudioRoutingControl_reply_func+0x34>
		log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
80002598:	0f a8       	ld.ub	r8,r7[0x2]
8000259a:	1a d8       	st.w	--sp,r8
8000259c:	48 6c       	lddpc	r12,800025b4 <AudioRoutingControl_reply_func+0x3c>
8000259e:	f0 1f 00 04 	mcall	800025ac <AudioRoutingControl_reply_func+0x34>
800025a2:	2f fd       	sub	sp,-4
800025a4:	e3 cd 80 80 	ldm	sp++,r7,pc
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	c4 ec       	rcall	80002646 <Volume_reply_func+0x5a>
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	5e 90       	retgt	r0
800025b0:	80 00       	ld.sh	r0,r0[0x0]
800025b2:	c4 fc       	rcall	80002650 <spk_brdcst_func>
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	c5 10       	breq	80002658 <spk_brdcst_func+0x8>

800025b8 <Volume_brdcst_func>:
	
	
}

void Volume_brdcst_func(xcmp_fragment_t * xcmp)
{
800025b8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	VolumeControl_brdcst_t *ptr = (VolumeControl_brdcst_t* )xcmp->u8;
800025bc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800025c0:	0f 89       	ld.ub	r9,r7[0x0]
800025c2:	0f 98       	ld.ub	r8,r7[0x1]
800025c4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025c8:	1a d8       	st.w	--sp,r8
800025ca:	48 6c       	lddpc	r12,800025e0 <Volume_brdcst_func+0x28>
800025cc:	f0 1f 00 06 	mcall	800025e4 <Volume_brdcst_func+0x2c>
	
	log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
800025d0:	0f b8       	ld.ub	r8,r7[0x3]
800025d2:	1a d8       	st.w	--sp,r8
800025d4:	48 5c       	lddpc	r12,800025e8 <Volume_brdcst_func+0x30>
800025d6:	f0 1f 00 04 	mcall	800025e4 <Volume_brdcst_func+0x2c>
800025da:	2f ed       	sub	sp,-8
	
	
}
800025dc:	e3 cd 80 80 	ldm	sp++,r7,pc
800025e0:	80 00       	ld.sh	r0,r0[0x0]
800025e2:	c5 30       	breq	80002688 <spk_brdcst_func+0x38>
800025e4:	80 00       	ld.sh	r0,r0[0x0]
800025e6:	5e 90       	retgt	r0
800025e8:	80 00       	ld.sh	r0,r0[0x0]
800025ea:	c5 4c       	rcall	80002692 <spk_brdcst_func+0x42>

800025ec <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
800025ec:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800025f0:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800025f4:	0f 89       	ld.ub	r9,r7[0x0]
800025f6:	30 08       	mov	r8,0
800025f8:	f0 09 18 00 	cp.b	r9,r8
800025fc:	c1 b1       	brne	80002632 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800025fe:	0f b8       	ld.ub	r8,r7[0x3]
80002600:	31 09       	mov	r9,16
80002602:	f2 08 18 00 	cp.b	r8,r9
80002606:	c0 f1       	brne	80002624 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002608:	48 dc       	lddpc	r12,8000263c <Volume_reply_func+0x50>
8000260a:	f0 1f 00 0e 	mcall	80002640 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
8000260e:	0f 99       	ld.ub	r9,r7[0x1]
80002610:	0f a8       	ld.ub	r8,r7[0x2]
80002612:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002616:	1a d8       	st.w	--sp,r8
80002618:	48 bc       	lddpc	r12,80002644 <Volume_reply_func+0x58>
8000261a:	f0 1f 00 0a 	mcall	80002640 <Volume_reply_func+0x54>
8000261e:	2f fd       	sub	sp,-4
80002620:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002624:	1a d8       	st.w	--sp,r8
80002626:	48 9c       	lddpc	r12,80002648 <Volume_reply_func+0x5c>
80002628:	f0 1f 00 06 	mcall	80002640 <Volume_reply_func+0x54>
8000262c:	2f fd       	sub	sp,-4
8000262e:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
80002632:	48 7c       	lddpc	r12,8000264c <Volume_reply_func+0x60>
80002634:	f0 1f 00 03 	mcall	80002640 <Volume_reply_func+0x54>
80002638:	e3 cd 80 80 	ldm	sp++,r7,pc
8000263c:	80 00       	ld.sh	r0,r0[0x0]
8000263e:	c5 68       	rjmp	800026ea <mic_reply_func+0x26>
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	5e 90       	retgt	r0
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	c5 30       	breq	800026ec <mic_reply_func+0x28>
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	c5 7c       	rcall	800026f8 <mic_reply_func+0x34>
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	c5 94       	brge	80002700 <mic_reply_func+0x3c>

80002650 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002650:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002652:	19 d9       	ld.ub	r9,r12[0x5]
80002654:	30 08       	mov	r8,0
80002656:	f0 09 18 00 	cp.b	r9,r8
8000265a:	c0 91       	brne	8000266c <spk_brdcst_func+0x1c>
	{
		is_unmute =0;
8000265c:	48 99       	lddpc	r9,80002680 <spk_brdcst_func+0x30>
8000265e:	b2 88       	st.b	r9[0x0],r8
		Silent_flag = 0;
80002660:	48 99       	lddpc	r9,80002684 <spk_brdcst_func+0x34>
80002662:	b2 88       	st.b	r9[0x0],r8
		log("spk_s_close ");
80002664:	48 9c       	lddpc	r12,80002688 <spk_brdcst_func+0x38>
80002666:	f0 1f 00 0a 	mcall	8000268c <spk_brdcst_func+0x3c>
8000266a:	d8 02       	popm	pc
		
		
	}
	else
	{
		Silent_flag = 1;
8000266c:	30 18       	mov	r8,1
8000266e:	48 69       	lddpc	r9,80002684 <spk_brdcst_func+0x34>
80002670:	b2 88       	st.b	r9[0x0],r8
		is_unmute = 1;
80002672:	48 49       	lddpc	r9,80002680 <spk_brdcst_func+0x30>
80002674:	b2 88       	st.b	r9[0x0],r8
		log("spk_s_open ");
80002676:	48 7c       	lddpc	r12,80002690 <spk_brdcst_func+0x40>
80002678:	f0 1f 00 05 	mcall	8000268c <spk_brdcst_func+0x3c>
8000267c:	d8 02       	popm	pc
8000267e:	00 00       	add	r0,r0
80002680:	00 00       	add	r0,r0
80002682:	0a 45       	or	r5,r5
80002684:	00 00       	add	r0,r0
80002686:	0a 4c       	or	r12,r5
80002688:	80 00       	ld.sh	r0,r0[0x0]
8000268a:	c5 ac       	rcall	8000273e <mic_reply_func+0x7a>
8000268c:	80 00       	ld.sh	r0,r0[0x0]
8000268e:	5e 90       	retgt	r0
80002690:	80 00       	ld.sh	r0,r0[0x0]
80002692:	c5 bc       	rcall	80002748 <mic_reply_func+0x84>

80002694 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002694:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002696:	19 a9       	ld.ub	r9,r12[0x2]
80002698:	30 08       	mov	r8,0
8000269a:	f0 09 18 00 	cp.b	r9,r8
8000269e:	c0 81       	brne	800026ae <spk_reply_func+0x1a>
		{
			//is_unmute = 1;
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800026a0:	19 e8       	ld.ub	r8,r12[0x6]
800026a2:	1a d8       	st.w	--sp,r8
800026a4:	48 5c       	lddpc	r12,800026b8 <spk_reply_func+0x24>
800026a6:	f0 1f 00 06 	mcall	800026bc <spk_reply_func+0x28>
800026aa:	2f fd       	sub	sp,-4
800026ac:	d8 02       	popm	pc
		
	}
	else
	{
		log("spk error");
800026ae:	48 5c       	lddpc	r12,800026c0 <spk_reply_func+0x2c>
800026b0:	f0 1f 00 03 	mcall	800026bc <spk_reply_func+0x28>
800026b4:	d8 02       	popm	pc
800026b6:	00 00       	add	r0,r0
800026b8:	80 00       	ld.sh	r0,r0[0x0]
800026ba:	c5 c8       	rjmp	80002772 <dcm_brdcst_func+0x1a>
800026bc:	80 00       	ld.sh	r0,r0[0x0]
800026be:	5e 90       	retgt	r0
800026c0:	80 00       	ld.sh	r0,r0[0x0]
800026c2:	c5 d8       	rjmp	8000277c <dcm_brdcst_func+0x24>

800026c4 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800026c4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800026c8:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800026cc:	49 ac       	lddpc	r12,80002734 <mic_reply_func+0x70>
800026ce:	f0 1f 00 1b 	mcall	80002738 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800026d2:	0f 89       	ld.ub	r9,r7[0x0]
800026d4:	30 08       	mov	r8,0
800026d6:	f0 09 18 00 	cp.b	r9,r8
800026da:	c2 71       	brne	80002728 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800026dc:	0f 98       	ld.ub	r8,r7[0x1]
800026de:	30 29       	mov	r9,2
800026e0:	f2 08 18 00 	cp.b	r8,r9
800026e4:	c1 b1       	brne	8000271a <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800026e6:	49 6c       	lddpc	r12,8000273c <mic_reply_func+0x78>
800026e8:	f0 1f 00 14 	mcall	80002738 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800026ec:	0f a8       	ld.ub	r8,r7[0x2]
800026ee:	1a d8       	st.w	--sp,r8
800026f0:	49 4c       	lddpc	r12,80002740 <mic_reply_func+0x7c>
800026f2:	f0 1f 00 12 	mcall	80002738 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800026f6:	0f b8       	ld.ub	r8,r7[0x3]
800026f8:	1a d8       	st.w	--sp,r8
800026fa:	49 3c       	lddpc	r12,80002744 <mic_reply_func+0x80>
800026fc:	f0 1f 00 0f 	mcall	80002738 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002700:	0f c8       	ld.ub	r8,r7[0x4]
80002702:	1a d8       	st.w	--sp,r8
80002704:	49 1c       	lddpc	r12,80002748 <mic_reply_func+0x84>
80002706:	f0 1f 00 0d 	mcall	80002738 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000270a:	0f d8       	ld.ub	r8,r7[0x5]
8000270c:	1a d8       	st.w	--sp,r8
8000270e:	49 0c       	lddpc	r12,8000274c <mic_reply_func+0x88>
80002710:	f0 1f 00 0a 	mcall	80002738 <mic_reply_func+0x74>
80002714:	2f cd       	sub	sp,-16
80002716:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
8000271a:	1a d8       	st.w	--sp,r8
8000271c:	48 dc       	lddpc	r12,80002750 <mic_reply_func+0x8c>
8000271e:	f0 1f 00 07 	mcall	80002738 <mic_reply_func+0x74>
80002722:	2f fd       	sub	sp,-4
80002724:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002728:	48 bc       	lddpc	r12,80002754 <mic_reply_func+0x90>
8000272a:	f0 1f 00 04 	mcall	80002738 <mic_reply_func+0x74>
8000272e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002732:	00 00       	add	r0,r0
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	c5 e4       	brge	800027f2 <dcm_reply_func+0x52>
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	5e 90       	retgt	r0
8000273c:	80 00       	ld.sh	r0,r0[0x0]
8000273e:	c5 f4       	brge	800027fc <dcm_reply_func+0x5c>
80002740:	80 00       	ld.sh	r0,r0[0x0]
80002742:	c6 08       	rjmp	80002802 <dcm_reply_func+0x62>
80002744:	80 00       	ld.sh	r0,r0[0x0]
80002746:	c6 1c       	rcall	80002808 <ToneControl_reply_func>
80002748:	80 00       	ld.sh	r0,r0[0x0]
8000274a:	c6 38       	rjmp	80002810 <ToneControl_reply_func+0x8>
8000274c:	80 00       	ld.sh	r0,r0[0x0]
8000274e:	c6 50       	breq	80002818 <ToneControl_reply_func+0x10>
80002750:	80 00       	ld.sh	r0,r0[0x0]
80002752:	c6 68       	rjmp	8000281e <ToneControl_reply_func+0x16>
80002754:	80 00       	ld.sh	r0,r0[0x0]
80002756:	c6 80       	breq	80002826 <ToneControl_reply_func+0x1e>

80002758 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002758:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
8000275c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002760:	48 bc       	lddpc	r12,8000278c <dcm_brdcst_func+0x34>
80002762:	f0 1f 00 0c 	mcall	80002790 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002766:	0f 88       	ld.ub	r8,r7[0x0]
80002768:	1a d8       	st.w	--sp,r8
8000276a:	48 bc       	lddpc	r12,80002794 <dcm_brdcst_func+0x3c>
8000276c:	f0 1f 00 09 	mcall	80002790 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002770:	0f a8       	ld.ub	r8,r7[0x2]
80002772:	1a d8       	st.w	--sp,r8
80002774:	48 9c       	lddpc	r12,80002798 <dcm_brdcst_func+0x40>
80002776:	f0 1f 00 07 	mcall	80002790 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000277a:	0f 98       	ld.ub	r8,r7[0x1]
8000277c:	1a d8       	st.w	--sp,r8
8000277e:	48 8c       	lddpc	r12,8000279c <dcm_brdcst_func+0x44>
80002780:	f0 1f 00 04 	mcall	80002790 <dcm_brdcst_func+0x38>
80002784:	2f dd       	sub	sp,-12
	
	
}
80002786:	e3 cd 80 80 	ldm	sp++,r7,pc
8000278a:	00 00       	add	r0,r0
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	c6 90       	breq	80002860 <app_payload_rx_proc+0x4>
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	5e 90       	retgt	r0
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	c6 a4       	brge	8000286a <app_payload_rx_proc+0xe>
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	c6 b8       	rjmp	80002870 <app_payload_rx_proc+0x14>
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	c6 d0       	breq	80002878 <app_payload_rx_proc+0x1c>

800027a0 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800027a0:	eb cd 40 80 	pushm	r7,lr
800027a4:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800027a6:	19 a9       	ld.ub	r9,r12[0x2]
800027a8:	30 08       	mov	r8,0
800027aa:	f0 09 18 00 	cp.b	r9,r8
800027ae:	c1 b1       	brne	800027e4 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800027b0:	19 b8       	ld.ub	r8,r12[0x3]
800027b2:	30 19       	mov	r9,1
800027b4:	f2 08 18 00 	cp.b	r8,r9
800027b8:	c0 51       	brne	800027c2 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800027ba:	48 ec       	lddpc	r12,800027f0 <dcm_reply_func+0x50>
800027bc:	f0 1f 00 0e 	mcall	800027f4 <dcm_reply_func+0x54>
800027c0:	c0 a8       	rjmp	800027d4 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800027c2:	58 08       	cp.w	r8,0
800027c4:	c0 51       	brne	800027ce <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800027c6:	48 dc       	lddpc	r12,800027f8 <dcm_reply_func+0x58>
800027c8:	f0 1f 00 0b 	mcall	800027f4 <dcm_reply_func+0x54>
800027cc:	c0 48       	rjmp	800027d4 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800027ce:	48 cc       	lddpc	r12,800027fc <dcm_reply_func+0x5c>
800027d0:	f0 1f 00 09 	mcall	800027f4 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800027d4:	0f d8       	ld.ub	r8,r7[0x5]
800027d6:	1a d8       	st.w	--sp,r8
800027d8:	48 ac       	lddpc	r12,80002800 <dcm_reply_func+0x60>
800027da:	f0 1f 00 07 	mcall	800027f4 <dcm_reply_func+0x54>
800027de:	2f fd       	sub	sp,-4
800027e0:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800027e4:	48 8c       	lddpc	r12,80002804 <dcm_reply_func+0x64>
800027e6:	f0 1f 00 04 	mcall	800027f4 <dcm_reply_func+0x54>
800027ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800027ee:	00 00       	add	r0,r0
800027f0:	80 00       	ld.sh	r0,r0[0x0]
800027f2:	c6 ec       	rcall	800028ce <DeviceInitializationStatus_brdcst_func+0x22>
800027f4:	80 00       	ld.sh	r0,r0[0x0]
800027f6:	5e 90       	retgt	r0
800027f8:	80 00       	ld.sh	r0,r0[0x0]
800027fa:	c7 00       	breq	800028da <DeviceInitializationStatus_brdcst_func+0x2e>
800027fc:	80 00       	ld.sh	r0,r0[0x0]
800027fe:	c7 14       	brge	800028e0 <DeviceInitializationStatus_brdcst_func+0x34>
80002800:	80 00       	ld.sh	r0,r0[0x0]
80002802:	c7 28       	rjmp	800028e6 <fl_write+0x2>
80002804:	80 00       	ld.sh	r0,r0[0x0]
80002806:	c7 34       	brge	800028ec <fl_write+0x8>

80002808 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002808:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000280a:	19 a9       	ld.ub	r9,r12[0x2]
8000280c:	30 08       	mov	r8,0
8000280e:	f0 09 18 00 	cp.b	r9,r8
80002812:	c0 51       	brne	8000281c <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
80002814:	48 4c       	lddpc	r12,80002824 <ToneControl_reply_func+0x1c>
80002816:	f0 1f 00 05 	mcall	80002828 <ToneControl_reply_func+0x20>
8000281a:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
8000281c:	48 4c       	lddpc	r12,8000282c <ToneControl_reply_func+0x24>
8000281e:	f0 1f 00 03 	mcall	80002828 <ToneControl_reply_func+0x20>
80002822:	d8 02       	popm	pc
80002824:	80 00       	ld.sh	r0,r0[0x0]
80002826:	c7 40       	breq	8000290e <fl_write+0x2a>
80002828:	80 00       	ld.sh	r0,r0[0x0]
8000282a:	5e 90       	retgt	r0
8000282c:	80 00       	ld.sh	r0,r0[0x0]
8000282e:	c7 48       	rjmp	80002916 <fl_write+0x32>

80002830 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002830:	eb cd 40 80 	pushm	r7,lr
80002834:	18 97       	mov	r7,r12
  log("R");
80002836:	48 6c       	lddpc	r12,8000284c <app_payload_tx_proc+0x1c>
80002838:	f0 1f 00 06 	mcall	80002850 <app_payload_tx_proc+0x20>
  //fl_write("voice.dat", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
  
  //vTaskDelay(100);
  
  //payload_fragment_t * ptr = (payload_fragment_t *)payload;
  set_payload_idle(payload);
8000283c:	48 68       	lddpc	r8,80002854 <app_payload_tx_proc+0x24>
8000283e:	70 0c       	ld.w	r12,r8[0x0]
80002840:	0e 9b       	mov	r11,r7
80002842:	f0 1f 00 06 	mcall	80002858 <app_payload_tx_proc+0x28>

//

}
80002846:	e3 cd 80 80 	ldm	sp++,r7,pc
8000284a:	00 00       	add	r0,r0
8000284c:	80 00       	ld.sh	r0,r0[0x0]
8000284e:	c7 54       	brge	80002938 <fl_write+0x54>
80002850:	80 00       	ld.sh	r0,r0[0x0]
80002852:	5e 90       	retgt	r0
80002854:	00 00       	add	r0,r0
80002856:	0a 80       	andn	r0,r5
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	2a 60       	sub	r0,-90

8000285c <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
8000285c:	eb cd 40 80 	pushm	r7,lr
80002860:	18 97       	mov	r7,r12
	log("\n\r w: \n\r");
80002862:	48 cc       	lddpc	r12,80002890 <app_payload_rx_proc+0x34>
80002864:	f0 1f 00 0c 	mcall	80002894 <app_payload_rx_proc+0x38>
	if (AMBE_flag)
80002868:	48 c8       	lddpc	r8,80002898 <app_payload_rx_proc+0x3c>
8000286a:	11 89       	ld.ub	r9,r8[0x0]
8000286c:	30 08       	mov	r8,0
8000286e:	f0 09 18 00 	cp.b	r9,r8
80002872:	c0 81       	brne	80002882 <app_payload_rx_proc+0x26>
	{
		//fl_write("AMBEvo.bit", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	else
	{
		fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
80002874:	e0 69 02 00 	mov	r9,512
80002878:	0e 9a       	mov	r10,r7
8000287a:	3f fb       	mov	r11,-1
8000287c:	48 8c       	lddpc	r12,8000289c <app_payload_rx_proc+0x40>
8000287e:	f0 1f 00 09 	mcall	800028a0 <app_payload_rx_proc+0x44>
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
80002882:	48 98       	lddpc	r8,800028a4 <app_payload_rx_proc+0x48>
80002884:	70 0c       	ld.w	r12,r8[0x0]
80002886:	0e 9b       	mov	r11,r7
80002888:	f0 1f 00 08 	mcall	800028a8 <app_payload_rx_proc+0x4c>

}
8000288c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	c7 58       	rjmp	8000297c <CalculateBurst+0x10>
80002894:	80 00       	ld.sh	r0,r0[0x0]
80002896:	5e 90       	retgt	r0
80002898:	00 00       	add	r0,r0
8000289a:	0a 3c       	cp.w	r12,r5
8000289c:	80 00       	ld.sh	r0,r0[0x0]
8000289e:	c7 64       	brge	8000298a <payload_init+0x2>
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	28 e4       	sub	r4,-114
800028a4:	00 00       	add	r0,r0
800028a6:	0a 80       	andn	r0,r5
800028a8:	80 00       	ld.sh	r0,r0[0x0]
800028aa:	2a 60       	sub	r0,-90

800028ac <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028ac:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028ae:	19 e8       	ld.ub	r8,r12[0x6]
800028b0:	30 19       	mov	r9,1
800028b2:	f2 08 18 00 	cp.b	r8,r9
800028b6:	c0 61       	brne	800028c2 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028b8:	48 98       	lddpc	r8,800028dc <DeviceInitializationStatus_brdcst_func+0x30>
800028ba:	70 09       	ld.w	r9,r8[0x0]
800028bc:	a1 a9       	sbr	r9,0x0
800028be:	91 09       	st.w	r8[0x0],r9
800028c0:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028c2:	30 29       	mov	r9,2
800028c4:	f2 08 18 00 	cp.b	r8,r9
800028c8:	c0 80       	breq	800028d8 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028ca:	48 58       	lddpc	r8,800028dc <DeviceInitializationStatus_brdcst_func+0x30>
800028cc:	70 09       	ld.w	r9,r8[0x0]
800028ce:	e0 19 ff fc 	andl	r9,0xfffc
800028d2:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028d4:	f0 1f 00 03 	mcall	800028e0 <DeviceInitializationStatus_brdcst_func+0x34>
800028d8:	d8 02       	popm	pc
800028da:	00 00       	add	r0,r0
800028dc:	00 00       	add	r0,r0
800028de:	0d 78       	ld.ub	r8,--r6
800028e0:	80 00       	ld.sh	r0,r0[0x0]
800028e2:	3d f8       	mov	r8,-33

800028e4 <fl_write>:
	}
}


void fl_write(void * path, S32 offset, void * buffer, U32 length)
{
800028e4:	eb cd 40 f8 	pushm	r3-r7,lr
800028e8:	20 2d       	sub	sp,8
800028ea:	18 95       	mov	r5,r12
800028ec:	16 94       	mov	r4,r11
800028ee:	14 93       	mov	r3,r10
800028f0:	12 96       	mov	r6,r9
	
	fl_write_t * fl_write_ptr = pvPortMalloc(sizeof(fl_write_t));
800028f2:	34 cc       	mov	r12,76
800028f4:	f0 1f 00 16 	mcall	8000294c <fl_write+0x68>
800028f8:	18 97       	mov	r7,r12
	
	sprintf(fl_write_ptr->path, "%s", path);
800028fa:	0a 9b       	mov	r11,r5
800028fc:	f0 1f 00 15 	mcall	80002950 <fl_write+0x6c>
	fl_write_ptr->offset = offset;
80002900:	ef 44 00 40 	st.w	r7[64],r4
	fl_write_ptr->length = length;	
80002904:	ef 46 00 44 	st.w	r7[68],r6
	
	fl_write_ptr->buffer = pvPortMalloc(length);
80002908:	0c 9c       	mov	r12,r6
8000290a:	f0 1f 00 11 	mcall	8000294c <fl_write+0x68>
8000290e:	ef 4c 00 48 	st.w	r7[72],r12
	memcpy(fl_write_ptr->buffer, buffer, length);
80002912:	0c 9a       	mov	r10,r6
80002914:	06 9b       	mov	r11,r3
80002916:	f0 1f 00 10 	mcall	80002954 <fl_write+0x70>
	
	fl_oper_t fl_oper;
	
	fl_oper.opcode = FL_WRITE;
8000291a:	e0 68 40 00 	mov	r8,16384
8000291e:	ba 08       	st.h	sp[0x0],r8
	fl_oper.payload = fl_write_ptr;
80002920:	50 17       	stdsp	sp[0x4],r7
	
	if(pdTRUE != xQueueSend( fl_oper_queue, &fl_oper, 0 ))
80002922:	48 e8       	lddpc	r8,80002958 <fl_write+0x74>
80002924:	70 0c       	ld.w	r12,r8[0x0]
80002926:	30 09       	mov	r9,0
80002928:	12 9a       	mov	r10,r9
8000292a:	1a 9b       	mov	r11,sp
8000292c:	f0 1f 00 0c 	mcall	8000295c <fl_write+0x78>
80002930:	58 1c       	cp.w	r12,1
80002932:	c0 a0       	breq	80002946 <fl_write+0x62>
	{
		vPortFree(fl_write_ptr->buffer);
80002934:	6f 2c       	ld.w	r12,r7[0x48]
80002936:	f0 1f 00 0b 	mcall	80002960 <fl_write+0x7c>
		vPortFree(fl_write_ptr);
8000293a:	0e 9c       	mov	r12,r7
8000293c:	f0 1f 00 09 	mcall	80002960 <fl_write+0x7c>
		log("\n\r fsmm \n\r");//man...提升SPI_PBA时钟的频率可以有效的提升写文件的速度。
80002940:	48 9c       	lddpc	r12,80002964 <fl_write+0x80>
80002942:	f0 1f 00 0a 	mcall	80002968 <fl_write+0x84>
	}
	
}
80002946:	2f ed       	sub	sp,-8
80002948:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000294c:	80 00       	ld.sh	r0,r0[0x0]
8000294e:	4f a4       	lddpc	r4,80002b34 <phy_tx_func+0x30>
80002950:	80 00       	ld.sh	r0,r0[0x0]
80002952:	6c 5c       	ld.w	r12,r6[0x14]
80002954:	80 00       	ld.sh	r0,r0[0x0]
80002956:	67 e8       	ld.w	r8,r3[0x78]
80002958:	00 00       	add	r0,r0
8000295a:	0a 54       	eor	r4,r5
8000295c:	80 00       	ld.sh	r0,r0[0x0]
8000295e:	52 f8       	stdsp	sp[0xbc],r8
80002960:	80 00       	ld.sh	r0,r0[0x0]
80002962:	4f 7c       	lddpc	r12,80002b3c <phy_tx_func+0x38>
80002964:	80 00       	ld.sh	r0,r0[0x0]
80002966:	c7 74       	brge	80002a54 <phy_rx+0x2c>
80002968:	80 00       	ld.sh	r0,r0[0x0]
8000296a:	5e 90       	retgt	r0

8000296c <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
8000296c:	20 1c       	sub	r12,1
8000296e:	5c 5c       	castu.b	r12
80002970:	31 18       	mov	r8,17
80002972:	f0 0c 18 00 	cp.b	r12,r8
80002976:	e0 88 00 03 	brls	8000297c <CalculateBurst+0x10>
8000297a:	5e fd       	retal	0
8000297c:	48 28       	lddpc	r8,80002984 <CalculateBurst+0x18>
8000297e:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002982:	5e fc       	retal	r12
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	c7 e0       	breq	80002a82 <phy_tx+0x2>

80002988 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80002988:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
8000298a:	48 98       	lddpc	r8,800029ac <payload_init+0x24>
8000298c:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
8000298e:	48 98       	lddpc	r8,800029b0 <payload_init+0x28>
80002990:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002992:	30 09       	mov	r9,0
80002994:	1a d9       	st.w	--sp,r9
80002996:	1a d9       	st.w	--sp,r9
80002998:	1a d9       	st.w	--sp,r9
8000299a:	30 28       	mov	r8,2
8000299c:	e0 6a 04 00 	mov	r10,1024
800029a0:	48 5b       	lddpc	r11,800029b4 <payload_init+0x2c>
800029a2:	48 6c       	lddpc	r12,800029b8 <payload_init+0x30>
800029a4:	f0 1f 00 06 	mcall	800029bc <payload_init+0x34>
800029a8:	2f dd       	sub	sp,-12
	
	
	
	
	
}
800029aa:	d8 02       	popm	pc
800029ac:	00 00       	add	r0,r0
800029ae:	0a 58       	eor	r8,r5
800029b0:	00 00       	add	r0,r0
800029b2:	0a 5c       	eor	r12,r5
800029b4:	80 00       	ld.sh	r0,r0[0x0]
800029b6:	c8 28       	rjmp	80002aba <phy_tx+0x3a>
800029b8:	80 00       	ld.sh	r0,r0[0x0]
800029ba:	29 c0       	sub	r0,-100
800029bc:	80 00       	ld.sh	r0,r0[0x0]
800029be:	5a cc       	cp.w	r12,-20

800029c0 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
800029c0:	eb cd 40 f8 	pushm	r3-r7,lr
800029c4:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
800029c6:	48 e8       	lddpc	r8,800029fc <payload_rx_process+0x3c>
800029c8:	70 08       	ld.w	r8,r8[0x0]
800029ca:	58 08       	cp.w	r8,0
800029cc:	c0 71       	brne	800029da <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
800029ce:	30 4b       	mov	r11,4
800029d0:	30 5c       	mov	r12,5
800029d2:	f0 1f 00 0c 	mcall	80002a00 <payload_rx_process+0x40>
800029d6:	48 a8       	lddpc	r8,800029fc <payload_rx_process+0x3c>
800029d8:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
800029da:	48 96       	lddpc	r6,800029fc <payload_rx_process+0x3c>
800029dc:	30 05       	mov	r5,0
800029de:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
800029e0:	48 93       	lddpc	r3,80002a04 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
800029e2:	6c 0c       	ld.w	r12,r6[0x0]
800029e4:	0a 99       	mov	r9,r5
800029e6:	08 9a       	mov	r10,r4
800029e8:	1a 9b       	mov	r11,sp
800029ea:	f0 1f 00 08 	mcall	80002a08 <payload_rx_process+0x48>
800029ee:	58 1c       	cp.w	r12,1
800029f0:	cf 91       	brne	800029e2 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
800029f2:	66 08       	ld.w	r8,r3[0x0]
800029f4:	40 0c       	lddsp	r12,sp[0x0]
800029f6:	5d 18       	icall	r8
800029f8:	cf 5b       	rjmp	800029e2 <payload_rx_process+0x22>
800029fa:	00 00       	add	r0,r0
800029fc:	00 00       	add	r0,r0
800029fe:	0a 70       	tst	r0,r5
80002a00:	80 00       	ld.sh	r0,r0[0x0]
80002a02:	53 f8       	stdsp	sp[0xfc],r8
80002a04:	00 00       	add	r0,r0
80002a06:	0a 58       	eor	r8,r5
80002a08:	80 00       	ld.sh	r0,r0[0x0]
80002a0a:	50 ec       	stdsp	sp[0x38],r12

80002a0c <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002a0c:	d4 01       	pushm	lr
80002a0e:	20 2d       	sub	sp,8
80002a10:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a12:	30 09       	mov	r9,0
80002a14:	fa ca ff f8 	sub	r10,sp,-8
80002a18:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002a1a:	1a 9b       	mov	r11,sp
80002a1c:	f0 1f 00 02 	mcall	80002a24 <set_idle_store_isr+0x18>
}
80002a20:	2f ed       	sub	sp,-8
80002a22:	d8 02       	popm	pc
80002a24:	80 00       	ld.sh	r0,r0[0x0]
80002a26:	52 a8       	stdsp	sp[0xa8],r8

80002a28 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002a28:	d4 01       	pushm	lr
80002a2a:	20 2d       	sub	sp,8
80002a2c:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002a2e:	58 0c       	cp.w	r12,0
80002a30:	c1 10       	breq	80002a52 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a32:	30 08       	mov	r8,0
80002a34:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002a36:	98 88       	ld.uh	r8,r12[0x0]
80002a38:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a3c:	e0 48 40 00 	cp.w	r8,16384
80002a40:	c0 91       	brne	80002a52 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002a42:	48 68       	lddpc	r8,80002a58 <phy_rx+0x30>
80002a44:	70 0c       	ld.w	r12,r8[0x0]
80002a46:	30 09       	mov	r9,0
80002a48:	fa ca ff fc 	sub	r10,sp,-4
80002a4c:	1a 9b       	mov	r11,sp
80002a4e:	f0 1f 00 04 	mcall	80002a5c <phy_rx+0x34>
		}	

    }
		
 
}
80002a52:	2f ed       	sub	sp,-8
80002a54:	d8 02       	popm	pc
80002a56:	00 00       	add	r0,r0
80002a58:	00 00       	add	r0,r0
80002a5a:	0a ac       	st.w	r5++,r12
80002a5c:	80 00       	ld.sh	r0,r0[0x0]
80002a5e:	52 a8       	stdsp	sp[0xa8],r8

80002a60 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002a60:	eb cd 40 80 	pushm	r7,lr
80002a64:	20 1d       	sub	sp,4
80002a66:	fa c7 ff fc 	sub	r7,sp,-4
80002a6a:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002a6c:	30 09       	mov	r9,0
80002a6e:	12 9a       	mov	r10,r9
80002a70:	1a 9b       	mov	r11,sp
80002a72:	f0 1f 00 03 	mcall	80002a7c <set_idle_store+0x1c>
}
80002a76:	2f fd       	sub	sp,-4
80002a78:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a7c:	80 00       	ld.sh	r0,r0[0x0]
80002a7e:	52 f8       	stdsp	sp[0xbc],r8

80002a80 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002a80:	d4 01       	pushm	lr
80002a82:	20 1d       	sub	sp,4
80002a84:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002a86:	98 88       	ld.uh	r8,r12[0x0]
80002a88:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a8c:	e0 48 40 00 	cp.w	r8,16384
80002a90:	c0 d1       	brne	80002aaa <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002a92:	49 08       	lddpc	r8,80002ad0 <phy_tx+0x50>
80002a94:	70 08       	ld.w	r8,r8[0x0]
80002a96:	58 08       	cp.w	r8,0
80002a98:	c1 a0       	breq	80002acc <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002a9a:	48 e8       	lddpc	r8,80002ad0 <phy_tx+0x50>
80002a9c:	70 0c       	ld.w	r12,r8[0x0]
80002a9e:	30 09       	mov	r9,0
80002aa0:	12 9a       	mov	r10,r9
80002aa2:	1a 9b       	mov	r11,sp
80002aa4:	f0 1f 00 0c 	mcall	80002ad4 <phy_tx+0x54>
80002aa8:	c1 28       	rjmp	80002acc <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002aaa:	e0 48 10 00 	cp.w	r8,4096
80002aae:	5f 0a       	sreq	r10
80002ab0:	e0 48 20 00 	cp.w	r8,8192
80002ab4:	5f 09       	sreq	r9
80002ab6:	f5 e9 10 09 	or	r9,r10,r9
80002aba:	c0 71       	brne	80002ac8 <phy_tx+0x48>
80002abc:	e0 48 50 00 	cp.w	r8,20480
80002ac0:	c0 40       	breq	80002ac8 <phy_tx+0x48>
80002ac2:	e0 48 60 00 	cp.w	r8,24576
80002ac6:	c0 31       	brne	80002acc <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002ac8:	48 48       	lddpc	r8,80002ad8 <phy_tx+0x58>
80002aca:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002acc:	2f fd       	sub	sp,-4
80002ace:	d8 02       	popm	pc
80002ad0:	00 00       	add	r0,r0
80002ad2:	0a c0       	st.b	r5++,r0
80002ad4:	80 00       	ld.sh	r0,r0[0x0]
80002ad6:	52 f8       	stdsp	sp[0xbc],r8
80002ad8:	00 00       	add	r0,r0
80002ada:	0a a4       	st.w	r5++,r4

80002adc <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002adc:	d4 01       	pushm	lr
80002ade:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002ae0:	30 08       	mov	r8,0
80002ae2:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002ae4:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002ae6:	1a 9a       	mov	r10,sp
80002ae8:	fa cb ff fc 	sub	r11,sp,-4
80002aec:	f0 1f 00 05 	mcall	80002b00 <get_idle_store_isr+0x24>
80002af0:	58 1c       	cp.w	r12,1
80002af2:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002af6:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002afa:	2f ed       	sub	sp,-8
80002afc:	d8 02       	popm	pc
80002afe:	00 00       	add	r0,r0
80002b00:	80 00       	ld.sh	r0,r0[0x0]
80002b02:	4f fc       	lddpc	r12,80002cfc <phy_tx_func+0x1f8>

80002b04 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002b04:	eb cd 40 c0 	pushm	r6-r7,lr
80002b08:	20 1d       	sub	sp,4
80002b0a:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002b0c:	fe f8 05 54 	ld.w	r8,pc[1364]
80002b10:	70 08       	ld.w	r8,r8[0x0]
80002b12:	58 08       	cp.w	r8,0
80002b14:	c7 40       	breq	80002bfc <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002b16:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b18:	30 08       	mov	r8,0
80002b1a:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002b1c:	fe f8 05 48 	ld.w	r8,pc[1352]
80002b20:	70 08       	ld.w	r8,r8[0x0]
80002b22:	58 18       	cp.w	r8,1
80002b24:	c2 90       	breq	80002b76 <phy_tx_func+0x72>
80002b26:	c0 43       	brcs	80002b2e <phy_tx_func+0x2a>
80002b28:	58 28       	cp.w	r8,2
80002b2a:	c6 91       	brne	80002bfc <phy_tx_func+0xf8>
80002b2c:	c6 18       	rjmp	80002bee <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002b2e:	fe f8 05 32 	ld.w	r8,pc[1330]
80002b32:	70 0c       	ld.w	r12,r8[0x0]
80002b34:	1a 9a       	mov	r10,sp
80002b36:	fe fb 05 32 	ld.w	r11,pc[1330]
80002b3a:	f0 1f 01 4d 	mcall	8000306c <phy_tx_func+0x568>
80002b3e:	58 1c       	cp.w	r12,1
80002b40:	c1 51       	brne	80002b6a <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002b42:	fe f8 05 26 	ld.w	r8,pc[1318]
80002b46:	70 08       	ld.w	r8,r8[0x0]
80002b48:	11 9a       	ld.ub	r10,r8[0x1]
80002b4a:	fe f9 05 26 	ld.w	r9,pc[1318]
80002b4e:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002b50:	90 88       	ld.uh	r8,r8[0x0]
80002b52:	ea 18 ab cd 	orh	r8,0xabcd
80002b56:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002b58:	30 19       	mov	r9,1
80002b5a:	fe f8 05 1a 	ld.w	r8,pc[1306]
80002b5e:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002b60:	30 19       	mov	r9,1
80002b62:	fe f8 05 02 	ld.w	r8,pc[1282]
80002b66:	91 09       	st.w	r8[0x0],r9
80002b68:	c4 a8       	rjmp	80002bfc <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002b6a:	e0 68 5a 5a 	mov	r8,23130
80002b6e:	ea 18 ab cd 	orh	r8,0xabcd
80002b72:	8f 18       	st.w	r7[0x4],r8
80002b74:	c4 48       	rjmp	80002bfc <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b76:	fe f9 04 fe 	ld.w	r9,pc[1278]
80002b7a:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002b7c:	fe fa 04 ec 	ld.w	r10,pc[1260]
80002b80:	74 0a       	ld.w	r10,r10[0x0]
80002b82:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002b86:	b1 6a       	lsl	r10,0x10
80002b88:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b8a:	2f f8       	sub	r8,-1
80002b8c:	5c 58       	castu.b	r8
80002b8e:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b90:	fe fa 04 e0 	ld.w	r10,pc[1248]
80002b94:	94 09       	ld.sh	r9,r10[0x0]
80002b96:	20 29       	sub	r9,2
80002b98:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b9a:	30 0a       	mov	r10,0
80002b9c:	f4 09 19 00 	cp.h	r9,r10
80002ba0:	e0 89 00 0b 	brgt	80002bb6 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002ba4:	78 18       	ld.w	r8,r12[0x4]
80002ba6:	e8 18 00 ba 	orl	r8,0xba
80002baa:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80002bac:	30 09       	mov	r9,0
80002bae:	fe f8 04 b6 	ld.w	r8,pc[1206]
80002bb2:	91 09       	st.w	r8[0x0],r9
80002bb4:	c2 48       	rjmp	80002bfc <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002bb6:	fe f9 04 b2 	ld.w	r9,pc[1202]
80002bba:	72 09       	ld.w	r9,r9[0x0]
80002bbc:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002bc0:	78 1a       	ld.w	r10,r12[0x4]
80002bc2:	f5 e9 10 09 	or	r9,r10,r9
80002bc6:	99 19       	st.w	r12[0x4],r9
80002bc8:	2f f8       	sub	r8,-1
80002bca:	fe f9 04 aa 	ld.w	r9,pc[1194]
80002bce:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002bd0:	fe f9 04 a0 	ld.w	r9,pc[1184]
80002bd4:	92 08       	ld.sh	r8,r9[0x0]
80002bd6:	20 28       	sub	r8,2
80002bd8:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002bda:	30 09       	mov	r9,0
80002bdc:	f2 08 19 00 	cp.h	r8,r9
80002be0:	e0 89 00 0e 	brgt	80002bfc <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002be4:	30 29       	mov	r9,2
80002be6:	fe f8 04 7e 	ld.w	r8,pc[1150]
80002bea:	91 09       	st.w	r8[0x0],r9
80002bec:	c0 88       	rjmp	80002bfc <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002bee:	fc 18 00 ba 	movh	r8,0xba
80002bf2:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002bf4:	30 09       	mov	r9,0
80002bf6:	fe f8 04 6e 	ld.w	r8,pc[1134]
80002bfa:	91 09       	st.w	r8[0x0],r9
	static U32 i = 0;
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if (AMBE_flag)
80002bfc:	fe f8 04 7c 	ld.w	r8,pc[1148]
80002c00:	11 89       	ld.ub	r9,r8[0x0]
80002c02:	30 08       	mov	r8,0
80002c04:	f0 09 18 00 	cp.b	r9,r8
80002c08:	e0 80 00 c6 	breq	80002d94 <phy_tx_func+0x290>
	{

	  //AMBE_flag
		switch(payload_tx_state)
80002c0c:	fe f8 04 70 	ld.w	r8,pc[1136]
80002c10:	11 88       	ld.ub	r8,r8[0x0]
80002c12:	30 19       	mov	r9,1
80002c14:	f2 08 18 00 	cp.b	r8,r9
80002c18:	c3 e0       	breq	80002c94 <phy_tx_func+0x190>
80002c1a:	c0 73       	brcs	80002c28 <phy_tx_func+0x124>
80002c1c:	30 29       	mov	r9,2
80002c1e:	f2 08 18 00 	cp.b	r8,r9
80002c22:	e0 81 02 1b 	brne	80003058 <phy_tx_func+0x554>
80002c26:	c9 28       	rjmp	80002d4a <phy_tx_func+0x246>
		{
			case 0:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80002c28:	fe f8 04 58 	ld.w	r8,pc[1112]
80002c2c:	70 08       	ld.w	r8,r8[0x0]
80002c2e:	58 08       	cp.w	r8,0
80002c30:	c0 b0       	breq	80002c46 <phy_tx_func+0x142>
80002c32:	fe f8 04 4e 	ld.w	r8,pc[1102]
80002c36:	70 08       	ld.w	r8,r8[0x0]
80002c38:	58 98       	cp.w	r8,9
80002c3a:	c0 60       	breq	80002c46 <phy_tx_func+0x142>
80002c3c:	fe f8 04 44 	ld.w	r8,pc[1092]
80002c40:	70 08       	ld.w	r8,r8[0x0]
80002c42:	58 18       	cp.w	r8,1
80002c44:	c0 a1       	brne	80002c58 <phy_tx_func+0x154>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002c46:	e0 68 5a 5a 	mov	r8,23130
80002c4a:	ea 18 ab cd 	orh	r8,0xabcd
80002c4e:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002c50:	30 08       	mov	r8,0
80002c52:	8f 38       	st.w	r7[0xc],r8
80002c54:	e0 8f 02 02 	bral	80003058 <phy_tx_func+0x554>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80002c58:	fe f8 04 28 	ld.w	r8,pc[1064]
80002c5c:	70 08       	ld.w	r8,r8[0x0]
80002c5e:	58 28       	cp.w	r8,2
80002c60:	c0 91       	brne	80002c72 <phy_tx_func+0x16e>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80002c62:	fe f8 04 22 	ld.w	r8,pc[1058]
80002c66:	70 09       	ld.w	r9,r8[0x0]
80002c68:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80002c6a:	70 18       	ld.w	r8,r8[0x4]
80002c6c:	8f 38       	st.w	r7[0xc],r8
80002c6e:	e0 8f 01 f5 	bral	80003058 <phy_tx_func+0x554>
				}
				else
				{
					payload_tx_state = 1;
80002c72:	30 19       	mov	r9,1
80002c74:	fe f8 04 08 	ld.w	r8,pc[1032]
80002c78:	b0 89       	st.b	r8[0x0],r9
					
					//0xABCDCOOE
					payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80002c7a:	e0 68 c0 0e 	mov	r8,49166
80002c7e:	ea 18 ab cd 	orh	r8,0xabcd
80002c82:	8f 28       	st.w	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[2] = VBSP_data[0];
80002c84:	fe f8 04 04 	ld.w	r8,pc[1028]
80002c88:	90 09       	ld.sh	r9,r8[0x0]
80002c8a:	ae 69       	st.h	r7[0xc],r9
					//0xF00x
					payload_tx_channel->word[3] = VBSP_data[1];
80002c8c:	90 18       	ld.sh	r8,r8[0x2]
80002c8e:	ae 78       	st.h	r7[0xe],r8
80002c90:	e0 8f 01 e4 	bral	80003058 <phy_tx_func+0x554>
				break;
			
			case 1:
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80002c94:	fe 78 88 f2 	mov	r8,-30478
80002c98:	ae 48       	st.h	r7[0x8],r8
			
				switch (m_RxBurstType)//在发送函数中去做加密处理
80002c9a:	fe f8 03 e6 	ld.w	r8,pc[998]
80002c9e:	70 08       	ld.w	r8,r8[0x0]
80002ca0:	58 38       	cp.w	r8,3
80002ca2:	c0 60       	breq	80002cae <phy_tx_func+0x1aa>
80002ca4:	c4 73       	brcs	80002d32 <phy_tx_func+0x22e>
80002ca6:	58 88       	cp.w	r8,8
80002ca8:	e0 8b 00 45 	brhi	80002d32 <phy_tx_func+0x22e>
80002cac:	c2 a8       	rjmp	80002d00 <phy_tx_func+0x1fc>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80002cae:	fe f8 03 de 	ld.w	r8,pc[990]
80002cb2:	11 89       	ld.ub	r9,r8[0x0]
80002cb4:	30 18       	mov	r8,1
80002cb6:	f0 09 18 00 	cp.b	r9,r8
80002cba:	c0 a1       	brne	80002cce <phy_tx_func+0x1ca>
							{	
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80002cbc:	fe f8 03 d4 	ld.w	r8,pc[980]
80002cc0:	90 09       	ld.sh	r9,r8[0x0]
80002cc2:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80002cc4:	90 19       	ld.sh	r9,r8[0x2]
80002cc6:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80002cc8:	90 28       	ld.sh	r8,r8[0x4]
80002cca:	ae 78       	st.h	r7[0xe],r8
80002ccc:	c1 48       	rjmp	80002cf4 <phy_tx_func+0x1f0>
								//logFromISR("\n\r MMQ \n\r");
							}
							else//VF_SN==2/3
							{
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002cce:	fe f9 03 c6 	ld.w	r9,pc[966]
80002cd2:	92 0b       	ld.sh	r11,r9[0x0]
80002cd4:	fe f8 03 bc 	ld.w	r8,pc[956]
80002cd8:	90 0a       	ld.sh	r10,r8[0x0]
80002cda:	f7 ea 20 0a 	eor	r10,r11,r10
80002cde:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002ce0:	92 1b       	ld.sh	r11,r9[0x2]
80002ce2:	90 1a       	ld.sh	r10,r8[0x2]
80002ce4:	f7 ea 20 0a 	eor	r10,r11,r10
80002ce8:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002cea:	92 29       	ld.sh	r9,r9[0x4]
80002cec:	90 28       	ld.sh	r8,r8[0x4]
80002cee:	f3 e8 20 08 	eor	r8,r9,r8
80002cf2:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
						
							}
					
							payload_tx_state = 2;
80002cf4:	30 29       	mov	r9,2
80002cf6:	fe f8 03 86 	ld.w	r8,pc[902]
80002cfa:	b0 89       	st.b	r8[0x0],r9
80002cfc:	e0 8f 01 ae 	bral	80003058 <phy_tx_func+0x554>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002d00:	fe f9 03 94 	ld.w	r9,pc[916]
80002d04:	92 0b       	ld.sh	r11,r9[0x0]
80002d06:	fe f8 03 8a 	ld.w	r8,pc[906]
80002d0a:	90 0a       	ld.sh	r10,r8[0x0]
80002d0c:	f7 ea 20 0a 	eor	r10,r11,r10
80002d10:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002d12:	92 1b       	ld.sh	r11,r9[0x2]
80002d14:	90 1a       	ld.sh	r10,r8[0x2]
80002d16:	f7 ea 20 0a 	eor	r10,r11,r10
80002d1a:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002d1c:	92 29       	ld.sh	r9,r9[0x4]
80002d1e:	90 28       	ld.sh	r8,r8[0x4]
80002d20:	f3 e8 20 08 	eor	r8,r9,r8
80002d24:	ae 78       	st.h	r7[0xe],r8
						
							payload_tx_state = 2;
80002d26:	30 29       	mov	r9,2
80002d28:	fe f8 03 54 	ld.w	r8,pc[852]
80002d2c:	b0 89       	st.b	r8[0x0],r9
80002d2e:	e0 8f 01 95 	bral	80003058 <phy_tx_func+0x554>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002d32:	e0 68 5a 5a 	mov	r8,23130
80002d36:	ea 18 ab cd 	orh	r8,0xabcd
80002d3a:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002d3c:	30 08       	mov	r8,0
80002d3e:	8f 38       	st.w	r7[0xc],r8
							payload_tx_state = 0;
80002d40:	fe f9 03 3c 	ld.w	r9,pc[828]
80002d44:	b2 88       	st.b	r9[0x0],r8
80002d46:	e0 8f 01 89 	bral	80003058 <phy_tx_func+0x554>
			
			case 2:
					//Encrypted AMBE data(XOR)
					//payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
				
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
80002d4a:	fe f8 03 36 	ld.w	r8,pc[822]
80002d4e:	70 08       	ld.w	r8,r8[0x0]
80002d50:	58 38       	cp.w	r8,3
80002d52:	c0 d1       	brne	80002d6c <phy_tx_func+0x268>
80002d54:	fe f8 03 38 	ld.w	r8,pc[824]
80002d58:	11 89       	ld.ub	r9,r8[0x0]
80002d5a:	30 18       	mov	r8,1
80002d5c:	f0 09 18 00 	cp.b	r9,r8
80002d60:	c0 61       	brne	80002d6c <phy_tx_func+0x268>
					{
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3])) ;
80002d62:	fe f8 03 2e 	ld.w	r8,pc[814]
80002d66:	90 38       	ld.sh	r8,r8[0x6]
80002d68:	ae 48       	st.h	r7[0x8],r8
80002d6a:	c0 a8       	rjmp	80002d7e <phy_tx_func+0x27a>
					}
					else{
					
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3]) ^ (AMBEBurst_rawdata[3])) ;
80002d6c:	fe f8 03 28 	ld.w	r8,pc[808]
80002d70:	90 39       	ld.sh	r9,r8[0x6]
80002d72:	fe f8 03 1e 	ld.w	r8,pc[798]
80002d76:	90 38       	ld.sh	r8,r8[0x6]
80002d78:	f3 e8 20 08 	eor	r8,r9,r8
80002d7c:	ae 48       	st.h	r7[0x8],r8
					
					}
					payload_tx_channel->word[1]	= 0x00BA ; 
80002d7e:	e0 68 00 ba 	mov	r8,186
80002d82:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002d84:	30 08       	mov	r8,0
80002d86:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002d88:	ae 78       	st.h	r7[0xe],r8
				
					payload_tx_state = 0;
80002d8a:	fe f9 02 f2 	ld.w	r9,pc[754]
80002d8e:	b2 88       	st.b	r9[0x0],r8
80002d90:	e0 8f 01 64 	bral	80003058 <phy_tx_func+0x554>

#if 1
else//Send-PCM-data（注意测试回放时：模拟信道码流为40bytes/2.5ms.）
{
	
	index = (index >=30240) ? 0 : index;
80002d94:	fe f8 03 04 	ld.w	r8,pc[772]
80002d98:	70 08       	ld.w	r8,r8[0x0]
80002d9a:	e0 48 76 20 	cp.w	r8,30240
80002d9e:	f9 b8 02 00 	movhs	r8,0
80002da2:	fe f9 02 f6 	ld.w	r9,pc[758]
80002da6:	93 08       	st.w	r9[0x0],r8
	
	if(is_unmute == 1)counter++;
80002da8:	fe f8 02 f4 	ld.w	r8,pc[756]
80002dac:	11 89       	ld.ub	r9,r8[0x0]
80002dae:	30 18       	mov	r8,1
80002db0:	f0 09 18 00 	cp.b	r9,r8
80002db4:	c0 61       	brne	80002dc0 <phy_tx_func+0x2bc>
80002db6:	fe f8 02 ea 	ld.w	r8,pc[746]
80002dba:	70 09       	ld.w	r9,r8[0x0]
80002dbc:	2f f9       	sub	r9,-1
80002dbe:	91 09       	st.w	r8[0x0],r9
	
	switch(payload_tx_state)
80002dc0:	fe f8 02 bc 	ld.w	r8,pc[700]
80002dc4:	11 88       	ld.ub	r8,r8[0x0]
80002dc6:	30 19       	mov	r9,1
80002dc8:	f2 08 18 00 	cp.b	r8,r9
80002dcc:	c3 60       	breq	80002e38 <phy_tx_func+0x334>
80002dce:	c0 73       	brcs	80002ddc <phy_tx_func+0x2d8>
80002dd0:	30 29       	mov	r9,2
80002dd2:	f2 08 18 00 	cp.b	r8,r9
80002dd6:	e0 81 01 3e 	brne	80003052 <phy_tx_func+0x54e>
80002dda:	c7 c8       	rjmp	80002ed2 <phy_tx_func+0x3ce>
	{
		case 0:
		
			payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ddc:	e0 68 5a 5a 	mov	r8,23130
80002de0:	ea 18 ab cd 	orh	r8,0xabcd
80002de4:	8f 28       	st.w	r7[0x8],r8
			payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002de6:	30 08       	mov	r8,0
80002de8:	8f 38       	st.w	r7[0xc],r8
		
			if(((counter % 20 )== 0) && (counter != 0) &&(is_unmute == 1))//20*125us = 2.5ms.
80002dea:	fe f8 02 b6 	ld.w	r8,pc[694]
80002dee:	70 08       	ld.w	r8,r8[0x0]
80002df0:	e0 6b cc cd 	mov	r11,52429
80002df4:	ea 1b cc cc 	orh	r11,0xcccc
80002df8:	f0 0b 06 4a 	mulu.d	r10,r8,r11
80002dfc:	f6 09 16 04 	lsr	r9,r11,0x4
80002e00:	f2 09 00 29 	add	r9,r9,r9<<0x2
80002e04:	f0 09 01 29 	sub	r9,r8,r9<<0x2
80002e08:	c1 21       	brne	80002e2c <phy_tx_func+0x328>
80002e0a:	58 08       	cp.w	r8,0
80002e0c:	c1 00       	breq	80002e2c <phy_tx_func+0x328>
80002e0e:	fe f8 02 8e 	ld.w	r8,pc[654]
80002e12:	11 89       	ld.ub	r9,r8[0x0]
80002e14:	30 18       	mov	r8,1
80002e16:	f0 09 18 00 	cp.b	r9,r8
80002e1a:	c0 91       	brne	80002e2c <phy_tx_func+0x328>
			{
				payload_tx_state = 1;
80002e1c:	10 99       	mov	r9,r8
80002e1e:	fe f8 02 5e 	ld.w	r8,pc[606]
80002e22:	b0 89       	st.b	r8[0x0],r9
				//payload_tx_state = 0;
				frame_number = 0;
80002e24:	30 09       	mov	r9,0
80002e26:	fe f8 02 7e 	ld.w	r8,pc[638]
80002e2a:	b0 89       	st.b	r8[0x0],r9
	
			}
		
			send_num++;
80002e2c:	fe f8 02 7c 	ld.w	r8,pc[636]
80002e30:	70 09       	ld.w	r9,r8[0x0]
80002e32:	2f f9       	sub	r9,-1
80002e34:	91 09       	st.w	r8[0x0],r9
80002e36:	c1 19       	rjmp	80003058 <phy_tx_func+0x554>
			break;
		
		case 1:
		
	
			payload_tx_channel->word[0] = 0xABCD; 
80002e38:	fe 78 ab cd 	mov	r8,-21555
80002e3c:	ae 48       	st.h	r7[0x8],r8
		
			if(frame_number == 0)
80002e3e:	fe f8 02 66 	ld.w	r8,pc[614]
80002e42:	11 89       	ld.ub	r9,r8[0x0]
80002e44:	30 08       	mov	r8,0
80002e46:	f0 09 18 00 	cp.b	r9,r8
80002e4a:	c1 b1       	brne	80002e80 <phy_tx_func+0x37c>
			{
				if (Silent_flag == 1)
80002e4c:	fe f8 02 60 	ld.w	r8,pc[608]
80002e50:	11 89       	ld.ub	r9,r8[0x0]
80002e52:	30 18       	mov	r8,1
80002e54:	f0 09 18 00 	cp.b	r9,r8
80002e58:	c0 91       	brne	80002e6a <phy_tx_func+0x366>
				{
					//即是44betes-4bytes= 40bytes
					expexted_length = 0x2C;//One Descriptor Indicator
80002e5a:	32 c9       	mov	r9,44
80002e5c:	fe f8 02 54 	ld.w	r8,pc[596]
80002e60:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102C;//44betes-4bytes= 40bytes
80002e62:	e0 68 10 2c 	mov	r8,4140
80002e66:	ae 58       	st.h	r7[0xa],r8
80002e68:	c0 88       	rjmp	80002e78 <phy_tx_func+0x374>
				}
				
				else
				{
					//first frame
					expexted_length = 0x2A;
80002e6a:	32 a9       	mov	r9,42
80002e6c:	fe f8 02 44 	ld.w	r8,pc[580]
80002e70:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102A;//42-2= 40 bytes;	
80002e72:	e0 68 10 2a 	mov	r8,4138
80002e76:	ae 58       	st.h	r7[0xa],r8
				}
				
					last_frame = TRUE;
80002e78:	30 19       	mov	r9,1
80002e7a:	fe f8 02 3a 	ld.w	r8,pc[570]
80002e7e:	b0 89       	st.b	r8[0x0],r9
			//
			//
			//}
			//else//不执行
			
			if (Silent_flag == 1)//发送静音指令
80002e80:	fe f8 02 2c 	ld.w	r8,pc[556]
80002e84:	11 89       	ld.ub	r9,r8[0x0]
80002e86:	30 18       	mov	r8,1
80002e88:	f0 09 18 00 	cp.b	r9,r8
80002e8c:	c0 61       	brne	80002e98 <phy_tx_func+0x394>
			{
			
				payload_tx_channel->word[2] = 0x0001;//Array Descriptor Length
80002e8e:	30 18       	mov	r8,1
80002e90:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  0x0004;//Silent Descriptor Indicator
80002e92:	30 48       	mov	r8,4
80002e94:	ae 78       	st.h	r7[0xe],r8
80002e96:	c1 38       	rjmp	80002ebc <phy_tx_func+0x3b8>

			}
			else
			{
			
				payload_tx_channel->word[2] = 0x0000;
80002e98:	30 08       	mov	r8,0
80002e9a:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80002e9c:	4f f8       	lddpc	r8,80003098 <phy_tx_func+0x594>
80002e9e:	70 09       	ld.w	r9,r8[0x0]
80002ea0:	fe fa 02 18 	ld.w	r10,pc[536]
80002ea4:	f4 09 00 0b 	add	r11,r10,r9
80002ea8:	17 9b       	ld.ub	r11,r11[0x1]
80002eaa:	f4 09 07 09 	ld.ub	r9,r10[r9]
80002eae:	a9 69       	lsl	r9,0x8
80002eb0:	f6 09 00 09 	add	r9,r11,r9
80002eb4:	ae 79       	st.h	r7[0xe],r9
				index+=2;
80002eb6:	70 09       	ld.w	r9,r8[0x0]
80002eb8:	2f e9       	sub	r9,-2
80002eba:	91 09       	st.w	r8[0x0],r9
			
			}
		
			expexted_length -= 4;
80002ebc:	4f d8       	lddpc	r8,800030b0 <phy_tx_func+0x5ac>
80002ebe:	90 09       	ld.sh	r9,r8[0x0]
80002ec0:	20 49       	sub	r9,4
80002ec2:	b0 09       	st.h	r8[0x0],r9
		
			//frame_number++;
			payload_tx_state = 2;
80002ec4:	30 29       	mov	r9,2
80002ec6:	4e e8       	lddpc	r8,8000307c <phy_tx_func+0x578>
80002ec8:	b0 89       	st.b	r8[0x0],r9
		
			i = 0;
80002eca:	30 09       	mov	r9,0
80002ecc:	4f c8       	lddpc	r8,800030bc <phy_tx_func+0x5b8>
80002ece:	91 09       	st.w	r8[0x0],r9
80002ed0:	cc 48       	rjmp	80003058 <phy_tx_func+0x554>
		
			break;
		
		case 2:
		
			if(expexted_length <= 0)
80002ed2:	4f 88       	lddpc	r8,800030b0 <phy_tx_func+0x5ac>
80002ed4:	90 09       	ld.sh	r9,r8[0x0]
80002ed6:	30 08       	mov	r8,0
80002ed8:	f0 09 19 00 	cp.h	r9,r8
80002edc:	e0 89 00 12 	brgt	80002f00 <phy_tx_func+0x3fc>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80002ee0:	4f 58       	lddpc	r8,800030b4 <phy_tx_func+0x5b0>
80002ee2:	11 89       	ld.ub	r9,r8[0x0]
80002ee4:	30 08       	mov	r8,0
80002ee6:	f0 09 18 00 	cp.b	r9,r8
80002eea:	5f 09       	sreq	r9
80002eec:	4e 48       	lddpc	r8,8000307c <phy_tx_func+0x578>
80002eee:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[0] = 0x00BA;
80002ef0:	e0 68 00 ba 	mov	r8,186
80002ef4:	ae 48       	st.h	r7[0x8],r8
				payload_tx_channel->word[1] = 0x0000;
80002ef6:	30 08       	mov	r8,0
80002ef8:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
80002efa:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80002efc:	ae 78       	st.h	r7[0xe],r8
80002efe:	ca d8       	rjmp	80003058 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
80002f00:	4e b8       	lddpc	r8,800030ac <phy_tx_func+0x5a8>
80002f02:	11 89       	ld.ub	r9,r8[0x0]
80002f04:	30 18       	mov	r8,1
80002f06:	f0 09 18 00 	cp.b	r9,r8
80002f0a:	c0 41       	brne	80002f12 <phy_tx_func+0x40e>
			{
				payload_tx_channel->word[0] =  0x0000;
80002f0c:	30 08       	mov	r8,0
80002f0e:	ae 48       	st.h	r7[0x8],r8
80002f10:	c1 08       	rjmp	80002f30 <phy_tx_func+0x42c>
			}
			else
			{
				//payload_tx_channel->word[0] = AudioData[index++] + (AudioData[index++] << 8);
				payload_tx_channel->word[0] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80002f12:	4e 28       	lddpc	r8,80003098 <phy_tx_func+0x594>
80002f14:	70 09       	ld.w	r9,r8[0x0]
80002f16:	4e 9a       	lddpc	r10,800030b8 <phy_tx_func+0x5b4>
80002f18:	f4 09 00 0b 	add	r11,r10,r9
80002f1c:	17 9b       	ld.ub	r11,r11[0x1]
80002f1e:	f4 09 07 09 	ld.ub	r9,r10[r9]
80002f22:	a9 69       	lsl	r9,0x8
80002f24:	f6 09 00 09 	add	r9,r11,r9
80002f28:	ae 49       	st.h	r7[0x8],r9
				index+=2;
80002f2a:	70 09       	ld.w	r9,r8[0x0]
80002f2c:	2f e9       	sub	r9,-2
80002f2e:	91 09       	st.w	r8[0x0],r9
			
			}

			expexted_length -= 2;
80002f30:	4e 09       	lddpc	r9,800030b0 <phy_tx_func+0x5ac>
80002f32:	92 08       	ld.sh	r8,r9[0x0]
80002f34:	20 28       	sub	r8,2
80002f36:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80002f38:	30 09       	mov	r9,0
80002f3a:	f2 08 19 00 	cp.h	r8,r9
80002f3e:	e0 89 00 11 	brgt	80002f60 <phy_tx_func+0x45c>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80002f42:	4d d8       	lddpc	r8,800030b4 <phy_tx_func+0x5b0>
80002f44:	11 89       	ld.ub	r9,r8[0x0]
80002f46:	30 08       	mov	r8,0
80002f48:	f0 09 18 00 	cp.b	r9,r8
80002f4c:	5f 09       	sreq	r9
80002f4e:	4c c8       	lddpc	r8,8000307c <phy_tx_func+0x578>
80002f50:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[1] = 0x00BA;
80002f52:	e0 68 00 ba 	mov	r8,186
80002f56:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
80002f58:	30 08       	mov	r8,0
80002f5a:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80002f5c:	ae 78       	st.h	r7[0xe],r8
80002f5e:	c7 d8       	rjmp	80003058 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
80002f60:	4d 38       	lddpc	r8,800030ac <phy_tx_func+0x5a8>
80002f62:	11 89       	ld.ub	r9,r8[0x0]
80002f64:	30 18       	mov	r8,1
80002f66:	f0 09 18 00 	cp.b	r9,r8
80002f6a:	c0 41       	brne	80002f72 <phy_tx_func+0x46e>
			{
				payload_tx_channel->word[1] =  0x0000;
80002f6c:	30 08       	mov	r8,0
80002f6e:	ae 58       	st.h	r7[0xa],r8
80002f70:	c1 08       	rjmp	80002f90 <phy_tx_func+0x48c>
			}
			else
			{
			
				payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80002f72:	4c a8       	lddpc	r8,80003098 <phy_tx_func+0x594>
80002f74:	70 09       	ld.w	r9,r8[0x0]
80002f76:	4d 1a       	lddpc	r10,800030b8 <phy_tx_func+0x5b4>
80002f78:	f4 09 00 0b 	add	r11,r10,r9
80002f7c:	17 9b       	ld.ub	r11,r11[0x1]
80002f7e:	f4 09 07 09 	ld.ub	r9,r10[r9]
80002f82:	a9 69       	lsl	r9,0x8
80002f84:	f6 09 00 09 	add	r9,r11,r9
80002f88:	ae 59       	st.h	r7[0xa],r9
				index+=2;
80002f8a:	70 09       	ld.w	r9,r8[0x0]
80002f8c:	2f e9       	sub	r9,-2
80002f8e:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
80002f90:	4c 89       	lddpc	r9,800030b0 <phy_tx_func+0x5ac>
80002f92:	92 08       	ld.sh	r8,r9[0x0]
80002f94:	20 28       	sub	r8,2
80002f96:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80002f98:	30 09       	mov	r9,0
80002f9a:	f2 08 19 00 	cp.h	r8,r9
80002f9e:	e0 89 00 10 	brgt	80002fbe <phy_tx_func+0x4ba>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80002fa2:	4c 58       	lddpc	r8,800030b4 <phy_tx_func+0x5b0>
80002fa4:	11 89       	ld.ub	r9,r8[0x0]
80002fa6:	30 08       	mov	r8,0
80002fa8:	f0 09 18 00 	cp.b	r9,r8
80002fac:	5f 09       	sreq	r9
80002fae:	4b 48       	lddpc	r8,8000307c <phy_tx_func+0x578>
80002fb0:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[2] = 0x00BA;
80002fb2:	e0 68 00 ba 	mov	r8,186
80002fb6:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80002fb8:	30 08       	mov	r8,0
80002fba:	ae 78       	st.h	r7[0xe],r8
80002fbc:	c4 e8       	rjmp	80003058 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
80002fbe:	4b c8       	lddpc	r8,800030ac <phy_tx_func+0x5a8>
80002fc0:	11 89       	ld.ub	r9,r8[0x0]
80002fc2:	30 18       	mov	r8,1
80002fc4:	f0 09 18 00 	cp.b	r9,r8
80002fc8:	c0 41       	brne	80002fd0 <phy_tx_func+0x4cc>
			{
				payload_tx_channel->word[2] =  0x0000;
80002fca:	30 08       	mov	r8,0
80002fcc:	ae 68       	st.h	r7[0xc],r8
80002fce:	c1 08       	rjmp	80002fee <phy_tx_func+0x4ea>
			}
			else
			{
			
				payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80002fd0:	4b 28       	lddpc	r8,80003098 <phy_tx_func+0x594>
80002fd2:	70 09       	ld.w	r9,r8[0x0]
80002fd4:	4b 9a       	lddpc	r10,800030b8 <phy_tx_func+0x5b4>
80002fd6:	f4 09 00 0b 	add	r11,r10,r9
80002fda:	17 9b       	ld.ub	r11,r11[0x1]
80002fdc:	f4 09 07 09 	ld.ub	r9,r10[r9]
80002fe0:	a9 69       	lsl	r9,0x8
80002fe2:	f6 09 00 09 	add	r9,r11,r9
80002fe6:	ae 69       	st.h	r7[0xc],r9
				index+=2;
80002fe8:	70 09       	ld.w	r9,r8[0x0]
80002fea:	2f e9       	sub	r9,-2
80002fec:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
80002fee:	4b 19       	lddpc	r9,800030b0 <phy_tx_func+0x5ac>
80002ff0:	92 08       	ld.sh	r8,r9[0x0]
80002ff2:	20 28       	sub	r8,2
80002ff4:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80002ff6:	30 09       	mov	r9,0
80002ff8:	f2 08 19 00 	cp.h	r8,r9
80002ffc:	e0 89 00 0e 	brgt	80003018 <phy_tx_func+0x514>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80003000:	4a d8       	lddpc	r8,800030b4 <phy_tx_func+0x5b0>
80003002:	11 89       	ld.ub	r9,r8[0x0]
80003004:	30 08       	mov	r8,0
80003006:	f0 09 18 00 	cp.b	r9,r8
8000300a:	5f 09       	sreq	r9
8000300c:	49 c8       	lddpc	r8,8000307c <phy_tx_func+0x578>
8000300e:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[3] = 0x00BA;
80003010:	e0 68 00 ba 	mov	r8,186
80003014:	ae 78       	st.h	r7[0xe],r8
80003016:	c2 18       	rjmp	80003058 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
80003018:	4a 58       	lddpc	r8,800030ac <phy_tx_func+0x5a8>
8000301a:	11 89       	ld.ub	r9,r8[0x0]
8000301c:	30 18       	mov	r8,1
8000301e:	f0 09 18 00 	cp.b	r9,r8
80003022:	c0 41       	brne	8000302a <phy_tx_func+0x526>
			{
				payload_tx_channel->word[3] =  0x0000;
80003024:	30 08       	mov	r8,0
80003026:	ae 78       	st.h	r7[0xe],r8
80003028:	c1 08       	rjmp	80003048 <phy_tx_func+0x544>
			}
			else
			{
			
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
8000302a:	49 c8       	lddpc	r8,80003098 <phy_tx_func+0x594>
8000302c:	70 09       	ld.w	r9,r8[0x0]
8000302e:	4a 3a       	lddpc	r10,800030b8 <phy_tx_func+0x5b4>
80003030:	f4 09 00 0b 	add	r11,r10,r9
80003034:	17 9b       	ld.ub	r11,r11[0x1]
80003036:	f4 09 07 09 	ld.ub	r9,r10[r9]
8000303a:	a9 69       	lsl	r9,0x8
8000303c:	f6 09 00 09 	add	r9,r11,r9
80003040:	ae 79       	st.h	r7[0xe],r9
				index+=2;
80003042:	70 09       	ld.w	r9,r8[0x0]
80003044:	2f e9       	sub	r9,-2
80003046:	91 09       	st.w	r8[0x0],r9
			}
		
			//payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
80003048:	49 a8       	lddpc	r8,800030b0 <phy_tx_func+0x5ac>
8000304a:	90 09       	ld.sh	r9,r8[0x0]
8000304c:	20 29       	sub	r9,2
8000304e:	b0 09       	st.h	r8[0x0],r9
80003050:	c0 48       	rjmp	80003058 <phy_tx_func+0x554>
		
			break;
		
		default:
			payload_tx_state = 0;
80003052:	30 09       	mov	r9,0
80003054:	48 a8       	lddpc	r8,8000307c <phy_tx_func+0x578>
80003056:	b0 89       	st.b	r8[0x0],r9
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80003058:	2f fd       	sub	sp,-4
8000305a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000305e:	00 00       	add	r0,r0
80003060:	00 00       	add	r0,r0
80003062:	0a c0       	st.b	r5++,r0
80003064:	00 00       	add	r0,r0
80003066:	0a 84       	andn	r4,r5
80003068:	00 00       	add	r0,r0
8000306a:	0a 60       	and	r0,r5
8000306c:	80 00       	ld.sh	r0,r0[0x0]
8000306e:	4f fc       	lddpc	r12,80003268 <phy_rx_func+0x64>
80003070:	00 00       	add	r0,r0
80003072:	0a aa       	st.w	r5++,r10
80003074:	00 00       	add	r0,r0
80003076:	0a 99       	mov	r9,r5
80003078:	00 00       	add	r0,r0
8000307a:	0a 3c       	cp.w	r12,r5
8000307c:	00 00       	add	r0,r0
8000307e:	0a a0       	st.w	r5++,r0
80003080:	00 00       	add	r0,r0
80003082:	0a 68       	and	r8,r5
80003084:	00 00       	add	r0,r0
80003086:	0a 88       	andn	r8,r5
80003088:	00 00       	add	r0,r0
8000308a:	0e 74       	tst	r4,r7
8000308c:	00 00       	add	r0,r0
8000308e:	0a 44       	or	r4,r5
80003090:	80 00       	ld.sh	r0,r0[0x0]
80003092:	c7 d8       	rjmp	8000318c <phy_init+0xa4>
80003094:	00 00       	add	r0,r0
80003096:	0d 7c       	ld.ub	r12,--r6
80003098:	00 00       	add	r0,r0
8000309a:	0a 78       	tst	r8,r5
8000309c:	00 00       	add	r0,r0
8000309e:	0a 45       	or	r5,r5
800030a0:	00 00       	add	r0,r0
800030a2:	0a c4       	st.b	r5++,r4
800030a4:	00 00       	add	r0,r0
800030a6:	0a 98       	mov	r8,r5
800030a8:	00 00       	add	r0,r0
800030aa:	0a b4       	st.h	r5++,r4
800030ac:	00 00       	add	r0,r0
800030ae:	0a 4c       	or	r12,r5
800030b0:	00 00       	add	r0,r0
800030b2:	0a d0       	st.w	--r5,r0
800030b4:	00 00       	add	r0,r0
800030b6:	0a 6c       	and	r12,r5
800030b8:	80 00       	ld.sh	r0,r0[0x0]
800030ba:	c8 34       	brge	80002fc0 <phy_tx_func+0x4bc>
800030bc:	00 00       	add	r0,r0
800030be:	0a d4       	st.w	--r5,r4

800030c0 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
800030c0:	d4 01       	pushm	lr
800030c2:	20 1d       	sub	sp,4
	void * ptr = NULL;
800030c4:	30 0a       	mov	r10,0
800030c6:	fa cb ff fc 	sub	r11,sp,-4
800030ca:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
800030cc:	14 99       	mov	r9,r10
800030ce:	1a 9b       	mov	r11,sp
800030d0:	f0 1f 00 05 	mcall	800030e4 <get_idle_store+0x24>
800030d4:	58 1c       	cp.w	r12,1
800030d6:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
800030da:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
800030de:	2f fd       	sub	sp,-4
800030e0:	d8 02       	popm	pc
800030e2:	00 00       	add	r0,r0
800030e4:	80 00       	ld.sh	r0,r0[0x0]
800030e6:	50 ec       	stdsp	sp[0x38],r12

800030e8 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
800030e8:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
800030ec:	f0 1f 00 21 	mcall	80003170 <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
800030f0:	4a 1b       	lddpc	r11,80003174 <phy_init+0x8c>
800030f2:	4a 2c       	lddpc	r12,80003178 <phy_init+0x90>
800030f4:	f0 1f 00 22 	mcall	8000317c <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800030f8:	30 4b       	mov	r11,4
800030fa:	31 ec       	mov	r12,30
800030fc:	f0 1f 00 21 	mcall	80003180 <phy_init+0x98>
80003100:	4a 18       	lddpc	r8,80003184 <phy_init+0x9c>
80003102:	91 0c       	st.w	r8[0x0],r12
80003104:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80003106:	10 96       	mov	r6,r8
80003108:	4a 05       	lddpc	r5,80003188 <phy_init+0xa0>
8000310a:	6c 0c       	ld.w	r12,r6[0x0]
8000310c:	ea 07 00 0b 	add	r11,r5,r7
80003110:	f0 1f 00 1f 	mcall	8000318c <phy_init+0xa4>
80003114:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80003118:	e0 47 1e 00 	cp.w	r7,7680
8000311c:	cf 71       	brne	8000310a <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000311e:	30 4b       	mov	r11,4
80003120:	31 4c       	mov	r12,20
80003122:	f0 1f 00 18 	mcall	80003180 <phy_init+0x98>
80003126:	49 b8       	lddpc	r8,80003190 <phy_init+0xa8>
80003128:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000312a:	30 4b       	mov	r11,4
8000312c:	30 ac       	mov	r12,10
8000312e:	f0 1f 00 15 	mcall	80003180 <phy_init+0x98>
80003132:	49 98       	lddpc	r8,80003194 <phy_init+0xac>
80003134:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80003136:	30 4b       	mov	r11,4
80003138:	30 ac       	mov	r12,10
8000313a:	f0 1f 00 12 	mcall	80003180 <phy_init+0x98>
8000313e:	49 78       	lddpc	r8,80003198 <phy_init+0xb0>
80003140:	91 0c       	st.w	r8[0x0],r12
80003142:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80003144:	10 96       	mov	r6,r8
80003146:	49 65       	lddpc	r5,8000319c <phy_init+0xb4>
80003148:	6c 0c       	ld.w	r12,r6[0x0]
8000314a:	ea 07 00 0b 	add	r11,r5,r7
8000314e:	f0 1f 00 10 	mcall	8000318c <phy_init+0xa4>
80003152:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80003156:	e0 47 14 00 	cp.w	r7,5120
8000315a:	cf 71       	brne	80003148 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
8000315c:	e0 6b 01 00 	mov	r11,256
80003160:	30 5c       	mov	r12,5
80003162:	f0 1f 00 08 	mcall	80003180 <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
80003166:	48 f8       	lddpc	r8,800031a0 <phy_init+0xb8>
80003168:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
8000316a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000316e:	00 00       	add	r0,r0
80003170:	80 00       	ld.sh	r0,r0[0x0]
80003172:	3d 3c       	mov	r12,-45
80003174:	80 00       	ld.sh	r0,r0[0x0]
80003176:	2b 04       	sub	r4,-80
80003178:	80 00       	ld.sh	r0,r0[0x0]
8000317a:	32 04       	mov	r4,32
8000317c:	80 00       	ld.sh	r0,r0[0x0]
8000317e:	3d 28       	mov	r8,-46
80003180:	80 00       	ld.sh	r0,r0[0x0]
80003182:	53 f8       	stdsp	sp[0xfc],r8
80003184:	00 00       	add	r0,r0
80003186:	0a 90       	mov	r0,r5
80003188:	00 00       	add	r0,r0
8000318a:	22 78       	sub	r8,39
8000318c:	80 00       	ld.sh	r0,r0[0x0]
8000318e:	2a 60       	sub	r0,-90
80003190:	00 00       	add	r0,r0
80003192:	0a c0       	st.b	r5++,r0
80003194:	00 00       	add	r0,r0
80003196:	0a ac       	st.w	r5++,r12
80003198:	00 00       	add	r0,r0
8000319a:	0a 80       	andn	r0,r5
8000319c:	00 00       	add	r0,r0
8000319e:	0e 78       	tst	r8,r7
800031a0:	00 00       	add	r0,r0
800031a2:	0a a4       	st.w	r5++,r4

800031a4 <payload_rx>:




static void payload_rx(void * payload)
{
800031a4:	d4 01       	pushm	lr
800031a6:	20 2d       	sub	sp,8
800031a8:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800031aa:	30 08       	mov	r8,0
800031ac:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
800031ae:	48 f8       	lddpc	r8,800031e8 <payload_rx+0x44>
800031b0:	70 08       	ld.w	r8,r8[0x0]
800031b2:	58 08       	cp.w	r8,0
800031b4:	c0 71       	brne	800031c2 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
800031b6:	30 4b       	mov	r11,4
800031b8:	30 5c       	mov	r12,5
800031ba:	f0 1f 00 0d 	mcall	800031ec <payload_rx+0x48>
800031be:	48 b8       	lddpc	r8,800031e8 <payload_rx+0x44>
800031c0:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
800031c2:	48 a8       	lddpc	r8,800031e8 <payload_rx+0x44>
800031c4:	70 0c       	ld.w	r12,r8[0x0]
800031c6:	30 09       	mov	r9,0
800031c8:	fa ca ff fc 	sub	r10,sp,-4
800031cc:	1a 9b       	mov	r11,sp
800031ce:	f0 1f 00 09 	mcall	800031f0 <payload_rx+0x4c>
800031d2:	c0 91       	brne	800031e4 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
800031d4:	48 88       	lddpc	r8,800031f4 <payload_rx+0x50>
800031d6:	70 0c       	ld.w	r12,r8[0x0]
800031d8:	40 0b       	lddsp	r11,sp[0x0]
800031da:	f0 1f 00 08 	mcall	800031f8 <payload_rx+0x54>
		logFromISR("mm");
800031de:	48 8c       	lddpc	r12,800031fc <payload_rx+0x58>
800031e0:	f0 1f 00 08 	mcall	80003200 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
800031e4:	2f ed       	sub	sp,-8
800031e6:	d8 02       	popm	pc
800031e8:	00 00       	add	r0,r0
800031ea:	0a 70       	tst	r0,r5
800031ec:	80 00       	ld.sh	r0,r0[0x0]
800031ee:	53 f8       	stdsp	sp[0xfc],r8
800031f0:	80 00       	ld.sh	r0,r0[0x0]
800031f2:	52 a8       	stdsp	sp[0xa8],r8
800031f4:	00 00       	add	r0,r0
800031f6:	0a 80       	andn	r0,r5
800031f8:	80 00       	ld.sh	r0,r0[0x0]
800031fa:	2a 0c       	sub	r12,-96
800031fc:	80 01       	ld.sh	r1,r0[0x0]
800031fe:	4b e4       	lddpc	r4,800032f4 <phy_rx_func+0xf0>
80003200:	80 00       	ld.sh	r0,r0[0x0]
80003202:	60 1c       	ld.w	r12,r0[0x4]

80003204 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80003204:	eb cd 40 e0 	pushm	r5-r7,lr
80003208:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
8000320a:	fe f8 09 7e 	ld.w	r8,pc[2430]
8000320e:	70 08       	ld.w	r8,r8[0x0]
80003210:	58 08       	cp.w	r8,0
80003212:	e0 80 01 05 	breq	8000341c <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80003216:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003218:	fe f8 09 74 	ld.w	r8,pc[2420]
8000321c:	70 09       	ld.w	r9,r8[0x0]
8000321e:	2f f9       	sub	r9,-1
80003220:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80003222:	fe f8 09 6e 	ld.w	r8,pc[2414]
80003226:	70 08       	ld.w	r8,r8[0x0]
80003228:	58 18       	cp.w	r8,1
8000322a:	e0 80 00 84 	breq	80003332 <phy_rx_func+0x12e>
8000322e:	c0 73       	brcs	8000323c <phy_rx_func+0x38>
80003230:	58 28       	cp.w	r8,2
80003232:	c5 b0       	breq	800032e8 <phy_rx_func+0xe4>
80003234:	58 38       	cp.w	r8,3
80003236:	e0 81 00 f3 	brne	8000341c <phy_rx_func+0x218>
8000323a:	cd 38       	rjmp	800033e0 <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
8000323c:	e0 6a 5a 5a 	mov	r10,23130
80003240:	ea 1a ab cd 	orh	r10,0xabcd
80003244:	14 36       	cp.w	r6,r10
80003246:	e0 80 00 eb 	breq	8000341c <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
8000324a:	ec 08 16 10 	lsr	r8,r6,0x10
8000324e:	e0 48 ab cd 	cp.w	r8,43981
80003252:	e0 81 00 e5 	brne	8000341c <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80003256:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
8000325a:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000325e:	20 28       	sub	r8,2
80003260:	fe f9 09 34 	ld.w	r9,pc[2356]
80003264:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80003266:	30 09       	mov	r9,0
80003268:	f2 08 19 00 	cp.h	r8,r9
8000326c:	e0 8a 00 d8 	brle	8000341c <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
80003270:	fe f8 09 28 	ld.w	r8,pc[2344]
80003274:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
80003276:	fe f8 09 26 	ld.w	r8,pc[2342]
8000327a:	70 0c       	ld.w	r12,r8[0x0]
8000327c:	f0 1f 02 49 	mcall	80003ba0 <phy_rx_func+0x99c>
80003280:	fe f8 09 24 	ld.w	r8,pc[2340]
80003284:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80003286:	58 0c       	cp.w	r12,0
80003288:	e0 80 00 ca 	breq	8000341c <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
8000328c:	fe f8 09 0c 	ld.w	r8,pc[2316]
80003290:	90 09       	ld.sh	r9,r8[0x0]
80003292:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80003296:	2f f9       	sub	r9,-1
80003298:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000329a:	fe fa 09 0a 	ld.w	r10,pc[2314]
8000329e:	74 0a       	ld.w	r10,r10[0x0]
800032a0:	fe fb 08 ec 	ld.w	r11,pc[2284]
800032a4:	76 0b       	ld.w	r11,r11[0x0]
800032a6:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
800032aa:	2f f9       	sub	r9,-1
800032ac:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
800032ae:	e2 16 0f 00 	andl	r6,0xf00,COH
800032b2:	e0 46 01 00 	cp.w	r6,256
800032b6:	c0 c0       	breq	800032ce <phy_rx_func+0xca>
800032b8:	e0 8b 00 05 	brhi	800032c2 <phy_rx_func+0xbe>
800032bc:	58 06       	cp.w	r6,0
800032be:	c0 80       	breq	800032ce <phy_rx_func+0xca>
800032c0:	c0 c8       	rjmp	800032d8 <phy_rx_func+0xd4>
800032c2:	e0 46 02 00 	cp.w	r6,512
800032c6:	c0 40       	breq	800032ce <phy_rx_func+0xca>
800032c8:	e0 46 03 00 	cp.w	r6,768
800032cc:	c0 61       	brne	800032d8 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
800032ce:	30 29       	mov	r9,2
800032d0:	fe f8 08 c0 	ld.w	r8,pc[2240]
800032d4:	91 09       	st.w	r8[0x0],r9
800032d6:	ca 38       	rjmp	8000341c <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
800032d8:	fe f6 08 cc 	ld.w	r6,pc[2252]
800032dc:	6c 0c       	ld.w	r12,r6[0x0]
800032de:	f0 1f 02 33 	mcall	80003ba8 <phy_rx_func+0x9a4>
					phy_frame_ptr = NULL;					
800032e2:	30 08       	mov	r8,0
800032e4:	8d 08       	st.w	r6[0x0],r8
800032e6:	c9 b8       	rjmp	8000341c <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
800032e8:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
800032ec:	b1 86       	lsr	r6,0x10
800032ee:	14 06       	add	r6,r10
800032f0:	fe f8 08 bc 	ld.w	r8,pc[2236]
800032f4:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800032f6:	fe f8 08 a2 	ld.w	r8,pc[2210]
800032fa:	90 09       	ld.sh	r9,r8[0x0]
800032fc:	fe fb 08 a8 	ld.w	r11,pc[2216]
80003300:	76 0b       	ld.w	r11,r11[0x0]
80003302:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80003306:	2f f9       	sub	r9,-1
80003308:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
8000330a:	fe f9 08 8a 	ld.w	r9,pc[2186]
8000330e:	92 08       	ld.sh	r8,r9[0x0]
80003310:	20 28       	sub	r8,2
80003312:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80003314:	30 09       	mov	r9,0
80003316:	f2 08 19 00 	cp.h	r8,r9
8000331a:	e0 8a 00 07 	brle	80003328 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
8000331e:	30 19       	mov	r9,1
80003320:	fe f8 08 70 	ld.w	r8,pc[2160]
80003324:	91 09       	st.w	r8[0x0],r9
80003326:	c7 b8       	rjmp	8000341c <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80003328:	30 39       	mov	r9,3
8000332a:	fe f8 08 66 	ld.w	r8,pc[2150]
8000332e:	91 09       	st.w	r8[0x0],r9
80003330:	c7 68       	rjmp	8000341c <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80003332:	ec 0a 14 10 	asr	r10,r6,0x10
80003336:	fe f8 08 76 	ld.w	r8,pc[2166]
8000333a:	90 09       	ld.sh	r9,r8[0x0]
8000333c:	14 09       	add	r9,r10
8000333e:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003340:	fe f9 08 58 	ld.w	r9,pc[2136]
80003344:	92 08       	ld.sh	r8,r9[0x0]
80003346:	fe fb 08 5e 	ld.w	r11,pc[2142]
8000334a:	76 0b       	ld.w	r11,r11[0x0]
8000334c:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80003350:	2f f8       	sub	r8,-1
80003352:	5c 88       	casts.h	r8
80003354:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003356:	fe fa 08 3e 	ld.w	r10,pc[2110]
8000335a:	94 09       	ld.sh	r9,r10[0x0]
8000335c:	20 29       	sub	r9,2
8000335e:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80003360:	30 0a       	mov	r10,0
80003362:	f4 09 19 00 	cp.h	r9,r10
80003366:	e0 89 00 1f 	brgt	800033a4 <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
8000336a:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
8000336e:	e0 46 00 ba 	cp.w	r6,186
80003372:	c0 d1       	brne	8000338c <phy_rx_func+0x188>
80003374:	fe f8 08 38 	ld.w	r8,pc[2104]
80003378:	90 09       	ld.sh	r9,r8[0x0]
8000337a:	f4 09 19 00 	cp.h	r9,r10
8000337e:	c0 71       	brne	8000338c <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003380:	fe f8 08 24 	ld.w	r8,pc[2084]
80003384:	70 0c       	ld.w	r12,r8[0x0]
80003386:	f0 1f 02 0b 	mcall	80003bb0 <phy_rx_func+0x9ac>
8000338a:	c0 88       	rjmp	8000339a <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
8000338c:	fe f6 08 18 	ld.w	r6,pc[2072]
80003390:	6c 0c       	ld.w	r12,r6[0x0]
80003392:	f0 1f 02 06 	mcall	80003ba8 <phy_rx_func+0x9a4>
					phy_frame_ptr = NULL;
80003396:	30 08       	mov	r8,0
80003398:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
8000339a:	30 09       	mov	r9,0
8000339c:	fe f8 07 f4 	ld.w	r8,pc[2036]
800033a0:	91 09       	st.w	r8[0x0],r9
800033a2:	c3 d8       	rjmp	8000341c <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
800033a4:	5c 86       	casts.h	r6
800033a6:	fe f9 08 06 	ld.w	r9,pc[2054]
800033aa:	92 0a       	ld.sh	r10,r9[0x0]
800033ac:	0c 0a       	add	r10,r6
800033ae:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800033b0:	fe f9 07 f4 	ld.w	r9,pc[2036]
800033b4:	72 09       	ld.w	r9,r9[0x0]
800033b6:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
800033ba:	2f f8       	sub	r8,-1
800033bc:	fe f9 07 dc 	ld.w	r9,pc[2012]
800033c0:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
800033c2:	fe f9 07 d2 	ld.w	r9,pc[2002]
800033c6:	92 08       	ld.sh	r8,r9[0x0]
800033c8:	20 28       	sub	r8,2
800033ca:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
800033cc:	30 09       	mov	r9,0
800033ce:	f2 08 19 00 	cp.h	r8,r9
800033d2:	e0 89 00 25 	brgt	8000341c <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
800033d6:	30 39       	mov	r9,3
800033d8:	fe f8 07 b8 	ld.w	r8,pc[1976]
800033dc:	91 09       	st.w	r8[0x0],r9
800033de:	c1 f8       	rjmp	8000341c <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
800033e0:	e6 16 00 ff 	andh	r6,0xff,COH
800033e4:	fc 19 00 ba 	movh	r9,0xba
800033e8:	12 36       	cp.w	r6,r9
800033ea:	c0 e1       	brne	80003406 <phy_rx_func+0x202>
800033ec:	fe f8 07 c0 	ld.w	r8,pc[1984]
800033f0:	90 09       	ld.sh	r9,r8[0x0]
800033f2:	30 08       	mov	r8,0
800033f4:	f0 09 19 00 	cp.h	r9,r8
800033f8:	c0 71       	brne	80003406 <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800033fa:	fe f8 07 aa 	ld.w	r8,pc[1962]
800033fe:	70 0c       	ld.w	r12,r8[0x0]
80003400:	f0 1f 01 ec 	mcall	80003bb0 <phy_rx_func+0x9ac>
80003404:	c0 88       	rjmp	80003414 <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
80003406:	fe f6 07 9e 	ld.w	r6,pc[1950]
8000340a:	6c 0c       	ld.w	r12,r6[0x0]
8000340c:	f0 1f 01 e7 	mcall	80003ba8 <phy_rx_func+0x9a4>
				phy_frame_ptr = NULL;
80003410:	30 08       	mov	r8,0
80003412:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80003414:	30 09       	mov	r9,0
80003416:	fe f8 07 7a 	ld.w	r8,pc[1914]
8000341a:	91 09       	st.w	r8[0x0],r9
	
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
	
	
	if(is_first == FALSE)
8000341c:	fe f8 07 98 	ld.w	r8,pc[1944]
80003420:	11 89       	ld.ub	r9,r8[0x0]
80003422:	30 08       	mov	r8,0
80003424:	f0 09 18 00 	cp.b	r9,r8
80003428:	c0 d1       	brne	80003442 <phy_rx_func+0x23e>
	{
		payload_ptr = get_payload_idle_isr();
8000342a:	fe f8 07 8e 	ld.w	r8,pc[1934]
8000342e:	70 0c       	ld.w	r12,r8[0x0]
80003430:	f0 1f 01 dc 	mcall	80003ba0 <phy_rx_func+0x99c>
80003434:	fe f8 07 88 	ld.w	r8,pc[1928]
80003438:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
8000343a:	30 19       	mov	r9,1
8000343c:	fe f8 07 78 	ld.w	r8,pc[1912]
80003440:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003442:	fe f8 07 7e 	ld.w	r8,pc[1918]
80003446:	70 08       	ld.w	r8,r8[0x0]
80003448:	58 28       	cp.w	r8,2
8000344a:	e0 80 01 58 	breq	800036fa <phy_rx_func+0x4f6>
8000344e:	58 38       	cp.w	r8,3
80003450:	e0 80 02 16 	breq	8000387c <phy_rx_func+0x678>
80003454:	58 08       	cp.w	r8,0
80003456:	e0 81 03 96 	brne	80003b82 <phy_rx_func+0x97e>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
8000345a:	6e 28       	ld.w	r8,r7[0x8]
8000345c:	e0 6a 5a 5a 	mov	r10,23130
80003460:	ea 1a ab cd 	orh	r10,0xabcd
80003464:	14 38       	cp.w	r8,r10
80003466:	c0 71       	brne	80003474 <phy_rx_func+0x270>
			{
				m_RxBurstType = VOICE_WATING;
80003468:	30 09       	mov	r9,0
8000346a:	fe f8 07 5a 	ld.w	r8,pc[1882]
8000346e:	91 09       	st.w	r8[0x0],r9
80003470:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003474:	10 99       	mov	r9,r8
80003476:	e0 19 00 00 	andl	r9,0x0
8000347a:	fc 1a ab cd 	movh	r10,0xabcd
8000347e:	14 39       	cp.w	r9,r10
80003480:	e0 81 03 81 	brne	80003b82 <phy_rx_func+0x97e>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003484:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003488:	fe f9 07 40 	ld.w	r9,pc[1856]
8000348c:	93 08       	st.w	r9[0x0],r8
		
			if(NULL== payload_ptr)
8000348e:	fe f8 07 2e 	ld.w	r8,pc[1838]
80003492:	70 08       	ld.w	r8,r8[0x0]
80003494:	58 08       	cp.w	r8,0
80003496:	c0 c1       	brne	800034ae <phy_rx_func+0x2aa>
			{
				payload_ptr = get_payload_idle_isr();
80003498:	fe f8 07 20 	ld.w	r8,pc[1824]
8000349c:	70 0c       	ld.w	r12,r8[0x0]
8000349e:	f0 1f 01 c1 	mcall	80003ba0 <phy_rx_func+0x99c>
800034a2:	fe f8 07 1a 	ld.w	r8,pc[1818]
800034a6:	91 0c       	st.w	r8[0x0],r12
				if(NULL== payload_ptr)
800034a8:	58 0c       	cp.w	r12,0
800034aa:	e0 80 03 6c 	breq	80003b82 <phy_rx_func+0x97e>
				}
			}
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800034ae:	6e 28       	ld.w	r8,r7[0x8]
800034b0:	e2 18 f0 00 	andl	r8,0xf000,COH
800034b4:	e0 48 c0 00 	cp.w	r8,49152
800034b8:	e0 81 00 8e 	brne	800035d4 <phy_rx_func+0x3d0>
			{
				AMBE_flag = 1;
800034bc:	30 19       	mov	r9,1
800034be:	fe f8 07 0e 	ld.w	r8,pc[1806]
800034c2:	b0 89       	st.b	r8[0x0],r9
								
				Item_ID = payload_rx_channel->byte[5];
800034c4:	ef 39 00 0d 	ld.ub	r9,r7[13]
800034c8:	fe f8 07 08 	ld.w	r8,pc[1800]
800034cc:	b0 89       	st.b	r8[0x0],r9
				
				VF_SN = payload_rx_channel->byte[7];//This parameter is very important to the loopback Radio, as a reference.
800034ce:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800034d2:	fe f9 07 02 	ld.w	r9,pc[1794]
800034d6:	b2 8c       	st.b	r9[0x0],r12
					
				//The OB know the Call begin and discard the Voice Header
				//The OB know the Call end and discard the Voice  Terminator			
				if (Item_ID == Raw_Tx_Data_HT)
800034d8:	11 89       	ld.ub	r9,r8[0x0]
800034da:	3f 08       	mov	r8,-16
800034dc:	f0 09 18 00 	cp.b	r9,r8
800034e0:	c2 b1       	brne	80003536 <phy_rx_func+0x332>
				{
					//HT_index = 0;
					//AMBE_HT[0] = payload_rx_channel->dword[0];
					//AMBE_HT[1] = payload_rx_channel->dword[1];
					//
					if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800034e2:	ef 38 00 0e 	ld.ub	r8,r7[14]
800034e6:	e2 18 00 f0 	andl	r8,0xf0,COH
800034ea:	59 08       	cp.w	r8,16
800034ec:	c0 71       	brne	800034fa <phy_rx_func+0x2f6>
					{
						m_RxBurstType = VOICEHEADER;		
800034ee:	30 19       	mov	r9,1
800034f0:	fe f8 06 d4 	ld.w	r8,pc[1748]
800034f4:	91 09       	st.w	r8[0x0],r9
800034f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

					}
					else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800034fa:	e0 48 00 20 	cp.w	r8,32
800034fe:	c1 61       	brne	8000352a <phy_rx_func+0x326>
					{
						m_RxBurstType = VOICETERMINATOR;
80003500:	30 99       	mov	r9,9
80003502:	fe f8 06 c2 	ld.w	r8,pc[1730]
80003506:	91 09       	st.w	r8[0x0],r9
						//In order to complete the save data AMBE stream to SDcard.
						//AMBE-data and PCM-data is not the same. AMBE is compressed data,
						//if there was a missing portion, a clear voice is difficult to extract the data. 
						//It must ensure that all the data received AMBE.
						RxMedia_IsFillingNext16 = 0;
80003508:	30 09       	mov	r9,0
8000350a:	fe f8 06 ce 	ld.w	r8,pc[1742]
8000350e:	91 09       	st.w	r8[0x0],r9
						payload_rx(payload_ptr);//注意！！！考虑是否需要把剩余的空间置0。
80003510:	fe f7 06 ac 	ld.w	r7,pc[1708]
80003514:	6e 0c       	ld.w	r12,r7[0x0]
80003516:	f0 1f 01 b2 	mcall	80003bdc <phy_rx_func+0x9d8>
						payload_ptr = get_payload_idle_isr();
8000351a:	fe f8 06 9e 	ld.w	r8,pc[1694]
8000351e:	70 0c       	ld.w	r12,r8[0x0]
80003520:	f0 1f 01 a0 	mcall	80003ba0 <phy_rx_func+0x99c>
80003524:	8f 0c       	st.w	r7[0x0],r12
80003526:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						//logFromISR("\n\r QQ1 \n\r");
						
					}
					else//error voice
					{
						m_RxBurstType = VOICE_WATING;
8000352a:	30 09       	mov	r9,0
8000352c:	fe f8 06 98 	ld.w	r8,pc[1688]
80003530:	91 09       	st.w	r8[0x0],r9
80003532:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					
					break;//WAITINGABAB.
		
						
				}
				else if (Item_ID == Vocoder_Bit_Stream_Parameter)//Vocoder Bits Stream Parameter
80003536:	fe f8 06 9a 	ld.w	r8,pc[1690]
8000353a:	11 89       	ld.ub	r9,r8[0x0]
8000353c:	31 28       	mov	r8,18
8000353e:	f0 09 18 00 	cp.b	r9,r8
80003542:	c0 d1       	brne	8000355c <phy_rx_func+0x358>
				{	
						
						VBSP_data[0] = payload_rx_channel->word[2];
80003544:	8e 69       	ld.sh	r9,r7[0xc]
80003546:	fe f8 06 9a 	ld.w	r8,pc[1690]
8000354a:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[3];
8000354c:	8e 79       	ld.sh	r9,r7[0xe]
8000354e:	b0 19       	st.h	r8[0x2],r9
						m_RxBurstType = CalculateBurst(VF_SN);
80003550:	f0 1f 01 a5 	mcall	80003be4 <phy_rx_func+0x9e0>
80003554:	fe f8 06 70 	ld.w	r8,pc[1648]
80003558:	91 0c       	st.w	r8[0x0],r12
8000355a:	c3 78       	rjmp	800035c8 <phy_rx_func+0x3c4>

				}
				else if ((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
8000355c:	fe f8 06 74 	ld.w	r8,pc[1652]
80003560:	11 89       	ld.ub	r9,r8[0x0]
80003562:	30 48       	mov	r8,4
80003564:	f0 09 18 00 	cp.b	r9,r8
80003568:	c0 80       	breq	80003578 <phy_rx_func+0x374>
8000356a:	fe f8 06 66 	ld.w	r8,pc[1638]
8000356e:	11 89       	ld.ub	r9,r8[0x0]
80003570:	30 38       	mov	r8,3
80003572:	f0 09 18 00 	cp.b	r9,r8
80003576:	c1 c1       	brne	800035ae <phy_rx_func+0x3aa>
				{
					//break;
					m_RxBurstType = UNSUREDATA;
80003578:	30 29       	mov	r9,2
8000357a:	fe f8 06 4a 	ld.w	r8,pc[1610]
8000357e:	91 09       	st.w	r8[0x0],r9
					AMBE_HT[0] = payload_rx_channel->dword[0];
80003580:	6e 29       	ld.w	r9,r7[0x8]
80003582:	fe f8 06 66 	ld.w	r8,pc[1638]
80003586:	91 09       	st.w	r8[0x0],r9
					AMBE_HT[1] = payload_rx_channel->dword[1];
80003588:	6e 39       	ld.w	r9,r7[0xc]
8000358a:	91 19       	st.w	r8[0x4],r9
					
					if (RxBytesWaiting == 0x00000014)
8000358c:	fe f8 06 3c 	ld.w	r8,pc[1596]
80003590:	70 08       	ld.w	r8,r8[0x0]
80003592:	59 48       	cp.w	r8,20
80003594:	c0 61       	brne	800035a0 <phy_rx_func+0x39c>
					{
						RxBytesWaiting = 0x18;//24 Reassigned
80003596:	31 89       	mov	r9,24
80003598:	fe f8 06 30 	ld.w	r8,pc[1584]
8000359c:	91 09       	st.w	r8[0x0],r9
8000359e:	c1 58       	rjmp	800035c8 <phy_rx_func+0x3c4>
						//_flag =0;
							
					}
					if (RxBytesWaiting == 0x00000010)
800035a0:	59 08       	cp.w	r8,16
800035a2:	c1 31       	brne	800035c8 <phy_rx_func+0x3c4>
					{
						RxBytesWaiting = 0x10;//16 Reassigned
800035a4:	31 09       	mov	r9,16
800035a6:	fe f8 06 22 	ld.w	r8,pc[1570]
800035aa:	91 09       	st.w	r8[0x0],r9
800035ac:	c0 e8       	rjmp	800035c8 <phy_rx_func+0x3c4>
					
				}
				else
				{
					
					logFromISR("\n\r Item_ID:%x \n\r", payload_rx_channel->word[2]);
800035ae:	8e e8       	ld.uh	r8,r7[0xc]
800035b0:	1a d8       	st.w	--sp,r8
800035b2:	fe fc 06 3a 	ld.w	r12,pc[1594]
800035b6:	f0 1f 01 8f 	mcall	80003bf0 <phy_rx_func+0x9ec>
					logFromISR("\n\r Axiba \n\r");
800035ba:	fe fc 06 3a 	ld.w	r12,pc[1594]
800035be:	f0 1f 01 8d 	mcall	80003bf0 <phy_rx_func+0x9ec>
800035c2:	2f fd       	sub	sp,-4
800035c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					//Radio Internal Parameter(0x7F):
					//The OB should use the route back this item to radio without change content.
					break;
				}
				
				RxMediaState = READING_AMBE_MEDIA;//Jump
800035c8:	30 39       	mov	r9,3
800035ca:	fe f8 05 f6 	ld.w	r8,pc[1526]
800035ce:	91 09       	st.w	r8[0x0],r9
800035d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
800035d4:	e0 48 10 00 	cp.w	r8,4096
800035d8:	5f 19       	srne	r9
800035da:	e0 48 20 00 	cp.w	r8,8192
800035de:	5f 18       	srne	r8
800035e0:	f3 e8 00 08 	and	r8,r9,r8
800035e4:	e0 81 02 cf 	brne	80003b82 <phy_rx_func+0x97e>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_flag = 0;
800035e8:	fe f9 05 e4 	ld.w	r9,pc[1508]
800035ec:	b2 88       	st.b	r9[0x0],r8
				
				Item_ID = 0;//To make sure your save PCM data.
800035ee:	fe f9 05 e2 	ld.w	r9,pc[1506]
800035f2:	b2 88       	st.b	r9[0x0],r8
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800035f4:	6e 28       	ld.w	r8,r7[0x8]
800035f6:	e2 18 0f 00 	andl	r8,0xf00,COH
800035fa:	58 18       	cp.w	r8,1
800035fc:	e0 8b 00 4d 	brhi	80003696 <phy_rx_func+0x492>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Frag type must process Array Discriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
				if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003600:	fe f9 05 c8 	ld.w	r9,pc[1480]
80003604:	72 08       	ld.w	r8,r9[0x0]
80003606:	20 48       	sub	r8,4
80003608:	93 08       	st.w	r9[0x0],r8
8000360a:	e0 80 02 bc 	breq	80003b82 <phy_rx_func+0x97e>
				ArrayDiscLength = payload_rx_channel->word[2];
8000360e:	8e 68       	ld.sh	r8,r7[0xc]
80003610:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003614:	fe f9 05 e4 	ld.w	r9,pc[1508]
80003618:	93 0a       	st.w	r9[0x0],r10
				
				switch (ArrayDiscLength){
8000361a:	30 09       	mov	r9,0
8000361c:	f2 08 19 00 	cp.h	r8,r9
80003620:	c0 70       	breq	8000362e <phy_rx_func+0x42a>
80003622:	30 19       	mov	r9,1
80003624:	f2 08 19 00 	cp.h	r8,r9
80003628:	e0 81 02 ad 	brne	80003b82 <phy_rx_func+0x97e>
8000362c:	c2 68       	rjmp	80003678 <phy_rx_func+0x474>
					case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
8000362e:	fe f8 05 aa 	ld.w	r8,pc[1450]
80003632:	70 0a       	ld.w	r10,r8[0x0]
80003634:	fe f9 05 88 	ld.w	r9,pc[1416]
80003638:	72 09       	ld.w	r9,r9[0x0]
8000363a:	8e 7b       	ld.sh	r11,r7[0xe]
8000363c:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
80003640:	70 09       	ld.w	r9,r8[0x0]
80003642:	2f f9       	sub	r9,-1
80003644:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003646:	e0 49 00 ff 	cp.w	r9,255
8000364a:	e0 88 00 11 	brls	8000366c <phy_rx_func+0x468>
						{
							RxMedia_IsFillingNext16 = 0;	
8000364e:	30 09       	mov	r9,0
80003650:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);	
80003652:	fe f7 05 6a 	ld.w	r7,pc[1386]
80003656:	6e 0c       	ld.w	r12,r7[0x0]
80003658:	f0 1f 01 61 	mcall	80003bdc <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
8000365c:	fe f8 05 5c 	ld.w	r8,pc[1372]
80003660:	70 0c       	ld.w	r12,r8[0x0]
80003662:	f0 1f 01 50 	mcall	80003ba0 <phy_rx_func+0x99c>
80003666:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
80003668:	e0 80 02 8d 	breq	80003b82 <phy_rx_func+0x97e>
							{
								break;
							}				
						}
							RxMediaState = READINGMEDIA;
8000366c:	30 29       	mov	r9,2
8000366e:	fe f8 05 52 	ld.w	r8,pc[1362]
80003672:	91 09       	st.w	r8[0x0],r9
80003674:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003678:	8e 79       	ld.sh	r9,r7[0xe]
8000367a:	30 38       	mov	r8,3
8000367c:	f0 09 19 00 	cp.h	r9,r8
80003680:	c0 51       	brne	8000368a <phy_rx_func+0x486>
				
					case 1: //The next usual case.
							//In general case, add code to process single word Array descriptor.
							if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
							{
								Terminator_Flag = 1;
80003682:	30 19       	mov	r9,1
80003684:	fe f8 05 78 	ld.w	r8,pc[1400]
80003688:	b0 89       	st.b	r8[0x0],r9
							{
								//Terminator_Flag = 0;
							}
					
					
							RxMediaState = READINGMEDIA;
8000368a:	30 29       	mov	r9,2
8000368c:	fe f8 05 34 	ld.w	r8,pc[1332]
80003690:	91 09       	st.w	r8[0x0],r9
80003692:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
				}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003696:	fe f8 05 32 	ld.w	r8,pc[1330]
8000369a:	70 08       	ld.w	r8,r8[0x0]
8000369c:	58 18       	cp.w	r8,1
8000369e:	e0 88 02 72 	brls	80003b82 <phy_rx_func+0x97e>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
800036a2:	fe f8 05 36 	ld.w	r8,pc[1334]
800036a6:	70 0a       	ld.w	r10,r8[0x0]
800036a8:	fe f9 05 14 	ld.w	r9,pc[1300]
800036ac:	72 09       	ld.w	r9,r9[0x0]
800036ae:	6e 3b       	ld.w	r11,r7[0xc]
800036b0:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800036b4:	70 09       	ld.w	r9,r8[0x0]
800036b6:	2f f9       	sub	r9,-1
800036b8:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800036ba:	e0 49 00 ff 	cp.w	r9,255
800036be:	e0 88 00 11 	brls	800036e0 <phy_rx_func+0x4dc>
				{
					RxMedia_IsFillingNext16 = 0;
800036c2:	30 09       	mov	r9,0
800036c4:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800036c6:	fe f7 04 f6 	ld.w	r7,pc[1270]
800036ca:	6e 0c       	ld.w	r12,r7[0x0]
800036cc:	f0 1f 01 44 	mcall	80003bdc <phy_rx_func+0x9d8>
								payload_ptr = get_payload_idle_isr();
800036d0:	fe f8 04 e8 	ld.w	r8,pc[1256]
800036d4:	70 0c       	ld.w	r12,r8[0x0]
800036d6:	f0 1f 01 33 	mcall	80003ba0 <phy_rx_func+0x99c>
800036da:	8f 0c       	st.w	r7[0x0],r12
													if(NULL == payload_ptr)
800036dc:	e0 80 02 53 	breq	80003b82 <phy_rx_func+0x97e>
													{
														break;
													}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
800036e0:	fe f9 04 e8 	ld.w	r9,pc[1256]
800036e4:	72 08       	ld.w	r8,r9[0x0]
800036e6:	20 28       	sub	r8,2
800036e8:	93 08       	st.w	r9[0x0],r8
800036ea:	e0 80 02 4c 	breq	80003b82 <phy_rx_func+0x97e>
				RxMediaState = READINGMEDIA;
800036ee:	30 29       	mov	r9,2
800036f0:	fe f8 04 d0 	ld.w	r8,pc[1232]
800036f4:	91 09       	st.w	r8[0x0],r9
800036f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800036fa:	fe f8 04 de 	ld.w	r8,pc[1246]
800036fe:	70 0a       	ld.w	r10,r8[0x0]
80003700:	fe f9 04 bc 	ld.w	r9,pc[1212]
80003704:	72 09       	ld.w	r9,r9[0x0]
80003706:	8e 4b       	ld.sh	r11,r7[0x8]
80003708:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
8000370c:	70 09       	ld.w	r9,r8[0x0]
8000370e:	2f f9       	sub	r9,-1
80003710:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003712:	e0 49 00 ff 	cp.w	r9,255
80003716:	e0 88 00 16 	brls	80003742 <phy_rx_func+0x53e>
					{
							RxMedia_IsFillingNext16 = 0;
8000371a:	30 09       	mov	r9,0
8000371c:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
8000371e:	fe f6 04 9e 	ld.w	r6,pc[1182]
80003722:	6c 0c       	ld.w	r12,r6[0x0]
80003724:	f0 1f 01 2e 	mcall	80003bdc <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
80003728:	fe f8 04 90 	ld.w	r8,pc[1168]
8000372c:	70 0c       	ld.w	r12,r8[0x0]
8000372e:	f0 1f 01 1d 	mcall	80003ba0 <phy_rx_func+0x99c>
80003732:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == payload_ptr)
80003734:	c0 71       	brne	80003742 <phy_rx_func+0x53e>
							{
								RxMediaState = WAITINGABAB;
80003736:	30 09       	mov	r9,0
80003738:	fe f8 04 88 	ld.w	r8,pc[1160]
8000373c:	91 09       	st.w	r8[0x0],r9
8000373e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
					}
				if ((RxBytesWaiting -= 2) <= 0)
80003742:	fe f9 04 86 	ld.w	r9,pc[1158]
80003746:	72 08       	ld.w	r8,r9[0x0]
80003748:	20 28       	sub	r8,2
8000374a:	93 08       	st.w	r9[0x0],r8
8000374c:	c0 71       	brne	8000375a <phy_rx_func+0x556>
				{
					RxMediaState = WAITINGABAB;
8000374e:	30 09       	mov	r9,0
80003750:	fe f8 04 70 	ld.w	r8,pc[1136]
80003754:	91 09       	st.w	r8[0x0],r9
80003756:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
8000375a:	fe f8 04 7e 	ld.w	r8,pc[1150]
8000375e:	70 0a       	ld.w	r10,r8[0x0]
80003760:	fe f9 04 5c 	ld.w	r9,pc[1116]
80003764:	72 09       	ld.w	r9,r9[0x0]
80003766:	8e 5b       	ld.sh	r11,r7[0xa]
80003768:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000376c:	70 09       	ld.w	r9,r8[0x0]
8000376e:	2f f9       	sub	r9,-1
80003770:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003772:	e0 49 00 ff 	cp.w	r9,255
80003776:	e0 88 00 16 	brls	800037a2 <phy_rx_func+0x59e>
						{
							RxMedia_IsFillingNext16 = 0;
8000377a:	30 09       	mov	r9,0
8000377c:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
8000377e:	fe f6 04 3e 	ld.w	r6,pc[1086]
80003782:	6c 0c       	ld.w	r12,r6[0x0]
80003784:	f0 1f 01 16 	mcall	80003bdc <phy_rx_func+0x9d8>
								payload_ptr = get_payload_idle_isr();
80003788:	fe f8 04 30 	ld.w	r8,pc[1072]
8000378c:	70 0c       	ld.w	r12,r8[0x0]
8000378e:	f0 1f 01 05 	mcall	80003ba0 <phy_rx_func+0x99c>
80003792:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
80003794:	c0 71       	brne	800037a2 <phy_rx_func+0x59e>
								{
									RxMediaState = WAITINGABAB;
80003796:	30 09       	mov	r9,0
80003798:	fe f8 04 28 	ld.w	r8,pc[1064]
8000379c:	91 09       	st.w	r8[0x0],r9
8000379e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
						}
				if ((RxBytesWaiting -= 2) <= 0){
800037a2:	fe f9 04 26 	ld.w	r9,pc[1062]
800037a6:	72 08       	ld.w	r8,r9[0x0]
800037a8:	20 28       	sub	r8,2
800037aa:	93 08       	st.w	r9[0x0],r8
800037ac:	c0 71       	brne	800037ba <phy_rx_func+0x5b6>
					RxMediaState = WAITINGABAB;
800037ae:	30 09       	mov	r9,0
800037b0:	fe f8 04 10 	ld.w	r8,pc[1040]
800037b4:	91 09       	st.w	r8[0x0],r9
800037b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
800037ba:	fe f8 04 1e 	ld.w	r8,pc[1054]
800037be:	70 0a       	ld.w	r10,r8[0x0]
800037c0:	fe f9 03 fc 	ld.w	r9,pc[1020]
800037c4:	72 09       	ld.w	r9,r9[0x0]
800037c6:	8e 6b       	ld.sh	r11,r7[0xc]
800037c8:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800037cc:	70 09       	ld.w	r9,r8[0x0]
800037ce:	2f f9       	sub	r9,-1
800037d0:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800037d2:	e0 49 00 ff 	cp.w	r9,255
800037d6:	e0 88 00 16 	brls	80003802 <phy_rx_func+0x5fe>
						{
							RxMedia_IsFillingNext16 = 0;
800037da:	30 09       	mov	r9,0
800037dc:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800037de:	fe f6 03 de 	ld.w	r6,pc[990]
800037e2:	6c 0c       	ld.w	r12,r6[0x0]
800037e4:	f0 1f 00 fe 	mcall	80003bdc <phy_rx_func+0x9d8>
									payload_ptr = get_payload_idle_isr();
800037e8:	fe f8 03 d0 	ld.w	r8,pc[976]
800037ec:	70 0c       	ld.w	r12,r8[0x0]
800037ee:	f0 1f 00 ed 	mcall	80003ba0 <phy_rx_func+0x99c>
800037f2:	8d 0c       	st.w	r6[0x0],r12
									if(NULL == payload_ptr)
800037f4:	c0 71       	brne	80003802 <phy_rx_func+0x5fe>
									{
										RxMediaState = WAITINGABAB;
800037f6:	30 09       	mov	r9,0
800037f8:	fe f8 03 c8 	ld.w	r8,pc[968]
800037fc:	91 09       	st.w	r8[0x0],r9
800037fe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80003802:	fe f9 03 c6 	ld.w	r9,pc[966]
80003806:	72 08       	ld.w	r8,r9[0x0]
80003808:	20 28       	sub	r8,2
8000380a:	93 08       	st.w	r9[0x0],r8
8000380c:	c0 71       	brne	8000381a <phy_rx_func+0x616>
					RxMediaState = WAITINGABAB;
8000380e:	30 09       	mov	r9,0
80003810:	fe f8 03 b0 	ld.w	r8,pc[944]
80003814:	91 09       	st.w	r8[0x0],r9
80003816:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
8000381a:	fe f8 03 be 	ld.w	r8,pc[958]
8000381e:	70 0a       	ld.w	r10,r8[0x0]
80003820:	fe f9 03 9c 	ld.w	r9,pc[924]
80003824:	72 09       	ld.w	r9,r9[0x0]
80003826:	8e 7b       	ld.sh	r11,r7[0xe]
80003828:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000382c:	70 09       	ld.w	r9,r8[0x0]
8000382e:	2f f9       	sub	r9,-1
80003830:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003832:	e0 49 00 ff 	cp.w	r9,255
80003836:	e0 88 00 16 	brls	80003862 <phy_rx_func+0x65e>
						{
							RxMedia_IsFillingNext16 = 0;
8000383a:	30 09       	mov	r9,0
8000383c:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
8000383e:	fe f7 03 7e 	ld.w	r7,pc[894]
80003842:	6e 0c       	ld.w	r12,r7[0x0]
80003844:	f0 1f 00 e6 	mcall	80003bdc <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
80003848:	fe f8 03 70 	ld.w	r8,pc[880]
8000384c:	70 0c       	ld.w	r12,r8[0x0]
8000384e:	f0 1f 00 d5 	mcall	80003ba0 <phy_rx_func+0x99c>
80003852:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
80003854:	c0 71       	brne	80003862 <phy_rx_func+0x65e>
							{
								RxMediaState = WAITINGABAB;
80003856:	30 09       	mov	r9,0
80003858:	fe f8 03 68 	ld.w	r8,pc[872]
8000385c:	91 09       	st.w	r8[0x0],r9
8000385e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80003862:	fe f9 03 66 	ld.w	r9,pc[870]
80003866:	72 08       	ld.w	r8,r9[0x0]
80003868:	20 28       	sub	r8,2
8000386a:	93 08       	st.w	r9[0x0],r8
8000386c:	e0 81 01 8b 	brne	80003b82 <phy_rx_func+0x97e>
					RxMediaState = WAITINGABAB;
80003870:	30 09       	mov	r9,0
80003872:	fe f8 03 4e 	ld.w	r8,pc[846]
80003876:	91 09       	st.w	r8[0x0],r9
80003878:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			}
			break; //End of READINGMEDIA.

		case READING_AMBE_MEDIA:
			
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
8000387c:	fe f8 03 54 	ld.w	r8,pc[852]
80003880:	11 89       	ld.ub	r9,r8[0x0]
80003882:	31 28       	mov	r8,18
80003884:	f0 09 18 00 	cp.b	r9,r8
80003888:	e0 81 00 b0 	brne	800039e8 <phy_rx_func+0x7e4>
					{
						Item_ID = payload_rx_channel->byte[1];
8000388c:	ef 39 00 09 	ld.ub	r9,r7[9]
80003890:	fe f8 03 40 	ld.w	r8,pc[832]
80003894:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)
80003896:	11 89       	ld.ub	r9,r8[0x0]
80003898:	3f 28       	mov	r8,-14
8000389a:	f0 09 18 00 	cp.b	r9,r8
8000389e:	e0 81 00 a0 	brne	800039de <phy_rx_func+0x7da>
						{
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
800038a2:	6e 29       	ld.w	r9,r7[0x8]
800038a4:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
800038a8:	fe f8 03 20 	ld.w	r8,pc[800]
800038ac:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
800038ae:	8e 59       	ld.sh	r9,r7[0xa]
800038b0:	fe f8 03 50 	ld.w	r8,pc[848]
800038b4:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
800038b6:	8e 69       	ld.sh	r9,r7[0xc]
800038b8:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
800038ba:	8e 79       	ld.sh	r9,r7[0xe]
800038bc:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800038be:	fe f8 03 1a 	ld.w	r8,pc[794]
800038c2:	70 0a       	ld.w	r10,r8[0x0]
800038c4:	fe f9 02 f8 	ld.w	r9,pc[760]
800038c8:	72 09       	ld.w	r9,r9[0x0]
800038ca:	8e 5b       	ld.sh	r11,r7[0xa]
800038cc:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800038d0:	70 09       	ld.w	r9,r8[0x0]
800038d2:	2f f9       	sub	r9,-1
800038d4:	91 09       	st.w	r8[0x0],r9
							
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800038d6:	e0 49 00 ff 	cp.w	r9,255
800038da:	e0 88 00 16 	brls	80003906 <phy_rx_func+0x702>
							{
								RxMedia_IsFillingNext16 = 0;
800038de:	30 09       	mov	r9,0
800038e0:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800038e2:	fe f6 02 da 	ld.w	r6,pc[730]
800038e6:	6c 0c       	ld.w	r12,r6[0x0]
800038e8:	f0 1f 00 bd 	mcall	80003bdc <phy_rx_func+0x9d8>
								payload_ptr = get_payload_idle_isr();
800038ec:	fe f8 02 cc 	ld.w	r8,pc[716]
800038f0:	70 0c       	ld.w	r12,r8[0x0]
800038f2:	f0 1f 00 ac 	mcall	80003ba0 <phy_rx_func+0x99c>
800038f6:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
800038f8:	c0 71       	brne	80003906 <phy_rx_func+0x702>
								{
									RxMediaState = WAITINGABAB;
800038fa:	30 09       	mov	r9,0
800038fc:	fe f8 02 c4 	ld.w	r8,pc[708]
80003900:	91 09       	st.w	r8[0x0],r9
80003902:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 2) <= 0){
80003906:	fe f9 02 c2 	ld.w	r9,pc[706]
8000390a:	72 08       	ld.w	r8,r9[0x0]
8000390c:	20 28       	sub	r8,2
8000390e:	93 08       	st.w	r9[0x0],r8
80003910:	c0 71       	brne	8000391e <phy_rx_func+0x71a>
								RxMediaState = WAITINGABAB;
80003912:	30 09       	mov	r9,0
80003914:	fe f8 02 ac 	ld.w	r8,pc[684]
80003918:	91 09       	st.w	r8[0x0],r9
8000391a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
8000391e:	fe f8 02 ba 	ld.w	r8,pc[698]
80003922:	70 0a       	ld.w	r10,r8[0x0]
80003924:	fe f9 02 98 	ld.w	r9,pc[664]
80003928:	72 09       	ld.w	r9,r9[0x0]
8000392a:	8e 6b       	ld.sh	r11,r7[0xc]
8000392c:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80003930:	70 09       	ld.w	r9,r8[0x0]
80003932:	2f f9       	sub	r9,-1
80003934:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003936:	e0 49 00 ff 	cp.w	r9,255
8000393a:	e0 88 00 16 	brls	80003966 <phy_rx_func+0x762>
							{
								RxMedia_IsFillingNext16 = 0;
8000393e:	30 09       	mov	r9,0
80003940:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80003942:	fe f6 02 7a 	ld.w	r6,pc[634]
80003946:	6c 0c       	ld.w	r12,r6[0x0]
80003948:	f0 1f 00 a5 	mcall	80003bdc <phy_rx_func+0x9d8>
								payload_ptr = get_payload_idle_isr();
8000394c:	fe f8 02 6c 	ld.w	r8,pc[620]
80003950:	70 0c       	ld.w	r12,r8[0x0]
80003952:	f0 1f 00 94 	mcall	80003ba0 <phy_rx_func+0x99c>
80003956:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
80003958:	c0 71       	brne	80003966 <phy_rx_func+0x762>
								{
									RxMediaState = WAITINGABAB;
8000395a:	30 09       	mov	r9,0
8000395c:	fe f8 02 64 	ld.w	r8,pc[612]
80003960:	91 09       	st.w	r8[0x0],r9
80003962:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 2) <= 0){
80003966:	fe f9 02 62 	ld.w	r9,pc[610]
8000396a:	72 08       	ld.w	r8,r9[0x0]
8000396c:	20 28       	sub	r8,2
8000396e:	93 08       	st.w	r9[0x0],r8
80003970:	c0 71       	brne	8000397e <phy_rx_func+0x77a>
								RxMediaState = WAITINGABAB;
80003972:	30 09       	mov	r9,0
80003974:	fe f8 02 4c 	ld.w	r8,pc[588]
80003978:	91 09       	st.w	r8[0x0],r9
8000397a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
8000397e:	fe f8 02 5a 	ld.w	r8,pc[602]
80003982:	70 0a       	ld.w	r10,r8[0x0]
80003984:	fe f9 02 38 	ld.w	r9,pc[568]
80003988:	72 09       	ld.w	r9,r9[0x0]
8000398a:	8e 7b       	ld.sh	r11,r7[0xe]
8000398c:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80003990:	70 09       	ld.w	r9,r8[0x0]
80003992:	2f f9       	sub	r9,-1
80003994:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003996:	e0 49 00 ff 	cp.w	r9,255
8000399a:	e0 88 00 16 	brls	800039c6 <phy_rx_func+0x7c2>
							{
								RxMedia_IsFillingNext16 = 0;
8000399e:	30 09       	mov	r9,0
800039a0:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800039a2:	fe f7 02 1a 	ld.w	r7,pc[538]
800039a6:	6e 0c       	ld.w	r12,r7[0x0]
800039a8:	f0 1f 00 8d 	mcall	80003bdc <phy_rx_func+0x9d8>
								payload_ptr = get_payload_idle_isr();
800039ac:	fe f8 02 0c 	ld.w	r8,pc[524]
800039b0:	70 0c       	ld.w	r12,r8[0x0]
800039b2:	f0 1f 00 7c 	mcall	80003ba0 <phy_rx_func+0x99c>
800039b6:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr)
800039b8:	c0 71       	brne	800039c6 <phy_rx_func+0x7c2>
								{
									RxMediaState = WAITINGABAB;
800039ba:	30 09       	mov	r9,0
800039bc:	fe f8 02 04 	ld.w	r8,pc[516]
800039c0:	91 09       	st.w	r8[0x0],r9
800039c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 2) <= 0){
800039c6:	fe f9 02 02 	ld.w	r9,pc[514]
800039ca:	72 08       	ld.w	r8,r9[0x0]
800039cc:	20 28       	sub	r8,2
800039ce:	93 08       	st.w	r9[0x0],r8
800039d0:	e0 81 00 d9 	brne	80003b82 <phy_rx_func+0x97e>
								RxMediaState = WAITINGABAB;
800039d4:	30 09       	mov	r9,0
800039d6:	4f b8       	lddpc	r8,80003bc0 <phy_rx_func+0x9bc>
800039d8:	91 09       	st.w	r8[0x0],r9
800039da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
800039de:	30 09       	mov	r9,0
800039e0:	4f 88       	lddpc	r8,80003bc0 <phy_rx_func+0x9bc>
800039e2:	91 09       	st.w	r8[0x0],r9
800039e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800039e8:	4f a8       	lddpc	r8,80003bd0 <phy_rx_func+0x9cc>
800039ea:	11 89       	ld.ub	r9,r8[0x0]
800039ec:	3f 28       	mov	r8,-14
800039ee:	f0 09 18 00 	cp.b	r9,r8
800039f2:	e0 81 00 aa 	brne	80003b46 <phy_rx_func+0x942>
					{
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800039f6:	8e 49       	ld.sh	r9,r7[0x8]
800039f8:	fe f8 02 08 	ld.w	r8,pc[520]
800039fc:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800039fe:	4f 78       	lddpc	r8,80003bd8 <phy_rx_func+0x9d4>
80003a00:	70 0a       	ld.w	r10,r8[0x0]
80003a02:	4e f9       	lddpc	r9,80003bbc <phy_rx_func+0x9b8>
80003a04:	72 09       	ld.w	r9,r9[0x0]
80003a06:	8e 4b       	ld.sh	r11,r7[0x8]
80003a08:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
80003a0c:	70 09       	ld.w	r9,r8[0x0]
80003a0e:	2f f9       	sub	r9,-1
80003a10:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003a12:	e0 49 00 ff 	cp.w	r9,255
80003a16:	e0 88 00 13 	brls	80003a3c <phy_rx_func+0x838>
						{
							RxMedia_IsFillingNext16 = 0;
80003a1a:	30 09       	mov	r9,0
80003a1c:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80003a1e:	4e 86       	lddpc	r6,80003bbc <phy_rx_func+0x9b8>
80003a20:	6c 0c       	ld.w	r12,r6[0x0]
80003a22:	f0 1f 00 6f 	mcall	80003bdc <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
80003a26:	4e 58       	lddpc	r8,80003bb8 <phy_rx_func+0x9b4>
80003a28:	70 0c       	ld.w	r12,r8[0x0]
80003a2a:	f0 1f 00 5e 	mcall	80003ba0 <phy_rx_func+0x99c>
80003a2e:	8d 0c       	st.w	r6[0x0],r12
							
							if(NULL == payload_ptr){
80003a30:	c0 61       	brne	80003a3c <phy_rx_func+0x838>
								RxMediaState = WAITINGABAB;
80003a32:	30 09       	mov	r9,0
80003a34:	4e 38       	lddpc	r8,80003bc0 <phy_rx_func+0x9bc>
80003a36:	91 09       	st.w	r8[0x0],r9
80003a38:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				
						if ((RxBytesWaiting -= 2) <= 0)
80003a3c:	4e 39       	lddpc	r9,80003bc8 <phy_rx_func+0x9c4>
80003a3e:	72 08       	ld.w	r8,r9[0x0]
80003a40:	20 28       	sub	r8,2
80003a42:	93 08       	st.w	r9[0x0],r8
80003a44:	c0 61       	brne	80003a50 <phy_rx_func+0x84c>
						{
							RxMediaState = WAITINGABAB;
80003a46:	30 09       	mov	r9,0
80003a48:	4d e8       	lddpc	r8,80003bc0 <phy_rx_func+0x9bc>
80003a4a:	91 09       	st.w	r8[0x0],r9
80003a4c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						}
						
						/******************************
						*******************/
						//(49bits)This shouldn't happen, but must check.
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003a50:	4e 28       	lddpc	r8,80003bd8 <phy_rx_func+0x9d4>
80003a52:	70 0a       	ld.w	r10,r8[0x0]
80003a54:	4d a9       	lddpc	r9,80003bbc <phy_rx_func+0x9b8>
80003a56:	72 09       	ld.w	r9,r9[0x0]
80003a58:	8e 5b       	ld.sh	r11,r7[0xa]
80003a5a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
80003a5e:	70 09       	ld.w	r9,r8[0x0]
80003a60:	2f f9       	sub	r9,-1
80003a62:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003a64:	e0 49 00 ff 	cp.w	r9,255
80003a68:	e0 88 00 13 	brls	80003a8e <phy_rx_func+0x88a>
						{
							RxMedia_IsFillingNext16 = 0;
80003a6c:	30 09       	mov	r9,0
80003a6e:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80003a70:	4d 36       	lddpc	r6,80003bbc <phy_rx_func+0x9b8>
80003a72:	6c 0c       	ld.w	r12,r6[0x0]
80003a74:	f0 1f 00 5a 	mcall	80003bdc <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
80003a78:	4d 08       	lddpc	r8,80003bb8 <phy_rx_func+0x9b4>
80003a7a:	70 0c       	ld.w	r12,r8[0x0]
80003a7c:	f0 1f 00 49 	mcall	80003ba0 <phy_rx_func+0x99c>
80003a80:	8d 0c       	st.w	r6[0x0],r12
							
							if(NULL == payload_ptr){
80003a82:	c0 61       	brne	80003a8e <phy_rx_func+0x88a>
								RxMediaState = WAITINGABAB;
80003a84:	30 09       	mov	r9,0
80003a86:	4c f8       	lddpc	r8,80003bc0 <phy_rx_func+0x9bc>
80003a88:	91 09       	st.w	r8[0x0],r9
80003a8a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 2) <= 0){
80003a8e:	4c f9       	lddpc	r9,80003bc8 <phy_rx_func+0x9c4>
80003a90:	72 08       	ld.w	r8,r9[0x0]
80003a92:	20 28       	sub	r8,2
80003a94:	93 08       	st.w	r9[0x0],r8
80003a96:	c0 61       	brne	80003aa2 <phy_rx_func+0x89e>
							RxMediaState = WAITINGABAB;
80003a98:	30 09       	mov	r9,0
80003a9a:	4c a8       	lddpc	r8,80003bc0 <phy_rx_func+0x9bc>
80003a9c:	91 09       	st.w	r8[0x0],r9
80003a9e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}

						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003aa2:	4c e8       	lddpc	r8,80003bd8 <phy_rx_func+0x9d4>
80003aa4:	70 0a       	ld.w	r10,r8[0x0]
80003aa6:	4c 69       	lddpc	r9,80003bbc <phy_rx_func+0x9b8>
80003aa8:	72 09       	ld.w	r9,r9[0x0]
80003aaa:	8e 6b       	ld.sh	r11,r7[0xc]
80003aac:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;							
80003ab0:	70 09       	ld.w	r9,r8[0x0]
80003ab2:	2f f9       	sub	r9,-1
80003ab4:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003ab6:	e0 49 00 ff 	cp.w	r9,255
80003aba:	e0 88 00 13 	brls	80003ae0 <phy_rx_func+0x8dc>
						{
							RxMedia_IsFillingNext16 = 0;
80003abe:	30 09       	mov	r9,0
80003ac0:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80003ac2:	4b f6       	lddpc	r6,80003bbc <phy_rx_func+0x9b8>
80003ac4:	6c 0c       	ld.w	r12,r6[0x0]
80003ac6:	f0 1f 00 46 	mcall	80003bdc <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
80003aca:	4b c8       	lddpc	r8,80003bb8 <phy_rx_func+0x9b4>
80003acc:	70 0c       	ld.w	r12,r8[0x0]
80003ace:	f0 1f 00 35 	mcall	80003ba0 <phy_rx_func+0x99c>
80003ad2:	8d 0c       	st.w	r6[0x0],r12
							
							if(NULL == payload_ptr){
80003ad4:	c0 61       	brne	80003ae0 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80003ad6:	30 09       	mov	r9,0
80003ad8:	4b a8       	lddpc	r8,80003bc0 <phy_rx_func+0x9bc>
80003ada:	91 09       	st.w	r8[0x0],r9
80003adc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 2) <= 0){
80003ae0:	4b a9       	lddpc	r9,80003bc8 <phy_rx_func+0x9c4>
80003ae2:	72 08       	ld.w	r8,r9[0x0]
80003ae4:	20 28       	sub	r8,2
80003ae6:	93 08       	st.w	r9[0x0],r8
80003ae8:	c0 61       	brne	80003af4 <phy_rx_func+0x8f0>
							RxMediaState = WAITINGABAB;
80003aea:	30 09       	mov	r9,0
80003aec:	4b 58       	lddpc	r8,80003bc0 <phy_rx_func+0x9bc>
80003aee:	91 09       	st.w	r8[0x0],r9
80003af0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
							
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003af4:	4b 98       	lddpc	r8,80003bd8 <phy_rx_func+0x9d4>
80003af6:	70 0a       	ld.w	r10,r8[0x0]
80003af8:	4b 19       	lddpc	r9,80003bbc <phy_rx_func+0x9b8>
80003afa:	72 09       	ld.w	r9,r9[0x0]
80003afc:	8e 7b       	ld.sh	r11,r7[0xe]
80003afe:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
80003b02:	70 09       	ld.w	r9,r8[0x0]
80003b04:	2f f9       	sub	r9,-1
80003b06:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003b08:	e0 49 00 ff 	cp.w	r9,255
80003b0c:	e0 88 00 13 	brls	80003b32 <phy_rx_func+0x92e>
						{
							RxMedia_IsFillingNext16 = 0;
80003b10:	30 09       	mov	r9,0
80003b12:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80003b14:	4a a7       	lddpc	r7,80003bbc <phy_rx_func+0x9b8>
80003b16:	6e 0c       	ld.w	r12,r7[0x0]
80003b18:	f0 1f 00 31 	mcall	80003bdc <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
80003b1c:	4a 78       	lddpc	r8,80003bb8 <phy_rx_func+0x9b4>
80003b1e:	70 0c       	ld.w	r12,r8[0x0]
80003b20:	f0 1f 00 20 	mcall	80003ba0 <phy_rx_func+0x99c>
80003b24:	8f 0c       	st.w	r7[0x0],r12
							
							if(NULL == payload_ptr){
80003b26:	c0 61       	brne	80003b32 <phy_rx_func+0x92e>
								RxMediaState = WAITINGABAB;
80003b28:	30 09       	mov	r9,0
80003b2a:	4a 68       	lddpc	r8,80003bc0 <phy_rx_func+0x9bc>
80003b2c:	91 09       	st.w	r8[0x0],r9
80003b2e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 2) <= 0){
80003b32:	4a 69       	lddpc	r9,80003bc8 <phy_rx_func+0x9c4>
80003b34:	72 08       	ld.w	r8,r9[0x0]
80003b36:	20 28       	sub	r8,2
80003b38:	93 08       	st.w	r9[0x0],r8
80003b3a:	c2 41       	brne	80003b82 <phy_rx_func+0x97e>
							RxMediaState = WAITINGABAB;
80003b3c:	30 09       	mov	r9,0
80003b3e:	4a 18       	lddpc	r8,80003bc0 <phy_rx_func+0x9bc>
80003b40:	91 09       	st.w	r8[0x0],r9
80003b42:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						*******************/
						
								
					}
					
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003b46:	4a 38       	lddpc	r8,80003bd0 <phy_rx_func+0x9cc>
80003b48:	11 89       	ld.ub	r9,r8[0x0]
80003b4a:	30 48       	mov	r8,4
80003b4c:	f0 09 18 00 	cp.b	r9,r8
80003b50:	c0 70       	breq	80003b5e <phy_rx_func+0x95a>
80003b52:	4a 08       	lddpc	r8,80003bd0 <phy_rx_func+0x9cc>
80003b54:	11 89       	ld.ub	r9,r8[0x0]
80003b56:	30 38       	mov	r8,3
80003b58:	f0 09 18 00 	cp.b	r9,r8
80003b5c:	c1 01       	brne	80003b7c <phy_rx_func+0x978>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003b5e:	6e 29       	ld.w	r9,r7[0x8]
80003b60:	4a 28       	lddpc	r8,80003be8 <phy_rx_func+0x9e4>
80003b62:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003b64:	6e 39       	ld.w	r9,r7[0xc]
80003b66:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003b68:	49 89       	lddpc	r9,80003bc8 <phy_rx_func+0x9c4>
80003b6a:	72 08       	ld.w	r8,r9[0x0]
80003b6c:	20 88       	sub	r8,8
80003b6e:	93 08       	st.w	r9[0x0],r8
80003b70:	c0 91       	brne	80003b82 <phy_rx_func+0x97e>
						{
					
							RxBytesWaiting = 0;
80003b72:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003b74:	49 39       	lddpc	r9,80003bc0 <phy_rx_func+0x9bc>
80003b76:	93 08       	st.w	r9[0x0],r8
80003b78:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					//}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003b7c:	30 09       	mov	r9,0
80003b7e:	49 18       	lddpc	r8,80003bc0 <phy_rx_func+0x9bc>
80003b80:	91 09       	st.w	r8[0x0],r9
80003b82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003b86:	00 00       	add	r0,r0
80003b88:	00 00       	add	r0,r0
80003b8a:	0a ac       	st.w	r5++,r12
80003b8c:	00 00       	add	r0,r0
80003b8e:	0a c8       	st.b	r5++,r8
80003b90:	00 00       	add	r0,r0
80003b92:	0a 94       	mov	r4,r5
80003b94:	00 00       	add	r0,r0
80003b96:	0a 7c       	tst	r12,r5
80003b98:	00 00       	add	r0,r0
80003b9a:	0a 76       	tst	r6,r5
80003b9c:	00 00       	add	r0,r0
80003b9e:	0a 90       	mov	r0,r5
80003ba0:	80 00       	ld.sh	r0,r0[0x0]
80003ba2:	2a dc       	sub	r12,-83
80003ba4:	00 00       	add	r0,r0
80003ba6:	0a cc       	st.b	r5++,r12
80003ba8:	80 00       	ld.sh	r0,r0[0x0]
80003baa:	4f 7c       	lddpc	r12,80003d84 <ssc_init+0x48>
80003bac:	00 00       	add	r0,r0
80003bae:	0a a8       	st.w	r5++,r8
80003bb0:	80 00       	ld.sh	r0,r0[0x0]
80003bb2:	2a 28       	sub	r8,-94
80003bb4:	00 00       	add	r0,r0
80003bb6:	0a 75       	tst	r5,r5
80003bb8:	00 00       	add	r0,r0
80003bba:	0a 80       	andn	r0,r5
80003bbc:	00 00       	add	r0,r0
80003bbe:	0a 9c       	mov	r12,r5
80003bc0:	00 00       	add	r0,r0
80003bc2:	0a bc       	st.h	r5++,r12
80003bc4:	00 00       	add	r0,r0
80003bc6:	0a 68       	and	r8,r5
80003bc8:	00 00       	add	r0,r0
80003bca:	0a 64       	and	r4,r5
80003bcc:	00 00       	add	r0,r0
80003bce:	0a 3c       	cp.w	r12,r5
80003bd0:	00 00       	add	r0,r0
80003bd2:	0a 74       	tst	r4,r5
80003bd4:	00 00       	add	r0,r0
80003bd6:	0a 44       	or	r4,r5
80003bd8:	00 00       	add	r0,r0
80003bda:	0a b0       	st.h	r5++,r0
80003bdc:	80 00       	ld.sh	r0,r0[0x0]
80003bde:	31 a4       	mov	r4,26
80003be0:	00 00       	add	r0,r0
80003be2:	0e 74       	tst	r4,r7
80003be4:	80 00       	ld.sh	r0,r0[0x0]
80003be6:	29 6c       	sub	r12,-106
80003be8:	00 00       	add	r0,r0
80003bea:	0a 88       	andn	r8,r5
80003bec:	80 01       	ld.sh	r1,r0[0x0]
80003bee:	4b e8       	lddpc	r8,80003ce4 <local_start_PDC+0x28>
80003bf0:	80 00       	ld.sh	r0,r0[0x0]
80003bf2:	60 1c       	ld.w	r12,r0[0x4]
80003bf4:	80 01       	ld.sh	r1,r0[0x0]
80003bf6:	4b fc       	lddpc	r12,80003cf0 <local_start_PDC+0x34>
80003bf8:	00 00       	add	r0,r0
80003bfa:	0a b8       	st.h	r5++,r8
80003bfc:	00 00       	add	r0,r0
80003bfe:	0a 4d       	or	sp,r5
80003c00:	00 00       	add	r0,r0
80003c02:	0d 7c       	ld.ub	r12,--r6

80003c04 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003c04:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003c06:	49 88       	lddpc	r8,80003c64 <pdca_int_handler+0x60>
80003c08:	11 89       	ld.ub	r9,r8[0x0]
80003c0a:	ec 19 00 01 	eorl	r9,0x1
80003c0e:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003c10:	11 89       	ld.ub	r9,r8[0x0]
80003c12:	a5 69       	lsl	r9,0x4
80003c14:	2f c9       	sub	r9,-4
80003c16:	49 5a       	lddpc	r10,80003c68 <pdca_int_handler+0x64>
80003c18:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003c1a:	fe 7a 00 40 	mov	r10,-65472
80003c1e:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003c20:	30 39       	mov	r9,3
80003c22:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003c24:	11 8a       	ld.ub	r10,r8[0x0]
80003c26:	a5 6a       	lsl	r10,0x4
80003c28:	2f ca       	sub	r10,-4
80003c2a:	49 18       	lddpc	r8,80003c6c <pdca_int_handler+0x68>
80003c2c:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003c2e:	fe 78 00 00 	mov	r8,-65536
80003c32:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003c34:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003c36:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003c38:	48 e8       	lddpc	r8,80003c70 <pdca_int_handler+0x6c>
80003c3a:	70 08       	ld.w	r8,r8[0x0]
80003c3c:	58 08       	cp.w	r8,0
80003c3e:	c0 70       	breq	80003c4c <pdca_int_handler+0x48>
80003c40:	48 99       	lddpc	r9,80003c64 <pdca_int_handler+0x60>
80003c42:	13 89       	ld.ub	r9,r9[0x0]
80003c44:	a5 69       	lsl	r9,0x4
80003c46:	48 ac       	lddpc	r12,80003c6c <pdca_int_handler+0x68>
80003c48:	12 0c       	add	r12,r9
80003c4a:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003c4c:	48 a8       	lddpc	r8,80003c74 <pdca_int_handler+0x70>
80003c4e:	70 08       	ld.w	r8,r8[0x0]
80003c50:	58 08       	cp.w	r8,0
80003c52:	c0 70       	breq	80003c60 <pdca_int_handler+0x5c>
80003c54:	48 49       	lddpc	r9,80003c64 <pdca_int_handler+0x60>
80003c56:	13 89       	ld.ub	r9,r9[0x0]
80003c58:	a5 69       	lsl	r9,0x4
80003c5a:	48 4c       	lddpc	r12,80003c68 <pdca_int_handler+0x64>
80003c5c:	12 0c       	add	r12,r9
80003c5e:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003c60:	d4 02       	popm	lr
80003c62:	d6 03       	rete
80003c64:	00 00       	add	r0,r0
80003c66:	40 7c       	lddsp	r12,sp[0x1c]
80003c68:	00 00       	add	r0,r0
80003c6a:	40 a4       	lddsp	r4,sp[0x28]
80003c6c:	00 00       	add	r0,r0
80003c6e:	40 84       	lddsp	r4,sp[0x20]
80003c70:	00 00       	add	r0,r0
80003c72:	0a d8       	st.w	--r5,r8
80003c74:	00 00       	add	r0,r0
80003c76:	0a dc       	st.w	--r5,r12

80003c78 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003c78:	fe 78 10 00 	mov	r8,-61440
80003c7c:	e0 69 0d c0 	mov	r9,3520
80003c80:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003c84:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003c88:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003c8c:	fe 78 34 00 	mov	r8,-52224
80003c90:	e0 69 80 00 	mov	r9,32768
80003c94:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003c96:	30 09       	mov	r9,0
80003c98:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003c9a:	e0 69 04 21 	mov	r9,1057
80003c9e:	ea 19 3f 20 	orh	r9,0x3f20
80003ca2:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80003ca4:	e0 69 02 9f 	mov	r9,671
80003ca8:	ea 19 01 00 	orh	r9,0x100
80003cac:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80003cae:	e0 6a 04 02 	mov	r10,1026
80003cb2:	ea 1a 3f 20 	orh	r10,0x3f20
80003cb6:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80003cb8:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003cba:	5e fc       	retal	r12

80003cbc <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003cbc:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003cbe:	30 19       	mov	r9,1
80003cc0:	49 78       	lddpc	r8,80003d1c <local_start_PDC+0x60>
80003cc2:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003cc4:	fe 78 00 00 	mov	r8,-65536
80003cc8:	30 7b       	mov	r11,7
80003cca:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003ccc:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003cce:	49 59       	lddpc	r9,80003d20 <local_start_PDC+0x64>
80003cd0:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003cd4:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003cd6:	30 3a       	mov	r10,3
80003cd8:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003cda:	30 1c       	mov	r12,1
80003cdc:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003cde:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003ce0:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003ce2:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003ce4:	30 2c       	mov	r12,2
80003ce6:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003ce8:	48 f9       	lddpc	r9,80003d24 <local_start_PDC+0x68>
80003cea:	e0 68 5a 5a 	mov	r8,23130
80003cee:	ea 18 ab cd 	orh	r8,0xabcd
80003cf2:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003cf4:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003cf6:	30 0e       	mov	lr,0
80003cf8:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003cfa:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003cfc:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003cfe:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003d00:	fe 78 00 40 	mov	r8,-65472
80003d04:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003d06:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003d08:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003d0c:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003d0e:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003d10:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003d12:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003d14:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003d16:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003d18:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003d1a:	d8 02       	popm	pc
80003d1c:	00 00       	add	r0,r0
80003d1e:	40 7c       	lddsp	r12,sp[0x1c]
80003d20:	00 00       	add	r0,r0
80003d22:	40 84       	lddsp	r4,sp[0x20]
80003d24:	00 00       	add	r0,r0
80003d26:	40 a4       	lddsp	r4,sp[0x28]

80003d28 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003d28:	48 38       	lddpc	r8,80003d34 <register_rx_tx_func+0xc>
80003d2a:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003d2c:	48 38       	lddpc	r8,80003d38 <register_rx_tx_func+0x10>
80003d2e:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003d30:	5e fc       	retal	r12
80003d32:	00 00       	add	r0,r0
80003d34:	00 00       	add	r0,r0
80003d36:	0a d8       	st.w	--r5,r8
80003d38:	00 00       	add	r0,r0
80003d3a:	0a dc       	st.w	--r5,r12

80003d3c <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003d3c:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003d3e:	fe 78 10 00 	mov	r8,-61440
80003d42:	30 29       	mov	r9,2
80003d44:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003d48:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003d4c:	10 99       	mov	r9,r8
80003d4e:	f2 f8 01 60 	ld.w	r8,r9[352]
80003d52:	e2 18 00 02 	andl	r8,0x2,COH
80003d56:	cf c0       	breq	80003d4e <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003d58:	fe 79 10 00 	mov	r9,-61440
80003d5c:	f2 f8 01 60 	ld.w	r8,r9[352]
80003d60:	e2 18 00 02 	andl	r8,0x2,COH
80003d64:	cf c1       	brne	80003d5c <ssc_init+0x20>
				
    INTC_register_interrupt (
80003d66:	30 3a       	mov	r10,3
80003d68:	36 0b       	mov	r11,96
80003d6a:	48 bc       	lddpc	r12,80003d94 <ssc_init+0x58>
80003d6c:	f0 1f 00 0b 	mcall	80003d98 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80003d70:	f0 1f 00 0b 	mcall	80003d9c <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80003d74:	f0 1f 00 0b 	mcall	80003da0 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003d78:	fe 79 00 00 	mov	r9,-65536
80003d7c:	30 18       	mov	r8,1
80003d7e:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003d80:	fe 7a 00 40 	mov	r10,-65472
80003d84:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003d86:	e0 6b 01 01 	mov	r11,257
80003d8a:	fe 7a 34 00 	mov	r10,-52224
80003d8e:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80003d90:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80003d92:	d8 02       	popm	pc
80003d94:	80 00       	ld.sh	r0,r0[0x0]
80003d96:	3c 04       	mov	r4,-64
80003d98:	80 00       	ld.sh	r0,r0[0x0]
80003d9a:	47 04       	lddsp	r4,sp[0x1c0]
80003d9c:	80 00       	ld.sh	r0,r0[0x0]
80003d9e:	3c 78       	mov	r8,-57
80003da0:	80 00       	ld.sh	r0,r0[0x0]
80003da2:	3c bc       	mov	r12,-53

80003da4 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003da4:	48 28       	lddpc	r8,80003dac <xcmp_register_app_list+0x8>
80003da6:	91 0c       	st.w	r8[0x0],r12
}
80003da8:	5e fc       	retal	r12
80003daa:	00 00       	add	r0,r0
80003dac:	00 00       	add	r0,r0
80003dae:	40 c4       	lddsp	r4,sp[0x30]

80003db0 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003db0:	eb cd 40 80 	pushm	r7,lr
80003db4:	fa cd 01 00 	sub	sp,sp,256
80003db8:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003dba:	16 98       	mov	r8,r11
80003dbc:	2f 08       	sub	r8,-16
80003dbe:	af a8       	sbr	r8,0xe
80003dc0:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003dc2:	3f f8       	mov	r8,-1
80003dc4:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003dc6:	30 b9       	mov	r9,11
80003dc8:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003dca:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003dcc:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003dce:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003dd0:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003dd2:	f6 ca ff fe 	sub	r10,r11,-2
80003dd6:	18 9b       	mov	r11,r12
80003dd8:	fa cc ff f0 	sub	r12,sp,-16
80003ddc:	f0 1f 00 05 	mcall	80003df0 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003de0:	2f e7       	sub	r7,-2
80003de2:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003de4:	1a 9c       	mov	r12,sp
80003de6:	f0 1f 00 04 	mcall	80003df4 <xcmp_tx+0x44>
}
80003dea:	2c 0d       	sub	sp,-256
80003dec:	e3 cd 80 80 	ldm	sp++,r7,pc
80003df0:	80 00       	ld.sh	r0,r0[0x0]
80003df2:	67 e8       	ld.w	r8,r3[0x78]
80003df4:	80 00       	ld.sh	r0,r0[0x0]
80003df6:	42 00       	lddsp	r0,sp[0x80]

80003df8 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003df8:	d4 01       	pushm	lr
80003dfa:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003dfe:	fe 78 b4 00 	mov	r8,-19456
80003e02:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003e04:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003e08:	30 89       	mov	r9,8
80003e0a:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003e0c:	30 19       	mov	r9,1
80003e0e:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003e10:	30 09       	mov	r9,0
80003e12:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003e14:	30 5a       	mov	r10,5
80003e16:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003e18:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003e1a:	30 7a       	mov	r10,7
80003e1c:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003e1e:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003e20:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003e22:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003e26:	30 9b       	mov	r11,9
80003e28:	fa cc ff fe 	sub	r12,sp,-2
80003e2c:	f0 1f 00 02 	mcall	80003e34 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003e30:	2c dd       	sub	sp,-204
80003e32:	d8 02       	popm	pc
80003e34:	80 00       	ld.sh	r0,r0[0x0]
80003e36:	3d b0       	mov	r0,-37

80003e38 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003e38:	d4 01       	pushm	lr
80003e3a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003e3e:	fe 78 80 00 	mov	r8,-32768
80003e42:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003e44:	30 38       	mov	r8,3
80003e46:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003e48:	30 1b       	mov	r11,1
80003e4a:	fa cc ff fe 	sub	r12,sp,-2
80003e4e:	f0 1f 00 03 	mcall	80003e58 <xcmp_opcode_not_supported+0x20>
}
80003e52:	2c dd       	sub	sp,-204
80003e54:	d8 02       	popm	pc
80003e56:	00 00       	add	r0,r0
80003e58:	80 00       	ld.sh	r0,r0[0x0]
80003e5a:	3d b0       	mov	r0,-37

80003e5c <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003e5c:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003e5e:	96 88       	ld.uh	r8,r11[0x0]
80003e60:	e2 18 f0 00 	andl	r8,0xf000,COH
80003e64:	e0 48 80 00 	cp.w	r8,32768
80003e68:	c0 f0       	breq	80003e86 <xcmp_exec_func+0x2a>
80003e6a:	e0 48 b0 00 	cp.w	r8,45056
80003e6e:	c1 20       	breq	80003e92 <xcmp_exec_func+0x36>
80003e70:	58 08       	cp.w	r8,0
80003e72:	c1 51       	brne	80003e9c <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003e74:	78 08       	ld.w	r8,r12[0x0]
80003e76:	58 08       	cp.w	r8,0
80003e78:	c0 40       	breq	80003e80 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003e7a:	16 9c       	mov	r12,r11
80003e7c:	5d 18       	icall	r8
80003e7e:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80003e80:	f0 1f 00 08 	mcall	80003ea0 <xcmp_exec_func+0x44>
80003e84:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003e86:	78 18       	ld.w	r8,r12[0x4]
80003e88:	58 08       	cp.w	r8,0
80003e8a:	c0 90       	breq	80003e9c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003e8c:	16 9c       	mov	r12,r11
80003e8e:	5d 18       	icall	r8
80003e90:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003e92:	78 28       	ld.w	r8,r12[0x8]
80003e94:	58 08       	cp.w	r8,0
80003e96:	c0 30       	breq	80003e9c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003e98:	16 9c       	mov	r12,r11
80003e9a:	5d 18       	icall	r8
80003e9c:	d8 02       	popm	pc
80003e9e:	00 00       	add	r0,r0
80003ea0:	80 00       	ld.sh	r0,r0[0x0]
80003ea2:	3e 38       	mov	r8,-29

80003ea4 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80003ea4:	d4 01       	pushm	lr
80003ea6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003eaa:	e0 68 04 09 	mov	r8,1033
80003eae:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003eb0:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80003eb4:	30 19       	mov	r9,1
80003eb6:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
80003eb8:	30 09       	mov	r9,0
80003eba:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
80003ebc:	30 ca       	mov	r10,12
80003ebe:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003ec0:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003ec2:	fb 69 00 08 	st.b	sp[8],r9
80003ec6:	fa c8 ff f7 	sub	r8,sp,-9
80003eca:	b0 89       	st.b	r8[0x0],r9
80003ecc:	fa c8 ff f6 	sub	r8,sp,-10
80003ed0:	b0 89       	st.b	r8[0x0],r9
80003ed2:	fa c8 ff f5 	sub	r8,sp,-11
80003ed6:	b0 89       	st.b	r8[0x0],r9
80003ed8:	fa c8 ff f4 	sub	r8,sp,-12
80003edc:	b0 89       	st.b	r8[0x0],r9
80003ede:	fa c8 ff f3 	sub	r8,sp,-13
80003ee2:	b0 89       	st.b	r8[0x0],r9
80003ee4:	fa c8 ff f2 	sub	r8,sp,-14
80003ee8:	b0 89       	st.b	r8[0x0],r9
80003eea:	fa c8 ff f1 	sub	r8,sp,-15
80003eee:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003ef0:	30 cb       	mov	r11,12
80003ef2:	fa cc ff fe 	sub	r12,sp,-2
80003ef6:	f0 1f 00 03 	mcall	80003f00 <xcmp_IdleTestTone+0x5c>
}
80003efa:	2c dd       	sub	sp,-204
80003efc:	d8 02       	popm	pc
80003efe:	00 00       	add	r0,r0
80003f00:	80 00       	ld.sh	r0,r0[0x0]
80003f02:	3d b0       	mov	r0,-37

80003f04 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80003f04:	d4 01       	pushm	lr
	/*initialize the xnl*/
	//xnl_init();
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80003f06:	48 dc       	lddpc	r12,80003f38 <xcmp_init+0x34>
80003f08:	f0 1f 00 0d 	mcall	80003f3c <xcmp_init+0x38>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80003f0c:	30 4b       	mov	r11,4
80003f0e:	31 4c       	mov	r12,20
80003f10:	f0 1f 00 0c 	mcall	80003f40 <xcmp_init+0x3c>
80003f14:	48 c8       	lddpc	r8,80003f44 <xcmp_init+0x40>
80003f16:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80003f18:	30 09       	mov	r9,0
80003f1a:	1a d9       	st.w	--sp,r9
80003f1c:	1a d9       	st.w	--sp,r9
80003f1e:	1a d9       	st.w	--sp,r9
80003f20:	30 28       	mov	r8,2
80003f22:	e0 6a 01 80 	mov	r10,384
80003f26:	48 9b       	lddpc	r11,80003f48 <xcmp_init+0x44>
80003f28:	48 9c       	lddpc	r12,80003f4c <xcmp_init+0x48>
80003f2a:	f0 1f 00 0a 	mcall	80003f50 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	
	xnl_init();
80003f2e:	f0 1f 00 0a 	mcall	80003f54 <xcmp_init+0x50>
80003f32:	2f dd       	sub	sp,-12
	
}
80003f34:	d8 02       	popm	pc
80003f36:	00 00       	add	r0,r0
80003f38:	80 00       	ld.sh	r0,r0[0x0]
80003f3a:	40 54       	lddsp	r4,sp[0x14]
80003f3c:	80 00       	ld.sh	r0,r0[0x0]
80003f3e:	40 a0       	lddsp	r0,sp[0x28]
80003f40:	80 00       	ld.sh	r0,r0[0x0]
80003f42:	53 f8       	stdsp	sp[0xfc],r8
80003f44:	00 00       	add	r0,r0
80003f46:	0a ec       	st.h	--r5,r12
80003f48:	80 01       	ld.sh	r1,r0[0x0]
80003f4a:	4c 08       	lddpc	r8,80004048 <xcmp_rx_process+0xf0>
80003f4c:	80 00       	ld.sh	r0,r0[0x0]
80003f4e:	3f 58       	mov	r8,-11
80003f50:	80 00       	ld.sh	r0,r0[0x0]
80003f52:	5a cc       	cp.w	r12,-20
80003f54:	80 00       	ld.sh	r0,r0[0x0]
80003f56:	42 e4       	lddsp	r4,sp[0xb8]

80003f58 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80003f58:	d4 31       	pushm	r0-r7,lr
80003f5a:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003f5c:	4b 16       	lddpc	r6,80004020 <xcmp_rx_process+0xc8>
80003f5e:	30 05       	mov	r5,0
80003f60:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003f62:	4b 13       	lddpc	r3,80004024 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80003f64:	4b 12       	lddpc	r2,80004028 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80003f66:	4b 21       	lddpc	r1,8000402c <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80003f68:	4b 20       	lddpc	r0,80004030 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003f6a:	6c 0c       	ld.w	r12,r6[0x0]
80003f6c:	0a 99       	mov	r9,r5
80003f6e:	08 9a       	mov	r10,r4
80003f70:	1a 9b       	mov	r11,sp
80003f72:	f0 1f 00 31 	mcall	80004034 <xcmp_rx_process+0xdc>
80003f76:	58 1c       	cp.w	r12,1
80003f78:	cf 91       	brne	80003f6a <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80003f7a:	40 0b       	lddsp	r11,sp[0x0]
80003f7c:	58 0b       	cp.w	r11,0
80003f7e:	cf 60       	breq	80003f6a <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80003f80:	96 0a       	ld.sh	r10,r11[0x0]
80003f82:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80003f86:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80003f8a:	59 c8       	cp.w	r8,28
80003f8c:	c1 e0       	breq	80003fc8 <xcmp_rx_process+0x70>
80003f8e:	e0 89 00 07 	brgt	80003f9c <xcmp_rx_process+0x44>
80003f92:	58 e8       	cp.w	r8,14
80003f94:	c0 e0       	breq	80003fb0 <xcmp_rx_process+0x58>
80003f96:	58 f8       	cp.w	r8,15
80003f98:	c2 41       	brne	80003fe0 <xcmp_rx_process+0x88>
80003f9a:	c0 f8       	rjmp	80003fb8 <xcmp_rx_process+0x60>
80003f9c:	e0 48 01 09 	cp.w	r8,265
80003fa0:	c1 80       	breq	80003fd0 <xcmp_rx_process+0x78>
80003fa2:	e0 48 01 0a 	cp.w	r8,266
80003fa6:	c1 90       	breq	80003fd8 <xcmp_rx_process+0x80>
80003fa8:	e0 48 00 2c 	cp.w	r8,44
80003fac:	c1 a1       	brne	80003fe0 <xcmp_rx_process+0x88>
80003fae:	c0 98       	rjmp	80003fc0 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80003fb0:	4a 2c       	lddpc	r12,80004038 <xcmp_rx_process+0xe0>
80003fb2:	f0 1f 00 23 	mcall	8000403c <xcmp_rx_process+0xe4>
					break;
80003fb6:	c2 f8       	rjmp	80004014 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80003fb8:	4a 2c       	lddpc	r12,80004040 <xcmp_rx_process+0xe8>
80003fba:	f0 1f 00 21 	mcall	8000403c <xcmp_rx_process+0xe4>
					break;
80003fbe:	c2 b8       	rjmp	80004014 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80003fc0:	4a 1c       	lddpc	r12,80004044 <xcmp_rx_process+0xec>
80003fc2:	f0 1f 00 1f 	mcall	8000403c <xcmp_rx_process+0xe4>
					break;
80003fc6:	c2 78       	rjmp	80004014 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80003fc8:	04 9c       	mov	r12,r2
80003fca:	f0 1f 00 1d 	mcall	8000403c <xcmp_rx_process+0xe4>
						, ptr);
					break;
80003fce:	c2 38       	rjmp	80004014 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80003fd0:	02 9c       	mov	r12,r1
80003fd2:	f0 1f 00 1b 	mcall	8000403c <xcmp_rx_process+0xe4>
					break;
80003fd6:	c1 f8       	rjmp	80004014 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80003fd8:	00 9c       	mov	r12,r0
80003fda:	f0 1f 00 19 	mcall	8000403c <xcmp_rx_process+0xe4>
					break;
80003fde:	c1 b8       	rjmp	80004014 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80003fe0:	12 98       	mov	r8,r9
80003fe2:	e2 18 04 00 	andl	r8,0x400,COH
80003fe6:	c0 70       	breq	80003ff4 <xcmp_rx_process+0x9c>
80003fe8:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80003fec:	e0 48 00 68 	cp.w	r8,104
80003ff0:	e0 8a 00 08 	brle	80004000 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80003ff4:	e2 19 f0 00 	andl	r9,0xf000,COH
80003ff8:	c0 e1       	brne	80004014 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80003ffa:	f0 1f 00 14 	mcall	80004048 <xcmp_rx_process+0xf0>
80003ffe:	c0 b8       	rjmp	80004014 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004000:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004004:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004008:	49 19       	lddpc	r9,8000404c <xcmp_rx_process+0xf4>
8000400a:	72 08       	ld.w	r8,r9[0x0]
8000400c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004010:	f0 1f 00 0b 	mcall	8000403c <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004014:	66 0c       	ld.w	r12,r3[0x0]
80004016:	40 0b       	lddsp	r11,sp[0x0]
80004018:	f0 1f 00 0e 	mcall	80004050 <xcmp_rx_process+0xf8>
8000401c:	ca 7b       	rjmp	80003f6a <xcmp_rx_process+0x12>
8000401e:	00 00       	add	r0,r0
80004020:	00 00       	add	r0,r0
80004022:	0a ec       	st.h	--r5,r12
80004024:	00 00       	add	r0,r0
80004026:	0a 90       	mov	r0,r5
80004028:	00 00       	add	r0,r0
8000402a:	0a fc       	st.b	--r5,r12
8000402c:	00 00       	add	r0,r0
8000402e:	0a f0       	st.b	--r5,r0
80004030:	00 00       	add	r0,r0
80004032:	0b 08       	ld.w	r8,r5++
80004034:	80 00       	ld.sh	r0,r0[0x0]
80004036:	50 ec       	stdsp	sp[0x38],r12
80004038:	00 00       	add	r0,r0
8000403a:	0b 20       	ld.uh	r0,r5++
8000403c:	80 00       	ld.sh	r0,r0[0x0]
8000403e:	3e 5c       	mov	r12,-27
80004040:	00 00       	add	r0,r0
80004042:	0a e0       	st.h	--r5,r0
80004044:	00 00       	add	r0,r0
80004046:	0b 14       	ld.sh	r4,r5++
80004048:	80 00       	ld.sh	r0,r0[0x0]
8000404a:	3e 38       	mov	r8,-29
8000404c:	00 00       	add	r0,r0
8000404e:	40 c4       	lddsp	r4,sp[0x30]
80004050:	80 00       	ld.sh	r0,r0[0x0]
80004052:	2a 60       	sub	r0,-90

80004054 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004054:	eb cd 40 90 	pushm	r4,r7,lr
80004058:	20 1d       	sub	sp,4
8000405a:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000405e:	48 c8       	lddpc	r8,8000408c <xcmp_rx+0x38>
80004060:	70 0c       	ld.w	r12,r8[0x0]
80004062:	f0 1f 00 0c 	mcall	80004090 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004066:	c1 00       	breq	80004086 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004068:	fa c7 ff fc 	sub	r7,sp,-4
8000406c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000406e:	e0 6a 00 ca 	mov	r10,202
80004072:	08 9b       	mov	r11,r4
80004074:	f0 1f 00 08 	mcall	80004094 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004078:	48 88       	lddpc	r8,80004098 <xcmp_rx+0x44>
8000407a:	70 0c       	ld.w	r12,r8[0x0]
8000407c:	30 09       	mov	r9,0
8000407e:	12 9a       	mov	r10,r9
80004080:	1a 9b       	mov	r11,sp
80004082:	f0 1f 00 07 	mcall	8000409c <xcmp_rx+0x48>
	}	
}
80004086:	2f fd       	sub	sp,-4
80004088:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
8000408c:	00 00       	add	r0,r0
8000408e:	0a 90       	mov	r0,r5
80004090:	80 00       	ld.sh	r0,r0[0x0]
80004092:	30 c0       	mov	r0,12
80004094:	80 00       	ld.sh	r0,r0[0x0]
80004096:	67 e8       	ld.w	r8,r3[0x78]
80004098:	00 00       	add	r0,r0
8000409a:	0a ec       	st.h	--r5,r12
8000409c:	80 00       	ld.sh	r0,r0[0x0]
8000409e:	52 f8       	stdsp	sp[0xbc],r8

800040a0 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
800040a0:	48 28       	lddpc	r8,800040a8 <xnl_register_xcmp_func+0x8>
800040a2:	91 0c       	st.w	r8[0x0],r12
}
800040a4:	5e fc       	retal	r12
800040a6:	00 00       	add	r0,r0
800040a8:	00 00       	add	r0,r0
800040aa:	0b 50       	ld.sh	r0,--r5

800040ac <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
800040ac:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
800040ae:	48 88       	lddpc	r8,800040cc <xnl_get_msg_ack_func+0x20>
800040b0:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
800040b2:	98 49       	ld.sh	r9,r12[0x8]
800040b4:	f0 09 19 00 	cp.h	r9,r8
800040b8:	c0 81       	brne	800040c8 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
800040ba:	48 68       	lddpc	r8,800040d0 <xnl_get_msg_ack_func+0x24>
800040bc:	70 0c       	ld.w	r12,r8[0x0]
800040be:	30 09       	mov	r9,0
800040c0:	12 9a       	mov	r10,r9
800040c2:	12 9b       	mov	r11,r9
800040c4:	f0 1f 00 04 	mcall	800040d4 <xnl_get_msg_ack_func+0x28>
800040c8:	d8 02       	popm	pc
800040ca:	00 00       	add	r0,r0
800040cc:	00 00       	add	r0,r0
800040ce:	0b 30       	ld.ub	r0,r5++
800040d0:	00 00       	add	r0,r0
800040d2:	0b 2c       	ld.uh	r12,r5++
800040d4:	80 00       	ld.sh	r0,r0[0x0]
800040d6:	52 f8       	stdsp	sp[0xbc],r8

800040d8 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
800040d8:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800040da:	4a 86       	lddpc	r6,80004178 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800040dc:	4a 82       	lddpc	r2,8000417c <xnl_tx_process+0xa4>
800040de:	4a 94       	lddpc	r4,80004180 <xnl_tx_process+0xa8>
800040e0:	30 07       	mov	r7,0
800040e2:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800040e4:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800040e6:	4a 85       	lddpc	r5,80004184 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800040e8:	4a 83       	lddpc	r3,80004188 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800040ea:	6c 08       	ld.w	r8,r6[0x0]
800040ec:	58 08       	cp.w	r8,0
800040ee:	c0 40       	breq	800040f6 <xnl_tx_process+0x1e>
800040f0:	58 18       	cp.w	r8,1
800040f2:	cf d1       	brne	800040ec <xnl_tx_process+0x14>
800040f4:	c2 08       	rjmp	80004134 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800040f6:	64 0c       	ld.w	r12,r2[0x0]
800040f8:	0e 99       	mov	r9,r7
800040fa:	02 9a       	mov	r10,r1
800040fc:	08 9b       	mov	r11,r4
800040fe:	f0 1f 00 24 	mcall	8000418c <xnl_tx_process+0xb4>
80004102:	58 1c       	cp.w	r12,1
80004104:	cf 31       	brne	800040ea <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004106:	68 0c       	ld.w	r12,r4[0x0]
80004108:	58 0c       	cp.w	r12,0
8000410a:	cf 00       	breq	800040ea <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
8000410c:	98 28       	ld.sh	r8,r12[0x4]
8000410e:	e0 08 19 00 	cp.h	r8,r0
80004112:	c0 41       	brne	8000411a <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
80004114:	f0 1f 00 1f 	mcall	80004190 <xnl_tx_process+0xb8>
						break;
80004118:	ce 9b       	rjmp	800040ea <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
8000411a:	f0 1f 00 1f 	mcall	80004194 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
8000411e:	30 18       	mov	r8,1
80004120:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004122:	66 0c       	ld.w	r12,r3[0x0]
80004124:	0e 99       	mov	r9,r7
80004126:	0e 9a       	mov	r10,r7
80004128:	0e 9b       	mov	r11,r7
8000412a:	f0 1f 00 19 	mcall	8000418c <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
8000412e:	30 18       	mov	r8,1
80004130:	8d 08       	st.w	r6[0x0],r8
80004132:	cd cb       	rjmp	800040ea <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004134:	66 0c       	ld.w	r12,r3[0x0]
80004136:	0e 99       	mov	r9,r7
80004138:	36 4a       	mov	r10,100
8000413a:	0e 9b       	mov	r11,r7
8000413c:	f0 1f 00 14 	mcall	8000418c <xnl_tx_process+0xb4>
80004140:	58 1c       	cp.w	r12,1
80004142:	c0 81       	brne	80004152 <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
80004144:	49 58       	lddpc	r8,80004198 <xnl_tx_process+0xc0>
80004146:	70 0c       	ld.w	r12,r8[0x0]
80004148:	68 0b       	ld.w	r11,r4[0x0]
8000414a:	f0 1f 00 15 	mcall	8000419c <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000414e:	8d 07       	st.w	r6[0x0],r7
80004150:	cc db       	rjmp	800040ea <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004152:	6a 08       	ld.w	r8,r5[0x0]
80004154:	58 38       	cp.w	r8,3
80004156:	e0 89 00 09 	brgt	80004168 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000415a:	68 0c       	ld.w	r12,r4[0x0]
8000415c:	f0 1f 00 0e 	mcall	80004194 <xnl_tx_process+0xbc>
						xnl_send_times++;
80004160:	6a 08       	ld.w	r8,r5[0x0]
80004162:	2f f8       	sub	r8,-1
80004164:	8b 08       	st.w	r5[0x0],r8
80004166:	cc 2b       	rjmp	800040ea <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004168:	48 c8       	lddpc	r8,80004198 <xnl_tx_process+0xc0>
8000416a:	70 0c       	ld.w	r12,r8[0x0]
8000416c:	68 0b       	ld.w	r11,r4[0x0]
8000416e:	f0 1f 00 0c 	mcall	8000419c <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004172:	8d 07       	st.w	r6[0x0],r7
80004174:	cb bb       	rjmp	800040ea <xnl_tx_process+0x12>
80004176:	00 00       	add	r0,r0
80004178:	00 00       	add	r0,r0
8000417a:	0b 44       	ld.w	r4,--r5
8000417c:	00 00       	add	r0,r0
8000417e:	0b 40       	ld.w	r0,--r5
80004180:	00 00       	add	r0,r0
80004182:	0b 3c       	ld.ub	r12,r5++
80004184:	00 00       	add	r0,r0
80004186:	0b 48       	ld.w	r8,--r5
80004188:	00 00       	add	r0,r0
8000418a:	0b 2c       	ld.uh	r12,r5++
8000418c:	80 00       	ld.sh	r0,r0[0x0]
8000418e:	50 ec       	stdsp	sp[0x38],r12
80004190:	80 00       	ld.sh	r0,r0[0x0]
80004192:	4f 7c       	lddpc	r12,8000436c <xnl_init+0x88>
80004194:	80 00       	ld.sh	r0,r0[0x0]
80004196:	2a 80       	sub	r0,-88
80004198:	00 00       	add	r0,r0
8000419a:	0a 90       	mov	r0,r5
8000419c:	80 00       	ld.sh	r0,r0[0x0]
8000419e:	2a 60       	sub	r0,-90

800041a0 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
800041a0:	eb cd 40 fe 	pushm	r1-r7,lr
800041a4:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800041a6:	49 26       	lddpc	r6,800041ec <xnl_rx_process+0x4c>
800041a8:	30 05       	mov	r5,0
800041aa:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800041ac:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800041ae:	49 11       	lddpc	r1,800041f0 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800041b0:	49 12       	lddpc	r2,800041f4 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800041b2:	6c 0c       	ld.w	r12,r6[0x0]
800041b4:	0a 99       	mov	r9,r5
800041b6:	08 9a       	mov	r10,r4
800041b8:	1a 9b       	mov	r11,sp
800041ba:	f0 1f 00 10 	mcall	800041f8 <xnl_rx_process+0x58>
800041be:	58 1c       	cp.w	r12,1
800041c0:	cf 91       	brne	800041b2 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800041c2:	40 0c       	lddsp	r12,sp[0x0]
800041c4:	58 0c       	cp.w	r12,0
800041c6:	cf 60       	breq	800041b2 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800041c8:	98 28       	ld.sh	r8,r12[0x4]
800041ca:	e6 08 19 00 	cp.h	r8,r3
800041ce:	e0 8b 00 0a 	brhi	800041e2 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800041d2:	5c 78       	castu.h	r8
800041d4:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800041d8:	58 09       	cp.w	r9,0
800041da:	c0 40       	breq	800041e2 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800041dc:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800041e0:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800041e2:	62 0c       	ld.w	r12,r1[0x0]
800041e4:	40 0b       	lddsp	r11,sp[0x0]
800041e6:	f0 1f 00 06 	mcall	800041fc <xnl_rx_process+0x5c>
800041ea:	ce 4b       	rjmp	800041b2 <xnl_rx_process+0x12>
800041ec:	00 00       	add	r0,r0
800041ee:	0a ac       	st.w	r5++,r12
800041f0:	00 00       	add	r0,r0
800041f2:	0a 90       	mov	r0,r5
800041f4:	00 00       	add	r0,r0
800041f6:	04 f4       	st.b	--r2,r4
800041f8:	80 00       	ld.sh	r0,r0[0x0]
800041fa:	50 ec       	stdsp	sp[0x38],r12
800041fc:	80 00       	ld.sh	r0,r0[0x0]
800041fe:	2a 60       	sub	r0,-90

80004200 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004200:	eb cd 40 c0 	pushm	r6-r7,lr
80004204:	20 1d       	sub	sp,4
80004206:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004208:	98 39       	ld.sh	r9,r12[0x6]
8000420a:	3f f8       	mov	r8,-1
8000420c:	f0 09 19 00 	cp.h	r9,r8
80004210:	c0 a1       	brne	80004224 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004212:	4a e9       	lddpc	r9,800042c8 <xnl_tx+0xc8>
80004214:	13 88       	ld.ub	r8,r9[0x0]
80004216:	2f f8       	sub	r8,-1
80004218:	5c 58       	castu.b	r8
8000421a:	b2 88       	st.b	r9[0x0],r8
8000421c:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004220:	a9 a8       	sbr	r8,0x8
80004222:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004224:	8c 49       	ld.sh	r9,r6[0x8]
80004226:	3f f8       	mov	r8,-1
80004228:	f0 09 19 00 	cp.h	r9,r8
8000422c:	c0 41       	brne	80004234 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
8000422e:	4a 88       	lddpc	r8,800042cc <xnl_tx+0xcc>
80004230:	90 18       	ld.sh	r8,r8[0x2]
80004232:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004234:	8c 59       	ld.sh	r9,r6[0xa]
80004236:	3f f8       	mov	r8,-1
80004238:	f0 09 19 00 	cp.h	r9,r8
8000423c:	c0 41       	brne	80004244 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000423e:	4a 48       	lddpc	r8,800042cc <xnl_tx+0xcc>
80004240:	90 28       	ld.sh	r8,r8[0x4]
80004242:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004244:	8c 69       	ld.sh	r9,r6[0xc]
80004246:	3f f8       	mov	r8,-1
80004248:	f0 09 19 00 	cp.h	r9,r8
8000424c:	c0 e1       	brne	80004268 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000424e:	4a 08       	lddpc	r8,800042cc <xnl_tx+0xcc>
80004250:	90 49       	ld.sh	r9,r8[0x8]
80004252:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004254:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004256:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004258:	90 49       	ld.sh	r9,r8[0x8]
8000425a:	e0 19 ff 00 	andl	r9,0xff00
8000425e:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004262:	f3 e8 10 08 	or	r8,r9,r8
80004266:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004268:	0d 98       	ld.ub	r8,r6[0x1]
8000426a:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
8000426c:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004270:	10 0c       	add	r12,r8
80004272:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004274:	58 0c       	cp.w	r12,0
80004276:	e0 89 00 04 	brgt	8000427e <xnl_tx+0x7e>
8000427a:	30 09       	mov	r9,0
8000427c:	c0 d8       	rjmp	80004296 <xnl_tx+0x96>
8000427e:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004282:	2f ec       	sub	r12,-2
80004284:	30 09       	mov	r9,0
80004286:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004288:	15 1b       	ld.sh	r11,r10++
8000428a:	f6 09 00 09 	add	r9,r11,r9
8000428e:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004290:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004292:	18 38       	cp.w	r8,r12
80004294:	cf a1       	brne	80004288 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004296:	5c 39       	neg	r9
80004298:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000429a:	48 e8       	lddpc	r8,800042d0 <xnl_tx+0xd0>
8000429c:	70 0c       	ld.w	r12,r8[0x0]
8000429e:	f0 1f 00 0e 	mcall	800042d4 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800042a2:	c1 00       	breq	800042c2 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800042a4:	fa c7 ff fc 	sub	r7,sp,-4
800042a8:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800042aa:	e0 6a 01 00 	mov	r10,256
800042ae:	0c 9b       	mov	r11,r6
800042b0:	f0 1f 00 0a 	mcall	800042d8 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800042b4:	48 a8       	lddpc	r8,800042dc <xnl_tx+0xdc>
800042b6:	70 0c       	ld.w	r12,r8[0x0]
800042b8:	30 09       	mov	r9,0
800042ba:	12 9a       	mov	r10,r9
800042bc:	1a 9b       	mov	r11,sp
800042be:	f0 1f 00 09 	mcall	800042e0 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800042c2:	2f fd       	sub	sp,-4
800042c4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800042c8:	00 00       	add	r0,r0
800042ca:	0b 4c       	ld.w	r12,--r5
800042cc:	00 00       	add	r0,r0
800042ce:	0b 30       	ld.ub	r0,r5++
800042d0:	00 00       	add	r0,r0
800042d2:	0a 90       	mov	r0,r5
800042d4:	80 00       	ld.sh	r0,r0[0x0]
800042d6:	30 c0       	mov	r0,12
800042d8:	80 00       	ld.sh	r0,r0[0x0]
800042da:	67 e8       	ld.w	r8,r3[0x78]
800042dc:	00 00       	add	r0,r0
800042de:	0b 40       	ld.w	r0,--r5
800042e0:	80 00       	ld.sh	r0,r0[0x0]
800042e2:	52 f8       	stdsp	sp[0xbc],r8

800042e4 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800042e4:	eb cd 40 80 	pushm	r7,lr
800042e8:	fa cd 01 00 	sub	sp,sp,256
	///*initialize the physical layer*/
	//phy_init();
	
	xnl_information.is_connected = FALSE;
800042ec:	30 09       	mov	r9,0
800042ee:	4a 78       	lddpc	r8,80004388 <xnl_init+0xa4>
800042f0:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800042f2:	30 0b       	mov	r11,0
800042f4:	30 1c       	mov	r12,1
800042f6:	f0 1f 00 26 	mcall	8000438c <xnl_init+0xa8>
800042fa:	4a 68       	lddpc	r8,80004390 <xnl_init+0xac>
800042fc:	91 0c       	st.w	r8[0x0],r12
800042fe:	70 08       	ld.w	r8,r8[0x0]
80004300:	58 08       	cp.w	r8,0
80004302:	c0 80       	breq	80004312 <xnl_init+0x2e>
80004304:	4a 38       	lddpc	r8,80004390 <xnl_init+0xac>
80004306:	70 0c       	ld.w	r12,r8[0x0]
80004308:	30 09       	mov	r9,0
8000430a:	12 9a       	mov	r10,r9
8000430c:	12 9b       	mov	r11,r9
8000430e:	f0 1f 00 22 	mcall	80004394 <xnl_init+0xb0>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004312:	30 4b       	mov	r11,4
80004314:	31 4c       	mov	r12,20
80004316:	f0 1f 00 1e 	mcall	8000438c <xnl_init+0xa8>
8000431a:	4a 08       	lddpc	r8,80004398 <xnl_init+0xb4>
8000431c:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000431e:	30 07       	mov	r7,0
80004320:	1a d7       	st.w	--sp,r7
80004322:	1a d7       	st.w	--sp,r7
80004324:	1a d7       	st.w	--sp,r7
80004326:	30 38       	mov	r8,3
80004328:	0e 99       	mov	r9,r7
8000432a:	e0 6a 02 00 	mov	r10,512
8000432e:	49 cb       	lddpc	r11,8000439c <xnl_init+0xb8>
80004330:	49 cc       	lddpc	r12,800043a0 <xnl_init+0xbc>
80004332:	f0 1f 00 1d 	mcall	800043a4 <xnl_init+0xc0>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004336:	1a d7       	st.w	--sp,r7
80004338:	1a d7       	st.w	--sp,r7
8000433a:	1a d7       	st.w	--sp,r7
8000433c:	30 38       	mov	r8,3
8000433e:	0e 99       	mov	r9,r7
80004340:	e0 6a 03 20 	mov	r10,800
80004344:	49 9b       	lddpc	r11,800043a8 <xnl_init+0xc4>
80004346:	49 ac       	lddpc	r12,800043ac <xnl_init+0xc8>
80004348:	f0 1f 00 17 	mcall	800043a4 <xnl_init+0xc0>
	,  NULL
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	phy_init();
8000434c:	f0 1f 00 19 	mcall	800043b0 <xnl_init+0xcc>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004350:	e0 68 40 0e 	mov	r8,16398
80004354:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004358:	3f f8       	mov	r8,-1
8000435a:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
8000435e:	30 38       	mov	r8,3
80004360:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004364:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004368:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000436c:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004370:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004374:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004378:	fa cc ff e8 	sub	r12,sp,-24
8000437c:	f0 1f 00 0e 	mcall	800043b4 <xnl_init+0xd0>
80004380:	2f ad       	sub	sp,-24
	);
	
	phy_init();
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
80004382:	2c 0d       	sub	sp,-256
80004384:	e3 cd 80 80 	ldm	sp++,r7,pc
80004388:	00 00       	add	r0,r0
8000438a:	0b 30       	ld.ub	r0,r5++
8000438c:	80 00       	ld.sh	r0,r0[0x0]
8000438e:	53 f8       	stdsp	sp[0xfc],r8
80004390:	00 00       	add	r0,r0
80004392:	0b 2c       	ld.uh	r12,r5++
80004394:	80 00       	ld.sh	r0,r0[0x0]
80004396:	52 f8       	stdsp	sp[0xbc],r8
80004398:	00 00       	add	r0,r0
8000439a:	0b 40       	ld.w	r0,--r5
8000439c:	80 01       	ld.sh	r1,r0[0x0]
8000439e:	4c 10       	lddpc	r0,800044a0 <xnl_device_auth_reply_func+0x88>
800043a0:	80 00       	ld.sh	r0,r0[0x0]
800043a2:	41 a0       	lddsp	r0,sp[0x68]
800043a4:	80 00       	ld.sh	r0,r0[0x0]
800043a6:	5a cc       	cp.w	r12,-20
800043a8:	80 00       	ld.sh	r0,r0[0x0]
800043aa:	c0 00       	breq	800043aa <xnl_init+0xc6>
800043ac:	80 00       	ld.sh	r0,r0[0x0]
800043ae:	40 d8       	lddsp	r8,sp[0x34]
800043b0:	80 00       	ld.sh	r0,r0[0x0]
800043b2:	30 e8       	mov	r8,14
800043b4:	80 00       	ld.sh	r0,r0[0x0]
800043b6:	42 00       	lddsp	r0,sp[0x80]

800043b8 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800043b8:	eb cd 40 80 	pushm	r7,lr
800043bc:	fa cd 01 00 	sub	sp,sp,256
800043c0:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800043c2:	e0 68 40 0e 	mov	r8,16398
800043c6:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800043c8:	3f f8       	mov	r8,-1
800043ca:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800043cc:	30 c8       	mov	r8,12
800043ce:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800043d0:	98 38       	ld.sh	r8,r12[0x6]
800043d2:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
800043d4:	98 58       	ld.sh	r8,r12[0xa]
800043d6:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800043d8:	98 48       	ld.sh	r8,r12[0x8]
800043da:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800043dc:	98 68       	ld.sh	r8,r12[0xc]
800043de:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800043e0:	30 08       	mov	r8,0
800043e2:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800043e4:	1a 9c       	mov	r12,sp
800043e6:	f0 1f 00 0a 	mcall	8000440c <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800043ea:	fa cd 00 cc 	sub	sp,sp,204
800043ee:	e0 6a 00 ca 	mov	r10,202
800043f2:	ee cb ff f0 	sub	r11,r7,-16
800043f6:	1a 9c       	mov	r12,sp
800043f8:	f0 1f 00 06 	mcall	80004410 <xnl_data_msg_func+0x58>
800043fc:	48 68       	lddpc	r8,80004414 <xnl_data_msg_func+0x5c>
800043fe:	70 08       	ld.w	r8,r8[0x0]
80004400:	5d 18       	icall	r8
80004402:	fa cd ff 34 	sub	sp,sp,-204
}
80004406:	2c 0d       	sub	sp,-256
80004408:	e3 cd 80 80 	ldm	sp++,r7,pc
8000440c:	80 00       	ld.sh	r0,r0[0x0]
8000440e:	42 00       	lddsp	r0,sp[0x80]
80004410:	80 00       	ld.sh	r0,r0[0x0]
80004412:	67 e8       	ld.w	r8,r3[0x78]
80004414:	00 00       	add	r0,r0
80004416:	0b 50       	ld.sh	r0,--r5

80004418 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004418:	d4 21       	pushm	r4-r7,lr
8000441a:	fa cd 01 00 	sub	sp,sp,256
8000441e:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004420:	4c 28       	lddpc	r8,80004528 <xnl_device_auth_reply_func+0x110>
80004422:	11 88       	ld.ub	r8,r8[0x0]
80004424:	58 08       	cp.w	r8,0
80004426:	c7 e1       	brne	80004522 <xnl_device_auth_reply_func+0x10a>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004428:	4c 18       	lddpc	r8,8000452c <xnl_device_auth_reply_func+0x114>
8000442a:	70 0c       	ld.w	r12,r8[0x0]
8000442c:	30 09       	mov	r9,0
8000442e:	12 9a       	mov	r10,r9
80004430:	12 9b       	mov	r11,r9
80004432:	f0 1f 00 40 	mcall	80004530 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004436:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
8000443a:	4b c8       	lddpc	r8,80004528 <xnl_device_auth_reply_func+0x110>
8000443c:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
8000443e:	ef 39 00 12 	ld.ub	r9,r7[18]
80004442:	ef 38 00 13 	ld.ub	r8,r7[19]
80004446:	b1 68       	lsl	r8,0x10
80004448:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000444c:	ef 38 00 15 	ld.ub	r8,r7[21]
80004450:	f3 e8 10 08 	or	r8,r9,r8
80004454:	ef 39 00 14 	ld.ub	r9,r7[20]
80004458:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
8000445c:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004460:	ef 38 00 17 	ld.ub	r8,r7[23]
80004464:	b1 68       	lsl	r8,0x10
80004466:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
8000446a:	ef 38 00 19 	ld.ub	r8,r7[25]
8000446e:	f5 e8 10 08 	or	r8,r10,r8
80004472:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004476:	f1 ea 10 88 	or	r8,r8,r10<<0x8
8000447a:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000447c:	e0 64 79 b9 	mov	r4,31161
80004480:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004484:	e0 65 1c 1d 	mov	r5,7197
80004488:	ea 15 c3 38 	orh	r5,0xc338
8000448c:	e0 66 63 23 	mov	r6,25379
80004490:	ea 16 1c 8b 	orh	r6,0x1c8b
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004494:	e0 6e fc a2 	mov	lr,64674
80004498:	ea 1e 45 b0 	orh	lr,0x45b0
8000449c:	e0 67 75 d3 	mov	r7,30163
800044a0:	ea 17 c4 ca 	orh	r7,0xc4ca
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800044a4:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800044a6:	f4 08 00 0c 	add	r12,r10,r8
800044aa:	f0 0b 15 04 	lsl	r11,r8,0x4
800044ae:	0a 0b       	add	r11,r5
800044b0:	f9 eb 20 0b 	eor	r11,r12,r11
800044b4:	f0 0c 16 05 	lsr	r12,r8,0x5
800044b8:	0c 0c       	add	r12,r6
800044ba:	18 5b       	eor	r11,r12
800044bc:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800044be:	f2 0c 15 04 	lsl	r12,r9,0x4
800044c2:	1c 0c       	add	r12,lr
800044c4:	f2 0b 16 05 	lsr	r11,r9,0x5
800044c8:	0e 0b       	add	r11,r7
800044ca:	f9 eb 20 0b 	eor	r11,r12,r11
800044ce:	f2 0a 00 0c 	add	r12,r9,r10
800044d2:	18 5b       	eor	r11,r12
800044d4:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
800044d6:	e0 6b 37 20 	mov	r11,14112
800044da:	ea 1b c6 ef 	orh	r11,0xc6ef
800044de:	16 3a       	cp.w	r10,r11
800044e0:	ce 21       	brne	800044a4 <xnl_device_auth_reply_func+0x8c>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800044e2:	e0 6a 40 1a 	mov	r10,16410
800044e6:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800044e8:	3f fa       	mov	r10,-1
800044ea:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800044ec:	30 6b       	mov	r11,6
800044ee:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800044f0:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800044f2:	48 eb       	lddpc	r11,80004528 <xnl_device_auth_reply_func+0x110>
800044f4:	96 1c       	ld.sh	r12,r11[0x2]
800044f6:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800044f8:	96 2b       	ld.sh	r11,r11[0x4]
800044fa:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800044fc:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800044fe:	30 ca       	mov	r10,12
80004500:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004502:	30 0a       	mov	r10,0
80004504:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004508:	30 7a       	mov	r10,7
8000450a:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
8000450e:	30 2a       	mov	r10,2
80004510:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004514:	fa ca ff ec 	sub	r10,sp,-20
80004518:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000451a:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000451c:	1a 9c       	mov	r12,sp
8000451e:	f0 1f 00 06 	mcall	80004534 <xnl_device_auth_reply_func+0x11c>
}
80004522:	2c 0d       	sub	sp,-256
80004524:	d8 22       	popm	r4-r7,pc
80004526:	00 00       	add	r0,r0
80004528:	00 00       	add	r0,r0
8000452a:	0b 30       	ld.ub	r0,r5++
8000452c:	00 00       	add	r0,r0
8000452e:	0b 2c       	ld.uh	r12,r5++
80004530:	80 00       	ld.sh	r0,r0[0x0]
80004532:	52 f8       	stdsp	sp[0xbc],r8
80004534:	80 00       	ld.sh	r0,r0[0x0]
80004536:	42 00       	lddsp	r0,sp[0x80]

80004538 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004538:	eb cd 40 80 	pushm	r7,lr
8000453c:	fa cd 01 00 	sub	sp,sp,256
80004540:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004542:	49 28       	lddpc	r8,80004588 <xnl_master_status_brdcst_func+0x50>
80004544:	11 88       	ld.ub	r8,r8[0x0]
80004546:	58 08       	cp.w	r8,0
80004548:	c1 c1       	brne	80004580 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000454a:	49 18       	lddpc	r8,8000458c <xnl_master_status_brdcst_func+0x54>
8000454c:	70 0c       	ld.w	r12,r8[0x0]
8000454e:	30 09       	mov	r9,0
80004550:	12 9a       	mov	r10,r9
80004552:	12 9b       	mov	r11,r9
80004554:	f0 1f 00 0f 	mcall	80004590 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004558:	8e 58       	ld.sh	r8,r7[0xa]
8000455a:	48 c9       	lddpc	r9,80004588 <xnl_master_status_brdcst_func+0x50>
8000455c:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000455e:	e0 68 40 0e 	mov	r8,16398
80004562:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004564:	3f f8       	mov	r8,-1
80004566:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004568:	30 4a       	mov	r10,4
8000456a:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000456c:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000456e:	92 19       	ld.sh	r9,r9[0x2]
80004570:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004572:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004574:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004576:	30 08       	mov	r8,0
80004578:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
8000457a:	1a 9c       	mov	r12,sp
8000457c:	f0 1f 00 06 	mcall	80004594 <xnl_master_status_brdcst_func+0x5c>
	//log("--1--\r\n");
}
80004580:	2c 0d       	sub	sp,-256
80004582:	e3 cd 80 80 	ldm	sp++,r7,pc
80004586:	00 00       	add	r0,r0
80004588:	00 00       	add	r0,r0
8000458a:	0b 30       	ld.ub	r0,r5++
8000458c:	00 00       	add	r0,r0
8000458e:	0b 2c       	ld.uh	r12,r5++
80004590:	80 00       	ld.sh	r0,r0[0x0]
80004592:	52 f8       	stdsp	sp[0xbc],r8
80004594:	80 00       	ld.sh	r0,r0[0x0]
80004596:	42 00       	lddsp	r0,sp[0x80]

80004598 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004598:	eb cd 40 80 	pushm	r7,lr
8000459c:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
8000459e:	49 28       	lddpc	r8,800045e4 <xnl_device_conn_reply_func+0x4c>
800045a0:	70 0c       	ld.w	r12,r8[0x0]
800045a2:	30 09       	mov	r9,0
800045a4:	12 9a       	mov	r10,r9
800045a6:	12 9b       	mov	r11,r9
800045a8:	f0 1f 00 10 	mcall	800045e8 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800045ac:	ef 18 00 10 	ld.uh	r8,r7[16]
800045b0:	10 99       	mov	r9,r8
800045b2:	e2 19 ff 00 	andl	r9,0xff00,COH
800045b6:	e0 49 01 00 	cp.w	r9,256
800045ba:	c0 60       	breq	800045c6 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800045bc:	0e 9c       	mov	r12,r7
800045be:	f0 1f 00 0c 	mcall	800045ec <xnl_device_conn_reply_func+0x54>
800045c2:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800045c6:	a9 68       	lsl	r8,0x8
800045c8:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800045cc:	48 98       	lddpc	r8,800045f0 <xnl_device_conn_reply_func+0x58>
800045ce:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800045d0:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
800045d4:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
800045d6:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
800045da:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800045dc:	30 19       	mov	r9,1
800045de:	b0 89       	st.b	r8[0x0],r9
800045e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800045e4:	00 00       	add	r0,r0
800045e6:	0b 2c       	ld.uh	r12,r5++
800045e8:	80 00       	ld.sh	r0,r0[0x0]
800045ea:	52 f8       	stdsp	sp[0xbc],r8
800045ec:	80 00       	ld.sh	r0,r0[0x0]
800045ee:	45 38       	lddsp	r8,sp[0x14c]
800045f0:	00 00       	add	r0,r0
800045f2:	0b 30       	ld.ub	r0,r5++

800045f4 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
800045f4:	fe 78 0c 00 	mov	r8,-62464
800045f8:	e0 69 03 07 	mov	r9,775
800045fc:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
800045fe:	30 49       	mov	r9,4
80004600:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004602:	71 59       	ld.w	r9,r8[0x54]
80004604:	e2 19 00 80 	andl	r9,0x80,COH
80004608:	cf d0       	breq	80004602 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
8000460a:	fe 78 0c 00 	mov	r8,-62464
8000460e:	30 59       	mov	r9,5
80004610:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80004612:	e0 69 01 0d 	mov	r9,269
80004616:	ea 19 10 07 	orh	r9,0x1007
8000461a:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
8000461c:	71 59       	ld.w	r9,r8[0x54]
8000461e:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004622:	cf d0       	breq	8000461c <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004624:	fe 78 0c 00 	mov	r8,-62464
80004628:	fc 19 00 80 	movh	r9,0x80
8000462c:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
8000462e:	34 0a       	mov	r10,64
80004630:	fe 69 14 00 	mov	r9,-125952
80004634:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80004636:	30 69       	mov	r9,6
80004638:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
8000463a:	30 19       	mov	r9,1
8000463c:	fe 68 10 00 	mov	r8,-126976
80004640:	91 19       	st.w	r8[0x4],r9
}
80004642:	5e fc       	retal	r12

80004644 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80004644:	fe 78 10 00 	mov	r8,-61440
80004648:	fc 19 00 10 	movh	r9,0x10
8000464c:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
8000464e:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80004650:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80004652:	30 39       	mov	r9,3
80004654:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80004658:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
8000465c:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80004660:	fe 78 38 00 	mov	r8,-51200
80004664:	30 49       	mov	r9,4
80004666:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
8000466a:	e0 69 91 0d 	mov	r9,37133
8000466e:	ea 19 00 52 	orh	r9,0x52
80004672:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80004674:	32 09       	mov	r9,32
80004676:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004678:	30 59       	mov	r9,5
8000467a:	91 09       	st.w	r8[0x0],r9
}
8000467c:	5e fc       	retal	r12
8000467e:	d7 03       	nop

80004680 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80004680:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
80004682:	30 2a       	mov	r10,2
80004684:	e0 6b 01 c1 	mov	r11,449
80004688:	48 ec       	lddpc	r12,800046c0 <tc_init+0x40>
8000468a:	f0 1f 00 0f 	mcall	800046c4 <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
8000468e:	48 fb       	lddpc	r11,800046c8 <tc_init+0x48>
80004690:	fe 7c 38 00 	mov	r12,-51200
80004694:	f0 1f 00 0e 	mcall	800046cc <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80004698:	e0 6a 75 30 	mov	r10,30000
8000469c:	30 1b       	mov	r11,1
8000469e:	fe 7c 38 00 	mov	r12,-51200
800046a2:	f0 1f 00 0c 	mcall	800046d0 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
800046a6:	48 ca       	lddpc	r10,800046d4 <tc_init+0x54>
800046a8:	30 1b       	mov	r11,1
800046aa:	fe 7c 38 00 	mov	r12,-51200
800046ae:	f0 1f 00 0b 	mcall	800046d8 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
800046b2:	30 1b       	mov	r11,1
800046b4:	fe 7c 38 00 	mov	r12,-51200
800046b8:	f0 1f 00 09 	mcall	800046dc <tc_init+0x5c>
800046bc:	d8 02       	popm	pc
800046be:	00 00       	add	r0,r0
800046c0:	80 00       	ld.sh	r0,r0[0x0]
800046c2:	46 e0       	lddsp	r0,sp[0x1b8]
800046c4:	80 00       	ld.sh	r0,r0[0x0]
800046c6:	47 04       	lddsp	r4,sp[0x1c0]
800046c8:	80 01       	ld.sh	r1,r0[0x0]
800046ca:	4c 1c       	lddpc	r12,800047cc <INTC_init_interrupts+0x48>
800046cc:	80 00       	ld.sh	r0,r0[0x0]
800046ce:	48 10       	lddpc	r0,800046d0 <tc_init+0x50>
800046d0:	80 00       	ld.sh	r0,r0[0x0]
800046d2:	48 d0       	lddpc	r0,80004704 <INTC_register_interrupt>
800046d4:	80 01       	ld.sh	r1,r0[0x0]
800046d6:	4c 18       	lddpc	r8,800047d8 <_get_interrupt_handler>
800046d8:	80 00       	ld.sh	r0,r0[0x0]
800046da:	49 04       	lddpc	r4,80004718 <INTC_register_interrupt+0x14>
800046dc:	80 00       	ld.sh	r0,r0[0x0]
800046de:	48 ac       	lddpc	r12,80004704 <INTC_register_interrupt>

800046e0 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
800046e0:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
800046e2:	48 68       	lddpc	r8,800046f8 <_tc_interrupt+0x18>
800046e4:	70 09       	ld.w	r9,r8[0x0]
800046e6:	2f f9       	sub	r9,-1
800046e8:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
800046ea:	30 1b       	mov	r11,1
800046ec:	fe 7c 38 00 	mov	r12,-51200
800046f0:	f0 1f 00 03 	mcall	800046fc <_tc_interrupt+0x1c>
	
}
800046f4:	d4 02       	popm	lr
800046f6:	d6 03       	rete
800046f8:	00 00       	add	r0,r0
800046fa:	0b 54       	ld.sh	r4,--r5
800046fc:	80 00       	ld.sh	r0,r0[0x0]
800046fe:	48 be       	lddpc	lr,80004728 <INTC_register_interrupt+0x24>

80004700 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004700:	c0 08       	rjmp	80004700 <_unhandled_interrupt>
80004702:	d7 03       	nop

80004704 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004704:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004708:	49 99       	lddpc	r9,8000476c <INTC_register_interrupt+0x68>
8000470a:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000470e:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80004712:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004714:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004718:	58 0a       	cp.w	r10,0
8000471a:	c0 91       	brne	8000472c <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000471c:	49 59       	lddpc	r9,80004770 <INTC_register_interrupt+0x6c>
8000471e:	49 6a       	lddpc	r10,80004774 <INTC_register_interrupt+0x70>
80004720:	12 1a       	sub	r10,r9
80004722:	fe 79 08 00 	mov	r9,-63488
80004726:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000472a:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
8000472c:	58 1a       	cp.w	r10,1
8000472e:	c0 a1       	brne	80004742 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004730:	49 09       	lddpc	r9,80004770 <INTC_register_interrupt+0x6c>
80004732:	49 2a       	lddpc	r10,80004778 <INTC_register_interrupt+0x74>
80004734:	12 1a       	sub	r10,r9
80004736:	bf aa       	sbr	r10,0x1e
80004738:	fe 79 08 00 	mov	r9,-63488
8000473c:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004740:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80004742:	58 2a       	cp.w	r10,2
80004744:	c0 a1       	brne	80004758 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004746:	48 b9       	lddpc	r9,80004770 <INTC_register_interrupt+0x6c>
80004748:	48 da       	lddpc	r10,8000477c <INTC_register_interrupt+0x78>
8000474a:	12 1a       	sub	r10,r9
8000474c:	bf ba       	sbr	r10,0x1f
8000474e:	fe 79 08 00 	mov	r9,-63488
80004752:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004756:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004758:	48 69       	lddpc	r9,80004770 <INTC_register_interrupt+0x6c>
8000475a:	48 aa       	lddpc	r10,80004780 <INTC_register_interrupt+0x7c>
8000475c:	12 1a       	sub	r10,r9
8000475e:	ea 1a c0 00 	orh	r10,0xc000
80004762:	fe 79 08 00 	mov	r9,-63488
80004766:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000476a:	5e fc       	retal	r12
8000476c:	80 01       	ld.sh	r1,r0[0x0]
8000476e:	4c 24       	lddpc	r4,80004874 <tc_init_waveform+0x64>
80004770:	80 00       	ld.sh	r0,r0[0x0]
80004772:	be 00       	st.h	pc[0x0],r0
80004774:	80 00       	ld.sh	r0,r0[0x0]
80004776:	bf 04       	ld.d	r4,pc
80004778:	80 00       	ld.sh	r0,r0[0x0]
8000477a:	bf 12       	ld.d	r2,--pc
8000477c:	80 00       	ld.sh	r0,r0[0x0]
8000477e:	bf 20       	st.d	pc++,r0
80004780:	80 00       	ld.sh	r0,r0[0x0]
80004782:	bf 2e       	st.d	pc++,lr

80004784 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004784:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004786:	49 18       	lddpc	r8,800047c8 <INTC_init_interrupts+0x44>
80004788:	e3 b8 00 01 	mtsr	0x4,r8
8000478c:	49 0e       	lddpc	lr,800047cc <INTC_init_interrupts+0x48>
8000478e:	30 07       	mov	r7,0
80004790:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004792:	49 0c       	lddpc	r12,800047d0 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004794:	49 05       	lddpc	r5,800047d4 <INTC_init_interrupts+0x50>
80004796:	10 15       	sub	r5,r8
80004798:	fe 76 08 00 	mov	r6,-63488
8000479c:	c1 08       	rjmp	800047bc <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000479e:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800047a0:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800047a2:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800047a4:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800047a8:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800047aa:	10 3a       	cp.w	r10,r8
800047ac:	fe 9b ff fc 	brhi	800047a4 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800047b0:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800047b4:	2f f7       	sub	r7,-1
800047b6:	2f 8e       	sub	lr,-8
800047b8:	59 37       	cp.w	r7,19
800047ba:	c0 50       	breq	800047c4 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800047bc:	7c 08       	ld.w	r8,lr[0x0]
800047be:	58 08       	cp.w	r8,0
800047c0:	ce f1       	brne	8000479e <INTC_init_interrupts+0x1a>
800047c2:	cf 7b       	rjmp	800047b0 <INTC_init_interrupts+0x2c>
800047c4:	d8 22       	popm	r4-r7,pc
800047c6:	00 00       	add	r0,r0
800047c8:	80 00       	ld.sh	r0,r0[0x0]
800047ca:	be 00       	st.h	pc[0x0],r0
800047cc:	80 01       	ld.sh	r1,r0[0x0]
800047ce:	4c 24       	lddpc	r4,800048d4 <tc_write_rc+0x4>
800047d0:	80 00       	ld.sh	r0,r0[0x0]
800047d2:	47 00       	lddsp	r0,sp[0x1c0]
800047d4:	80 00       	ld.sh	r0,r0[0x0]
800047d6:	bf 04       	ld.d	r4,pc

800047d8 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800047d8:	fe 78 08 00 	mov	r8,-63488
800047dc:	e0 69 00 83 	mov	r9,131
800047e0:	f2 0c 01 0c 	sub	r12,r9,r12
800047e4:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800047e8:	f2 ca ff c0 	sub	r10,r9,-64
800047ec:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
800047f0:	58 08       	cp.w	r8,0
800047f2:	c0 21       	brne	800047f6 <_get_interrupt_handler+0x1e>
800047f4:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
800047f6:	f0 08 12 00 	clz	r8,r8
800047fa:	48 5a       	lddpc	r10,8000480c <_get_interrupt_handler+0x34>
800047fc:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004800:	f0 08 11 1f 	rsub	r8,r8,31
80004804:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004806:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000480a:	5e fc       	retal	r12
8000480c:	80 01       	ld.sh	r1,r0[0x0]
8000480e:	4c 24       	lddpc	r4,80004914 <tc_configure_interrupts+0x10>

80004810 <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80004810:	76 09       	ld.w	r9,r11[0x0]
80004812:	58 29       	cp.w	r9,2
80004814:	e0 88 00 03 	brls	8000481a <tc_init_waveform+0xa>
80004818:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
8000481a:	76 18       	ld.w	r8,r11[0x4]
8000481c:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80004820:	af ba       	sbr	r10,0xf
80004822:	10 9b       	mov	r11,r8
80004824:	e6 1b c0 00 	andh	r11,0xc000,COH
80004828:	16 4a       	or	r10,r11
8000482a:	10 9b       	mov	r11,r8
8000482c:	e6 1b 30 00 	andh	r11,0x3000,COH
80004830:	16 4a       	or	r10,r11
80004832:	10 9b       	mov	r11,r8
80004834:	e6 1b 0c 00 	andh	r11,0xc00,COH
80004838:	16 4a       	or	r10,r11
8000483a:	10 9b       	mov	r11,r8
8000483c:	e6 1b 03 00 	andh	r11,0x300,COH
80004840:	16 4a       	or	r10,r11
80004842:	10 9b       	mov	r11,r8
80004844:	e6 1b 00 c0 	andh	r11,0xc0,COH
80004848:	16 4a       	or	r10,r11
8000484a:	10 9b       	mov	r11,r8
8000484c:	e6 1b 00 30 	andh	r11,0x30,COH
80004850:	16 4a       	or	r10,r11
80004852:	10 9b       	mov	r11,r8
80004854:	e6 1b 00 0c 	andh	r11,0xc,COH
80004858:	16 4a       	or	r10,r11
8000485a:	10 9b       	mov	r11,r8
8000485c:	e6 1b 00 03 	andh	r11,0x3,COH
80004860:	16 4a       	or	r10,r11
80004862:	10 9b       	mov	r11,r8
80004864:	e2 1b 60 00 	andl	r11,0x6000,COH
80004868:	16 4a       	or	r10,r11
8000486a:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
8000486e:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80004872:	10 9b       	mov	r11,r8
80004874:	e2 1b 0c 00 	andl	r11,0xc00,COH
80004878:	16 4a       	or	r10,r11
8000487a:	10 9b       	mov	r11,r8
8000487c:	e2 1b 03 00 	andl	r11,0x300,COH
80004880:	16 4a       	or	r10,r11
80004882:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80004886:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
8000488a:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
8000488e:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80004892:	10 9b       	mov	r11,r8
80004894:	e2 1b 00 30 	andl	r11,0x30,COH
80004898:	16 4a       	or	r10,r11
8000489a:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
8000489e:	f5 e8 10 38 	or	r8,r10,r8<<0x3
800048a2:	a5 69       	lsl	r9,0x4
800048a4:	2f f9       	sub	r9,-1
800048a6:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
800048aa:	5e fd       	retal	0

800048ac <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800048ac:	58 2b       	cp.w	r11,2
800048ae:	e0 88 00 03 	brls	800048b4 <tc_start+0x8>
800048b2:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800048b4:	a7 6b       	lsl	r11,0x6
800048b6:	16 0c       	add	r12,r11
800048b8:	30 58       	mov	r8,5
800048ba:	99 08       	st.w	r12[0x0],r8
800048bc:	5e fd       	retal	0

800048be <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800048be:	58 2b       	cp.w	r11,2
800048c0:	e0 88 00 03 	brls	800048c6 <tc_read_sr+0x8>
800048c4:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
800048c6:	a7 6b       	lsl	r11,0x6
800048c8:	2e 0b       	sub	r11,-32
800048ca:	16 0c       	add	r12,r11
800048cc:	78 0c       	ld.w	r12,r12[0x0]
}
800048ce:	5e fc       	retal	r12

800048d0 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800048d0:	58 2b       	cp.w	r11,2
800048d2:	e0 88 00 03 	brls	800048d8 <tc_write_rc+0x8>
800048d6:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
800048d8:	f6 08 15 04 	lsl	r8,r11,0x4
800048dc:	2f f8       	sub	r8,-1
800048de:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
800048e2:	e2 18 80 00 	andl	r8,0x8000,COH
800048e6:	c0 c0       	breq	800048fe <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
800048e8:	a7 6b       	lsl	r11,0x6
800048ea:	16 0c       	add	r12,r11
800048ec:	2e 4c       	sub	r12,-28
800048ee:	78 08       	ld.w	r8,r12[0x0]
800048f0:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800048f4:	e0 18 00 00 	andl	r8,0x0
800048f8:	f3 e8 10 08 	or	r8,r9,r8
800048fc:	99 08       	st.w	r12[0x0],r8

  return value;
800048fe:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80004902:	5e fc       	retal	r12

80004904 <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80004904:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80004908:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
8000490c:	58 2b       	cp.w	r11,2
8000490e:	e0 88 00 04 	brls	80004916 <tc_configure_interrupts+0x12>
80004912:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80004916:	ee 19 00 01 	eorh	r9,0x1
8000491a:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
8000491e:	74 08       	ld.w	r8,r10[0x0]
80004920:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80004924:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80004928:	a7 6e       	lsl	lr,0x6
8000492a:	fd e7 10 7e 	or	lr,lr,r7<<0x7
8000492e:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80004932:	0e 4e       	or	lr,r7
80004934:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80004938:	fd e7 10 5e 	or	lr,lr,r7<<0x5
8000493c:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80004940:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80004944:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80004948:	fd e7 10 3e 	or	lr,lr,r7<<0x3
8000494c:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80004950:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80004954:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004958:	fd e8 10 18 	or	r8,lr,r8<<0x1
8000495c:	f6 0e 15 06 	lsl	lr,r11,0x6
80004960:	f8 0e 00 0e 	add	lr,r12,lr
80004964:	2d ce       	sub	lr,-36
80004966:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80004968:	58 09       	cp.w	r9,0
8000496a:	c0 20       	breq	8000496e <tc_configure_interrupts+0x6a>
8000496c:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
8000496e:	74 08       	ld.w	r8,r10[0x0]
80004970:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80004974:	e0 65 00 80 	mov	r5,128
80004978:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
8000497c:	74 08       	ld.w	r8,r10[0x0]
8000497e:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80004982:	f9 b4 00 40 	moveq	r4,64
80004986:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
8000498a:	74 08       	ld.w	r8,r10[0x0]
8000498c:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80004990:	f9 b3 00 20 	moveq	r3,32
80004994:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80004998:	74 08       	ld.w	r8,r10[0x0]
8000499a:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
8000499e:	f9 b2 00 10 	moveq	r2,16
800049a2:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
800049a6:	74 08       	ld.w	r8,r10[0x0]
800049a8:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
800049ac:	f9 b6 00 08 	moveq	r6,8
800049b0:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
800049b4:	74 08       	ld.w	r8,r10[0x0]
800049b6:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
800049ba:	f9 b7 00 04 	moveq	r7,4
800049be:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
800049c2:	74 08       	ld.w	r8,r10[0x0]
800049c4:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
800049c8:	f9 be 00 02 	moveq	lr,2
800049cc:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
800049d0:	74 08       	ld.w	r8,r10[0x0]
800049d2:	ec 18 00 01 	eorl	r8,0x1
800049d6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800049da:	eb e8 10 08 	or	r8,r5,r8
800049de:	08 48       	or	r8,r4
800049e0:	06 48       	or	r8,r3
800049e2:	04 48       	or	r8,r2
800049e4:	0c 48       	or	r8,r6
800049e6:	0e 48       	or	r8,r7
800049e8:	1c 48       	or	r8,lr
800049ea:	f6 0a 15 06 	lsl	r10,r11,0x6
800049ee:	f8 0a 00 0a 	add	r10,r12,r10
800049f2:	2d 8a       	sub	r10,-40
800049f4:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
800049f6:	a7 6b       	lsl	r11,0x6
800049f8:	2e 0b       	sub	r11,-32
800049fa:	16 0c       	add	r12,r11
800049fc:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
800049fe:	58 09       	cp.w	r9,0
80004a00:	c0 31       	brne	80004a06 <tc_configure_interrupts+0x102>
80004a02:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80004a06:	d5 03       	csrf	0x10
80004a08:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

80004a0c <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80004a0c:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80004a0e:	f6 08 15 04 	lsl	r8,r11,0x4
80004a12:	14 38       	cp.w	r8,r10
80004a14:	f9 b8 08 10 	movls	r8,16
80004a18:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80004a1c:	f0 0b 02 4b 	mul	r11,r8,r11
80004a20:	f6 09 16 01 	lsr	r9,r11,0x1
80004a24:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80004a28:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80004a2c:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004a30:	f2 cb 00 01 	sub	r11,r9,1
80004a34:	e0 4b ff fe 	cp.w	r11,65534
80004a38:	e0 88 00 03 	brls	80004a3e <usart_set_async_baudrate+0x32>
80004a3c:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004a3e:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004a40:	e8 6e 00 00 	mov	lr,524288
80004a44:	59 08       	cp.w	r8,16
80004a46:	fc 08 17 10 	movne	r8,lr
80004a4a:	f9 b8 00 00 	moveq	r8,0
80004a4e:	e4 1b ff f7 	andh	r11,0xfff7
80004a52:	e0 1b fe cf 	andl	r11,0xfecf
80004a56:	16 48       	or	r8,r11
80004a58:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80004a5a:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80004a5e:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80004a62:	99 89       	st.w	r12[0x20],r9
80004a64:	d8 0a       	popm	pc,r12=0

80004a66 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004a66:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80004a68:	e2 18 00 02 	andl	r8,0x2,COH
80004a6c:	c0 31       	brne	80004a72 <usart_write_char+0xc>
80004a6e:	30 2c       	mov	r12,2
80004a70:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004a72:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80004a76:	99 7b       	st.w	r12[0x1c],r11
80004a78:	5e fd       	retal	0
80004a7a:	d7 03       	nop

80004a7c <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004a7c:	eb cd 40 e0 	pushm	r5-r7,lr
80004a80:	18 96       	mov	r6,r12
80004a82:	16 95       	mov	r5,r11
80004a84:	e0 67 27 0f 	mov	r7,9999
80004a88:	c0 68       	rjmp	80004a94 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80004a8a:	58 07       	cp.w	r7,0
80004a8c:	c0 31       	brne	80004a92 <usart_putchar+0x16>
80004a8e:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80004a92:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004a94:	0a 9b       	mov	r11,r5
80004a96:	0c 9c       	mov	r12,r6
80004a98:	f0 1f 00 03 	mcall	80004aa4 <usart_putchar+0x28>
80004a9c:	cf 71       	brne	80004a8a <usart_putchar+0xe>

  return USART_SUCCESS;
}
80004a9e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004aa2:	00 00       	add	r0,r0
80004aa4:	80 00       	ld.sh	r0,r0[0x0]
80004aa6:	4a 66       	lddpc	r6,80004b3c <usart_reset+0x20>

80004aa8 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004aa8:	78 58       	ld.w	r8,r12[0x14]
80004aaa:	e2 18 00 e0 	andl	r8,0xe0,COH
80004aae:	c0 30       	breq	80004ab4 <usart_read_char+0xc>
80004ab0:	30 4c       	mov	r12,4
80004ab2:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004ab4:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004ab6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004aba:	c0 31       	brne	80004ac0 <usart_read_char+0x18>
80004abc:	30 3c       	mov	r12,3
80004abe:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004ac0:	78 68       	ld.w	r8,r12[0x18]
80004ac2:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80004ac6:	97 08       	st.w	r11[0x0],r8
80004ac8:	5e fd       	retal	0
80004aca:	d7 03       	nop

80004acc <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80004acc:	eb cd 40 c0 	pushm	r6-r7,lr
80004ad0:	20 1d       	sub	sp,4
80004ad2:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004ad4:	1a 97       	mov	r7,sp
80004ad6:	1a 9b       	mov	r11,sp
80004ad8:	0c 9c       	mov	r12,r6
80004ada:	f0 1f 00 07 	mcall	80004af4 <usart_getchar+0x28>
80004ade:	58 3c       	cp.w	r12,3
80004ae0:	cf b0       	breq	80004ad6 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80004ae2:	58 4c       	cp.w	r12,4
80004ae4:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80004ae8:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80004aec:	2f fd       	sub	sp,-4
80004aee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004af2:	00 00       	add	r0,r0
80004af4:	80 00       	ld.sh	r0,r0[0x0]
80004af6:	4a a8       	lddpc	r8,80004b9c <usart_init_rs232+0x54>

80004af8 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80004af8:	eb cd 40 c0 	pushm	r6-r7,lr
80004afc:	18 96       	mov	r6,r12
80004afe:	16 97       	mov	r7,r11
  while (*string != '\0')
80004b00:	17 8b       	ld.ub	r11,r11[0x0]
80004b02:	58 0b       	cp.w	r11,0
80004b04:	c0 80       	breq	80004b14 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80004b06:	2f f7       	sub	r7,-1
80004b08:	0c 9c       	mov	r12,r6
80004b0a:	f0 1f 00 04 	mcall	80004b18 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80004b0e:	0f 8b       	ld.ub	r11,r7[0x0]
80004b10:	58 0b       	cp.w	r11,0
80004b12:	cf a1       	brne	80004b06 <usart_write_line+0xe>
80004b14:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b18:	80 00       	ld.sh	r0,r0[0x0]
80004b1a:	4a 7c       	lddpc	r12,80004bb4 <usart_init_rs232+0x6c>

80004b1c <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80004b1c:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80004b20:	e6 18 00 01 	andh	r8,0x1,COH
80004b24:	c0 71       	brne	80004b32 <usart_reset+0x16>
80004b26:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80004b28:	3f f8       	mov	r8,-1
80004b2a:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004b2c:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80004b2e:	d5 03       	csrf	0x10
80004b30:	c0 48       	rjmp	80004b38 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80004b32:	3f f8       	mov	r8,-1
80004b34:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004b36:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004b38:	30 08       	mov	r8,0
80004b3a:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80004b3c:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80004b3e:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80004b40:	ea 68 61 0c 	mov	r8,680204
80004b44:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004b46:	5e fc       	retal	r12

80004b48 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004b48:	eb cd 40 e0 	pushm	r5-r7,lr
80004b4c:	18 96       	mov	r6,r12
80004b4e:	16 97       	mov	r7,r11
80004b50:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004b52:	f0 1f 00 2f 	mcall	80004c0c <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80004b56:	58 07       	cp.w	r7,0
80004b58:	c5 80       	breq	80004c08 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80004b5a:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004b5c:	30 49       	mov	r9,4
80004b5e:	f2 08 18 00 	cp.b	r8,r9
80004b62:	e0 88 00 53 	brls	80004c08 <usart_init_rs232+0xc0>
80004b66:	30 99       	mov	r9,9
80004b68:	f2 08 18 00 	cp.b	r8,r9
80004b6c:	e0 8b 00 4e 	brhi	80004c08 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004b70:	0f d9       	ld.ub	r9,r7[0x5]
80004b72:	30 78       	mov	r8,7
80004b74:	f0 09 18 00 	cp.b	r9,r8
80004b78:	e0 8b 00 48 	brhi	80004c08 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80004b7c:	8e 39       	ld.sh	r9,r7[0x6]
80004b7e:	e0 68 01 01 	mov	r8,257
80004b82:	f0 09 19 00 	cp.h	r9,r8
80004b86:	e0 8b 00 41 	brhi	80004c08 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80004b8a:	ef 39 00 08 	ld.ub	r9,r7[8]
80004b8e:	30 38       	mov	r8,3
80004b90:	f0 09 18 00 	cp.b	r9,r8
80004b94:	e0 8b 00 3a 	brhi	80004c08 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004b98:	0a 9a       	mov	r10,r5
80004b9a:	6e 0b       	ld.w	r11,r7[0x0]
80004b9c:	0c 9c       	mov	r12,r6
80004b9e:	f0 1f 00 1d 	mcall	80004c10 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004ba2:	58 1c       	cp.w	r12,1
80004ba4:	c3 20       	breq	80004c08 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80004ba6:	0f c8       	ld.ub	r8,r7[0x4]
80004ba8:	30 99       	mov	r9,9
80004baa:	f2 08 18 00 	cp.b	r8,r9
80004bae:	c0 51       	brne	80004bb8 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004bb0:	6c 18       	ld.w	r8,r6[0x4]
80004bb2:	b1 b8       	sbr	r8,0x11
80004bb4:	8d 18       	st.w	r6[0x4],r8
80004bb6:	c0 68       	rjmp	80004bc2 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004bb8:	6c 19       	ld.w	r9,r6[0x4]
80004bba:	20 58       	sub	r8,5
80004bbc:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80004bc0:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004bc2:	6c 19       	ld.w	r9,r6[0x4]
80004bc4:	ef 3a 00 08 	ld.ub	r10,r7[8]
80004bc8:	0f d8       	ld.ub	r8,r7[0x5]
80004bca:	a9 78       	lsl	r8,0x9
80004bcc:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80004bd0:	12 48       	or	r8,r9
80004bd2:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004bd4:	8e 38       	ld.sh	r8,r7[0x6]
80004bd6:	30 29       	mov	r9,2
80004bd8:	f2 08 19 00 	cp.h	r8,r9
80004bdc:	e0 88 00 09 	brls	80004bee <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004be0:	6c 18       	ld.w	r8,r6[0x4]
80004be2:	ad b8       	sbr	r8,0xd
80004be4:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004be6:	8e b8       	ld.uh	r8,r7[0x6]
80004be8:	20 28       	sub	r8,2
80004bea:	8d a8       	st.w	r6[0x28],r8
80004bec:	c0 68       	rjmp	80004bf8 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004bee:	6c 19       	ld.w	r9,r6[0x4]
80004bf0:	5c 78       	castu.h	r8
80004bf2:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80004bf6:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004bf8:	6c 18       	ld.w	r8,r6[0x4]
80004bfa:	e0 18 ff f0 	andl	r8,0xfff0
80004bfe:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004c00:	35 08       	mov	r8,80
80004c02:	8d 08       	st.w	r6[0x0],r8
80004c04:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004c08:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80004c0c:	80 00       	ld.sh	r0,r0[0x0]
80004c0e:	4b 1c       	lddpc	r12,80004cd0 <pxPortInitialiseStack+0x2c>
80004c10:	80 00       	ld.sh	r0,r0[0x0]
80004c12:	4a 0c       	lddpc	r12,80004c90 <vListRemove+0x12>

80004c14 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004c14:	f8 c8 ff f8 	sub	r8,r12,-8
80004c18:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004c1a:	3f f9       	mov	r9,-1
80004c1c:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004c1e:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004c20:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004c22:	30 08       	mov	r8,0
80004c24:	99 08       	st.w	r12[0x0],r8
}
80004c26:	5e fc       	retal	r12

80004c28 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004c28:	30 08       	mov	r8,0
80004c2a:	99 48       	st.w	r12[0x10],r8
}
80004c2c:	5e fc       	retal	r12

80004c2e <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004c2e:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80004c30:	70 19       	ld.w	r9,r8[0x4]
80004c32:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004c34:	78 19       	ld.w	r9,r12[0x4]
80004c36:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004c38:	70 19       	ld.w	r9,r8[0x4]
80004c3a:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004c3c:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004c3e:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004c40:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004c42:	78 08       	ld.w	r8,r12[0x0]
80004c44:	2f f8       	sub	r8,-1
80004c46:	99 08       	st.w	r12[0x0],r8
}
80004c48:	5e fc       	retal	r12

80004c4a <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004c4a:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004c4c:	5b fa       	cp.w	r10,-1
80004c4e:	c0 31       	brne	80004c54 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004c50:	78 48       	ld.w	r8,r12[0x10]
80004c52:	c0 c8       	rjmp	80004c6a <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004c54:	f8 c8 ff f8 	sub	r8,r12,-8
80004c58:	70 19       	ld.w	r9,r8[0x4]
80004c5a:	72 09       	ld.w	r9,r9[0x0]
80004c5c:	12 3a       	cp.w	r10,r9
80004c5e:	c0 63       	brcs	80004c6a <vListInsert+0x20>
80004c60:	70 18       	ld.w	r8,r8[0x4]
80004c62:	70 19       	ld.w	r9,r8[0x4]
80004c64:	72 09       	ld.w	r9,r9[0x0]
80004c66:	12 3a       	cp.w	r10,r9
80004c68:	cf c2       	brcc	80004c60 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80004c6a:	70 19       	ld.w	r9,r8[0x4]
80004c6c:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004c6e:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80004c70:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80004c72:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004c74:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004c76:	78 08       	ld.w	r8,r12[0x0]
80004c78:	2f f8       	sub	r8,-1
80004c7a:	99 08       	st.w	r12[0x0],r8
}
80004c7c:	5e fc       	retal	r12

80004c7e <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80004c7e:	78 18       	ld.w	r8,r12[0x4]
80004c80:	78 29       	ld.w	r9,r12[0x8]
80004c82:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80004c84:	78 28       	ld.w	r8,r12[0x8]
80004c86:	78 19       	ld.w	r9,r12[0x4]
80004c88:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80004c8a:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80004c8c:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80004c8e:	18 39       	cp.w	r9,r12
80004c90:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80004c94:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004c98:	30 09       	mov	r9,0
80004c9a:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80004c9c:	70 09       	ld.w	r9,r8[0x0]
80004c9e:	20 19       	sub	r9,1
80004ca0:	91 09       	st.w	r8[0x0],r9
}
80004ca2:	5e fc       	retal	r12

80004ca4 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80004ca4:	e0 68 08 08 	mov	r8,2056
80004ca8:	ea 18 08 08 	orh	r8,0x808
80004cac:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80004cae:	e0 68 09 09 	mov	r8,2313
80004cb2:	ea 18 09 09 	orh	r8,0x909
80004cb6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80004cb8:	e0 68 0a 0a 	mov	r8,2570
80004cbc:	ea 18 0a 0a 	orh	r8,0xa0a
80004cc0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80004cc2:	e0 68 0b 0b 	mov	r8,2827
80004cc6:	ea 18 0b 0b 	orh	r8,0xb0b
80004cca:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80004ccc:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80004cce:	e0 68 be ef 	mov	r8,48879
80004cd2:	ea 18 de ad 	orh	r8,0xdead
80004cd6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80004cd8:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80004cda:	fc 18 00 40 	movh	r8,0x40
80004cde:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80004ce0:	e0 68 00 ff 	mov	r8,255
80004ce4:	ea 18 ff 00 	orh	r8,0xff00
80004ce8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80004cea:	e0 68 01 01 	mov	r8,257
80004cee:	ea 18 01 01 	orh	r8,0x101
80004cf2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80004cf4:	e0 68 02 02 	mov	r8,514
80004cf8:	ea 18 02 02 	orh	r8,0x202
80004cfc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80004cfe:	e0 68 03 03 	mov	r8,771
80004d02:	ea 18 03 03 	orh	r8,0x303
80004d06:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80004d08:	e0 68 04 04 	mov	r8,1028
80004d0c:	ea 18 04 04 	orh	r8,0x404
80004d10:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80004d12:	e0 68 05 05 	mov	r8,1285
80004d16:	ea 18 05 05 	orh	r8,0x505
80004d1a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80004d1c:	e0 68 06 06 	mov	r8,1542
80004d20:	ea 18 06 06 	orh	r8,0x606
80004d24:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80004d26:	e0 68 07 07 	mov	r8,1799
80004d2a:	ea 18 07 07 	orh	r8,0x707
80004d2e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80004d30:	30 08       	mov	r8,0
80004d32:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80004d34:	5e fc       	retal	r12
80004d36:	d7 03       	nop

80004d38 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80004d38:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80004d3a:	48 38       	lddpc	r8,80004d44 <vPortEnterCritical+0xc>
80004d3c:	70 09       	ld.w	r9,r8[0x0]
80004d3e:	2f f9       	sub	r9,-1
80004d40:	91 09       	st.w	r8[0x0],r9
}
80004d42:	5e fc       	retal	r12
80004d44:	00 00       	add	r0,r0
80004d46:	05 28       	ld.uh	r8,r2++

80004d48 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80004d48:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80004d4a:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80004d4c:	30 0a       	mov	r10,0
80004d4e:	14 9b       	mov	r11,r10
80004d50:	49 2c       	lddpc	r12,80004d98 <xPortStartScheduler+0x50>
80004d52:	f0 1f 00 13 	mcall	80004d9c <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80004d56:	e0 68 5d c0 	mov	r8,24000
80004d5a:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80004d5e:	30 08       	mov	r8,0
80004d60:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80004d64:	e0 68 0c d0 	mov	r8,3280
80004d68:	ea 18 00 00 	orh	r8,0x0
80004d6c:	70 00       	ld.w	r0,r8[0x0]
80004d6e:	60 0d       	ld.w	sp,r0[0x0]
80004d70:	1b 00       	ld.w	r0,sp++
80004d72:	e0 68 05 28 	mov	r8,1320
80004d76:	ea 18 00 00 	orh	r8,0x0
80004d7a:	91 00       	st.w	r8[0x0],r0
80004d7c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004d80:	2f ed       	sub	sp,-8
80004d82:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80004d86:	fa f0 ff e0 	ld.w	r0,sp[-32]
80004d8a:	e3 b0 00 00 	mtsr	0x0,r0
80004d8e:	fa f0 ff dc 	ld.w	r0,sp[-36]
80004d92:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80004d96:	d8 0a       	popm	pc,r12=0
80004d98:	80 00       	ld.sh	r0,r0[0x0]
80004d9a:	4e 64       	lddpc	r4,80004f30 <_read+0x30>
80004d9c:	80 00       	ld.sh	r0,r0[0x0]
80004d9e:	47 04       	lddsp	r4,sp[0x1c0]

80004da0 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80004da0:	20 6d       	sub	sp,24
80004da2:	eb cd 00 ff 	pushm	r0-r7
80004da6:	fa c7 ff c0 	sub	r7,sp,-64
80004daa:	ee f0 ff f8 	ld.w	r0,r7[-8]
80004dae:	ef 40 ff e0 	st.w	r7[-32],r0
80004db2:	ee f0 ff fc 	ld.w	r0,r7[-4]
80004db6:	ef 40 ff e4 	st.w	r7[-28],r0
80004dba:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80004dbe:	e0 68 05 28 	mov	r8,1320
80004dc2:	ea 18 00 00 	orh	r8,0x0
80004dc6:	70 00       	ld.w	r0,r8[0x0]
80004dc8:	1a d0       	st.w	--sp,r0
80004dca:	f0 1f 00 1a 	mcall	80004e30 <LABEL_RET_SCALL_263+0x14>
80004dce:	e0 68 0c d0 	mov	r8,3280
80004dd2:	ea 18 00 00 	orh	r8,0x0
80004dd6:	70 00       	ld.w	r0,r8[0x0]
80004dd8:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80004dda:	f0 1f 00 17 	mcall	80004e34 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80004dde:	e0 68 0c d0 	mov	r8,3280
80004de2:	ea 18 00 00 	orh	r8,0x0
80004de6:	70 00       	ld.w	r0,r8[0x0]
80004de8:	60 0d       	ld.w	sp,r0[0x0]
80004dea:	1b 00       	ld.w	r0,sp++
80004dec:	e0 68 05 28 	mov	r8,1320
80004df0:	ea 18 00 00 	orh	r8,0x0
80004df4:	91 00       	st.w	r8[0x0],r0
80004df6:	fa c7 ff d8 	sub	r7,sp,-40
80004dfa:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80004dfe:	ee f0 ff e0 	ld.w	r0,r7[-32]
80004e02:	e0 61 05 28 	mov	r1,1320
80004e06:	ea 11 00 00 	orh	r1,0x0
80004e0a:	62 02       	ld.w	r2,r1[0x0]
80004e0c:	58 02       	cp.w	r2,0
80004e0e:	c0 70       	breq	80004e1c <LABEL_RET_SCALL_263>
80004e10:	e4 c2 00 01 	sub	r2,r2,1
80004e14:	83 02       	st.w	r1[0x0],r2
80004e16:	58 02       	cp.w	r2,0
80004e18:	c0 21       	brne	80004e1c <LABEL_RET_SCALL_263>
80004e1a:	b1 c0       	cbr	r0,0x10

80004e1c <LABEL_RET_SCALL_263>:
80004e1c:	ef 40 ff f8 	st.w	r7[-8],r0
80004e20:	ee f0 ff e4 	ld.w	r0,r7[-28]
80004e24:	ef 40 ff fc 	st.w	r7[-4],r0
80004e28:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004e2c:	2f ad       	sub	sp,-24
80004e2e:	d6 13       	rets
80004e30:	80 00       	ld.sh	r0,r0[0x0]
80004e32:	4d 38       	lddpc	r8,80004f7c <vPortFree>
80004e34:	80 00       	ld.sh	r0,r0[0x0]
80004e36:	54 7c       	stdsp	sp[0x11c],r12

80004e38 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80004e38:	e1 b8 00 43 	mfsr	r8,0x10c
80004e3c:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80004e40:	5e fc       	retal	r12
80004e42:	d7 03       	nop

80004e44 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80004e44:	48 78       	lddpc	r8,80004e60 <vPortExitCritical+0x1c>
80004e46:	70 08       	ld.w	r8,r8[0x0]
80004e48:	58 08       	cp.w	r8,0
80004e4a:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80004e4c:	48 58       	lddpc	r8,80004e60 <vPortExitCritical+0x1c>
80004e4e:	70 09       	ld.w	r9,r8[0x0]
80004e50:	20 19       	sub	r9,1
80004e52:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80004e54:	70 08       	ld.w	r8,r8[0x0]
80004e56:	58 08       	cp.w	r8,0
80004e58:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80004e5a:	d5 03       	csrf	0x10
80004e5c:	5e fc       	retal	r12
80004e5e:	00 00       	add	r0,r0
80004e60:	00 00       	add	r0,r0
80004e62:	05 28       	ld.uh	r8,r2++

80004e64 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80004e64:	eb cd 00 ff 	pushm	r0-r7
80004e68:	e0 68 05 28 	mov	r8,1320
80004e6c:	ea 18 00 00 	orh	r8,0x0
80004e70:	70 00       	ld.w	r0,r8[0x0]
80004e72:	1a d0       	st.w	--sp,r0
80004e74:	7a 90       	ld.w	r0,sp[0x24]
80004e76:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004e7a:	58 10       	cp.w	r0,1
80004e7c:	e0 8b 00 08 	brhi	80004e8c <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80004e80:	e0 68 0c d0 	mov	r8,3280
80004e84:	ea 18 00 00 	orh	r8,0x0
80004e88:	70 00       	ld.w	r0,r8[0x0]
80004e8a:	81 0d       	st.w	r0[0x0],sp

80004e8c <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80004e8c:	f0 1f 00 12 	mcall	80004ed4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80004e90:	f0 1f 00 12 	mcall	80004ed8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80004e94:	f0 1f 00 12 	mcall	80004edc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80004e98:	f0 1f 00 12 	mcall	80004ee0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80004e9c:	7a 90       	ld.w	r0,sp[0x24]
80004e9e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004ea2:	58 10       	cp.w	r0,1
80004ea4:	e0 8b 00 0e 	brhi	80004ec0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80004ea8:	f0 1f 00 0c 	mcall	80004ed8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80004eac:	f0 1f 00 0e 	mcall	80004ee4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80004eb0:	f0 1f 00 0c 	mcall	80004ee0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80004eb4:	e0 68 0c d0 	mov	r8,3280
80004eb8:	ea 18 00 00 	orh	r8,0x0
80004ebc:	70 00       	ld.w	r0,r8[0x0]
80004ebe:	60 0d       	ld.w	sp,r0[0x0]

80004ec0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80004ec0:	1b 00       	ld.w	r0,sp++
80004ec2:	e0 68 05 28 	mov	r8,1320
80004ec6:	ea 18 00 00 	orh	r8,0x0
80004eca:	91 00       	st.w	r8[0x0],r0
80004ecc:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004ed0:	d6 03       	rete
80004ed2:	00 00       	add	r0,r0
80004ed4:	80 00       	ld.sh	r0,r0[0x0]
80004ed6:	4e 38       	lddpc	r8,80005060 <prvUnlockQueue+0x14>
80004ed8:	80 00       	ld.sh	r0,r0[0x0]
80004eda:	4d 38       	lddpc	r8,80005024 <xQueueReceiveFromISR+0x28>
80004edc:	80 00       	ld.sh	r0,r0[0x0]
80004ede:	56 80       	stdsp	sp[0x1a0],r0
80004ee0:	80 00       	ld.sh	r0,r0[0x0]
80004ee2:	4e 44       	lddpc	r4,80005070 <prvUnlockQueue+0x24>
80004ee4:	80 00       	ld.sh	r0,r0[0x0]
80004ee6:	54 7c       	stdsp	sp[0x11c],r12

80004ee8 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80004ee8:	d4 01       	pushm	lr
	vTaskSuspendAll();
80004eea:	f0 1f 00 02 	mcall	80004ef0 <__malloc_lock+0x8>
}
80004eee:	d8 02       	popm	pc
80004ef0:	80 00       	ld.sh	r0,r0[0x0]
80004ef2:	54 6c       	stdsp	sp[0x118],r12

80004ef4 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80004ef4:	d4 01       	pushm	lr
	xTaskResumeAll();
80004ef6:	f0 1f 00 02 	mcall	80004efc <__malloc_unlock+0x8>
}
80004efa:	d8 02       	popm	pc
80004efc:	80 00       	ld.sh	r0,r0[0x0]
80004efe:	58 28       	cp.w	r8,2

80004f00 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80004f00:	d4 21       	pushm	r4-r7,lr
80004f02:	16 95       	mov	r5,r11
80004f04:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80004f06:	58 0c       	cp.w	r12,0
80004f08:	c0 30       	breq	80004f0e <_read+0xe>
80004f0a:	3f f7       	mov	r7,-1
80004f0c:	c1 48       	rjmp	80004f34 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80004f0e:	58 0a       	cp.w	r10,0
80004f10:	e0 89 00 04 	brgt	80004f18 <_read+0x18>
80004f14:	30 07       	mov	r7,0
80004f16:	c0 f8       	rjmp	80004f34 <_read+0x34>
80004f18:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80004f1a:	48 84       	lddpc	r4,80004f38 <_read+0x38>
80004f1c:	68 0c       	ld.w	r12,r4[0x0]
80004f1e:	f0 1f 00 08 	mcall	80004f3c <_read+0x3c>
    if (c < 0)
80004f22:	c0 95       	brlt	80004f34 <_read+0x34>
      break;

    *ptr++ = c;
80004f24:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80004f28:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80004f2a:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80004f2e:	58 08       	cp.w	r8,0
80004f30:	fe 99 ff f6 	brgt	80004f1c <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80004f34:	0e 9c       	mov	r12,r7
80004f36:	d8 22       	popm	r4-r7,pc
80004f38:	00 00       	add	r0,r0
80004f3a:	40 c8       	lddsp	r8,sp[0x30]
80004f3c:	80 00       	ld.sh	r0,r0[0x0]
80004f3e:	4a cc       	lddpc	r12,80004fec <prvCopyDataFromQueue+0x20>

80004f40 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80004f40:	d4 21       	pushm	r4-r7,lr
80004f42:	16 95       	mov	r5,r11
80004f44:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80004f46:	20 1c       	sub	r12,1
80004f48:	58 2c       	cp.w	r12,2
80004f4a:	e0 8b 00 12 	brhi	80004f6e <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80004f4e:	58 0a       	cp.w	r10,0
80004f50:	c0 31       	brne	80004f56 <_write+0x16>
80004f52:	30 07       	mov	r7,0
80004f54:	c0 e8       	rjmp	80004f70 <_write+0x30>
80004f56:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80004f58:	48 74       	lddpc	r4,80004f74 <_write+0x34>
80004f5a:	68 0c       	ld.w	r12,r4[0x0]
80004f5c:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80004f60:	f0 1f 00 06 	mcall	80004f78 <_write+0x38>
80004f64:	c0 55       	brlt	80004f6e <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80004f66:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80004f68:	0e 36       	cp.w	r6,r7
80004f6a:	cf 81       	brne	80004f5a <_write+0x1a>
80004f6c:	c0 28       	rjmp	80004f70 <_write+0x30>
80004f6e:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80004f70:	0e 9c       	mov	r12,r7
80004f72:	d8 22       	popm	r4-r7,pc
80004f74:	00 00       	add	r0,r0
80004f76:	40 c8       	lddsp	r8,sp[0x30]
80004f78:	80 00       	ld.sh	r0,r0[0x0]
80004f7a:	4a 7c       	lddpc	r12,80005014 <xQueueReceiveFromISR+0x18>

80004f7c <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80004f7c:	eb cd 40 80 	pushm	r7,lr
80004f80:	18 97       	mov	r7,r12
	if( pv )
80004f82:	58 0c       	cp.w	r12,0
80004f84:	c0 80       	breq	80004f94 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80004f86:	f0 1f 00 05 	mcall	80004f98 <vPortFree+0x1c>
		{
			free( pv );
80004f8a:	0e 9c       	mov	r12,r7
80004f8c:	f0 1f 00 04 	mcall	80004f9c <vPortFree+0x20>
		}
		xTaskResumeAll();
80004f90:	f0 1f 00 04 	mcall	80004fa0 <vPortFree+0x24>
80004f94:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f98:	80 00       	ld.sh	r0,r0[0x0]
80004f9a:	54 6c       	stdsp	sp[0x118],r12
80004f9c:	80 00       	ld.sh	r0,r0[0x0]
80004f9e:	63 90       	ld.w	r0,r1[0x64]
80004fa0:	80 00       	ld.sh	r0,r0[0x0]
80004fa2:	58 28       	cp.w	r8,2

80004fa4 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80004fa4:	eb cd 40 80 	pushm	r7,lr
80004fa8:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80004faa:	f0 1f 00 06 	mcall	80004fc0 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80004fae:	0e 9c       	mov	r12,r7
80004fb0:	f0 1f 00 05 	mcall	80004fc4 <pvPortMalloc+0x20>
80004fb4:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80004fb6:	f0 1f 00 05 	mcall	80004fc8 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80004fba:	0e 9c       	mov	r12,r7
80004fbc:	e3 cd 80 80 	ldm	sp++,r7,pc
80004fc0:	80 00       	ld.sh	r0,r0[0x0]
80004fc2:	54 6c       	stdsp	sp[0x118],r12
80004fc4:	80 00       	ld.sh	r0,r0[0x0]
80004fc6:	63 a0       	ld.w	r0,r1[0x68]
80004fc8:	80 00       	ld.sh	r0,r0[0x0]
80004fca:	58 28       	cp.w	r8,2

80004fcc <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80004fcc:	d4 01       	pushm	lr
80004fce:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80004fd0:	78 09       	ld.w	r9,r12[0x0]
80004fd2:	58 09       	cp.w	r9,0
80004fd4:	c1 10       	breq	80004ff6 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80004fd6:	78 3a       	ld.w	r10,r12[0xc]
80004fd8:	79 09       	ld.w	r9,r12[0x40]
80004fda:	f4 09 00 09 	add	r9,r10,r9
80004fde:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80004fe0:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80004fe2:	14 39       	cp.w	r9,r10
80004fe4:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80004fe8:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80004fec:	79 0a       	ld.w	r10,r12[0x40]
80004fee:	78 3b       	ld.w	r11,r12[0xc]
80004ff0:	10 9c       	mov	r12,r8
80004ff2:	f0 1f 00 02 	mcall	80004ff8 <prvCopyDataFromQueue+0x2c>
80004ff6:	d8 02       	popm	pc
80004ff8:	80 00       	ld.sh	r0,r0[0x0]
80004ffa:	67 e8       	ld.w	r8,r3[0x78]

80004ffc <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80004ffc:	eb cd 40 c0 	pushm	r6-r7,lr
80005000:	18 97       	mov	r7,r12
80005002:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005004:	78 e8       	ld.w	r8,r12[0x38]
80005006:	58 08       	cp.w	r8,0
80005008:	c0 31       	brne	8000500e <xQueueReceiveFromISR+0x12>
8000500a:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
8000500e:	f0 1f 00 0e 	mcall	80005044 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005012:	6e e8       	ld.w	r8,r7[0x38]
80005014:	20 18       	sub	r8,1
80005016:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005018:	6f 18       	ld.w	r8,r7[0x44]
8000501a:	5b f8       	cp.w	r8,-1
8000501c:	c0 d1       	brne	80005036 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000501e:	6e 48       	ld.w	r8,r7[0x10]
80005020:	58 08       	cp.w	r8,0
80005022:	c0 f0       	breq	80005040 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005024:	ee cc ff f0 	sub	r12,r7,-16
80005028:	f0 1f 00 08 	mcall	80005048 <xQueueReceiveFromISR+0x4c>
8000502c:	c0 a0       	breq	80005040 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
8000502e:	30 1c       	mov	r12,1
80005030:	8d 0c       	st.w	r6[0x0],r12
80005032:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005036:	2f f8       	sub	r8,-1
80005038:	ef 48 00 44 	st.w	r7[68],r8
8000503c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005040:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005044:	80 00       	ld.sh	r0,r0[0x0]
80005046:	4f cc       	lddpc	r12,80005234 <prvCopyDataToQueue+0x4>
80005048:	80 00       	ld.sh	r0,r0[0x0]
8000504a:	56 04       	stdsp	sp[0x180],r4

8000504c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
8000504c:	eb cd 40 c0 	pushm	r6-r7,lr
80005050:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005052:	f0 1f 00 23 	mcall	800050dc <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005056:	6f 28       	ld.w	r8,r7[0x48]
80005058:	58 08       	cp.w	r8,0
8000505a:	e0 8a 00 18 	brle	8000508a <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000505e:	6e 98       	ld.w	r8,r7[0x24]
80005060:	58 08       	cp.w	r8,0
80005062:	c1 40       	breq	8000508a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005064:	ee c6 ff dc 	sub	r6,r7,-36
80005068:	c0 48       	rjmp	80005070 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000506a:	6e 98       	ld.w	r8,r7[0x24]
8000506c:	58 08       	cp.w	r8,0
8000506e:	c0 e0       	breq	8000508a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005070:	0c 9c       	mov	r12,r6
80005072:	f0 1f 00 1c 	mcall	800050e0 <prvUnlockQueue+0x94>
80005076:	c0 30       	breq	8000507c <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005078:	f0 1f 00 1b 	mcall	800050e4 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
8000507c:	6f 28       	ld.w	r8,r7[0x48]
8000507e:	20 18       	sub	r8,1
80005080:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005084:	58 08       	cp.w	r8,0
80005086:	fe 99 ff f2 	brgt	8000506a <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
8000508a:	3f f8       	mov	r8,-1
8000508c:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005090:	f0 1f 00 16 	mcall	800050e8 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005094:	f0 1f 00 12 	mcall	800050dc <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005098:	6f 18       	ld.w	r8,r7[0x44]
8000509a:	58 08       	cp.w	r8,0
8000509c:	e0 8a 00 18 	brle	800050cc <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800050a0:	6e 48       	ld.w	r8,r7[0x10]
800050a2:	58 08       	cp.w	r8,0
800050a4:	c1 40       	breq	800050cc <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800050a6:	ee c6 ff f0 	sub	r6,r7,-16
800050aa:	c0 48       	rjmp	800050b2 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800050ac:	6e 48       	ld.w	r8,r7[0x10]
800050ae:	58 08       	cp.w	r8,0
800050b0:	c0 e0       	breq	800050cc <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800050b2:	0c 9c       	mov	r12,r6
800050b4:	f0 1f 00 0b 	mcall	800050e0 <prvUnlockQueue+0x94>
800050b8:	c0 30       	breq	800050be <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800050ba:	f0 1f 00 0b 	mcall	800050e4 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
800050be:	6f 18       	ld.w	r8,r7[0x44]
800050c0:	20 18       	sub	r8,1
800050c2:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800050c6:	58 08       	cp.w	r8,0
800050c8:	fe 99 ff f2 	brgt	800050ac <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800050cc:	3f f8       	mov	r8,-1
800050ce:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
800050d2:	f0 1f 00 06 	mcall	800050e8 <prvUnlockQueue+0x9c>
}
800050d6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800050da:	00 00       	add	r0,r0
800050dc:	80 00       	ld.sh	r0,r0[0x0]
800050de:	4d 38       	lddpc	r8,80005228 <xQueueGenericReceive+0x13c>
800050e0:	80 00       	ld.sh	r0,r0[0x0]
800050e2:	56 04       	stdsp	sp[0x180],r4
800050e4:	80 00       	ld.sh	r0,r0[0x0]
800050e6:	55 10       	stdsp	sp[0x144],r0
800050e8:	80 00       	ld.sh	r0,r0[0x0]
800050ea:	4e 44       	lddpc	r4,80005278 <prvCopyDataToQueue+0x48>

800050ec <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
800050ec:	d4 31       	pushm	r0-r7,lr
800050ee:	20 5d       	sub	sp,20
800050f0:	18 97       	mov	r7,r12
800050f2:	50 0b       	stdsp	sp[0x0],r11
800050f4:	50 2a       	stdsp	sp[0x8],r10
800050f6:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800050f8:	f8 c2 ff dc 	sub	r2,r12,-36
800050fc:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800050fe:	fa c4 ff f4 	sub	r4,sp,-12
80005102:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005104:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005106:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
8000510a:	f0 1f 00 3e 	mcall	80005200 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000510e:	6e e8       	ld.w	r8,r7[0x38]
80005110:	58 08       	cp.w	r8,0
80005112:	c2 a0       	breq	80005166 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005114:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80005116:	40 0b       	lddsp	r11,sp[0x0]
80005118:	0e 9c       	mov	r12,r7
8000511a:	f0 1f 00 3b 	mcall	80005204 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
8000511e:	40 18       	lddsp	r8,sp[0x4]
80005120:	58 08       	cp.w	r8,0
80005122:	c1 51       	brne	8000514c <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80005124:	6e e8       	ld.w	r8,r7[0x38]
80005126:	20 18       	sub	r8,1
80005128:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000512a:	6e 08       	ld.w	r8,r7[0x0]
8000512c:	58 08       	cp.w	r8,0
8000512e:	c0 41       	brne	80005136 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005130:	f0 1f 00 36 	mcall	80005208 <xQueueGenericReceive+0x11c>
80005134:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005136:	6e 48       	ld.w	r8,r7[0x10]
80005138:	58 08       	cp.w	r8,0
8000513a:	c1 20       	breq	8000515e <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
8000513c:	ee cc ff f0 	sub	r12,r7,-16
80005140:	f0 1f 00 33 	mcall	8000520c <xQueueGenericReceive+0x120>
80005144:	58 1c       	cp.w	r12,1
80005146:	c0 c1       	brne	8000515e <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005148:	d7 33       	scall
8000514a:	c0 a8       	rjmp	8000515e <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
8000514c:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000514e:	6e 98       	ld.w	r8,r7[0x24]
80005150:	58 08       	cp.w	r8,0
80005152:	c0 60       	breq	8000515e <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005154:	04 9c       	mov	r12,r2
80005156:	f0 1f 00 2e 	mcall	8000520c <xQueueGenericReceive+0x120>
8000515a:	c0 20       	breq	8000515e <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
8000515c:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
8000515e:	f0 1f 00 2d 	mcall	80005210 <xQueueGenericReceive+0x124>
80005162:	30 1c       	mov	r12,1
				return pdPASS;
80005164:	c4 c8       	rjmp	800051fc <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005166:	40 28       	lddsp	r8,sp[0x8]
80005168:	58 08       	cp.w	r8,0
8000516a:	c0 51       	brne	80005174 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000516c:	f0 1f 00 29 	mcall	80005210 <xQueueGenericReceive+0x124>
80005170:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80005172:	c4 58       	rjmp	800051fc <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80005174:	58 05       	cp.w	r5,0
80005176:	c0 51       	brne	80005180 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005178:	08 9c       	mov	r12,r4
8000517a:	f0 1f 00 27 	mcall	80005214 <xQueueGenericReceive+0x128>
8000517e:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005180:	f0 1f 00 24 	mcall	80005210 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005184:	f0 1f 00 25 	mcall	80005218 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005188:	f0 1f 00 1e 	mcall	80005200 <xQueueGenericReceive+0x114>
8000518c:	6f 18       	ld.w	r8,r7[0x44]
8000518e:	5b f8       	cp.w	r8,-1
80005190:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005194:	6f 28       	ld.w	r8,r7[0x48]
80005196:	5b f8       	cp.w	r8,-1
80005198:	ef f1 0a 12 	st.weq	r7[0x48],r1
8000519c:	f0 1f 00 1d 	mcall	80005210 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800051a0:	06 9b       	mov	r11,r3
800051a2:	08 9c       	mov	r12,r4
800051a4:	f0 1f 00 1e 	mcall	8000521c <xQueueGenericReceive+0x130>
800051a8:	c2 41       	brne	800051f0 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800051aa:	f0 1f 00 16 	mcall	80005200 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
800051ae:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
800051b0:	f0 1f 00 18 	mcall	80005210 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
800051b4:	58 06       	cp.w	r6,0
800051b6:	c1 71       	brne	800051e4 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800051b8:	6e 08       	ld.w	r8,r7[0x0]
800051ba:	58 08       	cp.w	r8,0
800051bc:	c0 81       	brne	800051cc <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800051be:	f0 1f 00 11 	mcall	80005200 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800051c2:	6e 1c       	ld.w	r12,r7[0x4]
800051c4:	f0 1f 00 17 	mcall	80005220 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800051c8:	f0 1f 00 12 	mcall	80005210 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800051cc:	40 2b       	lddsp	r11,sp[0x8]
800051ce:	04 9c       	mov	r12,r2
800051d0:	f0 1f 00 15 	mcall	80005224 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
800051d4:	0e 9c       	mov	r12,r7
800051d6:	f0 1f 00 15 	mcall	80005228 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
800051da:	f0 1f 00 15 	mcall	8000522c <xQueueGenericReceive+0x140>
800051de:	c9 61       	brne	8000510a <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
800051e0:	d7 33       	scall
800051e2:	c9 4b       	rjmp	8000510a <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800051e4:	0e 9c       	mov	r12,r7
800051e6:	f0 1f 00 11 	mcall	80005228 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
800051ea:	f0 1f 00 11 	mcall	8000522c <xQueueGenericReceive+0x140>
800051ee:	c8 eb       	rjmp	8000510a <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800051f0:	0e 9c       	mov	r12,r7
800051f2:	f0 1f 00 0e 	mcall	80005228 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800051f6:	f0 1f 00 0e 	mcall	8000522c <xQueueGenericReceive+0x140>
800051fa:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800051fc:	2f bd       	sub	sp,-20
800051fe:	d8 32       	popm	r0-r7,pc
80005200:	80 00       	ld.sh	r0,r0[0x0]
80005202:	4d 38       	lddpc	r8,8000534c <xQueueGenericSend+0x54>
80005204:	80 00       	ld.sh	r0,r0[0x0]
80005206:	4f cc       	lddpc	r12,800053f4 <xQueueGenericSend+0xfc>
80005208:	80 00       	ld.sh	r0,r0[0x0]
8000520a:	55 1c       	stdsp	sp[0x144],r12
8000520c:	80 00       	ld.sh	r0,r0[0x0]
8000520e:	56 04       	stdsp	sp[0x180],r4
80005210:	80 00       	ld.sh	r0,r0[0x0]
80005212:	4e 44       	lddpc	r4,800053a0 <xQueueGenericSend+0xa8>
80005214:	80 00       	ld.sh	r0,r0[0x0]
80005216:	54 f8       	stdsp	sp[0x13c],r8
80005218:	80 00       	ld.sh	r0,r0[0x0]
8000521a:	54 6c       	stdsp	sp[0x118],r12
8000521c:	80 00       	ld.sh	r0,r0[0x0]
8000521e:	57 94       	stdsp	sp[0x1e4],r4
80005220:	80 00       	ld.sh	r0,r0[0x0]
80005222:	55 80       	stdsp	sp[0x160],r0
80005224:	80 00       	ld.sh	r0,r0[0x0]
80005226:	59 ec       	cp.w	r12,30
80005228:	80 00       	ld.sh	r0,r0[0x0]
8000522a:	50 4c       	stdsp	sp[0x10],r12
8000522c:	80 00       	ld.sh	r0,r0[0x0]
8000522e:	58 28       	cp.w	r8,2

80005230 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005230:	eb cd 40 80 	pushm	r7,lr
80005234:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80005236:	79 08       	ld.w	r8,r12[0x40]
80005238:	58 08       	cp.w	r8,0
8000523a:	c0 a1       	brne	8000524e <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000523c:	78 08       	ld.w	r8,r12[0x0]
8000523e:	58 08       	cp.w	r8,0
80005240:	c2 b1       	brne	80005296 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80005242:	78 1c       	ld.w	r12,r12[0x4]
80005244:	f0 1f 00 17 	mcall	800052a0 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005248:	30 08       	mov	r8,0
8000524a:	8f 18       	st.w	r7[0x4],r8
8000524c:	c2 58       	rjmp	80005296 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
8000524e:	58 0a       	cp.w	r10,0
80005250:	c1 01       	brne	80005270 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005252:	10 9a       	mov	r10,r8
80005254:	78 2c       	ld.w	r12,r12[0x8]
80005256:	f0 1f 00 14 	mcall	800052a4 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000525a:	6e 29       	ld.w	r9,r7[0x8]
8000525c:	6f 08       	ld.w	r8,r7[0x40]
8000525e:	f2 08 00 08 	add	r8,r9,r8
80005262:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005264:	6e 19       	ld.w	r9,r7[0x4]
80005266:	12 38       	cp.w	r8,r9
80005268:	c1 73       	brcs	80005296 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000526a:	6e 08       	ld.w	r8,r7[0x0]
8000526c:	8f 28       	st.w	r7[0x8],r8
8000526e:	c1 48       	rjmp	80005296 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005270:	10 9a       	mov	r10,r8
80005272:	78 3c       	ld.w	r12,r12[0xc]
80005274:	f0 1f 00 0c 	mcall	800052a4 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005278:	6f 08       	ld.w	r8,r7[0x40]
8000527a:	6e 39       	ld.w	r9,r7[0xc]
8000527c:	f2 08 01 08 	sub	r8,r9,r8
80005280:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80005282:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80005284:	12 38       	cp.w	r8,r9
80005286:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
8000528a:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
8000528e:	f3 d8 e3 19 	subcs	r9,r9,r8
80005292:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80005296:	6e e8       	ld.w	r8,r7[0x38]
80005298:	2f f8       	sub	r8,-1
8000529a:	8f e8       	st.w	r7[0x38],r8
}
8000529c:	e3 cd 80 80 	ldm	sp++,r7,pc
800052a0:	80 00       	ld.sh	r0,r0[0x0]
800052a2:	55 28       	stdsp	sp[0x148],r8
800052a4:	80 00       	ld.sh	r0,r0[0x0]
800052a6:	67 e8       	ld.w	r8,r3[0x78]

800052a8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800052a8:	eb cd 40 c0 	pushm	r6-r7,lr
800052ac:	18 97       	mov	r7,r12
800052ae:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800052b0:	78 ec       	ld.w	r12,r12[0x38]
800052b2:	6e f8       	ld.w	r8,r7[0x3c]
800052b4:	10 3c       	cp.w	r12,r8
800052b6:	c0 33       	brcs	800052bc <xQueueGenericSendFromISR+0x14>
800052b8:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800052bc:	12 9a       	mov	r10,r9
800052be:	0e 9c       	mov	r12,r7
800052c0:	f0 1f 00 0c 	mcall	800052f0 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800052c4:	6f 28       	ld.w	r8,r7[0x48]
800052c6:	5b f8       	cp.w	r8,-1
800052c8:	c0 d1       	brne	800052e2 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800052ca:	6e 98       	ld.w	r8,r7[0x24]
800052cc:	58 08       	cp.w	r8,0
800052ce:	c0 f0       	breq	800052ec <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800052d0:	ee cc ff dc 	sub	r12,r7,-36
800052d4:	f0 1f 00 08 	mcall	800052f4 <xQueueGenericSendFromISR+0x4c>
800052d8:	c0 a0       	breq	800052ec <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
800052da:	30 1c       	mov	r12,1
800052dc:	8d 0c       	st.w	r6[0x0],r12
800052de:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
800052e2:	2f f8       	sub	r8,-1
800052e4:	ef 48 00 48 	st.w	r7[72],r8
800052e8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800052ec:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800052f0:	80 00       	ld.sh	r0,r0[0x0]
800052f2:	52 30       	stdsp	sp[0x8c],r0
800052f4:	80 00       	ld.sh	r0,r0[0x0]
800052f6:	56 04       	stdsp	sp[0x180],r4

800052f8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800052f8:	d4 31       	pushm	r0-r7,lr
800052fa:	20 5d       	sub	sp,20
800052fc:	18 97       	mov	r7,r12
800052fe:	50 0b       	stdsp	sp[0x0],r11
80005300:	50 2a       	stdsp	sp[0x8],r10
80005302:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005304:	f8 c0 ff f0 	sub	r0,r12,-16
80005308:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000530a:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000530e:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005310:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80005314:	f0 1f 00 2f 	mcall	800053d0 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005318:	6e e9       	ld.w	r9,r7[0x38]
8000531a:	6e f8       	ld.w	r8,r7[0x3c]
8000531c:	10 39       	cp.w	r9,r8
8000531e:	c1 42       	brcc	80005346 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005320:	40 1a       	lddsp	r10,sp[0x4]
80005322:	40 0b       	lddsp	r11,sp[0x0]
80005324:	0e 9c       	mov	r12,r7
80005326:	f0 1f 00 2c 	mcall	800053d4 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000532a:	6e 98       	ld.w	r8,r7[0x24]
8000532c:	58 08       	cp.w	r8,0
8000532e:	c0 80       	breq	8000533e <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005330:	ee cc ff dc 	sub	r12,r7,-36
80005334:	f0 1f 00 29 	mcall	800053d8 <xQueueGenericSend+0xe0>
80005338:	58 1c       	cp.w	r12,1
8000533a:	c0 21       	brne	8000533e <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
8000533c:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
8000533e:	f0 1f 00 28 	mcall	800053dc <xQueueGenericSend+0xe4>
80005342:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80005344:	c4 38       	rjmp	800053ca <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005346:	40 28       	lddsp	r8,sp[0x8]
80005348:	58 08       	cp.w	r8,0
8000534a:	c0 51       	brne	80005354 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000534c:	f0 1f 00 24 	mcall	800053dc <xQueueGenericSend+0xe4>
80005350:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80005352:	c3 c8       	rjmp	800053ca <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80005354:	58 04       	cp.w	r4,0
80005356:	c0 51       	brne	80005360 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005358:	06 9c       	mov	r12,r3
8000535a:	f0 1f 00 22 	mcall	800053e0 <xQueueGenericSend+0xe8>
8000535e:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005360:	f0 1f 00 1f 	mcall	800053dc <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005364:	f0 1f 00 20 	mcall	800053e4 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005368:	f0 1f 00 1a 	mcall	800053d0 <xQueueGenericSend+0xd8>
8000536c:	6f 18       	ld.w	r8,r7[0x44]
8000536e:	5b f8       	cp.w	r8,-1
80005370:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005374:	6f 28       	ld.w	r8,r7[0x48]
80005376:	5b f8       	cp.w	r8,-1
80005378:	ef f1 0a 12 	st.weq	r7[0x48],r1
8000537c:	f0 1f 00 18 	mcall	800053dc <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005380:	04 9b       	mov	r11,r2
80005382:	06 9c       	mov	r12,r3
80005384:	f0 1f 00 19 	mcall	800053e8 <xQueueGenericSend+0xf0>
80005388:	c1 b1       	brne	800053be <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000538a:	f0 1f 00 12 	mcall	800053d0 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
8000538e:	6e e5       	ld.w	r5,r7[0x38]
80005390:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80005392:	f0 1f 00 13 	mcall	800053dc <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80005396:	0c 35       	cp.w	r5,r6
80005398:	c0 d1       	brne	800053b2 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000539a:	40 2b       	lddsp	r11,sp[0x8]
8000539c:	00 9c       	mov	r12,r0
8000539e:	f0 1f 00 14 	mcall	800053ec <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800053a2:	0e 9c       	mov	r12,r7
800053a4:	f0 1f 00 13 	mcall	800053f0 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800053a8:	f0 1f 00 13 	mcall	800053f4 <xQueueGenericSend+0xfc>
800053ac:	cb 41       	brne	80005314 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800053ae:	d7 33       	scall
800053b0:	cb 2b       	rjmp	80005314 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800053b2:	0e 9c       	mov	r12,r7
800053b4:	f0 1f 00 0f 	mcall	800053f0 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800053b8:	f0 1f 00 0f 	mcall	800053f4 <xQueueGenericSend+0xfc>
800053bc:	ca cb       	rjmp	80005314 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800053be:	0e 9c       	mov	r12,r7
800053c0:	f0 1f 00 0c 	mcall	800053f0 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800053c4:	f0 1f 00 0c 	mcall	800053f4 <xQueueGenericSend+0xfc>
800053c8:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800053ca:	2f bd       	sub	sp,-20
800053cc:	d8 32       	popm	r0-r7,pc
800053ce:	00 00       	add	r0,r0
800053d0:	80 00       	ld.sh	r0,r0[0x0]
800053d2:	4d 38       	lddpc	r8,8000551c <xTaskGetCurrentTaskHandle>
800053d4:	80 00       	ld.sh	r0,r0[0x0]
800053d6:	52 30       	stdsp	sp[0x8c],r0
800053d8:	80 00       	ld.sh	r0,r0[0x0]
800053da:	56 04       	stdsp	sp[0x180],r4
800053dc:	80 00       	ld.sh	r0,r0[0x0]
800053de:	4e 44       	lddpc	r4,8000556c <vTaskPriorityDisinherit+0x44>
800053e0:	80 00       	ld.sh	r0,r0[0x0]
800053e2:	54 f8       	stdsp	sp[0x13c],r8
800053e4:	80 00       	ld.sh	r0,r0[0x0]
800053e6:	54 6c       	stdsp	sp[0x118],r12
800053e8:	80 00       	ld.sh	r0,r0[0x0]
800053ea:	57 94       	stdsp	sp[0x1e4],r4
800053ec:	80 00       	ld.sh	r0,r0[0x0]
800053ee:	59 ec       	cp.w	r12,30
800053f0:	80 00       	ld.sh	r0,r0[0x0]
800053f2:	50 4c       	stdsp	sp[0x10],r12
800053f4:	80 00       	ld.sh	r0,r0[0x0]
800053f6:	58 28       	cp.w	r8,2

800053f8 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800053f8:	d4 21       	pushm	r4-r7,lr
800053fa:	18 97       	mov	r7,r12
800053fc:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800053fe:	58 0c       	cp.w	r12,0
80005400:	c2 f0       	breq	8000545e <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005402:	34 cc       	mov	r12,76
80005404:	f0 1f 00 17 	mcall	80005460 <xQueueCreate+0x68>
80005408:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000540a:	c2 a0       	breq	8000545e <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000540c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005410:	e8 cc ff ff 	sub	r12,r4,-1
80005414:	f0 1f 00 13 	mcall	80005460 <xQueueCreate+0x68>
80005418:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000541a:	c1 e0       	breq	80005456 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000541c:	f8 04 00 04 	add	r4,r12,r4
80005420:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005422:	30 08       	mov	r8,0
80005424:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005426:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005428:	ee c8 00 01 	sub	r8,r7,1
8000542c:	ad 38       	mul	r8,r6
8000542e:	10 0c       	add	r12,r8
80005430:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005432:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005434:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005438:	3f f8       	mov	r8,-1
8000543a:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000543e:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005442:	ea cc ff f0 	sub	r12,r5,-16
80005446:	f0 1f 00 08 	mcall	80005464 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000544a:	ea cc ff dc 	sub	r12,r5,-36
8000544e:	f0 1f 00 06 	mcall	80005464 <xQueueCreate+0x6c>
80005452:	0a 9c       	mov	r12,r5
80005454:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005456:	0a 9c       	mov	r12,r5
80005458:	f0 1f 00 04 	mcall	80005468 <xQueueCreate+0x70>
8000545c:	d8 2a       	popm	r4-r7,pc,r12=0
8000545e:	d8 2a       	popm	r4-r7,pc,r12=0
80005460:	80 00       	ld.sh	r0,r0[0x0]
80005462:	4f a4       	lddpc	r4,80005648 <xTaskRemoveFromEventList+0x44>
80005464:	80 00       	ld.sh	r0,r0[0x0]
80005466:	4c 14       	lddpc	r4,80005568 <vTaskPriorityDisinherit+0x40>
80005468:	80 00       	ld.sh	r0,r0[0x0]
8000546a:	4f 7c       	lddpc	r12,80005644 <xTaskRemoveFromEventList+0x40>

8000546c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
8000546c:	48 38       	lddpc	r8,80005478 <vTaskSuspendAll+0xc>
8000546e:	70 09       	ld.w	r9,r8[0x0]
80005470:	2f f9       	sub	r9,-1
80005472:	91 09       	st.w	r8[0x0],r9
}
80005474:	5e fc       	retal	r12
80005476:	00 00       	add	r0,r0
80005478:	00 00       	add	r0,r0
8000547a:	0d 00       	ld.w	r0,r6++

8000547c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
8000547c:	49 a8       	lddpc	r8,800054e4 <vTaskSwitchContext+0x68>
8000547e:	70 08       	ld.w	r8,r8[0x0]
80005480:	58 08       	cp.w	r8,0
80005482:	c0 b1       	brne	80005498 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005484:	49 98       	lddpc	r8,800054e8 <vTaskSwitchContext+0x6c>
80005486:	70 08       	ld.w	r8,r8[0x0]
80005488:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000548c:	49 89       	lddpc	r9,800054ec <vTaskSwitchContext+0x70>
8000548e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005492:	58 08       	cp.w	r8,0
80005494:	c0 60       	breq	800054a0 <vTaskSwitchContext+0x24>
80005496:	c1 18       	rjmp	800054b8 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005498:	30 19       	mov	r9,1
8000549a:	49 68       	lddpc	r8,800054f0 <vTaskSwitchContext+0x74>
8000549c:	91 09       	st.w	r8[0x0],r9
8000549e:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800054a0:	49 28       	lddpc	r8,800054e8 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800054a2:	49 3a       	lddpc	r10,800054ec <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800054a4:	70 09       	ld.w	r9,r8[0x0]
800054a6:	20 19       	sub	r9,1
800054a8:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800054aa:	70 09       	ld.w	r9,r8[0x0]
800054ac:	f2 09 00 29 	add	r9,r9,r9<<0x2
800054b0:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800054b4:	58 09       	cp.w	r9,0
800054b6:	cf 70       	breq	800054a4 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800054b8:	48 c8       	lddpc	r8,800054e8 <vTaskSwitchContext+0x6c>
800054ba:	70 08       	ld.w	r8,r8[0x0]
800054bc:	f0 08 00 28 	add	r8,r8,r8<<0x2
800054c0:	48 b9       	lddpc	r9,800054ec <vTaskSwitchContext+0x70>
800054c2:	f2 08 00 28 	add	r8,r9,r8<<0x2
800054c6:	70 19       	ld.w	r9,r8[0x4]
800054c8:	72 19       	ld.w	r9,r9[0x4]
800054ca:	91 19       	st.w	r8[0x4],r9
800054cc:	f0 ca ff f8 	sub	r10,r8,-8
800054d0:	14 39       	cp.w	r9,r10
800054d2:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800054d6:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800054da:	70 18       	ld.w	r8,r8[0x4]
800054dc:	70 39       	ld.w	r9,r8[0xc]
800054de:	48 68       	lddpc	r8,800054f4 <vTaskSwitchContext+0x78>
800054e0:	91 09       	st.w	r8[0x0],r9
800054e2:	5e fc       	retal	r12
800054e4:	00 00       	add	r0,r0
800054e6:	0d 00       	ld.w	r0,r6++
800054e8:	00 00       	add	r0,r0
800054ea:	0d 38       	ld.ub	r8,r6++
800054ec:	00 00       	add	r0,r0
800054ee:	0c 1c       	sub	r12,r6
800054f0:	00 00       	add	r0,r0
800054f2:	0d 20       	ld.uh	r0,r6++
800054f4:	00 00       	add	r0,r0
800054f6:	0c d0       	st.w	--r6,r0

800054f8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800054f8:	48 48       	lddpc	r8,80005508 <vTaskSetTimeOutState+0x10>
800054fa:	70 08       	ld.w	r8,r8[0x0]
800054fc:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800054fe:	48 48       	lddpc	r8,8000550c <vTaskSetTimeOutState+0x14>
80005500:	70 08       	ld.w	r8,r8[0x0]
80005502:	99 18       	st.w	r12[0x4],r8
}
80005504:	5e fc       	retal	r12
80005506:	00 00       	add	r0,r0
80005508:	00 00       	add	r0,r0
8000550a:	0c 14       	sub	r4,r6
8000550c:	00 00       	add	r0,r0
8000550e:	0c fc       	st.b	--r6,r12

80005510 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80005510:	30 19       	mov	r9,1
80005512:	48 28       	lddpc	r8,80005518 <vTaskMissedYield+0x8>
80005514:	91 09       	st.w	r8[0x0],r9
}
80005516:	5e fc       	retal	r12
80005518:	00 00       	add	r0,r0
8000551a:	0d 20       	ld.uh	r0,r6++

8000551c <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
8000551c:	48 28       	lddpc	r8,80005524 <xTaskGetCurrentTaskHandle+0x8>
8000551e:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80005520:	5e fc       	retal	r12
80005522:	00 00       	add	r0,r0
80005524:	00 00       	add	r0,r0
80005526:	0c d0       	st.w	--r6,r0

80005528 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80005528:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
8000552c:	58 0c       	cp.w	r12,0
8000552e:	c1 f0       	breq	8000556c <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005530:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80005532:	78 b9       	ld.w	r9,r12[0x2c]
80005534:	79 18       	ld.w	r8,r12[0x44]
80005536:	10 39       	cp.w	r9,r8
80005538:	c1 a0       	breq	8000556c <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000553a:	f8 c6 ff fc 	sub	r6,r12,-4
8000553e:	0c 9c       	mov	r12,r6
80005540:	f0 1f 00 0c 	mcall	80005570 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80005544:	6f 1c       	ld.w	r12,r7[0x44]
80005546:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005548:	f8 08 11 08 	rsub	r8,r12,8
8000554c:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000554e:	48 a8       	lddpc	r8,80005574 <vTaskPriorityDisinherit+0x4c>
80005550:	70 08       	ld.w	r8,r8[0x0]
80005552:	10 3c       	cp.w	r12,r8
80005554:	e0 88 00 04 	brls	8000555c <vTaskPriorityDisinherit+0x34>
80005558:	48 78       	lddpc	r8,80005574 <vTaskPriorityDisinherit+0x4c>
8000555a:	91 0c       	st.w	r8[0x0],r12
8000555c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005560:	0c 9b       	mov	r11,r6
80005562:	48 68       	lddpc	r8,80005578 <vTaskPriorityDisinherit+0x50>
80005564:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005568:	f0 1f 00 05 	mcall	8000557c <vTaskPriorityDisinherit+0x54>
8000556c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005570:	80 00       	ld.sh	r0,r0[0x0]
80005572:	4c 7e       	lddpc	lr,8000568c <vTaskIncrementTick+0xc>
80005574:	00 00       	add	r0,r0
80005576:	0d 38       	ld.ub	r8,r6++
80005578:	00 00       	add	r0,r0
8000557a:	0c 1c       	sub	r12,r6
8000557c:	80 00       	ld.sh	r0,r0[0x0]
8000557e:	4c 2e       	lddpc	lr,80005684 <vTaskIncrementTick+0x4>

80005580 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005580:	eb cd 40 c0 	pushm	r6-r7,lr
80005584:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80005586:	49 b8       	lddpc	r8,800055f0 <vTaskPriorityInherit+0x70>
80005588:	70 08       	ld.w	r8,r8[0x0]
8000558a:	78 b9       	ld.w	r9,r12[0x2c]
8000558c:	70 b8       	ld.w	r8,r8[0x2c]
8000558e:	10 39       	cp.w	r9,r8
80005590:	c2 d2       	brcc	800055ea <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80005592:	49 88       	lddpc	r8,800055f0 <vTaskPriorityInherit+0x70>
80005594:	70 08       	ld.w	r8,r8[0x0]
80005596:	70 b8       	ld.w	r8,r8[0x2c]
80005598:	f0 08 11 08 	rsub	r8,r8,8
8000559c:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000559e:	f2 09 00 28 	add	r8,r9,r9<<0x2
800055a2:	49 59       	lddpc	r9,800055f4 <vTaskPriorityInherit+0x74>
800055a4:	f2 08 00 28 	add	r8,r9,r8<<0x2
800055a8:	78 59       	ld.w	r9,r12[0x14]
800055aa:	10 39       	cp.w	r9,r8
800055ac:	c1 b1       	brne	800055e2 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800055ae:	f8 c6 ff fc 	sub	r6,r12,-4
800055b2:	0c 9c       	mov	r12,r6
800055b4:	f0 1f 00 11 	mcall	800055f8 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800055b8:	48 e8       	lddpc	r8,800055f0 <vTaskPriorityInherit+0x70>
800055ba:	70 08       	ld.w	r8,r8[0x0]
800055bc:	70 bc       	ld.w	r12,r8[0x2c]
800055be:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800055c0:	48 f8       	lddpc	r8,800055fc <vTaskPriorityInherit+0x7c>
800055c2:	70 08       	ld.w	r8,r8[0x0]
800055c4:	10 3c       	cp.w	r12,r8
800055c6:	e0 88 00 04 	brls	800055ce <vTaskPriorityInherit+0x4e>
800055ca:	48 d8       	lddpc	r8,800055fc <vTaskPriorityInherit+0x7c>
800055cc:	91 0c       	st.w	r8[0x0],r12
800055ce:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800055d2:	0c 9b       	mov	r11,r6
800055d4:	48 88       	lddpc	r8,800055f4 <vTaskPriorityInherit+0x74>
800055d6:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800055da:	f0 1f 00 0a 	mcall	80005600 <vTaskPriorityInherit+0x80>
800055de:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800055e2:	48 48       	lddpc	r8,800055f0 <vTaskPriorityInherit+0x70>
800055e4:	70 08       	ld.w	r8,r8[0x0]
800055e6:	70 b8       	ld.w	r8,r8[0x2c]
800055e8:	99 b8       	st.w	r12[0x2c],r8
800055ea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800055ee:	00 00       	add	r0,r0
800055f0:	00 00       	add	r0,r0
800055f2:	0c d0       	st.w	--r6,r0
800055f4:	00 00       	add	r0,r0
800055f6:	0c 1c       	sub	r12,r6
800055f8:	80 00       	ld.sh	r0,r0[0x0]
800055fa:	4c 7e       	lddpc	lr,80005714 <vTaskIncrementTick+0x94>
800055fc:	00 00       	add	r0,r0
800055fe:	0d 38       	ld.ub	r8,r6++
80005600:	80 00       	ld.sh	r0,r0[0x0]
80005602:	4c 2e       	lddpc	lr,80005708 <vTaskIncrementTick+0x88>

80005604 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80005604:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80005608:	78 38       	ld.w	r8,r12[0xc]
8000560a:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
8000560c:	ee c6 ff e8 	sub	r6,r7,-24
80005610:	0c 9c       	mov	r12,r6
80005612:	f0 1f 00 15 	mcall	80005664 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005616:	49 58       	lddpc	r8,80005668 <xTaskRemoveFromEventList+0x64>
80005618:	70 08       	ld.w	r8,r8[0x0]
8000561a:	58 08       	cp.w	r8,0
8000561c:	c1 71       	brne	8000564a <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000561e:	ee c6 ff fc 	sub	r6,r7,-4
80005622:	0c 9c       	mov	r12,r6
80005624:	f0 1f 00 10 	mcall	80005664 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005628:	6e bc       	ld.w	r12,r7[0x2c]
8000562a:	49 18       	lddpc	r8,8000566c <xTaskRemoveFromEventList+0x68>
8000562c:	70 08       	ld.w	r8,r8[0x0]
8000562e:	10 3c       	cp.w	r12,r8
80005630:	e0 88 00 04 	brls	80005638 <xTaskRemoveFromEventList+0x34>
80005634:	48 e8       	lddpc	r8,8000566c <xTaskRemoveFromEventList+0x68>
80005636:	91 0c       	st.w	r8[0x0],r12
80005638:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000563c:	0c 9b       	mov	r11,r6
8000563e:	48 d8       	lddpc	r8,80005670 <xTaskRemoveFromEventList+0x6c>
80005640:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005644:	f0 1f 00 0c 	mcall	80005674 <xTaskRemoveFromEventList+0x70>
80005648:	c0 58       	rjmp	80005652 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000564a:	0c 9b       	mov	r11,r6
8000564c:	48 bc       	lddpc	r12,80005678 <xTaskRemoveFromEventList+0x74>
8000564e:	f0 1f 00 0a 	mcall	80005674 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005652:	48 b8       	lddpc	r8,8000567c <xTaskRemoveFromEventList+0x78>
80005654:	70 08       	ld.w	r8,r8[0x0]
80005656:	6e b9       	ld.w	r9,r7[0x2c]
80005658:	70 b8       	ld.w	r8,r8[0x2c]
8000565a:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
8000565c:	5f 2c       	srhs	r12
8000565e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005662:	00 00       	add	r0,r0
80005664:	80 00       	ld.sh	r0,r0[0x0]
80005666:	4c 7e       	lddpc	lr,80005780 <vTaskIncrementTick+0x100>
80005668:	00 00       	add	r0,r0
8000566a:	0d 00       	ld.w	r0,r6++
8000566c:	00 00       	add	r0,r0
8000566e:	0d 38       	ld.ub	r8,r6++
80005670:	00 00       	add	r0,r0
80005672:	0c 1c       	sub	r12,r6
80005674:	80 00       	ld.sh	r0,r0[0x0]
80005676:	4c 2e       	lddpc	lr,8000577c <vTaskIncrementTick+0xfc>
80005678:	00 00       	add	r0,r0
8000567a:	0c d4       	st.w	--r6,r4
8000567c:	00 00       	add	r0,r0
8000567e:	0c d0       	st.w	--r6,r0

80005680 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005680:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005684:	4b 98       	lddpc	r8,80005768 <vTaskIncrementTick+0xe8>
80005686:	70 08       	ld.w	r8,r8[0x0]
80005688:	58 08       	cp.w	r8,0
8000568a:	c6 91       	brne	8000575c <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
8000568c:	4b 88       	lddpc	r8,8000576c <vTaskIncrementTick+0xec>
8000568e:	70 09       	ld.w	r9,r8[0x0]
80005690:	2f f9       	sub	r9,-1
80005692:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005694:	70 08       	ld.w	r8,r8[0x0]
80005696:	58 08       	cp.w	r8,0
80005698:	c1 a1       	brne	800056cc <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
8000569a:	4b 68       	lddpc	r8,80005770 <vTaskIncrementTick+0xf0>
8000569c:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000569e:	4b 69       	lddpc	r9,80005774 <vTaskIncrementTick+0xf4>
800056a0:	72 0b       	ld.w	r11,r9[0x0]
800056a2:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800056a4:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800056a6:	4b 59       	lddpc	r9,80005778 <vTaskIncrementTick+0xf8>
800056a8:	72 0a       	ld.w	r10,r9[0x0]
800056aa:	2f fa       	sub	r10,-1
800056ac:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800056ae:	70 08       	ld.w	r8,r8[0x0]
800056b0:	70 08       	ld.w	r8,r8[0x0]
800056b2:	58 08       	cp.w	r8,0
800056b4:	c0 51       	brne	800056be <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800056b6:	3f f9       	mov	r9,-1
800056b8:	4b 18       	lddpc	r8,8000577c <vTaskIncrementTick+0xfc>
800056ba:	91 09       	st.w	r8[0x0],r9
800056bc:	c0 88       	rjmp	800056cc <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800056be:	4a d8       	lddpc	r8,80005770 <vTaskIncrementTick+0xf0>
800056c0:	70 08       	ld.w	r8,r8[0x0]
800056c2:	70 38       	ld.w	r8,r8[0xc]
800056c4:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800056c6:	70 19       	ld.w	r9,r8[0x4]
800056c8:	4a d8       	lddpc	r8,8000577c <vTaskIncrementTick+0xfc>
800056ca:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800056cc:	4a 88       	lddpc	r8,8000576c <vTaskIncrementTick+0xec>
800056ce:	70 09       	ld.w	r9,r8[0x0]
800056d0:	4a b8       	lddpc	r8,8000577c <vTaskIncrementTick+0xfc>
800056d2:	70 08       	ld.w	r8,r8[0x0]
800056d4:	10 39       	cp.w	r9,r8
800056d6:	c4 73       	brcs	80005764 <vTaskIncrementTick+0xe4>
800056d8:	4a 68       	lddpc	r8,80005770 <vTaskIncrementTick+0xf0>
800056da:	70 08       	ld.w	r8,r8[0x0]
800056dc:	70 08       	ld.w	r8,r8[0x0]
800056de:	58 08       	cp.w	r8,0
800056e0:	c0 c0       	breq	800056f8 <vTaskIncrementTick+0x78>
800056e2:	4a 48       	lddpc	r8,80005770 <vTaskIncrementTick+0xf0>
800056e4:	70 08       	ld.w	r8,r8[0x0]
800056e6:	70 38       	ld.w	r8,r8[0xc]
800056e8:	70 37       	ld.w	r7,r8[0xc]
800056ea:	6e 18       	ld.w	r8,r7[0x4]
800056ec:	4a 09       	lddpc	r9,8000576c <vTaskIncrementTick+0xec>
800056ee:	72 09       	ld.w	r9,r9[0x0]
800056f0:	12 38       	cp.w	r8,r9
800056f2:	e0 88 00 14 	brls	8000571a <vTaskIncrementTick+0x9a>
800056f6:	c0 e8       	rjmp	80005712 <vTaskIncrementTick+0x92>
800056f8:	3f f9       	mov	r9,-1
800056fa:	4a 18       	lddpc	r8,8000577c <vTaskIncrementTick+0xfc>
800056fc:	91 09       	st.w	r8[0x0],r9
800056fe:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005702:	6a 08       	ld.w	r8,r5[0x0]
80005704:	70 38       	ld.w	r8,r8[0xc]
80005706:	70 37       	ld.w	r7,r8[0xc]
80005708:	6e 18       	ld.w	r8,r7[0x4]
8000570a:	64 09       	ld.w	r9,r2[0x0]
8000570c:	12 38       	cp.w	r8,r9
8000570e:	e0 88 00 0a 	brls	80005722 <vTaskIncrementTick+0xa2>
80005712:	49 b9       	lddpc	r9,8000577c <vTaskIncrementTick+0xfc>
80005714:	93 08       	st.w	r9[0x0],r8
80005716:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000571a:	49 a4       	lddpc	r4,80005780 <vTaskIncrementTick+0x100>
8000571c:	49 a3       	lddpc	r3,80005784 <vTaskIncrementTick+0x104>
8000571e:	49 55       	lddpc	r5,80005770 <vTaskIncrementTick+0xf0>
80005720:	49 32       	lddpc	r2,8000576c <vTaskIncrementTick+0xec>
80005722:	ee c6 ff fc 	sub	r6,r7,-4
80005726:	0c 9c       	mov	r12,r6
80005728:	f0 1f 00 18 	mcall	80005788 <vTaskIncrementTick+0x108>
8000572c:	6e a8       	ld.w	r8,r7[0x28]
8000572e:	58 08       	cp.w	r8,0
80005730:	c0 50       	breq	8000573a <vTaskIncrementTick+0xba>
80005732:	ee cc ff e8 	sub	r12,r7,-24
80005736:	f0 1f 00 15 	mcall	80005788 <vTaskIncrementTick+0x108>
8000573a:	6e bc       	ld.w	r12,r7[0x2c]
8000573c:	68 08       	ld.w	r8,r4[0x0]
8000573e:	10 3c       	cp.w	r12,r8
80005740:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005744:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005748:	0c 9b       	mov	r11,r6
8000574a:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000574e:	f0 1f 00 10 	mcall	8000578c <vTaskIncrementTick+0x10c>
80005752:	6a 08       	ld.w	r8,r5[0x0]
80005754:	70 08       	ld.w	r8,r8[0x0]
80005756:	58 08       	cp.w	r8,0
80005758:	cd 51       	brne	80005702 <vTaskIncrementTick+0x82>
8000575a:	cc fb       	rjmp	800056f8 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
8000575c:	48 d8       	lddpc	r8,80005790 <vTaskIncrementTick+0x110>
8000575e:	70 09       	ld.w	r9,r8[0x0]
80005760:	2f f9       	sub	r9,-1
80005762:	91 09       	st.w	r8[0x0],r9
80005764:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005768:	00 00       	add	r0,r0
8000576a:	0d 00       	ld.w	r0,r6++
8000576c:	00 00       	add	r0,r0
8000576e:	0c fc       	st.b	--r6,r12
80005770:	00 00       	add	r0,r0
80005772:	0c 08       	add	r8,r6
80005774:	00 00       	add	r0,r0
80005776:	0c 18       	sub	r8,r6
80005778:	00 00       	add	r0,r0
8000577a:	0c 14       	sub	r4,r6
8000577c:	00 00       	add	r0,r0
8000577e:	05 2c       	ld.uh	r12,r2++
80005780:	00 00       	add	r0,r0
80005782:	0d 38       	ld.ub	r8,r6++
80005784:	00 00       	add	r0,r0
80005786:	0c 1c       	sub	r12,r6
80005788:	80 00       	ld.sh	r0,r0[0x0]
8000578a:	4c 7e       	lddpc	lr,800058a4 <xTaskResumeAll+0x7c>
8000578c:	80 00       	ld.sh	r0,r0[0x0]
8000578e:	4c 2e       	lddpc	lr,80005894 <xTaskResumeAll+0x6c>
80005790:	00 00       	add	r0,r0
80005792:	0c 00       	add	r0,r6

80005794 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80005794:	eb cd 40 c0 	pushm	r6-r7,lr
80005798:	18 97       	mov	r7,r12
8000579a:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
8000579c:	f0 1f 00 15 	mcall	800057f0 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800057a0:	6c 08       	ld.w	r8,r6[0x0]
800057a2:	5b f8       	cp.w	r8,-1
800057a4:	c0 31       	brne	800057aa <xTaskCheckForTimeOut+0x16>
800057a6:	30 07       	mov	r7,0
800057a8:	c1 f8       	rjmp	800057e6 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800057aa:	49 39       	lddpc	r9,800057f4 <xTaskCheckForTimeOut+0x60>
800057ac:	72 09       	ld.w	r9,r9[0x0]
800057ae:	6e 0a       	ld.w	r10,r7[0x0]
800057b0:	12 3a       	cp.w	r10,r9
800057b2:	c0 70       	breq	800057c0 <xTaskCheckForTimeOut+0x2c>
800057b4:	49 19       	lddpc	r9,800057f8 <xTaskCheckForTimeOut+0x64>
800057b6:	72 09       	ld.w	r9,r9[0x0]
800057b8:	6e 1a       	ld.w	r10,r7[0x4]
800057ba:	12 3a       	cp.w	r10,r9
800057bc:	e0 88 00 14 	brls	800057e4 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800057c0:	48 e9       	lddpc	r9,800057f8 <xTaskCheckForTimeOut+0x64>
800057c2:	72 0a       	ld.w	r10,r9[0x0]
800057c4:	6e 19       	ld.w	r9,r7[0x4]
800057c6:	12 1a       	sub	r10,r9
800057c8:	14 38       	cp.w	r8,r10
800057ca:	e0 88 00 0d 	brls	800057e4 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800057ce:	48 ba       	lddpc	r10,800057f8 <xTaskCheckForTimeOut+0x64>
800057d0:	74 0a       	ld.w	r10,r10[0x0]
800057d2:	14 19       	sub	r9,r10
800057d4:	f2 08 00 08 	add	r8,r9,r8
800057d8:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800057da:	0e 9c       	mov	r12,r7
800057dc:	f0 1f 00 08 	mcall	800057fc <xTaskCheckForTimeOut+0x68>
800057e0:	30 07       	mov	r7,0
800057e2:	c0 28       	rjmp	800057e6 <xTaskCheckForTimeOut+0x52>
800057e4:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800057e6:	f0 1f 00 07 	mcall	80005800 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800057ea:	0e 9c       	mov	r12,r7
800057ec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800057f0:	80 00       	ld.sh	r0,r0[0x0]
800057f2:	4d 38       	lddpc	r8,8000593c <prvAddCurrentTaskToDelayedList+0x2c>
800057f4:	00 00       	add	r0,r0
800057f6:	0c 14       	sub	r4,r6
800057f8:	00 00       	add	r0,r0
800057fa:	0c fc       	st.b	--r6,r12
800057fc:	80 00       	ld.sh	r0,r0[0x0]
800057fe:	54 f8       	stdsp	sp[0x13c],r8
80005800:	80 00       	ld.sh	r0,r0[0x0]
80005802:	4e 44       	lddpc	r4,80005990 <vTaskDelayUntil+0x24>

80005804 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005804:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005808:	f0 1f 00 05 	mcall	8000581c <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
8000580c:	48 58       	lddpc	r8,80005820 <xTaskGetTickCount+0x1c>
8000580e:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80005810:	f0 1f 00 05 	mcall	80005824 <xTaskGetTickCount+0x20>

	return xTicks;
}
80005814:	0e 9c       	mov	r12,r7
80005816:	e3 cd 80 80 	ldm	sp++,r7,pc
8000581a:	00 00       	add	r0,r0
8000581c:	80 00       	ld.sh	r0,r0[0x0]
8000581e:	4d 38       	lddpc	r8,80005968 <prvAddCurrentTaskToDelayedList+0x58>
80005820:	00 00       	add	r0,r0
80005822:	0c fc       	st.b	--r6,r12
80005824:	80 00       	ld.sh	r0,r0[0x0]
80005826:	4e 44       	lddpc	r4,800059b4 <vTaskDelayUntil+0x48>

80005828 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005828:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
8000582c:	f0 1f 00 2c 	mcall	800058dc <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80005830:	4a c8       	lddpc	r8,800058e0 <xTaskResumeAll+0xb8>
80005832:	70 09       	ld.w	r9,r8[0x0]
80005834:	20 19       	sub	r9,1
80005836:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005838:	70 08       	ld.w	r8,r8[0x0]
8000583a:	58 08       	cp.w	r8,0
8000583c:	c4 91       	brne	800058ce <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000583e:	4a a8       	lddpc	r8,800058e4 <xTaskResumeAll+0xbc>
80005840:	70 08       	ld.w	r8,r8[0x0]
80005842:	58 08       	cp.w	r8,0
80005844:	c4 50       	breq	800058ce <xTaskResumeAll+0xa6>
80005846:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005848:	4a 85       	lddpc	r5,800058e8 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000584a:	4a 93       	lddpc	r3,800058ec <xTaskResumeAll+0xc4>
8000584c:	4a 92       	lddpc	r2,800058f0 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000584e:	4a a1       	lddpc	r1,800058f4 <xTaskResumeAll+0xcc>
80005850:	c1 e8       	rjmp	8000588c <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005852:	6a 38       	ld.w	r8,r5[0xc]
80005854:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80005856:	ee cc ff e8 	sub	r12,r7,-24
8000585a:	f0 1f 00 28 	mcall	800058f8 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000585e:	ee c6 ff fc 	sub	r6,r7,-4
80005862:	0c 9c       	mov	r12,r6
80005864:	f0 1f 00 25 	mcall	800058f8 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80005868:	6e bc       	ld.w	r12,r7[0x2c]
8000586a:	66 08       	ld.w	r8,r3[0x0]
8000586c:	10 3c       	cp.w	r12,r8
8000586e:	e7 fc ba 00 	st.whi	r3[0x0],r12
80005872:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005876:	0c 9b       	mov	r11,r6
80005878:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
8000587c:	f0 1f 00 20 	mcall	800058fc <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005880:	62 08       	ld.w	r8,r1[0x0]
80005882:	6e b9       	ld.w	r9,r7[0x2c]
80005884:	70 b8       	ld.w	r8,r8[0x2c]
80005886:	10 39       	cp.w	r9,r8
80005888:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000588c:	6a 08       	ld.w	r8,r5[0x0]
8000588e:	58 08       	cp.w	r8,0
80005890:	ce 11       	brne	80005852 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005892:	49 c8       	lddpc	r8,80005900 <xTaskResumeAll+0xd8>
80005894:	70 08       	ld.w	r8,r8[0x0]
80005896:	58 08       	cp.w	r8,0
80005898:	c0 f0       	breq	800058b6 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000589a:	49 a8       	lddpc	r8,80005900 <xTaskResumeAll+0xd8>
8000589c:	70 08       	ld.w	r8,r8[0x0]
8000589e:	58 08       	cp.w	r8,0
800058a0:	c1 10       	breq	800058c2 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800058a2:	49 87       	lddpc	r7,80005900 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800058a4:	f0 1f 00 18 	mcall	80005904 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800058a8:	6e 08       	ld.w	r8,r7[0x0]
800058aa:	20 18       	sub	r8,1
800058ac:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800058ae:	6e 08       	ld.w	r8,r7[0x0]
800058b0:	58 08       	cp.w	r8,0
800058b2:	cf 91       	brne	800058a4 <xTaskResumeAll+0x7c>
800058b4:	c0 78       	rjmp	800058c2 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800058b6:	58 14       	cp.w	r4,1
800058b8:	c0 50       	breq	800058c2 <xTaskResumeAll+0x9a>
800058ba:	49 48       	lddpc	r8,80005908 <xTaskResumeAll+0xe0>
800058bc:	70 08       	ld.w	r8,r8[0x0]
800058be:	58 18       	cp.w	r8,1
800058c0:	c0 71       	brne	800058ce <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800058c2:	30 09       	mov	r9,0
800058c4:	49 18       	lddpc	r8,80005908 <xTaskResumeAll+0xe0>
800058c6:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800058c8:	d7 33       	scall
800058ca:	30 17       	mov	r7,1
800058cc:	c0 28       	rjmp	800058d0 <xTaskResumeAll+0xa8>
800058ce:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800058d0:	f0 1f 00 0f 	mcall	8000590c <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800058d4:	0e 9c       	mov	r12,r7
800058d6:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800058da:	00 00       	add	r0,r0
800058dc:	80 00       	ld.sh	r0,r0[0x0]
800058de:	4d 38       	lddpc	r8,80005a28 <vTaskPlaceOnEventList+0x3c>
800058e0:	00 00       	add	r0,r0
800058e2:	0d 00       	ld.w	r0,r6++
800058e4:	00 00       	add	r0,r0
800058e6:	0d 1c       	ld.sh	r12,r6++
800058e8:	00 00       	add	r0,r0
800058ea:	0c d4       	st.w	--r6,r4
800058ec:	00 00       	add	r0,r0
800058ee:	0d 38       	ld.ub	r8,r6++
800058f0:	00 00       	add	r0,r0
800058f2:	0c 1c       	sub	r12,r6
800058f4:	00 00       	add	r0,r0
800058f6:	0c d0       	st.w	--r6,r0
800058f8:	80 00       	ld.sh	r0,r0[0x0]
800058fa:	4c 7e       	lddpc	lr,80005a14 <vTaskPlaceOnEventList+0x28>
800058fc:	80 00       	ld.sh	r0,r0[0x0]
800058fe:	4c 2e       	lddpc	lr,80005a04 <vTaskPlaceOnEventList+0x18>
80005900:	00 00       	add	r0,r0
80005902:	0c 00       	add	r0,r6
80005904:	80 00       	ld.sh	r0,r0[0x0]
80005906:	56 80       	stdsp	sp[0x1a0],r0
80005908:	00 00       	add	r0,r0
8000590a:	0d 20       	ld.uh	r0,r6++
8000590c:	80 00       	ld.sh	r0,r0[0x0]
8000590e:	4e 44       	lddpc	r4,80005a9c <prvIdleTask+0x58>

80005910 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80005910:	eb cd 40 80 	pushm	r7,lr
80005914:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005916:	49 08       	lddpc	r8,80005954 <prvAddCurrentTaskToDelayedList+0x44>
80005918:	70 08       	ld.w	r8,r8[0x0]
8000591a:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
8000591c:	48 f8       	lddpc	r8,80005958 <prvAddCurrentTaskToDelayedList+0x48>
8000591e:	70 08       	ld.w	r8,r8[0x0]
80005920:	10 3c       	cp.w	r12,r8
80005922:	c0 a2       	brcc	80005936 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005924:	48 c8       	lddpc	r8,80005954 <prvAddCurrentTaskToDelayedList+0x44>
80005926:	70 0b       	ld.w	r11,r8[0x0]
80005928:	48 d8       	lddpc	r8,8000595c <prvAddCurrentTaskToDelayedList+0x4c>
8000592a:	70 0c       	ld.w	r12,r8[0x0]
8000592c:	2f cb       	sub	r11,-4
8000592e:	f0 1f 00 0d 	mcall	80005960 <prvAddCurrentTaskToDelayedList+0x50>
80005932:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005936:	48 88       	lddpc	r8,80005954 <prvAddCurrentTaskToDelayedList+0x44>
80005938:	70 0b       	ld.w	r11,r8[0x0]
8000593a:	48 b8       	lddpc	r8,80005964 <prvAddCurrentTaskToDelayedList+0x54>
8000593c:	70 0c       	ld.w	r12,r8[0x0]
8000593e:	2f cb       	sub	r11,-4
80005940:	f0 1f 00 08 	mcall	80005960 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005944:	48 98       	lddpc	r8,80005968 <prvAddCurrentTaskToDelayedList+0x58>
80005946:	70 08       	ld.w	r8,r8[0x0]
80005948:	10 37       	cp.w	r7,r8
8000594a:	c0 32       	brcc	80005950 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
8000594c:	48 78       	lddpc	r8,80005968 <prvAddCurrentTaskToDelayedList+0x58>
8000594e:	91 07       	st.w	r8[0x0],r7
80005950:	e3 cd 80 80 	ldm	sp++,r7,pc
80005954:	00 00       	add	r0,r0
80005956:	0c d0       	st.w	--r6,r0
80005958:	00 00       	add	r0,r0
8000595a:	0c fc       	st.b	--r6,r12
8000595c:	00 00       	add	r0,r0
8000595e:	0c 18       	sub	r8,r6
80005960:	80 00       	ld.sh	r0,r0[0x0]
80005962:	4c 4a       	lddpc	r10,80005a70 <prvIdleTask+0x2c>
80005964:	00 00       	add	r0,r0
80005966:	0c 08       	add	r8,r6
80005968:	00 00       	add	r0,r0
8000596a:	05 2c       	ld.uh	r12,r2++

8000596c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
8000596c:	eb cd 40 c0 	pushm	r6-r7,lr
80005970:	18 96       	mov	r6,r12
80005972:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80005974:	f0 1f 00 18 	mcall	800059d4 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005978:	6c 08       	ld.w	r8,r6[0x0]
8000597a:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
8000597c:	49 79       	lddpc	r9,800059d8 <vTaskDelayUntil+0x6c>
8000597e:	72 09       	ld.w	r9,r9[0x0]
80005980:	12 38       	cp.w	r8,r9
80005982:	e0 88 00 0c 	brls	8000599a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005986:	0e 38       	cp.w	r8,r7
80005988:	e0 88 00 22 	brls	800059cc <vTaskDelayUntil+0x60>
8000598c:	49 38       	lddpc	r8,800059d8 <vTaskDelayUntil+0x6c>
8000598e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005990:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80005992:	10 37       	cp.w	r7,r8
80005994:	e0 88 00 14 	brls	800059bc <vTaskDelayUntil+0x50>
80005998:	c0 a8       	rjmp	800059ac <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
8000599a:	0e 38       	cp.w	r8,r7
8000599c:	e0 8b 00 16 	brhi	800059c8 <vTaskDelayUntil+0x5c>
800059a0:	48 e8       	lddpc	r8,800059d8 <vTaskDelayUntil+0x6c>
800059a2:	70 08       	ld.w	r8,r8[0x0]
800059a4:	10 37       	cp.w	r7,r8
800059a6:	e0 8b 00 11 	brhi	800059c8 <vTaskDelayUntil+0x5c>
800059aa:	c1 18       	rjmp	800059cc <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800059ac:	48 c8       	lddpc	r8,800059dc <vTaskDelayUntil+0x70>
800059ae:	70 0c       	ld.w	r12,r8[0x0]
800059b0:	2f cc       	sub	r12,-4
800059b2:	f0 1f 00 0c 	mcall	800059e0 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800059b6:	0e 9c       	mov	r12,r7
800059b8:	f0 1f 00 0b 	mcall	800059e4 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
800059bc:	f0 1f 00 0b 	mcall	800059e8 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800059c0:	c0 81       	brne	800059d0 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
800059c2:	d7 33       	scall
800059c4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800059c8:	8d 07       	st.w	r6[0x0],r7
800059ca:	cf 1b       	rjmp	800059ac <vTaskDelayUntil+0x40>
800059cc:	8d 07       	st.w	r6[0x0],r7
800059ce:	cf 7b       	rjmp	800059bc <vTaskDelayUntil+0x50>
800059d0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800059d4:	80 00       	ld.sh	r0,r0[0x0]
800059d6:	54 6c       	stdsp	sp[0x118],r12
800059d8:	00 00       	add	r0,r0
800059da:	0c fc       	st.b	--r6,r12
800059dc:	00 00       	add	r0,r0
800059de:	0c d0       	st.w	--r6,r0
800059e0:	80 00       	ld.sh	r0,r0[0x0]
800059e2:	4c 7e       	lddpc	lr,80005afc <xTaskGenericCreate+0x30>
800059e4:	80 00       	ld.sh	r0,r0[0x0]
800059e6:	59 10       	cp.w	r0,17
800059e8:	80 00       	ld.sh	r0,r0[0x0]
800059ea:	58 28       	cp.w	r8,2

800059ec <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800059ec:	eb cd 40 c0 	pushm	r6-r7,lr
800059f0:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800059f2:	48 e7       	lddpc	r7,80005a28 <vTaskPlaceOnEventList+0x3c>
800059f4:	6e 0b       	ld.w	r11,r7[0x0]
800059f6:	2e 8b       	sub	r11,-24
800059f8:	f0 1f 00 0d 	mcall	80005a2c <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800059fc:	6e 0c       	ld.w	r12,r7[0x0]
800059fe:	2f cc       	sub	r12,-4
80005a00:	f0 1f 00 0c 	mcall	80005a30 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80005a04:	5b f6       	cp.w	r6,-1
80005a06:	c0 81       	brne	80005a16 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005a08:	6e 0b       	ld.w	r11,r7[0x0]
80005a0a:	2f cb       	sub	r11,-4
80005a0c:	48 ac       	lddpc	r12,80005a34 <vTaskPlaceOnEventList+0x48>
80005a0e:	f0 1f 00 0b 	mcall	80005a38 <vTaskPlaceOnEventList+0x4c>
80005a12:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80005a16:	48 a8       	lddpc	r8,80005a3c <vTaskPlaceOnEventList+0x50>
80005a18:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80005a1a:	ec 0c 00 0c 	add	r12,r6,r12
80005a1e:	f0 1f 00 09 	mcall	80005a40 <vTaskPlaceOnEventList+0x54>
80005a22:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005a26:	00 00       	add	r0,r0
80005a28:	00 00       	add	r0,r0
80005a2a:	0c d0       	st.w	--r6,r0
80005a2c:	80 00       	ld.sh	r0,r0[0x0]
80005a2e:	4c 4a       	lddpc	r10,80005b3c <xTaskGenericCreate+0x70>
80005a30:	80 00       	ld.sh	r0,r0[0x0]
80005a32:	4c 7e       	lddpc	lr,80005b4c <xTaskGenericCreate+0x80>
80005a34:	00 00       	add	r0,r0
80005a36:	0d 24       	ld.uh	r4,r6++
80005a38:	80 00       	ld.sh	r0,r0[0x0]
80005a3a:	4c 2e       	lddpc	lr,80005b40 <xTaskGenericCreate+0x74>
80005a3c:	00 00       	add	r0,r0
80005a3e:	0c fc       	st.b	--r6,r12
80005a40:	80 00       	ld.sh	r0,r0[0x0]
80005a42:	59 10       	cp.w	r0,17

80005a44 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80005a44:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005a48:	49 67       	lddpc	r7,80005aa0 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005a4a:	49 74       	lddpc	r4,80005aa4 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005a4c:	49 73       	lddpc	r3,80005aa8 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005a4e:	49 85       	lddpc	r5,80005aac <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005a50:	6e 08       	ld.w	r8,r7[0x0]
80005a52:	58 08       	cp.w	r8,0
80005a54:	c1 e0       	breq	80005a90 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80005a56:	f0 1f 00 17 	mcall	80005ab0 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005a5a:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005a5c:	f0 1f 00 16 	mcall	80005ab4 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80005a60:	58 06       	cp.w	r6,0
80005a62:	c1 70       	breq	80005a90 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80005a64:	f0 1f 00 15 	mcall	80005ab8 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80005a68:	68 38       	ld.w	r8,r4[0xc]
80005a6a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80005a6c:	ec cc ff fc 	sub	r12,r6,-4
80005a70:	f0 1f 00 13 	mcall	80005abc <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80005a74:	66 08       	ld.w	r8,r3[0x0]
80005a76:	20 18       	sub	r8,1
80005a78:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80005a7a:	6e 08       	ld.w	r8,r7[0x0]
80005a7c:	20 18       	sub	r8,1
80005a7e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80005a80:	f0 1f 00 10 	mcall	80005ac0 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80005a84:	6c cc       	ld.w	r12,r6[0x30]
80005a86:	f0 1f 00 10 	mcall	80005ac4 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80005a8a:	0c 9c       	mov	r12,r6
80005a8c:	f0 1f 00 0e 	mcall	80005ac4 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005a90:	6a 08       	ld.w	r8,r5[0x0]
80005a92:	58 18       	cp.w	r8,1
80005a94:	e0 88 00 03 	brls	80005a9a <prvIdleTask+0x56>
			{
				taskYIELD();
80005a98:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80005a9a:	f0 1f 00 0c 	mcall	80005ac8 <prvIdleTask+0x84>
		}
		#endif
	}
80005a9e:	cd 9b       	rjmp	80005a50 <prvIdleTask+0xc>
80005aa0:	00 00       	add	r0,r0
80005aa2:	0c 10       	sub	r0,r6
80005aa4:	00 00       	add	r0,r0
80005aa6:	0c bc       	st.h	r6++,r12
80005aa8:	00 00       	add	r0,r0
80005aaa:	0d 1c       	ld.sh	r12,r6++
80005aac:	00 00       	add	r0,r0
80005aae:	0c 1c       	sub	r12,r6
80005ab0:	80 00       	ld.sh	r0,r0[0x0]
80005ab2:	54 6c       	stdsp	sp[0x118],r12
80005ab4:	80 00       	ld.sh	r0,r0[0x0]
80005ab6:	58 28       	cp.w	r8,2
80005ab8:	80 00       	ld.sh	r0,r0[0x0]
80005aba:	4d 38       	lddpc	r8,80005c04 <xTaskGenericCreate+0x138>
80005abc:	80 00       	ld.sh	r0,r0[0x0]
80005abe:	4c 7e       	lddpc	lr,80005bd8 <xTaskGenericCreate+0x10c>
80005ac0:	80 00       	ld.sh	r0,r0[0x0]
80005ac2:	4e 44       	lddpc	r4,80005c50 <xTaskGenericCreate+0x184>
80005ac4:	80 00       	ld.sh	r0,r0[0x0]
80005ac6:	4f 7c       	lddpc	r12,80005ca0 <xTaskGenericCreate+0x1d4>
80005ac8:	80 00       	ld.sh	r0,r0[0x0]
80005aca:	20 30       	sub	r0,3

80005acc <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005acc:	d4 31       	pushm	r0-r7,lr
80005ace:	20 1d       	sub	sp,4
80005ad0:	fa c4 ff d8 	sub	r4,sp,-40
80005ad4:	50 0c       	stdsp	sp[0x0],r12
80005ad6:	16 91       	mov	r1,r11
80005ad8:	14 97       	mov	r7,r10
80005ada:	12 90       	mov	r0,r9
80005adc:	10 93       	mov	r3,r8
80005ade:	68 02       	ld.w	r2,r4[0x0]
80005ae0:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80005ae2:	34 8c       	mov	r12,72
80005ae4:	f0 1f 00 5c 	mcall	80005c54 <xTaskGenericCreate+0x188>
80005ae8:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80005aea:	c0 31       	brne	80005af0 <xTaskGenericCreate+0x24>
80005aec:	3f fc       	mov	r12,-1
80005aee:	ca f8       	rjmp	80005c4c <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005af0:	58 06       	cp.w	r6,0
80005af2:	e0 81 00 af 	brne	80005c50 <xTaskGenericCreate+0x184>
80005af6:	0e 9c       	mov	r12,r7
80005af8:	5c 7c       	castu.h	r12
80005afa:	a3 6c       	lsl	r12,0x2
80005afc:	f0 1f 00 56 	mcall	80005c54 <xTaskGenericCreate+0x188>
80005b00:	18 96       	mov	r6,r12
80005b02:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80005b04:	c0 61       	brne	80005b10 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80005b06:	0a 9c       	mov	r12,r5
80005b08:	f0 1f 00 54 	mcall	80005c58 <xTaskGenericCreate+0x18c>
80005b0c:	3f fc       	mov	r12,-1
80005b0e:	c9 f8       	rjmp	80005c4c <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80005b10:	5c 77       	castu.h	r7
80005b12:	ee 0a 15 02 	lsl	r10,r7,0x2
80005b16:	e0 6b 00 a5 	mov	r11,165
80005b1a:	0c 9c       	mov	r12,r6
80005b1c:	f0 1f 00 50 	mcall	80005c5c <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80005b20:	ee c6 00 01 	sub	r6,r7,1
80005b24:	6a c8       	ld.w	r8,r5[0x30]
80005b26:	f0 06 00 26 	add	r6,r8,r6<<0x2
80005b2a:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80005b2e:	31 0a       	mov	r10,16
80005b30:	02 9b       	mov	r11,r1
80005b32:	ea cc ff cc 	sub	r12,r5,-52
80005b36:	f0 1f 00 4b 	mcall	80005c60 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80005b3a:	30 08       	mov	r8,0
80005b3c:	eb 68 00 43 	st.b	r5[67],r8
80005b40:	58 73       	cp.w	r3,7
80005b42:	e6 07 17 80 	movls	r7,r3
80005b46:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80005b4a:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80005b4c:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80005b50:	ea c4 ff fc 	sub	r4,r5,-4
80005b54:	08 9c       	mov	r12,r4
80005b56:	f0 1f 00 44 	mcall	80005c64 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80005b5a:	ea cc ff e8 	sub	r12,r5,-24
80005b5e:	f0 1f 00 42 	mcall	80005c64 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80005b62:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80005b64:	ee 07 11 08 	rsub	r7,r7,8
80005b68:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80005b6a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005b6c:	00 9a       	mov	r10,r0
80005b6e:	40 0b       	lddsp	r11,sp[0x0]
80005b70:	0c 9c       	mov	r12,r6
80005b72:	f0 1f 00 3e 	mcall	80005c68 <xTaskGenericCreate+0x19c>
80005b76:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005b78:	58 02       	cp.w	r2,0
80005b7a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005b7e:	f0 1f 00 3c 	mcall	80005c6c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80005b82:	4b c8       	lddpc	r8,80005c70 <xTaskGenericCreate+0x1a4>
80005b84:	70 09       	ld.w	r9,r8[0x0]
80005b86:	2f f9       	sub	r9,-1
80005b88:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005b8a:	4b b8       	lddpc	r8,80005c74 <xTaskGenericCreate+0x1a8>
80005b8c:	70 08       	ld.w	r8,r8[0x0]
80005b8e:	58 08       	cp.w	r8,0
80005b90:	c2 61       	brne	80005bdc <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80005b92:	4b 98       	lddpc	r8,80005c74 <xTaskGenericCreate+0x1a8>
80005b94:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005b96:	4b 78       	lddpc	r8,80005c70 <xTaskGenericCreate+0x1a4>
80005b98:	70 08       	ld.w	r8,r8[0x0]
80005b9a:	58 18       	cp.w	r8,1
80005b9c:	c2 b1       	brne	80005bf2 <xTaskGenericCreate+0x126>
80005b9e:	4b 77       	lddpc	r7,80005c78 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80005ba0:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80005ba4:	0e 9c       	mov	r12,r7
80005ba6:	f0 1f 00 36 	mcall	80005c7c <xTaskGenericCreate+0x1b0>
80005baa:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80005bac:	0c 37       	cp.w	r7,r6
80005bae:	cf b1       	brne	80005ba4 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80005bb0:	4b 47       	lddpc	r7,80005c80 <xTaskGenericCreate+0x1b4>
80005bb2:	0e 9c       	mov	r12,r7
80005bb4:	f0 1f 00 32 	mcall	80005c7c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80005bb8:	4b 36       	lddpc	r6,80005c84 <xTaskGenericCreate+0x1b8>
80005bba:	0c 9c       	mov	r12,r6
80005bbc:	f0 1f 00 30 	mcall	80005c7c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80005bc0:	4b 2c       	lddpc	r12,80005c88 <xTaskGenericCreate+0x1bc>
80005bc2:	f0 1f 00 2f 	mcall	80005c7c <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80005bc6:	4b 2c       	lddpc	r12,80005c8c <xTaskGenericCreate+0x1c0>
80005bc8:	f0 1f 00 2d 	mcall	80005c7c <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80005bcc:	4b 1c       	lddpc	r12,80005c90 <xTaskGenericCreate+0x1c4>
80005bce:	f0 1f 00 2c 	mcall	80005c7c <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80005bd2:	4b 18       	lddpc	r8,80005c94 <xTaskGenericCreate+0x1c8>
80005bd4:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80005bd6:	4b 18       	lddpc	r8,80005c98 <xTaskGenericCreate+0x1cc>
80005bd8:	91 06       	st.w	r8[0x0],r6
80005bda:	c0 c8       	rjmp	80005bf2 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005bdc:	4b 08       	lddpc	r8,80005c9c <xTaskGenericCreate+0x1d0>
80005bde:	70 08       	ld.w	r8,r8[0x0]
80005be0:	58 08       	cp.w	r8,0
80005be2:	c0 81       	brne	80005bf2 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005be4:	4a 48       	lddpc	r8,80005c74 <xTaskGenericCreate+0x1a8>
80005be6:	70 08       	ld.w	r8,r8[0x0]
80005be8:	70 b8       	ld.w	r8,r8[0x2c]
80005bea:	10 33       	cp.w	r3,r8
80005bec:	c0 33       	brcs	80005bf2 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80005bee:	4a 28       	lddpc	r8,80005c74 <xTaskGenericCreate+0x1a8>
80005bf0:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80005bf2:	6a b8       	ld.w	r8,r5[0x2c]
80005bf4:	4a b9       	lddpc	r9,80005ca0 <xTaskGenericCreate+0x1d4>
80005bf6:	72 09       	ld.w	r9,r9[0x0]
80005bf8:	12 38       	cp.w	r8,r9
80005bfa:	e0 88 00 04 	brls	80005c02 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005bfe:	4a 99       	lddpc	r9,80005ca0 <xTaskGenericCreate+0x1d4>
80005c00:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80005c02:	4a 98       	lddpc	r8,80005ca4 <xTaskGenericCreate+0x1d8>
80005c04:	70 09       	ld.w	r9,r8[0x0]
80005c06:	2f f9       	sub	r9,-1
80005c08:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80005c0a:	6a b8       	ld.w	r8,r5[0x2c]
80005c0c:	4a 79       	lddpc	r9,80005ca8 <xTaskGenericCreate+0x1dc>
80005c0e:	72 09       	ld.w	r9,r9[0x0]
80005c10:	12 38       	cp.w	r8,r9
80005c12:	e0 88 00 04 	brls	80005c1a <xTaskGenericCreate+0x14e>
80005c16:	4a 59       	lddpc	r9,80005ca8 <xTaskGenericCreate+0x1dc>
80005c18:	93 08       	st.w	r9[0x0],r8
80005c1a:	6a bc       	ld.w	r12,r5[0x2c]
80005c1c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005c20:	08 9b       	mov	r11,r4
80005c22:	49 68       	lddpc	r8,80005c78 <xTaskGenericCreate+0x1ac>
80005c24:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005c28:	f0 1f 00 21 	mcall	80005cac <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80005c2c:	f0 1f 00 21 	mcall	80005cb0 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80005c30:	49 b8       	lddpc	r8,80005c9c <xTaskGenericCreate+0x1d0>
80005c32:	70 08       	ld.w	r8,r8[0x0]
80005c34:	58 08       	cp.w	r8,0
80005c36:	c0 a0       	breq	80005c4a <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80005c38:	48 f8       	lddpc	r8,80005c74 <xTaskGenericCreate+0x1a8>
80005c3a:	70 08       	ld.w	r8,r8[0x0]
80005c3c:	70 b8       	ld.w	r8,r8[0x2c]
80005c3e:	10 33       	cp.w	r3,r8
80005c40:	e0 88 00 05 	brls	80005c4a <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80005c44:	d7 33       	scall
80005c46:	30 1c       	mov	r12,1
80005c48:	c0 28       	rjmp	80005c4c <xTaskGenericCreate+0x180>
80005c4a:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80005c4c:	2f fd       	sub	sp,-4
80005c4e:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005c50:	99 c6       	st.w	r12[0x30],r6
80005c52:	c5 fb       	rjmp	80005b10 <xTaskGenericCreate+0x44>
80005c54:	80 00       	ld.sh	r0,r0[0x0]
80005c56:	4f a4       	lddpc	r4,80005e3c <PrintDec+0x86>
80005c58:	80 00       	ld.sh	r0,r0[0x0]
80005c5a:	4f 7c       	lddpc	r12,80005e34 <PrintDec+0x7e>
80005c5c:	80 00       	ld.sh	r0,r0[0x0]
80005c5e:	69 30       	ld.w	r0,r4[0x4c]
80005c60:	80 00       	ld.sh	r0,r0[0x0]
80005c62:	6c 84       	ld.w	r4,r6[0x20]
80005c64:	80 00       	ld.sh	r0,r0[0x0]
80005c66:	4c 28       	lddpc	r8,80005d6c <PrintHex+0x68>
80005c68:	80 00       	ld.sh	r0,r0[0x0]
80005c6a:	4c a4       	lddpc	r4,80005d90 <PrintHex+0x8c>
80005c6c:	80 00       	ld.sh	r0,r0[0x0]
80005c6e:	4d 38       	lddpc	r8,80005db8 <PrintDec+0x2>
80005c70:	00 00       	add	r0,r0
80005c72:	0d 1c       	ld.sh	r12,r6++
80005c74:	00 00       	add	r0,r0
80005c76:	0c d0       	st.w	--r6,r0
80005c78:	00 00       	add	r0,r0
80005c7a:	0c 1c       	sub	r12,r6
80005c7c:	80 00       	ld.sh	r0,r0[0x0]
80005c7e:	4c 14       	lddpc	r4,80005d80 <PrintHex+0x7c>
80005c80:	00 00       	add	r0,r0
80005c82:	0c e8       	st.h	--r6,r8
80005c84:	00 00       	add	r0,r0
80005c86:	0d 04       	ld.w	r4,r6++
80005c88:	00 00       	add	r0,r0
80005c8a:	0c d4       	st.w	--r6,r4
80005c8c:	00 00       	add	r0,r0
80005c8e:	0c bc       	st.h	r6++,r12
80005c90:	00 00       	add	r0,r0
80005c92:	0d 24       	ld.uh	r4,r6++
80005c94:	00 00       	add	r0,r0
80005c96:	0c 08       	add	r8,r6
80005c98:	00 00       	add	r0,r0
80005c9a:	0c 18       	sub	r8,r6
80005c9c:	00 00       	add	r0,r0
80005c9e:	0c 0c       	add	r12,r6
80005ca0:	00 00       	add	r0,r0
80005ca2:	0c 04       	add	r4,r6
80005ca4:	00 00       	add	r0,r0
80005ca6:	0d 18       	ld.sh	r8,r6++
80005ca8:	00 00       	add	r0,r0
80005caa:	0d 38       	ld.ub	r8,r6++
80005cac:	80 00       	ld.sh	r0,r0[0x0]
80005cae:	4c 2e       	lddpc	lr,80005db4 <PrintHex+0xb0>
80005cb0:	80 00       	ld.sh	r0,r0[0x0]
80005cb2:	4e 44       	lddpc	r4,80005e40 <PrintDec+0x8a>

80005cb4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80005cb4:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80005cb6:	30 09       	mov	r9,0
80005cb8:	1a d9       	st.w	--sp,r9
80005cba:	1a d9       	st.w	--sp,r9
80005cbc:	1a d9       	st.w	--sp,r9
80005cbe:	12 98       	mov	r8,r9
80005cc0:	e0 6a 01 00 	mov	r10,256
80005cc4:	48 9b       	lddpc	r11,80005ce8 <vTaskStartScheduler+0x34>
80005cc6:	48 ac       	lddpc	r12,80005cec <vTaskStartScheduler+0x38>
80005cc8:	f0 1f 00 0a 	mcall	80005cf0 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005ccc:	2f dd       	sub	sp,-12
80005cce:	58 1c       	cp.w	r12,1
80005cd0:	c0 a1       	brne	80005ce4 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80005cd2:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80005cd4:	30 19       	mov	r9,1
80005cd6:	48 88       	lddpc	r8,80005cf4 <vTaskStartScheduler+0x40>
80005cd8:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80005cda:	30 09       	mov	r9,0
80005cdc:	48 78       	lddpc	r8,80005cf8 <vTaskStartScheduler+0x44>
80005cde:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80005ce0:	f0 1f 00 07 	mcall	80005cfc <vTaskStartScheduler+0x48>
80005ce4:	d8 02       	popm	pc
80005ce6:	00 00       	add	r0,r0
80005ce8:	80 01       	ld.sh	r1,r0[0x0]
80005cea:	4c bc       	lddpc	r12,80005e14 <PrintDec+0x5e>
80005cec:	80 00       	ld.sh	r0,r0[0x0]
80005cee:	5a 44       	cp.w	r4,-28
80005cf0:	80 00       	ld.sh	r0,r0[0x0]
80005cf2:	5a cc       	cp.w	r12,-20
80005cf4:	00 00       	add	r0,r0
80005cf6:	0c 0c       	add	r12,r6
80005cf8:	00 00       	add	r0,r0
80005cfa:	0c fc       	st.b	--r6,r12
80005cfc:	80 00       	ld.sh	r0,r0[0x0]
80005cfe:	4d 48       	lddpc	r8,80005e4c <PrintDec+0x96>

80005d00 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80005d00:	16 cc       	st.b	r11++,r12
	return str;
}
80005d02:	5e fb       	retal	r11

80005d04 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80005d04:	eb cd 40 c0 	pushm	r6-r7,lr
80005d08:	20 3d       	sub	sp,12
80005d0a:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80005d0c:	30 06       	mov	r6,0
80005d0e:	30 07       	mov	r7,0
80005d10:	fa e7 00 00 	st.d	sp[0],r6
80005d14:	30 0c       	mov	r12,0
80005d16:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80005d18:	58 08       	cp.w	r8,0
80005d1a:	c1 30       	breq	80005d40 <PrintHex+0x3c>
80005d1c:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80005d1e:	1a 9c       	mov	r12,sp
80005d20:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005d24:	58 9e       	cp.w	lr,9
80005d26:	e0 8a 00 04 	brle	80005d2e <PrintHex+0x2a>
80005d2a:	2c 9e       	sub	lr,-55
80005d2c:	c0 48       	rjmp	80005d34 <PrintHex+0x30>
80005d2e:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005d32:	2d 0e       	sub	lr,-48
80005d34:	f8 09 0b 0e 	st.b	r12[r9],lr
80005d38:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80005d3a:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80005d3c:	cf 21       	brne	80005d20 <PrintHex+0x1c>
80005d3e:	c0 48       	rjmp	80005d46 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80005d40:	33 08       	mov	r8,48
80005d42:	ba 88       	st.b	sp[0x0],r8
80005d44:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80005d46:	f6 09 01 08 	sub	r8,r11,r9
80005d4a:	58 08       	cp.w	r8,0
80005d4c:	e0 8a 00 13 	brle	80005d72 <PrintHex+0x6e>
	{
		char num = len - cnt;
80005d50:	12 1b       	sub	r11,r9
80005d52:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80005d56:	18 9e       	mov	lr,r12
80005d58:	58 0c       	cp.w	r12,0
80005d5a:	e0 8a 00 0c 	brle	80005d72 <PrintHex+0x6e>
80005d5e:	1a 9b       	mov	r11,sp
80005d60:	12 0b       	add	r11,r9
80005d62:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005d64:	33 07       	mov	r7,48
80005d66:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80005d68:	2f f8       	sub	r8,-1
80005d6a:	1c 38       	cp.w	r8,lr
80005d6c:	cf d5       	brlt	80005d66 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005d6e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005d72:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80005d76:	f0 cb ff ff 	sub	r11,r8,-1
80005d7a:	58 0b       	cp.w	r11,0
80005d7c:	e0 8a 00 19 	brle	80005dae <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005d80:	fa cb ff f4 	sub	r11,sp,-12
80005d84:	f6 09 00 09 	add	r9,r11,r9
80005d88:	37 8b       	mov	r11,120
80005d8a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80005d8e:	fa c9 ff f4 	sub	r9,sp,-12
80005d92:	10 09       	add	r9,r8
80005d94:	33 0b       	mov	r11,48
80005d96:	f3 6b ff f4 	st.b	r9[-12],r11
80005d9a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005d9e:	fa ce 00 01 	sub	lr,sp,1
80005da2:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80005da4:	11 8b       	ld.ub	r11,r8[0x0]
80005da6:	12 cb       	st.b	r9++,r11
80005da8:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80005daa:	1c 38       	cp.w	r8,lr
80005dac:	cf c1       	brne	80005da4 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80005dae:	14 9c       	mov	r12,r10
80005db0:	2f dd       	sub	sp,-12
80005db2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80005db6 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80005db6:	d4 21       	pushm	r4-r7,lr
80005db8:	20 3d       	sub	sp,12
80005dba:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80005dbc:	30 06       	mov	r6,0
80005dbe:	30 07       	mov	r7,0
80005dc0:	fa e7 00 00 	st.d	sp[0],r6
80005dc4:	30 0c       	mov	r12,0
80005dc6:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80005dc8:	58 08       	cp.w	r8,0
80005dca:	c0 35       	brlt	80005dd0 <PrintDec+0x1a>
80005dcc:	14 97       	mov	r7,r10
80005dce:	c0 58       	rjmp	80005dd8 <PrintDec+0x22>
	{
		*p++ = '-';
80005dd0:	14 97       	mov	r7,r10
80005dd2:	32 d9       	mov	r9,45
80005dd4:	0e c9       	st.b	r7++,r9
		i = -i;
80005dd6:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80005dd8:	58 08       	cp.w	r8,0
80005dda:	c0 51       	brne	80005de4 <PrintDec+0x2e>
80005ddc:	33 08       	mov	r8,48
80005dde:	ba 88       	st.b	sp[0x0],r8
80005de0:	30 1e       	mov	lr,1
80005de2:	c2 f8       	rjmp	80005e40 <PrintDec+0x8a>
	
	int ten = i%10;
80005de4:	e0 65 66 67 	mov	r5,26215
80005de8:	ea 15 66 66 	orh	r5,0x6666
80005dec:	f0 05 04 44 	muls.d	r4,r8,r5
80005df0:	ea 0c 14 02 	asr	r12,r5,0x2
80005df4:	f0 09 14 1f 	asr	r9,r8,0x1f
80005df8:	f8 09 01 09 	sub	r9,r12,r9
80005dfc:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005e00:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80005e04:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80005e06:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80005e08:	e0 66 66 67 	mov	r6,26215
80005e0c:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80005e10:	2d 09       	sub	r9,-48
80005e12:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80005e16:	2f fe       	sub	lr,-1
		i /= 10;
80005e18:	f0 06 04 44 	muls.d	r4,r8,r6
80005e1c:	ea 09 14 02 	asr	r9,r5,0x2
80005e20:	bf 58       	asr	r8,0x1f
80005e22:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80005e26:	f0 06 04 44 	muls.d	r4,r8,r6
80005e2a:	ea 09 14 02 	asr	r9,r5,0x2
80005e2e:	f0 05 14 1f 	asr	r5,r8,0x1f
80005e32:	0a 19       	sub	r9,r5
80005e34:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005e38:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80005e3c:	58 08       	cp.w	r8,0
80005e3e:	ce 91       	brne	80005e10 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80005e40:	f6 0e 01 08 	sub	r8,r11,lr
80005e44:	58 08       	cp.w	r8,0
80005e46:	e0 89 00 06 	brgt	80005e52 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80005e4a:	58 0e       	cp.w	lr,0
80005e4c:	e0 89 00 14 	brgt	80005e74 <PrintDec+0xbe>
80005e50:	c1 d8       	rjmp	80005e8a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80005e52:	1c 1b       	sub	r11,lr
80005e54:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80005e56:	16 9c       	mov	r12,r11
80005e58:	58 0b       	cp.w	r11,0
80005e5a:	fe 9a ff f8 	brle	80005e4a <PrintDec+0x94>
80005e5e:	1a 99       	mov	r9,sp
80005e60:	1c 09       	add	r9,lr
80005e62:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005e64:	33 06       	mov	r6,48
80005e66:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80005e68:	2f f8       	sub	r8,-1
80005e6a:	18 38       	cp.w	r8,r12
80005e6c:	cf d5       	brlt	80005e66 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80005e6e:	f6 0e 00 0e 	add	lr,r11,lr
80005e72:	ce cb       	rjmp	80005e4a <PrintDec+0x94>
80005e74:	fa c8 ff f4 	sub	r8,sp,-12
80005e78:	1c 08       	add	r8,lr
80005e7a:	20 d8       	sub	r8,13
80005e7c:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80005e80:	11 89       	ld.ub	r9,r8[0x0]
80005e82:	0e c9       	st.b	r7++,r9
80005e84:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80005e86:	16 38       	cp.w	r8,r11
80005e88:	cf c1       	brne	80005e80 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80005e8a:	14 9c       	mov	r12,r10
80005e8c:	2f dd       	sub	sp,-12
80005e8e:	d8 22       	popm	r4-r7,pc

80005e90 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80005e90:	d4 31       	pushm	r0-r7,lr
80005e92:	fa cd 02 08 	sub	sp,sp,520
80005e96:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80005e98:	e0 6a 01 00 	mov	r10,256
80005e9c:	30 0b       	mov	r11,0
80005e9e:	fa cc fe f8 	sub	r12,sp,-264
80005ea2:	f0 1f 00 4e 	mcall	80005fd8 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80005ea6:	fa c4 fd d4 	sub	r4,sp,-556
80005eaa:	30 0a       	mov	r10,0
80005eac:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005eae:	fa c3 ff fc 	sub	r3,sp,-4
80005eb2:	e0 61 01 00 	mov	r1,256
80005eb6:	14 90       	mov	r0,r10
			
					if(*str == '%')
80005eb8:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005eba:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005ebe:	02 9a       	mov	r10,r1
80005ec0:	00 9b       	mov	r11,r0
80005ec2:	06 9c       	mov	r12,r3
80005ec4:	f0 1f 00 45 	mcall	80005fd8 <log+0x148>
			
					if(*str == '%')
80005ec8:	0f 88       	ld.ub	r8,r7[0x0]
80005eca:	e4 08 18 00 	cp.b	r8,r2
80005ece:	c5 71       	brne	80005f7c <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80005ed0:	ee c8 ff ff 	sub	r8,r7,-1
80005ed4:	11 89       	ld.ub	r9,r8[0x0]
80005ed6:	4c 2a       	lddpc	r10,80005fdc <log+0x14c>
80005ed8:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80005eda:	23 09       	sub	r9,48
80005edc:	30 9a       	mov	r10,9
80005ede:	f4 09 18 00 	cp.b	r9,r10
80005ee2:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80005ee6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80005eea:	f7 b9 08 30 	subls	r9,48
80005eee:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80005ef2:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80005ef6:	0f 88       	ld.ub	r8,r7[0x0]
80005ef8:	22 58       	sub	r8,37
80005efa:	e0 48 00 53 	cp.w	r8,83
80005efe:	e0 8b 00 31 	brhi	80005f60 <log+0xd0>
80005f02:	4b 89       	lddpc	r9,80005fe0 <log+0x150>
80005f04:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80005f08:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80005f0c:	06 9a       	mov	r10,r3
80005f0e:	40 0b       	lddsp	r11,sp[0x0]
80005f10:	5c 5b       	castu.b	r11
80005f12:	68 0c       	ld.w	r12,r4[0x0]
80005f14:	f0 1f 00 34 	mcall	80005fe4 <log+0x154>
							break;
80005f18:	c2 98       	rjmp	80005f6a <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80005f1a:	4b 4c       	lddpc	r12,80005fe8 <log+0x158>
80005f1c:	f0 1f 00 34 	mcall	80005fec <log+0x15c>
80005f20:	08 95       	mov	r5,r4
80005f22:	06 9c       	mov	r12,r3
							break;
80005f24:	c2 38       	rjmp	80005f6a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80005f26:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80005f2a:	06 9a       	mov	r10,r3
80005f2c:	40 0b       	lddsp	r11,sp[0x0]
80005f2e:	5c 5b       	castu.b	r11
80005f30:	68 0c       	ld.w	r12,r4[0x0]
80005f32:	f0 1f 00 30 	mcall	80005ff0 <log+0x160>
80005f36:	06 9c       	mov	r12,r3
							break;
80005f38:	c1 98       	rjmp	80005f6a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80005f3a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80005f3e:	06 9b       	mov	r11,r3
80005f40:	09 bc       	ld.ub	r12,r4[0x3]
80005f42:	f0 1f 00 2d 	mcall	80005ff4 <log+0x164>
80005f46:	06 9c       	mov	r12,r3
							break;
80005f48:	c1 18       	rjmp	80005f6a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80005f4a:	e8 c5 ff fc 	sub	r5,r4,-4
80005f4e:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80005f50:	c0 d8       	rjmp	80005f6a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80005f52:	06 9b       	mov	r11,r3
80005f54:	32 5c       	mov	r12,37
80005f56:	f0 1f 00 28 	mcall	80005ff4 <log+0x164>
80005f5a:	08 95       	mov	r5,r4
80005f5c:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80005f5e:	c0 68       	rjmp	80005f6a <log+0xda>
							
							default:
							log("I need relax.");
80005f60:	4a 6c       	lddpc	r12,80005ff8 <log+0x168>
80005f62:	f0 1f 00 23 	mcall	80005fec <log+0x15c>
80005f66:	08 95       	mov	r5,r4
80005f68:	06 9c       	mov	r12,r3
						}
						str++;
80005f6a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80005f6c:	1a dc       	st.w	--sp,r12
80005f6e:	1a d6       	st.w	--sp,r6
80005f70:	4a 3b       	lddpc	r11,80005ffc <log+0x16c>
80005f72:	0c 9c       	mov	r12,r6
80005f74:	f0 1f 00 23 	mcall	80006000 <log+0x170>
80005f78:	2f ed       	sub	sp,-8
80005f7a:	c0 a8       	rjmp	80005f8e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005f7c:	2f f7       	sub	r7,-1
80005f7e:	1a d8       	st.w	--sp,r8
80005f80:	1a d6       	st.w	--sp,r6
80005f82:	4a 1b       	lddpc	r11,80006004 <log+0x174>
80005f84:	0c 9c       	mov	r12,r6
80005f86:	f0 1f 00 1f 	mcall	80006000 <log+0x170>
80005f8a:	08 95       	mov	r5,r4
80005f8c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80005f8e:	0f 89       	ld.ub	r9,r7[0x0]
80005f90:	30 08       	mov	r8,0
80005f92:	f0 09 18 00 	cp.b	r9,r8
80005f96:	c0 30       	breq	80005f9c <log+0x10c>
80005f98:	0a 94       	mov	r4,r5
80005f9a:	c9 2b       	rjmp	80005ebe <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80005f9c:	fa c7 fe f8 	sub	r7,sp,-264
80005fa0:	1a d7       	st.w	--sp,r7
80005fa2:	49 ab       	lddpc	r11,80006008 <log+0x178>
80005fa4:	0e 9c       	mov	r12,r7
80005fa6:	f0 1f 00 17 	mcall	80006000 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80005faa:	5c 5c       	castu.b	r12
80005fac:	f8 c6 ff ff 	sub	r6,r12,-1
80005fb0:	0c 9c       	mov	r12,r6
80005fb2:	f0 1f 00 17 	mcall	8000600c <log+0x17c>
80005fb6:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80005fb8:	0c 9a       	mov	r10,r6
80005fba:	0e 9b       	mov	r11,r7
80005fbc:	f0 1f 00 15 	mcall	80006010 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
80005fc0:	30 09       	mov	r9,0
80005fc2:	30 5a       	mov	r10,5
80005fc4:	fa cb fe f8 	sub	r11,sp,-264
80005fc8:	49 38       	lddpc	r8,80006014 <log+0x184>
80005fca:	70 0c       	ld.w	r12,r8[0x0]
80005fcc:	f0 1f 00 13 	mcall	80006018 <log+0x188>
80005fd0:	2f fd       	sub	sp,-4
}
80005fd2:	fe 3d fd f8 	sub	sp,-520
80005fd6:	d8 32       	popm	r0-r7,pc
80005fd8:	80 00       	ld.sh	r0,r0[0x0]
80005fda:	69 30       	ld.w	r0,r4[0x4c]
80005fdc:	00 00       	add	r0,r0
80005fde:	0d 3c       	ld.ub	r12,r6++
80005fe0:	80 01       	ld.sh	r1,r0[0x0]
80005fe2:	4c c4       	lddpc	r4,80006110 <logFromISR+0xf4>
80005fe4:	80 00       	ld.sh	r0,r0[0x0]
80005fe6:	5d b6       	*unknown*
80005fe8:	80 01       	ld.sh	r1,r0[0x0]
80005fea:	4f 70       	lddpc	r0,800061c4 <log_init+0x28>
80005fec:	80 00       	ld.sh	r0,r0[0x0]
80005fee:	5e 90       	retgt	r0
80005ff0:	80 00       	ld.sh	r0,r0[0x0]
80005ff2:	5d 04       	ror	r4
80005ff4:	80 00       	ld.sh	r0,r0[0x0]
80005ff6:	5d 00       	ror	r0
80005ff8:	80 01       	ld.sh	r1,r0[0x0]
80005ffa:	4f 80       	lddpc	r0,800061d8 <log_init+0x3c>
80005ffc:	80 01       	ld.sh	r1,r0[0x0]
80005ffe:	4f 90       	lddpc	r0,800061e0 <log_init+0x44>
80006000:	80 00       	ld.sh	r0,r0[0x0]
80006002:	6c 20       	ld.w	r0,r6[0x8]
80006004:	80 01       	ld.sh	r1,r0[0x0]
80006006:	4f 98       	lddpc	r8,800061e8 <log_init+0x4c>
80006008:	80 01       	ld.sh	r1,r0[0x0]
8000600a:	4f a0       	lddpc	r0,800061f0 <log_init+0x54>
8000600c:	80 00       	ld.sh	r0,r0[0x0]
8000600e:	4f a4       	lddpc	r4,800061f4 <log_init+0x58>
80006010:	80 00       	ld.sh	r0,r0[0x0]
80006012:	67 e8       	ld.w	r8,r3[0x78]
80006014:	00 00       	add	r0,r0
80006016:	40 cc       	lddsp	r12,sp[0x30]
80006018:	80 00       	ld.sh	r0,r0[0x0]
8000601a:	52 f8       	stdsp	sp[0xbc],r8

8000601c <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
8000601c:	d4 31       	pushm	r0-r7,lr
8000601e:	fa cd 02 0c 	sub	sp,sp,524
80006022:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006024:	e0 6a 01 00 	mov	r10,256
80006028:	30 0b       	mov	r11,0
8000602a:	fa cc fe f4 	sub	r12,sp,-268
8000602e:	f0 1f 00 4c 	mcall	8000615c <logFromISR+0x140>
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
}
	
	
int logFromISR(char * content, ...)
80006032:	fa c4 fd d0 	sub	r4,sp,-560
80006036:	30 0a       	mov	r10,0
80006038:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000603a:	fa c3 ff fc 	sub	r3,sp,-4
8000603e:	e0 61 01 00 	mov	r1,256
80006042:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006044:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006046:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000604a:	02 9a       	mov	r10,r1
8000604c:	00 9b       	mov	r11,r0
8000604e:	06 9c       	mov	r12,r3
80006050:	f0 1f 00 43 	mcall	8000615c <logFromISR+0x140>
			
			if(*str == '%')
80006054:	0f 88       	ld.ub	r8,r7[0x0]
80006056:	e4 08 18 00 	cp.b	r8,r2
8000605a:	c5 11       	brne	800060fc <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
8000605c:	ee c8 ff ff 	sub	r8,r7,-1
80006060:	11 89       	ld.ub	r9,r8[0x0]
80006062:	4c 0a       	lddpc	r10,80006160 <logFromISR+0x144>
80006064:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006066:	23 09       	sub	r9,48
80006068:	30 9a       	mov	r10,9
8000606a:	f4 09 18 00 	cp.b	r9,r10
8000606e:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006072:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006076:	f7 b9 08 30 	subls	r9,48
8000607a:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
8000607e:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006082:	0f 88       	ld.ub	r8,r7[0x0]
80006084:	22 58       	sub	r8,37
80006086:	e0 48 00 53 	cp.w	r8,83
8000608a:	e0 8b 00 2b 	brhi	800060e0 <logFromISR+0xc4>
8000608e:	4b 69       	lddpc	r9,80006164 <logFromISR+0x148>
80006090:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006094:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006098:	06 9a       	mov	r10,r3
8000609a:	40 0b       	lddsp	r11,sp[0x0]
8000609c:	5c 5b       	castu.b	r11
8000609e:	68 0c       	ld.w	r12,r4[0x0]
800060a0:	f0 1f 00 32 	mcall	80006168 <logFromISR+0x14c>
					break;
800060a4:	c2 38       	rjmp	800060ea <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
800060a6:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
800060aa:	06 9a       	mov	r10,r3
800060ac:	40 0b       	lddsp	r11,sp[0x0]
800060ae:	5c 5b       	castu.b	r11
800060b0:	68 0c       	ld.w	r12,r4[0x0]
800060b2:	f0 1f 00 2f 	mcall	8000616c <logFromISR+0x150>
800060b6:	06 9c       	mov	r12,r3
					break;
800060b8:	c1 98       	rjmp	800060ea <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
800060ba:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
800060be:	06 9b       	mov	r11,r3
800060c0:	09 bc       	ld.ub	r12,r4[0x3]
800060c2:	f0 1f 00 2c 	mcall	80006170 <logFromISR+0x154>
800060c6:	06 9c       	mov	r12,r3
					break;
800060c8:	c1 18       	rjmp	800060ea <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
800060ca:	e8 c5 ff fc 	sub	r5,r4,-4
800060ce:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
800060d0:	c0 d8       	rjmp	800060ea <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
800060d2:	06 9b       	mov	r11,r3
800060d4:	32 5c       	mov	r12,37
800060d6:	f0 1f 00 27 	mcall	80006170 <logFromISR+0x154>
800060da:	08 95       	mov	r5,r4
800060dc:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800060de:	c0 68       	rjmp	800060ea <logFromISR+0xce>
					default:
					log("I need relax.");
800060e0:	4a 5c       	lddpc	r12,80006174 <logFromISR+0x158>
800060e2:	f0 1f 00 26 	mcall	80006178 <logFromISR+0x15c>
800060e6:	08 95       	mov	r5,r4
800060e8:	06 9c       	mov	r12,r3
				}
				str++;
800060ea:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800060ec:	1a dc       	st.w	--sp,r12
800060ee:	1a d6       	st.w	--sp,r6
800060f0:	4a 3b       	lddpc	r11,8000617c <logFromISR+0x160>
800060f2:	0c 9c       	mov	r12,r6
800060f4:	f0 1f 00 23 	mcall	80006180 <logFromISR+0x164>
800060f8:	2f ed       	sub	sp,-8
800060fa:	c0 a8       	rjmp	8000610e <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800060fc:	2f f7       	sub	r7,-1
800060fe:	1a d8       	st.w	--sp,r8
80006100:	1a d6       	st.w	--sp,r6
80006102:	4a 1b       	lddpc	r11,80006184 <logFromISR+0x168>
80006104:	0c 9c       	mov	r12,r6
80006106:	f0 1f 00 1f 	mcall	80006180 <logFromISR+0x164>
8000610a:	08 95       	mov	r5,r4
8000610c:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
8000610e:	0f 89       	ld.ub	r9,r7[0x0]
80006110:	30 08       	mov	r8,0
80006112:	f0 09 18 00 	cp.b	r9,r8
80006116:	c0 30       	breq	8000611c <logFromISR+0x100>
80006118:	0a 94       	mov	r4,r5
8000611a:	c9 8b       	rjmp	8000604a <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
8000611c:	fa c7 fe f4 	sub	r7,sp,-268
80006120:	1a d7       	st.w	--sp,r7
80006122:	49 ab       	lddpc	r11,80006188 <logFromISR+0x16c>
80006124:	0e 9c       	mov	r12,r7
80006126:	f0 1f 00 17 	mcall	80006180 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000612a:	5c 5c       	castu.b	r12
8000612c:	f8 c6 ff ff 	sub	r6,r12,-1
80006130:	0c 9c       	mov	r12,r6
80006132:	f0 1f 00 17 	mcall	8000618c <logFromISR+0x170>
80006136:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006138:	0c 9a       	mov	r10,r6
8000613a:	0e 9b       	mov	r11,r7
8000613c:	f0 1f 00 15 	mcall	80006190 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006140:	30 09       	mov	r9,0
80006142:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006144:	fa ca fe f8 	sub	r10,sp,-264
80006148:	fa cb fe f4 	sub	r11,sp,-268
8000614c:	49 28       	lddpc	r8,80006194 <logFromISR+0x178>
8000614e:	70 0c       	ld.w	r12,r8[0x0]
80006150:	f0 1f 00 12 	mcall	80006198 <logFromISR+0x17c>
80006154:	2f fd       	sub	sp,-4
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80006156:	fe 3d fd f4 	sub	sp,-524
8000615a:	d8 32       	popm	r0-r7,pc
8000615c:	80 00       	ld.sh	r0,r0[0x0]
8000615e:	69 30       	ld.w	r0,r4[0x4c]
80006160:	00 00       	add	r0,r0
80006162:	0d 3d       	ld.ub	sp,r6++
80006164:	80 01       	ld.sh	r1,r0[0x0]
80006166:	4e 14       	lddpc	r4,800062e8 <gpio_enable_module_pin+0x1c>
80006168:	80 00       	ld.sh	r0,r0[0x0]
8000616a:	5d b6       	*unknown*
8000616c:	80 00       	ld.sh	r0,r0[0x0]
8000616e:	5d 04       	ror	r4
80006170:	80 00       	ld.sh	r0,r0[0x0]
80006172:	5d 00       	ror	r0
80006174:	80 01       	ld.sh	r1,r0[0x0]
80006176:	4f 80       	lddpc	r0,80006354 <_stext+0x4>
80006178:	80 00       	ld.sh	r0,r0[0x0]
8000617a:	5e 90       	retgt	r0
8000617c:	80 01       	ld.sh	r1,r0[0x0]
8000617e:	4f 90       	lddpc	r0,80006360 <_stext+0x10>
80006180:	80 00       	ld.sh	r0,r0[0x0]
80006182:	6c 20       	ld.w	r0,r6[0x8]
80006184:	80 01       	ld.sh	r1,r0[0x0]
80006186:	4f 98       	lddpc	r8,80006368 <_stext+0x18>
80006188:	80 01       	ld.sh	r1,r0[0x0]
8000618a:	4f a0       	lddpc	r0,80006370 <idata_load_loop+0x6>
8000618c:	80 00       	ld.sh	r0,r0[0x0]
8000618e:	4f a4       	lddpc	r4,80006374 <idata_load_loop_end+0x2>
80006190:	80 00       	ld.sh	r0,r0[0x0]
80006192:	67 e8       	ld.w	r8,r3[0x78]
80006194:	00 00       	add	r0,r0
80006196:	40 cc       	lddsp	r12,sp[0x30]
80006198:	80 00       	ld.sh	r0,r0[0x0]
8000619a:	52 a8       	stdsp	sp[0xa8],r8

8000619c <log_init>:
		
	return str;
}

void log_init(void)
{
8000619c:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000619e:	30 2b       	mov	r11,2
800061a0:	49 0c       	lddpc	r12,800061e0 <log_init+0x44>
800061a2:	f0 1f 00 11 	mcall	800061e4 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
800061a6:	e0 6a 36 00 	mov	r10,13824
800061aa:	ea 1a 01 6e 	orh	r10,0x16e
800061ae:	48 fb       	lddpc	r11,800061e8 <log_init+0x4c>
800061b0:	fe 7c 18 00 	mov	r12,-59392
800061b4:	f0 1f 00 0e 	mcall	800061ec <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
800061b8:	30 4b       	mov	r11,4
800061ba:	33 2c       	mov	r12,50
800061bc:	f0 1f 00 0d 	mcall	800061f0 <log_init+0x54>
800061c0:	48 d8       	lddpc	r8,800061f4 <log_init+0x58>
800061c2:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800061c4:	30 09       	mov	r9,0
800061c6:	1a d9       	st.w	--sp,r9
800061c8:	1a d9       	st.w	--sp,r9
800061ca:	1a d9       	st.w	--sp,r9
800061cc:	30 18       	mov	r8,1
800061ce:	e0 6a 01 80 	mov	r10,384
800061d2:	48 ab       	lddpc	r11,800061f8 <log_init+0x5c>
800061d4:	48 ac       	lddpc	r12,800061fc <log_init+0x60>
800061d6:	f0 1f 00 0b 	mcall	80006200 <log_init+0x64>
800061da:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800061dc:	d8 02       	popm	pc
800061de:	00 00       	add	r0,r0
800061e0:	80 01       	ld.sh	r1,r0[0x0]
800061e2:	4f ac       	lddpc	r12,800063c8 <_malloc_r+0x18>
800061e4:	80 00       	ld.sh	r0,r0[0x0]
800061e6:	63 20       	ld.w	r0,r1[0x48]
800061e8:	80 01       	ld.sh	r1,r0[0x0]
800061ea:	4f 64       	lddpc	r4,800063c0 <_malloc_r+0x10>
800061ec:	80 00       	ld.sh	r0,r0[0x0]
800061ee:	4b 48       	lddpc	r8,800062bc <main+0x74>
800061f0:	80 00       	ld.sh	r0,r0[0x0]
800061f2:	53 f8       	stdsp	sp[0xfc],r8
800061f4:	00 00       	add	r0,r0
800061f6:	40 cc       	lddsp	r12,sp[0x30]
800061f8:	80 01       	ld.sh	r1,r0[0x0]
800061fa:	4f a8       	lddpc	r8,800063e0 <_malloc_r+0x30>
800061fc:	80 00       	ld.sh	r0,r0[0x0]
800061fe:	62 04       	ld.w	r4,r1[0x0]
80006200:	80 00       	ld.sh	r0,r0[0x0]
80006202:	5a cc       	cp.w	r12,-20

80006204 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80006204:	eb cd 40 f8 	pushm	r3-r7,lr
80006208:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000620a:	48 c7       	lddpc	r7,80006238 <task_log+0x34>
8000620c:	30 05       	mov	r5,0
8000620e:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006210:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006214:	0a 99       	mov	r9,r5
80006216:	08 9a       	mov	r10,r4
80006218:	1a 9b       	mov	r11,sp
8000621a:	6e 0c       	ld.w	r12,r7[0x0]
8000621c:	f0 1f 00 08 	mcall	8000623c <task_log+0x38>
80006220:	58 1c       	cp.w	r12,1
80006222:	cf 91       	brne	80006214 <task_log+0x10>
		{
			if( NULL != str)
80006224:	40 0b       	lddsp	r11,sp[0x0]
80006226:	58 0b       	cp.w	r11,0
80006228:	cf 60       	breq	80006214 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
8000622a:	06 9c       	mov	r12,r3
8000622c:	f0 1f 00 05 	mcall	80006240 <task_log+0x3c>
				vPortFree(str);
80006230:	40 0c       	lddsp	r12,sp[0x0]
80006232:	f0 1f 00 05 	mcall	80006244 <task_log+0x40>
80006236:	ce fb       	rjmp	80006214 <task_log+0x10>
80006238:	00 00       	add	r0,r0
8000623a:	40 cc       	lddsp	r12,sp[0x30]
8000623c:	80 00       	ld.sh	r0,r0[0x0]
8000623e:	50 ec       	stdsp	sp[0x38],r12
80006240:	80 00       	ld.sh	r0,r0[0x0]
80006242:	4a f8       	lddpc	r8,800062fc <gpio_enable_module_pin+0x30>
80006244:	80 00       	ld.sh	r0,r0[0x0]
80006246:	4f 7c       	lddpc	r12,80006420 <_malloc_r+0x70>

80006248 <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
80006248:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000624a:	fe 78 10 00 	mov	r8,-61440
8000624e:	30 19       	mov	r9,1
80006250:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006254:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006258:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
8000625c:	d3 03       	ssrf	0x10
	local_start_pll0();
8000625e:	f0 1f 00 12 	mcall	800062a4 <main+0x5c>
		
	INTC_init_interrupts();
80006262:	f0 1f 00 12 	mcall	800062a8 <main+0x60>
	
	log_init();		
80006266:	f0 1f 00 12 	mcall	800062ac <main+0x64>
	log("----start debug----");	
8000626a:	49 2c       	lddpc	r12,800062b0 <main+0x68>
8000626c:	f0 1f 00 12 	mcall	800062b4 <main+0x6c>
		
	//rtc_init();
	
	//fs_init();//65795机器无法通过文件系统初始化

	tc_init();	
80006270:	f0 1f 00 12 	mcall	800062b8 <main+0x70>
	
	app_init();
80006274:	f0 1f 00 12 	mcall	800062bc <main+0x74>
			
	xcmp_init();
80006278:	f0 1f 00 12 	mcall	800062c0 <main+0x78>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
8000627c:	fe 79 10 00 	mov	r9,-61440
80006280:	f2 f8 01 60 	ld.w	r8,r9[352]
80006284:	e2 18 00 02 	andl	r8,0x2,COH
80006288:	cf c0       	breq	80006280 <main+0x38>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000628a:	fe 79 10 00 	mov	r9,-61440
8000628e:	f2 f8 01 60 	ld.w	r8,r9[352]
80006292:	e2 18 00 02 	andl	r8,0x2,COH
80006296:	cf c1       	brne	8000628e <main+0x46>
	local_start_timer();
80006298:	f0 1f 00 0b 	mcall	800062c4 <main+0x7c>
	
	Enable_global_interrupt();
8000629c:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
8000629e:	f0 1f 00 0b 	mcall	800062c8 <main+0x80>
	return 0;
}
800062a2:	d8 0a       	popm	pc,r12=0
800062a4:	80 00       	ld.sh	r0,r0[0x0]
800062a6:	45 f4       	lddsp	r4,sp[0x17c]
800062a8:	80 00       	ld.sh	r0,r0[0x0]
800062aa:	47 84       	lddsp	r4,sp[0x1e0]
800062ac:	80 00       	ld.sh	r0,r0[0x0]
800062ae:	61 9c       	ld.w	r12,r0[0x64]
800062b0:	80 01       	ld.sh	r1,r0[0x0]
800062b2:	4f bc       	lddpc	r12,8000649c <_malloc_r+0xec>
800062b4:	80 00       	ld.sh	r0,r0[0x0]
800062b6:	5e 90       	retgt	r0
800062b8:	80 00       	ld.sh	r0,r0[0x0]
800062ba:	46 80       	lddsp	r0,sp[0x1a0]
800062bc:	80 00       	ld.sh	r0,r0[0x0]
800062be:	20 40       	sub	r0,4
800062c0:	80 00       	ld.sh	r0,r0[0x0]
800062c2:	3f 04       	mov	r4,-16
800062c4:	80 00       	ld.sh	r0,r0[0x0]
800062c6:	46 44       	lddsp	r4,sp[0x190]
800062c8:	80 00       	ld.sh	r0,r0[0x0]
800062ca:	5c b4       	swap.b	r4

800062cc <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800062cc:	f8 08 16 05 	lsr	r8,r12,0x5
800062d0:	a9 68       	lsl	r8,0x8
800062d2:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800062d6:	58 1b       	cp.w	r11,1
800062d8:	c0 d0       	breq	800062f2 <gpio_enable_module_pin+0x26>
800062da:	c0 63       	brcs	800062e6 <gpio_enable_module_pin+0x1a>
800062dc:	58 2b       	cp.w	r11,2
800062de:	c1 00       	breq	800062fe <gpio_enable_module_pin+0x32>
800062e0:	58 3b       	cp.w	r11,3
800062e2:	c1 40       	breq	8000630a <gpio_enable_module_pin+0x3e>
800062e4:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800062e6:	30 19       	mov	r9,1
800062e8:	f2 0c 09 49 	lsl	r9,r9,r12
800062ec:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800062ee:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800062f0:	c1 28       	rjmp	80006314 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800062f2:	30 19       	mov	r9,1
800062f4:	f2 0c 09 49 	lsl	r9,r9,r12
800062f8:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800062fa:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800062fc:	c0 c8       	rjmp	80006314 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800062fe:	30 19       	mov	r9,1
80006300:	f2 0c 09 49 	lsl	r9,r9,r12
80006304:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006306:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006308:	c0 68       	rjmp	80006314 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000630a:	30 19       	mov	r9,1
8000630c:	f2 0c 09 49 	lsl	r9,r9,r12
80006310:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006312:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80006314:	30 19       	mov	r9,1
80006316:	f2 0c 09 4c 	lsl	r12,r9,r12
8000631a:	91 2c       	st.w	r8[0x8],r12
8000631c:	5e fd       	retal	0
8000631e:	d7 03       	nop

80006320 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80006320:	d4 21       	pushm	r4-r7,lr
80006322:	18 97       	mov	r7,r12
80006324:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006326:	58 0b       	cp.w	r11,0
80006328:	c0 31       	brne	8000632e <gpio_enable_module+0xe>
8000632a:	30 05       	mov	r5,0
8000632c:	c0 d8       	rjmp	80006346 <gpio_enable_module+0x26>
8000632e:	30 06       	mov	r6,0
80006330:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80006332:	6e 1b       	ld.w	r11,r7[0x4]
80006334:	6e 0c       	ld.w	r12,r7[0x0]
80006336:	f0 1f 00 06 	mcall	8000634c <gpio_enable_module+0x2c>
8000633a:	18 45       	or	r5,r12
		gpiomap++;
8000633c:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000633e:	2f f6       	sub	r6,-1
80006340:	0c 34       	cp.w	r4,r6
80006342:	fe 9b ff f8 	brhi	80006332 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80006346:	0a 9c       	mov	r12,r5
80006348:	d8 22       	popm	r4-r7,pc
8000634a:	00 00       	add	r0,r0
8000634c:	80 00       	ld.sh	r0,r0[0x0]
8000634e:	62 cc       	ld.w	r12,r1[0x30]

80006350 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006350:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006354:	fe c0 a5 54 	sub	r0,pc,-23212

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006358:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
8000635c:	d5 53       	csrf	0x15
  cp      r0, r1
8000635e:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80006360:	e0 61 0a 38 	mov	r1,2616
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006364:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006366:	c0 62       	brcc	80006372 <idata_load_loop_end>
  cp      r0, r1
80006368:	48 92       	lddpc	r2,8000638c <udata_clear_loop_end+0x4>

8000636a <idata_load_loop>:
  brlo    idata_load_loop
8000636a:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
8000636c:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
8000636e:	02 30       	cp.w	r0,r1
  cp      r0, r1
80006370:	cf d3       	brcs	8000636a <idata_load_loop>

80006372 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80006372:	e0 60 0a 38 	mov	r0,2616
  mov     r2, 0
  mov     r3, 0
80006376:	e0 61 40 d8 	mov	r1,16600
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
8000637a:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
8000637c:	c0 62       	brcc	80006388 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000637e:	30 02       	mov	r2,0
80006380:	30 03       	mov	r3,0

80006382 <udata_clear_loop>:
80006382:	a1 22       	st.d	r0++,r2
80006384:	02 30       	cp.w	r0,r1
80006386:	cf e3       	brcs	80006382 <udata_clear_loop>

80006388 <udata_clear_loop_end>:
80006388:	fe cf 01 40 	sub	pc,pc,320
8000638c:	80 01       	ld.sh	r1,r0[0x0]
8000638e:	55 58       	stdsp	sp[0x154],r8

80006390 <free>:
80006390:	d4 01       	pushm	lr
80006392:	e0 68 0a 30 	mov	r8,2608
80006396:	18 9b       	mov	r11,r12
80006398:	70 0c       	ld.w	r12,r8[0x0]
8000639a:	e0 a0 1e 8f 	rcall	8000a0b8 <_free_r>
8000639e:	d8 02       	popm	pc

800063a0 <malloc>:
800063a0:	d4 01       	pushm	lr
800063a2:	e0 68 0a 30 	mov	r8,2608
800063a6:	18 9b       	mov	r11,r12
800063a8:	70 0c       	ld.w	r12,r8[0x0]
800063aa:	c0 3c       	rcall	800063b0 <_malloc_r>
800063ac:	d8 02       	popm	pc
800063ae:	d7 03       	nop

800063b0 <_malloc_r>:
800063b0:	d4 31       	pushm	r0-r7,lr
800063b2:	f6 c8 ff f5 	sub	r8,r11,-11
800063b6:	18 95       	mov	r5,r12
800063b8:	10 97       	mov	r7,r8
800063ba:	e0 17 ff f8 	andl	r7,0xfff8
800063be:	59 68       	cp.w	r8,22
800063c0:	f9 b7 08 10 	movls	r7,16
800063c4:	16 37       	cp.w	r7,r11
800063c6:	5f 38       	srlo	r8
800063c8:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800063cc:	c0 50       	breq	800063d6 <_malloc_r+0x26>
800063ce:	30 c8       	mov	r8,12
800063d0:	99 38       	st.w	r12[0xc],r8
800063d2:	e0 8f 01 fa 	bral	800067c6 <_malloc_r+0x416>
800063d6:	fe b0 f5 89 	rcall	80004ee8 <__malloc_lock>
800063da:	e0 47 01 f7 	cp.w	r7,503
800063de:	e0 8b 00 1d 	brhi	80006418 <_malloc_r+0x68>
800063e2:	ee 03 16 03 	lsr	r3,r7,0x3
800063e6:	e0 68 05 30 	mov	r8,1328
800063ea:	f0 03 00 38 	add	r8,r8,r3<<0x3
800063ee:	70 36       	ld.w	r6,r8[0xc]
800063f0:	10 36       	cp.w	r6,r8
800063f2:	c0 61       	brne	800063fe <_malloc_r+0x4e>
800063f4:	ec c8 ff f8 	sub	r8,r6,-8
800063f8:	70 36       	ld.w	r6,r8[0xc]
800063fa:	10 36       	cp.w	r6,r8
800063fc:	c0 c0       	breq	80006414 <_malloc_r+0x64>
800063fe:	6c 18       	ld.w	r8,r6[0x4]
80006400:	e0 18 ff fc 	andl	r8,0xfffc
80006404:	6c 3a       	ld.w	r10,r6[0xc]
80006406:	ec 08 00 09 	add	r9,r6,r8
8000640a:	0a 9c       	mov	r12,r5
8000640c:	6c 28       	ld.w	r8,r6[0x8]
8000640e:	95 28       	st.w	r10[0x8],r8
80006410:	91 3a       	st.w	r8[0xc],r10
80006412:	c4 78       	rjmp	800064a0 <_malloc_r+0xf0>
80006414:	2f e3       	sub	r3,-2
80006416:	c4 d8       	rjmp	800064b0 <_malloc_r+0x100>
80006418:	ee 03 16 09 	lsr	r3,r7,0x9
8000641c:	c0 41       	brne	80006424 <_malloc_r+0x74>
8000641e:	ee 03 16 03 	lsr	r3,r7,0x3
80006422:	c2 68       	rjmp	8000646e <_malloc_r+0xbe>
80006424:	58 43       	cp.w	r3,4
80006426:	e0 8b 00 06 	brhi	80006432 <_malloc_r+0x82>
8000642a:	ee 03 16 06 	lsr	r3,r7,0x6
8000642e:	2c 83       	sub	r3,-56
80006430:	c1 f8       	rjmp	8000646e <_malloc_r+0xbe>
80006432:	59 43       	cp.w	r3,20
80006434:	e0 8b 00 04 	brhi	8000643c <_malloc_r+0x8c>
80006438:	2a 53       	sub	r3,-91
8000643a:	c1 a8       	rjmp	8000646e <_malloc_r+0xbe>
8000643c:	e0 43 00 54 	cp.w	r3,84
80006440:	e0 8b 00 06 	brhi	8000644c <_malloc_r+0x9c>
80006444:	ee 03 16 0c 	lsr	r3,r7,0xc
80006448:	29 23       	sub	r3,-110
8000644a:	c1 28       	rjmp	8000646e <_malloc_r+0xbe>
8000644c:	e0 43 01 54 	cp.w	r3,340
80006450:	e0 8b 00 06 	brhi	8000645c <_malloc_r+0xac>
80006454:	ee 03 16 0f 	lsr	r3,r7,0xf
80006458:	28 93       	sub	r3,-119
8000645a:	c0 a8       	rjmp	8000646e <_malloc_r+0xbe>
8000645c:	e0 43 05 54 	cp.w	r3,1364
80006460:	e0 88 00 04 	brls	80006468 <_malloc_r+0xb8>
80006464:	37 e3       	mov	r3,126
80006466:	c0 48       	rjmp	8000646e <_malloc_r+0xbe>
80006468:	ee 03 16 12 	lsr	r3,r7,0x12
8000646c:	28 43       	sub	r3,-124
8000646e:	e0 6a 05 30 	mov	r10,1328
80006472:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006476:	74 36       	ld.w	r6,r10[0xc]
80006478:	c1 98       	rjmp	800064aa <_malloc_r+0xfa>
8000647a:	6c 19       	ld.w	r9,r6[0x4]
8000647c:	e0 19 ff fc 	andl	r9,0xfffc
80006480:	f2 07 01 0b 	sub	r11,r9,r7
80006484:	58 fb       	cp.w	r11,15
80006486:	e0 8a 00 04 	brle	8000648e <_malloc_r+0xde>
8000648a:	20 13       	sub	r3,1
8000648c:	c1 18       	rjmp	800064ae <_malloc_r+0xfe>
8000648e:	6c 38       	ld.w	r8,r6[0xc]
80006490:	58 0b       	cp.w	r11,0
80006492:	c0 b5       	brlt	800064a8 <_malloc_r+0xf8>
80006494:	6c 2a       	ld.w	r10,r6[0x8]
80006496:	ec 09 00 09 	add	r9,r6,r9
8000649a:	0a 9c       	mov	r12,r5
8000649c:	91 2a       	st.w	r8[0x8],r10
8000649e:	95 38       	st.w	r10[0xc],r8
800064a0:	72 18       	ld.w	r8,r9[0x4]
800064a2:	a1 a8       	sbr	r8,0x0
800064a4:	93 18       	st.w	r9[0x4],r8
800064a6:	cb c8       	rjmp	8000661e <_malloc_r+0x26e>
800064a8:	10 96       	mov	r6,r8
800064aa:	14 36       	cp.w	r6,r10
800064ac:	ce 71       	brne	8000647a <_malloc_r+0xca>
800064ae:	2f f3       	sub	r3,-1
800064b0:	e0 6a 05 30 	mov	r10,1328
800064b4:	f4 cc ff f8 	sub	r12,r10,-8
800064b8:	78 26       	ld.w	r6,r12[0x8]
800064ba:	18 36       	cp.w	r6,r12
800064bc:	c6 c0       	breq	80006594 <_malloc_r+0x1e4>
800064be:	6c 19       	ld.w	r9,r6[0x4]
800064c0:	e0 19 ff fc 	andl	r9,0xfffc
800064c4:	f2 07 01 08 	sub	r8,r9,r7
800064c8:	58 f8       	cp.w	r8,15
800064ca:	e0 89 00 8f 	brgt	800065e8 <_malloc_r+0x238>
800064ce:	99 3c       	st.w	r12[0xc],r12
800064d0:	99 2c       	st.w	r12[0x8],r12
800064d2:	58 08       	cp.w	r8,0
800064d4:	c0 55       	brlt	800064de <_malloc_r+0x12e>
800064d6:	ec 09 00 09 	add	r9,r6,r9
800064da:	0a 9c       	mov	r12,r5
800064dc:	ce 2b       	rjmp	800064a0 <_malloc_r+0xf0>
800064de:	e0 49 01 ff 	cp.w	r9,511
800064e2:	e0 8b 00 13 	brhi	80006508 <_malloc_r+0x158>
800064e6:	a3 99       	lsr	r9,0x3
800064e8:	f4 09 00 38 	add	r8,r10,r9<<0x3
800064ec:	70 2b       	ld.w	r11,r8[0x8]
800064ee:	8d 38       	st.w	r6[0xc],r8
800064f0:	8d 2b       	st.w	r6[0x8],r11
800064f2:	97 36       	st.w	r11[0xc],r6
800064f4:	91 26       	st.w	r8[0x8],r6
800064f6:	a3 49       	asr	r9,0x2
800064f8:	74 18       	ld.w	r8,r10[0x4]
800064fa:	30 1b       	mov	r11,1
800064fc:	f6 09 09 49 	lsl	r9,r11,r9
80006500:	f1 e9 10 09 	or	r9,r8,r9
80006504:	95 19       	st.w	r10[0x4],r9
80006506:	c4 78       	rjmp	80006594 <_malloc_r+0x1e4>
80006508:	f2 0a 16 09 	lsr	r10,r9,0x9
8000650c:	58 4a       	cp.w	r10,4
8000650e:	e0 8b 00 07 	brhi	8000651c <_malloc_r+0x16c>
80006512:	f2 0a 16 06 	lsr	r10,r9,0x6
80006516:	2c 8a       	sub	r10,-56
80006518:	c2 08       	rjmp	80006558 <_malloc_r+0x1a8>
8000651a:	d7 03       	nop
8000651c:	59 4a       	cp.w	r10,20
8000651e:	e0 8b 00 04 	brhi	80006526 <_malloc_r+0x176>
80006522:	2a 5a       	sub	r10,-91
80006524:	c1 a8       	rjmp	80006558 <_malloc_r+0x1a8>
80006526:	e0 4a 00 54 	cp.w	r10,84
8000652a:	e0 8b 00 06 	brhi	80006536 <_malloc_r+0x186>
8000652e:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006532:	29 2a       	sub	r10,-110
80006534:	c1 28       	rjmp	80006558 <_malloc_r+0x1a8>
80006536:	e0 4a 01 54 	cp.w	r10,340
8000653a:	e0 8b 00 06 	brhi	80006546 <_malloc_r+0x196>
8000653e:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006542:	28 9a       	sub	r10,-119
80006544:	c0 a8       	rjmp	80006558 <_malloc_r+0x1a8>
80006546:	e0 4a 05 54 	cp.w	r10,1364
8000654a:	e0 88 00 04 	brls	80006552 <_malloc_r+0x1a2>
8000654e:	37 ea       	mov	r10,126
80006550:	c0 48       	rjmp	80006558 <_malloc_r+0x1a8>
80006552:	f2 0a 16 12 	lsr	r10,r9,0x12
80006556:	28 4a       	sub	r10,-124
80006558:	e0 6b 05 30 	mov	r11,1328
8000655c:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006560:	68 28       	ld.w	r8,r4[0x8]
80006562:	08 38       	cp.w	r8,r4
80006564:	c0 e1       	brne	80006580 <_malloc_r+0x1d0>
80006566:	76 19       	ld.w	r9,r11[0x4]
80006568:	a3 4a       	asr	r10,0x2
8000656a:	30 1e       	mov	lr,1
8000656c:	fc 0a 09 4a 	lsl	r10,lr,r10
80006570:	f3 ea 10 0a 	or	r10,r9,r10
80006574:	10 99       	mov	r9,r8
80006576:	97 1a       	st.w	r11[0x4],r10
80006578:	c0 a8       	rjmp	8000658c <_malloc_r+0x1dc>
8000657a:	70 28       	ld.w	r8,r8[0x8]
8000657c:	08 38       	cp.w	r8,r4
8000657e:	c0 60       	breq	8000658a <_malloc_r+0x1da>
80006580:	70 1a       	ld.w	r10,r8[0x4]
80006582:	e0 1a ff fc 	andl	r10,0xfffc
80006586:	14 39       	cp.w	r9,r10
80006588:	cf 93       	brcs	8000657a <_malloc_r+0x1ca>
8000658a:	70 39       	ld.w	r9,r8[0xc]
8000658c:	8d 39       	st.w	r6[0xc],r9
8000658e:	8d 28       	st.w	r6[0x8],r8
80006590:	91 36       	st.w	r8[0xc],r6
80006592:	93 26       	st.w	r9[0x8],r6
80006594:	e6 08 14 02 	asr	r8,r3,0x2
80006598:	30 1b       	mov	r11,1
8000659a:	e0 64 05 30 	mov	r4,1328
8000659e:	f6 08 09 4b 	lsl	r11,r11,r8
800065a2:	68 18       	ld.w	r8,r4[0x4]
800065a4:	10 3b       	cp.w	r11,r8
800065a6:	e0 8b 00 6b 	brhi	8000667c <_malloc_r+0x2cc>
800065aa:	f7 e8 00 09 	and	r9,r11,r8
800065ae:	c0 b1       	brne	800065c4 <_malloc_r+0x214>
800065b0:	e0 13 ff fc 	andl	r3,0xfffc
800065b4:	a1 7b       	lsl	r11,0x1
800065b6:	2f c3       	sub	r3,-4
800065b8:	c0 38       	rjmp	800065be <_malloc_r+0x20e>
800065ba:	2f c3       	sub	r3,-4
800065bc:	a1 7b       	lsl	r11,0x1
800065be:	f7 e8 00 09 	and	r9,r11,r8
800065c2:	cf c0       	breq	800065ba <_malloc_r+0x20a>
800065c4:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800065c8:	06 92       	mov	r2,r3
800065ca:	1c 91       	mov	r1,lr
800065cc:	62 36       	ld.w	r6,r1[0xc]
800065ce:	c2 e8       	rjmp	8000662a <_malloc_r+0x27a>
800065d0:	6c 1a       	ld.w	r10,r6[0x4]
800065d2:	e0 1a ff fc 	andl	r10,0xfffc
800065d6:	f4 07 01 08 	sub	r8,r10,r7
800065da:	58 f8       	cp.w	r8,15
800065dc:	e0 8a 00 15 	brle	80006606 <_malloc_r+0x256>
800065e0:	6c 3a       	ld.w	r10,r6[0xc]
800065e2:	6c 29       	ld.w	r9,r6[0x8]
800065e4:	95 29       	st.w	r10[0x8],r9
800065e6:	93 3a       	st.w	r9[0xc],r10
800065e8:	0e 99       	mov	r9,r7
800065ea:	ec 07 00 07 	add	r7,r6,r7
800065ee:	a1 a9       	sbr	r9,0x0
800065f0:	99 37       	st.w	r12[0xc],r7
800065f2:	99 27       	st.w	r12[0x8],r7
800065f4:	8d 19       	st.w	r6[0x4],r9
800065f6:	ee 08 09 08 	st.w	r7[r8],r8
800065fa:	8f 2c       	st.w	r7[0x8],r12
800065fc:	8f 3c       	st.w	r7[0xc],r12
800065fe:	a1 a8       	sbr	r8,0x0
80006600:	0a 9c       	mov	r12,r5
80006602:	8f 18       	st.w	r7[0x4],r8
80006604:	c0 d8       	rjmp	8000661e <_malloc_r+0x26e>
80006606:	6c 39       	ld.w	r9,r6[0xc]
80006608:	58 08       	cp.w	r8,0
8000660a:	c0 f5       	brlt	80006628 <_malloc_r+0x278>
8000660c:	ec 0a 00 0a 	add	r10,r6,r10
80006610:	74 18       	ld.w	r8,r10[0x4]
80006612:	a1 a8       	sbr	r8,0x0
80006614:	0a 9c       	mov	r12,r5
80006616:	95 18       	st.w	r10[0x4],r8
80006618:	6c 28       	ld.w	r8,r6[0x8]
8000661a:	93 28       	st.w	r9[0x8],r8
8000661c:	91 39       	st.w	r8[0xc],r9
8000661e:	fe b0 f4 6b 	rcall	80004ef4 <__malloc_unlock>
80006622:	ec cc ff f8 	sub	r12,r6,-8
80006626:	d8 32       	popm	r0-r7,pc
80006628:	12 96       	mov	r6,r9
8000662a:	02 36       	cp.w	r6,r1
8000662c:	cd 21       	brne	800065d0 <_malloc_r+0x220>
8000662e:	2f f2       	sub	r2,-1
80006630:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006634:	c0 30       	breq	8000663a <_malloc_r+0x28a>
80006636:	2f 81       	sub	r1,-8
80006638:	cc ab       	rjmp	800065cc <_malloc_r+0x21c>
8000663a:	1c 98       	mov	r8,lr
8000663c:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006640:	c0 81       	brne	80006650 <_malloc_r+0x2a0>
80006642:	68 19       	ld.w	r9,r4[0x4]
80006644:	f6 08 11 ff 	rsub	r8,r11,-1
80006648:	f3 e8 00 08 	and	r8,r9,r8
8000664c:	89 18       	st.w	r4[0x4],r8
8000664e:	c0 78       	rjmp	8000665c <_malloc_r+0x2ac>
80006650:	f0 c9 00 08 	sub	r9,r8,8
80006654:	20 13       	sub	r3,1
80006656:	70 08       	ld.w	r8,r8[0x0]
80006658:	12 38       	cp.w	r8,r9
8000665a:	cf 10       	breq	8000663c <_malloc_r+0x28c>
8000665c:	a1 7b       	lsl	r11,0x1
8000665e:	68 18       	ld.w	r8,r4[0x4]
80006660:	10 3b       	cp.w	r11,r8
80006662:	e0 8b 00 0d 	brhi	8000667c <_malloc_r+0x2cc>
80006666:	58 0b       	cp.w	r11,0
80006668:	c0 a0       	breq	8000667c <_malloc_r+0x2cc>
8000666a:	04 93       	mov	r3,r2
8000666c:	c0 38       	rjmp	80006672 <_malloc_r+0x2c2>
8000666e:	2f c3       	sub	r3,-4
80006670:	a1 7b       	lsl	r11,0x1
80006672:	f7 e8 00 09 	and	r9,r11,r8
80006676:	ca 71       	brne	800065c4 <_malloc_r+0x214>
80006678:	cf bb       	rjmp	8000666e <_malloc_r+0x2be>
8000667a:	d7 03       	nop
8000667c:	68 23       	ld.w	r3,r4[0x8]
8000667e:	66 12       	ld.w	r2,r3[0x4]
80006680:	e0 12 ff fc 	andl	r2,0xfffc
80006684:	0e 32       	cp.w	r2,r7
80006686:	5f 39       	srlo	r9
80006688:	e4 07 01 08 	sub	r8,r2,r7
8000668c:	58 f8       	cp.w	r8,15
8000668e:	5f aa       	srle	r10
80006690:	f5 e9 10 09 	or	r9,r10,r9
80006694:	e0 80 00 9a 	breq	800067c8 <_malloc_r+0x418>
80006698:	e0 68 0d 48 	mov	r8,3400
8000669c:	70 01       	ld.w	r1,r8[0x0]
8000669e:	e0 68 09 3c 	mov	r8,2364
800066a2:	2f 01       	sub	r1,-16
800066a4:	70 08       	ld.w	r8,r8[0x0]
800066a6:	0e 01       	add	r1,r7
800066a8:	5b f8       	cp.w	r8,-1
800066aa:	c0 40       	breq	800066b2 <_malloc_r+0x302>
800066ac:	28 11       	sub	r1,-127
800066ae:	e0 11 ff 80 	andl	r1,0xff80
800066b2:	02 9b       	mov	r11,r1
800066b4:	0a 9c       	mov	r12,r5
800066b6:	e0 a0 02 a5 	rcall	80006c00 <_sbrk_r>
800066ba:	18 96       	mov	r6,r12
800066bc:	5b fc       	cp.w	r12,-1
800066be:	c7 50       	breq	800067a8 <_malloc_r+0x3f8>
800066c0:	e6 02 00 08 	add	r8,r3,r2
800066c4:	10 3c       	cp.w	r12,r8
800066c6:	c0 32       	brcc	800066cc <_malloc_r+0x31c>
800066c8:	08 33       	cp.w	r3,r4
800066ca:	c6 f1       	brne	800067a8 <_malloc_r+0x3f8>
800066cc:	e0 6a 0d 4c 	mov	r10,3404
800066d0:	74 09       	ld.w	r9,r10[0x0]
800066d2:	e2 09 00 09 	add	r9,r1,r9
800066d6:	95 09       	st.w	r10[0x0],r9
800066d8:	10 36       	cp.w	r6,r8
800066da:	c0 a1       	brne	800066ee <_malloc_r+0x33e>
800066dc:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800066e0:	c0 71       	brne	800066ee <_malloc_r+0x33e>
800066e2:	e2 02 00 02 	add	r2,r1,r2
800066e6:	68 28       	ld.w	r8,r4[0x8]
800066e8:	a1 a2       	sbr	r2,0x0
800066ea:	91 12       	st.w	r8[0x4],r2
800066ec:	c4 f8       	rjmp	8000678a <_malloc_r+0x3da>
800066ee:	e0 6a 09 3c 	mov	r10,2364
800066f2:	74 0b       	ld.w	r11,r10[0x0]
800066f4:	5b fb       	cp.w	r11,-1
800066f6:	c0 31       	brne	800066fc <_malloc_r+0x34c>
800066f8:	95 06       	st.w	r10[0x0],r6
800066fa:	c0 78       	rjmp	80006708 <_malloc_r+0x358>
800066fc:	ec 09 00 09 	add	r9,r6,r9
80006700:	e0 6a 0d 4c 	mov	r10,3404
80006704:	10 19       	sub	r9,r8
80006706:	95 09       	st.w	r10[0x0],r9
80006708:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000670c:	f0 09 11 08 	rsub	r9,r8,8
80006710:	58 08       	cp.w	r8,0
80006712:	f2 08 17 10 	movne	r8,r9
80006716:	ed d8 e1 06 	addne	r6,r6,r8
8000671a:	28 08       	sub	r8,-128
8000671c:	ec 01 00 01 	add	r1,r6,r1
80006720:	0a 9c       	mov	r12,r5
80006722:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006726:	f0 01 01 01 	sub	r1,r8,r1
8000672a:	02 9b       	mov	r11,r1
8000672c:	e0 a0 02 6a 	rcall	80006c00 <_sbrk_r>
80006730:	e0 68 0d 4c 	mov	r8,3404
80006734:	5b fc       	cp.w	r12,-1
80006736:	ec 0c 17 00 	moveq	r12,r6
8000673a:	f9 b1 00 00 	moveq	r1,0
8000673e:	70 09       	ld.w	r9,r8[0x0]
80006740:	0c 1c       	sub	r12,r6
80006742:	89 26       	st.w	r4[0x8],r6
80006744:	02 0c       	add	r12,r1
80006746:	12 01       	add	r1,r9
80006748:	a1 ac       	sbr	r12,0x0
8000674a:	91 01       	st.w	r8[0x0],r1
8000674c:	8d 1c       	st.w	r6[0x4],r12
8000674e:	08 33       	cp.w	r3,r4
80006750:	c1 d0       	breq	8000678a <_malloc_r+0x3da>
80006752:	58 f2       	cp.w	r2,15
80006754:	e0 8b 00 05 	brhi	8000675e <_malloc_r+0x3ae>
80006758:	30 18       	mov	r8,1
8000675a:	8d 18       	st.w	r6[0x4],r8
8000675c:	c2 68       	rjmp	800067a8 <_malloc_r+0x3f8>
8000675e:	30 59       	mov	r9,5
80006760:	20 c2       	sub	r2,12
80006762:	e0 12 ff f8 	andl	r2,0xfff8
80006766:	e6 02 00 08 	add	r8,r3,r2
8000676a:	91 29       	st.w	r8[0x8],r9
8000676c:	91 19       	st.w	r8[0x4],r9
8000676e:	66 18       	ld.w	r8,r3[0x4]
80006770:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006774:	e5 e8 10 08 	or	r8,r2,r8
80006778:	87 18       	st.w	r3[0x4],r8
8000677a:	58 f2       	cp.w	r2,15
8000677c:	e0 88 00 07 	brls	8000678a <_malloc_r+0x3da>
80006780:	e6 cb ff f8 	sub	r11,r3,-8
80006784:	0a 9c       	mov	r12,r5
80006786:	e0 a0 1c 99 	rcall	8000a0b8 <_free_r>
8000678a:	e0 69 0d 44 	mov	r9,3396
8000678e:	72 0a       	ld.w	r10,r9[0x0]
80006790:	e0 68 0d 4c 	mov	r8,3404
80006794:	70 08       	ld.w	r8,r8[0x0]
80006796:	14 38       	cp.w	r8,r10
80006798:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000679c:	e0 69 0d 40 	mov	r9,3392
800067a0:	72 0a       	ld.w	r10,r9[0x0]
800067a2:	14 38       	cp.w	r8,r10
800067a4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800067a8:	68 28       	ld.w	r8,r4[0x8]
800067aa:	70 18       	ld.w	r8,r8[0x4]
800067ac:	e0 18 ff fc 	andl	r8,0xfffc
800067b0:	0e 38       	cp.w	r8,r7
800067b2:	5f 39       	srlo	r9
800067b4:	0e 18       	sub	r8,r7
800067b6:	58 f8       	cp.w	r8,15
800067b8:	5f aa       	srle	r10
800067ba:	f5 e9 10 09 	or	r9,r10,r9
800067be:	c0 50       	breq	800067c8 <_malloc_r+0x418>
800067c0:	0a 9c       	mov	r12,r5
800067c2:	fe b0 f3 99 	rcall	80004ef4 <__malloc_unlock>
800067c6:	d8 3a       	popm	r0-r7,pc,r12=0
800067c8:	68 26       	ld.w	r6,r4[0x8]
800067ca:	a1 a8       	sbr	r8,0x0
800067cc:	0e 99       	mov	r9,r7
800067ce:	a1 a9       	sbr	r9,0x0
800067d0:	8d 19       	st.w	r6[0x4],r9
800067d2:	ec 07 00 07 	add	r7,r6,r7
800067d6:	0a 9c       	mov	r12,r5
800067d8:	89 27       	st.w	r4[0x8],r7
800067da:	8f 18       	st.w	r7[0x4],r8
800067dc:	fe b0 f3 8c 	rcall	80004ef4 <__malloc_unlock>
800067e0:	ec cc ff f8 	sub	r12,r6,-8
800067e4:	d8 32       	popm	r0-r7,pc
800067e6:	d7 03       	nop

800067e8 <memcpy>:
800067e8:	58 8a       	cp.w	r10,8
800067ea:	c2 f5       	brlt	80006848 <memcpy+0x60>
800067ec:	f9 eb 10 09 	or	r9,r12,r11
800067f0:	e2 19 00 03 	andl	r9,0x3,COH
800067f4:	e0 81 00 97 	brne	80006922 <memcpy+0x13a>
800067f8:	e0 4a 00 20 	cp.w	r10,32
800067fc:	c3 b4       	brge	80006872 <memcpy+0x8a>
800067fe:	f4 08 14 02 	asr	r8,r10,0x2
80006802:	f0 09 11 08 	rsub	r9,r8,8
80006806:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000680a:	76 69       	ld.w	r9,r11[0x18]
8000680c:	99 69       	st.w	r12[0x18],r9
8000680e:	76 59       	ld.w	r9,r11[0x14]
80006810:	99 59       	st.w	r12[0x14],r9
80006812:	76 49       	ld.w	r9,r11[0x10]
80006814:	99 49       	st.w	r12[0x10],r9
80006816:	76 39       	ld.w	r9,r11[0xc]
80006818:	99 39       	st.w	r12[0xc],r9
8000681a:	76 29       	ld.w	r9,r11[0x8]
8000681c:	99 29       	st.w	r12[0x8],r9
8000681e:	76 19       	ld.w	r9,r11[0x4]
80006820:	99 19       	st.w	r12[0x4],r9
80006822:	76 09       	ld.w	r9,r11[0x0]
80006824:	99 09       	st.w	r12[0x0],r9
80006826:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000682a:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000682e:	e0 1a 00 03 	andl	r10,0x3
80006832:	f4 0a 11 04 	rsub	r10,r10,4
80006836:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000683a:	17 a9       	ld.ub	r9,r11[0x2]
8000683c:	b0 a9       	st.b	r8[0x2],r9
8000683e:	17 99       	ld.ub	r9,r11[0x1]
80006840:	b0 99       	st.b	r8[0x1],r9
80006842:	17 89       	ld.ub	r9,r11[0x0]
80006844:	b0 89       	st.b	r8[0x0],r9
80006846:	5e fc       	retal	r12
80006848:	f4 0a 11 09 	rsub	r10,r10,9
8000684c:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006850:	17 f9       	ld.ub	r9,r11[0x7]
80006852:	b8 f9       	st.b	r12[0x7],r9
80006854:	17 e9       	ld.ub	r9,r11[0x6]
80006856:	b8 e9       	st.b	r12[0x6],r9
80006858:	17 d9       	ld.ub	r9,r11[0x5]
8000685a:	b8 d9       	st.b	r12[0x5],r9
8000685c:	17 c9       	ld.ub	r9,r11[0x4]
8000685e:	b8 c9       	st.b	r12[0x4],r9
80006860:	17 b9       	ld.ub	r9,r11[0x3]
80006862:	b8 b9       	st.b	r12[0x3],r9
80006864:	17 a9       	ld.ub	r9,r11[0x2]
80006866:	b8 a9       	st.b	r12[0x2],r9
80006868:	17 99       	ld.ub	r9,r11[0x1]
8000686a:	b8 99       	st.b	r12[0x1],r9
8000686c:	17 89       	ld.ub	r9,r11[0x0]
8000686e:	b8 89       	st.b	r12[0x0],r9
80006870:	5e fc       	retal	r12
80006872:	eb cd 40 c0 	pushm	r6-r7,lr
80006876:	18 99       	mov	r9,r12
80006878:	22 0a       	sub	r10,32
8000687a:	b7 07       	ld.d	r6,r11++
8000687c:	b3 26       	st.d	r9++,r6
8000687e:	b7 07       	ld.d	r6,r11++
80006880:	b3 26       	st.d	r9++,r6
80006882:	b7 07       	ld.d	r6,r11++
80006884:	b3 26       	st.d	r9++,r6
80006886:	b7 07       	ld.d	r6,r11++
80006888:	b3 26       	st.d	r9++,r6
8000688a:	22 0a       	sub	r10,32
8000688c:	cf 74       	brge	8000687a <memcpy+0x92>
8000688e:	2f 0a       	sub	r10,-16
80006890:	c0 65       	brlt	8000689c <memcpy+0xb4>
80006892:	b7 07       	ld.d	r6,r11++
80006894:	b3 26       	st.d	r9++,r6
80006896:	b7 07       	ld.d	r6,r11++
80006898:	b3 26       	st.d	r9++,r6
8000689a:	21 0a       	sub	r10,16
8000689c:	5c 3a       	neg	r10
8000689e:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800068a2:	d7 03       	nop
800068a4:	d7 03       	nop
800068a6:	f7 36 00 0e 	ld.ub	r6,r11[14]
800068aa:	f3 66 00 0e 	st.b	r9[14],r6
800068ae:	f7 36 00 0d 	ld.ub	r6,r11[13]
800068b2:	f3 66 00 0d 	st.b	r9[13],r6
800068b6:	f7 36 00 0c 	ld.ub	r6,r11[12]
800068ba:	f3 66 00 0c 	st.b	r9[12],r6
800068be:	f7 36 00 0b 	ld.ub	r6,r11[11]
800068c2:	f3 66 00 0b 	st.b	r9[11],r6
800068c6:	f7 36 00 0a 	ld.ub	r6,r11[10]
800068ca:	f3 66 00 0a 	st.b	r9[10],r6
800068ce:	f7 36 00 09 	ld.ub	r6,r11[9]
800068d2:	f3 66 00 09 	st.b	r9[9],r6
800068d6:	f7 36 00 08 	ld.ub	r6,r11[8]
800068da:	f3 66 00 08 	st.b	r9[8],r6
800068de:	f7 36 00 07 	ld.ub	r6,r11[7]
800068e2:	f3 66 00 07 	st.b	r9[7],r6
800068e6:	f7 36 00 06 	ld.ub	r6,r11[6]
800068ea:	f3 66 00 06 	st.b	r9[6],r6
800068ee:	f7 36 00 05 	ld.ub	r6,r11[5]
800068f2:	f3 66 00 05 	st.b	r9[5],r6
800068f6:	f7 36 00 04 	ld.ub	r6,r11[4]
800068fa:	f3 66 00 04 	st.b	r9[4],r6
800068fe:	f7 36 00 03 	ld.ub	r6,r11[3]
80006902:	f3 66 00 03 	st.b	r9[3],r6
80006906:	f7 36 00 02 	ld.ub	r6,r11[2]
8000690a:	f3 66 00 02 	st.b	r9[2],r6
8000690e:	f7 36 00 01 	ld.ub	r6,r11[1]
80006912:	f3 66 00 01 	st.b	r9[1],r6
80006916:	f7 36 00 00 	ld.ub	r6,r11[0]
8000691a:	f3 66 00 00 	st.b	r9[0],r6
8000691e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006922:	20 1a       	sub	r10,1
80006924:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006928:	f8 0a 0b 09 	st.b	r12[r10],r9
8000692c:	cf b1       	brne	80006922 <memcpy+0x13a>
8000692e:	5e fc       	retal	r12

80006930 <memset>:
80006930:	18 98       	mov	r8,r12
80006932:	c0 38       	rjmp	80006938 <memset+0x8>
80006934:	10 cb       	st.b	r8++,r11
80006936:	20 1a       	sub	r10,1
80006938:	58 0a       	cp.w	r10,0
8000693a:	cf d1       	brne	80006934 <memset+0x4>
8000693c:	5e fc       	retal	r12
8000693e:	d7 03       	nop

80006940 <_realloc_r>:
80006940:	d4 31       	pushm	r0-r7,lr
80006942:	20 1d       	sub	sp,4
80006944:	16 94       	mov	r4,r11
80006946:	18 92       	mov	r2,r12
80006948:	14 9b       	mov	r11,r10
8000694a:	58 04       	cp.w	r4,0
8000694c:	c0 51       	brne	80006956 <_realloc_r+0x16>
8000694e:	fe b0 fd 31 	rcall	800063b0 <_malloc_r>
80006952:	18 95       	mov	r5,r12
80006954:	c5 39       	rjmp	80006bfa <_realloc_r+0x2ba>
80006956:	50 0a       	stdsp	sp[0x0],r10
80006958:	fe b0 f2 c8 	rcall	80004ee8 <__malloc_lock>
8000695c:	40 0b       	lddsp	r11,sp[0x0]
8000695e:	f6 c8 ff f5 	sub	r8,r11,-11
80006962:	e8 c1 00 08 	sub	r1,r4,8
80006966:	10 96       	mov	r6,r8
80006968:	62 1c       	ld.w	r12,r1[0x4]
8000696a:	e0 16 ff f8 	andl	r6,0xfff8
8000696e:	59 68       	cp.w	r8,22
80006970:	f9 b6 08 10 	movls	r6,16
80006974:	16 36       	cp.w	r6,r11
80006976:	5f 38       	srlo	r8
80006978:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8000697c:	c0 50       	breq	80006986 <_realloc_r+0x46>
8000697e:	30 c8       	mov	r8,12
80006980:	30 05       	mov	r5,0
80006982:	85 38       	st.w	r2[0xc],r8
80006984:	c3 b9       	rjmp	80006bfa <_realloc_r+0x2ba>
80006986:	18 90       	mov	r0,r12
80006988:	e0 10 ff fc 	andl	r0,0xfffc
8000698c:	0c 30       	cp.w	r0,r6
8000698e:	e0 84 01 0b 	brge	80006ba4 <_realloc_r+0x264>
80006992:	e0 68 05 30 	mov	r8,1328
80006996:	e2 00 00 09 	add	r9,r1,r0
8000699a:	70 25       	ld.w	r5,r8[0x8]
8000699c:	0a 39       	cp.w	r9,r5
8000699e:	c0 90       	breq	800069b0 <_realloc_r+0x70>
800069a0:	72 1a       	ld.w	r10,r9[0x4]
800069a2:	a1 ca       	cbr	r10,0x0
800069a4:	f2 0a 00 0a 	add	r10,r9,r10
800069a8:	74 1a       	ld.w	r10,r10[0x4]
800069aa:	ed ba 00 00 	bld	r10,0x0
800069ae:	c2 20       	breq	800069f2 <_realloc_r+0xb2>
800069b0:	72 1a       	ld.w	r10,r9[0x4]
800069b2:	e0 1a ff fc 	andl	r10,0xfffc
800069b6:	f4 00 00 03 	add	r3,r10,r0
800069ba:	0a 39       	cp.w	r9,r5
800069bc:	c1 31       	brne	800069e2 <_realloc_r+0xa2>
800069be:	ec c7 ff f0 	sub	r7,r6,-16
800069c2:	0e 33       	cp.w	r3,r7
800069c4:	c1 95       	brlt	800069f6 <_realloc_r+0xb6>
800069c6:	e2 06 00 09 	add	r9,r1,r6
800069ca:	0c 13       	sub	r3,r6
800069cc:	a1 a3       	sbr	r3,0x0
800069ce:	93 13       	st.w	r9[0x4],r3
800069d0:	91 29       	st.w	r8[0x8],r9
800069d2:	04 9c       	mov	r12,r2
800069d4:	62 18       	ld.w	r8,r1[0x4]
800069d6:	08 95       	mov	r5,r4
800069d8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800069dc:	10 46       	or	r6,r8
800069de:	83 16       	st.w	r1[0x4],r6
800069e0:	c0 b9       	rjmp	80006bf6 <_realloc_r+0x2b6>
800069e2:	0c 33       	cp.w	r3,r6
800069e4:	c0 95       	brlt	800069f6 <_realloc_r+0xb6>
800069e6:	72 28       	ld.w	r8,r9[0x8]
800069e8:	02 97       	mov	r7,r1
800069ea:	72 39       	ld.w	r9,r9[0xc]
800069ec:	93 28       	st.w	r9[0x8],r8
800069ee:	91 39       	st.w	r8[0xc],r9
800069f0:	cd c8       	rjmp	80006ba8 <_realloc_r+0x268>
800069f2:	30 0a       	mov	r10,0
800069f4:	14 99       	mov	r9,r10
800069f6:	ed bc 00 00 	bld	r12,0x0
800069fa:	e0 80 00 95 	breq	80006b24 <_realloc_r+0x1e4>
800069fe:	62 07       	ld.w	r7,r1[0x0]
80006a00:	e2 07 01 07 	sub	r7,r1,r7
80006a04:	6e 1c       	ld.w	r12,r7[0x4]
80006a06:	e0 1c ff fc 	andl	r12,0xfffc
80006a0a:	58 09       	cp.w	r9,0
80006a0c:	c5 60       	breq	80006ab8 <_realloc_r+0x178>
80006a0e:	f8 00 00 03 	add	r3,r12,r0
80006a12:	0a 39       	cp.w	r9,r5
80006a14:	c4 81       	brne	80006aa4 <_realloc_r+0x164>
80006a16:	14 03       	add	r3,r10
80006a18:	ec c9 ff f0 	sub	r9,r6,-16
80006a1c:	12 33       	cp.w	r3,r9
80006a1e:	c4 d5       	brlt	80006ab8 <_realloc_r+0x178>
80006a20:	6e 3a       	ld.w	r10,r7[0xc]
80006a22:	6e 29       	ld.w	r9,r7[0x8]
80006a24:	95 29       	st.w	r10[0x8],r9
80006a26:	93 3a       	st.w	r9[0xc],r10
80006a28:	ee c5 ff f8 	sub	r5,r7,-8
80006a2c:	e0 ca 00 04 	sub	r10,r0,4
80006a30:	e0 4a 00 24 	cp.w	r10,36
80006a34:	e0 8b 00 25 	brhi	80006a7e <_realloc_r+0x13e>
80006a38:	0a 99       	mov	r9,r5
80006a3a:	59 3a       	cp.w	r10,19
80006a3c:	e0 88 00 1a 	brls	80006a70 <_realloc_r+0x130>
80006a40:	09 09       	ld.w	r9,r4++
80006a42:	8b 09       	st.w	r5[0x0],r9
80006a44:	09 09       	ld.w	r9,r4++
80006a46:	8f 39       	st.w	r7[0xc],r9
80006a48:	ee c9 ff f0 	sub	r9,r7,-16
80006a4c:	59 ba       	cp.w	r10,27
80006a4e:	e0 88 00 11 	brls	80006a70 <_realloc_r+0x130>
80006a52:	09 0b       	ld.w	r11,r4++
80006a54:	93 0b       	st.w	r9[0x0],r11
80006a56:	09 09       	ld.w	r9,r4++
80006a58:	8f 59       	st.w	r7[0x14],r9
80006a5a:	ee c9 ff e8 	sub	r9,r7,-24
80006a5e:	e0 4a 00 24 	cp.w	r10,36
80006a62:	c0 71       	brne	80006a70 <_realloc_r+0x130>
80006a64:	09 0a       	ld.w	r10,r4++
80006a66:	93 0a       	st.w	r9[0x0],r10
80006a68:	ee c9 ff e0 	sub	r9,r7,-32
80006a6c:	09 0a       	ld.w	r10,r4++
80006a6e:	8f 7a       	st.w	r7[0x1c],r10
80006a70:	09 0a       	ld.w	r10,r4++
80006a72:	12 aa       	st.w	r9++,r10
80006a74:	68 0a       	ld.w	r10,r4[0x0]
80006a76:	93 0a       	st.w	r9[0x0],r10
80006a78:	68 1a       	ld.w	r10,r4[0x4]
80006a7a:	93 1a       	st.w	r9[0x4],r10
80006a7c:	c0 78       	rjmp	80006a8a <_realloc_r+0x14a>
80006a7e:	50 08       	stdsp	sp[0x0],r8
80006a80:	08 9b       	mov	r11,r4
80006a82:	0a 9c       	mov	r12,r5
80006a84:	e0 a0 1d bd 	rcall	8000a5fe <memmove>
80006a88:	40 08       	lddsp	r8,sp[0x0]
80006a8a:	ee 06 00 09 	add	r9,r7,r6
80006a8e:	0c 13       	sub	r3,r6
80006a90:	a1 a3       	sbr	r3,0x0
80006a92:	93 13       	st.w	r9[0x4],r3
80006a94:	91 29       	st.w	r8[0x8],r9
80006a96:	04 9c       	mov	r12,r2
80006a98:	6e 18       	ld.w	r8,r7[0x4]
80006a9a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006a9e:	10 46       	or	r6,r8
80006aa0:	8f 16       	st.w	r7[0x4],r6
80006aa2:	ca a8       	rjmp	80006bf6 <_realloc_r+0x2b6>
80006aa4:	14 03       	add	r3,r10
80006aa6:	0c 33       	cp.w	r3,r6
80006aa8:	c0 85       	brlt	80006ab8 <_realloc_r+0x178>
80006aaa:	72 28       	ld.w	r8,r9[0x8]
80006aac:	72 39       	ld.w	r9,r9[0xc]
80006aae:	93 28       	st.w	r9[0x8],r8
80006ab0:	91 39       	st.w	r8[0xc],r9
80006ab2:	6e 28       	ld.w	r8,r7[0x8]
80006ab4:	6e 39       	ld.w	r9,r7[0xc]
80006ab6:	c0 78       	rjmp	80006ac4 <_realloc_r+0x184>
80006ab8:	f8 00 00 03 	add	r3,r12,r0
80006abc:	0c 33       	cp.w	r3,r6
80006abe:	c3 35       	brlt	80006b24 <_realloc_r+0x1e4>
80006ac0:	6e 39       	ld.w	r9,r7[0xc]
80006ac2:	6e 28       	ld.w	r8,r7[0x8]
80006ac4:	93 28       	st.w	r9[0x8],r8
80006ac6:	91 39       	st.w	r8[0xc],r9
80006ac8:	e0 ca 00 04 	sub	r10,r0,4
80006acc:	ee cc ff f8 	sub	r12,r7,-8
80006ad0:	e0 4a 00 24 	cp.w	r10,36
80006ad4:	e0 8b 00 24 	brhi	80006b1c <_realloc_r+0x1dc>
80006ad8:	59 3a       	cp.w	r10,19
80006ada:	e0 88 00 1a 	brls	80006b0e <_realloc_r+0x1ce>
80006ade:	09 08       	ld.w	r8,r4++
80006ae0:	99 08       	st.w	r12[0x0],r8
80006ae2:	09 08       	ld.w	r8,r4++
80006ae4:	8f 38       	st.w	r7[0xc],r8
80006ae6:	ee cc ff f0 	sub	r12,r7,-16
80006aea:	59 ba       	cp.w	r10,27
80006aec:	e0 88 00 11 	brls	80006b0e <_realloc_r+0x1ce>
80006af0:	09 08       	ld.w	r8,r4++
80006af2:	99 08       	st.w	r12[0x0],r8
80006af4:	09 08       	ld.w	r8,r4++
80006af6:	8f 58       	st.w	r7[0x14],r8
80006af8:	ee cc ff e8 	sub	r12,r7,-24
80006afc:	e0 4a 00 24 	cp.w	r10,36
80006b00:	c0 71       	brne	80006b0e <_realloc_r+0x1ce>
80006b02:	09 08       	ld.w	r8,r4++
80006b04:	99 08       	st.w	r12[0x0],r8
80006b06:	ee cc ff e0 	sub	r12,r7,-32
80006b0a:	09 08       	ld.w	r8,r4++
80006b0c:	8f 78       	st.w	r7[0x1c],r8
80006b0e:	09 08       	ld.w	r8,r4++
80006b10:	18 a8       	st.w	r12++,r8
80006b12:	68 08       	ld.w	r8,r4[0x0]
80006b14:	99 08       	st.w	r12[0x0],r8
80006b16:	68 18       	ld.w	r8,r4[0x4]
80006b18:	99 18       	st.w	r12[0x4],r8
80006b1a:	c4 78       	rjmp	80006ba8 <_realloc_r+0x268>
80006b1c:	08 9b       	mov	r11,r4
80006b1e:	e0 a0 1d 70 	rcall	8000a5fe <memmove>
80006b22:	c4 38       	rjmp	80006ba8 <_realloc_r+0x268>
80006b24:	04 9c       	mov	r12,r2
80006b26:	fe b0 fc 45 	rcall	800063b0 <_malloc_r>
80006b2a:	18 95       	mov	r5,r12
80006b2c:	c3 a0       	breq	80006ba0 <_realloc_r+0x260>
80006b2e:	62 18       	ld.w	r8,r1[0x4]
80006b30:	f8 c9 00 08 	sub	r9,r12,8
80006b34:	a1 c8       	cbr	r8,0x0
80006b36:	e2 08 00 08 	add	r8,r1,r8
80006b3a:	10 39       	cp.w	r9,r8
80006b3c:	c0 71       	brne	80006b4a <_realloc_r+0x20a>
80006b3e:	72 13       	ld.w	r3,r9[0x4]
80006b40:	02 97       	mov	r7,r1
80006b42:	e0 13 ff fc 	andl	r3,0xfffc
80006b46:	00 03       	add	r3,r0
80006b48:	c3 08       	rjmp	80006ba8 <_realloc_r+0x268>
80006b4a:	e0 ca 00 04 	sub	r10,r0,4
80006b4e:	e0 4a 00 24 	cp.w	r10,36
80006b52:	e0 8b 00 20 	brhi	80006b92 <_realloc_r+0x252>
80006b56:	08 99       	mov	r9,r4
80006b58:	18 98       	mov	r8,r12
80006b5a:	59 3a       	cp.w	r10,19
80006b5c:	e0 88 00 14 	brls	80006b84 <_realloc_r+0x244>
80006b60:	13 0b       	ld.w	r11,r9++
80006b62:	10 ab       	st.w	r8++,r11
80006b64:	13 0b       	ld.w	r11,r9++
80006b66:	10 ab       	st.w	r8++,r11
80006b68:	59 ba       	cp.w	r10,27
80006b6a:	e0 88 00 0d 	brls	80006b84 <_realloc_r+0x244>
80006b6e:	13 0b       	ld.w	r11,r9++
80006b70:	10 ab       	st.w	r8++,r11
80006b72:	13 0b       	ld.w	r11,r9++
80006b74:	10 ab       	st.w	r8++,r11
80006b76:	e0 4a 00 24 	cp.w	r10,36
80006b7a:	c0 51       	brne	80006b84 <_realloc_r+0x244>
80006b7c:	13 0a       	ld.w	r10,r9++
80006b7e:	10 aa       	st.w	r8++,r10
80006b80:	13 0a       	ld.w	r10,r9++
80006b82:	10 aa       	st.w	r8++,r10
80006b84:	13 0a       	ld.w	r10,r9++
80006b86:	10 aa       	st.w	r8++,r10
80006b88:	72 0a       	ld.w	r10,r9[0x0]
80006b8a:	91 0a       	st.w	r8[0x0],r10
80006b8c:	72 19       	ld.w	r9,r9[0x4]
80006b8e:	91 19       	st.w	r8[0x4],r9
80006b90:	c0 48       	rjmp	80006b98 <_realloc_r+0x258>
80006b92:	08 9b       	mov	r11,r4
80006b94:	e0 a0 1d 35 	rcall	8000a5fe <memmove>
80006b98:	08 9b       	mov	r11,r4
80006b9a:	04 9c       	mov	r12,r2
80006b9c:	e0 a0 1a 8e 	rcall	8000a0b8 <_free_r>
80006ba0:	04 9c       	mov	r12,r2
80006ba2:	c2 a8       	rjmp	80006bf6 <_realloc_r+0x2b6>
80006ba4:	00 93       	mov	r3,r0
80006ba6:	02 97       	mov	r7,r1
80006ba8:	e6 06 01 09 	sub	r9,r3,r6
80006bac:	6e 18       	ld.w	r8,r7[0x4]
80006bae:	58 f9       	cp.w	r9,15
80006bb0:	e0 88 00 16 	brls	80006bdc <_realloc_r+0x29c>
80006bb4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006bb8:	ed e8 10 08 	or	r8,r6,r8
80006bbc:	8f 18       	st.w	r7[0x4],r8
80006bbe:	12 98       	mov	r8,r9
80006bc0:	a1 a8       	sbr	r8,0x0
80006bc2:	ee 06 00 0b 	add	r11,r7,r6
80006bc6:	f6 09 00 09 	add	r9,r11,r9
80006bca:	97 18       	st.w	r11[0x4],r8
80006bcc:	72 18       	ld.w	r8,r9[0x4]
80006bce:	a1 a8       	sbr	r8,0x0
80006bd0:	2f 8b       	sub	r11,-8
80006bd2:	93 18       	st.w	r9[0x4],r8
80006bd4:	04 9c       	mov	r12,r2
80006bd6:	e0 a0 1a 71 	rcall	8000a0b8 <_free_r>
80006bda:	c0 b8       	rjmp	80006bf0 <_realloc_r+0x2b0>
80006bdc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006be0:	e7 e8 10 08 	or	r8,r3,r8
80006be4:	8f 18       	st.w	r7[0x4],r8
80006be6:	ee 03 00 03 	add	r3,r7,r3
80006bea:	66 18       	ld.w	r8,r3[0x4]
80006bec:	a1 a8       	sbr	r8,0x0
80006bee:	87 18       	st.w	r3[0x4],r8
80006bf0:	04 9c       	mov	r12,r2
80006bf2:	ee c5 ff f8 	sub	r5,r7,-8
80006bf6:	fe b0 f1 7f 	rcall	80004ef4 <__malloc_unlock>
80006bfa:	0a 9c       	mov	r12,r5
80006bfc:	2f fd       	sub	sp,-4
80006bfe:	d8 32       	popm	r0-r7,pc

80006c00 <_sbrk_r>:
80006c00:	d4 21       	pushm	r4-r7,lr
80006c02:	30 08       	mov	r8,0
80006c04:	18 97       	mov	r7,r12
80006c06:	e0 66 40 d0 	mov	r6,16592
80006c0a:	16 9c       	mov	r12,r11
80006c0c:	8d 08       	st.w	r6[0x0],r8
80006c0e:	c9 9c       	rcall	80006d40 <_sbrk>
80006c10:	5b fc       	cp.w	r12,-1
80006c12:	c0 51       	brne	80006c1c <_sbrk_r+0x1c>
80006c14:	6c 08       	ld.w	r8,r6[0x0]
80006c16:	58 08       	cp.w	r8,0
80006c18:	ef f8 1a 03 	st.wne	r7[0xc],r8
80006c1c:	d8 22       	popm	r4-r7,pc
80006c1e:	d7 03       	nop

80006c20 <sprintf>:
80006c20:	d4 01       	pushm	lr
80006c22:	21 7d       	sub	sp,92
80006c24:	e0 68 ff ff 	mov	r8,65535
80006c28:	ea 18 7f ff 	orh	r8,0x7fff
80006c2c:	50 58       	stdsp	sp[0x14],r8
80006c2e:	50 28       	stdsp	sp[0x8],r8
80006c30:	e0 68 02 08 	mov	r8,520
80006c34:	ba 68       	st.h	sp[0xc],r8
80006c36:	3f f8       	mov	r8,-1
80006c38:	ba 78       	st.h	sp[0xe],r8
80006c3a:	e0 68 0a 30 	mov	r8,2608
80006c3e:	50 4c       	stdsp	sp[0x10],r12
80006c40:	16 9a       	mov	r10,r11
80006c42:	50 0c       	stdsp	sp[0x0],r12
80006c44:	fa c9 ff a0 	sub	r9,sp,-96
80006c48:	70 0c       	ld.w	r12,r8[0x0]
80006c4a:	1a 9b       	mov	r11,sp
80006c4c:	e0 a0 02 34 	rcall	800070b4 <_vfprintf_r>
80006c50:	30 09       	mov	r9,0
80006c52:	40 08       	lddsp	r8,sp[0x0]
80006c54:	b0 89       	st.b	r8[0x0],r9
80006c56:	2e 9d       	sub	sp,-92
80006c58:	d8 02       	popm	pc
80006c5a:	d7 03       	nop

80006c5c <strcpy>:
80006c5c:	30 08       	mov	r8,0
80006c5e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006c62:	f8 08 0b 09 	st.b	r12[r8],r9
80006c66:	2f f8       	sub	r8,-1
80006c68:	58 09       	cp.w	r9,0
80006c6a:	cf a1       	brne	80006c5e <strcpy+0x2>
80006c6c:	5e fc       	retal	r12

80006c6e <strlen>:
80006c6e:	30 09       	mov	r9,0
80006c70:	18 98       	mov	r8,r12
80006c72:	c0 28       	rjmp	80006c76 <strlen+0x8>
80006c74:	2f f8       	sub	r8,-1
80006c76:	11 8a       	ld.ub	r10,r8[0x0]
80006c78:	f2 0a 18 00 	cp.b	r10,r9
80006c7c:	cf c1       	brne	80006c74 <strlen+0x6>
80006c7e:	f0 0c 01 0c 	sub	r12,r8,r12
80006c82:	5e fc       	retal	r12

80006c84 <strncpy>:
80006c84:	30 08       	mov	r8,0
80006c86:	10 3a       	cp.w	r10,r8
80006c88:	5e 0c       	reteq	r12
80006c8a:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006c8e:	f8 08 0b 09 	st.b	r12[r8],r9
80006c92:	2f f8       	sub	r8,-1
80006c94:	58 09       	cp.w	r9,0
80006c96:	cf 81       	brne	80006c86 <strncpy+0x2>
80006c98:	10 3a       	cp.w	r10,r8
80006c9a:	5e 0c       	reteq	r12
80006c9c:	f8 08 0b 09 	st.b	r12[r8],r9
80006ca0:	2f f8       	sub	r8,-1
80006ca2:	cf bb       	rjmp	80006c98 <strncpy+0x14>

80006ca4 <_close>:
80006ca4:	30 28       	mov	r8,2
80006ca6:	d6 73       	breakpoint
80006ca8:	3f fc       	mov	r12,-1
80006caa:	35 8b       	mov	r11,88
80006cac:	58 0c       	cp.w	r12,0
80006cae:	5e 4c       	retge	r12
80006cb0:	e0 6a 40 d0 	mov	r10,16592
80006cb4:	95 0b       	st.w	r10[0x0],r11
80006cb6:	5e fc       	retal	r12

80006cb8 <_lseek>:
80006cb8:	30 58       	mov	r8,5
80006cba:	d6 73       	breakpoint
80006cbc:	3f fc       	mov	r12,-1
80006cbe:	35 8b       	mov	r11,88
80006cc0:	58 0c       	cp.w	r12,0
80006cc2:	5e 4c       	retge	r12
80006cc4:	e0 6a 40 d0 	mov	r10,16592
80006cc8:	95 0b       	st.w	r10[0x0],r11
80006cca:	5e fc       	retal	r12

80006ccc <isatty>:
80006ccc:	30 b8       	mov	r8,11
80006cce:	d6 73       	breakpoint
80006cd0:	3f fc       	mov	r12,-1
80006cd2:	35 8b       	mov	r11,88
80006cd4:	58 0c       	cp.w	r12,0
80006cd6:	5e 4c       	retge	r12
80006cd8:	e0 6a 40 d0 	mov	r10,16592
80006cdc:	95 0b       	st.w	r10[0x0],r11
80006cde:	5e fc       	retal	r12

80006ce0 <_fstat_host>:
80006ce0:	30 98       	mov	r8,9
80006ce2:	d6 73       	breakpoint
80006ce4:	3f fc       	mov	r12,-1
80006ce6:	35 8b       	mov	r11,88
80006ce8:	58 0c       	cp.w	r12,0
80006cea:	5e 4c       	retge	r12
80006cec:	e0 6a 40 d0 	mov	r10,16592
80006cf0:	95 0b       	st.w	r10[0x0],r11
80006cf2:	5e fc       	retal	r12

80006cf4 <_fstat>:
80006cf4:	d4 21       	pushm	r4-r7,lr
80006cf6:	21 0d       	sub	sp,64
80006cf8:	16 97       	mov	r7,r11
80006cfa:	1a 9b       	mov	r11,sp
80006cfc:	cf 2f       	rcall	80006ce0 <_fstat_host>
80006cfe:	c0 34       	brge	80006d04 <_fstat+0x10>
80006d00:	3f fc       	mov	r12,-1
80006d02:	c1 c8       	rjmp	80006d3a <_fstat+0x46>
80006d04:	40 08       	lddsp	r8,sp[0x0]
80006d06:	ae 08       	st.h	r7[0x0],r8
80006d08:	40 18       	lddsp	r8,sp[0x4]
80006d0a:	ae 18       	st.h	r7[0x2],r8
80006d0c:	40 28       	lddsp	r8,sp[0x8]
80006d0e:	8f 18       	st.w	r7[0x4],r8
80006d10:	40 38       	lddsp	r8,sp[0xc]
80006d12:	ae 48       	st.h	r7[0x8],r8
80006d14:	40 48       	lddsp	r8,sp[0x10]
80006d16:	ae 58       	st.h	r7[0xa],r8
80006d18:	40 58       	lddsp	r8,sp[0x14]
80006d1a:	ae 68       	st.h	r7[0xc],r8
80006d1c:	40 68       	lddsp	r8,sp[0x18]
80006d1e:	ae 78       	st.h	r7[0xe],r8
80006d20:	40 88       	lddsp	r8,sp[0x20]
80006d22:	8f 48       	st.w	r7[0x10],r8
80006d24:	40 a8       	lddsp	r8,sp[0x28]
80006d26:	8f b8       	st.w	r7[0x2c],r8
80006d28:	40 c8       	lddsp	r8,sp[0x30]
80006d2a:	8f c8       	st.w	r7[0x30],r8
80006d2c:	40 d8       	lddsp	r8,sp[0x34]
80006d2e:	8f 58       	st.w	r7[0x14],r8
80006d30:	40 e8       	lddsp	r8,sp[0x38]
80006d32:	30 0c       	mov	r12,0
80006d34:	8f 78       	st.w	r7[0x1c],r8
80006d36:	40 f8       	lddsp	r8,sp[0x3c]
80006d38:	8f 98       	st.w	r7[0x24],r8
80006d3a:	2f 0d       	sub	sp,-64
80006d3c:	d8 22       	popm	r4-r7,pc
80006d3e:	d7 03       	nop

80006d40 <_sbrk>:
80006d40:	d4 01       	pushm	lr
80006d42:	e0 68 0d 74 	mov	r8,3444
80006d46:	70 09       	ld.w	r9,r8[0x0]
80006d48:	58 09       	cp.w	r9,0
80006d4a:	c0 41       	brne	80006d52 <_sbrk+0x12>
80006d4c:	e0 69 40 d8 	mov	r9,16600
80006d50:	91 09       	st.w	r8[0x0],r9
80006d52:	e0 69 0d 74 	mov	r9,3444
80006d56:	e0 7a 70 00 	mov	r10,94208
80006d5a:	72 08       	ld.w	r8,r9[0x0]
80006d5c:	f0 0c 00 0c 	add	r12,r8,r12
80006d60:	14 3c       	cp.w	r12,r10
80006d62:	e0 8b 00 04 	brhi	80006d6a <_sbrk+0x2a>
80006d66:	93 0c       	st.w	r9[0x0],r12
80006d68:	c0 68       	rjmp	80006d74 <_sbrk+0x34>
80006d6a:	e0 a0 18 2b 	rcall	80009dc0 <__errno>
80006d6e:	30 c8       	mov	r8,12
80006d70:	99 08       	st.w	r12[0x0],r8
80006d72:	3f f8       	mov	r8,-1
80006d74:	10 9c       	mov	r12,r8
80006d76:	d8 02       	popm	pc

80006d78 <get_arg>:
80006d78:	d4 31       	pushm	r0-r7,lr
80006d7a:	20 8d       	sub	sp,32
80006d7c:	fa c4 ff bc 	sub	r4,sp,-68
80006d80:	50 4b       	stdsp	sp[0x10],r11
80006d82:	68 2e       	ld.w	lr,r4[0x8]
80006d84:	50 58       	stdsp	sp[0x14],r8
80006d86:	12 96       	mov	r6,r9
80006d88:	7c 0b       	ld.w	r11,lr[0x0]
80006d8a:	70 05       	ld.w	r5,r8[0x0]
80006d8c:	50 6e       	stdsp	sp[0x18],lr
80006d8e:	58 0b       	cp.w	r11,0
80006d90:	f4 0b 17 00 	moveq	r11,r10
80006d94:	68 03       	ld.w	r3,r4[0x0]
80006d96:	68 11       	ld.w	r1,r4[0x4]
80006d98:	40 49       	lddsp	r9,sp[0x10]
80006d9a:	30 08       	mov	r8,0
80006d9c:	c2 e9       	rjmp	80006ff8 <get_arg+0x280>
80006d9e:	2f fb       	sub	r11,-1
80006da0:	32 5c       	mov	r12,37
80006da2:	17 8a       	ld.ub	r10,r11[0x0]
80006da4:	f8 0a 18 00 	cp.b	r10,r12
80006da8:	5f 1e       	srne	lr
80006daa:	f0 0a 18 00 	cp.b	r10,r8
80006dae:	5f 1c       	srne	r12
80006db0:	fd ec 00 0c 	and	r12,lr,r12
80006db4:	f0 0c 18 00 	cp.b	r12,r8
80006db8:	cf 31       	brne	80006d9e <get_arg+0x26>
80006dba:	58 0a       	cp.w	r10,0
80006dbc:	e0 80 01 2b 	breq	80007012 <get_arg+0x29a>
80006dc0:	30 0c       	mov	r12,0
80006dc2:	3f fa       	mov	r10,-1
80006dc4:	18 90       	mov	r0,r12
80006dc6:	50 3a       	stdsp	sp[0xc],r10
80006dc8:	18 94       	mov	r4,r12
80006dca:	18 92       	mov	r2,r12
80006dcc:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80006dd0:	16 97       	mov	r7,r11
80006dd2:	50 7c       	stdsp	sp[0x1c],r12
80006dd4:	4c ec       	lddpc	r12,80006f0c <get_arg+0x194>
80006dd6:	0f 3a       	ld.ub	r10,r7++
80006dd8:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80006ddc:	40 7c       	lddsp	r12,sp[0x1c]
80006dde:	1c 0c       	add	r12,lr
80006de0:	4c ce       	lddpc	lr,80006f10 <get_arg+0x198>
80006de2:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80006de6:	20 1e       	sub	lr,1
80006de8:	50 0e       	stdsp	sp[0x0],lr
80006dea:	4c be       	lddpc	lr,80006f14 <get_arg+0x19c>
80006dec:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80006df0:	50 7c       	stdsp	sp[0x1c],r12
80006df2:	40 0c       	lddsp	r12,sp[0x0]
80006df4:	58 7c       	cp.w	r12,7
80006df6:	e0 8b 00 fa 	brhi	80006fea <get_arg+0x272>
80006dfa:	4c 8e       	lddpc	lr,80006f18 <get_arg+0x1a0>
80006dfc:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80006e00:	36 8b       	mov	r11,104
80006e02:	f6 0a 18 00 	cp.b	r10,r11
80006e06:	e0 80 00 f2 	breq	80006fea <get_arg+0x272>
80006e0a:	37 1b       	mov	r11,113
80006e0c:	f6 0a 18 00 	cp.b	r10,r11
80006e10:	c0 70       	breq	80006e1e <get_arg+0xa6>
80006e12:	34 cb       	mov	r11,76
80006e14:	f6 0a 18 00 	cp.b	r10,r11
80006e18:	c0 51       	brne	80006e22 <get_arg+0xaa>
80006e1a:	a3 b4       	sbr	r4,0x3
80006e1c:	ce 78       	rjmp	80006fea <get_arg+0x272>
80006e1e:	a5 b4       	sbr	r4,0x5
80006e20:	ce 58       	rjmp	80006fea <get_arg+0x272>
80006e22:	08 9a       	mov	r10,r4
80006e24:	0e 9b       	mov	r11,r7
80006e26:	a5 aa       	sbr	r10,0x4
80006e28:	17 3c       	ld.ub	r12,r11++
80006e2a:	a5 b4       	sbr	r4,0x5
80006e2c:	36 ce       	mov	lr,108
80006e2e:	fc 0c 18 00 	cp.b	r12,lr
80006e32:	e0 80 00 dd 	breq	80006fec <get_arg+0x274>
80006e36:	14 94       	mov	r4,r10
80006e38:	cd 98       	rjmp	80006fea <get_arg+0x272>
80006e3a:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80006e3e:	36 7c       	mov	r12,103
80006e40:	f8 0a 18 00 	cp.b	r10,r12
80006e44:	e0 8b 00 27 	brhi	80006e92 <get_arg+0x11a>
80006e48:	36 5b       	mov	r11,101
80006e4a:	f6 0a 18 00 	cp.b	r10,r11
80006e4e:	c4 82       	brcc	80006ede <get_arg+0x166>
80006e50:	34 fb       	mov	r11,79
80006e52:	f6 0a 18 00 	cp.b	r10,r11
80006e56:	c4 80       	breq	80006ee6 <get_arg+0x16e>
80006e58:	e0 8b 00 0c 	brhi	80006e70 <get_arg+0xf8>
80006e5c:	34 5b       	mov	r11,69
80006e5e:	f6 0a 18 00 	cp.b	r10,r11
80006e62:	c3 e0       	breq	80006ede <get_arg+0x166>
80006e64:	34 7b       	mov	r11,71
80006e66:	f6 0a 18 00 	cp.b	r10,r11
80006e6a:	c3 a0       	breq	80006ede <get_arg+0x166>
80006e6c:	34 4b       	mov	r11,68
80006e6e:	c0 88       	rjmp	80006e7e <get_arg+0x106>
80006e70:	35 8b       	mov	r11,88
80006e72:	f6 0a 18 00 	cp.b	r10,r11
80006e76:	c2 c0       	breq	80006ece <get_arg+0x156>
80006e78:	e0 8b 00 07 	brhi	80006e86 <get_arg+0x10e>
80006e7c:	35 5b       	mov	r11,85
80006e7e:	f6 0a 18 00 	cp.b	r10,r11
80006e82:	c3 51       	brne	80006eec <get_arg+0x174>
80006e84:	c3 18       	rjmp	80006ee6 <get_arg+0x16e>
80006e86:	36 3b       	mov	r11,99
80006e88:	f6 0a 18 00 	cp.b	r10,r11
80006e8c:	c2 f0       	breq	80006eea <get_arg+0x172>
80006e8e:	36 4b       	mov	r11,100
80006e90:	c0 e8       	rjmp	80006eac <get_arg+0x134>
80006e92:	37 0b       	mov	r11,112
80006e94:	f6 0a 18 00 	cp.b	r10,r11
80006e98:	c2 50       	breq	80006ee2 <get_arg+0x16a>
80006e9a:	e0 8b 00 0d 	brhi	80006eb4 <get_arg+0x13c>
80006e9e:	36 eb       	mov	r11,110
80006ea0:	f6 0a 18 00 	cp.b	r10,r11
80006ea4:	c1 f0       	breq	80006ee2 <get_arg+0x16a>
80006ea6:	e0 8b 00 14 	brhi	80006ece <get_arg+0x156>
80006eaa:	36 9b       	mov	r11,105
80006eac:	f6 0a 18 00 	cp.b	r10,r11
80006eb0:	c1 e1       	brne	80006eec <get_arg+0x174>
80006eb2:	c0 e8       	rjmp	80006ece <get_arg+0x156>
80006eb4:	37 5b       	mov	r11,117
80006eb6:	f6 0a 18 00 	cp.b	r10,r11
80006eba:	c0 a0       	breq	80006ece <get_arg+0x156>
80006ebc:	37 8b       	mov	r11,120
80006ebe:	f6 0a 18 00 	cp.b	r10,r11
80006ec2:	c0 60       	breq	80006ece <get_arg+0x156>
80006ec4:	37 3b       	mov	r11,115
80006ec6:	f6 0a 18 00 	cp.b	r10,r11
80006eca:	c1 11       	brne	80006eec <get_arg+0x174>
80006ecc:	c0 b8       	rjmp	80006ee2 <get_arg+0x16a>
80006ece:	ed b4 00 04 	bld	r4,0x4
80006ed2:	c0 a0       	breq	80006ee6 <get_arg+0x16e>
80006ed4:	ed b4 00 05 	bld	r4,0x5
80006ed8:	c0 91       	brne	80006eea <get_arg+0x172>
80006eda:	30 20       	mov	r0,2
80006edc:	c0 88       	rjmp	80006eec <get_arg+0x174>
80006ede:	30 40       	mov	r0,4
80006ee0:	c0 68       	rjmp	80006eec <get_arg+0x174>
80006ee2:	30 30       	mov	r0,3
80006ee4:	c0 48       	rjmp	80006eec <get_arg+0x174>
80006ee6:	30 10       	mov	r0,1
80006ee8:	c0 28       	rjmp	80006eec <get_arg+0x174>
80006eea:	30 00       	mov	r0,0
80006eec:	40 3b       	lddsp	r11,sp[0xc]
80006eee:	5b fb       	cp.w	r11,-1
80006ef0:	c0 40       	breq	80006ef8 <get_arg+0x180>
80006ef2:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80006ef6:	c7 a8       	rjmp	80006fea <get_arg+0x272>
80006ef8:	58 60       	cp.w	r0,6
80006efa:	e0 8b 00 78 	brhi	80006fea <get_arg+0x272>
80006efe:	6c 0a       	ld.w	r10,r6[0x0]
80006f00:	ea cc ff ff 	sub	r12,r5,-1
80006f04:	48 6e       	lddpc	lr,80006f1c <get_arg+0x1a4>
80006f06:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80006f0a:	d7 03       	nop
80006f0c:	80 01       	ld.sh	r1,r0[0x0]
80006f0e:	52 a4       	stdsp	sp[0xa8],r4
80006f10:	80 01       	ld.sh	r1,r0[0x0]
80006f12:	51 dc       	stdsp	sp[0x74],r12
80006f14:	80 01       	ld.sh	r1,r0[0x0]
80006f16:	51 70       	stdsp	sp[0x5c],r0
80006f18:	80 01       	ld.sh	r1,r0[0x0]
80006f1a:	4f d0       	lddpc	r0,8000710c <_vfprintf_r+0x58>
80006f1c:	80 01       	ld.sh	r1,r0[0x0]
80006f1e:	4f f0       	lddpc	r0,80007118 <_vfprintf_r+0x64>
80006f20:	f4 cb ff f8 	sub	r11,r10,-8
80006f24:	8d 0b       	st.w	r6[0x0],r11
80006f26:	f4 ea 00 00 	ld.d	r10,r10[0]
80006f2a:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80006f2e:	c0 f8       	rjmp	80006f4c <get_arg+0x1d4>
80006f30:	f4 cb ff fc 	sub	r11,r10,-4
80006f34:	8d 0b       	st.w	r6[0x0],r11
80006f36:	74 0a       	ld.w	r10,r10[0x0]
80006f38:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80006f3c:	c0 88       	rjmp	80006f4c <get_arg+0x1d4>
80006f3e:	f4 cb ff f8 	sub	r11,r10,-8
80006f42:	8d 0b       	st.w	r6[0x0],r11
80006f44:	f4 ea 00 00 	ld.d	r10,r10[0]
80006f48:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80006f4c:	0e 9b       	mov	r11,r7
80006f4e:	18 95       	mov	r5,r12
80006f50:	c4 e8       	rjmp	80006fec <get_arg+0x274>
80006f52:	62 0a       	ld.w	r10,r1[0x0]
80006f54:	5b fa       	cp.w	r10,-1
80006f56:	c0 b1       	brne	80006f6c <get_arg+0x1f4>
80006f58:	50 19       	stdsp	sp[0x4],r9
80006f5a:	50 28       	stdsp	sp[0x8],r8
80006f5c:	e0 6a 00 80 	mov	r10,128
80006f60:	30 0b       	mov	r11,0
80006f62:	02 9c       	mov	r12,r1
80006f64:	fe b0 fc e6 	rcall	80006930 <memset>
80006f68:	40 28       	lddsp	r8,sp[0x8]
80006f6a:	40 19       	lddsp	r9,sp[0x4]
80006f6c:	e4 cc 00 01 	sub	r12,r2,1
80006f70:	0e 9b       	mov	r11,r7
80006f72:	50 3c       	stdsp	sp[0xc],r12
80006f74:	f2 0c 0c 49 	max	r9,r9,r12
80006f78:	c3 a8       	rjmp	80006fec <get_arg+0x274>
80006f7a:	62 0a       	ld.w	r10,r1[0x0]
80006f7c:	5b fa       	cp.w	r10,-1
80006f7e:	c0 b1       	brne	80006f94 <get_arg+0x21c>
80006f80:	50 19       	stdsp	sp[0x4],r9
80006f82:	50 28       	stdsp	sp[0x8],r8
80006f84:	e0 6a 00 80 	mov	r10,128
80006f88:	30 0b       	mov	r11,0
80006f8a:	02 9c       	mov	r12,r1
80006f8c:	fe b0 fc d2 	rcall	80006930 <memset>
80006f90:	40 28       	lddsp	r8,sp[0x8]
80006f92:	40 19       	lddsp	r9,sp[0x4]
80006f94:	20 12       	sub	r2,1
80006f96:	30 0a       	mov	r10,0
80006f98:	0e 9b       	mov	r11,r7
80006f9a:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80006f9e:	f2 02 0c 49 	max	r9,r9,r2
80006fa2:	c2 58       	rjmp	80006fec <get_arg+0x274>
80006fa4:	16 97       	mov	r7,r11
80006fa6:	6c 0a       	ld.w	r10,r6[0x0]
80006fa8:	f4 cb ff fc 	sub	r11,r10,-4
80006fac:	8d 0b       	st.w	r6[0x0],r11
80006fae:	74 0a       	ld.w	r10,r10[0x0]
80006fb0:	0e 9b       	mov	r11,r7
80006fb2:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80006fb6:	2f f5       	sub	r5,-1
80006fb8:	c1 a8       	rjmp	80006fec <get_arg+0x274>
80006fba:	f4 c2 00 30 	sub	r2,r10,48
80006fbe:	c0 68       	rjmp	80006fca <get_arg+0x252>
80006fc0:	e4 02 00 22 	add	r2,r2,r2<<0x2
80006fc4:	2f f7       	sub	r7,-1
80006fc6:	f4 02 00 12 	add	r2,r10,r2<<0x1
80006fca:	0f 8a       	ld.ub	r10,r7[0x0]
80006fcc:	58 0a       	cp.w	r10,0
80006fce:	c0 e0       	breq	80006fea <get_arg+0x272>
80006fd0:	23 0a       	sub	r10,48
80006fd2:	58 9a       	cp.w	r10,9
80006fd4:	fe 98 ff f6 	brls	80006fc0 <get_arg+0x248>
80006fd8:	c0 98       	rjmp	80006fea <get_arg+0x272>
80006fda:	2f f7       	sub	r7,-1
80006fdc:	0f 8a       	ld.ub	r10,r7[0x0]
80006fde:	58 0a       	cp.w	r10,0
80006fe0:	c0 50       	breq	80006fea <get_arg+0x272>
80006fe2:	23 0a       	sub	r10,48
80006fe4:	58 9a       	cp.w	r10,9
80006fe6:	fe 98 ff fa 	brls	80006fda <get_arg+0x262>
80006fea:	0e 9b       	mov	r11,r7
80006fec:	40 7c       	lddsp	r12,sp[0x1c]
80006fee:	30 ba       	mov	r10,11
80006ff0:	f4 0c 18 00 	cp.b	r12,r10
80006ff4:	fe 91 fe ec 	brne	80006dcc <get_arg+0x54>
80006ff8:	40 42       	lddsp	r2,sp[0x10]
80006ffa:	17 8c       	ld.ub	r12,r11[0x0]
80006ffc:	0a 32       	cp.w	r2,r5
80006ffe:	5f 4a       	srge	r10
80007000:	f0 0c 18 00 	cp.b	r12,r8
80007004:	5f 1c       	srne	r12
80007006:	f9 ea 00 0a 	and	r10,r12,r10
8000700a:	f0 0a 18 00 	cp.b	r10,r8
8000700e:	fe 91 fe c9 	brne	80006da0 <get_arg+0x28>
80007012:	30 08       	mov	r8,0
80007014:	40 4e       	lddsp	lr,sp[0x10]
80007016:	17 8a       	ld.ub	r10,r11[0x0]
80007018:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000701c:	f0 0a 18 00 	cp.b	r10,r8
80007020:	fc 09 17 10 	movne	r9,lr
80007024:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007028:	06 9e       	mov	lr,r3
8000702a:	c2 a8       	rjmp	8000707e <get_arg+0x306>
8000702c:	62 0a       	ld.w	r10,r1[0x0]
8000702e:	58 3a       	cp.w	r10,3
80007030:	c1 e0       	breq	8000706c <get_arg+0x2f4>
80007032:	e0 89 00 07 	brgt	80007040 <get_arg+0x2c8>
80007036:	58 1a       	cp.w	r10,1
80007038:	c1 a0       	breq	8000706c <get_arg+0x2f4>
8000703a:	58 2a       	cp.w	r10,2
8000703c:	c1 81       	brne	8000706c <get_arg+0x2f4>
8000703e:	c0 58       	rjmp	80007048 <get_arg+0x2d0>
80007040:	58 5a       	cp.w	r10,5
80007042:	c0 c0       	breq	8000705a <get_arg+0x2e2>
80007044:	c0 b5       	brlt	8000705a <get_arg+0x2e2>
80007046:	c1 38       	rjmp	8000706c <get_arg+0x2f4>
80007048:	6c 0a       	ld.w	r10,r6[0x0]
8000704a:	f4 cc ff f8 	sub	r12,r10,-8
8000704e:	8d 0c       	st.w	r6[0x0],r12
80007050:	f4 e2 00 00 	ld.d	r2,r10[0]
80007054:	f0 e3 00 00 	st.d	r8[0],r2
80007058:	c1 08       	rjmp	80007078 <get_arg+0x300>
8000705a:	6c 0a       	ld.w	r10,r6[0x0]
8000705c:	f4 cc ff f8 	sub	r12,r10,-8
80007060:	8d 0c       	st.w	r6[0x0],r12
80007062:	f4 e2 00 00 	ld.d	r2,r10[0]
80007066:	f0 e3 00 00 	st.d	r8[0],r2
8000706a:	c0 78       	rjmp	80007078 <get_arg+0x300>
8000706c:	6c 0a       	ld.w	r10,r6[0x0]
8000706e:	f4 cc ff fc 	sub	r12,r10,-4
80007072:	8d 0c       	st.w	r6[0x0],r12
80007074:	74 0a       	ld.w	r10,r10[0x0]
80007076:	91 0a       	st.w	r8[0x0],r10
80007078:	2f f5       	sub	r5,-1
8000707a:	2f 88       	sub	r8,-8
8000707c:	2f c1       	sub	r1,-4
8000707e:	12 35       	cp.w	r5,r9
80007080:	fe 9a ff d6 	brle	8000702c <get_arg+0x2b4>
80007084:	1c 93       	mov	r3,lr
80007086:	40 52       	lddsp	r2,sp[0x14]
80007088:	40 6e       	lddsp	lr,sp[0x18]
8000708a:	85 05       	st.w	r2[0x0],r5
8000708c:	9d 0b       	st.w	lr[0x0],r11
8000708e:	40 4b       	lddsp	r11,sp[0x10]
80007090:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007094:	2f 8d       	sub	sp,-32
80007096:	d8 32       	popm	r0-r7,pc

80007098 <__sprint_r>:
80007098:	d4 21       	pushm	r4-r7,lr
8000709a:	14 97       	mov	r7,r10
8000709c:	74 28       	ld.w	r8,r10[0x8]
8000709e:	58 08       	cp.w	r8,0
800070a0:	c0 41       	brne	800070a8 <__sprint_r+0x10>
800070a2:	95 18       	st.w	r10[0x4],r8
800070a4:	10 9c       	mov	r12,r8
800070a6:	d8 22       	popm	r4-r7,pc
800070a8:	e0 a0 18 ce 	rcall	8000a244 <__sfvwrite_r>
800070ac:	30 08       	mov	r8,0
800070ae:	8f 18       	st.w	r7[0x4],r8
800070b0:	8f 28       	st.w	r7[0x8],r8
800070b2:	d8 22       	popm	r4-r7,pc

800070b4 <_vfprintf_r>:
800070b4:	d4 31       	pushm	r0-r7,lr
800070b6:	fa cd 06 bc 	sub	sp,sp,1724
800070ba:	51 09       	stdsp	sp[0x40],r9
800070bc:	16 91       	mov	r1,r11
800070be:	14 97       	mov	r7,r10
800070c0:	18 95       	mov	r5,r12
800070c2:	e0 a0 1a 31 	rcall	8000a524 <_localeconv_r>
800070c6:	78 0c       	ld.w	r12,r12[0x0]
800070c8:	50 cc       	stdsp	sp[0x30],r12
800070ca:	58 05       	cp.w	r5,0
800070cc:	c0 70       	breq	800070da <_vfprintf_r+0x26>
800070ce:	6a 68       	ld.w	r8,r5[0x18]
800070d0:	58 08       	cp.w	r8,0
800070d2:	c0 41       	brne	800070da <_vfprintf_r+0x26>
800070d4:	0a 9c       	mov	r12,r5
800070d6:	e0 a0 17 57 	rcall	80009f84 <__sinit>
800070da:	4d 08       	lddpc	r8,80007218 <_vfprintf_r+0x164>
800070dc:	10 31       	cp.w	r1,r8
800070de:	c0 31       	brne	800070e4 <_vfprintf_r+0x30>
800070e0:	6a 01       	ld.w	r1,r5[0x0]
800070e2:	c0 a8       	rjmp	800070f6 <_vfprintf_r+0x42>
800070e4:	4c e8       	lddpc	r8,8000721c <_vfprintf_r+0x168>
800070e6:	10 31       	cp.w	r1,r8
800070e8:	c0 31       	brne	800070ee <_vfprintf_r+0x3a>
800070ea:	6a 11       	ld.w	r1,r5[0x4]
800070ec:	c0 58       	rjmp	800070f6 <_vfprintf_r+0x42>
800070ee:	4c d8       	lddpc	r8,80007220 <_vfprintf_r+0x16c>
800070f0:	10 31       	cp.w	r1,r8
800070f2:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800070f6:	82 68       	ld.sh	r8,r1[0xc]
800070f8:	ed b8 00 03 	bld	r8,0x3
800070fc:	c0 41       	brne	80007104 <_vfprintf_r+0x50>
800070fe:	62 48       	ld.w	r8,r1[0x10]
80007100:	58 08       	cp.w	r8,0
80007102:	c0 71       	brne	80007110 <_vfprintf_r+0x5c>
80007104:	02 9b       	mov	r11,r1
80007106:	0a 9c       	mov	r12,r5
80007108:	e0 a0 0f 6c 	rcall	80008fe0 <__swsetup_r>
8000710c:	e0 81 0f 63 	brne	80008fd2 <_vfprintf_r+0x1f1e>
80007110:	82 68       	ld.sh	r8,r1[0xc]
80007112:	10 99       	mov	r9,r8
80007114:	e2 19 00 1a 	andl	r9,0x1a,COH
80007118:	58 a9       	cp.w	r9,10
8000711a:	c3 c1       	brne	80007192 <_vfprintf_r+0xde>
8000711c:	82 79       	ld.sh	r9,r1[0xe]
8000711e:	30 0a       	mov	r10,0
80007120:	f4 09 19 00 	cp.h	r9,r10
80007124:	c3 75       	brlt	80007192 <_vfprintf_r+0xde>
80007126:	a1 d8       	cbr	r8,0x1
80007128:	fb 58 05 d0 	st.h	sp[1488],r8
8000712c:	62 88       	ld.w	r8,r1[0x20]
8000712e:	fb 48 05 e4 	st.w	sp[1508],r8
80007132:	62 a8       	ld.w	r8,r1[0x28]
80007134:	fb 48 05 ec 	st.w	sp[1516],r8
80007138:	fa c8 ff bc 	sub	r8,sp,-68
8000713c:	fb 48 05 d4 	st.w	sp[1492],r8
80007140:	fb 48 05 c4 	st.w	sp[1476],r8
80007144:	e0 68 04 00 	mov	r8,1024
80007148:	fb 48 05 d8 	st.w	sp[1496],r8
8000714c:	fb 48 05 cc 	st.w	sp[1484],r8
80007150:	30 08       	mov	r8,0
80007152:	fb 59 05 d2 	st.h	sp[1490],r9
80007156:	0e 9a       	mov	r10,r7
80007158:	41 09       	lddsp	r9,sp[0x40]
8000715a:	fa c7 fa 3c 	sub	r7,sp,-1476
8000715e:	fb 48 05 dc 	st.w	sp[1500],r8
80007162:	0a 9c       	mov	r12,r5
80007164:	0e 9b       	mov	r11,r7
80007166:	ca 7f       	rcall	800070b4 <_vfprintf_r>
80007168:	50 bc       	stdsp	sp[0x2c],r12
8000716a:	c0 95       	brlt	8000717c <_vfprintf_r+0xc8>
8000716c:	0e 9b       	mov	r11,r7
8000716e:	0a 9c       	mov	r12,r5
80007170:	e0 a0 16 2e 	rcall	80009dcc <_fflush_r>
80007174:	40 be       	lddsp	lr,sp[0x2c]
80007176:	f9 be 01 ff 	movne	lr,-1
8000717a:	50 be       	stdsp	sp[0x2c],lr
8000717c:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007180:	ed b8 00 06 	bld	r8,0x6
80007184:	e0 81 0f 29 	brne	80008fd6 <_vfprintf_r+0x1f22>
80007188:	82 68       	ld.sh	r8,r1[0xc]
8000718a:	a7 a8       	sbr	r8,0x6
8000718c:	a2 68       	st.h	r1[0xc],r8
8000718e:	e0 8f 0f 24 	bral	80008fd6 <_vfprintf_r+0x1f22>
80007192:	30 08       	mov	r8,0
80007194:	fb 48 06 b4 	st.w	sp[1716],r8
80007198:	fb 48 06 90 	st.w	sp[1680],r8
8000719c:	fb 48 06 8c 	st.w	sp[1676],r8
800071a0:	fb 48 06 b0 	st.w	sp[1712],r8
800071a4:	30 08       	mov	r8,0
800071a6:	30 09       	mov	r9,0
800071a8:	50 a7       	stdsp	sp[0x28],r7
800071aa:	50 78       	stdsp	sp[0x1c],r8
800071ac:	fa c3 f9 e0 	sub	r3,sp,-1568
800071b0:	3f f8       	mov	r8,-1
800071b2:	50 59       	stdsp	sp[0x14],r9
800071b4:	fb 43 06 88 	st.w	sp[1672],r3
800071b8:	fb 48 05 44 	st.w	sp[1348],r8
800071bc:	12 9c       	mov	r12,r9
800071be:	50 69       	stdsp	sp[0x18],r9
800071c0:	50 d9       	stdsp	sp[0x34],r9
800071c2:	50 e9       	stdsp	sp[0x38],r9
800071c4:	50 b9       	stdsp	sp[0x2c],r9
800071c6:	12 97       	mov	r7,r9
800071c8:	0a 94       	mov	r4,r5
800071ca:	40 a2       	lddsp	r2,sp[0x28]
800071cc:	32 5a       	mov	r10,37
800071ce:	30 08       	mov	r8,0
800071d0:	c0 28       	rjmp	800071d4 <_vfprintf_r+0x120>
800071d2:	2f f2       	sub	r2,-1
800071d4:	05 89       	ld.ub	r9,r2[0x0]
800071d6:	f0 09 18 00 	cp.b	r9,r8
800071da:	5f 1b       	srne	r11
800071dc:	f4 09 18 00 	cp.b	r9,r10
800071e0:	5f 19       	srne	r9
800071e2:	f3 eb 00 0b 	and	r11,r9,r11
800071e6:	f0 0b 18 00 	cp.b	r11,r8
800071ea:	cf 41       	brne	800071d2 <_vfprintf_r+0x11e>
800071ec:	40 ab       	lddsp	r11,sp[0x28]
800071ee:	e4 0b 01 06 	sub	r6,r2,r11
800071f2:	c2 50       	breq	8000723c <_vfprintf_r+0x188>
800071f4:	fa f8 06 90 	ld.w	r8,sp[1680]
800071f8:	0c 08       	add	r8,r6
800071fa:	87 0b       	st.w	r3[0x0],r11
800071fc:	fb 48 06 90 	st.w	sp[1680],r8
80007200:	87 16       	st.w	r3[0x4],r6
80007202:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007206:	2f f8       	sub	r8,-1
80007208:	fb 48 06 8c 	st.w	sp[1676],r8
8000720c:	58 78       	cp.w	r8,7
8000720e:	e0 89 00 0b 	brgt	80007224 <_vfprintf_r+0x170>
80007212:	2f 83       	sub	r3,-8
80007214:	c1 18       	rjmp	80007236 <_vfprintf_r+0x182>
80007216:	d7 03       	nop
80007218:	80 01       	ld.sh	r1,r0[0x0]
8000721a:	53 b4       	stdsp	sp[0xec],r4
8000721c:	80 01       	ld.sh	r1,r0[0x0]
8000721e:	53 d4       	stdsp	sp[0xf4],r4
80007220:	80 01       	ld.sh	r1,r0[0x0]
80007222:	53 f4       	stdsp	sp[0xfc],r4
80007224:	fa ca f9 78 	sub	r10,sp,-1672
80007228:	02 9b       	mov	r11,r1
8000722a:	08 9c       	mov	r12,r4
8000722c:	c3 6f       	rcall	80007098 <__sprint_r>
8000722e:	e0 81 0e ce 	brne	80008fca <_vfprintf_r+0x1f16>
80007232:	fa c3 f9 e0 	sub	r3,sp,-1568
80007236:	40 ba       	lddsp	r10,sp[0x2c]
80007238:	0c 0a       	add	r10,r6
8000723a:	50 ba       	stdsp	sp[0x2c],r10
8000723c:	05 89       	ld.ub	r9,r2[0x0]
8000723e:	30 08       	mov	r8,0
80007240:	f0 09 18 00 	cp.b	r9,r8
80007244:	e0 80 0e b2 	breq	80008fa8 <_vfprintf_r+0x1ef4>
80007248:	30 09       	mov	r9,0
8000724a:	fb 68 06 bb 	st.b	sp[1723],r8
8000724e:	0e 96       	mov	r6,r7
80007250:	e4 c8 ff ff 	sub	r8,r2,-1
80007254:	3f fe       	mov	lr,-1
80007256:	50 93       	stdsp	sp[0x24],r3
80007258:	50 41       	stdsp	sp[0x10],r1
8000725a:	0e 93       	mov	r3,r7
8000725c:	04 91       	mov	r1,r2
8000725e:	50 89       	stdsp	sp[0x20],r9
80007260:	50 a8       	stdsp	sp[0x28],r8
80007262:	50 2e       	stdsp	sp[0x8],lr
80007264:	50 39       	stdsp	sp[0xc],r9
80007266:	12 95       	mov	r5,r9
80007268:	12 90       	mov	r0,r9
8000726a:	10 97       	mov	r7,r8
8000726c:	08 92       	mov	r2,r4
8000726e:	c0 78       	rjmp	8000727c <_vfprintf_r+0x1c8>
80007270:	3f fc       	mov	r12,-1
80007272:	08 97       	mov	r7,r4
80007274:	50 2c       	stdsp	sp[0x8],r12
80007276:	c0 38       	rjmp	8000727c <_vfprintf_r+0x1c8>
80007278:	30 0b       	mov	r11,0
8000727a:	50 3b       	stdsp	sp[0xc],r11
8000727c:	0f 38       	ld.ub	r8,r7++
8000727e:	c0 28       	rjmp	80007282 <_vfprintf_r+0x1ce>
80007280:	12 90       	mov	r0,r9
80007282:	f0 c9 00 20 	sub	r9,r8,32
80007286:	e0 49 00 58 	cp.w	r9,88
8000728a:	e0 8b 0a 36 	brhi	800086f6 <_vfprintf_r+0x1642>
8000728e:	4d 9a       	lddpc	r10,800073f0 <_vfprintf_r+0x33c>
80007290:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007294:	50 a7       	stdsp	sp[0x28],r7
80007296:	50 80       	stdsp	sp[0x20],r0
80007298:	0c 97       	mov	r7,r6
8000729a:	04 94       	mov	r4,r2
8000729c:	06 96       	mov	r6,r3
8000729e:	02 92       	mov	r2,r1
800072a0:	4d 59       	lddpc	r9,800073f4 <_vfprintf_r+0x340>
800072a2:	40 93       	lddsp	r3,sp[0x24]
800072a4:	10 90       	mov	r0,r8
800072a6:	40 41       	lddsp	r1,sp[0x10]
800072a8:	50 d9       	stdsp	sp[0x34],r9
800072aa:	e0 8f 08 95 	bral	800083d4 <_vfprintf_r+0x1320>
800072ae:	30 08       	mov	r8,0
800072b0:	fb 39 06 bb 	ld.ub	r9,sp[1723]
800072b4:	f0 09 18 00 	cp.b	r9,r8
800072b8:	ce 21       	brne	8000727c <_vfprintf_r+0x1c8>
800072ba:	32 08       	mov	r8,32
800072bc:	c6 e8       	rjmp	80007398 <_vfprintf_r+0x2e4>
800072be:	a1 a5       	sbr	r5,0x0
800072c0:	cd eb       	rjmp	8000727c <_vfprintf_r+0x1c8>
800072c2:	0f 89       	ld.ub	r9,r7[0x0]
800072c4:	f2 c8 00 30 	sub	r8,r9,48
800072c8:	58 98       	cp.w	r8,9
800072ca:	e0 8b 00 1d 	brhi	80007304 <_vfprintf_r+0x250>
800072ce:	ee c8 ff ff 	sub	r8,r7,-1
800072d2:	30 0b       	mov	r11,0
800072d4:	23 09       	sub	r9,48
800072d6:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800072da:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800072de:	11 39       	ld.ub	r9,r8++
800072e0:	f2 ca 00 30 	sub	r10,r9,48
800072e4:	58 9a       	cp.w	r10,9
800072e6:	fe 98 ff f7 	brls	800072d4 <_vfprintf_r+0x220>
800072ea:	e0 49 00 24 	cp.w	r9,36
800072ee:	cc 51       	brne	80007278 <_vfprintf_r+0x1c4>
800072f0:	e0 4b 00 20 	cp.w	r11,32
800072f4:	e0 89 0e 6a 	brgt	80008fc8 <_vfprintf_r+0x1f14>
800072f8:	20 1b       	sub	r11,1
800072fa:	fa f9 06 b4 	ld.w	r9,sp[1716]
800072fe:	12 3b       	cp.w	r11,r9
80007300:	c0 95       	brlt	80007312 <_vfprintf_r+0x25e>
80007302:	c1 08       	rjmp	80007322 <_vfprintf_r+0x26e>
80007304:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007308:	ec ca ff ff 	sub	r10,r6,-1
8000730c:	12 36       	cp.w	r6,r9
8000730e:	c1 f5       	brlt	8000734c <_vfprintf_r+0x298>
80007310:	c2 68       	rjmp	8000735c <_vfprintf_r+0x2a8>
80007312:	fa ce f9 44 	sub	lr,sp,-1724
80007316:	10 97       	mov	r7,r8
80007318:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000731c:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007320:	c3 58       	rjmp	8000738a <_vfprintf_r+0x2d6>
80007322:	10 97       	mov	r7,r8
80007324:	fa c8 f9 50 	sub	r8,sp,-1712
80007328:	1a d8       	st.w	--sp,r8
8000732a:	fa c8 fa b8 	sub	r8,sp,-1352
8000732e:	1a d8       	st.w	--sp,r8
80007330:	fa c8 fb b4 	sub	r8,sp,-1100
80007334:	02 9a       	mov	r10,r1
80007336:	1a d8       	st.w	--sp,r8
80007338:	04 9c       	mov	r12,r2
8000733a:	fa c8 f9 40 	sub	r8,sp,-1728
8000733e:	fa c9 ff b4 	sub	r9,sp,-76
80007342:	fe b0 fd 1b 	rcall	80006d78 <get_arg>
80007346:	2f dd       	sub	sp,-12
80007348:	78 00       	ld.w	r0,r12[0x0]
8000734a:	c2 08       	rjmp	8000738a <_vfprintf_r+0x2d6>
8000734c:	fa cc f9 44 	sub	r12,sp,-1724
80007350:	14 96       	mov	r6,r10
80007352:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007356:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000735a:	c1 88       	rjmp	8000738a <_vfprintf_r+0x2d6>
8000735c:	41 08       	lddsp	r8,sp[0x40]
8000735e:	59 f9       	cp.w	r9,31
80007360:	e0 89 00 11 	brgt	80007382 <_vfprintf_r+0x2ce>
80007364:	f0 cb ff fc 	sub	r11,r8,-4
80007368:	51 0b       	stdsp	sp[0x40],r11
8000736a:	70 00       	ld.w	r0,r8[0x0]
8000736c:	fa cb f9 44 	sub	r11,sp,-1724
80007370:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007374:	f1 40 fd 88 	st.w	r8[-632],r0
80007378:	2f f9       	sub	r9,-1
8000737a:	14 96       	mov	r6,r10
8000737c:	fb 49 06 b4 	st.w	sp[1716],r9
80007380:	c0 58       	rjmp	8000738a <_vfprintf_r+0x2d6>
80007382:	70 00       	ld.w	r0,r8[0x0]
80007384:	14 96       	mov	r6,r10
80007386:	2f c8       	sub	r8,-4
80007388:	51 08       	stdsp	sp[0x40],r8
8000738a:	58 00       	cp.w	r0,0
8000738c:	fe 94 ff 78 	brge	8000727c <_vfprintf_r+0x1c8>
80007390:	5c 30       	neg	r0
80007392:	a3 a5       	sbr	r5,0x2
80007394:	c7 4b       	rjmp	8000727c <_vfprintf_r+0x1c8>
80007396:	32 b8       	mov	r8,43
80007398:	fb 68 06 bb 	st.b	sp[1723],r8
8000739c:	c7 0b       	rjmp	8000727c <_vfprintf_r+0x1c8>
8000739e:	0f 38       	ld.ub	r8,r7++
800073a0:	e0 48 00 2a 	cp.w	r8,42
800073a4:	c0 30       	breq	800073aa <_vfprintf_r+0x2f6>
800073a6:	30 09       	mov	r9,0
800073a8:	c7 d8       	rjmp	800074a2 <_vfprintf_r+0x3ee>
800073aa:	0f 88       	ld.ub	r8,r7[0x0]
800073ac:	f0 c9 00 30 	sub	r9,r8,48
800073b0:	58 99       	cp.w	r9,9
800073b2:	e0 8b 00 23 	brhi	800073f8 <_vfprintf_r+0x344>
800073b6:	ee c4 ff ff 	sub	r4,r7,-1
800073ba:	30 0b       	mov	r11,0
800073bc:	23 08       	sub	r8,48
800073be:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800073c2:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800073c6:	09 38       	ld.ub	r8,r4++
800073c8:	f0 c9 00 30 	sub	r9,r8,48
800073cc:	58 99       	cp.w	r9,9
800073ce:	fe 98 ff f7 	brls	800073bc <_vfprintf_r+0x308>
800073d2:	e0 48 00 24 	cp.w	r8,36
800073d6:	fe 91 ff 51 	brne	80007278 <_vfprintf_r+0x1c4>
800073da:	e0 4b 00 20 	cp.w	r11,32
800073de:	e0 89 0d f5 	brgt	80008fc8 <_vfprintf_r+0x1f14>
800073e2:	20 1b       	sub	r11,1
800073e4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800073e8:	10 3b       	cp.w	r11,r8
800073ea:	c0 e5       	brlt	80007406 <_vfprintf_r+0x352>
800073ec:	c1 58       	rjmp	80007416 <_vfprintf_r+0x362>
800073ee:	d7 03       	nop
800073f0:	80 01       	ld.sh	r1,r0[0x0]
800073f2:	50 0c       	stdsp	sp[0x0],r12
800073f4:	80 01       	ld.sh	r1,r0[0x0]
800073f6:	52 48       	stdsp	sp[0x90],r8
800073f8:	fa fa 06 b4 	ld.w	r10,sp[1716]
800073fc:	ec c9 ff ff 	sub	r9,r6,-1
80007400:	14 36       	cp.w	r6,r10
80007402:	c1 f5       	brlt	80007440 <_vfprintf_r+0x38c>
80007404:	c2 88       	rjmp	80007454 <_vfprintf_r+0x3a0>
80007406:	fa ca f9 44 	sub	r10,sp,-1724
8000740a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000740e:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007412:	50 2b       	stdsp	sp[0x8],r11
80007414:	c3 c8       	rjmp	8000748c <_vfprintf_r+0x3d8>
80007416:	fa c8 f9 50 	sub	r8,sp,-1712
8000741a:	1a d8       	st.w	--sp,r8
8000741c:	fa c8 fa b8 	sub	r8,sp,-1352
80007420:	1a d8       	st.w	--sp,r8
80007422:	fa c8 fb b4 	sub	r8,sp,-1100
80007426:	02 9a       	mov	r10,r1
80007428:	1a d8       	st.w	--sp,r8
8000742a:	04 9c       	mov	r12,r2
8000742c:	fa c8 f9 40 	sub	r8,sp,-1728
80007430:	fa c9 ff b4 	sub	r9,sp,-76
80007434:	fe b0 fc a2 	rcall	80006d78 <get_arg>
80007438:	2f dd       	sub	sp,-12
8000743a:	78 0c       	ld.w	r12,r12[0x0]
8000743c:	50 2c       	stdsp	sp[0x8],r12
8000743e:	c2 78       	rjmp	8000748c <_vfprintf_r+0x3d8>
80007440:	12 96       	mov	r6,r9
80007442:	0e 94       	mov	r4,r7
80007444:	fa c9 f9 44 	sub	r9,sp,-1724
80007448:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000744c:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007450:	50 28       	stdsp	sp[0x8],r8
80007452:	c1 d8       	rjmp	8000748c <_vfprintf_r+0x3d8>
80007454:	41 08       	lddsp	r8,sp[0x40]
80007456:	59 fa       	cp.w	r10,31
80007458:	e0 89 00 14 	brgt	80007480 <_vfprintf_r+0x3cc>
8000745c:	f0 cb ff fc 	sub	r11,r8,-4
80007460:	70 08       	ld.w	r8,r8[0x0]
80007462:	51 0b       	stdsp	sp[0x40],r11
80007464:	50 28       	stdsp	sp[0x8],r8
80007466:	fa c6 f9 44 	sub	r6,sp,-1724
8000746a:	40 2e       	lddsp	lr,sp[0x8]
8000746c:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007470:	f1 4e fd 88 	st.w	r8[-632],lr
80007474:	2f fa       	sub	r10,-1
80007476:	0e 94       	mov	r4,r7
80007478:	fb 4a 06 b4 	st.w	sp[1716],r10
8000747c:	12 96       	mov	r6,r9
8000747e:	c0 78       	rjmp	8000748c <_vfprintf_r+0x3d8>
80007480:	70 0c       	ld.w	r12,r8[0x0]
80007482:	0e 94       	mov	r4,r7
80007484:	2f c8       	sub	r8,-4
80007486:	50 2c       	stdsp	sp[0x8],r12
80007488:	12 96       	mov	r6,r9
8000748a:	51 08       	stdsp	sp[0x40],r8
8000748c:	40 2b       	lddsp	r11,sp[0x8]
8000748e:	58 0b       	cp.w	r11,0
80007490:	fe 95 fe f0 	brlt	80007270 <_vfprintf_r+0x1bc>
80007494:	08 97       	mov	r7,r4
80007496:	cf 3a       	rjmp	8000727c <_vfprintf_r+0x1c8>
80007498:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000749c:	0f 38       	ld.ub	r8,r7++
8000749e:	f4 09 00 19 	add	r9,r10,r9<<0x1
800074a2:	f0 ca 00 30 	sub	r10,r8,48
800074a6:	58 9a       	cp.w	r10,9
800074a8:	fe 98 ff f8 	brls	80007498 <_vfprintf_r+0x3e4>
800074ac:	3f fa       	mov	r10,-1
800074ae:	f2 0a 0c 49 	max	r9,r9,r10
800074b2:	50 29       	stdsp	sp[0x8],r9
800074b4:	ce 7a       	rjmp	80007282 <_vfprintf_r+0x1ce>
800074b6:	a7 b5       	sbr	r5,0x7
800074b8:	ce 2a       	rjmp	8000727c <_vfprintf_r+0x1c8>
800074ba:	30 09       	mov	r9,0
800074bc:	23 08       	sub	r8,48
800074be:	f2 09 00 29 	add	r9,r9,r9<<0x2
800074c2:	f0 09 00 19 	add	r9,r8,r9<<0x1
800074c6:	0f 38       	ld.ub	r8,r7++
800074c8:	f0 ca 00 30 	sub	r10,r8,48
800074cc:	58 9a       	cp.w	r10,9
800074ce:	fe 98 ff f7 	brls	800074bc <_vfprintf_r+0x408>
800074d2:	e0 48 00 24 	cp.w	r8,36
800074d6:	fe 91 fe d5 	brne	80007280 <_vfprintf_r+0x1cc>
800074da:	e0 49 00 20 	cp.w	r9,32
800074de:	e0 89 0d 75 	brgt	80008fc8 <_vfprintf_r+0x1f14>
800074e2:	f2 c3 00 01 	sub	r3,r9,1
800074e6:	30 19       	mov	r9,1
800074e8:	50 39       	stdsp	sp[0xc],r9
800074ea:	cc 9a       	rjmp	8000727c <_vfprintf_r+0x1c8>
800074ec:	a3 b5       	sbr	r5,0x3
800074ee:	cc 7a       	rjmp	8000727c <_vfprintf_r+0x1c8>
800074f0:	a7 a5       	sbr	r5,0x6
800074f2:	cc 5a       	rjmp	8000727c <_vfprintf_r+0x1c8>
800074f4:	0a 98       	mov	r8,r5
800074f6:	a5 b5       	sbr	r5,0x5
800074f8:	a5 a8       	sbr	r8,0x4
800074fa:	0f 89       	ld.ub	r9,r7[0x0]
800074fc:	36 ce       	mov	lr,108
800074fe:	fc 09 18 00 	cp.b	r9,lr
80007502:	f7 b7 00 ff 	subeq	r7,-1
80007506:	f0 05 17 10 	movne	r5,r8
8000750a:	cb 9a       	rjmp	8000727c <_vfprintf_r+0x1c8>
8000750c:	a5 b5       	sbr	r5,0x5
8000750e:	cb 7a       	rjmp	8000727c <_vfprintf_r+0x1c8>
80007510:	50 a7       	stdsp	sp[0x28],r7
80007512:	50 80       	stdsp	sp[0x20],r0
80007514:	0c 97       	mov	r7,r6
80007516:	10 90       	mov	r0,r8
80007518:	06 96       	mov	r6,r3
8000751a:	04 94       	mov	r4,r2
8000751c:	40 93       	lddsp	r3,sp[0x24]
8000751e:	02 92       	mov	r2,r1
80007520:	0e 99       	mov	r9,r7
80007522:	40 41       	lddsp	r1,sp[0x10]
80007524:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007528:	40 3c       	lddsp	r12,sp[0xc]
8000752a:	58 0c       	cp.w	r12,0
8000752c:	c1 d0       	breq	80007566 <_vfprintf_r+0x4b2>
8000752e:	10 36       	cp.w	r6,r8
80007530:	c0 64       	brge	8000753c <_vfprintf_r+0x488>
80007532:	fa cb f9 44 	sub	r11,sp,-1724
80007536:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000753a:	c1 d8       	rjmp	80007574 <_vfprintf_r+0x4c0>
8000753c:	fa c8 f9 50 	sub	r8,sp,-1712
80007540:	1a d8       	st.w	--sp,r8
80007542:	fa c8 fa b8 	sub	r8,sp,-1352
80007546:	1a d8       	st.w	--sp,r8
80007548:	fa c8 fb b4 	sub	r8,sp,-1100
8000754c:	1a d8       	st.w	--sp,r8
8000754e:	fa c8 f9 40 	sub	r8,sp,-1728
80007552:	fa c9 ff b4 	sub	r9,sp,-76
80007556:	04 9a       	mov	r10,r2
80007558:	0c 9b       	mov	r11,r6
8000755a:	08 9c       	mov	r12,r4
8000755c:	fe b0 fc 0e 	rcall	80006d78 <get_arg>
80007560:	2f dd       	sub	sp,-12
80007562:	19 b8       	ld.ub	r8,r12[0x3]
80007564:	c2 28       	rjmp	800075a8 <_vfprintf_r+0x4f4>
80007566:	2f f7       	sub	r7,-1
80007568:	10 39       	cp.w	r9,r8
8000756a:	c0 84       	brge	8000757a <_vfprintf_r+0x4c6>
8000756c:	fa ca f9 44 	sub	r10,sp,-1724
80007570:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007574:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007578:	c1 88       	rjmp	800075a8 <_vfprintf_r+0x4f4>
8000757a:	41 09       	lddsp	r9,sp[0x40]
8000757c:	59 f8       	cp.w	r8,31
8000757e:	e0 89 00 12 	brgt	800075a2 <_vfprintf_r+0x4ee>
80007582:	f2 ca ff fc 	sub	r10,r9,-4
80007586:	51 0a       	stdsp	sp[0x40],r10
80007588:	72 09       	ld.w	r9,r9[0x0]
8000758a:	fa c6 f9 44 	sub	r6,sp,-1724
8000758e:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007592:	2f f8       	sub	r8,-1
80007594:	f5 49 fd 88 	st.w	r10[-632],r9
80007598:	fb 48 06 b4 	st.w	sp[1716],r8
8000759c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800075a0:	c0 48       	rjmp	800075a8 <_vfprintf_r+0x4f4>
800075a2:	13 b8       	ld.ub	r8,r9[0x3]
800075a4:	2f c9       	sub	r9,-4
800075a6:	51 09       	stdsp	sp[0x40],r9
800075a8:	fb 68 06 60 	st.b	sp[1632],r8
800075ac:	30 0e       	mov	lr,0
800075ae:	30 08       	mov	r8,0
800075b0:	30 12       	mov	r2,1
800075b2:	fb 68 06 bb 	st.b	sp[1723],r8
800075b6:	50 2e       	stdsp	sp[0x8],lr
800075b8:	e0 8f 08 b1 	bral	8000871a <_vfprintf_r+0x1666>
800075bc:	50 a7       	stdsp	sp[0x28],r7
800075be:	50 80       	stdsp	sp[0x20],r0
800075c0:	0c 97       	mov	r7,r6
800075c2:	04 94       	mov	r4,r2
800075c4:	06 96       	mov	r6,r3
800075c6:	02 92       	mov	r2,r1
800075c8:	40 93       	lddsp	r3,sp[0x24]
800075ca:	10 90       	mov	r0,r8
800075cc:	40 41       	lddsp	r1,sp[0x10]
800075ce:	a5 a5       	sbr	r5,0x4
800075d0:	c0 a8       	rjmp	800075e4 <_vfprintf_r+0x530>
800075d2:	50 a7       	stdsp	sp[0x28],r7
800075d4:	50 80       	stdsp	sp[0x20],r0
800075d6:	0c 97       	mov	r7,r6
800075d8:	04 94       	mov	r4,r2
800075da:	06 96       	mov	r6,r3
800075dc:	02 92       	mov	r2,r1
800075de:	40 93       	lddsp	r3,sp[0x24]
800075e0:	10 90       	mov	r0,r8
800075e2:	40 41       	lddsp	r1,sp[0x10]
800075e4:	ed b5 00 05 	bld	r5,0x5
800075e8:	c5 11       	brne	8000768a <_vfprintf_r+0x5d6>
800075ea:	fa f8 06 b4 	ld.w	r8,sp[1716]
800075ee:	40 3c       	lddsp	r12,sp[0xc]
800075f0:	58 0c       	cp.w	r12,0
800075f2:	c1 e0       	breq	8000762e <_vfprintf_r+0x57a>
800075f4:	10 36       	cp.w	r6,r8
800075f6:	c0 64       	brge	80007602 <_vfprintf_r+0x54e>
800075f8:	fa cb f9 44 	sub	r11,sp,-1724
800075fc:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007600:	c2 08       	rjmp	80007640 <_vfprintf_r+0x58c>
80007602:	fa c8 f9 50 	sub	r8,sp,-1712
80007606:	1a d8       	st.w	--sp,r8
80007608:	fa c8 fa b8 	sub	r8,sp,-1352
8000760c:	0c 9b       	mov	r11,r6
8000760e:	1a d8       	st.w	--sp,r8
80007610:	fa c8 fb b4 	sub	r8,sp,-1100
80007614:	1a d8       	st.w	--sp,r8
80007616:	fa c9 ff b4 	sub	r9,sp,-76
8000761a:	fa c8 f9 40 	sub	r8,sp,-1728
8000761e:	04 9a       	mov	r10,r2
80007620:	08 9c       	mov	r12,r4
80007622:	fe b0 fb ab 	rcall	80006d78 <get_arg>
80007626:	2f dd       	sub	sp,-12
80007628:	78 1b       	ld.w	r11,r12[0x4]
8000762a:	78 09       	ld.w	r9,r12[0x0]
8000762c:	c2 b8       	rjmp	80007682 <_vfprintf_r+0x5ce>
8000762e:	ee ca ff ff 	sub	r10,r7,-1
80007632:	10 37       	cp.w	r7,r8
80007634:	c0 b4       	brge	8000764a <_vfprintf_r+0x596>
80007636:	fa c9 f9 44 	sub	r9,sp,-1724
8000763a:	14 97       	mov	r7,r10
8000763c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007640:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007644:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007648:	c1 d8       	rjmp	80007682 <_vfprintf_r+0x5ce>
8000764a:	41 09       	lddsp	r9,sp[0x40]
8000764c:	59 f8       	cp.w	r8,31
8000764e:	e0 89 00 14 	brgt	80007676 <_vfprintf_r+0x5c2>
80007652:	f2 cb ff f8 	sub	r11,r9,-8
80007656:	51 0b       	stdsp	sp[0x40],r11
80007658:	fa c6 f9 44 	sub	r6,sp,-1724
8000765c:	72 1b       	ld.w	r11,r9[0x4]
8000765e:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007662:	72 09       	ld.w	r9,r9[0x0]
80007664:	f9 4b fd 8c 	st.w	r12[-628],r11
80007668:	f9 49 fd 88 	st.w	r12[-632],r9
8000766c:	2f f8       	sub	r8,-1
8000766e:	14 97       	mov	r7,r10
80007670:	fb 48 06 b4 	st.w	sp[1716],r8
80007674:	c0 78       	rjmp	80007682 <_vfprintf_r+0x5ce>
80007676:	f2 c8 ff f8 	sub	r8,r9,-8
8000767a:	72 1b       	ld.w	r11,r9[0x4]
8000767c:	14 97       	mov	r7,r10
8000767e:	51 08       	stdsp	sp[0x40],r8
80007680:	72 09       	ld.w	r9,r9[0x0]
80007682:	16 98       	mov	r8,r11
80007684:	fa e9 00 00 	st.d	sp[0],r8
80007688:	ca e8       	rjmp	800077e4 <_vfprintf_r+0x730>
8000768a:	ed b5 00 04 	bld	r5,0x4
8000768e:	c1 71       	brne	800076bc <_vfprintf_r+0x608>
80007690:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007694:	40 3e       	lddsp	lr,sp[0xc]
80007696:	58 0e       	cp.w	lr,0
80007698:	c0 80       	breq	800076a8 <_vfprintf_r+0x5f4>
8000769a:	10 36       	cp.w	r6,r8
8000769c:	c6 94       	brge	8000776e <_vfprintf_r+0x6ba>
8000769e:	fa cc f9 44 	sub	r12,sp,-1724
800076a2:	f8 06 00 36 	add	r6,r12,r6<<0x3
800076a6:	c8 28       	rjmp	800077aa <_vfprintf_r+0x6f6>
800076a8:	ee ca ff ff 	sub	r10,r7,-1
800076ac:	10 37       	cp.w	r7,r8
800076ae:	e0 84 00 81 	brge	800077b0 <_vfprintf_r+0x6fc>
800076b2:	fa cb f9 44 	sub	r11,sp,-1724
800076b6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800076ba:	c7 78       	rjmp	800077a8 <_vfprintf_r+0x6f4>
800076bc:	ed b5 00 06 	bld	r5,0x6
800076c0:	c4 b1       	brne	80007756 <_vfprintf_r+0x6a2>
800076c2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800076c6:	40 3c       	lddsp	r12,sp[0xc]
800076c8:	58 0c       	cp.w	r12,0
800076ca:	c1 d0       	breq	80007704 <_vfprintf_r+0x650>
800076cc:	10 36       	cp.w	r6,r8
800076ce:	c0 64       	brge	800076da <_vfprintf_r+0x626>
800076d0:	fa cb f9 44 	sub	r11,sp,-1724
800076d4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800076d8:	c1 f8       	rjmp	80007716 <_vfprintf_r+0x662>
800076da:	fa c8 f9 50 	sub	r8,sp,-1712
800076de:	1a d8       	st.w	--sp,r8
800076e0:	fa c8 fa b8 	sub	r8,sp,-1352
800076e4:	1a d8       	st.w	--sp,r8
800076e6:	fa c8 fb b4 	sub	r8,sp,-1100
800076ea:	1a d8       	st.w	--sp,r8
800076ec:	fa c8 f9 40 	sub	r8,sp,-1728
800076f0:	fa c9 ff b4 	sub	r9,sp,-76
800076f4:	04 9a       	mov	r10,r2
800076f6:	0c 9b       	mov	r11,r6
800076f8:	08 9c       	mov	r12,r4
800076fa:	fe b0 fb 3f 	rcall	80006d78 <get_arg>
800076fe:	2f dd       	sub	sp,-12
80007700:	98 18       	ld.sh	r8,r12[0x2]
80007702:	c2 68       	rjmp	8000774e <_vfprintf_r+0x69a>
80007704:	ee ca ff ff 	sub	r10,r7,-1
80007708:	10 37       	cp.w	r7,r8
8000770a:	c0 94       	brge	8000771c <_vfprintf_r+0x668>
8000770c:	fa c9 f9 44 	sub	r9,sp,-1724
80007710:	14 97       	mov	r7,r10
80007712:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007716:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000771a:	c1 a8       	rjmp	8000774e <_vfprintf_r+0x69a>
8000771c:	41 09       	lddsp	r9,sp[0x40]
8000771e:	59 f8       	cp.w	r8,31
80007720:	e0 89 00 13 	brgt	80007746 <_vfprintf_r+0x692>
80007724:	f2 cb ff fc 	sub	r11,r9,-4
80007728:	51 0b       	stdsp	sp[0x40],r11
8000772a:	72 09       	ld.w	r9,r9[0x0]
8000772c:	fa c6 f9 44 	sub	r6,sp,-1724
80007730:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007734:	2f f8       	sub	r8,-1
80007736:	f7 49 fd 88 	st.w	r11[-632],r9
8000773a:	fb 48 06 b4 	st.w	sp[1716],r8
8000773e:	14 97       	mov	r7,r10
80007740:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007744:	c0 58       	rjmp	8000774e <_vfprintf_r+0x69a>
80007746:	92 18       	ld.sh	r8,r9[0x2]
80007748:	14 97       	mov	r7,r10
8000774a:	2f c9       	sub	r9,-4
8000774c:	51 09       	stdsp	sp[0x40],r9
8000774e:	50 18       	stdsp	sp[0x4],r8
80007750:	bf 58       	asr	r8,0x1f
80007752:	50 08       	stdsp	sp[0x0],r8
80007754:	c4 88       	rjmp	800077e4 <_vfprintf_r+0x730>
80007756:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000775a:	40 3c       	lddsp	r12,sp[0xc]
8000775c:	58 0c       	cp.w	r12,0
8000775e:	c1 d0       	breq	80007798 <_vfprintf_r+0x6e4>
80007760:	10 36       	cp.w	r6,r8
80007762:	c0 64       	brge	8000776e <_vfprintf_r+0x6ba>
80007764:	fa cb f9 44 	sub	r11,sp,-1724
80007768:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000776c:	c1 f8       	rjmp	800077aa <_vfprintf_r+0x6f6>
8000776e:	fa c8 f9 50 	sub	r8,sp,-1712
80007772:	1a d8       	st.w	--sp,r8
80007774:	fa c8 fa b8 	sub	r8,sp,-1352
80007778:	0c 9b       	mov	r11,r6
8000777a:	1a d8       	st.w	--sp,r8
8000777c:	fa c8 fb b4 	sub	r8,sp,-1100
80007780:	04 9a       	mov	r10,r2
80007782:	1a d8       	st.w	--sp,r8
80007784:	08 9c       	mov	r12,r4
80007786:	fa c8 f9 40 	sub	r8,sp,-1728
8000778a:	fa c9 ff b4 	sub	r9,sp,-76
8000778e:	fe b0 fa f5 	rcall	80006d78 <get_arg>
80007792:	2f dd       	sub	sp,-12
80007794:	78 0b       	ld.w	r11,r12[0x0]
80007796:	c2 48       	rjmp	800077de <_vfprintf_r+0x72a>
80007798:	ee ca ff ff 	sub	r10,r7,-1
8000779c:	10 37       	cp.w	r7,r8
8000779e:	c0 94       	brge	800077b0 <_vfprintf_r+0x6fc>
800077a0:	fa c9 f9 44 	sub	r9,sp,-1724
800077a4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800077a8:	14 97       	mov	r7,r10
800077aa:	ec fb fd 88 	ld.w	r11,r6[-632]
800077ae:	c1 88       	rjmp	800077de <_vfprintf_r+0x72a>
800077b0:	41 09       	lddsp	r9,sp[0x40]
800077b2:	59 f8       	cp.w	r8,31
800077b4:	e0 89 00 11 	brgt	800077d6 <_vfprintf_r+0x722>
800077b8:	f2 cb ff fc 	sub	r11,r9,-4
800077bc:	51 0b       	stdsp	sp[0x40],r11
800077be:	fa c6 f9 44 	sub	r6,sp,-1724
800077c2:	72 0b       	ld.w	r11,r9[0x0]
800077c4:	ec 08 00 39 	add	r9,r6,r8<<0x3
800077c8:	f3 4b fd 88 	st.w	r9[-632],r11
800077cc:	2f f8       	sub	r8,-1
800077ce:	14 97       	mov	r7,r10
800077d0:	fb 48 06 b4 	st.w	sp[1716],r8
800077d4:	c0 58       	rjmp	800077de <_vfprintf_r+0x72a>
800077d6:	72 0b       	ld.w	r11,r9[0x0]
800077d8:	14 97       	mov	r7,r10
800077da:	2f c9       	sub	r9,-4
800077dc:	51 09       	stdsp	sp[0x40],r9
800077de:	50 1b       	stdsp	sp[0x4],r11
800077e0:	bf 5b       	asr	r11,0x1f
800077e2:	50 0b       	stdsp	sp[0x0],r11
800077e4:	fa ea 00 00 	ld.d	r10,sp[0]
800077e8:	58 0a       	cp.w	r10,0
800077ea:	5c 2b       	cpc	r11
800077ec:	c0 e4       	brge	80007808 <_vfprintf_r+0x754>
800077ee:	30 08       	mov	r8,0
800077f0:	fa ea 00 00 	ld.d	r10,sp[0]
800077f4:	30 09       	mov	r9,0
800077f6:	f0 0a 01 0a 	sub	r10,r8,r10
800077fa:	f2 0b 01 4b 	sbc	r11,r9,r11
800077fe:	32 d8       	mov	r8,45
80007800:	fa eb 00 00 	st.d	sp[0],r10
80007804:	fb 68 06 bb 	st.b	sp[1723],r8
80007808:	30 18       	mov	r8,1
8000780a:	e0 8f 06 fe 	bral	80008606 <_vfprintf_r+0x1552>
8000780e:	50 a7       	stdsp	sp[0x28],r7
80007810:	50 80       	stdsp	sp[0x20],r0
80007812:	0c 97       	mov	r7,r6
80007814:	04 94       	mov	r4,r2
80007816:	06 96       	mov	r6,r3
80007818:	02 92       	mov	r2,r1
8000781a:	40 93       	lddsp	r3,sp[0x24]
8000781c:	10 90       	mov	r0,r8
8000781e:	40 41       	lddsp	r1,sp[0x10]
80007820:	0e 99       	mov	r9,r7
80007822:	ed b5 00 03 	bld	r5,0x3
80007826:	c4 11       	brne	800078a8 <_vfprintf_r+0x7f4>
80007828:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000782c:	40 3a       	lddsp	r10,sp[0xc]
8000782e:	58 0a       	cp.w	r10,0
80007830:	c1 90       	breq	80007862 <_vfprintf_r+0x7ae>
80007832:	10 36       	cp.w	r6,r8
80007834:	c6 45       	brlt	800078fc <_vfprintf_r+0x848>
80007836:	fa c8 f9 50 	sub	r8,sp,-1712
8000783a:	1a d8       	st.w	--sp,r8
8000783c:	fa c8 fa b8 	sub	r8,sp,-1352
80007840:	1a d8       	st.w	--sp,r8
80007842:	fa c8 fb b4 	sub	r8,sp,-1100
80007846:	0c 9b       	mov	r11,r6
80007848:	1a d8       	st.w	--sp,r8
8000784a:	04 9a       	mov	r10,r2
8000784c:	fa c8 f9 40 	sub	r8,sp,-1728
80007850:	fa c9 ff b4 	sub	r9,sp,-76
80007854:	08 9c       	mov	r12,r4
80007856:	fe b0 fa 91 	rcall	80006d78 <get_arg>
8000785a:	2f dd       	sub	sp,-12
8000785c:	78 16       	ld.w	r6,r12[0x4]
8000785e:	50 76       	stdsp	sp[0x1c],r6
80007860:	c4 88       	rjmp	800078f0 <_vfprintf_r+0x83c>
80007862:	2f f7       	sub	r7,-1
80007864:	10 39       	cp.w	r9,r8
80007866:	c0 c4       	brge	8000787e <_vfprintf_r+0x7ca>
80007868:	fa ce f9 44 	sub	lr,sp,-1724
8000786c:	fc 06 00 36 	add	r6,lr,r6<<0x3
80007870:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007874:	50 7c       	stdsp	sp[0x1c],r12
80007876:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000787a:	50 56       	stdsp	sp[0x14],r6
8000787c:	c6 68       	rjmp	80007948 <_vfprintf_r+0x894>
8000787e:	41 09       	lddsp	r9,sp[0x40]
80007880:	59 f8       	cp.w	r8,31
80007882:	e0 89 00 10 	brgt	800078a2 <_vfprintf_r+0x7ee>
80007886:	f2 ca ff f8 	sub	r10,r9,-8
8000788a:	72 1b       	ld.w	r11,r9[0x4]
8000788c:	51 0a       	stdsp	sp[0x40],r10
8000788e:	72 09       	ld.w	r9,r9[0x0]
80007890:	fa ca f9 44 	sub	r10,sp,-1724
80007894:	50 7b       	stdsp	sp[0x1c],r11
80007896:	50 59       	stdsp	sp[0x14],r9
80007898:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000789c:	40 5b       	lddsp	r11,sp[0x14]
8000789e:	40 7a       	lddsp	r10,sp[0x1c]
800078a0:	c4 78       	rjmp	8000792e <_vfprintf_r+0x87a>
800078a2:	72 18       	ld.w	r8,r9[0x4]
800078a4:	50 78       	stdsp	sp[0x1c],r8
800078a6:	c4 c8       	rjmp	8000793e <_vfprintf_r+0x88a>
800078a8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800078ac:	40 3e       	lddsp	lr,sp[0xc]
800078ae:	58 0e       	cp.w	lr,0
800078b0:	c2 30       	breq	800078f6 <_vfprintf_r+0x842>
800078b2:	10 36       	cp.w	r6,r8
800078b4:	c0 94       	brge	800078c6 <_vfprintf_r+0x812>
800078b6:	fa cc f9 44 	sub	r12,sp,-1724
800078ba:	f8 06 00 36 	add	r6,r12,r6<<0x3
800078be:	ec fb fd 8c 	ld.w	r11,r6[-628]
800078c2:	50 7b       	stdsp	sp[0x1c],r11
800078c4:	cd 9b       	rjmp	80007876 <_vfprintf_r+0x7c2>
800078c6:	fa c8 f9 50 	sub	r8,sp,-1712
800078ca:	1a d8       	st.w	--sp,r8
800078cc:	fa c8 fa b8 	sub	r8,sp,-1352
800078d0:	04 9a       	mov	r10,r2
800078d2:	1a d8       	st.w	--sp,r8
800078d4:	fa c8 fb b4 	sub	r8,sp,-1100
800078d8:	0c 9b       	mov	r11,r6
800078da:	1a d8       	st.w	--sp,r8
800078dc:	08 9c       	mov	r12,r4
800078de:	fa c8 f9 40 	sub	r8,sp,-1728
800078e2:	fa c9 ff b4 	sub	r9,sp,-76
800078e6:	fe b0 fa 49 	rcall	80006d78 <get_arg>
800078ea:	2f dd       	sub	sp,-12
800078ec:	78 1a       	ld.w	r10,r12[0x4]
800078ee:	50 7a       	stdsp	sp[0x1c],r10
800078f0:	78 0c       	ld.w	r12,r12[0x0]
800078f2:	50 5c       	stdsp	sp[0x14],r12
800078f4:	c2 a8       	rjmp	80007948 <_vfprintf_r+0x894>
800078f6:	2f f7       	sub	r7,-1
800078f8:	10 39       	cp.w	r9,r8
800078fa:	c0 94       	brge	8000790c <_vfprintf_r+0x858>
800078fc:	fa c9 f9 44 	sub	r9,sp,-1724
80007900:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007904:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80007908:	50 78       	stdsp	sp[0x1c],r8
8000790a:	cb 6b       	rjmp	80007876 <_vfprintf_r+0x7c2>
8000790c:	41 09       	lddsp	r9,sp[0x40]
8000790e:	59 f8       	cp.w	r8,31
80007910:	e0 89 00 15 	brgt	8000793a <_vfprintf_r+0x886>
80007914:	f2 ca ff f8 	sub	r10,r9,-8
80007918:	72 16       	ld.w	r6,r9[0x4]
8000791a:	72 09       	ld.w	r9,r9[0x0]
8000791c:	51 0a       	stdsp	sp[0x40],r10
8000791e:	50 59       	stdsp	sp[0x14],r9
80007920:	fa ce f9 44 	sub	lr,sp,-1724
80007924:	50 76       	stdsp	sp[0x1c],r6
80007926:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000792a:	40 5b       	lddsp	r11,sp[0x14]
8000792c:	0c 9a       	mov	r10,r6
8000792e:	f2 eb fd 88 	st.d	r9[-632],r10
80007932:	2f f8       	sub	r8,-1
80007934:	fb 48 06 b4 	st.w	sp[1716],r8
80007938:	c0 88       	rjmp	80007948 <_vfprintf_r+0x894>
8000793a:	72 1c       	ld.w	r12,r9[0x4]
8000793c:	50 7c       	stdsp	sp[0x1c],r12
8000793e:	f2 c8 ff f8 	sub	r8,r9,-8
80007942:	51 08       	stdsp	sp[0x40],r8
80007944:	72 09       	ld.w	r9,r9[0x0]
80007946:	50 59       	stdsp	sp[0x14],r9
80007948:	40 5b       	lddsp	r11,sp[0x14]
8000794a:	40 7a       	lddsp	r10,sp[0x1c]
8000794c:	e0 a0 19 64 	rcall	8000ac14 <__isinfd>
80007950:	18 96       	mov	r6,r12
80007952:	c1 50       	breq	8000797c <_vfprintf_r+0x8c8>
80007954:	30 08       	mov	r8,0
80007956:	30 09       	mov	r9,0
80007958:	40 5b       	lddsp	r11,sp[0x14]
8000795a:	40 7a       	lddsp	r10,sp[0x1c]
8000795c:	e0 a0 1d ba 	rcall	8000b4d0 <__avr32_f64_cmp_lt>
80007960:	c0 40       	breq	80007968 <_vfprintf_r+0x8b4>
80007962:	32 d8       	mov	r8,45
80007964:	fb 68 06 bb 	st.b	sp[1723],r8
80007968:	4d 18       	lddpc	r8,80007aac <_vfprintf_r+0x9f8>
8000796a:	4d 26       	lddpc	r6,80007ab0 <_vfprintf_r+0x9fc>
8000796c:	a7 d5       	cbr	r5,0x7
8000796e:	e0 40 00 47 	cp.w	r0,71
80007972:	f0 06 17 a0 	movle	r6,r8
80007976:	30 32       	mov	r2,3
80007978:	e0 8f 06 d4 	bral	80008720 <_vfprintf_r+0x166c>
8000797c:	40 5b       	lddsp	r11,sp[0x14]
8000797e:	40 7a       	lddsp	r10,sp[0x1c]
80007980:	e0 a0 19 5f 	rcall	8000ac3e <__isnand>
80007984:	c0 c0       	breq	8000799c <_vfprintf_r+0x8e8>
80007986:	50 26       	stdsp	sp[0x8],r6
80007988:	4c b8       	lddpc	r8,80007ab4 <_vfprintf_r+0xa00>
8000798a:	4c c6       	lddpc	r6,80007ab8 <_vfprintf_r+0xa04>
8000798c:	a7 d5       	cbr	r5,0x7
8000798e:	e0 40 00 47 	cp.w	r0,71
80007992:	f0 06 17 a0 	movle	r6,r8
80007996:	30 32       	mov	r2,3
80007998:	e0 8f 06 ca 	bral	8000872c <_vfprintf_r+0x1678>
8000799c:	40 2a       	lddsp	r10,sp[0x8]
8000799e:	5b fa       	cp.w	r10,-1
800079a0:	c0 41       	brne	800079a8 <_vfprintf_r+0x8f4>
800079a2:	30 69       	mov	r9,6
800079a4:	50 29       	stdsp	sp[0x8],r9
800079a6:	c1 18       	rjmp	800079c8 <_vfprintf_r+0x914>
800079a8:	e0 40 00 47 	cp.w	r0,71
800079ac:	5f 09       	sreq	r9
800079ae:	e0 40 00 67 	cp.w	r0,103
800079b2:	5f 08       	sreq	r8
800079b4:	f3 e8 10 08 	or	r8,r9,r8
800079b8:	f8 08 18 00 	cp.b	r8,r12
800079bc:	c0 60       	breq	800079c8 <_vfprintf_r+0x914>
800079be:	40 28       	lddsp	r8,sp[0x8]
800079c0:	58 08       	cp.w	r8,0
800079c2:	f9 b8 00 01 	moveq	r8,1
800079c6:	50 28       	stdsp	sp[0x8],r8
800079c8:	40 78       	lddsp	r8,sp[0x1c]
800079ca:	40 59       	lddsp	r9,sp[0x14]
800079cc:	fa e9 06 94 	st.d	sp[1684],r8
800079d0:	a9 a5       	sbr	r5,0x8
800079d2:	fa f8 06 94 	ld.w	r8,sp[1684]
800079d6:	58 08       	cp.w	r8,0
800079d8:	c0 65       	brlt	800079e4 <_vfprintf_r+0x930>
800079da:	40 5e       	lddsp	lr,sp[0x14]
800079dc:	30 0c       	mov	r12,0
800079de:	50 6e       	stdsp	sp[0x18],lr
800079e0:	50 9c       	stdsp	sp[0x24],r12
800079e2:	c0 78       	rjmp	800079f0 <_vfprintf_r+0x93c>
800079e4:	40 5b       	lddsp	r11,sp[0x14]
800079e6:	32 da       	mov	r10,45
800079e8:	ee 1b 80 00 	eorh	r11,0x8000
800079ec:	50 9a       	stdsp	sp[0x24],r10
800079ee:	50 6b       	stdsp	sp[0x18],r11
800079f0:	e0 40 00 46 	cp.w	r0,70
800079f4:	5f 09       	sreq	r9
800079f6:	e0 40 00 66 	cp.w	r0,102
800079fa:	5f 08       	sreq	r8
800079fc:	f3 e8 10 08 	or	r8,r9,r8
80007a00:	50 48       	stdsp	sp[0x10],r8
80007a02:	c0 40       	breq	80007a0a <_vfprintf_r+0x956>
80007a04:	40 22       	lddsp	r2,sp[0x8]
80007a06:	30 39       	mov	r9,3
80007a08:	c1 08       	rjmp	80007a28 <_vfprintf_r+0x974>
80007a0a:	e0 40 00 45 	cp.w	r0,69
80007a0e:	5f 09       	sreq	r9
80007a10:	e0 40 00 65 	cp.w	r0,101
80007a14:	5f 08       	sreq	r8
80007a16:	40 22       	lddsp	r2,sp[0x8]
80007a18:	10 49       	or	r9,r8
80007a1a:	2f f2       	sub	r2,-1
80007a1c:	40 46       	lddsp	r6,sp[0x10]
80007a1e:	ec 09 18 00 	cp.b	r9,r6
80007a22:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80007a26:	30 29       	mov	r9,2
80007a28:	fa c8 f9 5c 	sub	r8,sp,-1700
80007a2c:	1a d8       	st.w	--sp,r8
80007a2e:	fa c8 f9 54 	sub	r8,sp,-1708
80007a32:	1a d8       	st.w	--sp,r8
80007a34:	fa c8 f9 4c 	sub	r8,sp,-1716
80007a38:	08 9c       	mov	r12,r4
80007a3a:	1a d8       	st.w	--sp,r8
80007a3c:	04 98       	mov	r8,r2
80007a3e:	40 9b       	lddsp	r11,sp[0x24]
80007a40:	40 aa       	lddsp	r10,sp[0x28]
80007a42:	e0 a0 0b cf 	rcall	800091e0 <_dtoa_r>
80007a46:	e0 40 00 47 	cp.w	r0,71
80007a4a:	5f 19       	srne	r9
80007a4c:	e0 40 00 67 	cp.w	r0,103
80007a50:	5f 18       	srne	r8
80007a52:	18 96       	mov	r6,r12
80007a54:	2f dd       	sub	sp,-12
80007a56:	f3 e8 00 08 	and	r8,r9,r8
80007a5a:	c0 41       	brne	80007a62 <_vfprintf_r+0x9ae>
80007a5c:	ed b5 00 00 	bld	r5,0x0
80007a60:	c3 81       	brne	80007ad0 <_vfprintf_r+0xa1c>
80007a62:	ec 02 00 0e 	add	lr,r6,r2
80007a66:	50 3e       	stdsp	sp[0xc],lr
80007a68:	40 4c       	lddsp	r12,sp[0x10]
80007a6a:	58 0c       	cp.w	r12,0
80007a6c:	c1 50       	breq	80007a96 <_vfprintf_r+0x9e2>
80007a6e:	0d 89       	ld.ub	r9,r6[0x0]
80007a70:	33 08       	mov	r8,48
80007a72:	f0 09 18 00 	cp.b	r9,r8
80007a76:	c0 b1       	brne	80007a8c <_vfprintf_r+0x9d8>
80007a78:	30 08       	mov	r8,0
80007a7a:	30 09       	mov	r9,0
80007a7c:	40 6b       	lddsp	r11,sp[0x18]
80007a7e:	40 7a       	lddsp	r10,sp[0x1c]
80007a80:	e0 a0 1c e1 	rcall	8000b442 <__avr32_f64_cmp_eq>
80007a84:	fb b2 00 01 	rsubeq	r2,1
80007a88:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80007a8c:	40 3b       	lddsp	r11,sp[0xc]
80007a8e:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007a92:	10 0b       	add	r11,r8
80007a94:	50 3b       	stdsp	sp[0xc],r11
80007a96:	40 6b       	lddsp	r11,sp[0x18]
80007a98:	30 08       	mov	r8,0
80007a9a:	30 09       	mov	r9,0
80007a9c:	40 7a       	lddsp	r10,sp[0x1c]
80007a9e:	e0 a0 1c d2 	rcall	8000b442 <__avr32_f64_cmp_eq>
80007aa2:	c1 10       	breq	80007ac4 <_vfprintf_r+0xa10>
80007aa4:	40 3a       	lddsp	r10,sp[0xc]
80007aa6:	fb 4a 06 a4 	st.w	sp[1700],r10
80007aaa:	c0 d8       	rjmp	80007ac4 <_vfprintf_r+0xa10>
80007aac:	80 01       	ld.sh	r1,r0[0x0]
80007aae:	52 5c       	stdsp	sp[0x94],r12
80007ab0:	80 01       	ld.sh	r1,r0[0x0]
80007ab2:	52 60       	stdsp	sp[0x98],r0
80007ab4:	80 01       	ld.sh	r1,r0[0x0]
80007ab6:	52 64       	stdsp	sp[0x98],r4
80007ab8:	80 01       	ld.sh	r1,r0[0x0]
80007aba:	52 68       	stdsp	sp[0x98],r8
80007abc:	10 c9       	st.b	r8++,r9
80007abe:	fb 48 06 a4 	st.w	sp[1700],r8
80007ac2:	c0 28       	rjmp	80007ac6 <_vfprintf_r+0xa12>
80007ac4:	33 09       	mov	r9,48
80007ac6:	fa f8 06 a4 	ld.w	r8,sp[1700]
80007aca:	40 3e       	lddsp	lr,sp[0xc]
80007acc:	1c 38       	cp.w	r8,lr
80007ace:	cf 73       	brcs	80007abc <_vfprintf_r+0xa08>
80007ad0:	e0 40 00 47 	cp.w	r0,71
80007ad4:	5f 09       	sreq	r9
80007ad6:	e0 40 00 67 	cp.w	r0,103
80007ada:	5f 08       	sreq	r8
80007adc:	f3 e8 10 08 	or	r8,r9,r8
80007ae0:	fa f9 06 a4 	ld.w	r9,sp[1700]
80007ae4:	0c 19       	sub	r9,r6
80007ae6:	50 69       	stdsp	sp[0x18],r9
80007ae8:	58 08       	cp.w	r8,0
80007aea:	c0 b0       	breq	80007b00 <_vfprintf_r+0xa4c>
80007aec:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007af0:	5b d8       	cp.w	r8,-3
80007af2:	c0 55       	brlt	80007afc <_vfprintf_r+0xa48>
80007af4:	40 2c       	lddsp	r12,sp[0x8]
80007af6:	18 38       	cp.w	r8,r12
80007af8:	e0 8a 00 6a 	brle	80007bcc <_vfprintf_r+0xb18>
80007afc:	20 20       	sub	r0,2
80007afe:	c0 58       	rjmp	80007b08 <_vfprintf_r+0xa54>
80007b00:	e0 40 00 65 	cp.w	r0,101
80007b04:	e0 89 00 46 	brgt	80007b90 <_vfprintf_r+0xadc>
80007b08:	fa fb 06 ac 	ld.w	r11,sp[1708]
80007b0c:	fb 60 06 9c 	st.b	sp[1692],r0
80007b10:	20 1b       	sub	r11,1
80007b12:	fb 4b 06 ac 	st.w	sp[1708],r11
80007b16:	c0 47       	brpl	80007b1e <_vfprintf_r+0xa6a>
80007b18:	5c 3b       	neg	r11
80007b1a:	32 d8       	mov	r8,45
80007b1c:	c0 28       	rjmp	80007b20 <_vfprintf_r+0xa6c>
80007b1e:	32 b8       	mov	r8,43
80007b20:	fb 68 06 9d 	st.b	sp[1693],r8
80007b24:	58 9b       	cp.w	r11,9
80007b26:	e0 8a 00 1d 	brle	80007b60 <_vfprintf_r+0xaac>
80007b2a:	fa c9 fa 35 	sub	r9,sp,-1483
80007b2e:	30 aa       	mov	r10,10
80007b30:	12 98       	mov	r8,r9
80007b32:	0e 9c       	mov	r12,r7
80007b34:	0c 92       	mov	r2,r6
80007b36:	f6 0a 0c 06 	divs	r6,r11,r10
80007b3a:	0e 9b       	mov	r11,r7
80007b3c:	2d 0b       	sub	r11,-48
80007b3e:	10 fb       	st.b	--r8,r11
80007b40:	0c 9b       	mov	r11,r6
80007b42:	58 96       	cp.w	r6,9
80007b44:	fe 99 ff f9 	brgt	80007b36 <_vfprintf_r+0xa82>
80007b48:	2d 0b       	sub	r11,-48
80007b4a:	18 97       	mov	r7,r12
80007b4c:	04 96       	mov	r6,r2
80007b4e:	10 fb       	st.b	--r8,r11
80007b50:	fa ca f9 62 	sub	r10,sp,-1694
80007b54:	c0 38       	rjmp	80007b5a <_vfprintf_r+0xaa6>
80007b56:	11 3b       	ld.ub	r11,r8++
80007b58:	14 cb       	st.b	r10++,r11
80007b5a:	12 38       	cp.w	r8,r9
80007b5c:	cf d3       	brcs	80007b56 <_vfprintf_r+0xaa2>
80007b5e:	c0 98       	rjmp	80007b70 <_vfprintf_r+0xabc>
80007b60:	2d 0b       	sub	r11,-48
80007b62:	33 08       	mov	r8,48
80007b64:	fb 6b 06 9f 	st.b	sp[1695],r11
80007b68:	fb 68 06 9e 	st.b	sp[1694],r8
80007b6c:	fa ca f9 60 	sub	r10,sp,-1696
80007b70:	fa c8 f9 64 	sub	r8,sp,-1692
80007b74:	f4 08 01 08 	sub	r8,r10,r8
80007b78:	50 e8       	stdsp	sp[0x38],r8
80007b7a:	10 92       	mov	r2,r8
80007b7c:	40 6b       	lddsp	r11,sp[0x18]
80007b7e:	16 02       	add	r2,r11
80007b80:	58 1b       	cp.w	r11,1
80007b82:	e0 89 00 05 	brgt	80007b8c <_vfprintf_r+0xad8>
80007b86:	ed b5 00 00 	bld	r5,0x0
80007b8a:	c3 51       	brne	80007bf4 <_vfprintf_r+0xb40>
80007b8c:	2f f2       	sub	r2,-1
80007b8e:	c3 38       	rjmp	80007bf4 <_vfprintf_r+0xb40>
80007b90:	e0 40 00 66 	cp.w	r0,102
80007b94:	c1 c1       	brne	80007bcc <_vfprintf_r+0xb18>
80007b96:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007b9a:	58 02       	cp.w	r2,0
80007b9c:	e0 8a 00 0c 	brle	80007bb4 <_vfprintf_r+0xb00>
80007ba0:	40 2a       	lddsp	r10,sp[0x8]
80007ba2:	58 0a       	cp.w	r10,0
80007ba4:	c0 41       	brne	80007bac <_vfprintf_r+0xaf8>
80007ba6:	ed b5 00 00 	bld	r5,0x0
80007baa:	c2 51       	brne	80007bf4 <_vfprintf_r+0xb40>
80007bac:	2f f2       	sub	r2,-1
80007bae:	40 29       	lddsp	r9,sp[0x8]
80007bb0:	12 02       	add	r2,r9
80007bb2:	c0 b8       	rjmp	80007bc8 <_vfprintf_r+0xb14>
80007bb4:	40 28       	lddsp	r8,sp[0x8]
80007bb6:	58 08       	cp.w	r8,0
80007bb8:	c0 61       	brne	80007bc4 <_vfprintf_r+0xb10>
80007bba:	ed b5 00 00 	bld	r5,0x0
80007bbe:	c0 30       	breq	80007bc4 <_vfprintf_r+0xb10>
80007bc0:	30 12       	mov	r2,1
80007bc2:	c1 98       	rjmp	80007bf4 <_vfprintf_r+0xb40>
80007bc4:	40 22       	lddsp	r2,sp[0x8]
80007bc6:	2f e2       	sub	r2,-2
80007bc8:	36 60       	mov	r0,102
80007bca:	c1 58       	rjmp	80007bf4 <_vfprintf_r+0xb40>
80007bcc:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007bd0:	40 6e       	lddsp	lr,sp[0x18]
80007bd2:	1c 32       	cp.w	r2,lr
80007bd4:	c0 65       	brlt	80007be0 <_vfprintf_r+0xb2c>
80007bd6:	ed b5 00 00 	bld	r5,0x0
80007bda:	f7 b2 00 ff 	subeq	r2,-1
80007bde:	c0 a8       	rjmp	80007bf2 <_vfprintf_r+0xb3e>
80007be0:	e4 08 11 02 	rsub	r8,r2,2
80007be4:	40 6c       	lddsp	r12,sp[0x18]
80007be6:	58 02       	cp.w	r2,0
80007be8:	f0 02 17 a0 	movle	r2,r8
80007bec:	f9 b2 09 01 	movgt	r2,1
80007bf0:	18 02       	add	r2,r12
80007bf2:	36 70       	mov	r0,103
80007bf4:	40 9b       	lddsp	r11,sp[0x24]
80007bf6:	58 0b       	cp.w	r11,0
80007bf8:	e0 80 05 94 	breq	80008720 <_vfprintf_r+0x166c>
80007bfc:	32 d8       	mov	r8,45
80007bfe:	fb 68 06 bb 	st.b	sp[1723],r8
80007c02:	e0 8f 05 93 	bral	80008728 <_vfprintf_r+0x1674>
80007c06:	50 a7       	stdsp	sp[0x28],r7
80007c08:	04 94       	mov	r4,r2
80007c0a:	0c 97       	mov	r7,r6
80007c0c:	02 92       	mov	r2,r1
80007c0e:	06 96       	mov	r6,r3
80007c10:	40 41       	lddsp	r1,sp[0x10]
80007c12:	40 93       	lddsp	r3,sp[0x24]
80007c14:	0e 99       	mov	r9,r7
80007c16:	ed b5 00 05 	bld	r5,0x5
80007c1a:	c4 81       	brne	80007caa <_vfprintf_r+0xbf6>
80007c1c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007c20:	40 3e       	lddsp	lr,sp[0xc]
80007c22:	58 0e       	cp.w	lr,0
80007c24:	c1 d0       	breq	80007c5e <_vfprintf_r+0xbaa>
80007c26:	10 36       	cp.w	r6,r8
80007c28:	c0 64       	brge	80007c34 <_vfprintf_r+0xb80>
80007c2a:	fa cc f9 44 	sub	r12,sp,-1724
80007c2e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007c32:	c1 d8       	rjmp	80007c6c <_vfprintf_r+0xbb8>
80007c34:	fa c8 f9 50 	sub	r8,sp,-1712
80007c38:	1a d8       	st.w	--sp,r8
80007c3a:	fa c8 fa b8 	sub	r8,sp,-1352
80007c3e:	04 9a       	mov	r10,r2
80007c40:	1a d8       	st.w	--sp,r8
80007c42:	fa c8 fb b4 	sub	r8,sp,-1100
80007c46:	0c 9b       	mov	r11,r6
80007c48:	1a d8       	st.w	--sp,r8
80007c4a:	08 9c       	mov	r12,r4
80007c4c:	fa c8 f9 40 	sub	r8,sp,-1728
80007c50:	fa c9 ff b4 	sub	r9,sp,-76
80007c54:	fe b0 f8 92 	rcall	80006d78 <get_arg>
80007c58:	2f dd       	sub	sp,-12
80007c5a:	78 0a       	ld.w	r10,r12[0x0]
80007c5c:	c2 08       	rjmp	80007c9c <_vfprintf_r+0xbe8>
80007c5e:	2f f7       	sub	r7,-1
80007c60:	10 39       	cp.w	r9,r8
80007c62:	c0 84       	brge	80007c72 <_vfprintf_r+0xbbe>
80007c64:	fa cb f9 44 	sub	r11,sp,-1724
80007c68:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007c6c:	ec fa fd 88 	ld.w	r10,r6[-632]
80007c70:	c1 68       	rjmp	80007c9c <_vfprintf_r+0xbe8>
80007c72:	41 09       	lddsp	r9,sp[0x40]
80007c74:	59 f8       	cp.w	r8,31
80007c76:	e0 89 00 10 	brgt	80007c96 <_vfprintf_r+0xbe2>
80007c7a:	f2 ca ff fc 	sub	r10,r9,-4
80007c7e:	51 0a       	stdsp	sp[0x40],r10
80007c80:	fa c6 f9 44 	sub	r6,sp,-1724
80007c84:	72 0a       	ld.w	r10,r9[0x0]
80007c86:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007c8a:	f3 4a fd 88 	st.w	r9[-632],r10
80007c8e:	2f f8       	sub	r8,-1
80007c90:	fb 48 06 b4 	st.w	sp[1716],r8
80007c94:	c0 48       	rjmp	80007c9c <_vfprintf_r+0xbe8>
80007c96:	72 0a       	ld.w	r10,r9[0x0]
80007c98:	2f c9       	sub	r9,-4
80007c9a:	51 09       	stdsp	sp[0x40],r9
80007c9c:	40 be       	lddsp	lr,sp[0x2c]
80007c9e:	1c 98       	mov	r8,lr
80007ca0:	95 1e       	st.w	r10[0x4],lr
80007ca2:	bf 58       	asr	r8,0x1f
80007ca4:	95 08       	st.w	r10[0x0],r8
80007ca6:	fe 9f fa 92 	bral	800071ca <_vfprintf_r+0x116>
80007caa:	ed b5 00 04 	bld	r5,0x4
80007cae:	c4 80       	breq	80007d3e <_vfprintf_r+0xc8a>
80007cb0:	e2 15 00 40 	andl	r5,0x40,COH
80007cb4:	c4 50       	breq	80007d3e <_vfprintf_r+0xc8a>
80007cb6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007cba:	40 3c       	lddsp	r12,sp[0xc]
80007cbc:	58 0c       	cp.w	r12,0
80007cbe:	c1 d0       	breq	80007cf8 <_vfprintf_r+0xc44>
80007cc0:	10 36       	cp.w	r6,r8
80007cc2:	c0 64       	brge	80007cce <_vfprintf_r+0xc1a>
80007cc4:	fa cb f9 44 	sub	r11,sp,-1724
80007cc8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007ccc:	c1 d8       	rjmp	80007d06 <_vfprintf_r+0xc52>
80007cce:	fa c8 f9 50 	sub	r8,sp,-1712
80007cd2:	1a d8       	st.w	--sp,r8
80007cd4:	fa c8 fa b8 	sub	r8,sp,-1352
80007cd8:	04 9a       	mov	r10,r2
80007cda:	1a d8       	st.w	--sp,r8
80007cdc:	fa c8 fb b4 	sub	r8,sp,-1100
80007ce0:	0c 9b       	mov	r11,r6
80007ce2:	1a d8       	st.w	--sp,r8
80007ce4:	08 9c       	mov	r12,r4
80007ce6:	fa c8 f9 40 	sub	r8,sp,-1728
80007cea:	fa c9 ff b4 	sub	r9,sp,-76
80007cee:	fe b0 f8 45 	rcall	80006d78 <get_arg>
80007cf2:	2f dd       	sub	sp,-12
80007cf4:	78 0a       	ld.w	r10,r12[0x0]
80007cf6:	c2 08       	rjmp	80007d36 <_vfprintf_r+0xc82>
80007cf8:	2f f7       	sub	r7,-1
80007cfa:	10 39       	cp.w	r9,r8
80007cfc:	c0 84       	brge	80007d0c <_vfprintf_r+0xc58>
80007cfe:	fa ca f9 44 	sub	r10,sp,-1724
80007d02:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007d06:	ec fa fd 88 	ld.w	r10,r6[-632]
80007d0a:	c1 68       	rjmp	80007d36 <_vfprintf_r+0xc82>
80007d0c:	41 09       	lddsp	r9,sp[0x40]
80007d0e:	59 f8       	cp.w	r8,31
80007d10:	e0 89 00 10 	brgt	80007d30 <_vfprintf_r+0xc7c>
80007d14:	f2 ca ff fc 	sub	r10,r9,-4
80007d18:	51 0a       	stdsp	sp[0x40],r10
80007d1a:	fa c6 f9 44 	sub	r6,sp,-1724
80007d1e:	72 0a       	ld.w	r10,r9[0x0]
80007d20:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007d24:	f3 4a fd 88 	st.w	r9[-632],r10
80007d28:	2f f8       	sub	r8,-1
80007d2a:	fb 48 06 b4 	st.w	sp[1716],r8
80007d2e:	c0 48       	rjmp	80007d36 <_vfprintf_r+0xc82>
80007d30:	72 0a       	ld.w	r10,r9[0x0]
80007d32:	2f c9       	sub	r9,-4
80007d34:	51 09       	stdsp	sp[0x40],r9
80007d36:	40 be       	lddsp	lr,sp[0x2c]
80007d38:	b4 0e       	st.h	r10[0x0],lr
80007d3a:	fe 9f fa 48 	bral	800071ca <_vfprintf_r+0x116>
80007d3e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d42:	40 3c       	lddsp	r12,sp[0xc]
80007d44:	58 0c       	cp.w	r12,0
80007d46:	c1 d0       	breq	80007d80 <_vfprintf_r+0xccc>
80007d48:	10 36       	cp.w	r6,r8
80007d4a:	c0 64       	brge	80007d56 <_vfprintf_r+0xca2>
80007d4c:	fa cb f9 44 	sub	r11,sp,-1724
80007d50:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007d54:	c1 d8       	rjmp	80007d8e <_vfprintf_r+0xcda>
80007d56:	fa c8 f9 50 	sub	r8,sp,-1712
80007d5a:	1a d8       	st.w	--sp,r8
80007d5c:	fa c8 fa b8 	sub	r8,sp,-1352
80007d60:	04 9a       	mov	r10,r2
80007d62:	1a d8       	st.w	--sp,r8
80007d64:	fa c8 fb b4 	sub	r8,sp,-1100
80007d68:	0c 9b       	mov	r11,r6
80007d6a:	1a d8       	st.w	--sp,r8
80007d6c:	08 9c       	mov	r12,r4
80007d6e:	fa c8 f9 40 	sub	r8,sp,-1728
80007d72:	fa c9 ff b4 	sub	r9,sp,-76
80007d76:	fe b0 f8 01 	rcall	80006d78 <get_arg>
80007d7a:	2f dd       	sub	sp,-12
80007d7c:	78 0a       	ld.w	r10,r12[0x0]
80007d7e:	c2 08       	rjmp	80007dbe <_vfprintf_r+0xd0a>
80007d80:	2f f7       	sub	r7,-1
80007d82:	10 39       	cp.w	r9,r8
80007d84:	c0 84       	brge	80007d94 <_vfprintf_r+0xce0>
80007d86:	fa ca f9 44 	sub	r10,sp,-1724
80007d8a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007d8e:	ec fa fd 88 	ld.w	r10,r6[-632]
80007d92:	c1 68       	rjmp	80007dbe <_vfprintf_r+0xd0a>
80007d94:	41 09       	lddsp	r9,sp[0x40]
80007d96:	59 f8       	cp.w	r8,31
80007d98:	e0 89 00 10 	brgt	80007db8 <_vfprintf_r+0xd04>
80007d9c:	f2 ca ff fc 	sub	r10,r9,-4
80007da0:	51 0a       	stdsp	sp[0x40],r10
80007da2:	fa c6 f9 44 	sub	r6,sp,-1724
80007da6:	72 0a       	ld.w	r10,r9[0x0]
80007da8:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007dac:	f3 4a fd 88 	st.w	r9[-632],r10
80007db0:	2f f8       	sub	r8,-1
80007db2:	fb 48 06 b4 	st.w	sp[1716],r8
80007db6:	c0 48       	rjmp	80007dbe <_vfprintf_r+0xd0a>
80007db8:	72 0a       	ld.w	r10,r9[0x0]
80007dba:	2f c9       	sub	r9,-4
80007dbc:	51 09       	stdsp	sp[0x40],r9
80007dbe:	40 be       	lddsp	lr,sp[0x2c]
80007dc0:	95 0e       	st.w	r10[0x0],lr
80007dc2:	fe 9f fa 04 	bral	800071ca <_vfprintf_r+0x116>
80007dc6:	50 a7       	stdsp	sp[0x28],r7
80007dc8:	50 80       	stdsp	sp[0x20],r0
80007dca:	0c 97       	mov	r7,r6
80007dcc:	04 94       	mov	r4,r2
80007dce:	06 96       	mov	r6,r3
80007dd0:	02 92       	mov	r2,r1
80007dd2:	40 93       	lddsp	r3,sp[0x24]
80007dd4:	10 90       	mov	r0,r8
80007dd6:	40 41       	lddsp	r1,sp[0x10]
80007dd8:	a5 a5       	sbr	r5,0x4
80007dda:	c0 a8       	rjmp	80007dee <_vfprintf_r+0xd3a>
80007ddc:	50 a7       	stdsp	sp[0x28],r7
80007dde:	50 80       	stdsp	sp[0x20],r0
80007de0:	0c 97       	mov	r7,r6
80007de2:	04 94       	mov	r4,r2
80007de4:	06 96       	mov	r6,r3
80007de6:	02 92       	mov	r2,r1
80007de8:	40 93       	lddsp	r3,sp[0x24]
80007dea:	10 90       	mov	r0,r8
80007dec:	40 41       	lddsp	r1,sp[0x10]
80007dee:	ed b5 00 05 	bld	r5,0x5
80007df2:	c5 d1       	brne	80007eac <_vfprintf_r+0xdf8>
80007df4:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007df8:	40 3c       	lddsp	r12,sp[0xc]
80007dfa:	58 0c       	cp.w	r12,0
80007dfc:	c2 60       	breq	80007e48 <_vfprintf_r+0xd94>
80007dfe:	10 36       	cp.w	r6,r8
80007e00:	c0 a4       	brge	80007e14 <_vfprintf_r+0xd60>
80007e02:	fa cb f9 44 	sub	r11,sp,-1724
80007e06:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007e0a:	ec e8 fd 88 	ld.d	r8,r6[-632]
80007e0e:	fa e9 00 00 	st.d	sp[0],r8
80007e12:	c1 88       	rjmp	80007e42 <_vfprintf_r+0xd8e>
80007e14:	fa c8 f9 50 	sub	r8,sp,-1712
80007e18:	1a d8       	st.w	--sp,r8
80007e1a:	fa c8 fa b8 	sub	r8,sp,-1352
80007e1e:	04 9a       	mov	r10,r2
80007e20:	1a d8       	st.w	--sp,r8
80007e22:	0c 9b       	mov	r11,r6
80007e24:	fa c8 fb b4 	sub	r8,sp,-1100
80007e28:	08 9c       	mov	r12,r4
80007e2a:	1a d8       	st.w	--sp,r8
80007e2c:	fa c8 f9 40 	sub	r8,sp,-1728
80007e30:	fa c9 ff b4 	sub	r9,sp,-76
80007e34:	fe b0 f7 a2 	rcall	80006d78 <get_arg>
80007e38:	2f dd       	sub	sp,-12
80007e3a:	f8 ea 00 00 	ld.d	r10,r12[0]
80007e3e:	fa eb 00 00 	st.d	sp[0],r10
80007e42:	30 08       	mov	r8,0
80007e44:	e0 8f 03 de 	bral	80008600 <_vfprintf_r+0x154c>
80007e48:	ee ca ff ff 	sub	r10,r7,-1
80007e4c:	10 37       	cp.w	r7,r8
80007e4e:	c0 b4       	brge	80007e64 <_vfprintf_r+0xdb0>
80007e50:	fa c9 f9 44 	sub	r9,sp,-1724
80007e54:	14 97       	mov	r7,r10
80007e56:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007e5a:	ec ea fd 88 	ld.d	r10,r6[-632]
80007e5e:	fa eb 00 00 	st.d	sp[0],r10
80007e62:	c1 88       	rjmp	80007e92 <_vfprintf_r+0xdde>
80007e64:	41 09       	lddsp	r9,sp[0x40]
80007e66:	59 f8       	cp.w	r8,31
80007e68:	e0 89 00 18 	brgt	80007e98 <_vfprintf_r+0xde4>
80007e6c:	f2 e6 00 00 	ld.d	r6,r9[0]
80007e70:	f2 cb ff f8 	sub	r11,r9,-8
80007e74:	fa e7 00 00 	st.d	sp[0],r6
80007e78:	51 0b       	stdsp	sp[0x40],r11
80007e7a:	fa c6 f9 44 	sub	r6,sp,-1724
80007e7e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007e82:	fa e6 00 00 	ld.d	r6,sp[0]
80007e86:	f2 e7 fd 88 	st.d	r9[-632],r6
80007e8a:	2f f8       	sub	r8,-1
80007e8c:	14 97       	mov	r7,r10
80007e8e:	fb 48 06 b4 	st.w	sp[1716],r8
80007e92:	40 38       	lddsp	r8,sp[0xc]
80007e94:	e0 8f 03 b6 	bral	80008600 <_vfprintf_r+0x154c>
80007e98:	f2 e6 00 00 	ld.d	r6,r9[0]
80007e9c:	40 38       	lddsp	r8,sp[0xc]
80007e9e:	fa e7 00 00 	st.d	sp[0],r6
80007ea2:	2f 89       	sub	r9,-8
80007ea4:	14 97       	mov	r7,r10
80007ea6:	51 09       	stdsp	sp[0x40],r9
80007ea8:	e0 8f 03 ac 	bral	80008600 <_vfprintf_r+0x154c>
80007eac:	ed b5 00 04 	bld	r5,0x4
80007eb0:	c1 61       	brne	80007edc <_vfprintf_r+0xe28>
80007eb2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007eb6:	40 3e       	lddsp	lr,sp[0xc]
80007eb8:	58 0e       	cp.w	lr,0
80007eba:	c0 80       	breq	80007eca <_vfprintf_r+0xe16>
80007ebc:	10 36       	cp.w	r6,r8
80007ebe:	c6 74       	brge	80007f8c <_vfprintf_r+0xed8>
80007ec0:	fa cc f9 44 	sub	r12,sp,-1724
80007ec4:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007ec8:	c8 08       	rjmp	80007fc8 <_vfprintf_r+0xf14>
80007eca:	ee ca ff ff 	sub	r10,r7,-1
80007ece:	10 37       	cp.w	r7,r8
80007ed0:	c7 f4       	brge	80007fce <_vfprintf_r+0xf1a>
80007ed2:	fa cb f9 44 	sub	r11,sp,-1724
80007ed6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007eda:	c7 68       	rjmp	80007fc6 <_vfprintf_r+0xf12>
80007edc:	ed b5 00 06 	bld	r5,0x6
80007ee0:	c4 a1       	brne	80007f74 <_vfprintf_r+0xec0>
80007ee2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ee6:	40 3c       	lddsp	r12,sp[0xc]
80007ee8:	58 0c       	cp.w	r12,0
80007eea:	c1 d0       	breq	80007f24 <_vfprintf_r+0xe70>
80007eec:	10 36       	cp.w	r6,r8
80007eee:	c0 64       	brge	80007efa <_vfprintf_r+0xe46>
80007ef0:	fa cb f9 44 	sub	r11,sp,-1724
80007ef4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007ef8:	c1 f8       	rjmp	80007f36 <_vfprintf_r+0xe82>
80007efa:	fa c8 f9 50 	sub	r8,sp,-1712
80007efe:	1a d8       	st.w	--sp,r8
80007f00:	fa c8 fa b8 	sub	r8,sp,-1352
80007f04:	1a d8       	st.w	--sp,r8
80007f06:	fa c8 fb b4 	sub	r8,sp,-1100
80007f0a:	1a d8       	st.w	--sp,r8
80007f0c:	fa c8 f9 40 	sub	r8,sp,-1728
80007f10:	fa c9 ff b4 	sub	r9,sp,-76
80007f14:	04 9a       	mov	r10,r2
80007f16:	0c 9b       	mov	r11,r6
80007f18:	08 9c       	mov	r12,r4
80007f1a:	fe b0 f7 2f 	rcall	80006d78 <get_arg>
80007f1e:	2f dd       	sub	sp,-12
80007f20:	98 18       	ld.sh	r8,r12[0x2]
80007f22:	c2 68       	rjmp	80007f6e <_vfprintf_r+0xeba>
80007f24:	ee ca ff ff 	sub	r10,r7,-1
80007f28:	10 37       	cp.w	r7,r8
80007f2a:	c0 94       	brge	80007f3c <_vfprintf_r+0xe88>
80007f2c:	fa c9 f9 44 	sub	r9,sp,-1724
80007f30:	14 97       	mov	r7,r10
80007f32:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007f36:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007f3a:	c1 a8       	rjmp	80007f6e <_vfprintf_r+0xeba>
80007f3c:	41 09       	lddsp	r9,sp[0x40]
80007f3e:	59 f8       	cp.w	r8,31
80007f40:	e0 89 00 13 	brgt	80007f66 <_vfprintf_r+0xeb2>
80007f44:	f2 cb ff fc 	sub	r11,r9,-4
80007f48:	51 0b       	stdsp	sp[0x40],r11
80007f4a:	72 09       	ld.w	r9,r9[0x0]
80007f4c:	fa c6 f9 44 	sub	r6,sp,-1724
80007f50:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007f54:	2f f8       	sub	r8,-1
80007f56:	f7 49 fd 88 	st.w	r11[-632],r9
80007f5a:	fb 48 06 b4 	st.w	sp[1716],r8
80007f5e:	14 97       	mov	r7,r10
80007f60:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007f64:	c0 58       	rjmp	80007f6e <_vfprintf_r+0xeba>
80007f66:	92 18       	ld.sh	r8,r9[0x2]
80007f68:	14 97       	mov	r7,r10
80007f6a:	2f c9       	sub	r9,-4
80007f6c:	51 09       	stdsp	sp[0x40],r9
80007f6e:	5c 78       	castu.h	r8
80007f70:	50 18       	stdsp	sp[0x4],r8
80007f72:	c4 68       	rjmp	80007ffe <_vfprintf_r+0xf4a>
80007f74:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f78:	40 3c       	lddsp	r12,sp[0xc]
80007f7a:	58 0c       	cp.w	r12,0
80007f7c:	c1 d0       	breq	80007fb6 <_vfprintf_r+0xf02>
80007f7e:	10 36       	cp.w	r6,r8
80007f80:	c0 64       	brge	80007f8c <_vfprintf_r+0xed8>
80007f82:	fa cb f9 44 	sub	r11,sp,-1724
80007f86:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f8a:	c1 f8       	rjmp	80007fc8 <_vfprintf_r+0xf14>
80007f8c:	fa c8 f9 50 	sub	r8,sp,-1712
80007f90:	1a d8       	st.w	--sp,r8
80007f92:	fa c8 fa b8 	sub	r8,sp,-1352
80007f96:	0c 9b       	mov	r11,r6
80007f98:	1a d8       	st.w	--sp,r8
80007f9a:	fa c8 fb b4 	sub	r8,sp,-1100
80007f9e:	04 9a       	mov	r10,r2
80007fa0:	1a d8       	st.w	--sp,r8
80007fa2:	08 9c       	mov	r12,r4
80007fa4:	fa c8 f9 40 	sub	r8,sp,-1728
80007fa8:	fa c9 ff b4 	sub	r9,sp,-76
80007fac:	fe b0 f6 e6 	rcall	80006d78 <get_arg>
80007fb0:	2f dd       	sub	sp,-12
80007fb2:	78 0b       	ld.w	r11,r12[0x0]
80007fb4:	c2 48       	rjmp	80007ffc <_vfprintf_r+0xf48>
80007fb6:	ee ca ff ff 	sub	r10,r7,-1
80007fba:	10 37       	cp.w	r7,r8
80007fbc:	c0 94       	brge	80007fce <_vfprintf_r+0xf1a>
80007fbe:	fa c9 f9 44 	sub	r9,sp,-1724
80007fc2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007fc6:	14 97       	mov	r7,r10
80007fc8:	ec fb fd 88 	ld.w	r11,r6[-632]
80007fcc:	c1 88       	rjmp	80007ffc <_vfprintf_r+0xf48>
80007fce:	41 09       	lddsp	r9,sp[0x40]
80007fd0:	59 f8       	cp.w	r8,31
80007fd2:	e0 89 00 11 	brgt	80007ff4 <_vfprintf_r+0xf40>
80007fd6:	f2 cb ff fc 	sub	r11,r9,-4
80007fda:	51 0b       	stdsp	sp[0x40],r11
80007fdc:	fa c6 f9 44 	sub	r6,sp,-1724
80007fe0:	72 0b       	ld.w	r11,r9[0x0]
80007fe2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007fe6:	f3 4b fd 88 	st.w	r9[-632],r11
80007fea:	2f f8       	sub	r8,-1
80007fec:	14 97       	mov	r7,r10
80007fee:	fb 48 06 b4 	st.w	sp[1716],r8
80007ff2:	c0 58       	rjmp	80007ffc <_vfprintf_r+0xf48>
80007ff4:	72 0b       	ld.w	r11,r9[0x0]
80007ff6:	14 97       	mov	r7,r10
80007ff8:	2f c9       	sub	r9,-4
80007ffa:	51 09       	stdsp	sp[0x40],r9
80007ffc:	50 1b       	stdsp	sp[0x4],r11
80007ffe:	30 0e       	mov	lr,0
80008000:	50 0e       	stdsp	sp[0x0],lr
80008002:	1c 98       	mov	r8,lr
80008004:	e0 8f 02 fe 	bral	80008600 <_vfprintf_r+0x154c>
80008008:	50 a7       	stdsp	sp[0x28],r7
8000800a:	50 80       	stdsp	sp[0x20],r0
8000800c:	0c 97       	mov	r7,r6
8000800e:	04 94       	mov	r4,r2
80008010:	06 96       	mov	r6,r3
80008012:	02 92       	mov	r2,r1
80008014:	40 93       	lddsp	r3,sp[0x24]
80008016:	40 41       	lddsp	r1,sp[0x10]
80008018:	0e 99       	mov	r9,r7
8000801a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000801e:	40 3c       	lddsp	r12,sp[0xc]
80008020:	58 0c       	cp.w	r12,0
80008022:	c1 d0       	breq	8000805c <_vfprintf_r+0xfa8>
80008024:	10 36       	cp.w	r6,r8
80008026:	c0 64       	brge	80008032 <_vfprintf_r+0xf7e>
80008028:	fa cb f9 44 	sub	r11,sp,-1724
8000802c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008030:	c1 d8       	rjmp	8000806a <_vfprintf_r+0xfb6>
80008032:	fa c8 f9 50 	sub	r8,sp,-1712
80008036:	1a d8       	st.w	--sp,r8
80008038:	fa c8 fa b8 	sub	r8,sp,-1352
8000803c:	1a d8       	st.w	--sp,r8
8000803e:	fa c8 fb b4 	sub	r8,sp,-1100
80008042:	1a d8       	st.w	--sp,r8
80008044:	fa c9 ff b4 	sub	r9,sp,-76
80008048:	fa c8 f9 40 	sub	r8,sp,-1728
8000804c:	04 9a       	mov	r10,r2
8000804e:	0c 9b       	mov	r11,r6
80008050:	08 9c       	mov	r12,r4
80008052:	fe b0 f6 93 	rcall	80006d78 <get_arg>
80008056:	2f dd       	sub	sp,-12
80008058:	78 09       	ld.w	r9,r12[0x0]
8000805a:	c2 18       	rjmp	8000809c <_vfprintf_r+0xfe8>
8000805c:	2f f7       	sub	r7,-1
8000805e:	10 39       	cp.w	r9,r8
80008060:	c0 84       	brge	80008070 <_vfprintf_r+0xfbc>
80008062:	fa ca f9 44 	sub	r10,sp,-1724
80008066:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000806a:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000806e:	c1 78       	rjmp	8000809c <_vfprintf_r+0xfe8>
80008070:	41 09       	lddsp	r9,sp[0x40]
80008072:	59 f8       	cp.w	r8,31
80008074:	e0 89 00 10 	brgt	80008094 <_vfprintf_r+0xfe0>
80008078:	f2 ca ff fc 	sub	r10,r9,-4
8000807c:	51 0a       	stdsp	sp[0x40],r10
8000807e:	fa c6 f9 44 	sub	r6,sp,-1724
80008082:	72 09       	ld.w	r9,r9[0x0]
80008084:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008088:	f5 49 fd 88 	st.w	r10[-632],r9
8000808c:	2f f8       	sub	r8,-1
8000808e:	fb 48 06 b4 	st.w	sp[1716],r8
80008092:	c0 58       	rjmp	8000809c <_vfprintf_r+0xfe8>
80008094:	f2 c8 ff fc 	sub	r8,r9,-4
80008098:	51 08       	stdsp	sp[0x40],r8
8000809a:	72 09       	ld.w	r9,r9[0x0]
8000809c:	33 08       	mov	r8,48
8000809e:	fb 68 06 b8 	st.b	sp[1720],r8
800080a2:	37 88       	mov	r8,120
800080a4:	30 0e       	mov	lr,0
800080a6:	fb 68 06 b9 	st.b	sp[1721],r8
800080aa:	4c ac       	lddpc	r12,800081d0 <_vfprintf_r+0x111c>
800080ac:	50 19       	stdsp	sp[0x4],r9
800080ae:	a1 b5       	sbr	r5,0x1
800080b0:	50 0e       	stdsp	sp[0x0],lr
800080b2:	50 dc       	stdsp	sp[0x34],r12
800080b4:	30 28       	mov	r8,2
800080b6:	37 80       	mov	r0,120
800080b8:	e0 8f 02 a4 	bral	80008600 <_vfprintf_r+0x154c>
800080bc:	50 a7       	stdsp	sp[0x28],r7
800080be:	50 80       	stdsp	sp[0x20],r0
800080c0:	10 90       	mov	r0,r8
800080c2:	30 08       	mov	r8,0
800080c4:	fb 68 06 bb 	st.b	sp[1723],r8
800080c8:	0c 97       	mov	r7,r6
800080ca:	04 94       	mov	r4,r2
800080cc:	06 96       	mov	r6,r3
800080ce:	02 92       	mov	r2,r1
800080d0:	40 93       	lddsp	r3,sp[0x24]
800080d2:	40 41       	lddsp	r1,sp[0x10]
800080d4:	0e 99       	mov	r9,r7
800080d6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080da:	40 3b       	lddsp	r11,sp[0xc]
800080dc:	58 0b       	cp.w	r11,0
800080de:	c1 d0       	breq	80008118 <_vfprintf_r+0x1064>
800080e0:	10 36       	cp.w	r6,r8
800080e2:	c0 64       	brge	800080ee <_vfprintf_r+0x103a>
800080e4:	fa ca f9 44 	sub	r10,sp,-1724
800080e8:	f4 06 00 36 	add	r6,r10,r6<<0x3
800080ec:	c1 d8       	rjmp	80008126 <_vfprintf_r+0x1072>
800080ee:	fa c8 f9 50 	sub	r8,sp,-1712
800080f2:	1a d8       	st.w	--sp,r8
800080f4:	fa c8 fa b8 	sub	r8,sp,-1352
800080f8:	1a d8       	st.w	--sp,r8
800080fa:	fa c8 fb b4 	sub	r8,sp,-1100
800080fe:	0c 9b       	mov	r11,r6
80008100:	1a d8       	st.w	--sp,r8
80008102:	04 9a       	mov	r10,r2
80008104:	fa c8 f9 40 	sub	r8,sp,-1728
80008108:	fa c9 ff b4 	sub	r9,sp,-76
8000810c:	08 9c       	mov	r12,r4
8000810e:	fe b0 f6 35 	rcall	80006d78 <get_arg>
80008112:	2f dd       	sub	sp,-12
80008114:	78 06       	ld.w	r6,r12[0x0]
80008116:	c2 08       	rjmp	80008156 <_vfprintf_r+0x10a2>
80008118:	2f f7       	sub	r7,-1
8000811a:	10 39       	cp.w	r9,r8
8000811c:	c0 84       	brge	8000812c <_vfprintf_r+0x1078>
8000811e:	fa c9 f9 44 	sub	r9,sp,-1724
80008122:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008126:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000812a:	c1 68       	rjmp	80008156 <_vfprintf_r+0x10a2>
8000812c:	41 09       	lddsp	r9,sp[0x40]
8000812e:	59 f8       	cp.w	r8,31
80008130:	e0 89 00 10 	brgt	80008150 <_vfprintf_r+0x109c>
80008134:	f2 ca ff fc 	sub	r10,r9,-4
80008138:	51 0a       	stdsp	sp[0x40],r10
8000813a:	72 06       	ld.w	r6,r9[0x0]
8000813c:	fa ce f9 44 	sub	lr,sp,-1724
80008140:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008144:	f3 46 fd 88 	st.w	r9[-632],r6
80008148:	2f f8       	sub	r8,-1
8000814a:	fb 48 06 b4 	st.w	sp[1716],r8
8000814e:	c0 48       	rjmp	80008156 <_vfprintf_r+0x10a2>
80008150:	72 06       	ld.w	r6,r9[0x0]
80008152:	2f c9       	sub	r9,-4
80008154:	51 09       	stdsp	sp[0x40],r9
80008156:	40 2c       	lddsp	r12,sp[0x8]
80008158:	58 0c       	cp.w	r12,0
8000815a:	c1 05       	brlt	8000817a <_vfprintf_r+0x10c6>
8000815c:	18 9a       	mov	r10,r12
8000815e:	30 0b       	mov	r11,0
80008160:	0c 9c       	mov	r12,r6
80008162:	e0 a0 12 43 	rcall	8000a5e8 <memchr>
80008166:	e0 80 02 e0 	breq	80008726 <_vfprintf_r+0x1672>
8000816a:	f8 06 01 02 	sub	r2,r12,r6
8000816e:	40 2b       	lddsp	r11,sp[0x8]
80008170:	16 32       	cp.w	r2,r11
80008172:	e0 89 02 da 	brgt	80008726 <_vfprintf_r+0x1672>
80008176:	e0 8f 02 d5 	bral	80008720 <_vfprintf_r+0x166c>
8000817a:	30 0a       	mov	r10,0
8000817c:	0c 9c       	mov	r12,r6
8000817e:	50 2a       	stdsp	sp[0x8],r10
80008180:	fe b0 f5 77 	rcall	80006c6e <strlen>
80008184:	18 92       	mov	r2,r12
80008186:	e0 8f 02 d3 	bral	8000872c <_vfprintf_r+0x1678>
8000818a:	50 a7       	stdsp	sp[0x28],r7
8000818c:	50 80       	stdsp	sp[0x20],r0
8000818e:	0c 97       	mov	r7,r6
80008190:	04 94       	mov	r4,r2
80008192:	06 96       	mov	r6,r3
80008194:	02 92       	mov	r2,r1
80008196:	40 93       	lddsp	r3,sp[0x24]
80008198:	10 90       	mov	r0,r8
8000819a:	40 41       	lddsp	r1,sp[0x10]
8000819c:	a5 a5       	sbr	r5,0x4
8000819e:	c0 a8       	rjmp	800081b2 <_vfprintf_r+0x10fe>
800081a0:	50 a7       	stdsp	sp[0x28],r7
800081a2:	50 80       	stdsp	sp[0x20],r0
800081a4:	0c 97       	mov	r7,r6
800081a6:	04 94       	mov	r4,r2
800081a8:	06 96       	mov	r6,r3
800081aa:	02 92       	mov	r2,r1
800081ac:	40 93       	lddsp	r3,sp[0x24]
800081ae:	10 90       	mov	r0,r8
800081b0:	40 41       	lddsp	r1,sp[0x10]
800081b2:	ed b5 00 05 	bld	r5,0x5
800081b6:	c5 71       	brne	80008264 <_vfprintf_r+0x11b0>
800081b8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081bc:	40 39       	lddsp	r9,sp[0xc]
800081be:	58 09       	cp.w	r9,0
800081c0:	c2 20       	breq	80008204 <_vfprintf_r+0x1150>
800081c2:	10 36       	cp.w	r6,r8
800081c4:	c0 84       	brge	800081d4 <_vfprintf_r+0x1120>
800081c6:	fa c8 f9 44 	sub	r8,sp,-1724
800081ca:	f0 06 00 36 	add	r6,r8,r6<<0x3
800081ce:	c2 48       	rjmp	80008216 <_vfprintf_r+0x1162>
800081d0:	80 01       	ld.sh	r1,r0[0x0]
800081d2:	52 6c       	stdsp	sp[0x98],r12
800081d4:	fa c8 f9 50 	sub	r8,sp,-1712
800081d8:	1a d8       	st.w	--sp,r8
800081da:	fa c8 fa b8 	sub	r8,sp,-1352
800081de:	1a d8       	st.w	--sp,r8
800081e0:	fa c8 fb b4 	sub	r8,sp,-1100
800081e4:	1a d8       	st.w	--sp,r8
800081e6:	fa c8 f9 40 	sub	r8,sp,-1728
800081ea:	fa c9 ff b4 	sub	r9,sp,-76
800081ee:	04 9a       	mov	r10,r2
800081f0:	0c 9b       	mov	r11,r6
800081f2:	08 9c       	mov	r12,r4
800081f4:	fe b0 f5 c2 	rcall	80006d78 <get_arg>
800081f8:	2f dd       	sub	sp,-12
800081fa:	f8 e8 00 00 	ld.d	r8,r12[0]
800081fe:	fa e9 00 00 	st.d	sp[0],r8
80008202:	c2 e8       	rjmp	8000825e <_vfprintf_r+0x11aa>
80008204:	ee ca ff ff 	sub	r10,r7,-1
80008208:	10 37       	cp.w	r7,r8
8000820a:	c0 b4       	brge	80008220 <_vfprintf_r+0x116c>
8000820c:	fa c8 f9 44 	sub	r8,sp,-1724
80008210:	14 97       	mov	r7,r10
80008212:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008216:	ec ea fd 88 	ld.d	r10,r6[-632]
8000821a:	fa eb 00 00 	st.d	sp[0],r10
8000821e:	c2 08       	rjmp	8000825e <_vfprintf_r+0x11aa>
80008220:	41 09       	lddsp	r9,sp[0x40]
80008222:	59 f8       	cp.w	r8,31
80008224:	e0 89 00 16 	brgt	80008250 <_vfprintf_r+0x119c>
80008228:	f2 e6 00 00 	ld.d	r6,r9[0]
8000822c:	f2 cb ff f8 	sub	r11,r9,-8
80008230:	fa e7 00 00 	st.d	sp[0],r6
80008234:	51 0b       	stdsp	sp[0x40],r11
80008236:	fa c6 f9 44 	sub	r6,sp,-1724
8000823a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000823e:	fa e6 00 00 	ld.d	r6,sp[0]
80008242:	f2 e7 fd 88 	st.d	r9[-632],r6
80008246:	2f f8       	sub	r8,-1
80008248:	14 97       	mov	r7,r10
8000824a:	fb 48 06 b4 	st.w	sp[1716],r8
8000824e:	c0 88       	rjmp	8000825e <_vfprintf_r+0x11aa>
80008250:	f2 e6 00 00 	ld.d	r6,r9[0]
80008254:	2f 89       	sub	r9,-8
80008256:	fa e7 00 00 	st.d	sp[0],r6
8000825a:	51 09       	stdsp	sp[0x40],r9
8000825c:	14 97       	mov	r7,r10
8000825e:	30 18       	mov	r8,1
80008260:	e0 8f 01 d0 	bral	80008600 <_vfprintf_r+0x154c>
80008264:	ed b5 00 04 	bld	r5,0x4
80008268:	c1 61       	brne	80008294 <_vfprintf_r+0x11e0>
8000826a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000826e:	40 3e       	lddsp	lr,sp[0xc]
80008270:	58 0e       	cp.w	lr,0
80008272:	c0 80       	breq	80008282 <_vfprintf_r+0x11ce>
80008274:	10 36       	cp.w	r6,r8
80008276:	c6 74       	brge	80008344 <_vfprintf_r+0x1290>
80008278:	fa cc f9 44 	sub	r12,sp,-1724
8000827c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008280:	c8 08       	rjmp	80008380 <_vfprintf_r+0x12cc>
80008282:	ee ca ff ff 	sub	r10,r7,-1
80008286:	10 37       	cp.w	r7,r8
80008288:	c7 f4       	brge	80008386 <_vfprintf_r+0x12d2>
8000828a:	fa cb f9 44 	sub	r11,sp,-1724
8000828e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008292:	c7 68       	rjmp	8000837e <_vfprintf_r+0x12ca>
80008294:	ed b5 00 06 	bld	r5,0x6
80008298:	c4 a1       	brne	8000832c <_vfprintf_r+0x1278>
8000829a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000829e:	40 3c       	lddsp	r12,sp[0xc]
800082a0:	58 0c       	cp.w	r12,0
800082a2:	c1 d0       	breq	800082dc <_vfprintf_r+0x1228>
800082a4:	10 36       	cp.w	r6,r8
800082a6:	c0 64       	brge	800082b2 <_vfprintf_r+0x11fe>
800082a8:	fa cb f9 44 	sub	r11,sp,-1724
800082ac:	f6 06 00 36 	add	r6,r11,r6<<0x3
800082b0:	c1 f8       	rjmp	800082ee <_vfprintf_r+0x123a>
800082b2:	fa c8 f9 50 	sub	r8,sp,-1712
800082b6:	1a d8       	st.w	--sp,r8
800082b8:	fa c8 fa b8 	sub	r8,sp,-1352
800082bc:	1a d8       	st.w	--sp,r8
800082be:	fa c8 fb b4 	sub	r8,sp,-1100
800082c2:	1a d8       	st.w	--sp,r8
800082c4:	fa c8 f9 40 	sub	r8,sp,-1728
800082c8:	fa c9 ff b4 	sub	r9,sp,-76
800082cc:	04 9a       	mov	r10,r2
800082ce:	0c 9b       	mov	r11,r6
800082d0:	08 9c       	mov	r12,r4
800082d2:	fe b0 f5 53 	rcall	80006d78 <get_arg>
800082d6:	2f dd       	sub	sp,-12
800082d8:	98 18       	ld.sh	r8,r12[0x2]
800082da:	c2 68       	rjmp	80008326 <_vfprintf_r+0x1272>
800082dc:	ee ca ff ff 	sub	r10,r7,-1
800082e0:	10 37       	cp.w	r7,r8
800082e2:	c0 94       	brge	800082f4 <_vfprintf_r+0x1240>
800082e4:	fa c9 f9 44 	sub	r9,sp,-1724
800082e8:	14 97       	mov	r7,r10
800082ea:	f2 06 00 36 	add	r6,r9,r6<<0x3
800082ee:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800082f2:	c1 a8       	rjmp	80008326 <_vfprintf_r+0x1272>
800082f4:	41 09       	lddsp	r9,sp[0x40]
800082f6:	59 f8       	cp.w	r8,31
800082f8:	e0 89 00 13 	brgt	8000831e <_vfprintf_r+0x126a>
800082fc:	f2 cb ff fc 	sub	r11,r9,-4
80008300:	51 0b       	stdsp	sp[0x40],r11
80008302:	72 09       	ld.w	r9,r9[0x0]
80008304:	fa c6 f9 44 	sub	r6,sp,-1724
80008308:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000830c:	2f f8       	sub	r8,-1
8000830e:	f7 49 fd 88 	st.w	r11[-632],r9
80008312:	fb 48 06 b4 	st.w	sp[1716],r8
80008316:	14 97       	mov	r7,r10
80008318:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000831c:	c0 58       	rjmp	80008326 <_vfprintf_r+0x1272>
8000831e:	92 18       	ld.sh	r8,r9[0x2]
80008320:	14 97       	mov	r7,r10
80008322:	2f c9       	sub	r9,-4
80008324:	51 09       	stdsp	sp[0x40],r9
80008326:	5c 78       	castu.h	r8
80008328:	50 18       	stdsp	sp[0x4],r8
8000832a:	c4 68       	rjmp	800083b6 <_vfprintf_r+0x1302>
8000832c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008330:	40 3c       	lddsp	r12,sp[0xc]
80008332:	58 0c       	cp.w	r12,0
80008334:	c1 d0       	breq	8000836e <_vfprintf_r+0x12ba>
80008336:	10 36       	cp.w	r6,r8
80008338:	c0 64       	brge	80008344 <_vfprintf_r+0x1290>
8000833a:	fa cb f9 44 	sub	r11,sp,-1724
8000833e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008342:	c1 f8       	rjmp	80008380 <_vfprintf_r+0x12cc>
80008344:	fa c8 f9 50 	sub	r8,sp,-1712
80008348:	1a d8       	st.w	--sp,r8
8000834a:	fa c8 fa b8 	sub	r8,sp,-1352
8000834e:	0c 9b       	mov	r11,r6
80008350:	1a d8       	st.w	--sp,r8
80008352:	fa c8 fb b4 	sub	r8,sp,-1100
80008356:	04 9a       	mov	r10,r2
80008358:	1a d8       	st.w	--sp,r8
8000835a:	08 9c       	mov	r12,r4
8000835c:	fa c8 f9 40 	sub	r8,sp,-1728
80008360:	fa c9 ff b4 	sub	r9,sp,-76
80008364:	fe b0 f5 0a 	rcall	80006d78 <get_arg>
80008368:	2f dd       	sub	sp,-12
8000836a:	78 0b       	ld.w	r11,r12[0x0]
8000836c:	c2 48       	rjmp	800083b4 <_vfprintf_r+0x1300>
8000836e:	ee ca ff ff 	sub	r10,r7,-1
80008372:	10 37       	cp.w	r7,r8
80008374:	c0 94       	brge	80008386 <_vfprintf_r+0x12d2>
80008376:	fa c9 f9 44 	sub	r9,sp,-1724
8000837a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000837e:	14 97       	mov	r7,r10
80008380:	ec fb fd 88 	ld.w	r11,r6[-632]
80008384:	c1 88       	rjmp	800083b4 <_vfprintf_r+0x1300>
80008386:	41 09       	lddsp	r9,sp[0x40]
80008388:	59 f8       	cp.w	r8,31
8000838a:	e0 89 00 11 	brgt	800083ac <_vfprintf_r+0x12f8>
8000838e:	f2 cb ff fc 	sub	r11,r9,-4
80008392:	51 0b       	stdsp	sp[0x40],r11
80008394:	fa c6 f9 44 	sub	r6,sp,-1724
80008398:	72 0b       	ld.w	r11,r9[0x0]
8000839a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000839e:	f3 4b fd 88 	st.w	r9[-632],r11
800083a2:	2f f8       	sub	r8,-1
800083a4:	14 97       	mov	r7,r10
800083a6:	fb 48 06 b4 	st.w	sp[1716],r8
800083aa:	c0 58       	rjmp	800083b4 <_vfprintf_r+0x1300>
800083ac:	72 0b       	ld.w	r11,r9[0x0]
800083ae:	14 97       	mov	r7,r10
800083b0:	2f c9       	sub	r9,-4
800083b2:	51 09       	stdsp	sp[0x40],r9
800083b4:	50 1b       	stdsp	sp[0x4],r11
800083b6:	30 0e       	mov	lr,0
800083b8:	30 18       	mov	r8,1
800083ba:	50 0e       	stdsp	sp[0x0],lr
800083bc:	c2 29       	rjmp	80008600 <_vfprintf_r+0x154c>
800083be:	50 a7       	stdsp	sp[0x28],r7
800083c0:	50 80       	stdsp	sp[0x20],r0
800083c2:	0c 97       	mov	r7,r6
800083c4:	04 94       	mov	r4,r2
800083c6:	06 96       	mov	r6,r3
800083c8:	02 92       	mov	r2,r1
800083ca:	4d 3c       	lddpc	r12,80008514 <_vfprintf_r+0x1460>
800083cc:	40 93       	lddsp	r3,sp[0x24]
800083ce:	10 90       	mov	r0,r8
800083d0:	40 41       	lddsp	r1,sp[0x10]
800083d2:	50 dc       	stdsp	sp[0x34],r12
800083d4:	ed b5 00 05 	bld	r5,0x5
800083d8:	c5 51       	brne	80008482 <_vfprintf_r+0x13ce>
800083da:	fa f8 06 b4 	ld.w	r8,sp[1716]
800083de:	40 3b       	lddsp	r11,sp[0xc]
800083e0:	58 0b       	cp.w	r11,0
800083e2:	c2 20       	breq	80008426 <_vfprintf_r+0x1372>
800083e4:	10 36       	cp.w	r6,r8
800083e6:	c0 a4       	brge	800083fa <_vfprintf_r+0x1346>
800083e8:	fa ca f9 44 	sub	r10,sp,-1724
800083ec:	f4 06 00 36 	add	r6,r10,r6<<0x3
800083f0:	ec e8 fd 88 	ld.d	r8,r6[-632]
800083f4:	fa e9 00 00 	st.d	sp[0],r8
800083f8:	cf 38       	rjmp	800085de <_vfprintf_r+0x152a>
800083fa:	fa c8 f9 50 	sub	r8,sp,-1712
800083fe:	1a d8       	st.w	--sp,r8
80008400:	fa c8 fa b8 	sub	r8,sp,-1352
80008404:	04 9a       	mov	r10,r2
80008406:	1a d8       	st.w	--sp,r8
80008408:	0c 9b       	mov	r11,r6
8000840a:	fa c8 fb b4 	sub	r8,sp,-1100
8000840e:	08 9c       	mov	r12,r4
80008410:	1a d8       	st.w	--sp,r8
80008412:	fa c8 f9 40 	sub	r8,sp,-1728
80008416:	fa c9 ff b4 	sub	r9,sp,-76
8000841a:	fe b0 f4 af 	rcall	80006d78 <get_arg>
8000841e:	2f dd       	sub	sp,-12
80008420:	f8 ea 00 00 	ld.d	r10,r12[0]
80008424:	c0 c8       	rjmp	8000843c <_vfprintf_r+0x1388>
80008426:	ee ca ff ff 	sub	r10,r7,-1
8000842a:	10 37       	cp.w	r7,r8
8000842c:	c0 b4       	brge	80008442 <_vfprintf_r+0x138e>
8000842e:	fa c9 f9 44 	sub	r9,sp,-1724
80008432:	14 97       	mov	r7,r10
80008434:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008438:	ec ea fd 88 	ld.d	r10,r6[-632]
8000843c:	fa eb 00 00 	st.d	sp[0],r10
80008440:	cc f8       	rjmp	800085de <_vfprintf_r+0x152a>
80008442:	41 09       	lddsp	r9,sp[0x40]
80008444:	59 f8       	cp.w	r8,31
80008446:	e0 89 00 16 	brgt	80008472 <_vfprintf_r+0x13be>
8000844a:	f2 e6 00 00 	ld.d	r6,r9[0]
8000844e:	f2 cb ff f8 	sub	r11,r9,-8
80008452:	fa e7 00 00 	st.d	sp[0],r6
80008456:	51 0b       	stdsp	sp[0x40],r11
80008458:	fa c6 f9 44 	sub	r6,sp,-1724
8000845c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008460:	fa e6 00 00 	ld.d	r6,sp[0]
80008464:	f2 e7 fd 88 	st.d	r9[-632],r6
80008468:	2f f8       	sub	r8,-1
8000846a:	14 97       	mov	r7,r10
8000846c:	fb 48 06 b4 	st.w	sp[1716],r8
80008470:	cb 78       	rjmp	800085de <_vfprintf_r+0x152a>
80008472:	f2 e6 00 00 	ld.d	r6,r9[0]
80008476:	2f 89       	sub	r9,-8
80008478:	fa e7 00 00 	st.d	sp[0],r6
8000847c:	51 09       	stdsp	sp[0x40],r9
8000847e:	14 97       	mov	r7,r10
80008480:	ca f8       	rjmp	800085de <_vfprintf_r+0x152a>
80008482:	ed b5 00 04 	bld	r5,0x4
80008486:	c1 71       	brne	800084b4 <_vfprintf_r+0x1400>
80008488:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000848c:	40 3e       	lddsp	lr,sp[0xc]
8000848e:	58 0e       	cp.w	lr,0
80008490:	c0 80       	breq	800084a0 <_vfprintf_r+0x13ec>
80008492:	10 36       	cp.w	r6,r8
80008494:	c6 a4       	brge	80008568 <_vfprintf_r+0x14b4>
80008496:	fa cc f9 44 	sub	r12,sp,-1724
8000849a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000849e:	c8 38       	rjmp	800085a4 <_vfprintf_r+0x14f0>
800084a0:	ee ca ff ff 	sub	r10,r7,-1
800084a4:	10 37       	cp.w	r7,r8
800084a6:	e0 84 00 82 	brge	800085aa <_vfprintf_r+0x14f6>
800084aa:	fa cb f9 44 	sub	r11,sp,-1724
800084ae:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084b2:	c7 88       	rjmp	800085a2 <_vfprintf_r+0x14ee>
800084b4:	ed b5 00 06 	bld	r5,0x6
800084b8:	c4 c1       	brne	80008550 <_vfprintf_r+0x149c>
800084ba:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084be:	40 3c       	lddsp	r12,sp[0xc]
800084c0:	58 0c       	cp.w	r12,0
800084c2:	c1 d0       	breq	800084fc <_vfprintf_r+0x1448>
800084c4:	10 36       	cp.w	r6,r8
800084c6:	c0 64       	brge	800084d2 <_vfprintf_r+0x141e>
800084c8:	fa cb f9 44 	sub	r11,sp,-1724
800084cc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084d0:	c1 f8       	rjmp	8000850e <_vfprintf_r+0x145a>
800084d2:	fa c8 f9 50 	sub	r8,sp,-1712
800084d6:	1a d8       	st.w	--sp,r8
800084d8:	fa c8 fa b8 	sub	r8,sp,-1352
800084dc:	1a d8       	st.w	--sp,r8
800084de:	fa c8 fb b4 	sub	r8,sp,-1100
800084e2:	1a d8       	st.w	--sp,r8
800084e4:	fa c8 f9 40 	sub	r8,sp,-1728
800084e8:	fa c9 ff b4 	sub	r9,sp,-76
800084ec:	04 9a       	mov	r10,r2
800084ee:	0c 9b       	mov	r11,r6
800084f0:	08 9c       	mov	r12,r4
800084f2:	fe b0 f4 43 	rcall	80006d78 <get_arg>
800084f6:	2f dd       	sub	sp,-12
800084f8:	98 18       	ld.sh	r8,r12[0x2]
800084fa:	c2 88       	rjmp	8000854a <_vfprintf_r+0x1496>
800084fc:	ee ca ff ff 	sub	r10,r7,-1
80008500:	10 37       	cp.w	r7,r8
80008502:	c0 b4       	brge	80008518 <_vfprintf_r+0x1464>
80008504:	fa c9 f9 44 	sub	r9,sp,-1724
80008508:	14 97       	mov	r7,r10
8000850a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000850e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008512:	c1 c8       	rjmp	8000854a <_vfprintf_r+0x1496>
80008514:	80 01       	ld.sh	r1,r0[0x0]
80008516:	52 6c       	stdsp	sp[0x98],r12
80008518:	41 09       	lddsp	r9,sp[0x40]
8000851a:	59 f8       	cp.w	r8,31
8000851c:	e0 89 00 13 	brgt	80008542 <_vfprintf_r+0x148e>
80008520:	f2 cb ff fc 	sub	r11,r9,-4
80008524:	51 0b       	stdsp	sp[0x40],r11
80008526:	72 09       	ld.w	r9,r9[0x0]
80008528:	fa c6 f9 44 	sub	r6,sp,-1724
8000852c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008530:	2f f8       	sub	r8,-1
80008532:	f7 49 fd 88 	st.w	r11[-632],r9
80008536:	fb 48 06 b4 	st.w	sp[1716],r8
8000853a:	14 97       	mov	r7,r10
8000853c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008540:	c0 58       	rjmp	8000854a <_vfprintf_r+0x1496>
80008542:	92 18       	ld.sh	r8,r9[0x2]
80008544:	14 97       	mov	r7,r10
80008546:	2f c9       	sub	r9,-4
80008548:	51 09       	stdsp	sp[0x40],r9
8000854a:	5c 78       	castu.h	r8
8000854c:	50 18       	stdsp	sp[0x4],r8
8000854e:	c4 68       	rjmp	800085da <_vfprintf_r+0x1526>
80008550:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008554:	40 3c       	lddsp	r12,sp[0xc]
80008556:	58 0c       	cp.w	r12,0
80008558:	c1 d0       	breq	80008592 <_vfprintf_r+0x14de>
8000855a:	10 36       	cp.w	r6,r8
8000855c:	c0 64       	brge	80008568 <_vfprintf_r+0x14b4>
8000855e:	fa cb f9 44 	sub	r11,sp,-1724
80008562:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008566:	c1 f8       	rjmp	800085a4 <_vfprintf_r+0x14f0>
80008568:	fa c8 f9 50 	sub	r8,sp,-1712
8000856c:	1a d8       	st.w	--sp,r8
8000856e:	fa c8 fa b8 	sub	r8,sp,-1352
80008572:	0c 9b       	mov	r11,r6
80008574:	1a d8       	st.w	--sp,r8
80008576:	fa c8 fb b4 	sub	r8,sp,-1100
8000857a:	04 9a       	mov	r10,r2
8000857c:	1a d8       	st.w	--sp,r8
8000857e:	08 9c       	mov	r12,r4
80008580:	fa c8 f9 40 	sub	r8,sp,-1728
80008584:	fa c9 ff b4 	sub	r9,sp,-76
80008588:	fe b0 f3 f8 	rcall	80006d78 <get_arg>
8000858c:	2f dd       	sub	sp,-12
8000858e:	78 0b       	ld.w	r11,r12[0x0]
80008590:	c2 48       	rjmp	800085d8 <_vfprintf_r+0x1524>
80008592:	ee ca ff ff 	sub	r10,r7,-1
80008596:	10 37       	cp.w	r7,r8
80008598:	c0 94       	brge	800085aa <_vfprintf_r+0x14f6>
8000859a:	fa c9 f9 44 	sub	r9,sp,-1724
8000859e:	f2 06 00 36 	add	r6,r9,r6<<0x3
800085a2:	14 97       	mov	r7,r10
800085a4:	ec fb fd 88 	ld.w	r11,r6[-632]
800085a8:	c1 88       	rjmp	800085d8 <_vfprintf_r+0x1524>
800085aa:	41 09       	lddsp	r9,sp[0x40]
800085ac:	59 f8       	cp.w	r8,31
800085ae:	e0 89 00 11 	brgt	800085d0 <_vfprintf_r+0x151c>
800085b2:	f2 cb ff fc 	sub	r11,r9,-4
800085b6:	51 0b       	stdsp	sp[0x40],r11
800085b8:	fa c6 f9 44 	sub	r6,sp,-1724
800085bc:	72 0b       	ld.w	r11,r9[0x0]
800085be:	ec 08 00 39 	add	r9,r6,r8<<0x3
800085c2:	f3 4b fd 88 	st.w	r9[-632],r11
800085c6:	2f f8       	sub	r8,-1
800085c8:	14 97       	mov	r7,r10
800085ca:	fb 48 06 b4 	st.w	sp[1716],r8
800085ce:	c0 58       	rjmp	800085d8 <_vfprintf_r+0x1524>
800085d0:	72 0b       	ld.w	r11,r9[0x0]
800085d2:	14 97       	mov	r7,r10
800085d4:	2f c9       	sub	r9,-4
800085d6:	51 09       	stdsp	sp[0x40],r9
800085d8:	50 1b       	stdsp	sp[0x4],r11
800085da:	30 0e       	mov	lr,0
800085dc:	50 0e       	stdsp	sp[0x0],lr
800085de:	40 08       	lddsp	r8,sp[0x0]
800085e0:	40 1c       	lddsp	r12,sp[0x4]
800085e2:	18 48       	or	r8,r12
800085e4:	5f 19       	srne	r9
800085e6:	0a 98       	mov	r8,r5
800085e8:	eb e9 00 09 	and	r9,r5,r9
800085ec:	a1 b8       	sbr	r8,0x1
800085ee:	58 09       	cp.w	r9,0
800085f0:	c0 70       	breq	800085fe <_vfprintf_r+0x154a>
800085f2:	10 95       	mov	r5,r8
800085f4:	fb 60 06 b9 	st.b	sp[1721],r0
800085f8:	33 08       	mov	r8,48
800085fa:	fb 68 06 b8 	st.b	sp[1720],r8
800085fe:	30 28       	mov	r8,2
80008600:	30 09       	mov	r9,0
80008602:	fb 69 06 bb 	st.b	sp[1723],r9
80008606:	0a 99       	mov	r9,r5
80008608:	a7 d9       	cbr	r9,0x7
8000860a:	40 2b       	lddsp	r11,sp[0x8]
8000860c:	40 16       	lddsp	r6,sp[0x4]
8000860e:	58 0b       	cp.w	r11,0
80008610:	5f 1a       	srne	r10
80008612:	f2 05 17 40 	movge	r5,r9
80008616:	fa c2 f9 78 	sub	r2,sp,-1672
8000861a:	40 09       	lddsp	r9,sp[0x0]
8000861c:	0c 49       	or	r9,r6
8000861e:	5f 19       	srne	r9
80008620:	f5 e9 10 09 	or	r9,r10,r9
80008624:	c5 c0       	breq	800086dc <_vfprintf_r+0x1628>
80008626:	30 19       	mov	r9,1
80008628:	f2 08 18 00 	cp.b	r8,r9
8000862c:	c0 60       	breq	80008638 <_vfprintf_r+0x1584>
8000862e:	30 29       	mov	r9,2
80008630:	f2 08 18 00 	cp.b	r8,r9
80008634:	c0 41       	brne	8000863c <_vfprintf_r+0x1588>
80008636:	c3 c8       	rjmp	800086ae <_vfprintf_r+0x15fa>
80008638:	04 96       	mov	r6,r2
8000863a:	c3 08       	rjmp	8000869a <_vfprintf_r+0x15e6>
8000863c:	04 96       	mov	r6,r2
8000863e:	fa e8 00 00 	ld.d	r8,sp[0]
80008642:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80008646:	2d 0a       	sub	r10,-48
80008648:	0c fa       	st.b	--r6,r10
8000864a:	f0 0b 16 03 	lsr	r11,r8,0x3
8000864e:	f2 0c 16 03 	lsr	r12,r9,0x3
80008652:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80008656:	18 99       	mov	r9,r12
80008658:	16 98       	mov	r8,r11
8000865a:	58 08       	cp.w	r8,0
8000865c:	5c 29       	cpc	r9
8000865e:	cf 21       	brne	80008642 <_vfprintf_r+0x158e>
80008660:	fa e9 00 00 	st.d	sp[0],r8
80008664:	ed b5 00 00 	bld	r5,0x0
80008668:	c4 51       	brne	800086f2 <_vfprintf_r+0x163e>
8000866a:	33 09       	mov	r9,48
8000866c:	f2 0a 18 00 	cp.b	r10,r9
80008670:	c4 10       	breq	800086f2 <_vfprintf_r+0x163e>
80008672:	0c f9       	st.b	--r6,r9
80008674:	c3 f8       	rjmp	800086f2 <_vfprintf_r+0x163e>
80008676:	fa ea 00 00 	ld.d	r10,sp[0]
8000867a:	30 a8       	mov	r8,10
8000867c:	30 09       	mov	r9,0
8000867e:	e0 a0 1a 1b 	rcall	8000bab4 <__avr32_umod64>
80008682:	30 a8       	mov	r8,10
80008684:	2d 0a       	sub	r10,-48
80008686:	30 09       	mov	r9,0
80008688:	ac 8a       	st.b	r6[0x0],r10
8000868a:	fa ea 00 00 	ld.d	r10,sp[0]
8000868e:	e0 a0 18 e1 	rcall	8000b850 <__avr32_udiv64>
80008692:	16 99       	mov	r9,r11
80008694:	14 98       	mov	r8,r10
80008696:	fa e9 00 00 	st.d	sp[0],r8
8000869a:	20 16       	sub	r6,1
8000869c:	fa ea 00 00 	ld.d	r10,sp[0]
800086a0:	58 9a       	cp.w	r10,9
800086a2:	5c 2b       	cpc	r11
800086a4:	fe 9b ff e9 	brhi	80008676 <_vfprintf_r+0x15c2>
800086a8:	1b f8       	ld.ub	r8,sp[0x7]
800086aa:	2d 08       	sub	r8,-48
800086ac:	c2 08       	rjmp	800086ec <_vfprintf_r+0x1638>
800086ae:	04 96       	mov	r6,r2
800086b0:	fa e8 00 00 	ld.d	r8,sp[0]
800086b4:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800086b8:	40 de       	lddsp	lr,sp[0x34]
800086ba:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800086be:	0c fa       	st.b	--r6,r10
800086c0:	f2 0b 16 04 	lsr	r11,r9,0x4
800086c4:	f0 0a 16 04 	lsr	r10,r8,0x4
800086c8:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800086cc:	16 99       	mov	r9,r11
800086ce:	14 98       	mov	r8,r10
800086d0:	58 08       	cp.w	r8,0
800086d2:	5c 29       	cpc	r9
800086d4:	cf 01       	brne	800086b4 <_vfprintf_r+0x1600>
800086d6:	fa e9 00 00 	st.d	sp[0],r8
800086da:	c0 c8       	rjmp	800086f2 <_vfprintf_r+0x163e>
800086dc:	58 08       	cp.w	r8,0
800086de:	c0 91       	brne	800086f0 <_vfprintf_r+0x163c>
800086e0:	ed b5 00 00 	bld	r5,0x0
800086e4:	c0 61       	brne	800086f0 <_vfprintf_r+0x163c>
800086e6:	fa c6 f9 79 	sub	r6,sp,-1671
800086ea:	33 08       	mov	r8,48
800086ec:	ac 88       	st.b	r6[0x0],r8
800086ee:	c0 28       	rjmp	800086f2 <_vfprintf_r+0x163e>
800086f0:	04 96       	mov	r6,r2
800086f2:	0c 12       	sub	r2,r6
800086f4:	c1 c8       	rjmp	8000872c <_vfprintf_r+0x1678>
800086f6:	50 a7       	stdsp	sp[0x28],r7
800086f8:	50 80       	stdsp	sp[0x20],r0
800086fa:	40 93       	lddsp	r3,sp[0x24]
800086fc:	0c 97       	mov	r7,r6
800086fe:	10 90       	mov	r0,r8
80008700:	04 94       	mov	r4,r2
80008702:	40 41       	lddsp	r1,sp[0x10]
80008704:	58 08       	cp.w	r8,0
80008706:	e0 80 04 51 	breq	80008fa8 <_vfprintf_r+0x1ef4>
8000870a:	fb 68 06 60 	st.b	sp[1632],r8
8000870e:	30 0c       	mov	r12,0
80008710:	30 08       	mov	r8,0
80008712:	30 12       	mov	r2,1
80008714:	fb 68 06 bb 	st.b	sp[1723],r8
80008718:	50 2c       	stdsp	sp[0x8],r12
8000871a:	fa c6 f9 a0 	sub	r6,sp,-1632
8000871e:	c0 78       	rjmp	8000872c <_vfprintf_r+0x1678>
80008720:	30 0b       	mov	r11,0
80008722:	50 2b       	stdsp	sp[0x8],r11
80008724:	c0 48       	rjmp	8000872c <_vfprintf_r+0x1678>
80008726:	40 22       	lddsp	r2,sp[0x8]
80008728:	30 0a       	mov	r10,0
8000872a:	50 2a       	stdsp	sp[0x8],r10
8000872c:	40 29       	lddsp	r9,sp[0x8]
8000872e:	e4 09 0c 49 	max	r9,r2,r9
80008732:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008736:	50 39       	stdsp	sp[0xc],r9
80008738:	0a 9e       	mov	lr,r5
8000873a:	30 09       	mov	r9,0
8000873c:	e2 1e 00 02 	andl	lr,0x2,COH
80008740:	f2 08 18 00 	cp.b	r8,r9
80008744:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80008748:	f7 b8 01 ff 	subne	r8,-1
8000874c:	fb f8 1a 03 	st.wne	sp[0xc],r8
80008750:	0a 9b       	mov	r11,r5
80008752:	58 0e       	cp.w	lr,0
80008754:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80008758:	f7 bc 01 fe 	subne	r12,-2
8000875c:	fb fc 1a 03 	st.wne	sp[0xc],r12
80008760:	e2 1b 00 84 	andl	r11,0x84,COH
80008764:	50 fe       	stdsp	sp[0x3c],lr
80008766:	50 9b       	stdsp	sp[0x24],r11
80008768:	c4 51       	brne	800087f2 <_vfprintf_r+0x173e>
8000876a:	40 8a       	lddsp	r10,sp[0x20]
8000876c:	40 39       	lddsp	r9,sp[0xc]
8000876e:	12 1a       	sub	r10,r9
80008770:	50 4a       	stdsp	sp[0x10],r10
80008772:	58 0a       	cp.w	r10,0
80008774:	e0 89 00 1f 	brgt	800087b2 <_vfprintf_r+0x16fe>
80008778:	c3 d8       	rjmp	800087f2 <_vfprintf_r+0x173e>
8000877a:	2f 09       	sub	r9,-16
8000877c:	2f f8       	sub	r8,-1
8000877e:	4c ee       	lddpc	lr,800088b4 <_vfprintf_r+0x1800>
80008780:	31 0c       	mov	r12,16
80008782:	fb 49 06 90 	st.w	sp[1680],r9
80008786:	87 0e       	st.w	r3[0x0],lr
80008788:	87 1c       	st.w	r3[0x4],r12
8000878a:	fb 48 06 8c 	st.w	sp[1676],r8
8000878e:	58 78       	cp.w	r8,7
80008790:	e0 89 00 04 	brgt	80008798 <_vfprintf_r+0x16e4>
80008794:	2f 83       	sub	r3,-8
80008796:	c0 b8       	rjmp	800087ac <_vfprintf_r+0x16f8>
80008798:	fa ca f9 78 	sub	r10,sp,-1672
8000879c:	02 9b       	mov	r11,r1
8000879e:	08 9c       	mov	r12,r4
800087a0:	fe b0 f4 7c 	rcall	80007098 <__sprint_r>
800087a4:	e0 81 04 13 	brne	80008fca <_vfprintf_r+0x1f16>
800087a8:	fa c3 f9 e0 	sub	r3,sp,-1568
800087ac:	40 4b       	lddsp	r11,sp[0x10]
800087ae:	21 0b       	sub	r11,16
800087b0:	50 4b       	stdsp	sp[0x10],r11
800087b2:	fa f9 06 90 	ld.w	r9,sp[1680]
800087b6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800087ba:	4b fa       	lddpc	r10,800088b4 <_vfprintf_r+0x1800>
800087bc:	40 4e       	lddsp	lr,sp[0x10]
800087be:	59 0e       	cp.w	lr,16
800087c0:	fe 99 ff dd 	brgt	8000877a <_vfprintf_r+0x16c6>
800087c4:	1c 09       	add	r9,lr
800087c6:	2f f8       	sub	r8,-1
800087c8:	87 0a       	st.w	r3[0x0],r10
800087ca:	fb 49 06 90 	st.w	sp[1680],r9
800087ce:	87 1e       	st.w	r3[0x4],lr
800087d0:	fb 48 06 8c 	st.w	sp[1676],r8
800087d4:	58 78       	cp.w	r8,7
800087d6:	e0 89 00 04 	brgt	800087de <_vfprintf_r+0x172a>
800087da:	2f 83       	sub	r3,-8
800087dc:	c0 b8       	rjmp	800087f2 <_vfprintf_r+0x173e>
800087de:	fa ca f9 78 	sub	r10,sp,-1672
800087e2:	02 9b       	mov	r11,r1
800087e4:	08 9c       	mov	r12,r4
800087e6:	fe b0 f4 59 	rcall	80007098 <__sprint_r>
800087ea:	e0 81 03 f0 	brne	80008fca <_vfprintf_r+0x1f16>
800087ee:	fa c3 f9 e0 	sub	r3,sp,-1568
800087f2:	30 09       	mov	r9,0
800087f4:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800087f8:	f2 08 18 00 	cp.b	r8,r9
800087fc:	c1 f0       	breq	8000883a <_vfprintf_r+0x1786>
800087fe:	fa f8 06 90 	ld.w	r8,sp[1680]
80008802:	fa c9 f9 45 	sub	r9,sp,-1723
80008806:	2f f8       	sub	r8,-1
80008808:	87 09       	st.w	r3[0x0],r9
8000880a:	fb 48 06 90 	st.w	sp[1680],r8
8000880e:	30 19       	mov	r9,1
80008810:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008814:	87 19       	st.w	r3[0x4],r9
80008816:	2f f8       	sub	r8,-1
80008818:	fb 48 06 8c 	st.w	sp[1676],r8
8000881c:	58 78       	cp.w	r8,7
8000881e:	e0 89 00 04 	brgt	80008826 <_vfprintf_r+0x1772>
80008822:	2f 83       	sub	r3,-8
80008824:	c0 b8       	rjmp	8000883a <_vfprintf_r+0x1786>
80008826:	fa ca f9 78 	sub	r10,sp,-1672
8000882a:	02 9b       	mov	r11,r1
8000882c:	08 9c       	mov	r12,r4
8000882e:	fe b0 f4 35 	rcall	80007098 <__sprint_r>
80008832:	e0 81 03 cc 	brne	80008fca <_vfprintf_r+0x1f16>
80008836:	fa c3 f9 e0 	sub	r3,sp,-1568
8000883a:	40 fc       	lddsp	r12,sp[0x3c]
8000883c:	58 0c       	cp.w	r12,0
8000883e:	c1 f0       	breq	8000887c <_vfprintf_r+0x17c8>
80008840:	fa f8 06 90 	ld.w	r8,sp[1680]
80008844:	fa c9 f9 48 	sub	r9,sp,-1720
80008848:	2f e8       	sub	r8,-2
8000884a:	87 09       	st.w	r3[0x0],r9
8000884c:	fb 48 06 90 	st.w	sp[1680],r8
80008850:	30 29       	mov	r9,2
80008852:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008856:	87 19       	st.w	r3[0x4],r9
80008858:	2f f8       	sub	r8,-1
8000885a:	fb 48 06 8c 	st.w	sp[1676],r8
8000885e:	58 78       	cp.w	r8,7
80008860:	e0 89 00 04 	brgt	80008868 <_vfprintf_r+0x17b4>
80008864:	2f 83       	sub	r3,-8
80008866:	c0 b8       	rjmp	8000887c <_vfprintf_r+0x17c8>
80008868:	fa ca f9 78 	sub	r10,sp,-1672
8000886c:	02 9b       	mov	r11,r1
8000886e:	08 9c       	mov	r12,r4
80008870:	fe b0 f4 14 	rcall	80007098 <__sprint_r>
80008874:	e0 81 03 ab 	brne	80008fca <_vfprintf_r+0x1f16>
80008878:	fa c3 f9 e0 	sub	r3,sp,-1568
8000887c:	40 9b       	lddsp	r11,sp[0x24]
8000887e:	e0 4b 00 80 	cp.w	r11,128
80008882:	c4 a1       	brne	80008916 <_vfprintf_r+0x1862>
80008884:	40 8a       	lddsp	r10,sp[0x20]
80008886:	40 39       	lddsp	r9,sp[0xc]
80008888:	12 1a       	sub	r10,r9
8000888a:	50 4a       	stdsp	sp[0x10],r10
8000888c:	58 0a       	cp.w	r10,0
8000888e:	e0 89 00 24 	brgt	800088d6 <_vfprintf_r+0x1822>
80008892:	c4 28       	rjmp	80008916 <_vfprintf_r+0x1862>
80008894:	2f 09       	sub	r9,-16
80008896:	2f f8       	sub	r8,-1
80008898:	48 8e       	lddpc	lr,800088b8 <_vfprintf_r+0x1804>
8000889a:	31 0c       	mov	r12,16
8000889c:	fb 49 06 90 	st.w	sp[1680],r9
800088a0:	87 0e       	st.w	r3[0x0],lr
800088a2:	87 1c       	st.w	r3[0x4],r12
800088a4:	fb 48 06 8c 	st.w	sp[1676],r8
800088a8:	58 78       	cp.w	r8,7
800088aa:	e0 89 00 09 	brgt	800088bc <_vfprintf_r+0x1808>
800088ae:	2f 83       	sub	r3,-8
800088b0:	c1 08       	rjmp	800088d0 <_vfprintf_r+0x181c>
800088b2:	d7 03       	nop
800088b4:	80 01       	ld.sh	r1,r0[0x0]
800088b6:	52 84       	stdsp	sp[0xa0],r4
800088b8:	80 01       	ld.sh	r1,r0[0x0]
800088ba:	52 94       	stdsp	sp[0xa4],r4
800088bc:	fa ca f9 78 	sub	r10,sp,-1672
800088c0:	02 9b       	mov	r11,r1
800088c2:	08 9c       	mov	r12,r4
800088c4:	fe b0 f3 ea 	rcall	80007098 <__sprint_r>
800088c8:	e0 81 03 81 	brne	80008fca <_vfprintf_r+0x1f16>
800088cc:	fa c3 f9 e0 	sub	r3,sp,-1568
800088d0:	40 4b       	lddsp	r11,sp[0x10]
800088d2:	21 0b       	sub	r11,16
800088d4:	50 4b       	stdsp	sp[0x10],r11
800088d6:	fa f9 06 90 	ld.w	r9,sp[1680]
800088da:	fa f8 06 8c 	ld.w	r8,sp[1676]
800088de:	4c 6a       	lddpc	r10,800089f4 <_vfprintf_r+0x1940>
800088e0:	40 4e       	lddsp	lr,sp[0x10]
800088e2:	59 0e       	cp.w	lr,16
800088e4:	fe 99 ff d8 	brgt	80008894 <_vfprintf_r+0x17e0>
800088e8:	1c 09       	add	r9,lr
800088ea:	2f f8       	sub	r8,-1
800088ec:	87 0a       	st.w	r3[0x0],r10
800088ee:	fb 49 06 90 	st.w	sp[1680],r9
800088f2:	87 1e       	st.w	r3[0x4],lr
800088f4:	fb 48 06 8c 	st.w	sp[1676],r8
800088f8:	58 78       	cp.w	r8,7
800088fa:	e0 89 00 04 	brgt	80008902 <_vfprintf_r+0x184e>
800088fe:	2f 83       	sub	r3,-8
80008900:	c0 b8       	rjmp	80008916 <_vfprintf_r+0x1862>
80008902:	fa ca f9 78 	sub	r10,sp,-1672
80008906:	02 9b       	mov	r11,r1
80008908:	08 9c       	mov	r12,r4
8000890a:	fe b0 f3 c7 	rcall	80007098 <__sprint_r>
8000890e:	e0 81 03 5e 	brne	80008fca <_vfprintf_r+0x1f16>
80008912:	fa c3 f9 e0 	sub	r3,sp,-1568
80008916:	40 2c       	lddsp	r12,sp[0x8]
80008918:	04 1c       	sub	r12,r2
8000891a:	50 2c       	stdsp	sp[0x8],r12
8000891c:	58 0c       	cp.w	r12,0
8000891e:	e0 89 00 1f 	brgt	8000895c <_vfprintf_r+0x18a8>
80008922:	c3 d8       	rjmp	8000899c <_vfprintf_r+0x18e8>
80008924:	2f 09       	sub	r9,-16
80008926:	2f f8       	sub	r8,-1
80008928:	4b 3b       	lddpc	r11,800089f4 <_vfprintf_r+0x1940>
8000892a:	31 0a       	mov	r10,16
8000892c:	fb 49 06 90 	st.w	sp[1680],r9
80008930:	87 0b       	st.w	r3[0x0],r11
80008932:	87 1a       	st.w	r3[0x4],r10
80008934:	fb 48 06 8c 	st.w	sp[1676],r8
80008938:	58 78       	cp.w	r8,7
8000893a:	e0 89 00 04 	brgt	80008942 <_vfprintf_r+0x188e>
8000893e:	2f 83       	sub	r3,-8
80008940:	c0 b8       	rjmp	80008956 <_vfprintf_r+0x18a2>
80008942:	fa ca f9 78 	sub	r10,sp,-1672
80008946:	02 9b       	mov	r11,r1
80008948:	08 9c       	mov	r12,r4
8000894a:	fe b0 f3 a7 	rcall	80007098 <__sprint_r>
8000894e:	e0 81 03 3e 	brne	80008fca <_vfprintf_r+0x1f16>
80008952:	fa c3 f9 e0 	sub	r3,sp,-1568
80008956:	40 29       	lddsp	r9,sp[0x8]
80008958:	21 09       	sub	r9,16
8000895a:	50 29       	stdsp	sp[0x8],r9
8000895c:	fa f9 06 90 	ld.w	r9,sp[1680]
80008960:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008964:	4a 4a       	lddpc	r10,800089f4 <_vfprintf_r+0x1940>
80008966:	40 2e       	lddsp	lr,sp[0x8]
80008968:	59 0e       	cp.w	lr,16
8000896a:	fe 99 ff dd 	brgt	80008924 <_vfprintf_r+0x1870>
8000896e:	1c 09       	add	r9,lr
80008970:	2f f8       	sub	r8,-1
80008972:	87 0a       	st.w	r3[0x0],r10
80008974:	fb 49 06 90 	st.w	sp[1680],r9
80008978:	87 1e       	st.w	r3[0x4],lr
8000897a:	fb 48 06 8c 	st.w	sp[1676],r8
8000897e:	58 78       	cp.w	r8,7
80008980:	e0 89 00 04 	brgt	80008988 <_vfprintf_r+0x18d4>
80008984:	2f 83       	sub	r3,-8
80008986:	c0 b8       	rjmp	8000899c <_vfprintf_r+0x18e8>
80008988:	fa ca f9 78 	sub	r10,sp,-1672
8000898c:	02 9b       	mov	r11,r1
8000898e:	08 9c       	mov	r12,r4
80008990:	fe b0 f3 84 	rcall	80007098 <__sprint_r>
80008994:	e0 81 03 1b 	brne	80008fca <_vfprintf_r+0x1f16>
80008998:	fa c3 f9 e0 	sub	r3,sp,-1568
8000899c:	ed b5 00 08 	bld	r5,0x8
800089a0:	c0 b0       	breq	800089b6 <_vfprintf_r+0x1902>
800089a2:	fa f8 06 90 	ld.w	r8,sp[1680]
800089a6:	87 12       	st.w	r3[0x4],r2
800089a8:	87 06       	st.w	r3[0x0],r6
800089aa:	f0 02 00 02 	add	r2,r8,r2
800089ae:	fb 42 06 90 	st.w	sp[1680],r2
800089b2:	e0 8f 01 d5 	bral	80008d5c <_vfprintf_r+0x1ca8>
800089b6:	e0 40 00 65 	cp.w	r0,101
800089ba:	e0 8a 01 d7 	brle	80008d68 <_vfprintf_r+0x1cb4>
800089be:	30 08       	mov	r8,0
800089c0:	30 09       	mov	r9,0
800089c2:	40 5b       	lddsp	r11,sp[0x14]
800089c4:	40 7a       	lddsp	r10,sp[0x1c]
800089c6:	e0 a0 15 3e 	rcall	8000b442 <__avr32_f64_cmp_eq>
800089ca:	c7 a0       	breq	80008abe <_vfprintf_r+0x1a0a>
800089cc:	fa f8 06 90 	ld.w	r8,sp[1680]
800089d0:	48 a9       	lddpc	r9,800089f8 <_vfprintf_r+0x1944>
800089d2:	2f f8       	sub	r8,-1
800089d4:	87 09       	st.w	r3[0x0],r9
800089d6:	fb 48 06 90 	st.w	sp[1680],r8
800089da:	30 19       	mov	r9,1
800089dc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800089e0:	87 19       	st.w	r3[0x4],r9
800089e2:	2f f8       	sub	r8,-1
800089e4:	fb 48 06 8c 	st.w	sp[1676],r8
800089e8:	58 78       	cp.w	r8,7
800089ea:	e0 89 00 09 	brgt	800089fc <_vfprintf_r+0x1948>
800089ee:	2f 83       	sub	r3,-8
800089f0:	c1 08       	rjmp	80008a10 <_vfprintf_r+0x195c>
800089f2:	d7 03       	nop
800089f4:	80 01       	ld.sh	r1,r0[0x0]
800089f6:	52 94       	stdsp	sp[0xa4],r4
800089f8:	80 01       	ld.sh	r1,r0[0x0]
800089fa:	52 80       	stdsp	sp[0xa0],r0
800089fc:	fa ca f9 78 	sub	r10,sp,-1672
80008a00:	02 9b       	mov	r11,r1
80008a02:	08 9c       	mov	r12,r4
80008a04:	fe b0 f3 4a 	rcall	80007098 <__sprint_r>
80008a08:	e0 81 02 e1 	brne	80008fca <_vfprintf_r+0x1f16>
80008a0c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a10:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008a14:	40 6c       	lddsp	r12,sp[0x18]
80008a16:	18 38       	cp.w	r8,r12
80008a18:	c0 55       	brlt	80008a22 <_vfprintf_r+0x196e>
80008a1a:	ed b5 00 00 	bld	r5,0x0
80008a1e:	e0 81 02 69 	brne	80008ef0 <_vfprintf_r+0x1e3c>
80008a22:	fa f8 06 90 	ld.w	r8,sp[1680]
80008a26:	2f f8       	sub	r8,-1
80008a28:	40 cb       	lddsp	r11,sp[0x30]
80008a2a:	fb 48 06 90 	st.w	sp[1680],r8
80008a2e:	30 19       	mov	r9,1
80008a30:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a34:	87 0b       	st.w	r3[0x0],r11
80008a36:	2f f8       	sub	r8,-1
80008a38:	87 19       	st.w	r3[0x4],r9
80008a3a:	fb 48 06 8c 	st.w	sp[1676],r8
80008a3e:	58 78       	cp.w	r8,7
80008a40:	e0 89 00 04 	brgt	80008a48 <_vfprintf_r+0x1994>
80008a44:	2f 83       	sub	r3,-8
80008a46:	c0 b8       	rjmp	80008a5c <_vfprintf_r+0x19a8>
80008a48:	fa ca f9 78 	sub	r10,sp,-1672
80008a4c:	02 9b       	mov	r11,r1
80008a4e:	08 9c       	mov	r12,r4
80008a50:	fe b0 f3 24 	rcall	80007098 <__sprint_r>
80008a54:	e0 81 02 bb 	brne	80008fca <_vfprintf_r+0x1f16>
80008a58:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a5c:	40 66       	lddsp	r6,sp[0x18]
80008a5e:	20 16       	sub	r6,1
80008a60:	58 06       	cp.w	r6,0
80008a62:	e0 89 00 1d 	brgt	80008a9c <_vfprintf_r+0x19e8>
80008a66:	e0 8f 02 45 	bral	80008ef0 <_vfprintf_r+0x1e3c>
80008a6a:	2f 09       	sub	r9,-16
80008a6c:	2f f8       	sub	r8,-1
80008a6e:	fb 49 06 90 	st.w	sp[1680],r9
80008a72:	87 02       	st.w	r3[0x0],r2
80008a74:	87 10       	st.w	r3[0x4],r0
80008a76:	fb 48 06 8c 	st.w	sp[1676],r8
80008a7a:	58 78       	cp.w	r8,7
80008a7c:	e0 89 00 04 	brgt	80008a84 <_vfprintf_r+0x19d0>
80008a80:	2f 83       	sub	r3,-8
80008a82:	c0 b8       	rjmp	80008a98 <_vfprintf_r+0x19e4>
80008a84:	fa ca f9 78 	sub	r10,sp,-1672
80008a88:	02 9b       	mov	r11,r1
80008a8a:	08 9c       	mov	r12,r4
80008a8c:	fe b0 f3 06 	rcall	80007098 <__sprint_r>
80008a90:	e0 81 02 9d 	brne	80008fca <_vfprintf_r+0x1f16>
80008a94:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a98:	21 06       	sub	r6,16
80008a9a:	c0 38       	rjmp	80008aa0 <_vfprintf_r+0x19ec>
80008a9c:	4d 22       	lddpc	r2,80008be4 <_vfprintf_r+0x1b30>
80008a9e:	31 00       	mov	r0,16
80008aa0:	fa f9 06 90 	ld.w	r9,sp[1680]
80008aa4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008aa8:	4c fa       	lddpc	r10,80008be4 <_vfprintf_r+0x1b30>
80008aaa:	59 06       	cp.w	r6,16
80008aac:	fe 99 ff df 	brgt	80008a6a <_vfprintf_r+0x19b6>
80008ab0:	0c 09       	add	r9,r6
80008ab2:	87 0a       	st.w	r3[0x0],r10
80008ab4:	fb 49 06 90 	st.w	sp[1680],r9
80008ab8:	2f f8       	sub	r8,-1
80008aba:	87 16       	st.w	r3[0x4],r6
80008abc:	c5 39       	rjmp	80008d62 <_vfprintf_r+0x1cae>
80008abe:	fa fa 06 ac 	ld.w	r10,sp[1708]
80008ac2:	58 0a       	cp.w	r10,0
80008ac4:	e0 89 00 94 	brgt	80008bec <_vfprintf_r+0x1b38>
80008ac8:	fa f8 06 90 	ld.w	r8,sp[1680]
80008acc:	4c 79       	lddpc	r9,80008be8 <_vfprintf_r+0x1b34>
80008ace:	2f f8       	sub	r8,-1
80008ad0:	87 09       	st.w	r3[0x0],r9
80008ad2:	fb 48 06 90 	st.w	sp[1680],r8
80008ad6:	30 19       	mov	r9,1
80008ad8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008adc:	87 19       	st.w	r3[0x4],r9
80008ade:	2f f8       	sub	r8,-1
80008ae0:	fb 48 06 8c 	st.w	sp[1676],r8
80008ae4:	58 78       	cp.w	r8,7
80008ae6:	e0 89 00 04 	brgt	80008aee <_vfprintf_r+0x1a3a>
80008aea:	2f 83       	sub	r3,-8
80008aec:	c0 b8       	rjmp	80008b02 <_vfprintf_r+0x1a4e>
80008aee:	fa ca f9 78 	sub	r10,sp,-1672
80008af2:	02 9b       	mov	r11,r1
80008af4:	08 9c       	mov	r12,r4
80008af6:	fe b0 f2 d1 	rcall	80007098 <__sprint_r>
80008afa:	e0 81 02 68 	brne	80008fca <_vfprintf_r+0x1f16>
80008afe:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b02:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008b06:	58 08       	cp.w	r8,0
80008b08:	c0 81       	brne	80008b18 <_vfprintf_r+0x1a64>
80008b0a:	40 6a       	lddsp	r10,sp[0x18]
80008b0c:	58 0a       	cp.w	r10,0
80008b0e:	c0 51       	brne	80008b18 <_vfprintf_r+0x1a64>
80008b10:	ed b5 00 00 	bld	r5,0x0
80008b14:	e0 81 01 ee 	brne	80008ef0 <_vfprintf_r+0x1e3c>
80008b18:	40 c9       	lddsp	r9,sp[0x30]
80008b1a:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b1e:	2f f8       	sub	r8,-1
80008b20:	87 09       	st.w	r3[0x0],r9
80008b22:	fb 48 06 90 	st.w	sp[1680],r8
80008b26:	30 19       	mov	r9,1
80008b28:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b2c:	87 19       	st.w	r3[0x4],r9
80008b2e:	2f f8       	sub	r8,-1
80008b30:	fb 48 06 8c 	st.w	sp[1676],r8
80008b34:	58 78       	cp.w	r8,7
80008b36:	e0 89 00 04 	brgt	80008b3e <_vfprintf_r+0x1a8a>
80008b3a:	2f 83       	sub	r3,-8
80008b3c:	c0 b8       	rjmp	80008b52 <_vfprintf_r+0x1a9e>
80008b3e:	fa ca f9 78 	sub	r10,sp,-1672
80008b42:	02 9b       	mov	r11,r1
80008b44:	08 9c       	mov	r12,r4
80008b46:	fe b0 f2 a9 	rcall	80007098 <__sprint_r>
80008b4a:	e0 81 02 40 	brne	80008fca <_vfprintf_r+0x1f16>
80008b4e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b52:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008b56:	5c 32       	neg	r2
80008b58:	58 02       	cp.w	r2,0
80008b5a:	e0 89 00 1d 	brgt	80008b94 <_vfprintf_r+0x1ae0>
80008b5e:	c3 b8       	rjmp	80008bd4 <_vfprintf_r+0x1b20>
80008b60:	2f 09       	sub	r9,-16
80008b62:	2f f8       	sub	r8,-1
80008b64:	31 0e       	mov	lr,16
80008b66:	fb 49 06 90 	st.w	sp[1680],r9
80008b6a:	87 00       	st.w	r3[0x0],r0
80008b6c:	87 1e       	st.w	r3[0x4],lr
80008b6e:	fb 48 06 8c 	st.w	sp[1676],r8
80008b72:	58 78       	cp.w	r8,7
80008b74:	e0 89 00 04 	brgt	80008b7c <_vfprintf_r+0x1ac8>
80008b78:	2f 83       	sub	r3,-8
80008b7a:	c0 b8       	rjmp	80008b90 <_vfprintf_r+0x1adc>
80008b7c:	fa ca f9 78 	sub	r10,sp,-1672
80008b80:	02 9b       	mov	r11,r1
80008b82:	08 9c       	mov	r12,r4
80008b84:	fe b0 f2 8a 	rcall	80007098 <__sprint_r>
80008b88:	e0 81 02 21 	brne	80008fca <_vfprintf_r+0x1f16>
80008b8c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b90:	21 02       	sub	r2,16
80008b92:	c0 28       	rjmp	80008b96 <_vfprintf_r+0x1ae2>
80008b94:	49 40       	lddpc	r0,80008be4 <_vfprintf_r+0x1b30>
80008b96:	fa f9 06 90 	ld.w	r9,sp[1680]
80008b9a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b9e:	49 2a       	lddpc	r10,80008be4 <_vfprintf_r+0x1b30>
80008ba0:	59 02       	cp.w	r2,16
80008ba2:	fe 99 ff df 	brgt	80008b60 <_vfprintf_r+0x1aac>
80008ba6:	04 09       	add	r9,r2
80008ba8:	2f f8       	sub	r8,-1
80008baa:	87 0a       	st.w	r3[0x0],r10
80008bac:	fb 49 06 90 	st.w	sp[1680],r9
80008bb0:	87 12       	st.w	r3[0x4],r2
80008bb2:	fb 48 06 8c 	st.w	sp[1676],r8
80008bb6:	58 78       	cp.w	r8,7
80008bb8:	e0 89 00 04 	brgt	80008bc0 <_vfprintf_r+0x1b0c>
80008bbc:	2f 83       	sub	r3,-8
80008bbe:	c0 b8       	rjmp	80008bd4 <_vfprintf_r+0x1b20>
80008bc0:	fa ca f9 78 	sub	r10,sp,-1672
80008bc4:	02 9b       	mov	r11,r1
80008bc6:	08 9c       	mov	r12,r4
80008bc8:	fe b0 f2 68 	rcall	80007098 <__sprint_r>
80008bcc:	e0 81 01 ff 	brne	80008fca <_vfprintf_r+0x1f16>
80008bd0:	fa c3 f9 e0 	sub	r3,sp,-1568
80008bd4:	40 6c       	lddsp	r12,sp[0x18]
80008bd6:	fa f8 06 90 	ld.w	r8,sp[1680]
80008bda:	87 06       	st.w	r3[0x0],r6
80008bdc:	87 1c       	st.w	r3[0x4],r12
80008bde:	18 08       	add	r8,r12
80008be0:	cb c8       	rjmp	80008d58 <_vfprintf_r+0x1ca4>
80008be2:	d7 03       	nop
80008be4:	80 01       	ld.sh	r1,r0[0x0]
80008be6:	52 94       	stdsp	sp[0xa4],r4
80008be8:	80 01       	ld.sh	r1,r0[0x0]
80008bea:	52 80       	stdsp	sp[0xa0],r0
80008bec:	fa f9 06 90 	ld.w	r9,sp[1680]
80008bf0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008bf4:	40 6b       	lddsp	r11,sp[0x18]
80008bf6:	16 3a       	cp.w	r10,r11
80008bf8:	c6 d5       	brlt	80008cd2 <_vfprintf_r+0x1c1e>
80008bfa:	16 09       	add	r9,r11
80008bfc:	2f f8       	sub	r8,-1
80008bfe:	87 06       	st.w	r3[0x0],r6
80008c00:	fb 49 06 90 	st.w	sp[1680],r9
80008c04:	87 1b       	st.w	r3[0x4],r11
80008c06:	fb 48 06 8c 	st.w	sp[1676],r8
80008c0a:	58 78       	cp.w	r8,7
80008c0c:	e0 89 00 04 	brgt	80008c14 <_vfprintf_r+0x1b60>
80008c10:	2f 83       	sub	r3,-8
80008c12:	c0 b8       	rjmp	80008c28 <_vfprintf_r+0x1b74>
80008c14:	fa ca f9 78 	sub	r10,sp,-1672
80008c18:	02 9b       	mov	r11,r1
80008c1a:	08 9c       	mov	r12,r4
80008c1c:	fe b0 f2 3e 	rcall	80007098 <__sprint_r>
80008c20:	e0 81 01 d5 	brne	80008fca <_vfprintf_r+0x1f16>
80008c24:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c28:	fa f6 06 ac 	ld.w	r6,sp[1708]
80008c2c:	40 6a       	lddsp	r10,sp[0x18]
80008c2e:	14 16       	sub	r6,r10
80008c30:	58 06       	cp.w	r6,0
80008c32:	e0 89 00 1c 	brgt	80008c6a <_vfprintf_r+0x1bb6>
80008c36:	c3 b8       	rjmp	80008cac <_vfprintf_r+0x1bf8>
80008c38:	2f 09       	sub	r9,-16
80008c3a:	2f f8       	sub	r8,-1
80008c3c:	fb 49 06 90 	st.w	sp[1680],r9
80008c40:	87 02       	st.w	r3[0x0],r2
80008c42:	87 10       	st.w	r3[0x4],r0
80008c44:	fb 48 06 8c 	st.w	sp[1676],r8
80008c48:	58 78       	cp.w	r8,7
80008c4a:	e0 89 00 04 	brgt	80008c52 <_vfprintf_r+0x1b9e>
80008c4e:	2f 83       	sub	r3,-8
80008c50:	c0 b8       	rjmp	80008c66 <_vfprintf_r+0x1bb2>
80008c52:	fa ca f9 78 	sub	r10,sp,-1672
80008c56:	02 9b       	mov	r11,r1
80008c58:	08 9c       	mov	r12,r4
80008c5a:	fe b0 f2 1f 	rcall	80007098 <__sprint_r>
80008c5e:	e0 81 01 b6 	brne	80008fca <_vfprintf_r+0x1f16>
80008c62:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c66:	21 06       	sub	r6,16
80008c68:	c0 38       	rjmp	80008c6e <_vfprintf_r+0x1bba>
80008c6a:	4d c2       	lddpc	r2,80008dd8 <_vfprintf_r+0x1d24>
80008c6c:	31 00       	mov	r0,16
80008c6e:	fa f9 06 90 	ld.w	r9,sp[1680]
80008c72:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c76:	4d 9a       	lddpc	r10,80008dd8 <_vfprintf_r+0x1d24>
80008c78:	59 06       	cp.w	r6,16
80008c7a:	fe 99 ff df 	brgt	80008c38 <_vfprintf_r+0x1b84>
80008c7e:	0c 09       	add	r9,r6
80008c80:	2f f8       	sub	r8,-1
80008c82:	87 0a       	st.w	r3[0x0],r10
80008c84:	fb 49 06 90 	st.w	sp[1680],r9
80008c88:	87 16       	st.w	r3[0x4],r6
80008c8a:	fb 48 06 8c 	st.w	sp[1676],r8
80008c8e:	58 78       	cp.w	r8,7
80008c90:	e0 89 00 04 	brgt	80008c98 <_vfprintf_r+0x1be4>
80008c94:	2f 83       	sub	r3,-8
80008c96:	c0 b8       	rjmp	80008cac <_vfprintf_r+0x1bf8>
80008c98:	fa ca f9 78 	sub	r10,sp,-1672
80008c9c:	02 9b       	mov	r11,r1
80008c9e:	08 9c       	mov	r12,r4
80008ca0:	fe b0 f1 fc 	rcall	80007098 <__sprint_r>
80008ca4:	e0 81 01 93 	brne	80008fca <_vfprintf_r+0x1f16>
80008ca8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008cac:	ed b5 00 00 	bld	r5,0x0
80008cb0:	e0 81 01 20 	brne	80008ef0 <_vfprintf_r+0x1e3c>
80008cb4:	40 c9       	lddsp	r9,sp[0x30]
80008cb6:	fa f8 06 90 	ld.w	r8,sp[1680]
80008cba:	2f f8       	sub	r8,-1
80008cbc:	87 09       	st.w	r3[0x0],r9
80008cbe:	fb 48 06 90 	st.w	sp[1680],r8
80008cc2:	30 19       	mov	r9,1
80008cc4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008cc8:	87 19       	st.w	r3[0x4],r9
80008cca:	2f f8       	sub	r8,-1
80008ccc:	fb 48 06 8c 	st.w	sp[1676],r8
80008cd0:	c0 29       	rjmp	80008ed4 <_vfprintf_r+0x1e20>
80008cd2:	14 09       	add	r9,r10
80008cd4:	2f f8       	sub	r8,-1
80008cd6:	fb 49 06 90 	st.w	sp[1680],r9
80008cda:	87 06       	st.w	r3[0x0],r6
80008cdc:	87 1a       	st.w	r3[0x4],r10
80008cde:	fb 48 06 8c 	st.w	sp[1676],r8
80008ce2:	58 78       	cp.w	r8,7
80008ce4:	e0 89 00 04 	brgt	80008cec <_vfprintf_r+0x1c38>
80008ce8:	2f 83       	sub	r3,-8
80008cea:	c0 b8       	rjmp	80008d00 <_vfprintf_r+0x1c4c>
80008cec:	fa ca f9 78 	sub	r10,sp,-1672
80008cf0:	02 9b       	mov	r11,r1
80008cf2:	08 9c       	mov	r12,r4
80008cf4:	fe b0 f1 d2 	rcall	80007098 <__sprint_r>
80008cf8:	e0 81 01 69 	brne	80008fca <_vfprintf_r+0x1f16>
80008cfc:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d00:	40 c8       	lddsp	r8,sp[0x30]
80008d02:	87 08       	st.w	r3[0x0],r8
80008d04:	fa f8 06 90 	ld.w	r8,sp[1680]
80008d08:	2f f8       	sub	r8,-1
80008d0a:	30 19       	mov	r9,1
80008d0c:	fb 48 06 90 	st.w	sp[1680],r8
80008d10:	87 19       	st.w	r3[0x4],r9
80008d12:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d16:	2f f8       	sub	r8,-1
80008d18:	fb 48 06 8c 	st.w	sp[1676],r8
80008d1c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008d20:	58 78       	cp.w	r8,7
80008d22:	e0 89 00 04 	brgt	80008d2a <_vfprintf_r+0x1c76>
80008d26:	2f 83       	sub	r3,-8
80008d28:	c0 b8       	rjmp	80008d3e <_vfprintf_r+0x1c8a>
80008d2a:	fa ca f9 78 	sub	r10,sp,-1672
80008d2e:	02 9b       	mov	r11,r1
80008d30:	08 9c       	mov	r12,r4
80008d32:	fe b0 f1 b3 	rcall	80007098 <__sprint_r>
80008d36:	e0 81 01 4a 	brne	80008fca <_vfprintf_r+0x1f16>
80008d3a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d3e:	04 06       	add	r6,r2
80008d40:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008d44:	87 06       	st.w	r3[0x0],r6
80008d46:	fa f9 06 90 	ld.w	r9,sp[1680]
80008d4a:	40 66       	lddsp	r6,sp[0x18]
80008d4c:	40 6e       	lddsp	lr,sp[0x18]
80008d4e:	10 16       	sub	r6,r8
80008d50:	f2 08 01 08 	sub	r8,r9,r8
80008d54:	87 16       	st.w	r3[0x4],r6
80008d56:	1c 08       	add	r8,lr
80008d58:	fb 48 06 90 	st.w	sp[1680],r8
80008d5c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d60:	2f f8       	sub	r8,-1
80008d62:	fb 48 06 8c 	st.w	sp[1676],r8
80008d66:	cb 78       	rjmp	80008ed4 <_vfprintf_r+0x1e20>
80008d68:	40 6c       	lddsp	r12,sp[0x18]
80008d6a:	58 1c       	cp.w	r12,1
80008d6c:	e0 89 00 06 	brgt	80008d78 <_vfprintf_r+0x1cc4>
80008d70:	ed b5 00 00 	bld	r5,0x0
80008d74:	e0 81 00 85 	brne	80008e7e <_vfprintf_r+0x1dca>
80008d78:	fa f8 06 90 	ld.w	r8,sp[1680]
80008d7c:	2f f8       	sub	r8,-1
80008d7e:	30 19       	mov	r9,1
80008d80:	fb 48 06 90 	st.w	sp[1680],r8
80008d84:	87 06       	st.w	r3[0x0],r6
80008d86:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d8a:	87 19       	st.w	r3[0x4],r9
80008d8c:	2f f8       	sub	r8,-1
80008d8e:	fb 48 06 8c 	st.w	sp[1676],r8
80008d92:	58 78       	cp.w	r8,7
80008d94:	e0 89 00 04 	brgt	80008d9c <_vfprintf_r+0x1ce8>
80008d98:	2f 83       	sub	r3,-8
80008d9a:	c0 b8       	rjmp	80008db0 <_vfprintf_r+0x1cfc>
80008d9c:	fa ca f9 78 	sub	r10,sp,-1672
80008da0:	02 9b       	mov	r11,r1
80008da2:	08 9c       	mov	r12,r4
80008da4:	fe b0 f1 7a 	rcall	80007098 <__sprint_r>
80008da8:	e0 81 01 11 	brne	80008fca <_vfprintf_r+0x1f16>
80008dac:	fa c3 f9 e0 	sub	r3,sp,-1568
80008db0:	fa f8 06 90 	ld.w	r8,sp[1680]
80008db4:	2f f8       	sub	r8,-1
80008db6:	40 cb       	lddsp	r11,sp[0x30]
80008db8:	fb 48 06 90 	st.w	sp[1680],r8
80008dbc:	30 19       	mov	r9,1
80008dbe:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008dc2:	87 0b       	st.w	r3[0x0],r11
80008dc4:	2f f8       	sub	r8,-1
80008dc6:	87 19       	st.w	r3[0x4],r9
80008dc8:	fb 48 06 8c 	st.w	sp[1676],r8
80008dcc:	58 78       	cp.w	r8,7
80008dce:	e0 89 00 07 	brgt	80008ddc <_vfprintf_r+0x1d28>
80008dd2:	2f 83       	sub	r3,-8
80008dd4:	c0 e8       	rjmp	80008df0 <_vfprintf_r+0x1d3c>
80008dd6:	d7 03       	nop
80008dd8:	80 01       	ld.sh	r1,r0[0x0]
80008dda:	52 94       	stdsp	sp[0xa4],r4
80008ddc:	fa ca f9 78 	sub	r10,sp,-1672
80008de0:	02 9b       	mov	r11,r1
80008de2:	08 9c       	mov	r12,r4
80008de4:	fe b0 f1 5a 	rcall	80007098 <__sprint_r>
80008de8:	e0 81 00 f1 	brne	80008fca <_vfprintf_r+0x1f16>
80008dec:	fa c3 f9 e0 	sub	r3,sp,-1568
80008df0:	30 08       	mov	r8,0
80008df2:	30 09       	mov	r9,0
80008df4:	40 5b       	lddsp	r11,sp[0x14]
80008df6:	40 7a       	lddsp	r10,sp[0x1c]
80008df8:	e0 a0 13 25 	rcall	8000b442 <__avr32_f64_cmp_eq>
80008dfc:	40 68       	lddsp	r8,sp[0x18]
80008dfe:	20 18       	sub	r8,1
80008e00:	58 0c       	cp.w	r12,0
80008e02:	c0 d1       	brne	80008e1c <_vfprintf_r+0x1d68>
80008e04:	2f f6       	sub	r6,-1
80008e06:	87 18       	st.w	r3[0x4],r8
80008e08:	87 06       	st.w	r3[0x0],r6
80008e0a:	fa f6 06 90 	ld.w	r6,sp[1680]
80008e0e:	10 06       	add	r6,r8
80008e10:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e14:	fb 46 06 90 	st.w	sp[1680],r6
80008e18:	2f f8       	sub	r8,-1
80008e1a:	c2 f8       	rjmp	80008e78 <_vfprintf_r+0x1dc4>
80008e1c:	10 96       	mov	r6,r8
80008e1e:	58 08       	cp.w	r8,0
80008e20:	e0 89 00 1c 	brgt	80008e58 <_vfprintf_r+0x1da4>
80008e24:	c4 98       	rjmp	80008eb6 <_vfprintf_r+0x1e02>
80008e26:	2f 09       	sub	r9,-16
80008e28:	2f f8       	sub	r8,-1
80008e2a:	fb 49 06 90 	st.w	sp[1680],r9
80008e2e:	87 02       	st.w	r3[0x0],r2
80008e30:	87 10       	st.w	r3[0x4],r0
80008e32:	fb 48 06 8c 	st.w	sp[1676],r8
80008e36:	58 78       	cp.w	r8,7
80008e38:	e0 89 00 04 	brgt	80008e40 <_vfprintf_r+0x1d8c>
80008e3c:	2f 83       	sub	r3,-8
80008e3e:	c0 b8       	rjmp	80008e54 <_vfprintf_r+0x1da0>
80008e40:	fa ca f9 78 	sub	r10,sp,-1672
80008e44:	02 9b       	mov	r11,r1
80008e46:	08 9c       	mov	r12,r4
80008e48:	fe b0 f1 28 	rcall	80007098 <__sprint_r>
80008e4c:	e0 81 00 bf 	brne	80008fca <_vfprintf_r+0x1f16>
80008e50:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e54:	21 06       	sub	r6,16
80008e56:	c0 38       	rjmp	80008e5c <_vfprintf_r+0x1da8>
80008e58:	4d 22       	lddpc	r2,80008fa0 <_vfprintf_r+0x1eec>
80008e5a:	31 00       	mov	r0,16
80008e5c:	fa f9 06 90 	ld.w	r9,sp[1680]
80008e60:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e64:	4c fa       	lddpc	r10,80008fa0 <_vfprintf_r+0x1eec>
80008e66:	59 06       	cp.w	r6,16
80008e68:	fe 99 ff df 	brgt	80008e26 <_vfprintf_r+0x1d72>
80008e6c:	0c 09       	add	r9,r6
80008e6e:	87 0a       	st.w	r3[0x0],r10
80008e70:	fb 49 06 90 	st.w	sp[1680],r9
80008e74:	2f f8       	sub	r8,-1
80008e76:	87 16       	st.w	r3[0x4],r6
80008e78:	fb 48 06 8c 	st.w	sp[1676],r8
80008e7c:	c0 e8       	rjmp	80008e98 <_vfprintf_r+0x1de4>
80008e7e:	fa f8 06 90 	ld.w	r8,sp[1680]
80008e82:	2f f8       	sub	r8,-1
80008e84:	30 19       	mov	r9,1
80008e86:	fb 48 06 90 	st.w	sp[1680],r8
80008e8a:	87 06       	st.w	r3[0x0],r6
80008e8c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e90:	87 19       	st.w	r3[0x4],r9
80008e92:	2f f8       	sub	r8,-1
80008e94:	fb 48 06 8c 	st.w	sp[1676],r8
80008e98:	58 78       	cp.w	r8,7
80008e9a:	e0 89 00 04 	brgt	80008ea2 <_vfprintf_r+0x1dee>
80008e9e:	2f 83       	sub	r3,-8
80008ea0:	c0 b8       	rjmp	80008eb6 <_vfprintf_r+0x1e02>
80008ea2:	fa ca f9 78 	sub	r10,sp,-1672
80008ea6:	02 9b       	mov	r11,r1
80008ea8:	08 9c       	mov	r12,r4
80008eaa:	fe b0 f0 f7 	rcall	80007098 <__sprint_r>
80008eae:	e0 81 00 8e 	brne	80008fca <_vfprintf_r+0x1f16>
80008eb2:	fa c3 f9 e0 	sub	r3,sp,-1568
80008eb6:	40 ea       	lddsp	r10,sp[0x38]
80008eb8:	fa f8 06 90 	ld.w	r8,sp[1680]
80008ebc:	14 08       	add	r8,r10
80008ebe:	fa c9 f9 64 	sub	r9,sp,-1692
80008ec2:	fb 48 06 90 	st.w	sp[1680],r8
80008ec6:	87 1a       	st.w	r3[0x4],r10
80008ec8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ecc:	87 09       	st.w	r3[0x0],r9
80008ece:	2f f8       	sub	r8,-1
80008ed0:	fb 48 06 8c 	st.w	sp[1676],r8
80008ed4:	58 78       	cp.w	r8,7
80008ed6:	e0 89 00 04 	brgt	80008ede <_vfprintf_r+0x1e2a>
80008eda:	2f 83       	sub	r3,-8
80008edc:	c0 a8       	rjmp	80008ef0 <_vfprintf_r+0x1e3c>
80008ede:	fa ca f9 78 	sub	r10,sp,-1672
80008ee2:	02 9b       	mov	r11,r1
80008ee4:	08 9c       	mov	r12,r4
80008ee6:	fe b0 f0 d9 	rcall	80007098 <__sprint_r>
80008eea:	c7 01       	brne	80008fca <_vfprintf_r+0x1f16>
80008eec:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ef0:	e2 15 00 04 	andl	r5,0x4,COH
80008ef4:	c3 d0       	breq	80008f6e <_vfprintf_r+0x1eba>
80008ef6:	40 86       	lddsp	r6,sp[0x20]
80008ef8:	40 39       	lddsp	r9,sp[0xc]
80008efa:	12 16       	sub	r6,r9
80008efc:	58 06       	cp.w	r6,0
80008efe:	e0 89 00 1a 	brgt	80008f32 <_vfprintf_r+0x1e7e>
80008f02:	c3 68       	rjmp	80008f6e <_vfprintf_r+0x1eba>
80008f04:	2f 09       	sub	r9,-16
80008f06:	2f f8       	sub	r8,-1
80008f08:	fb 49 06 90 	st.w	sp[1680],r9
80008f0c:	87 05       	st.w	r3[0x0],r5
80008f0e:	87 12       	st.w	r3[0x4],r2
80008f10:	fb 48 06 8c 	st.w	sp[1676],r8
80008f14:	58 78       	cp.w	r8,7
80008f16:	e0 89 00 04 	brgt	80008f1e <_vfprintf_r+0x1e6a>
80008f1a:	2f 83       	sub	r3,-8
80008f1c:	c0 98       	rjmp	80008f2e <_vfprintf_r+0x1e7a>
80008f1e:	00 9a       	mov	r10,r0
80008f20:	02 9b       	mov	r11,r1
80008f22:	08 9c       	mov	r12,r4
80008f24:	fe b0 f0 ba 	rcall	80007098 <__sprint_r>
80008f28:	c5 11       	brne	80008fca <_vfprintf_r+0x1f16>
80008f2a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f2e:	21 06       	sub	r6,16
80008f30:	c0 58       	rjmp	80008f3a <_vfprintf_r+0x1e86>
80008f32:	49 d5       	lddpc	r5,80008fa4 <_vfprintf_r+0x1ef0>
80008f34:	31 02       	mov	r2,16
80008f36:	fa c0 f9 78 	sub	r0,sp,-1672
80008f3a:	fa f9 06 90 	ld.w	r9,sp[1680]
80008f3e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f42:	49 9a       	lddpc	r10,80008fa4 <_vfprintf_r+0x1ef0>
80008f44:	59 06       	cp.w	r6,16
80008f46:	fe 99 ff df 	brgt	80008f04 <_vfprintf_r+0x1e50>
80008f4a:	0c 09       	add	r9,r6
80008f4c:	2f f8       	sub	r8,-1
80008f4e:	87 0a       	st.w	r3[0x0],r10
80008f50:	87 16       	st.w	r3[0x4],r6
80008f52:	fb 49 06 90 	st.w	sp[1680],r9
80008f56:	fb 48 06 8c 	st.w	sp[1676],r8
80008f5a:	58 78       	cp.w	r8,7
80008f5c:	e0 8a 00 09 	brle	80008f6e <_vfprintf_r+0x1eba>
80008f60:	fa ca f9 78 	sub	r10,sp,-1672
80008f64:	02 9b       	mov	r11,r1
80008f66:	08 9c       	mov	r12,r4
80008f68:	fe b0 f0 98 	rcall	80007098 <__sprint_r>
80008f6c:	c2 f1       	brne	80008fca <_vfprintf_r+0x1f16>
80008f6e:	40 bc       	lddsp	r12,sp[0x2c]
80008f70:	40 36       	lddsp	r6,sp[0xc]
80008f72:	40 8e       	lddsp	lr,sp[0x20]
80008f74:	ec 0e 0c 48 	max	r8,r6,lr
80008f78:	10 0c       	add	r12,r8
80008f7a:	50 bc       	stdsp	sp[0x2c],r12
80008f7c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f80:	58 08       	cp.w	r8,0
80008f82:	c0 80       	breq	80008f92 <_vfprintf_r+0x1ede>
80008f84:	fa ca f9 78 	sub	r10,sp,-1672
80008f88:	02 9b       	mov	r11,r1
80008f8a:	08 9c       	mov	r12,r4
80008f8c:	fe b0 f0 86 	rcall	80007098 <__sprint_r>
80008f90:	c1 d1       	brne	80008fca <_vfprintf_r+0x1f16>
80008f92:	30 0b       	mov	r11,0
80008f94:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f98:	fb 4b 06 8c 	st.w	sp[1676],r11
80008f9c:	fe 9f f1 17 	bral	800071ca <_vfprintf_r+0x116>
80008fa0:	80 01       	ld.sh	r1,r0[0x0]
80008fa2:	52 94       	stdsp	sp[0xa4],r4
80008fa4:	80 01       	ld.sh	r1,r0[0x0]
80008fa6:	52 84       	stdsp	sp[0xa0],r4
80008fa8:	08 95       	mov	r5,r4
80008faa:	fa f8 06 90 	ld.w	r8,sp[1680]
80008fae:	58 08       	cp.w	r8,0
80008fb0:	c0 80       	breq	80008fc0 <_vfprintf_r+0x1f0c>
80008fb2:	08 9c       	mov	r12,r4
80008fb4:	fa ca f9 78 	sub	r10,sp,-1672
80008fb8:	02 9b       	mov	r11,r1
80008fba:	fe b0 f0 6f 	rcall	80007098 <__sprint_r>
80008fbe:	c0 61       	brne	80008fca <_vfprintf_r+0x1f16>
80008fc0:	30 08       	mov	r8,0
80008fc2:	fb 48 06 8c 	st.w	sp[1676],r8
80008fc6:	c0 28       	rjmp	80008fca <_vfprintf_r+0x1f16>
80008fc8:	40 41       	lddsp	r1,sp[0x10]
80008fca:	82 68       	ld.sh	r8,r1[0xc]
80008fcc:	ed b8 00 06 	bld	r8,0x6
80008fd0:	c0 31       	brne	80008fd6 <_vfprintf_r+0x1f22>
80008fd2:	3f fa       	mov	r10,-1
80008fd4:	50 ba       	stdsp	sp[0x2c],r10
80008fd6:	40 bc       	lddsp	r12,sp[0x2c]
80008fd8:	fe 3d f9 44 	sub	sp,-1724
80008fdc:	d8 32       	popm	r0-r7,pc
80008fde:	d7 03       	nop

80008fe0 <__swsetup_r>:
80008fe0:	d4 21       	pushm	r4-r7,lr
80008fe2:	e0 68 0a 30 	mov	r8,2608
80008fe6:	18 96       	mov	r6,r12
80008fe8:	16 97       	mov	r7,r11
80008fea:	70 0c       	ld.w	r12,r8[0x0]
80008fec:	58 0c       	cp.w	r12,0
80008fee:	c0 60       	breq	80008ffa <__swsetup_r+0x1a>
80008ff0:	78 68       	ld.w	r8,r12[0x18]
80008ff2:	58 08       	cp.w	r8,0
80008ff4:	c0 31       	brne	80008ffa <__swsetup_r+0x1a>
80008ff6:	e0 a0 07 c7 	rcall	80009f84 <__sinit>
80008ffa:	4a f8       	lddpc	r8,800090b4 <__swsetup_r+0xd4>
80008ffc:	10 37       	cp.w	r7,r8
80008ffe:	c0 61       	brne	8000900a <__swsetup_r+0x2a>
80009000:	e0 68 0a 30 	mov	r8,2608
80009004:	70 08       	ld.w	r8,r8[0x0]
80009006:	70 07       	ld.w	r7,r8[0x0]
80009008:	c1 08       	rjmp	80009028 <__swsetup_r+0x48>
8000900a:	4a c8       	lddpc	r8,800090b8 <__swsetup_r+0xd8>
8000900c:	10 37       	cp.w	r7,r8
8000900e:	c0 61       	brne	8000901a <__swsetup_r+0x3a>
80009010:	e0 68 0a 30 	mov	r8,2608
80009014:	70 08       	ld.w	r8,r8[0x0]
80009016:	70 17       	ld.w	r7,r8[0x4]
80009018:	c0 88       	rjmp	80009028 <__swsetup_r+0x48>
8000901a:	4a 98       	lddpc	r8,800090bc <__swsetup_r+0xdc>
8000901c:	10 37       	cp.w	r7,r8
8000901e:	c0 51       	brne	80009028 <__swsetup_r+0x48>
80009020:	e0 68 0a 30 	mov	r8,2608
80009024:	70 08       	ld.w	r8,r8[0x0]
80009026:	70 27       	ld.w	r7,r8[0x8]
80009028:	8e 68       	ld.sh	r8,r7[0xc]
8000902a:	ed b8 00 03 	bld	r8,0x3
8000902e:	c1 e0       	breq	8000906a <__swsetup_r+0x8a>
80009030:	ed b8 00 04 	bld	r8,0x4
80009034:	c3 e1       	brne	800090b0 <__swsetup_r+0xd0>
80009036:	ed b8 00 02 	bld	r8,0x2
8000903a:	c1 51       	brne	80009064 <__swsetup_r+0x84>
8000903c:	6e db       	ld.w	r11,r7[0x34]
8000903e:	58 0b       	cp.w	r11,0
80009040:	c0 a0       	breq	80009054 <__swsetup_r+0x74>
80009042:	ee c8 ff bc 	sub	r8,r7,-68
80009046:	10 3b       	cp.w	r11,r8
80009048:	c0 40       	breq	80009050 <__swsetup_r+0x70>
8000904a:	0c 9c       	mov	r12,r6
8000904c:	e0 a0 08 36 	rcall	8000a0b8 <_free_r>
80009050:	30 08       	mov	r8,0
80009052:	8f d8       	st.w	r7[0x34],r8
80009054:	8e 68       	ld.sh	r8,r7[0xc]
80009056:	e0 18 ff db 	andl	r8,0xffdb
8000905a:	ae 68       	st.h	r7[0xc],r8
8000905c:	30 08       	mov	r8,0
8000905e:	8f 18       	st.w	r7[0x4],r8
80009060:	6e 48       	ld.w	r8,r7[0x10]
80009062:	8f 08       	st.w	r7[0x0],r8
80009064:	8e 68       	ld.sh	r8,r7[0xc]
80009066:	a3 b8       	sbr	r8,0x3
80009068:	ae 68       	st.h	r7[0xc],r8
8000906a:	6e 48       	ld.w	r8,r7[0x10]
8000906c:	58 08       	cp.w	r8,0
8000906e:	c0 b1       	brne	80009084 <__swsetup_r+0xa4>
80009070:	8e 68       	ld.sh	r8,r7[0xc]
80009072:	e2 18 02 80 	andl	r8,0x280,COH
80009076:	e0 48 02 00 	cp.w	r8,512
8000907a:	c0 50       	breq	80009084 <__swsetup_r+0xa4>
8000907c:	0c 9c       	mov	r12,r6
8000907e:	0e 9b       	mov	r11,r7
80009080:	e0 a0 0a 56 	rcall	8000a52c <__smakebuf_r>
80009084:	8e 69       	ld.sh	r9,r7[0xc]
80009086:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000908a:	c0 70       	breq	80009098 <__swsetup_r+0xb8>
8000908c:	30 08       	mov	r8,0
8000908e:	8f 28       	st.w	r7[0x8],r8
80009090:	6e 58       	ld.w	r8,r7[0x14]
80009092:	5c 38       	neg	r8
80009094:	8f 68       	st.w	r7[0x18],r8
80009096:	c0 68       	rjmp	800090a2 <__swsetup_r+0xc2>
80009098:	ed b9 00 01 	bld	r9,0x1
8000909c:	ef f8 10 05 	ld.wne	r8,r7[0x14]
800090a0:	8f 28       	st.w	r7[0x8],r8
800090a2:	6e 48       	ld.w	r8,r7[0x10]
800090a4:	58 08       	cp.w	r8,0
800090a6:	c0 61       	brne	800090b2 <__swsetup_r+0xd2>
800090a8:	8e 68       	ld.sh	r8,r7[0xc]
800090aa:	ed b8 00 07 	bld	r8,0x7
800090ae:	c0 21       	brne	800090b2 <__swsetup_r+0xd2>
800090b0:	dc 2a       	popm	r4-r7,pc,r12=-1
800090b2:	d8 2a       	popm	r4-r7,pc,r12=0
800090b4:	80 01       	ld.sh	r1,r0[0x0]
800090b6:	53 b4       	stdsp	sp[0xec],r4
800090b8:	80 01       	ld.sh	r1,r0[0x0]
800090ba:	53 d4       	stdsp	sp[0xf4],r4
800090bc:	80 01       	ld.sh	r1,r0[0x0]
800090be:	53 f4       	stdsp	sp[0xfc],r4

800090c0 <quorem>:
800090c0:	d4 31       	pushm	r0-r7,lr
800090c2:	20 2d       	sub	sp,8
800090c4:	18 97       	mov	r7,r12
800090c6:	78 48       	ld.w	r8,r12[0x10]
800090c8:	76 46       	ld.w	r6,r11[0x10]
800090ca:	0c 38       	cp.w	r8,r6
800090cc:	c0 34       	brge	800090d2 <quorem+0x12>
800090ce:	30 0c       	mov	r12,0
800090d0:	c8 58       	rjmp	800091da <quorem+0x11a>
800090d2:	ec c2 ff fc 	sub	r2,r6,-4
800090d6:	f6 c3 ff ec 	sub	r3,r11,-20
800090da:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
800090de:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
800090e2:	2f f9       	sub	r9,-1
800090e4:	20 16       	sub	r6,1
800090e6:	f8 09 0d 08 	divu	r8,r12,r9
800090ea:	f6 02 00 22 	add	r2,r11,r2<<0x2
800090ee:	ee c4 ff ec 	sub	r4,r7,-20
800090f2:	10 95       	mov	r5,r8
800090f4:	58 08       	cp.w	r8,0
800090f6:	c4 10       	breq	80009178 <quorem+0xb8>
800090f8:	30 09       	mov	r9,0
800090fa:	06 9a       	mov	r10,r3
800090fc:	08 98       	mov	r8,r4
800090fe:	12 91       	mov	r1,r9
80009100:	50 0b       	stdsp	sp[0x0],r11
80009102:	70 0e       	ld.w	lr,r8[0x0]
80009104:	b1 8e       	lsr	lr,0x10
80009106:	50 1e       	stdsp	sp[0x4],lr
80009108:	15 0e       	ld.w	lr,r10++
8000910a:	fc 00 16 10 	lsr	r0,lr,0x10
8000910e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009112:	ea 0e 03 41 	mac	r1,r5,lr
80009116:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000911a:	b1 81       	lsr	r1,0x10
8000911c:	40 1b       	lddsp	r11,sp[0x4]
8000911e:	ea 00 02 40 	mul	r0,r5,r0
80009122:	e2 00 00 00 	add	r0,r1,r0
80009126:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000912a:	02 1b       	sub	r11,r1
8000912c:	50 1b       	stdsp	sp[0x4],r11
8000912e:	70 0b       	ld.w	r11,r8[0x0]
80009130:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009134:	02 09       	add	r9,r1
80009136:	f2 0e 01 0e 	sub	lr,r9,lr
8000913a:	b0 1e       	st.h	r8[0x2],lr
8000913c:	fc 09 14 10 	asr	r9,lr,0x10
80009140:	40 1e       	lddsp	lr,sp[0x4]
80009142:	fc 09 00 09 	add	r9,lr,r9
80009146:	b0 09       	st.h	r8[0x0],r9
80009148:	e0 01 16 10 	lsr	r1,r0,0x10
8000914c:	2f c8       	sub	r8,-4
8000914e:	b1 49       	asr	r9,0x10
80009150:	04 3a       	cp.w	r10,r2
80009152:	fe 98 ff d8 	brls	80009102 <quorem+0x42>
80009156:	40 0b       	lddsp	r11,sp[0x0]
80009158:	58 0c       	cp.w	r12,0
8000915a:	c0 f1       	brne	80009178 <quorem+0xb8>
8000915c:	ec c8 ff fb 	sub	r8,r6,-5
80009160:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009164:	c0 28       	rjmp	80009168 <quorem+0xa8>
80009166:	20 16       	sub	r6,1
80009168:	20 48       	sub	r8,4
8000916a:	08 38       	cp.w	r8,r4
8000916c:	e0 88 00 05 	brls	80009176 <quorem+0xb6>
80009170:	70 09       	ld.w	r9,r8[0x0]
80009172:	58 09       	cp.w	r9,0
80009174:	cf 90       	breq	80009166 <quorem+0xa6>
80009176:	8f 46       	st.w	r7[0x10],r6
80009178:	0e 9c       	mov	r12,r7
8000917a:	e0 a0 0a d8 	rcall	8000a72a <__mcmp>
8000917e:	c2 d5       	brlt	800091d8 <quorem+0x118>
80009180:	2f f5       	sub	r5,-1
80009182:	08 98       	mov	r8,r4
80009184:	30 09       	mov	r9,0
80009186:	07 0b       	ld.w	r11,r3++
80009188:	f6 0a 16 10 	lsr	r10,r11,0x10
8000918c:	70 0c       	ld.w	r12,r8[0x0]
8000918e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009192:	f8 0e 16 10 	lsr	lr,r12,0x10
80009196:	14 1e       	sub	lr,r10
80009198:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000919c:	16 1a       	sub	r10,r11
8000919e:	12 0a       	add	r10,r9
800091a0:	b0 1a       	st.h	r8[0x2],r10
800091a2:	b1 4a       	asr	r10,0x10
800091a4:	fc 0a 00 09 	add	r9,lr,r10
800091a8:	b0 09       	st.h	r8[0x0],r9
800091aa:	2f c8       	sub	r8,-4
800091ac:	b1 49       	asr	r9,0x10
800091ae:	04 33       	cp.w	r3,r2
800091b0:	fe 98 ff eb 	brls	80009186 <quorem+0xc6>
800091b4:	ec c8 ff fb 	sub	r8,r6,-5
800091b8:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
800091bc:	58 09       	cp.w	r9,0
800091be:	c0 d1       	brne	800091d8 <quorem+0x118>
800091c0:	ee 08 00 28 	add	r8,r7,r8<<0x2
800091c4:	c0 28       	rjmp	800091c8 <quorem+0x108>
800091c6:	20 16       	sub	r6,1
800091c8:	20 48       	sub	r8,4
800091ca:	08 38       	cp.w	r8,r4
800091cc:	e0 88 00 05 	brls	800091d6 <quorem+0x116>
800091d0:	70 09       	ld.w	r9,r8[0x0]
800091d2:	58 09       	cp.w	r9,0
800091d4:	cf 90       	breq	800091c6 <quorem+0x106>
800091d6:	8f 46       	st.w	r7[0x10],r6
800091d8:	0a 9c       	mov	r12,r5
800091da:	2f ed       	sub	sp,-8
800091dc:	d8 32       	popm	r0-r7,pc
800091de:	d7 03       	nop

800091e0 <_dtoa_r>:
800091e0:	d4 31       	pushm	r0-r7,lr
800091e2:	21 ad       	sub	sp,104
800091e4:	fa c4 ff 74 	sub	r4,sp,-140
800091e8:	18 97       	mov	r7,r12
800091ea:	16 95       	mov	r5,r11
800091ec:	68 2c       	ld.w	r12,r4[0x8]
800091ee:	50 c9       	stdsp	sp[0x30],r9
800091f0:	68 16       	ld.w	r6,r4[0x4]
800091f2:	68 09       	ld.w	r9,r4[0x0]
800091f4:	50 e8       	stdsp	sp[0x38],r8
800091f6:	14 94       	mov	r4,r10
800091f8:	51 2c       	stdsp	sp[0x48],r12
800091fa:	fa e5 00 08 	st.d	sp[8],r4
800091fe:	51 59       	stdsp	sp[0x54],r9
80009200:	6e 95       	ld.w	r5,r7[0x24]
80009202:	58 05       	cp.w	r5,0
80009204:	c0 91       	brne	80009216 <_dtoa_r+0x36>
80009206:	31 0c       	mov	r12,16
80009208:	fe b0 e8 cc 	rcall	800063a0 <malloc>
8000920c:	99 35       	st.w	r12[0xc],r5
8000920e:	8f 9c       	st.w	r7[0x24],r12
80009210:	99 15       	st.w	r12[0x4],r5
80009212:	99 25       	st.w	r12[0x8],r5
80009214:	99 05       	st.w	r12[0x0],r5
80009216:	6e 99       	ld.w	r9,r7[0x24]
80009218:	72 08       	ld.w	r8,r9[0x0]
8000921a:	58 08       	cp.w	r8,0
8000921c:	c0 f0       	breq	8000923a <_dtoa_r+0x5a>
8000921e:	72 1a       	ld.w	r10,r9[0x4]
80009220:	91 1a       	st.w	r8[0x4],r10
80009222:	30 1a       	mov	r10,1
80009224:	72 19       	ld.w	r9,r9[0x4]
80009226:	f4 09 09 49 	lsl	r9,r10,r9
8000922a:	10 9b       	mov	r11,r8
8000922c:	91 29       	st.w	r8[0x8],r9
8000922e:	0e 9c       	mov	r12,r7
80009230:	e0 a0 0a 96 	rcall	8000a75c <_Bfree>
80009234:	6e 98       	ld.w	r8,r7[0x24]
80009236:	30 09       	mov	r9,0
80009238:	91 09       	st.w	r8[0x0],r9
8000923a:	40 28       	lddsp	r8,sp[0x8]
8000923c:	10 94       	mov	r4,r8
8000923e:	58 08       	cp.w	r8,0
80009240:	c0 64       	brge	8000924c <_dtoa_r+0x6c>
80009242:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009246:	50 28       	stdsp	sp[0x8],r8
80009248:	30 18       	mov	r8,1
8000924a:	c0 28       	rjmp	8000924e <_dtoa_r+0x6e>
8000924c:	30 08       	mov	r8,0
8000924e:	8d 08       	st.w	r6[0x0],r8
80009250:	fc 1c 7f f0 	movh	r12,0x7ff0
80009254:	40 26       	lddsp	r6,sp[0x8]
80009256:	0c 98       	mov	r8,r6
80009258:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000925c:	18 38       	cp.w	r8,r12
8000925e:	c1 e1       	brne	8000929a <_dtoa_r+0xba>
80009260:	e0 68 27 0f 	mov	r8,9999
80009264:	41 5b       	lddsp	r11,sp[0x54]
80009266:	97 08       	st.w	r11[0x0],r8
80009268:	40 3a       	lddsp	r10,sp[0xc]
8000926a:	58 0a       	cp.w	r10,0
8000926c:	c0 61       	brne	80009278 <_dtoa_r+0x98>
8000926e:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009272:	c0 31       	brne	80009278 <_dtoa_r+0x98>
80009274:	4a cc       	lddpc	r12,80009324 <_dtoa_r+0x144>
80009276:	c0 28       	rjmp	8000927a <_dtoa_r+0x9a>
80009278:	4a cc       	lddpc	r12,80009328 <_dtoa_r+0x148>
8000927a:	41 29       	lddsp	r9,sp[0x48]
8000927c:	58 09       	cp.w	r9,0
8000927e:	e0 80 05 9e 	breq	80009dba <_dtoa_r+0xbda>
80009282:	f8 c8 ff fd 	sub	r8,r12,-3
80009286:	f8 c9 ff f8 	sub	r9,r12,-8
8000928a:	11 8b       	ld.ub	r11,r8[0x0]
8000928c:	30 0a       	mov	r10,0
8000928e:	41 25       	lddsp	r5,sp[0x48]
80009290:	f4 0b 18 00 	cp.b	r11,r10
80009294:	f2 08 17 10 	movne	r8,r9
80009298:	c1 58       	rjmp	800092c2 <_dtoa_r+0xe2>
8000929a:	fa ea 00 08 	ld.d	r10,sp[8]
8000929e:	30 08       	mov	r8,0
800092a0:	fa eb 00 3c 	st.d	sp[60],r10
800092a4:	30 09       	mov	r9,0
800092a6:	e0 a0 10 ce 	rcall	8000b442 <__avr32_f64_cmp_eq>
800092aa:	c0 f0       	breq	800092c8 <_dtoa_r+0xe8>
800092ac:	30 18       	mov	r8,1
800092ae:	41 5a       	lddsp	r10,sp[0x54]
800092b0:	95 08       	st.w	r10[0x0],r8
800092b2:	49 fc       	lddpc	r12,8000932c <_dtoa_r+0x14c>
800092b4:	41 29       	lddsp	r9,sp[0x48]
800092b6:	f8 08 00 08 	add	r8,r12,r8
800092ba:	58 09       	cp.w	r9,0
800092bc:	e0 80 05 7f 	breq	80009dba <_dtoa_r+0xbda>
800092c0:	12 95       	mov	r5,r9
800092c2:	8b 08       	st.w	r5[0x0],r8
800092c4:	e0 8f 05 7b 	bral	80009dba <_dtoa_r+0xbda>
800092c8:	fa c8 ff 9c 	sub	r8,sp,-100
800092cc:	fa c9 ff a0 	sub	r9,sp,-96
800092d0:	fa ea 00 3c 	ld.d	r10,sp[60]
800092d4:	0e 9c       	mov	r12,r7
800092d6:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
800092da:	e0 a0 0a 93 	rcall	8000a800 <__d2b>
800092de:	18 93       	mov	r3,r12
800092e0:	58 05       	cp.w	r5,0
800092e2:	c0 d0       	breq	800092fc <_dtoa_r+0x11c>
800092e4:	fa ea 00 3c 	ld.d	r10,sp[60]
800092e8:	30 04       	mov	r4,0
800092ea:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
800092ee:	ea c5 03 ff 	sub	r5,r5,1023
800092f2:	10 9b       	mov	r11,r8
800092f4:	51 74       	stdsp	sp[0x5c],r4
800092f6:	ea 1b 3f f0 	orh	r11,0x3ff0
800092fa:	c2 a8       	rjmp	8000934e <_dtoa_r+0x16e>
800092fc:	41 88       	lddsp	r8,sp[0x60]
800092fe:	41 9c       	lddsp	r12,sp[0x64]
80009300:	10 0c       	add	r12,r8
80009302:	f8 c5 fb ce 	sub	r5,r12,-1074
80009306:	e0 45 00 20 	cp.w	r5,32
8000930a:	e0 8a 00 13 	brle	80009330 <_dtoa_r+0x150>
8000930e:	f8 cc fb ee 	sub	r12,r12,-1042
80009312:	40 3b       	lddsp	r11,sp[0xc]
80009314:	ea 08 11 40 	rsub	r8,r5,64
80009318:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000931c:	ec 08 09 46 	lsl	r6,r6,r8
80009320:	0c 4c       	or	r12,r6
80009322:	c0 c8       	rjmp	8000933a <_dtoa_r+0x15a>
80009324:	80 01       	ld.sh	r1,r0[0x0]
80009326:	53 a4       	stdsp	sp[0xe8],r4
80009328:	80 01       	ld.sh	r1,r0[0x0]
8000932a:	53 b0       	stdsp	sp[0xec],r0
8000932c:	80 01       	ld.sh	r1,r0[0x0]
8000932e:	52 80       	stdsp	sp[0xa0],r0
80009330:	ea 0c 11 20 	rsub	r12,r5,32
80009334:	40 3a       	lddsp	r10,sp[0xc]
80009336:	f4 0c 09 4c 	lsl	r12,r10,r12
8000933a:	e0 a0 10 10 	rcall	8000b35a <__avr32_u32_to_f64>
8000933e:	fc 18 fe 10 	movh	r8,0xfe10
80009342:	30 19       	mov	r9,1
80009344:	ea c5 04 33 	sub	r5,r5,1075
80009348:	f0 0b 00 0b 	add	r11,r8,r11
8000934c:	51 79       	stdsp	sp[0x5c],r9
8000934e:	30 08       	mov	r8,0
80009350:	fc 19 3f f8 	movh	r9,0x3ff8
80009354:	e0 a0 0e 98 	rcall	8000b084 <__avr32_f64_sub>
80009358:	e0 68 43 61 	mov	r8,17249
8000935c:	ea 18 63 6f 	orh	r8,0x636f
80009360:	e0 69 87 a7 	mov	r9,34727
80009364:	ea 19 3f d2 	orh	r9,0x3fd2
80009368:	e0 a0 0d a2 	rcall	8000aeac <__avr32_f64_mul>
8000936c:	e0 68 c8 b3 	mov	r8,51379
80009370:	ea 18 8b 60 	orh	r8,0x8b60
80009374:	e0 69 8a 28 	mov	r9,35368
80009378:	ea 19 3f c6 	orh	r9,0x3fc6
8000937c:	e0 a0 0f 52 	rcall	8000b220 <__avr32_f64_add>
80009380:	0a 9c       	mov	r12,r5
80009382:	14 90       	mov	r0,r10
80009384:	16 91       	mov	r1,r11
80009386:	e0 a0 0f ee 	rcall	8000b362 <__avr32_s32_to_f64>
8000938a:	e0 68 79 fb 	mov	r8,31227
8000938e:	ea 18 50 9f 	orh	r8,0x509f
80009392:	e0 69 44 13 	mov	r9,17427
80009396:	ea 19 3f d3 	orh	r9,0x3fd3
8000939a:	e0 a0 0d 89 	rcall	8000aeac <__avr32_f64_mul>
8000939e:	14 98       	mov	r8,r10
800093a0:	16 99       	mov	r9,r11
800093a2:	00 9a       	mov	r10,r0
800093a4:	02 9b       	mov	r11,r1
800093a6:	e0 a0 0f 3d 	rcall	8000b220 <__avr32_f64_add>
800093aa:	14 90       	mov	r0,r10
800093ac:	16 91       	mov	r1,r11
800093ae:	e0 a0 0f c3 	rcall	8000b334 <__avr32_f64_to_s32>
800093b2:	30 08       	mov	r8,0
800093b4:	18 96       	mov	r6,r12
800093b6:	30 09       	mov	r9,0
800093b8:	00 9a       	mov	r10,r0
800093ba:	02 9b       	mov	r11,r1
800093bc:	e0 a0 10 8a 	rcall	8000b4d0 <__avr32_f64_cmp_lt>
800093c0:	c0 c0       	breq	800093d8 <_dtoa_r+0x1f8>
800093c2:	0c 9c       	mov	r12,r6
800093c4:	e0 a0 0f cf 	rcall	8000b362 <__avr32_s32_to_f64>
800093c8:	14 98       	mov	r8,r10
800093ca:	16 99       	mov	r9,r11
800093cc:	00 9a       	mov	r10,r0
800093ce:	02 9b       	mov	r11,r1
800093d0:	e0 a0 10 39 	rcall	8000b442 <__avr32_f64_cmp_eq>
800093d4:	f7 b6 00 01 	subeq	r6,1
800093d8:	59 66       	cp.w	r6,22
800093da:	e0 88 00 05 	brls	800093e4 <_dtoa_r+0x204>
800093de:	30 18       	mov	r8,1
800093e0:	51 48       	stdsp	sp[0x50],r8
800093e2:	c1 28       	rjmp	80009406 <_dtoa_r+0x226>
800093e4:	4c 08       	lddpc	r8,800094e4 <_dtoa_r+0x304>
800093e6:	fa ea 00 3c 	ld.d	r10,sp[60]
800093ea:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
800093ee:	e0 a0 10 71 	rcall	8000b4d0 <__avr32_f64_cmp_lt>
800093f2:	f9 b4 00 00 	moveq	r4,0
800093f6:	fb f4 0a 14 	st.weq	sp[0x50],r4
800093fa:	f7 b6 01 01 	subne	r6,1
800093fe:	f9 bc 01 00 	movne	r12,0
80009402:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009406:	41 90       	lddsp	r0,sp[0x64]
80009408:	20 10       	sub	r0,1
8000940a:	0a 10       	sub	r0,r5
8000940c:	c0 46       	brmi	80009414 <_dtoa_r+0x234>
8000940e:	50 40       	stdsp	sp[0x10],r0
80009410:	30 00       	mov	r0,0
80009412:	c0 48       	rjmp	8000941a <_dtoa_r+0x23a>
80009414:	30 0b       	mov	r11,0
80009416:	5c 30       	neg	r0
80009418:	50 4b       	stdsp	sp[0x10],r11
8000941a:	ec 02 11 00 	rsub	r2,r6,0
8000941e:	58 06       	cp.w	r6,0
80009420:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009424:	f5 d6 e4 0a 	addge	r10,r10,r6
80009428:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000942c:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009430:	f9 b2 04 00 	movge	r2,0
80009434:	e1 d6 e5 10 	sublt	r0,r0,r6
80009438:	f9 b9 05 00 	movlt	r9,0
8000943c:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009440:	40 c8       	lddsp	r8,sp[0x30]
80009442:	58 98       	cp.w	r8,9
80009444:	e0 8b 00 20 	brhi	80009484 <_dtoa_r+0x2a4>
80009448:	58 58       	cp.w	r8,5
8000944a:	f9 b4 0a 01 	movle	r4,1
8000944e:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009452:	f7 b5 09 04 	subgt	r5,4
80009456:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000945a:	f9 b4 09 00 	movgt	r4,0
8000945e:	40 cc       	lddsp	r12,sp[0x30]
80009460:	58 3c       	cp.w	r12,3
80009462:	c2 d0       	breq	800094bc <_dtoa_r+0x2dc>
80009464:	e0 89 00 05 	brgt	8000946e <_dtoa_r+0x28e>
80009468:	58 2c       	cp.w	r12,2
8000946a:	c1 01       	brne	8000948a <_dtoa_r+0x2aa>
8000946c:	c1 88       	rjmp	8000949c <_dtoa_r+0x2bc>
8000946e:	40 cb       	lddsp	r11,sp[0x30]
80009470:	58 4b       	cp.w	r11,4
80009472:	c0 60       	breq	8000947e <_dtoa_r+0x29e>
80009474:	58 5b       	cp.w	r11,5
80009476:	c0 a1       	brne	8000948a <_dtoa_r+0x2aa>
80009478:	30 1a       	mov	r10,1
8000947a:	50 da       	stdsp	sp[0x34],r10
8000947c:	c2 28       	rjmp	800094c0 <_dtoa_r+0x2e0>
8000947e:	30 19       	mov	r9,1
80009480:	50 d9       	stdsp	sp[0x34],r9
80009482:	c0 f8       	rjmp	800094a0 <_dtoa_r+0x2c0>
80009484:	30 08       	mov	r8,0
80009486:	30 14       	mov	r4,1
80009488:	50 c8       	stdsp	sp[0x30],r8
8000948a:	3f f5       	mov	r5,-1
8000948c:	30 1c       	mov	r12,1
8000948e:	30 0b       	mov	r11,0
80009490:	50 95       	stdsp	sp[0x24],r5
80009492:	50 dc       	stdsp	sp[0x34],r12
80009494:	0a 91       	mov	r1,r5
80009496:	31 28       	mov	r8,18
80009498:	50 eb       	stdsp	sp[0x38],r11
8000949a:	c2 08       	rjmp	800094da <_dtoa_r+0x2fa>
8000949c:	30 0a       	mov	r10,0
8000949e:	50 da       	stdsp	sp[0x34],r10
800094a0:	40 e9       	lddsp	r9,sp[0x38]
800094a2:	58 09       	cp.w	r9,0
800094a4:	e0 89 00 07 	brgt	800094b2 <_dtoa_r+0x2d2>
800094a8:	30 18       	mov	r8,1
800094aa:	50 98       	stdsp	sp[0x24],r8
800094ac:	10 91       	mov	r1,r8
800094ae:	50 e8       	stdsp	sp[0x38],r8
800094b0:	c1 58       	rjmp	800094da <_dtoa_r+0x2fa>
800094b2:	40 e5       	lddsp	r5,sp[0x38]
800094b4:	50 95       	stdsp	sp[0x24],r5
800094b6:	0a 91       	mov	r1,r5
800094b8:	0a 98       	mov	r8,r5
800094ba:	c1 08       	rjmp	800094da <_dtoa_r+0x2fa>
800094bc:	30 0c       	mov	r12,0
800094be:	50 dc       	stdsp	sp[0x34],r12
800094c0:	40 eb       	lddsp	r11,sp[0x38]
800094c2:	ec 0b 00 0b 	add	r11,r6,r11
800094c6:	50 9b       	stdsp	sp[0x24],r11
800094c8:	16 98       	mov	r8,r11
800094ca:	2f f8       	sub	r8,-1
800094cc:	58 08       	cp.w	r8,0
800094ce:	e0 89 00 05 	brgt	800094d8 <_dtoa_r+0x2f8>
800094d2:	10 91       	mov	r1,r8
800094d4:	30 18       	mov	r8,1
800094d6:	c0 28       	rjmp	800094da <_dtoa_r+0x2fa>
800094d8:	10 91       	mov	r1,r8
800094da:	30 09       	mov	r9,0
800094dc:	6e 9a       	ld.w	r10,r7[0x24]
800094de:	95 19       	st.w	r10[0x4],r9
800094e0:	30 49       	mov	r9,4
800094e2:	c0 78       	rjmp	800094f0 <_dtoa_r+0x310>
800094e4:	80 01       	ld.sh	r1,r0[0x0]
800094e6:	54 64       	stdsp	sp[0x118],r4
800094e8:	6a 1a       	ld.w	r10,r5[0x4]
800094ea:	a1 79       	lsl	r9,0x1
800094ec:	2f fa       	sub	r10,-1
800094ee:	8b 1a       	st.w	r5[0x4],r10
800094f0:	6e 95       	ld.w	r5,r7[0x24]
800094f2:	f2 ca ff ec 	sub	r10,r9,-20
800094f6:	10 3a       	cp.w	r10,r8
800094f8:	fe 98 ff f8 	brls	800094e8 <_dtoa_r+0x308>
800094fc:	6a 1b       	ld.w	r11,r5[0x4]
800094fe:	0e 9c       	mov	r12,r7
80009500:	e0 a0 09 48 	rcall	8000a790 <_Balloc>
80009504:	58 e1       	cp.w	r1,14
80009506:	5f 88       	srls	r8
80009508:	8b 0c       	st.w	r5[0x0],r12
8000950a:	f1 e4 00 04 	and	r4,r8,r4
8000950e:	6e 98       	ld.w	r8,r7[0x24]
80009510:	70 08       	ld.w	r8,r8[0x0]
80009512:	50 88       	stdsp	sp[0x20],r8
80009514:	e0 80 01 82 	breq	80009818 <_dtoa_r+0x638>
80009518:	58 06       	cp.w	r6,0
8000951a:	e0 8a 00 40 	brle	8000959a <_dtoa_r+0x3ba>
8000951e:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009522:	4c b8       	lddpc	r8,8000964c <_dtoa_r+0x46c>
80009524:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80009528:	fa e5 00 18 	st.d	sp[24],r4
8000952c:	ec 04 14 04 	asr	r4,r6,0x4
80009530:	ed b4 00 04 	bld	r4,0x4
80009534:	c0 30       	breq	8000953a <_dtoa_r+0x35a>
80009536:	30 25       	mov	r5,2
80009538:	c0 f8       	rjmp	80009556 <_dtoa_r+0x376>
8000953a:	4c 68       	lddpc	r8,80009650 <_dtoa_r+0x470>
8000953c:	f0 e8 00 20 	ld.d	r8,r8[32]
80009540:	fa ea 00 3c 	ld.d	r10,sp[60]
80009544:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009548:	e0 a0 0f f8 	rcall	8000b538 <__avr32_f64_div>
8000954c:	30 35       	mov	r5,3
8000954e:	14 98       	mov	r8,r10
80009550:	16 99       	mov	r9,r11
80009552:	fa e9 00 08 	st.d	sp[8],r8
80009556:	4b fc       	lddpc	r12,80009650 <_dtoa_r+0x470>
80009558:	50 a3       	stdsp	sp[0x28],r3
8000955a:	0c 93       	mov	r3,r6
8000955c:	18 96       	mov	r6,r12
8000955e:	c0 f8       	rjmp	8000957c <_dtoa_r+0x39c>
80009560:	fa ea 00 18 	ld.d	r10,sp[24]
80009564:	ed b4 00 00 	bld	r4,0x0
80009568:	c0 81       	brne	80009578 <_dtoa_r+0x398>
8000956a:	ec e8 00 00 	ld.d	r8,r6[0]
8000956e:	2f f5       	sub	r5,-1
80009570:	e0 a0 0c 9e 	rcall	8000aeac <__avr32_f64_mul>
80009574:	fa eb 00 18 	st.d	sp[24],r10
80009578:	a1 54       	asr	r4,0x1
8000957a:	2f 86       	sub	r6,-8
8000957c:	58 04       	cp.w	r4,0
8000957e:	cf 11       	brne	80009560 <_dtoa_r+0x380>
80009580:	fa e8 00 18 	ld.d	r8,sp[24]
80009584:	fa ea 00 08 	ld.d	r10,sp[8]
80009588:	06 96       	mov	r6,r3
8000958a:	e0 a0 0f d7 	rcall	8000b538 <__avr32_f64_div>
8000958e:	40 a3       	lddsp	r3,sp[0x28]
80009590:	14 98       	mov	r8,r10
80009592:	16 99       	mov	r9,r11
80009594:	fa e9 00 08 	st.d	sp[8],r8
80009598:	c2 d8       	rjmp	800095f2 <_dtoa_r+0x412>
8000959a:	ec 08 11 00 	rsub	r8,r6,0
8000959e:	c0 31       	brne	800095a4 <_dtoa_r+0x3c4>
800095a0:	30 25       	mov	r5,2
800095a2:	c2 88       	rjmp	800095f2 <_dtoa_r+0x412>
800095a4:	4a bc       	lddpc	r12,80009650 <_dtoa_r+0x470>
800095a6:	f0 04 14 04 	asr	r4,r8,0x4
800095aa:	50 1c       	stdsp	sp[0x4],r12
800095ac:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800095b0:	4a 79       	lddpc	r9,8000964c <_dtoa_r+0x46c>
800095b2:	fa ea 00 3c 	ld.d	r10,sp[60]
800095b6:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
800095ba:	e0 a0 0c 79 	rcall	8000aeac <__avr32_f64_mul>
800095be:	40 1c       	lddsp	r12,sp[0x4]
800095c0:	50 63       	stdsp	sp[0x18],r3
800095c2:	30 25       	mov	r5,2
800095c4:	0c 93       	mov	r3,r6
800095c6:	fa eb 00 08 	st.d	sp[8],r10
800095ca:	18 96       	mov	r6,r12
800095cc:	c0 f8       	rjmp	800095ea <_dtoa_r+0x40a>
800095ce:	fa ea 00 08 	ld.d	r10,sp[8]
800095d2:	ed b4 00 00 	bld	r4,0x0
800095d6:	c0 81       	brne	800095e6 <_dtoa_r+0x406>
800095d8:	ec e8 00 00 	ld.d	r8,r6[0]
800095dc:	2f f5       	sub	r5,-1
800095de:	e0 a0 0c 67 	rcall	8000aeac <__avr32_f64_mul>
800095e2:	fa eb 00 08 	st.d	sp[8],r10
800095e6:	a1 54       	asr	r4,0x1
800095e8:	2f 86       	sub	r6,-8
800095ea:	58 04       	cp.w	r4,0
800095ec:	cf 11       	brne	800095ce <_dtoa_r+0x3ee>
800095ee:	06 96       	mov	r6,r3
800095f0:	40 63       	lddsp	r3,sp[0x18]
800095f2:	41 4a       	lddsp	r10,sp[0x50]
800095f4:	58 0a       	cp.w	r10,0
800095f6:	c2 f0       	breq	80009654 <_dtoa_r+0x474>
800095f8:	fa e8 00 08 	ld.d	r8,sp[8]
800095fc:	58 01       	cp.w	r1,0
800095fe:	5f 94       	srgt	r4
80009600:	fa e9 00 18 	st.d	sp[24],r8
80009604:	30 08       	mov	r8,0
80009606:	fc 19 3f f0 	movh	r9,0x3ff0
8000960a:	fa ea 00 18 	ld.d	r10,sp[24]
8000960e:	e0 a0 0f 61 	rcall	8000b4d0 <__avr32_f64_cmp_lt>
80009612:	f9 bc 00 00 	moveq	r12,0
80009616:	f9 bc 01 01 	movne	r12,1
8000961a:	e9 ec 00 0c 	and	r12,r4,r12
8000961e:	c1 b0       	breq	80009654 <_dtoa_r+0x474>
80009620:	40 98       	lddsp	r8,sp[0x24]
80009622:	58 08       	cp.w	r8,0
80009624:	e0 8a 00 f6 	brle	80009810 <_dtoa_r+0x630>
80009628:	30 08       	mov	r8,0
8000962a:	fc 19 40 24 	movh	r9,0x4024
8000962e:	ec c4 00 01 	sub	r4,r6,1
80009632:	fa ea 00 18 	ld.d	r10,sp[24]
80009636:	2f f5       	sub	r5,-1
80009638:	50 64       	stdsp	sp[0x18],r4
8000963a:	e0 a0 0c 39 	rcall	8000aeac <__avr32_f64_mul>
8000963e:	40 94       	lddsp	r4,sp[0x24]
80009640:	14 98       	mov	r8,r10
80009642:	16 99       	mov	r9,r11
80009644:	fa e9 00 08 	st.d	sp[8],r8
80009648:	c0 88       	rjmp	80009658 <_dtoa_r+0x478>
8000964a:	d7 03       	nop
8000964c:	80 01       	ld.sh	r1,r0[0x0]
8000964e:	54 64       	stdsp	sp[0x118],r4
80009650:	80 01       	ld.sh	r1,r0[0x0]
80009652:	55 2c       	stdsp	sp[0x148],r12
80009654:	50 66       	stdsp	sp[0x18],r6
80009656:	02 94       	mov	r4,r1
80009658:	0a 9c       	mov	r12,r5
8000965a:	e0 a0 0e 84 	rcall	8000b362 <__avr32_s32_to_f64>
8000965e:	fa e8 00 08 	ld.d	r8,sp[8]
80009662:	e0 a0 0c 25 	rcall	8000aeac <__avr32_f64_mul>
80009666:	30 08       	mov	r8,0
80009668:	fc 19 40 1c 	movh	r9,0x401c
8000966c:	e0 a0 0d da 	rcall	8000b220 <__avr32_f64_add>
80009670:	14 98       	mov	r8,r10
80009672:	16 99       	mov	r9,r11
80009674:	fa e9 00 28 	st.d	sp[40],r8
80009678:	fc 18 fc c0 	movh	r8,0xfcc0
8000967c:	40 a5       	lddsp	r5,sp[0x28]
8000967e:	10 05       	add	r5,r8
80009680:	50 a5       	stdsp	sp[0x28],r5
80009682:	58 04       	cp.w	r4,0
80009684:	c2 11       	brne	800096c6 <_dtoa_r+0x4e6>
80009686:	fa ea 00 08 	ld.d	r10,sp[8]
8000968a:	30 08       	mov	r8,0
8000968c:	fc 19 40 14 	movh	r9,0x4014
80009690:	e0 a0 0c fa 	rcall	8000b084 <__avr32_f64_sub>
80009694:	40 bc       	lddsp	r12,sp[0x2c]
80009696:	fa eb 00 08 	st.d	sp[8],r10
8000969a:	14 98       	mov	r8,r10
8000969c:	16 99       	mov	r9,r11
8000969e:	18 9a       	mov	r10,r12
800096a0:	0a 9b       	mov	r11,r5
800096a2:	e0 a0 0f 17 	rcall	8000b4d0 <__avr32_f64_cmp_lt>
800096a6:	e0 81 02 54 	brne	80009b4e <_dtoa_r+0x96e>
800096aa:	0a 98       	mov	r8,r5
800096ac:	40 b9       	lddsp	r9,sp[0x2c]
800096ae:	ee 18 80 00 	eorh	r8,0x8000
800096b2:	fa ea 00 08 	ld.d	r10,sp[8]
800096b6:	10 95       	mov	r5,r8
800096b8:	12 98       	mov	r8,r9
800096ba:	0a 99       	mov	r9,r5
800096bc:	e0 a0 0f 0a 	rcall	8000b4d0 <__avr32_f64_cmp_lt>
800096c0:	e0 81 02 3e 	brne	80009b3c <_dtoa_r+0x95c>
800096c4:	ca 68       	rjmp	80009810 <_dtoa_r+0x630>
800096c6:	4c e9       	lddpc	r9,800097fc <_dtoa_r+0x61c>
800096c8:	e8 c8 00 01 	sub	r8,r4,1
800096cc:	40 d5       	lddsp	r5,sp[0x34]
800096ce:	58 05       	cp.w	r5,0
800096d0:	c4 f0       	breq	8000976e <_dtoa_r+0x58e>
800096d2:	30 0c       	mov	r12,0
800096d4:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
800096d8:	51 3c       	stdsp	sp[0x4c],r12
800096da:	30 0a       	mov	r10,0
800096dc:	fc 1b 3f e0 	movh	r11,0x3fe0
800096e0:	e0 a0 0f 2c 	rcall	8000b538 <__avr32_f64_div>
800096e4:	fa e8 00 28 	ld.d	r8,sp[40]
800096e8:	40 85       	lddsp	r5,sp[0x20]
800096ea:	e0 a0 0c cd 	rcall	8000b084 <__avr32_f64_sub>
800096ee:	fa eb 00 28 	st.d	sp[40],r10
800096f2:	fa ea 00 08 	ld.d	r10,sp[8]
800096f6:	e0 a0 0e 1f 	rcall	8000b334 <__avr32_f64_to_s32>
800096fa:	51 6c       	stdsp	sp[0x58],r12
800096fc:	e0 a0 0e 33 	rcall	8000b362 <__avr32_s32_to_f64>
80009700:	14 98       	mov	r8,r10
80009702:	16 99       	mov	r9,r11
80009704:	fa ea 00 08 	ld.d	r10,sp[8]
80009708:	e0 a0 0c be 	rcall	8000b084 <__avr32_f64_sub>
8000970c:	fa eb 00 08 	st.d	sp[8],r10
80009710:	41 68       	lddsp	r8,sp[0x58]
80009712:	2d 08       	sub	r8,-48
80009714:	0a c8       	st.b	r5++,r8
80009716:	41 39       	lddsp	r9,sp[0x4c]
80009718:	2f f9       	sub	r9,-1
8000971a:	51 39       	stdsp	sp[0x4c],r9
8000971c:	fa e8 00 28 	ld.d	r8,sp[40]
80009720:	e0 a0 0e d8 	rcall	8000b4d0 <__avr32_f64_cmp_lt>
80009724:	e0 81 03 3a 	brne	80009d98 <_dtoa_r+0xbb8>
80009728:	fa e8 00 08 	ld.d	r8,sp[8]
8000972c:	30 0a       	mov	r10,0
8000972e:	fc 1b 3f f0 	movh	r11,0x3ff0
80009732:	e0 a0 0c a9 	rcall	8000b084 <__avr32_f64_sub>
80009736:	fa e8 00 28 	ld.d	r8,sp[40]
8000973a:	e0 a0 0e cb 	rcall	8000b4d0 <__avr32_f64_cmp_lt>
8000973e:	fa ea 00 28 	ld.d	r10,sp[40]
80009742:	30 08       	mov	r8,0
80009744:	fc 19 40 24 	movh	r9,0x4024
80009748:	e0 81 00 da 	brne	800098fc <_dtoa_r+0x71c>
8000974c:	41 3c       	lddsp	r12,sp[0x4c]
8000974e:	08 3c       	cp.w	r12,r4
80009750:	c6 04       	brge	80009810 <_dtoa_r+0x630>
80009752:	e0 a0 0b ad 	rcall	8000aeac <__avr32_f64_mul>
80009756:	30 08       	mov	r8,0
80009758:	fa eb 00 28 	st.d	sp[40],r10
8000975c:	fc 19 40 24 	movh	r9,0x4024
80009760:	fa ea 00 08 	ld.d	r10,sp[8]
80009764:	e0 a0 0b a4 	rcall	8000aeac <__avr32_f64_mul>
80009768:	fa eb 00 08 	st.d	sp[8],r10
8000976c:	cc 3b       	rjmp	800096f2 <_dtoa_r+0x512>
8000976e:	40 85       	lddsp	r5,sp[0x20]
80009770:	08 05       	add	r5,r4
80009772:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009776:	51 35       	stdsp	sp[0x4c],r5
80009778:	fa e8 00 28 	ld.d	r8,sp[40]
8000977c:	40 85       	lddsp	r5,sp[0x20]
8000977e:	e0 a0 0b 97 	rcall	8000aeac <__avr32_f64_mul>
80009782:	fa eb 00 28 	st.d	sp[40],r10
80009786:	fa ea 00 08 	ld.d	r10,sp[8]
8000978a:	e0 a0 0d d5 	rcall	8000b334 <__avr32_f64_to_s32>
8000978e:	51 6c       	stdsp	sp[0x58],r12
80009790:	e0 a0 0d e9 	rcall	8000b362 <__avr32_s32_to_f64>
80009794:	14 98       	mov	r8,r10
80009796:	16 99       	mov	r9,r11
80009798:	fa ea 00 08 	ld.d	r10,sp[8]
8000979c:	e0 a0 0c 74 	rcall	8000b084 <__avr32_f64_sub>
800097a0:	fa eb 00 08 	st.d	sp[8],r10
800097a4:	41 68       	lddsp	r8,sp[0x58]
800097a6:	2d 08       	sub	r8,-48
800097a8:	0a c8       	st.b	r5++,r8
800097aa:	41 3c       	lddsp	r12,sp[0x4c]
800097ac:	18 35       	cp.w	r5,r12
800097ae:	c2 91       	brne	80009800 <_dtoa_r+0x620>
800097b0:	30 08       	mov	r8,0
800097b2:	fc 19 3f e0 	movh	r9,0x3fe0
800097b6:	fa ea 00 28 	ld.d	r10,sp[40]
800097ba:	e0 a0 0d 33 	rcall	8000b220 <__avr32_f64_add>
800097be:	40 85       	lddsp	r5,sp[0x20]
800097c0:	fa e8 00 08 	ld.d	r8,sp[8]
800097c4:	08 05       	add	r5,r4
800097c6:	e0 a0 0e 85 	rcall	8000b4d0 <__avr32_f64_cmp_lt>
800097ca:	e0 81 00 99 	brne	800098fc <_dtoa_r+0x71c>
800097ce:	fa e8 00 28 	ld.d	r8,sp[40]
800097d2:	30 0a       	mov	r10,0
800097d4:	fc 1b 3f e0 	movh	r11,0x3fe0
800097d8:	e0 a0 0c 56 	rcall	8000b084 <__avr32_f64_sub>
800097dc:	14 98       	mov	r8,r10
800097de:	16 99       	mov	r9,r11
800097e0:	fa ea 00 08 	ld.d	r10,sp[8]
800097e4:	e0 a0 0e 76 	rcall	8000b4d0 <__avr32_f64_cmp_lt>
800097e8:	c1 40       	breq	80009810 <_dtoa_r+0x630>
800097ea:	33 09       	mov	r9,48
800097ec:	0a 98       	mov	r8,r5
800097ee:	11 7a       	ld.ub	r10,--r8
800097f0:	f2 0a 18 00 	cp.b	r10,r9
800097f4:	e0 81 02 d2 	brne	80009d98 <_dtoa_r+0xbb8>
800097f8:	10 95       	mov	r5,r8
800097fa:	cf 9b       	rjmp	800097ec <_dtoa_r+0x60c>
800097fc:	80 01       	ld.sh	r1,r0[0x0]
800097fe:	54 64       	stdsp	sp[0x118],r4
80009800:	30 08       	mov	r8,0
80009802:	fc 19 40 24 	movh	r9,0x4024
80009806:	e0 a0 0b 53 	rcall	8000aeac <__avr32_f64_mul>
8000980a:	fa eb 00 08 	st.d	sp[8],r10
8000980e:	cb cb       	rjmp	80009786 <_dtoa_r+0x5a6>
80009810:	fa ea 00 3c 	ld.d	r10,sp[60]
80009814:	fa eb 00 08 	st.d	sp[8],r10
80009818:	58 e6       	cp.w	r6,14
8000981a:	5f ab       	srle	r11
8000981c:	41 8a       	lddsp	r10,sp[0x60]
8000981e:	30 08       	mov	r8,0
80009820:	f4 09 11 ff 	rsub	r9,r10,-1
80009824:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80009828:	f0 09 18 00 	cp.b	r9,r8
8000982c:	e0 80 00 81 	breq	8000992e <_dtoa_r+0x74e>
80009830:	40 ea       	lddsp	r10,sp[0x38]
80009832:	58 01       	cp.w	r1,0
80009834:	5f a9       	srle	r9
80009836:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000983a:	4c 9a       	lddpc	r10,8000995c <_dtoa_r+0x77c>
8000983c:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
80009840:	fa e5 00 10 	st.d	sp[16],r4
80009844:	f0 09 18 00 	cp.b	r9,r8
80009848:	c1 40       	breq	80009870 <_dtoa_r+0x690>
8000984a:	58 01       	cp.w	r1,0
8000984c:	e0 81 01 78 	brne	80009b3c <_dtoa_r+0x95c>
80009850:	30 08       	mov	r8,0
80009852:	fc 19 40 14 	movh	r9,0x4014
80009856:	08 9a       	mov	r10,r4
80009858:	0a 9b       	mov	r11,r5
8000985a:	e0 a0 0b 29 	rcall	8000aeac <__avr32_f64_mul>
8000985e:	fa e8 00 08 	ld.d	r8,sp[8]
80009862:	e0 a0 0e 03 	rcall	8000b468 <__avr32_f64_cmp_ge>
80009866:	e0 81 01 6b 	brne	80009b3c <_dtoa_r+0x95c>
8000986a:	02 92       	mov	r2,r1
8000986c:	e0 8f 01 73 	bral	80009b52 <_dtoa_r+0x972>
80009870:	40 85       	lddsp	r5,sp[0x20]
80009872:	30 14       	mov	r4,1
80009874:	fa e8 00 10 	ld.d	r8,sp[16]
80009878:	fa ea 00 08 	ld.d	r10,sp[8]
8000987c:	e0 a0 0e 5e 	rcall	8000b538 <__avr32_f64_div>
80009880:	e0 a0 0d 5a 	rcall	8000b334 <__avr32_f64_to_s32>
80009884:	18 92       	mov	r2,r12
80009886:	e0 a0 0d 6e 	rcall	8000b362 <__avr32_s32_to_f64>
8000988a:	fa e8 00 10 	ld.d	r8,sp[16]
8000988e:	e0 a0 0b 0f 	rcall	8000aeac <__avr32_f64_mul>
80009892:	14 98       	mov	r8,r10
80009894:	16 99       	mov	r9,r11
80009896:	fa ea 00 08 	ld.d	r10,sp[8]
8000989a:	e0 a0 0b f5 	rcall	8000b084 <__avr32_f64_sub>
8000989e:	fa eb 00 08 	st.d	sp[8],r10
800098a2:	e4 c8 ff d0 	sub	r8,r2,-48
800098a6:	0a c8       	st.b	r5++,r8
800098a8:	fc 19 40 24 	movh	r9,0x4024
800098ac:	30 08       	mov	r8,0
800098ae:	02 34       	cp.w	r4,r1
800098b0:	c3 31       	brne	80009916 <_dtoa_r+0x736>
800098b2:	fa e8 00 08 	ld.d	r8,sp[8]
800098b6:	e0 a0 0c b5 	rcall	8000b220 <__avr32_f64_add>
800098ba:	16 91       	mov	r1,r11
800098bc:	14 90       	mov	r0,r10
800098be:	14 98       	mov	r8,r10
800098c0:	02 99       	mov	r9,r1
800098c2:	fa ea 00 10 	ld.d	r10,sp[16]
800098c6:	e0 a0 0e 05 	rcall	8000b4d0 <__avr32_f64_cmp_lt>
800098ca:	c1 a1       	brne	800098fe <_dtoa_r+0x71e>
800098cc:	fa e8 00 10 	ld.d	r8,sp[16]
800098d0:	00 9a       	mov	r10,r0
800098d2:	02 9b       	mov	r11,r1
800098d4:	e0 a0 0d b7 	rcall	8000b442 <__avr32_f64_cmp_eq>
800098d8:	e0 80 02 5f 	breq	80009d96 <_dtoa_r+0xbb6>
800098dc:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
800098e0:	c0 f1       	brne	800098fe <_dtoa_r+0x71e>
800098e2:	e0 8f 02 5a 	bral	80009d96 <_dtoa_r+0xbb6>
800098e6:	40 8a       	lddsp	r10,sp[0x20]
800098e8:	14 38       	cp.w	r8,r10
800098ea:	c0 30       	breq	800098f0 <_dtoa_r+0x710>
800098ec:	10 95       	mov	r5,r8
800098ee:	c0 98       	rjmp	80009900 <_dtoa_r+0x720>
800098f0:	33 08       	mov	r8,48
800098f2:	40 89       	lddsp	r9,sp[0x20]
800098f4:	2f f6       	sub	r6,-1
800098f6:	b2 88       	st.b	r9[0x0],r8
800098f8:	40 88       	lddsp	r8,sp[0x20]
800098fa:	c0 88       	rjmp	8000990a <_dtoa_r+0x72a>
800098fc:	40 66       	lddsp	r6,sp[0x18]
800098fe:	33 99       	mov	r9,57
80009900:	0a 98       	mov	r8,r5
80009902:	11 7a       	ld.ub	r10,--r8
80009904:	f2 0a 18 00 	cp.b	r10,r9
80009908:	ce f0       	breq	800098e6 <_dtoa_r+0x706>
8000990a:	50 66       	stdsp	sp[0x18],r6
8000990c:	11 89       	ld.ub	r9,r8[0x0]
8000990e:	2f f9       	sub	r9,-1
80009910:	b0 89       	st.b	r8[0x0],r9
80009912:	e0 8f 02 43 	bral	80009d98 <_dtoa_r+0xbb8>
80009916:	e0 a0 0a cb 	rcall	8000aeac <__avr32_f64_mul>
8000991a:	2f f4       	sub	r4,-1
8000991c:	fa eb 00 08 	st.d	sp[8],r10
80009920:	30 08       	mov	r8,0
80009922:	30 09       	mov	r9,0
80009924:	e0 a0 0d 8f 	rcall	8000b442 <__avr32_f64_cmp_eq>
80009928:	ca 60       	breq	80009874 <_dtoa_r+0x694>
8000992a:	e0 8f 02 36 	bral	80009d96 <_dtoa_r+0xbb6>
8000992e:	40 d8       	lddsp	r8,sp[0x34]
80009930:	58 08       	cp.w	r8,0
80009932:	c0 51       	brne	8000993c <_dtoa_r+0x75c>
80009934:	04 98       	mov	r8,r2
80009936:	00 95       	mov	r5,r0
80009938:	40 d4       	lddsp	r4,sp[0x34]
8000993a:	c3 88       	rjmp	800099aa <_dtoa_r+0x7ca>
8000993c:	40 c5       	lddsp	r5,sp[0x30]
8000993e:	58 15       	cp.w	r5,1
80009940:	e0 89 00 10 	brgt	80009960 <_dtoa_r+0x780>
80009944:	41 74       	lddsp	r4,sp[0x5c]
80009946:	58 04       	cp.w	r4,0
80009948:	c0 40       	breq	80009950 <_dtoa_r+0x770>
8000994a:	f4 c9 fb cd 	sub	r9,r10,-1075
8000994e:	c0 48       	rjmp	80009956 <_dtoa_r+0x776>
80009950:	41 99       	lddsp	r9,sp[0x64]
80009952:	f2 09 11 36 	rsub	r9,r9,54
80009956:	04 98       	mov	r8,r2
80009958:	00 95       	mov	r5,r0
8000995a:	c1 d8       	rjmp	80009994 <_dtoa_r+0x7b4>
8000995c:	80 01       	ld.sh	r1,r0[0x0]
8000995e:	54 64       	stdsp	sp[0x118],r4
80009960:	e2 c8 00 01 	sub	r8,r1,1
80009964:	58 01       	cp.w	r1,0
80009966:	e0 05 17 40 	movge	r5,r0
8000996a:	e2 09 17 40 	movge	r9,r1
8000996e:	e1 d1 e5 15 	sublt	r5,r0,r1
80009972:	f9 b9 05 00 	movlt	r9,0
80009976:	10 32       	cp.w	r2,r8
80009978:	e5 d8 e4 18 	subge	r8,r2,r8
8000997c:	f1 d2 e5 18 	sublt	r8,r8,r2
80009980:	e5 d8 e5 02 	addlt	r2,r2,r8
80009984:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80009988:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000998c:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80009990:	f9 b8 05 00 	movlt	r8,0
80009994:	40 4b       	lddsp	r11,sp[0x10]
80009996:	12 0b       	add	r11,r9
80009998:	50 08       	stdsp	sp[0x0],r8
8000999a:	50 4b       	stdsp	sp[0x10],r11
8000999c:	12 00       	add	r0,r9
8000999e:	30 1b       	mov	r11,1
800099a0:	0e 9c       	mov	r12,r7
800099a2:	e0 a0 08 ab 	rcall	8000aaf8 <__i2b>
800099a6:	40 08       	lddsp	r8,sp[0x0]
800099a8:	18 94       	mov	r4,r12
800099aa:	40 4a       	lddsp	r10,sp[0x10]
800099ac:	58 05       	cp.w	r5,0
800099ae:	5f 99       	srgt	r9
800099b0:	58 0a       	cp.w	r10,0
800099b2:	5f 9a       	srgt	r10
800099b4:	f5 e9 00 09 	and	r9,r10,r9
800099b8:	c0 80       	breq	800099c8 <_dtoa_r+0x7e8>
800099ba:	40 4c       	lddsp	r12,sp[0x10]
800099bc:	f8 05 0d 49 	min	r9,r12,r5
800099c0:	12 1c       	sub	r12,r9
800099c2:	12 10       	sub	r0,r9
800099c4:	50 4c       	stdsp	sp[0x10],r12
800099c6:	12 15       	sub	r5,r9
800099c8:	58 02       	cp.w	r2,0
800099ca:	e0 8a 00 27 	brle	80009a18 <_dtoa_r+0x838>
800099ce:	40 db       	lddsp	r11,sp[0x34]
800099d0:	58 0b       	cp.w	r11,0
800099d2:	c1 d0       	breq	80009a0c <_dtoa_r+0x82c>
800099d4:	58 08       	cp.w	r8,0
800099d6:	e0 8a 00 17 	brle	80009a04 <_dtoa_r+0x824>
800099da:	10 9a       	mov	r10,r8
800099dc:	50 08       	stdsp	sp[0x0],r8
800099de:	08 9b       	mov	r11,r4
800099e0:	0e 9c       	mov	r12,r7
800099e2:	e0 a0 08 d1 	rcall	8000ab84 <__pow5mult>
800099e6:	06 9a       	mov	r10,r3
800099e8:	18 9b       	mov	r11,r12
800099ea:	18 94       	mov	r4,r12
800099ec:	0e 9c       	mov	r12,r7
800099ee:	e0 a0 08 05 	rcall	8000a9f8 <__multiply>
800099f2:	18 99       	mov	r9,r12
800099f4:	06 9b       	mov	r11,r3
800099f6:	50 19       	stdsp	sp[0x4],r9
800099f8:	0e 9c       	mov	r12,r7
800099fa:	e0 a0 06 b1 	rcall	8000a75c <_Bfree>
800099fe:	40 19       	lddsp	r9,sp[0x4]
80009a00:	40 08       	lddsp	r8,sp[0x0]
80009a02:	12 93       	mov	r3,r9
80009a04:	e4 08 01 0a 	sub	r10,r2,r8
80009a08:	c0 80       	breq	80009a18 <_dtoa_r+0x838>
80009a0a:	c0 28       	rjmp	80009a0e <_dtoa_r+0x82e>
80009a0c:	04 9a       	mov	r10,r2
80009a0e:	06 9b       	mov	r11,r3
80009a10:	0e 9c       	mov	r12,r7
80009a12:	e0 a0 08 b9 	rcall	8000ab84 <__pow5mult>
80009a16:	18 93       	mov	r3,r12
80009a18:	30 1b       	mov	r11,1
80009a1a:	0e 9c       	mov	r12,r7
80009a1c:	e0 a0 08 6e 	rcall	8000aaf8 <__i2b>
80009a20:	41 1a       	lddsp	r10,sp[0x44]
80009a22:	18 92       	mov	r2,r12
80009a24:	58 0a       	cp.w	r10,0
80009a26:	e0 8a 00 07 	brle	80009a34 <_dtoa_r+0x854>
80009a2a:	18 9b       	mov	r11,r12
80009a2c:	0e 9c       	mov	r12,r7
80009a2e:	e0 a0 08 ab 	rcall	8000ab84 <__pow5mult>
80009a32:	18 92       	mov	r2,r12
80009a34:	40 c9       	lddsp	r9,sp[0x30]
80009a36:	58 19       	cp.w	r9,1
80009a38:	e0 89 00 14 	brgt	80009a60 <_dtoa_r+0x880>
80009a3c:	40 38       	lddsp	r8,sp[0xc]
80009a3e:	58 08       	cp.w	r8,0
80009a40:	c1 01       	brne	80009a60 <_dtoa_r+0x880>
80009a42:	40 29       	lddsp	r9,sp[0x8]
80009a44:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80009a48:	c0 c1       	brne	80009a60 <_dtoa_r+0x880>
80009a4a:	12 98       	mov	r8,r9
80009a4c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009a50:	c0 80       	breq	80009a60 <_dtoa_r+0x880>
80009a52:	40 4c       	lddsp	r12,sp[0x10]
80009a54:	30 1b       	mov	r11,1
80009a56:	2f fc       	sub	r12,-1
80009a58:	2f f0       	sub	r0,-1
80009a5a:	50 4c       	stdsp	sp[0x10],r12
80009a5c:	50 6b       	stdsp	sp[0x18],r11
80009a5e:	c0 38       	rjmp	80009a64 <_dtoa_r+0x884>
80009a60:	30 0a       	mov	r10,0
80009a62:	50 6a       	stdsp	sp[0x18],r10
80009a64:	41 19       	lddsp	r9,sp[0x44]
80009a66:	58 09       	cp.w	r9,0
80009a68:	c0 31       	brne	80009a6e <_dtoa_r+0x88e>
80009a6a:	30 1c       	mov	r12,1
80009a6c:	c0 98       	rjmp	80009a7e <_dtoa_r+0x89e>
80009a6e:	64 48       	ld.w	r8,r2[0x10]
80009a70:	2f c8       	sub	r8,-4
80009a72:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
80009a76:	e0 a0 05 e3 	rcall	8000a63c <__hi0bits>
80009a7a:	f8 0c 11 20 	rsub	r12,r12,32
80009a7e:	40 4b       	lddsp	r11,sp[0x10]
80009a80:	f8 0b 00 08 	add	r8,r12,r11
80009a84:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80009a88:	c0 c0       	breq	80009aa0 <_dtoa_r+0x8c0>
80009a8a:	f0 08 11 20 	rsub	r8,r8,32
80009a8e:	58 48       	cp.w	r8,4
80009a90:	e0 8a 00 06 	brle	80009a9c <_dtoa_r+0x8bc>
80009a94:	20 48       	sub	r8,4
80009a96:	10 0b       	add	r11,r8
80009a98:	50 4b       	stdsp	sp[0x10],r11
80009a9a:	c0 78       	rjmp	80009aa8 <_dtoa_r+0x8c8>
80009a9c:	58 48       	cp.w	r8,4
80009a9e:	c0 70       	breq	80009aac <_dtoa_r+0x8cc>
80009aa0:	40 4a       	lddsp	r10,sp[0x10]
80009aa2:	2e 48       	sub	r8,-28
80009aa4:	10 0a       	add	r10,r8
80009aa6:	50 4a       	stdsp	sp[0x10],r10
80009aa8:	10 00       	add	r0,r8
80009aaa:	10 05       	add	r5,r8
80009aac:	58 00       	cp.w	r0,0
80009aae:	e0 8a 00 08 	brle	80009abe <_dtoa_r+0x8de>
80009ab2:	06 9b       	mov	r11,r3
80009ab4:	00 9a       	mov	r10,r0
80009ab6:	0e 9c       	mov	r12,r7
80009ab8:	e0 a0 07 5c 	rcall	8000a970 <__lshift>
80009abc:	18 93       	mov	r3,r12
80009abe:	40 49       	lddsp	r9,sp[0x10]
80009ac0:	58 09       	cp.w	r9,0
80009ac2:	e0 8a 00 08 	brle	80009ad2 <_dtoa_r+0x8f2>
80009ac6:	04 9b       	mov	r11,r2
80009ac8:	12 9a       	mov	r10,r9
80009aca:	0e 9c       	mov	r12,r7
80009acc:	e0 a0 07 52 	rcall	8000a970 <__lshift>
80009ad0:	18 92       	mov	r2,r12
80009ad2:	41 48       	lddsp	r8,sp[0x50]
80009ad4:	58 08       	cp.w	r8,0
80009ad6:	c1 b0       	breq	80009b0c <_dtoa_r+0x92c>
80009ad8:	04 9b       	mov	r11,r2
80009ada:	06 9c       	mov	r12,r3
80009adc:	e0 a0 06 27 	rcall	8000a72a <__mcmp>
80009ae0:	c1 64       	brge	80009b0c <_dtoa_r+0x92c>
80009ae2:	06 9b       	mov	r11,r3
80009ae4:	30 09       	mov	r9,0
80009ae6:	30 aa       	mov	r10,10
80009ae8:	0e 9c       	mov	r12,r7
80009aea:	e0 a0 08 0f 	rcall	8000ab08 <__multadd>
80009aee:	20 16       	sub	r6,1
80009af0:	18 93       	mov	r3,r12
80009af2:	40 dc       	lddsp	r12,sp[0x34]
80009af4:	58 0c       	cp.w	r12,0
80009af6:	c0 31       	brne	80009afc <_dtoa_r+0x91c>
80009af8:	40 91       	lddsp	r1,sp[0x24]
80009afa:	c0 98       	rjmp	80009b0c <_dtoa_r+0x92c>
80009afc:	08 9b       	mov	r11,r4
80009afe:	40 91       	lddsp	r1,sp[0x24]
80009b00:	30 09       	mov	r9,0
80009b02:	30 aa       	mov	r10,10
80009b04:	0e 9c       	mov	r12,r7
80009b06:	e0 a0 08 01 	rcall	8000ab08 <__multadd>
80009b0a:	18 94       	mov	r4,r12
80009b0c:	58 01       	cp.w	r1,0
80009b0e:	5f a9       	srle	r9
80009b10:	40 cb       	lddsp	r11,sp[0x30]
80009b12:	58 2b       	cp.w	r11,2
80009b14:	5f 98       	srgt	r8
80009b16:	f3 e8 00 08 	and	r8,r9,r8
80009b1a:	c2 50       	breq	80009b64 <_dtoa_r+0x984>
80009b1c:	58 01       	cp.w	r1,0
80009b1e:	c1 11       	brne	80009b40 <_dtoa_r+0x960>
80009b20:	04 9b       	mov	r11,r2
80009b22:	02 99       	mov	r9,r1
80009b24:	30 5a       	mov	r10,5
80009b26:	0e 9c       	mov	r12,r7
80009b28:	e0 a0 07 f0 	rcall	8000ab08 <__multadd>
80009b2c:	18 92       	mov	r2,r12
80009b2e:	18 9b       	mov	r11,r12
80009b30:	06 9c       	mov	r12,r3
80009b32:	e0 a0 05 fc 	rcall	8000a72a <__mcmp>
80009b36:	e0 89 00 0f 	brgt	80009b54 <_dtoa_r+0x974>
80009b3a:	c0 38       	rjmp	80009b40 <_dtoa_r+0x960>
80009b3c:	30 02       	mov	r2,0
80009b3e:	04 94       	mov	r4,r2
80009b40:	40 ea       	lddsp	r10,sp[0x38]
80009b42:	30 09       	mov	r9,0
80009b44:	5c da       	com	r10
80009b46:	40 85       	lddsp	r5,sp[0x20]
80009b48:	50 6a       	stdsp	sp[0x18],r10
80009b4a:	50 49       	stdsp	sp[0x10],r9
80009b4c:	c0 f9       	rjmp	80009d6a <_dtoa_r+0xb8a>
80009b4e:	08 92       	mov	r2,r4
80009b50:	40 66       	lddsp	r6,sp[0x18]
80009b52:	04 94       	mov	r4,r2
80009b54:	2f f6       	sub	r6,-1
80009b56:	50 66       	stdsp	sp[0x18],r6
80009b58:	33 18       	mov	r8,49
80009b5a:	40 85       	lddsp	r5,sp[0x20]
80009b5c:	0a c8       	st.b	r5++,r8
80009b5e:	30 08       	mov	r8,0
80009b60:	50 48       	stdsp	sp[0x10],r8
80009b62:	c0 49       	rjmp	80009d6a <_dtoa_r+0xb8a>
80009b64:	40 dc       	lddsp	r12,sp[0x34]
80009b66:	58 0c       	cp.w	r12,0
80009b68:	e0 80 00 b5 	breq	80009cd2 <_dtoa_r+0xaf2>
80009b6c:	58 05       	cp.w	r5,0
80009b6e:	e0 8a 00 08 	brle	80009b7e <_dtoa_r+0x99e>
80009b72:	08 9b       	mov	r11,r4
80009b74:	0a 9a       	mov	r10,r5
80009b76:	0e 9c       	mov	r12,r7
80009b78:	e0 a0 06 fc 	rcall	8000a970 <__lshift>
80009b7c:	18 94       	mov	r4,r12
80009b7e:	40 6b       	lddsp	r11,sp[0x18]
80009b80:	58 0b       	cp.w	r11,0
80009b82:	c0 31       	brne	80009b88 <_dtoa_r+0x9a8>
80009b84:	08 9c       	mov	r12,r4
80009b86:	c1 38       	rjmp	80009bac <_dtoa_r+0x9cc>
80009b88:	68 1b       	ld.w	r11,r4[0x4]
80009b8a:	0e 9c       	mov	r12,r7
80009b8c:	e0 a0 06 02 	rcall	8000a790 <_Balloc>
80009b90:	68 4a       	ld.w	r10,r4[0x10]
80009b92:	18 95       	mov	r5,r12
80009b94:	e8 cb ff f4 	sub	r11,r4,-12
80009b98:	2f ea       	sub	r10,-2
80009b9a:	2f 4c       	sub	r12,-12
80009b9c:	a3 6a       	lsl	r10,0x2
80009b9e:	fe b0 e6 25 	rcall	800067e8 <memcpy>
80009ba2:	0a 9b       	mov	r11,r5
80009ba4:	30 1a       	mov	r10,1
80009ba6:	0e 9c       	mov	r12,r7
80009ba8:	e0 a0 06 e4 	rcall	8000a970 <__lshift>
80009bac:	50 44       	stdsp	sp[0x10],r4
80009bae:	40 3a       	lddsp	r10,sp[0xc]
80009bb0:	30 19       	mov	r9,1
80009bb2:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80009bb6:	18 94       	mov	r4,r12
80009bb8:	50 da       	stdsp	sp[0x34],r10
80009bba:	40 85       	lddsp	r5,sp[0x20]
80009bbc:	50 99       	stdsp	sp[0x24],r9
80009bbe:	50 26       	stdsp	sp[0x8],r6
80009bc0:	50 e1       	stdsp	sp[0x38],r1
80009bc2:	04 9b       	mov	r11,r2
80009bc4:	06 9c       	mov	r12,r3
80009bc6:	fe b0 fa 7d 	rcall	800090c0 <quorem>
80009bca:	40 4b       	lddsp	r11,sp[0x10]
80009bcc:	f8 c0 ff d0 	sub	r0,r12,-48
80009bd0:	06 9c       	mov	r12,r3
80009bd2:	e0 a0 05 ac 	rcall	8000a72a <__mcmp>
80009bd6:	08 9a       	mov	r10,r4
80009bd8:	50 6c       	stdsp	sp[0x18],r12
80009bda:	04 9b       	mov	r11,r2
80009bdc:	0e 9c       	mov	r12,r7
80009bde:	e0 a0 06 61 	rcall	8000a8a0 <__mdiff>
80009be2:	18 91       	mov	r1,r12
80009be4:	78 38       	ld.w	r8,r12[0xc]
80009be6:	58 08       	cp.w	r8,0
80009be8:	c0 30       	breq	80009bee <_dtoa_r+0xa0e>
80009bea:	30 16       	mov	r6,1
80009bec:	c0 68       	rjmp	80009bf8 <_dtoa_r+0xa18>
80009bee:	18 9b       	mov	r11,r12
80009bf0:	06 9c       	mov	r12,r3
80009bf2:	e0 a0 05 9c 	rcall	8000a72a <__mcmp>
80009bf6:	18 96       	mov	r6,r12
80009bf8:	0e 9c       	mov	r12,r7
80009bfa:	02 9b       	mov	r11,r1
80009bfc:	e0 a0 05 b0 	rcall	8000a75c <_Bfree>
80009c00:	40 cc       	lddsp	r12,sp[0x30]
80009c02:	ed ec 10 08 	or	r8,r6,r12
80009c06:	c0 d1       	brne	80009c20 <_dtoa_r+0xa40>
80009c08:	40 db       	lddsp	r11,sp[0x34]
80009c0a:	58 0b       	cp.w	r11,0
80009c0c:	c0 a1       	brne	80009c20 <_dtoa_r+0xa40>
80009c0e:	40 26       	lddsp	r6,sp[0x8]
80009c10:	e0 40 00 39 	cp.w	r0,57
80009c14:	c3 00       	breq	80009c74 <_dtoa_r+0xa94>
80009c16:	40 6a       	lddsp	r10,sp[0x18]
80009c18:	58 0a       	cp.w	r10,0
80009c1a:	e0 89 00 24 	brgt	80009c62 <_dtoa_r+0xa82>
80009c1e:	c2 f8       	rjmp	80009c7c <_dtoa_r+0xa9c>
80009c20:	40 69       	lddsp	r9,sp[0x18]
80009c22:	58 09       	cp.w	r9,0
80009c24:	c0 85       	brlt	80009c34 <_dtoa_r+0xa54>
80009c26:	12 98       	mov	r8,r9
80009c28:	40 cc       	lddsp	r12,sp[0x30]
80009c2a:	18 48       	or	r8,r12
80009c2c:	c1 d1       	brne	80009c66 <_dtoa_r+0xa86>
80009c2e:	40 db       	lddsp	r11,sp[0x34]
80009c30:	58 0b       	cp.w	r11,0
80009c32:	c1 a1       	brne	80009c66 <_dtoa_r+0xa86>
80009c34:	0c 99       	mov	r9,r6
80009c36:	40 26       	lddsp	r6,sp[0x8]
80009c38:	58 09       	cp.w	r9,0
80009c3a:	e0 8a 00 21 	brle	80009c7c <_dtoa_r+0xa9c>
80009c3e:	06 9b       	mov	r11,r3
80009c40:	30 1a       	mov	r10,1
80009c42:	0e 9c       	mov	r12,r7
80009c44:	e0 a0 06 96 	rcall	8000a970 <__lshift>
80009c48:	04 9b       	mov	r11,r2
80009c4a:	18 93       	mov	r3,r12
80009c4c:	e0 a0 05 6f 	rcall	8000a72a <__mcmp>
80009c50:	e0 89 00 06 	brgt	80009c5c <_dtoa_r+0xa7c>
80009c54:	c1 41       	brne	80009c7c <_dtoa_r+0xa9c>
80009c56:	ed b0 00 00 	bld	r0,0x0
80009c5a:	c1 11       	brne	80009c7c <_dtoa_r+0xa9c>
80009c5c:	e0 40 00 39 	cp.w	r0,57
80009c60:	c0 a0       	breq	80009c74 <_dtoa_r+0xa94>
80009c62:	2f f0       	sub	r0,-1
80009c64:	c0 c8       	rjmp	80009c7c <_dtoa_r+0xa9c>
80009c66:	58 06       	cp.w	r6,0
80009c68:	e0 8a 00 0c 	brle	80009c80 <_dtoa_r+0xaa0>
80009c6c:	40 26       	lddsp	r6,sp[0x8]
80009c6e:	e0 40 00 39 	cp.w	r0,57
80009c72:	c0 41       	brne	80009c7a <_dtoa_r+0xa9a>
80009c74:	33 98       	mov	r8,57
80009c76:	0a c8       	st.b	r5++,r8
80009c78:	c6 78       	rjmp	80009d46 <_dtoa_r+0xb66>
80009c7a:	2f f0       	sub	r0,-1
80009c7c:	0a c0       	st.b	r5++,r0
80009c7e:	c7 58       	rjmp	80009d68 <_dtoa_r+0xb88>
80009c80:	0a c0       	st.b	r5++,r0
80009c82:	40 9a       	lddsp	r10,sp[0x24]
80009c84:	40 e9       	lddsp	r9,sp[0x38]
80009c86:	12 3a       	cp.w	r10,r9
80009c88:	c4 30       	breq	80009d0e <_dtoa_r+0xb2e>
80009c8a:	06 9b       	mov	r11,r3
80009c8c:	30 09       	mov	r9,0
80009c8e:	30 aa       	mov	r10,10
80009c90:	0e 9c       	mov	r12,r7
80009c92:	e0 a0 07 3b 	rcall	8000ab08 <__multadd>
80009c96:	40 48       	lddsp	r8,sp[0x10]
80009c98:	18 93       	mov	r3,r12
80009c9a:	08 38       	cp.w	r8,r4
80009c9c:	c0 91       	brne	80009cae <_dtoa_r+0xace>
80009c9e:	10 9b       	mov	r11,r8
80009ca0:	30 09       	mov	r9,0
80009ca2:	30 aa       	mov	r10,10
80009ca4:	0e 9c       	mov	r12,r7
80009ca6:	e0 a0 07 31 	rcall	8000ab08 <__multadd>
80009caa:	50 4c       	stdsp	sp[0x10],r12
80009cac:	c0 e8       	rjmp	80009cc8 <_dtoa_r+0xae8>
80009cae:	40 4b       	lddsp	r11,sp[0x10]
80009cb0:	30 09       	mov	r9,0
80009cb2:	30 aa       	mov	r10,10
80009cb4:	0e 9c       	mov	r12,r7
80009cb6:	e0 a0 07 29 	rcall	8000ab08 <__multadd>
80009cba:	08 9b       	mov	r11,r4
80009cbc:	50 4c       	stdsp	sp[0x10],r12
80009cbe:	30 09       	mov	r9,0
80009cc0:	30 aa       	mov	r10,10
80009cc2:	0e 9c       	mov	r12,r7
80009cc4:	e0 a0 07 22 	rcall	8000ab08 <__multadd>
80009cc8:	18 94       	mov	r4,r12
80009cca:	40 9c       	lddsp	r12,sp[0x24]
80009ccc:	2f fc       	sub	r12,-1
80009cce:	50 9c       	stdsp	sp[0x24],r12
80009cd0:	c7 9b       	rjmp	80009bc2 <_dtoa_r+0x9e2>
80009cd2:	30 18       	mov	r8,1
80009cd4:	06 90       	mov	r0,r3
80009cd6:	40 85       	lddsp	r5,sp[0x20]
80009cd8:	08 93       	mov	r3,r4
80009cda:	0c 94       	mov	r4,r6
80009cdc:	10 96       	mov	r6,r8
80009cde:	04 9b       	mov	r11,r2
80009ce0:	00 9c       	mov	r12,r0
80009ce2:	fe b0 f9 ef 	rcall	800090c0 <quorem>
80009ce6:	2d 0c       	sub	r12,-48
80009ce8:	0a cc       	st.b	r5++,r12
80009cea:	02 36       	cp.w	r6,r1
80009cec:	c0 a4       	brge	80009d00 <_dtoa_r+0xb20>
80009cee:	00 9b       	mov	r11,r0
80009cf0:	30 09       	mov	r9,0
80009cf2:	30 aa       	mov	r10,10
80009cf4:	0e 9c       	mov	r12,r7
80009cf6:	2f f6       	sub	r6,-1
80009cf8:	e0 a0 07 08 	rcall	8000ab08 <__multadd>
80009cfc:	18 90       	mov	r0,r12
80009cfe:	cf 0b       	rjmp	80009cde <_dtoa_r+0xafe>
80009d00:	08 96       	mov	r6,r4
80009d02:	30 0b       	mov	r11,0
80009d04:	06 94       	mov	r4,r3
80009d06:	50 4b       	stdsp	sp[0x10],r11
80009d08:	00 93       	mov	r3,r0
80009d0a:	18 90       	mov	r0,r12
80009d0c:	c0 28       	rjmp	80009d10 <_dtoa_r+0xb30>
80009d0e:	40 26       	lddsp	r6,sp[0x8]
80009d10:	06 9b       	mov	r11,r3
80009d12:	30 1a       	mov	r10,1
80009d14:	0e 9c       	mov	r12,r7
80009d16:	e0 a0 06 2d 	rcall	8000a970 <__lshift>
80009d1a:	04 9b       	mov	r11,r2
80009d1c:	18 93       	mov	r3,r12
80009d1e:	e0 a0 05 06 	rcall	8000a72a <__mcmp>
80009d22:	e0 89 00 12 	brgt	80009d46 <_dtoa_r+0xb66>
80009d26:	c1 b1       	brne	80009d5c <_dtoa_r+0xb7c>
80009d28:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80009d2c:	c0 d1       	brne	80009d46 <_dtoa_r+0xb66>
80009d2e:	c1 78       	rjmp	80009d5c <_dtoa_r+0xb7c>
80009d30:	40 89       	lddsp	r9,sp[0x20]
80009d32:	12 38       	cp.w	r8,r9
80009d34:	c0 30       	breq	80009d3a <_dtoa_r+0xb5a>
80009d36:	10 95       	mov	r5,r8
80009d38:	c0 88       	rjmp	80009d48 <_dtoa_r+0xb68>
80009d3a:	2f f6       	sub	r6,-1
80009d3c:	50 66       	stdsp	sp[0x18],r6
80009d3e:	33 18       	mov	r8,49
80009d40:	40 8c       	lddsp	r12,sp[0x20]
80009d42:	b8 88       	st.b	r12[0x0],r8
80009d44:	c1 38       	rjmp	80009d6a <_dtoa_r+0xb8a>
80009d46:	33 9a       	mov	r10,57
80009d48:	0a 98       	mov	r8,r5
80009d4a:	11 79       	ld.ub	r9,--r8
80009d4c:	f4 09 18 00 	cp.b	r9,r10
80009d50:	cf 00       	breq	80009d30 <_dtoa_r+0xb50>
80009d52:	2f f9       	sub	r9,-1
80009d54:	b0 89       	st.b	r8[0x0],r9
80009d56:	c0 98       	rjmp	80009d68 <_dtoa_r+0xb88>
80009d58:	10 95       	mov	r5,r8
80009d5a:	c0 28       	rjmp	80009d5e <_dtoa_r+0xb7e>
80009d5c:	33 09       	mov	r9,48
80009d5e:	0a 98       	mov	r8,r5
80009d60:	11 7a       	ld.ub	r10,--r8
80009d62:	f2 0a 18 00 	cp.b	r10,r9
80009d66:	cf 90       	breq	80009d58 <_dtoa_r+0xb78>
80009d68:	50 66       	stdsp	sp[0x18],r6
80009d6a:	04 9b       	mov	r11,r2
80009d6c:	0e 9c       	mov	r12,r7
80009d6e:	e0 a0 04 f7 	rcall	8000a75c <_Bfree>
80009d72:	58 04       	cp.w	r4,0
80009d74:	c1 20       	breq	80009d98 <_dtoa_r+0xbb8>
80009d76:	40 4b       	lddsp	r11,sp[0x10]
80009d78:	08 3b       	cp.w	r11,r4
80009d7a:	5f 19       	srne	r9
80009d7c:	58 0b       	cp.w	r11,0
80009d7e:	5f 18       	srne	r8
80009d80:	f3 e8 00 08 	and	r8,r9,r8
80009d84:	c0 40       	breq	80009d8c <_dtoa_r+0xbac>
80009d86:	0e 9c       	mov	r12,r7
80009d88:	e0 a0 04 ea 	rcall	8000a75c <_Bfree>
80009d8c:	08 9b       	mov	r11,r4
80009d8e:	0e 9c       	mov	r12,r7
80009d90:	e0 a0 04 e6 	rcall	8000a75c <_Bfree>
80009d94:	c0 28       	rjmp	80009d98 <_dtoa_r+0xbb8>
80009d96:	50 66       	stdsp	sp[0x18],r6
80009d98:	0e 9c       	mov	r12,r7
80009d9a:	06 9b       	mov	r11,r3
80009d9c:	e0 a0 04 e0 	rcall	8000a75c <_Bfree>
80009da0:	30 08       	mov	r8,0
80009da2:	aa 88       	st.b	r5[0x0],r8
80009da4:	40 68       	lddsp	r8,sp[0x18]
80009da6:	41 5a       	lddsp	r10,sp[0x54]
80009da8:	2f f8       	sub	r8,-1
80009daa:	41 29       	lddsp	r9,sp[0x48]
80009dac:	95 08       	st.w	r10[0x0],r8
80009dae:	40 8c       	lddsp	r12,sp[0x20]
80009db0:	58 09       	cp.w	r9,0
80009db2:	fb f8 10 12 	ld.wne	r8,sp[0x48]
80009db6:	f1 f5 1a 00 	st.wne	r8[0x0],r5
80009dba:	2e 6d       	sub	sp,-104
80009dbc:	d8 32       	popm	r0-r7,pc
80009dbe:	d7 03       	nop

80009dc0 <__errno>:
80009dc0:	e0 68 0a 30 	mov	r8,2608
80009dc4:	70 0c       	ld.w	r12,r8[0x0]
80009dc6:	2f 4c       	sub	r12,-12
80009dc8:	5e fc       	retal	r12
80009dca:	d7 03       	nop

80009dcc <_fflush_r>:
80009dcc:	d4 21       	pushm	r4-r7,lr
80009dce:	16 97       	mov	r7,r11
80009dd0:	18 96       	mov	r6,r12
80009dd2:	76 48       	ld.w	r8,r11[0x10]
80009dd4:	58 08       	cp.w	r8,0
80009dd6:	c7 c0       	breq	80009ece <_fflush_r+0x102>
80009dd8:	58 0c       	cp.w	r12,0
80009dda:	c0 50       	breq	80009de4 <_fflush_r+0x18>
80009ddc:	78 68       	ld.w	r8,r12[0x18]
80009dde:	58 08       	cp.w	r8,0
80009de0:	c0 21       	brne	80009de4 <_fflush_r+0x18>
80009de2:	cd 1c       	rcall	80009f84 <__sinit>
80009de4:	4b b8       	lddpc	r8,80009ed0 <_fflush_r+0x104>
80009de6:	10 37       	cp.w	r7,r8
80009de8:	c0 31       	brne	80009dee <_fflush_r+0x22>
80009dea:	6c 07       	ld.w	r7,r6[0x0]
80009dec:	c0 a8       	rjmp	80009e00 <_fflush_r+0x34>
80009dee:	4b a8       	lddpc	r8,80009ed4 <_fflush_r+0x108>
80009df0:	10 37       	cp.w	r7,r8
80009df2:	c0 31       	brne	80009df8 <_fflush_r+0x2c>
80009df4:	6c 17       	ld.w	r7,r6[0x4]
80009df6:	c0 58       	rjmp	80009e00 <_fflush_r+0x34>
80009df8:	4b 88       	lddpc	r8,80009ed8 <_fflush_r+0x10c>
80009dfa:	10 37       	cp.w	r7,r8
80009dfc:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80009e00:	8e 6a       	ld.sh	r10,r7[0xc]
80009e02:	14 98       	mov	r8,r10
80009e04:	ed ba 00 03 	bld	r10,0x3
80009e08:	c4 20       	breq	80009e8c <_fflush_r+0xc0>
80009e0a:	ab ba       	sbr	r10,0xb
80009e0c:	ae 6a       	st.h	r7[0xc],r10
80009e0e:	6e 18       	ld.w	r8,r7[0x4]
80009e10:	58 08       	cp.w	r8,0
80009e12:	e0 89 00 06 	brgt	80009e1e <_fflush_r+0x52>
80009e16:	6f 08       	ld.w	r8,r7[0x40]
80009e18:	58 08       	cp.w	r8,0
80009e1a:	e0 8a 00 5a 	brle	80009ece <_fflush_r+0x102>
80009e1e:	6e b8       	ld.w	r8,r7[0x2c]
80009e20:	58 08       	cp.w	r8,0
80009e22:	c5 60       	breq	80009ece <_fflush_r+0x102>
80009e24:	e2 1a 10 00 	andl	r10,0x1000,COH
80009e28:	c0 30       	breq	80009e2e <_fflush_r+0x62>
80009e2a:	6f 55       	ld.w	r5,r7[0x54]
80009e2c:	c0 f8       	rjmp	80009e4a <_fflush_r+0x7e>
80009e2e:	30 19       	mov	r9,1
80009e30:	6e 8b       	ld.w	r11,r7[0x20]
80009e32:	0c 9c       	mov	r12,r6
80009e34:	5d 18       	icall	r8
80009e36:	18 95       	mov	r5,r12
80009e38:	5b fc       	cp.w	r12,-1
80009e3a:	c0 81       	brne	80009e4a <_fflush_r+0x7e>
80009e3c:	6c 38       	ld.w	r8,r6[0xc]
80009e3e:	59 d8       	cp.w	r8,29
80009e40:	c4 70       	breq	80009ece <_fflush_r+0x102>
80009e42:	8e 68       	ld.sh	r8,r7[0xc]
80009e44:	a7 a8       	sbr	r8,0x6
80009e46:	ae 68       	st.h	r7[0xc],r8
80009e48:	d8 22       	popm	r4-r7,pc
80009e4a:	8e 68       	ld.sh	r8,r7[0xc]
80009e4c:	ed b8 00 02 	bld	r8,0x2
80009e50:	c0 91       	brne	80009e62 <_fflush_r+0x96>
80009e52:	6e 18       	ld.w	r8,r7[0x4]
80009e54:	10 15       	sub	r5,r8
80009e56:	6e d8       	ld.w	r8,r7[0x34]
80009e58:	58 08       	cp.w	r8,0
80009e5a:	ef f8 10 10 	ld.wne	r8,r7[0x40]
80009e5e:	eb d8 e1 15 	subne	r5,r5,r8
80009e62:	6e b8       	ld.w	r8,r7[0x2c]
80009e64:	0c 9c       	mov	r12,r6
80009e66:	30 09       	mov	r9,0
80009e68:	0a 9a       	mov	r10,r5
80009e6a:	6e 8b       	ld.w	r11,r7[0x20]
80009e6c:	5d 18       	icall	r8
80009e6e:	8e 68       	ld.sh	r8,r7[0xc]
80009e70:	0a 3c       	cp.w	r12,r5
80009e72:	c2 61       	brne	80009ebe <_fflush_r+0xf2>
80009e74:	ab d8       	cbr	r8,0xb
80009e76:	30 0c       	mov	r12,0
80009e78:	6e 49       	ld.w	r9,r7[0x10]
80009e7a:	ae 68       	st.h	r7[0xc],r8
80009e7c:	8f 1c       	st.w	r7[0x4],r12
80009e7e:	8f 09       	st.w	r7[0x0],r9
80009e80:	ed b8 00 0c 	bld	r8,0xc
80009e84:	c2 51       	brne	80009ece <_fflush_r+0x102>
80009e86:	ef 45 00 54 	st.w	r7[84],r5
80009e8a:	d8 22       	popm	r4-r7,pc
80009e8c:	6e 45       	ld.w	r5,r7[0x10]
80009e8e:	58 05       	cp.w	r5,0
80009e90:	c1 f0       	breq	80009ece <_fflush_r+0x102>
80009e92:	6e 04       	ld.w	r4,r7[0x0]
80009e94:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80009e98:	8f 05       	st.w	r7[0x0],r5
80009e9a:	f9 b8 01 00 	movne	r8,0
80009e9e:	ef f8 00 05 	ld.weq	r8,r7[0x14]
80009ea2:	0a 14       	sub	r4,r5
80009ea4:	8f 28       	st.w	r7[0x8],r8
80009ea6:	c1 18       	rjmp	80009ec8 <_fflush_r+0xfc>
80009ea8:	08 99       	mov	r9,r4
80009eaa:	0a 9a       	mov	r10,r5
80009eac:	6e a8       	ld.w	r8,r7[0x28]
80009eae:	6e 8b       	ld.w	r11,r7[0x20]
80009eb0:	0c 9c       	mov	r12,r6
80009eb2:	5d 18       	icall	r8
80009eb4:	18 14       	sub	r4,r12
80009eb6:	58 0c       	cp.w	r12,0
80009eb8:	e0 89 00 07 	brgt	80009ec6 <_fflush_r+0xfa>
80009ebc:	8e 68       	ld.sh	r8,r7[0xc]
80009ebe:	a7 a8       	sbr	r8,0x6
80009ec0:	3f fc       	mov	r12,-1
80009ec2:	ae 68       	st.h	r7[0xc],r8
80009ec4:	d8 22       	popm	r4-r7,pc
80009ec6:	18 05       	add	r5,r12
80009ec8:	58 04       	cp.w	r4,0
80009eca:	fe 99 ff ef 	brgt	80009ea8 <_fflush_r+0xdc>
80009ece:	d8 2a       	popm	r4-r7,pc,r12=0
80009ed0:	80 01       	ld.sh	r1,r0[0x0]
80009ed2:	53 b4       	stdsp	sp[0xec],r4
80009ed4:	80 01       	ld.sh	r1,r0[0x0]
80009ed6:	53 d4       	stdsp	sp[0xf4],r4
80009ed8:	80 01       	ld.sh	r1,r0[0x0]
80009eda:	53 f4       	stdsp	sp[0xfc],r4

80009edc <__sfp_lock_acquire>:
80009edc:	5e fc       	retal	r12

80009ede <__sfp_lock_release>:
80009ede:	5e fc       	retal	r12

80009ee0 <_cleanup_r>:
80009ee0:	d4 01       	pushm	lr
80009ee2:	fe cb f0 ba 	sub	r11,pc,-3910
80009ee6:	e0 a0 02 f9 	rcall	8000a4d8 <_fwalk>
80009eea:	d8 02       	popm	pc

80009eec <__sfmoreglue>:
80009eec:	d4 21       	pushm	r4-r7,lr
80009eee:	16 95       	mov	r5,r11
80009ef0:	f6 06 10 5c 	mul	r6,r11,92
80009ef4:	ec cb ff f4 	sub	r11,r6,-12
80009ef8:	fe b0 e2 5c 	rcall	800063b0 <_malloc_r>
80009efc:	18 97       	mov	r7,r12
80009efe:	c0 90       	breq	80009f10 <__sfmoreglue+0x24>
80009f00:	99 15       	st.w	r12[0x4],r5
80009f02:	30 0b       	mov	r11,0
80009f04:	2f 4c       	sub	r12,-12
80009f06:	0c 9a       	mov	r10,r6
80009f08:	8f 2c       	st.w	r7[0x8],r12
80009f0a:	8f 0b       	st.w	r7[0x0],r11
80009f0c:	fe b0 e5 12 	rcall	80006930 <memset>
80009f10:	0e 9c       	mov	r12,r7
80009f12:	d8 22       	popm	r4-r7,pc

80009f14 <__sfp>:
80009f14:	d4 21       	pushm	r4-r7,lr
80009f16:	49 b8       	lddpc	r8,80009f80 <__sfp+0x6c>
80009f18:	18 96       	mov	r6,r12
80009f1a:	70 07       	ld.w	r7,r8[0x0]
80009f1c:	6e 68       	ld.w	r8,r7[0x18]
80009f1e:	58 08       	cp.w	r8,0
80009f20:	c0 31       	brne	80009f26 <__sfp+0x12>
80009f22:	0e 9c       	mov	r12,r7
80009f24:	c3 0c       	rcall	80009f84 <__sinit>
80009f26:	ee c7 ff 28 	sub	r7,r7,-216
80009f2a:	30 05       	mov	r5,0
80009f2c:	6e 2c       	ld.w	r12,r7[0x8]
80009f2e:	6e 18       	ld.w	r8,r7[0x4]
80009f30:	c0 68       	rjmp	80009f3c <__sfp+0x28>
80009f32:	98 69       	ld.sh	r9,r12[0xc]
80009f34:	ea 09 19 00 	cp.h	r9,r5
80009f38:	c1 10       	breq	80009f5a <__sfp+0x46>
80009f3a:	2a 4c       	sub	r12,-92
80009f3c:	20 18       	sub	r8,1
80009f3e:	cf a7       	brpl	80009f32 <__sfp+0x1e>
80009f40:	6e 08       	ld.w	r8,r7[0x0]
80009f42:	58 08       	cp.w	r8,0
80009f44:	c0 61       	brne	80009f50 <__sfp+0x3c>
80009f46:	30 4b       	mov	r11,4
80009f48:	0c 9c       	mov	r12,r6
80009f4a:	cd 1f       	rcall	80009eec <__sfmoreglue>
80009f4c:	8f 0c       	st.w	r7[0x0],r12
80009f4e:	c0 30       	breq	80009f54 <__sfp+0x40>
80009f50:	6e 07       	ld.w	r7,r7[0x0]
80009f52:	ce db       	rjmp	80009f2c <__sfp+0x18>
80009f54:	30 c8       	mov	r8,12
80009f56:	8d 38       	st.w	r6[0xc],r8
80009f58:	d8 22       	popm	r4-r7,pc
80009f5a:	30 08       	mov	r8,0
80009f5c:	f9 48 00 4c 	st.w	r12[76],r8
80009f60:	99 08       	st.w	r12[0x0],r8
80009f62:	99 28       	st.w	r12[0x8],r8
80009f64:	99 18       	st.w	r12[0x4],r8
80009f66:	99 48       	st.w	r12[0x10],r8
80009f68:	99 58       	st.w	r12[0x14],r8
80009f6a:	99 68       	st.w	r12[0x18],r8
80009f6c:	99 d8       	st.w	r12[0x34],r8
80009f6e:	99 e8       	st.w	r12[0x38],r8
80009f70:	f9 48 00 48 	st.w	r12[72],r8
80009f74:	3f f8       	mov	r8,-1
80009f76:	b8 78       	st.h	r12[0xe],r8
80009f78:	30 18       	mov	r8,1
80009f7a:	b8 68       	st.h	r12[0xc],r8
80009f7c:	d8 22       	popm	r4-r7,pc
80009f7e:	d7 03       	nop
80009f80:	80 01       	ld.sh	r1,r0[0x0]
80009f82:	54 18       	stdsp	sp[0x104],r8

80009f84 <__sinit>:
80009f84:	d4 21       	pushm	r4-r7,lr
80009f86:	18 96       	mov	r6,r12
80009f88:	78 67       	ld.w	r7,r12[0x18]
80009f8a:	58 07       	cp.w	r7,0
80009f8c:	c4 91       	brne	8000a01e <__sinit+0x9a>
80009f8e:	fe c8 00 ae 	sub	r8,pc,174
80009f92:	30 15       	mov	r5,1
80009f94:	99 a8       	st.w	r12[0x28],r8
80009f96:	f9 47 00 d8 	st.w	r12[216],r7
80009f9a:	f9 47 00 dc 	st.w	r12[220],r7
80009f9e:	f9 47 00 e0 	st.w	r12[224],r7
80009fa2:	99 65       	st.w	r12[0x18],r5
80009fa4:	cb 8f       	rcall	80009f14 <__sfp>
80009fa6:	8d 0c       	st.w	r6[0x0],r12
80009fa8:	0c 9c       	mov	r12,r6
80009faa:	cb 5f       	rcall	80009f14 <__sfp>
80009fac:	8d 1c       	st.w	r6[0x4],r12
80009fae:	0c 9c       	mov	r12,r6
80009fb0:	cb 2f       	rcall	80009f14 <__sfp>
80009fb2:	6c 09       	ld.w	r9,r6[0x0]
80009fb4:	30 48       	mov	r8,4
80009fb6:	93 07       	st.w	r9[0x0],r7
80009fb8:	b2 68       	st.h	r9[0xc],r8
80009fba:	93 17       	st.w	r9[0x4],r7
80009fbc:	93 27       	st.w	r9[0x8],r7
80009fbe:	6c 18       	ld.w	r8,r6[0x4]
80009fc0:	b2 77       	st.h	r9[0xe],r7
80009fc2:	93 47       	st.w	r9[0x10],r7
80009fc4:	93 57       	st.w	r9[0x14],r7
80009fc6:	93 67       	st.w	r9[0x18],r7
80009fc8:	93 89       	st.w	r9[0x20],r9
80009fca:	91 07       	st.w	r8[0x0],r7
80009fcc:	91 17       	st.w	r8[0x4],r7
80009fce:	91 27       	st.w	r8[0x8],r7
80009fd0:	fe ce f3 20 	sub	lr,pc,-3296
80009fd4:	fe cb f3 50 	sub	r11,pc,-3248
80009fd8:	93 9e       	st.w	r9[0x24],lr
80009fda:	93 ab       	st.w	r9[0x28],r11
80009fdc:	fe ca f3 78 	sub	r10,pc,-3208
80009fe0:	fe c4 f3 84 	sub	r4,pc,-3196
80009fe4:	93 ba       	st.w	r9[0x2c],r10
80009fe6:	93 c4       	st.w	r9[0x30],r4
80009fe8:	30 99       	mov	r9,9
80009fea:	b0 69       	st.h	r8[0xc],r9
80009fec:	b0 75       	st.h	r8[0xe],r5
80009fee:	91 c4       	st.w	r8[0x30],r4
80009ff0:	91 47       	st.w	r8[0x10],r7
80009ff2:	91 57       	st.w	r8[0x14],r7
80009ff4:	91 67       	st.w	r8[0x18],r7
80009ff6:	91 88       	st.w	r8[0x20],r8
80009ff8:	91 9e       	st.w	r8[0x24],lr
80009ffa:	91 ab       	st.w	r8[0x28],r11
80009ffc:	91 ba       	st.w	r8[0x2c],r10
80009ffe:	8d 2c       	st.w	r6[0x8],r12
8000a000:	31 28       	mov	r8,18
8000a002:	99 07       	st.w	r12[0x0],r7
8000a004:	b8 68       	st.h	r12[0xc],r8
8000a006:	99 17       	st.w	r12[0x4],r7
8000a008:	99 27       	st.w	r12[0x8],r7
8000a00a:	30 28       	mov	r8,2
8000a00c:	b8 78       	st.h	r12[0xe],r8
8000a00e:	99 c4       	st.w	r12[0x30],r4
8000a010:	99 67       	st.w	r12[0x18],r7
8000a012:	99 9e       	st.w	r12[0x24],lr
8000a014:	99 ab       	st.w	r12[0x28],r11
8000a016:	99 ba       	st.w	r12[0x2c],r10
8000a018:	99 47       	st.w	r12[0x10],r7
8000a01a:	99 57       	st.w	r12[0x14],r7
8000a01c:	99 8c       	st.w	r12[0x20],r12
8000a01e:	d8 22       	popm	r4-r7,pc

8000a020 <_malloc_trim_r>:
8000a020:	d4 21       	pushm	r4-r7,lr
8000a022:	16 95       	mov	r5,r11
8000a024:	18 97       	mov	r7,r12
8000a026:	fe b0 d7 61 	rcall	80004ee8 <__malloc_lock>
8000a02a:	e0 64 05 30 	mov	r4,1328
8000a02e:	68 28       	ld.w	r8,r4[0x8]
8000a030:	70 16       	ld.w	r6,r8[0x4]
8000a032:	e0 16 ff fc 	andl	r6,0xfffc
8000a036:	ec c8 ff 91 	sub	r8,r6,-111
8000a03a:	f0 05 01 05 	sub	r5,r8,r5
8000a03e:	e0 15 ff 80 	andl	r5,0xff80
8000a042:	ea c5 00 80 	sub	r5,r5,128
8000a046:	e0 45 00 7f 	cp.w	r5,127
8000a04a:	e0 8a 00 25 	brle	8000a094 <_malloc_trim_r+0x74>
8000a04e:	30 0b       	mov	r11,0
8000a050:	0e 9c       	mov	r12,r7
8000a052:	fe b0 e5 d7 	rcall	80006c00 <_sbrk_r>
8000a056:	68 28       	ld.w	r8,r4[0x8]
8000a058:	0c 08       	add	r8,r6
8000a05a:	10 3c       	cp.w	r12,r8
8000a05c:	c1 c1       	brne	8000a094 <_malloc_trim_r+0x74>
8000a05e:	ea 0b 11 00 	rsub	r11,r5,0
8000a062:	0e 9c       	mov	r12,r7
8000a064:	fe b0 e5 ce 	rcall	80006c00 <_sbrk_r>
8000a068:	5b fc       	cp.w	r12,-1
8000a06a:	c1 91       	brne	8000a09c <_malloc_trim_r+0x7c>
8000a06c:	30 0b       	mov	r11,0
8000a06e:	0e 9c       	mov	r12,r7
8000a070:	fe b0 e5 c8 	rcall	80006c00 <_sbrk_r>
8000a074:	68 28       	ld.w	r8,r4[0x8]
8000a076:	f8 08 01 09 	sub	r9,r12,r8
8000a07a:	58 f9       	cp.w	r9,15
8000a07c:	e0 8a 00 0c 	brle	8000a094 <_malloc_trim_r+0x74>
8000a080:	a1 a9       	sbr	r9,0x0
8000a082:	91 19       	st.w	r8[0x4],r9
8000a084:	e0 68 09 3c 	mov	r8,2364
8000a088:	70 09       	ld.w	r9,r8[0x0]
8000a08a:	e0 68 0d 4c 	mov	r8,3404
8000a08e:	f8 09 01 09 	sub	r9,r12,r9
8000a092:	91 09       	st.w	r8[0x0],r9
8000a094:	0e 9c       	mov	r12,r7
8000a096:	fe b0 d7 2f 	rcall	80004ef4 <__malloc_unlock>
8000a09a:	d8 2a       	popm	r4-r7,pc,r12=0
8000a09c:	68 28       	ld.w	r8,r4[0x8]
8000a09e:	0a 16       	sub	r6,r5
8000a0a0:	a1 a6       	sbr	r6,0x0
8000a0a2:	91 16       	st.w	r8[0x4],r6
8000a0a4:	e0 68 0d 4c 	mov	r8,3404
8000a0a8:	70 09       	ld.w	r9,r8[0x0]
8000a0aa:	0a 19       	sub	r9,r5
8000a0ac:	0e 9c       	mov	r12,r7
8000a0ae:	91 09       	st.w	r8[0x0],r9
8000a0b0:	fe b0 d7 22 	rcall	80004ef4 <__malloc_unlock>
8000a0b4:	da 2a       	popm	r4-r7,pc,r12=1
8000a0b6:	d7 03       	nop

8000a0b8 <_free_r>:
8000a0b8:	d4 21       	pushm	r4-r7,lr
8000a0ba:	16 96       	mov	r6,r11
8000a0bc:	18 97       	mov	r7,r12
8000a0be:	58 0b       	cp.w	r11,0
8000a0c0:	e0 80 00 c0 	breq	8000a240 <_free_r+0x188>
8000a0c4:	fe b0 d7 12 	rcall	80004ee8 <__malloc_lock>
8000a0c8:	20 86       	sub	r6,8
8000a0ca:	e0 6a 05 30 	mov	r10,1328
8000a0ce:	6c 18       	ld.w	r8,r6[0x4]
8000a0d0:	74 2e       	ld.w	lr,r10[0x8]
8000a0d2:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a0d6:	a1 c8       	cbr	r8,0x0
8000a0d8:	ec 08 00 09 	add	r9,r6,r8
8000a0dc:	72 1b       	ld.w	r11,r9[0x4]
8000a0de:	e0 1b ff fc 	andl	r11,0xfffc
8000a0e2:	1c 39       	cp.w	r9,lr
8000a0e4:	c1 e1       	brne	8000a120 <_free_r+0x68>
8000a0e6:	f6 08 00 08 	add	r8,r11,r8
8000a0ea:	58 0c       	cp.w	r12,0
8000a0ec:	c0 81       	brne	8000a0fc <_free_r+0x44>
8000a0ee:	6c 09       	ld.w	r9,r6[0x0]
8000a0f0:	12 16       	sub	r6,r9
8000a0f2:	12 08       	add	r8,r9
8000a0f4:	6c 3b       	ld.w	r11,r6[0xc]
8000a0f6:	6c 29       	ld.w	r9,r6[0x8]
8000a0f8:	97 29       	st.w	r11[0x8],r9
8000a0fa:	93 3b       	st.w	r9[0xc],r11
8000a0fc:	10 99       	mov	r9,r8
8000a0fe:	95 26       	st.w	r10[0x8],r6
8000a100:	a1 a9       	sbr	r9,0x0
8000a102:	8d 19       	st.w	r6[0x4],r9
8000a104:	e0 69 09 38 	mov	r9,2360
8000a108:	72 09       	ld.w	r9,r9[0x0]
8000a10a:	12 38       	cp.w	r8,r9
8000a10c:	c0 63       	brcs	8000a118 <_free_r+0x60>
8000a10e:	e0 68 0d 48 	mov	r8,3400
8000a112:	0e 9c       	mov	r12,r7
8000a114:	70 0b       	ld.w	r11,r8[0x0]
8000a116:	c8 5f       	rcall	8000a020 <_malloc_trim_r>
8000a118:	0e 9c       	mov	r12,r7
8000a11a:	fe b0 d6 ed 	rcall	80004ef4 <__malloc_unlock>
8000a11e:	d8 22       	popm	r4-r7,pc
8000a120:	93 1b       	st.w	r9[0x4],r11
8000a122:	58 0c       	cp.w	r12,0
8000a124:	c0 30       	breq	8000a12a <_free_r+0x72>
8000a126:	30 0c       	mov	r12,0
8000a128:	c1 08       	rjmp	8000a148 <_free_r+0x90>
8000a12a:	6c 0e       	ld.w	lr,r6[0x0]
8000a12c:	f4 c5 ff f8 	sub	r5,r10,-8
8000a130:	1c 16       	sub	r6,lr
8000a132:	1c 08       	add	r8,lr
8000a134:	6c 2e       	ld.w	lr,r6[0x8]
8000a136:	0a 3e       	cp.w	lr,r5
8000a138:	f9 bc 00 01 	moveq	r12,1
8000a13c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a140:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a144:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a148:	f2 0b 00 0e 	add	lr,r9,r11
8000a14c:	7c 1e       	ld.w	lr,lr[0x4]
8000a14e:	ed be 00 00 	bld	lr,0x0
8000a152:	c1 40       	breq	8000a17a <_free_r+0xc2>
8000a154:	16 08       	add	r8,r11
8000a156:	58 0c       	cp.w	r12,0
8000a158:	c0 d1       	brne	8000a172 <_free_r+0xba>
8000a15a:	e0 6e 05 30 	mov	lr,1328
8000a15e:	72 2b       	ld.w	r11,r9[0x8]
8000a160:	2f 8e       	sub	lr,-8
8000a162:	1c 3b       	cp.w	r11,lr
8000a164:	c0 71       	brne	8000a172 <_free_r+0xba>
8000a166:	97 36       	st.w	r11[0xc],r6
8000a168:	97 26       	st.w	r11[0x8],r6
8000a16a:	8d 2b       	st.w	r6[0x8],r11
8000a16c:	8d 3b       	st.w	r6[0xc],r11
8000a16e:	30 1c       	mov	r12,1
8000a170:	c0 58       	rjmp	8000a17a <_free_r+0xc2>
8000a172:	72 2b       	ld.w	r11,r9[0x8]
8000a174:	72 39       	ld.w	r9,r9[0xc]
8000a176:	93 2b       	st.w	r9[0x8],r11
8000a178:	97 39       	st.w	r11[0xc],r9
8000a17a:	10 99       	mov	r9,r8
8000a17c:	ec 08 09 08 	st.w	r6[r8],r8
8000a180:	a1 a9       	sbr	r9,0x0
8000a182:	8d 19       	st.w	r6[0x4],r9
8000a184:	58 0c       	cp.w	r12,0
8000a186:	c5 a1       	brne	8000a23a <_free_r+0x182>
8000a188:	e0 48 01 ff 	cp.w	r8,511
8000a18c:	e0 8b 00 13 	brhi	8000a1b2 <_free_r+0xfa>
8000a190:	a3 98       	lsr	r8,0x3
8000a192:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a196:	72 2b       	ld.w	r11,r9[0x8]
8000a198:	8d 39       	st.w	r6[0xc],r9
8000a19a:	8d 2b       	st.w	r6[0x8],r11
8000a19c:	97 36       	st.w	r11[0xc],r6
8000a19e:	93 26       	st.w	r9[0x8],r6
8000a1a0:	a3 48       	asr	r8,0x2
8000a1a2:	74 19       	ld.w	r9,r10[0x4]
8000a1a4:	30 1b       	mov	r11,1
8000a1a6:	f6 08 09 48 	lsl	r8,r11,r8
8000a1aa:	f3 e8 10 08 	or	r8,r9,r8
8000a1ae:	95 18       	st.w	r10[0x4],r8
8000a1b0:	c4 58       	rjmp	8000a23a <_free_r+0x182>
8000a1b2:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a1b6:	58 4b       	cp.w	r11,4
8000a1b8:	e0 8b 00 06 	brhi	8000a1c4 <_free_r+0x10c>
8000a1bc:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a1c0:	2c 8b       	sub	r11,-56
8000a1c2:	c2 08       	rjmp	8000a202 <_free_r+0x14a>
8000a1c4:	59 4b       	cp.w	r11,20
8000a1c6:	e0 8b 00 04 	brhi	8000a1ce <_free_r+0x116>
8000a1ca:	2a 5b       	sub	r11,-91
8000a1cc:	c1 b8       	rjmp	8000a202 <_free_r+0x14a>
8000a1ce:	e0 4b 00 54 	cp.w	r11,84
8000a1d2:	e0 8b 00 06 	brhi	8000a1de <_free_r+0x126>
8000a1d6:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a1da:	29 2b       	sub	r11,-110
8000a1dc:	c1 38       	rjmp	8000a202 <_free_r+0x14a>
8000a1de:	e0 4b 01 54 	cp.w	r11,340
8000a1e2:	e0 8b 00 06 	brhi	8000a1ee <_free_r+0x136>
8000a1e6:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a1ea:	28 9b       	sub	r11,-119
8000a1ec:	c0 b8       	rjmp	8000a202 <_free_r+0x14a>
8000a1ee:	e0 4b 05 54 	cp.w	r11,1364
8000a1f2:	e0 88 00 05 	brls	8000a1fc <_free_r+0x144>
8000a1f6:	37 eb       	mov	r11,126
8000a1f8:	c0 58       	rjmp	8000a202 <_free_r+0x14a>
8000a1fa:	d7 03       	nop
8000a1fc:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a200:	28 4b       	sub	r11,-124
8000a202:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a206:	78 29       	ld.w	r9,r12[0x8]
8000a208:	18 39       	cp.w	r9,r12
8000a20a:	c0 e1       	brne	8000a226 <_free_r+0x16e>
8000a20c:	74 18       	ld.w	r8,r10[0x4]
8000a20e:	a3 4b       	asr	r11,0x2
8000a210:	30 1c       	mov	r12,1
8000a212:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a216:	f1 eb 10 0b 	or	r11,r8,r11
8000a21a:	12 98       	mov	r8,r9
8000a21c:	95 1b       	st.w	r10[0x4],r11
8000a21e:	c0 a8       	rjmp	8000a232 <_free_r+0x17a>
8000a220:	72 29       	ld.w	r9,r9[0x8]
8000a222:	18 39       	cp.w	r9,r12
8000a224:	c0 60       	breq	8000a230 <_free_r+0x178>
8000a226:	72 1a       	ld.w	r10,r9[0x4]
8000a228:	e0 1a ff fc 	andl	r10,0xfffc
8000a22c:	14 38       	cp.w	r8,r10
8000a22e:	cf 93       	brcs	8000a220 <_free_r+0x168>
8000a230:	72 38       	ld.w	r8,r9[0xc]
8000a232:	8d 38       	st.w	r6[0xc],r8
8000a234:	8d 29       	st.w	r6[0x8],r9
8000a236:	93 36       	st.w	r9[0xc],r6
8000a238:	91 26       	st.w	r8[0x8],r6
8000a23a:	0e 9c       	mov	r12,r7
8000a23c:	fe b0 d6 5c 	rcall	80004ef4 <__malloc_unlock>
8000a240:	d8 22       	popm	r4-r7,pc
8000a242:	d7 03       	nop

8000a244 <__sfvwrite_r>:
8000a244:	d4 31       	pushm	r0-r7,lr
8000a246:	20 3d       	sub	sp,12
8000a248:	14 94       	mov	r4,r10
8000a24a:	18 95       	mov	r5,r12
8000a24c:	16 97       	mov	r7,r11
8000a24e:	74 28       	ld.w	r8,r10[0x8]
8000a250:	58 08       	cp.w	r8,0
8000a252:	e0 80 01 40 	breq	8000a4d2 <__sfvwrite_r+0x28e>
8000a256:	96 68       	ld.sh	r8,r11[0xc]
8000a258:	ed b8 00 03 	bld	r8,0x3
8000a25c:	c0 41       	brne	8000a264 <__sfvwrite_r+0x20>
8000a25e:	76 48       	ld.w	r8,r11[0x10]
8000a260:	58 08       	cp.w	r8,0
8000a262:	c0 c1       	brne	8000a27a <__sfvwrite_r+0x36>
8000a264:	0e 9b       	mov	r11,r7
8000a266:	0a 9c       	mov	r12,r5
8000a268:	fe b0 f6 bc 	rcall	80008fe0 <__swsetup_r>
8000a26c:	c0 70       	breq	8000a27a <__sfvwrite_r+0x36>
8000a26e:	8e 68       	ld.sh	r8,r7[0xc]
8000a270:	a7 a8       	sbr	r8,0x6
8000a272:	ae 68       	st.h	r7[0xc],r8
8000a274:	30 98       	mov	r8,9
8000a276:	8b 38       	st.w	r5[0xc],r8
8000a278:	c2 b9       	rjmp	8000a4ce <__sfvwrite_r+0x28a>
8000a27a:	8e 63       	ld.sh	r3,r7[0xc]
8000a27c:	68 00       	ld.w	r0,r4[0x0]
8000a27e:	06 96       	mov	r6,r3
8000a280:	e2 16 00 02 	andl	r6,0x2,COH
8000a284:	c2 10       	breq	8000a2c6 <__sfvwrite_r+0x82>
8000a286:	30 03       	mov	r3,0
8000a288:	e0 62 04 00 	mov	r2,1024
8000a28c:	06 96       	mov	r6,r3
8000a28e:	c0 48       	rjmp	8000a296 <__sfvwrite_r+0x52>
8000a290:	60 03       	ld.w	r3,r0[0x0]
8000a292:	60 16       	ld.w	r6,r0[0x4]
8000a294:	2f 80       	sub	r0,-8
8000a296:	58 06       	cp.w	r6,0
8000a298:	cf c0       	breq	8000a290 <__sfvwrite_r+0x4c>
8000a29a:	e0 46 04 00 	cp.w	r6,1024
8000a29e:	ec 09 17 80 	movls	r9,r6
8000a2a2:	e4 09 17 b0 	movhi	r9,r2
8000a2a6:	06 9a       	mov	r10,r3
8000a2a8:	6e a8       	ld.w	r8,r7[0x28]
8000a2aa:	6e 8b       	ld.w	r11,r7[0x20]
8000a2ac:	0a 9c       	mov	r12,r5
8000a2ae:	5d 18       	icall	r8
8000a2b0:	18 16       	sub	r6,r12
8000a2b2:	58 0c       	cp.w	r12,0
8000a2b4:	e0 8a 01 0a 	brle	8000a4c8 <__sfvwrite_r+0x284>
8000a2b8:	68 28       	ld.w	r8,r4[0x8]
8000a2ba:	18 18       	sub	r8,r12
8000a2bc:	89 28       	st.w	r4[0x8],r8
8000a2be:	e0 80 01 0a 	breq	8000a4d2 <__sfvwrite_r+0x28e>
8000a2c2:	18 03       	add	r3,r12
8000a2c4:	ce 9b       	rjmp	8000a296 <__sfvwrite_r+0x52>
8000a2c6:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000a2ca:	c0 70       	breq	8000a2d8 <__sfvwrite_r+0x94>
8000a2cc:	50 06       	stdsp	sp[0x0],r6
8000a2ce:	0c 93       	mov	r3,r6
8000a2d0:	0c 91       	mov	r1,r6
8000a2d2:	50 15       	stdsp	sp[0x4],r5
8000a2d4:	08 92       	mov	r2,r4
8000a2d6:	c9 c8       	rjmp	8000a40e <__sfvwrite_r+0x1ca>
8000a2d8:	06 96       	mov	r6,r3
8000a2da:	08 91       	mov	r1,r4
8000a2dc:	c0 48       	rjmp	8000a2e4 <__sfvwrite_r+0xa0>
8000a2de:	60 03       	ld.w	r3,r0[0x0]
8000a2e0:	60 16       	ld.w	r6,r0[0x4]
8000a2e2:	2f 80       	sub	r0,-8
8000a2e4:	58 06       	cp.w	r6,0
8000a2e6:	cf c0       	breq	8000a2de <__sfvwrite_r+0x9a>
8000a2e8:	8e 68       	ld.sh	r8,r7[0xc]
8000a2ea:	6e 24       	ld.w	r4,r7[0x8]
8000a2ec:	10 99       	mov	r9,r8
8000a2ee:	e2 19 02 00 	andl	r9,0x200,COH
8000a2f2:	c5 50       	breq	8000a39c <__sfvwrite_r+0x158>
8000a2f4:	08 36       	cp.w	r6,r4
8000a2f6:	c4 43       	brcs	8000a37e <__sfvwrite_r+0x13a>
8000a2f8:	10 99       	mov	r9,r8
8000a2fa:	e2 19 04 80 	andl	r9,0x480,COH
8000a2fe:	c4 00       	breq	8000a37e <__sfvwrite_r+0x13a>
8000a300:	6e 4b       	ld.w	r11,r7[0x10]
8000a302:	6e 09       	ld.w	r9,r7[0x0]
8000a304:	16 19       	sub	r9,r11
8000a306:	50 09       	stdsp	sp[0x0],r9
8000a308:	6e 59       	ld.w	r9,r7[0x14]
8000a30a:	10 9c       	mov	r12,r8
8000a30c:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000a310:	30 28       	mov	r8,2
8000a312:	f4 08 0c 08 	divs	r8,r10,r8
8000a316:	fa e9 00 04 	st.d	sp[4],r8
8000a31a:	10 94       	mov	r4,r8
8000a31c:	40 09       	lddsp	r9,sp[0x0]
8000a31e:	e2 1c 04 00 	andl	r12,0x400,COH
8000a322:	2f f9       	sub	r9,-1
8000a324:	0c 09       	add	r9,r6
8000a326:	12 38       	cp.w	r8,r9
8000a328:	f2 04 17 30 	movlo	r4,r9
8000a32c:	58 0c       	cp.w	r12,0
8000a32e:	c1 10       	breq	8000a350 <__sfvwrite_r+0x10c>
8000a330:	08 9b       	mov	r11,r4
8000a332:	0a 9c       	mov	r12,r5
8000a334:	fe b0 e0 3e 	rcall	800063b0 <_malloc_r>
8000a338:	18 92       	mov	r2,r12
8000a33a:	c1 40       	breq	8000a362 <__sfvwrite_r+0x11e>
8000a33c:	40 0a       	lddsp	r10,sp[0x0]
8000a33e:	6e 4b       	ld.w	r11,r7[0x10]
8000a340:	fe b0 e2 54 	rcall	800067e8 <memcpy>
8000a344:	8e 68       	ld.sh	r8,r7[0xc]
8000a346:	e0 18 fb 7f 	andl	r8,0xfb7f
8000a34a:	a7 b8       	sbr	r8,0x7
8000a34c:	ae 68       	st.h	r7[0xc],r8
8000a34e:	c0 d8       	rjmp	8000a368 <__sfvwrite_r+0x124>
8000a350:	08 9a       	mov	r10,r4
8000a352:	0a 9c       	mov	r12,r5
8000a354:	fe b0 e2 f6 	rcall	80006940 <_realloc_r>
8000a358:	18 92       	mov	r2,r12
8000a35a:	c0 71       	brne	8000a368 <__sfvwrite_r+0x124>
8000a35c:	6e 4b       	ld.w	r11,r7[0x10]
8000a35e:	0a 9c       	mov	r12,r5
8000a360:	ca ce       	rcall	8000a0b8 <_free_r>
8000a362:	30 c8       	mov	r8,12
8000a364:	8b 38       	st.w	r5[0xc],r8
8000a366:	cb 18       	rjmp	8000a4c8 <__sfvwrite_r+0x284>
8000a368:	40 0a       	lddsp	r10,sp[0x0]
8000a36a:	40 09       	lddsp	r9,sp[0x0]
8000a36c:	e8 0a 01 0a 	sub	r10,r4,r10
8000a370:	e4 09 00 08 	add	r8,r2,r9
8000a374:	8f 54       	st.w	r7[0x14],r4
8000a376:	8f 2a       	st.w	r7[0x8],r10
8000a378:	8f 08       	st.w	r7[0x0],r8
8000a37a:	8f 42       	st.w	r7[0x10],r2
8000a37c:	0c 94       	mov	r4,r6
8000a37e:	08 36       	cp.w	r6,r4
8000a380:	ec 04 17 30 	movlo	r4,r6
8000a384:	06 9b       	mov	r11,r3
8000a386:	08 9a       	mov	r10,r4
8000a388:	6e 0c       	ld.w	r12,r7[0x0]
8000a38a:	c3 ad       	rcall	8000a5fe <memmove>
8000a38c:	6e 08       	ld.w	r8,r7[0x0]
8000a38e:	08 08       	add	r8,r4
8000a390:	8f 08       	st.w	r7[0x0],r8
8000a392:	6e 28       	ld.w	r8,r7[0x8]
8000a394:	08 18       	sub	r8,r4
8000a396:	0c 94       	mov	r4,r6
8000a398:	8f 28       	st.w	r7[0x8],r8
8000a39a:	c2 e8       	rjmp	8000a3f6 <__sfvwrite_r+0x1b2>
8000a39c:	08 36       	cp.w	r6,r4
8000a39e:	5f ba       	srhi	r10
8000a3a0:	6e 0c       	ld.w	r12,r7[0x0]
8000a3a2:	6e 48       	ld.w	r8,r7[0x10]
8000a3a4:	10 3c       	cp.w	r12,r8
8000a3a6:	5f b8       	srhi	r8
8000a3a8:	f5 e8 00 08 	and	r8,r10,r8
8000a3ac:	f2 08 18 00 	cp.b	r8,r9
8000a3b0:	c0 d0       	breq	8000a3ca <__sfvwrite_r+0x186>
8000a3b2:	06 9b       	mov	r11,r3
8000a3b4:	08 9a       	mov	r10,r4
8000a3b6:	c2 4d       	rcall	8000a5fe <memmove>
8000a3b8:	6e 08       	ld.w	r8,r7[0x0]
8000a3ba:	08 08       	add	r8,r4
8000a3bc:	0e 9b       	mov	r11,r7
8000a3be:	8f 08       	st.w	r7[0x0],r8
8000a3c0:	0a 9c       	mov	r12,r5
8000a3c2:	fe b0 fd 05 	rcall	80009dcc <_fflush_r>
8000a3c6:	c1 80       	breq	8000a3f6 <__sfvwrite_r+0x1b2>
8000a3c8:	c8 08       	rjmp	8000a4c8 <__sfvwrite_r+0x284>
8000a3ca:	6e 59       	ld.w	r9,r7[0x14]
8000a3cc:	12 36       	cp.w	r6,r9
8000a3ce:	c0 a3       	brcs	8000a3e2 <__sfvwrite_r+0x19e>
8000a3d0:	6e a8       	ld.w	r8,r7[0x28]
8000a3d2:	06 9a       	mov	r10,r3
8000a3d4:	6e 8b       	ld.w	r11,r7[0x20]
8000a3d6:	0a 9c       	mov	r12,r5
8000a3d8:	5d 18       	icall	r8
8000a3da:	18 94       	mov	r4,r12
8000a3dc:	e0 89 00 0d 	brgt	8000a3f6 <__sfvwrite_r+0x1b2>
8000a3e0:	c7 48       	rjmp	8000a4c8 <__sfvwrite_r+0x284>
8000a3e2:	0c 9a       	mov	r10,r6
8000a3e4:	06 9b       	mov	r11,r3
8000a3e6:	c0 cd       	rcall	8000a5fe <memmove>
8000a3e8:	6e 08       	ld.w	r8,r7[0x0]
8000a3ea:	0c 08       	add	r8,r6
8000a3ec:	0c 94       	mov	r4,r6
8000a3ee:	8f 08       	st.w	r7[0x0],r8
8000a3f0:	6e 28       	ld.w	r8,r7[0x8]
8000a3f2:	0c 18       	sub	r8,r6
8000a3f4:	8f 28       	st.w	r7[0x8],r8
8000a3f6:	62 28       	ld.w	r8,r1[0x8]
8000a3f8:	08 18       	sub	r8,r4
8000a3fa:	83 28       	st.w	r1[0x8],r8
8000a3fc:	c6 b0       	breq	8000a4d2 <__sfvwrite_r+0x28e>
8000a3fe:	08 16       	sub	r6,r4
8000a400:	08 03       	add	r3,r4
8000a402:	c7 1b       	rjmp	8000a2e4 <__sfvwrite_r+0xa0>
8000a404:	60 03       	ld.w	r3,r0[0x0]
8000a406:	60 11       	ld.w	r1,r0[0x4]
8000a408:	30 08       	mov	r8,0
8000a40a:	2f 80       	sub	r0,-8
8000a40c:	50 08       	stdsp	sp[0x0],r8
8000a40e:	58 01       	cp.w	r1,0
8000a410:	cf a0       	breq	8000a404 <__sfvwrite_r+0x1c0>
8000a412:	40 0a       	lddsp	r10,sp[0x0]
8000a414:	58 0a       	cp.w	r10,0
8000a416:	c1 41       	brne	8000a43e <__sfvwrite_r+0x1fa>
8000a418:	e2 c6 ff ff 	sub	r6,r1,-1
8000a41c:	02 9a       	mov	r10,r1
8000a41e:	30 ab       	mov	r11,10
8000a420:	06 9c       	mov	r12,r3
8000a422:	ce 3c       	rcall	8000a5e8 <memchr>
8000a424:	f8 c8 ff ff 	sub	r8,r12,-1
8000a428:	58 0c       	cp.w	r12,0
8000a42a:	f1 d3 e1 16 	subne	r6,r8,r3
8000a42e:	f9 b9 01 01 	movne	r9,1
8000a432:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a436:	f9 b8 00 01 	moveq	r8,1
8000a43a:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000a43e:	02 36       	cp.w	r6,r1
8000a440:	ec 04 17 80 	movls	r4,r6
8000a444:	e2 04 17 b0 	movhi	r4,r1
8000a448:	6e 59       	ld.w	r9,r7[0x14]
8000a44a:	6e 25       	ld.w	r5,r7[0x8]
8000a44c:	f2 05 00 05 	add	r5,r9,r5
8000a450:	0a 34       	cp.w	r4,r5
8000a452:	5f 9a       	srgt	r10
8000a454:	6e 0c       	ld.w	r12,r7[0x0]
8000a456:	6e 48       	ld.w	r8,r7[0x10]
8000a458:	10 3c       	cp.w	r12,r8
8000a45a:	5f b8       	srhi	r8
8000a45c:	f5 e8 00 08 	and	r8,r10,r8
8000a460:	30 0a       	mov	r10,0
8000a462:	f4 08 18 00 	cp.b	r8,r10
8000a466:	c0 d0       	breq	8000a480 <__sfvwrite_r+0x23c>
8000a468:	06 9b       	mov	r11,r3
8000a46a:	0a 9a       	mov	r10,r5
8000a46c:	cc 9c       	rcall	8000a5fe <memmove>
8000a46e:	6e 08       	ld.w	r8,r7[0x0]
8000a470:	0a 08       	add	r8,r5
8000a472:	0e 9b       	mov	r11,r7
8000a474:	8f 08       	st.w	r7[0x0],r8
8000a476:	40 1c       	lddsp	r12,sp[0x4]
8000a478:	fe b0 fc aa 	rcall	80009dcc <_fflush_r>
8000a47c:	c1 70       	breq	8000a4aa <__sfvwrite_r+0x266>
8000a47e:	c2 58       	rjmp	8000a4c8 <__sfvwrite_r+0x284>
8000a480:	12 34       	cp.w	r4,r9
8000a482:	c0 a5       	brlt	8000a496 <__sfvwrite_r+0x252>
8000a484:	6e a8       	ld.w	r8,r7[0x28]
8000a486:	06 9a       	mov	r10,r3
8000a488:	6e 8b       	ld.w	r11,r7[0x20]
8000a48a:	40 1c       	lddsp	r12,sp[0x4]
8000a48c:	5d 18       	icall	r8
8000a48e:	18 95       	mov	r5,r12
8000a490:	e0 89 00 0d 	brgt	8000a4aa <__sfvwrite_r+0x266>
8000a494:	c1 a8       	rjmp	8000a4c8 <__sfvwrite_r+0x284>
8000a496:	08 9a       	mov	r10,r4
8000a498:	06 9b       	mov	r11,r3
8000a49a:	cb 2c       	rcall	8000a5fe <memmove>
8000a49c:	6e 08       	ld.w	r8,r7[0x0]
8000a49e:	08 08       	add	r8,r4
8000a4a0:	08 95       	mov	r5,r4
8000a4a2:	8f 08       	st.w	r7[0x0],r8
8000a4a4:	6e 28       	ld.w	r8,r7[0x8]
8000a4a6:	08 18       	sub	r8,r4
8000a4a8:	8f 28       	st.w	r7[0x8],r8
8000a4aa:	0a 16       	sub	r6,r5
8000a4ac:	c0 71       	brne	8000a4ba <__sfvwrite_r+0x276>
8000a4ae:	0e 9b       	mov	r11,r7
8000a4b0:	40 1c       	lddsp	r12,sp[0x4]
8000a4b2:	fe b0 fc 8d 	rcall	80009dcc <_fflush_r>
8000a4b6:	c0 91       	brne	8000a4c8 <__sfvwrite_r+0x284>
8000a4b8:	50 06       	stdsp	sp[0x0],r6
8000a4ba:	64 28       	ld.w	r8,r2[0x8]
8000a4bc:	0a 18       	sub	r8,r5
8000a4be:	85 28       	st.w	r2[0x8],r8
8000a4c0:	c0 90       	breq	8000a4d2 <__sfvwrite_r+0x28e>
8000a4c2:	0a 11       	sub	r1,r5
8000a4c4:	0a 03       	add	r3,r5
8000a4c6:	ca 4b       	rjmp	8000a40e <__sfvwrite_r+0x1ca>
8000a4c8:	8e 68       	ld.sh	r8,r7[0xc]
8000a4ca:	a7 a8       	sbr	r8,0x6
8000a4cc:	ae 68       	st.h	r7[0xc],r8
8000a4ce:	3f fc       	mov	r12,-1
8000a4d0:	c0 28       	rjmp	8000a4d4 <__sfvwrite_r+0x290>
8000a4d2:	30 0c       	mov	r12,0
8000a4d4:	2f dd       	sub	sp,-12
8000a4d6:	d8 32       	popm	r0-r7,pc

8000a4d8 <_fwalk>:
8000a4d8:	d4 31       	pushm	r0-r7,lr
8000a4da:	30 05       	mov	r5,0
8000a4dc:	16 91       	mov	r1,r11
8000a4de:	f8 c7 ff 28 	sub	r7,r12,-216
8000a4e2:	0a 92       	mov	r2,r5
8000a4e4:	fe b0 fc fc 	rcall	80009edc <__sfp_lock_acquire>
8000a4e8:	3f f3       	mov	r3,-1
8000a4ea:	c1 68       	rjmp	8000a516 <_fwalk+0x3e>
8000a4ec:	6e 26       	ld.w	r6,r7[0x8]
8000a4ee:	6e 14       	ld.w	r4,r7[0x4]
8000a4f0:	2f 46       	sub	r6,-12
8000a4f2:	c0 c8       	rjmp	8000a50a <_fwalk+0x32>
8000a4f4:	8c 08       	ld.sh	r8,r6[0x0]
8000a4f6:	e4 08 19 00 	cp.h	r8,r2
8000a4fa:	c0 70       	breq	8000a508 <_fwalk+0x30>
8000a4fc:	8c 18       	ld.sh	r8,r6[0x2]
8000a4fe:	e6 08 19 00 	cp.h	r8,r3
8000a502:	c0 30       	breq	8000a508 <_fwalk+0x30>
8000a504:	5d 11       	icall	r1
8000a506:	18 45       	or	r5,r12
8000a508:	2a 46       	sub	r6,-92
8000a50a:	20 14       	sub	r4,1
8000a50c:	ec cc 00 0c 	sub	r12,r6,12
8000a510:	58 04       	cp.w	r4,0
8000a512:	cf 14       	brge	8000a4f4 <_fwalk+0x1c>
8000a514:	6e 07       	ld.w	r7,r7[0x0]
8000a516:	58 07       	cp.w	r7,0
8000a518:	ce a1       	brne	8000a4ec <_fwalk+0x14>
8000a51a:	fe b0 fc e2 	rcall	80009ede <__sfp_lock_release>
8000a51e:	0a 9c       	mov	r12,r5
8000a520:	d8 32       	popm	r0-r7,pc
8000a522:	d7 03       	nop

8000a524 <_localeconv_r>:
8000a524:	48 1c       	lddpc	r12,8000a528 <_localeconv_r+0x4>
8000a526:	5e fc       	retal	r12
8000a528:	80 01       	ld.sh	r1,r0[0x0]
8000a52a:	54 1c       	stdsp	sp[0x104],r12

8000a52c <__smakebuf_r>:
8000a52c:	d4 21       	pushm	r4-r7,lr
8000a52e:	20 fd       	sub	sp,60
8000a530:	96 68       	ld.sh	r8,r11[0xc]
8000a532:	16 97       	mov	r7,r11
8000a534:	18 96       	mov	r6,r12
8000a536:	e2 18 00 02 	andl	r8,0x2,COH
8000a53a:	c3 d1       	brne	8000a5b4 <__smakebuf_r+0x88>
8000a53c:	96 7b       	ld.sh	r11,r11[0xe]
8000a53e:	f0 0b 19 00 	cp.h	r11,r8
8000a542:	c0 55       	brlt	8000a54c <__smakebuf_r+0x20>
8000a544:	1a 9a       	mov	r10,sp
8000a546:	e0 a0 04 79 	rcall	8000ae38 <_fstat_r>
8000a54a:	c0 f4       	brge	8000a568 <__smakebuf_r+0x3c>
8000a54c:	8e 65       	ld.sh	r5,r7[0xc]
8000a54e:	0a 98       	mov	r8,r5
8000a550:	ab b8       	sbr	r8,0xb
8000a552:	e2 15 00 80 	andl	r5,0x80,COH
8000a556:	ae 68       	st.h	r7[0xc],r8
8000a558:	30 04       	mov	r4,0
8000a55a:	e0 68 04 00 	mov	r8,1024
8000a55e:	f9 b5 01 40 	movne	r5,64
8000a562:	f0 05 17 00 	moveq	r5,r8
8000a566:	c1 c8       	rjmp	8000a59e <__smakebuf_r+0x72>
8000a568:	40 18       	lddsp	r8,sp[0x4]
8000a56a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000a56e:	e0 48 20 00 	cp.w	r8,8192
8000a572:	5f 04       	sreq	r4
8000a574:	e0 48 80 00 	cp.w	r8,32768
8000a578:	c0 e1       	brne	8000a594 <__smakebuf_r+0x68>
8000a57a:	6e b9       	ld.w	r9,r7[0x2c]
8000a57c:	fe c8 f9 18 	sub	r8,pc,-1768
8000a580:	10 39       	cp.w	r9,r8
8000a582:	c0 91       	brne	8000a594 <__smakebuf_r+0x68>
8000a584:	8e 68       	ld.sh	r8,r7[0xc]
8000a586:	e0 65 04 00 	mov	r5,1024
8000a58a:	ab a8       	sbr	r8,0xa
8000a58c:	ef 45 00 50 	st.w	r7[80],r5
8000a590:	ae 68       	st.h	r7[0xc],r8
8000a592:	c0 68       	rjmp	8000a59e <__smakebuf_r+0x72>
8000a594:	8e 68       	ld.sh	r8,r7[0xc]
8000a596:	e0 65 04 00 	mov	r5,1024
8000a59a:	ab b8       	sbr	r8,0xb
8000a59c:	ae 68       	st.h	r7[0xc],r8
8000a59e:	0a 9b       	mov	r11,r5
8000a5a0:	0c 9c       	mov	r12,r6
8000a5a2:	fe b0 df 07 	rcall	800063b0 <_malloc_r>
8000a5a6:	8e 68       	ld.sh	r8,r7[0xc]
8000a5a8:	c0 d1       	brne	8000a5c2 <__smakebuf_r+0x96>
8000a5aa:	ed b8 00 09 	bld	r8,0x9
8000a5ae:	c1 b0       	breq	8000a5e4 <__smakebuf_r+0xb8>
8000a5b0:	a1 b8       	sbr	r8,0x1
8000a5b2:	ae 68       	st.h	r7[0xc],r8
8000a5b4:	ee c8 ff b9 	sub	r8,r7,-71
8000a5b8:	8f 48       	st.w	r7[0x10],r8
8000a5ba:	8f 08       	st.w	r7[0x0],r8
8000a5bc:	30 18       	mov	r8,1
8000a5be:	8f 58       	st.w	r7[0x14],r8
8000a5c0:	c1 28       	rjmp	8000a5e4 <__smakebuf_r+0xb8>
8000a5c2:	a7 b8       	sbr	r8,0x7
8000a5c4:	8f 4c       	st.w	r7[0x10],r12
8000a5c6:	ae 68       	st.h	r7[0xc],r8
8000a5c8:	8f 55       	st.w	r7[0x14],r5
8000a5ca:	fe c8 06 ea 	sub	r8,pc,1770
8000a5ce:	8f 0c       	st.w	r7[0x0],r12
8000a5d0:	8d a8       	st.w	r6[0x28],r8
8000a5d2:	58 04       	cp.w	r4,0
8000a5d4:	c0 80       	breq	8000a5e4 <__smakebuf_r+0xb8>
8000a5d6:	8e 7c       	ld.sh	r12,r7[0xe]
8000a5d8:	fe b0 e3 7a 	rcall	80006ccc <isatty>
8000a5dc:	c0 40       	breq	8000a5e4 <__smakebuf_r+0xb8>
8000a5de:	8e 68       	ld.sh	r8,r7[0xc]
8000a5e0:	a1 a8       	sbr	r8,0x0
8000a5e2:	ae 68       	st.h	r7[0xc],r8
8000a5e4:	2f 1d       	sub	sp,-60
8000a5e6:	d8 22       	popm	r4-r7,pc

8000a5e8 <memchr>:
8000a5e8:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000a5ec:	c0 68       	rjmp	8000a5f8 <memchr+0x10>
8000a5ee:	20 1a       	sub	r10,1
8000a5f0:	19 88       	ld.ub	r8,r12[0x0]
8000a5f2:	16 38       	cp.w	r8,r11
8000a5f4:	5e 0c       	reteq	r12
8000a5f6:	2f fc       	sub	r12,-1
8000a5f8:	58 0a       	cp.w	r10,0
8000a5fa:	cf a1       	brne	8000a5ee <memchr+0x6>
8000a5fc:	5e fa       	retal	r10

8000a5fe <memmove>:
8000a5fe:	d4 01       	pushm	lr
8000a600:	18 3b       	cp.w	r11,r12
8000a602:	c1 92       	brcc	8000a634 <memmove+0x36>
8000a604:	f6 0a 00 09 	add	r9,r11,r10
8000a608:	12 3c       	cp.w	r12,r9
8000a60a:	c1 52       	brcc	8000a634 <memmove+0x36>
8000a60c:	f8 0a 00 0b 	add	r11,r12,r10
8000a610:	30 08       	mov	r8,0
8000a612:	c0 68       	rjmp	8000a61e <memmove+0x20>
8000a614:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000a618:	20 1a       	sub	r10,1
8000a61a:	f6 08 0b 0e 	st.b	r11[r8],lr
8000a61e:	20 18       	sub	r8,1
8000a620:	58 0a       	cp.w	r10,0
8000a622:	cf 91       	brne	8000a614 <memmove+0x16>
8000a624:	d8 02       	popm	pc
8000a626:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a62a:	20 1a       	sub	r10,1
8000a62c:	f8 08 0b 09 	st.b	r12[r8],r9
8000a630:	2f f8       	sub	r8,-1
8000a632:	c0 28       	rjmp	8000a636 <memmove+0x38>
8000a634:	30 08       	mov	r8,0
8000a636:	58 0a       	cp.w	r10,0
8000a638:	cf 71       	brne	8000a626 <memmove+0x28>
8000a63a:	d8 02       	popm	pc

8000a63c <__hi0bits>:
8000a63c:	18 98       	mov	r8,r12
8000a63e:	e0 1c 00 00 	andl	r12,0x0
8000a642:	f0 09 15 10 	lsl	r9,r8,0x10
8000a646:	58 0c       	cp.w	r12,0
8000a648:	f2 08 17 00 	moveq	r8,r9
8000a64c:	f9 bc 00 10 	moveq	r12,16
8000a650:	f9 bc 01 00 	movne	r12,0
8000a654:	10 9a       	mov	r10,r8
8000a656:	f0 09 15 08 	lsl	r9,r8,0x8
8000a65a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000a65e:	f7 bc 00 f8 	subeq	r12,-8
8000a662:	f2 08 17 00 	moveq	r8,r9
8000a666:	10 9a       	mov	r10,r8
8000a668:	f0 09 15 04 	lsl	r9,r8,0x4
8000a66c:	e6 1a f0 00 	andh	r10,0xf000,COH
8000a670:	f7 bc 00 fc 	subeq	r12,-4
8000a674:	f2 08 17 00 	moveq	r8,r9
8000a678:	10 9a       	mov	r10,r8
8000a67a:	f0 09 15 02 	lsl	r9,r8,0x2
8000a67e:	e6 1a c0 00 	andh	r10,0xc000,COH
8000a682:	f7 bc 00 fe 	subeq	r12,-2
8000a686:	f2 08 17 00 	moveq	r8,r9
8000a68a:	58 08       	cp.w	r8,0
8000a68c:	5e 5c       	retlt	r12
8000a68e:	ed b8 00 1e 	bld	r8,0x1e
8000a692:	f9 bc 01 20 	movne	r12,32
8000a696:	f7 bc 00 ff 	subeq	r12,-1
8000a69a:	5e fc       	retal	r12

8000a69c <__lo0bits>:
8000a69c:	18 99       	mov	r9,r12
8000a69e:	78 08       	ld.w	r8,r12[0x0]
8000a6a0:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000a6a4:	c1 50       	breq	8000a6ce <__lo0bits+0x32>
8000a6a6:	ed b8 00 00 	bld	r8,0x0
8000a6aa:	c0 21       	brne	8000a6ae <__lo0bits+0x12>
8000a6ac:	5e fd       	retal	0
8000a6ae:	10 9b       	mov	r11,r8
8000a6b0:	f0 0a 16 01 	lsr	r10,r8,0x1
8000a6b4:	e2 1b 00 02 	andl	r11,0x2,COH
8000a6b8:	a3 88       	lsr	r8,0x2
8000a6ba:	58 0b       	cp.w	r11,0
8000a6bc:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000a6c0:	f9 bc 01 01 	movne	r12,1
8000a6c4:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000a6c8:	f9 bc 00 02 	moveq	r12,2
8000a6cc:	5e fc       	retal	r12
8000a6ce:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000a6d2:	f0 0b 16 10 	lsr	r11,r8,0x10
8000a6d6:	58 0a       	cp.w	r10,0
8000a6d8:	f6 08 17 00 	moveq	r8,r11
8000a6dc:	f9 bc 00 10 	moveq	r12,16
8000a6e0:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000a6e4:	f0 0a 16 08 	lsr	r10,r8,0x8
8000a6e8:	58 0b       	cp.w	r11,0
8000a6ea:	f7 bc 00 f8 	subeq	r12,-8
8000a6ee:	f4 08 17 00 	moveq	r8,r10
8000a6f2:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000a6f6:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a6fa:	58 0b       	cp.w	r11,0
8000a6fc:	f7 bc 00 fc 	subeq	r12,-4
8000a700:	f4 08 17 00 	moveq	r8,r10
8000a704:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000a708:	f0 0a 16 02 	lsr	r10,r8,0x2
8000a70c:	58 0b       	cp.w	r11,0
8000a70e:	f7 bc 00 fe 	subeq	r12,-2
8000a712:	f4 08 17 00 	moveq	r8,r10
8000a716:	ed b8 00 00 	bld	r8,0x0
8000a71a:	c0 60       	breq	8000a726 <__lo0bits+0x8a>
8000a71c:	a1 98       	lsr	r8,0x1
8000a71e:	c0 31       	brne	8000a724 <__lo0bits+0x88>
8000a720:	32 0c       	mov	r12,32
8000a722:	5e fc       	retal	r12
8000a724:	2f fc       	sub	r12,-1
8000a726:	93 08       	st.w	r9[0x0],r8
8000a728:	5e fc       	retal	r12

8000a72a <__mcmp>:
8000a72a:	d4 01       	pushm	lr
8000a72c:	18 98       	mov	r8,r12
8000a72e:	76 49       	ld.w	r9,r11[0x10]
8000a730:	78 4c       	ld.w	r12,r12[0x10]
8000a732:	12 1c       	sub	r12,r9
8000a734:	c1 31       	brne	8000a75a <__mcmp+0x30>
8000a736:	2f b9       	sub	r9,-5
8000a738:	a3 69       	lsl	r9,0x2
8000a73a:	12 0b       	add	r11,r9
8000a73c:	f0 09 00 09 	add	r9,r8,r9
8000a740:	2e c8       	sub	r8,-20
8000a742:	13 4e       	ld.w	lr,--r9
8000a744:	17 4a       	ld.w	r10,--r11
8000a746:	14 3e       	cp.w	lr,r10
8000a748:	c0 60       	breq	8000a754 <__mcmp+0x2a>
8000a74a:	f9 bc 03 ff 	movlo	r12,-1
8000a74e:	f9 bc 02 01 	movhs	r12,1
8000a752:	d8 02       	popm	pc
8000a754:	10 39       	cp.w	r9,r8
8000a756:	fe 9b ff f6 	brhi	8000a742 <__mcmp+0x18>
8000a75a:	d8 02       	popm	pc

8000a75c <_Bfree>:
8000a75c:	d4 21       	pushm	r4-r7,lr
8000a75e:	18 97       	mov	r7,r12
8000a760:	16 95       	mov	r5,r11
8000a762:	78 96       	ld.w	r6,r12[0x24]
8000a764:	58 06       	cp.w	r6,0
8000a766:	c0 91       	brne	8000a778 <_Bfree+0x1c>
8000a768:	31 0c       	mov	r12,16
8000a76a:	fe b0 de 1b 	rcall	800063a0 <malloc>
8000a76e:	99 36       	st.w	r12[0xc],r6
8000a770:	8f 9c       	st.w	r7[0x24],r12
8000a772:	99 16       	st.w	r12[0x4],r6
8000a774:	99 26       	st.w	r12[0x8],r6
8000a776:	99 06       	st.w	r12[0x0],r6
8000a778:	58 05       	cp.w	r5,0
8000a77a:	c0 90       	breq	8000a78c <_Bfree+0x30>
8000a77c:	6a 19       	ld.w	r9,r5[0x4]
8000a77e:	6e 98       	ld.w	r8,r7[0x24]
8000a780:	70 38       	ld.w	r8,r8[0xc]
8000a782:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000a786:	8b 0a       	st.w	r5[0x0],r10
8000a788:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000a78c:	d8 22       	popm	r4-r7,pc
8000a78e:	d7 03       	nop

8000a790 <_Balloc>:
8000a790:	d4 21       	pushm	r4-r7,lr
8000a792:	18 97       	mov	r7,r12
8000a794:	16 96       	mov	r6,r11
8000a796:	78 95       	ld.w	r5,r12[0x24]
8000a798:	58 05       	cp.w	r5,0
8000a79a:	c0 91       	brne	8000a7ac <_Balloc+0x1c>
8000a79c:	31 0c       	mov	r12,16
8000a79e:	fe b0 de 01 	rcall	800063a0 <malloc>
8000a7a2:	99 35       	st.w	r12[0xc],r5
8000a7a4:	8f 9c       	st.w	r7[0x24],r12
8000a7a6:	99 15       	st.w	r12[0x4],r5
8000a7a8:	99 25       	st.w	r12[0x8],r5
8000a7aa:	99 05       	st.w	r12[0x0],r5
8000a7ac:	6e 95       	ld.w	r5,r7[0x24]
8000a7ae:	6a 38       	ld.w	r8,r5[0xc]
8000a7b0:	58 08       	cp.w	r8,0
8000a7b2:	c0 b1       	brne	8000a7c8 <_Balloc+0x38>
8000a7b4:	31 0a       	mov	r10,16
8000a7b6:	30 4b       	mov	r11,4
8000a7b8:	0e 9c       	mov	r12,r7
8000a7ba:	e0 a0 02 9d 	rcall	8000acf4 <_calloc_r>
8000a7be:	8b 3c       	st.w	r5[0xc],r12
8000a7c0:	6e 98       	ld.w	r8,r7[0x24]
8000a7c2:	70 3c       	ld.w	r12,r8[0xc]
8000a7c4:	58 0c       	cp.w	r12,0
8000a7c6:	c1 b0       	breq	8000a7fc <_Balloc+0x6c>
8000a7c8:	6e 98       	ld.w	r8,r7[0x24]
8000a7ca:	70 38       	ld.w	r8,r8[0xc]
8000a7cc:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000a7d0:	70 0c       	ld.w	r12,r8[0x0]
8000a7d2:	58 0c       	cp.w	r12,0
8000a7d4:	c0 40       	breq	8000a7dc <_Balloc+0x4c>
8000a7d6:	78 09       	ld.w	r9,r12[0x0]
8000a7d8:	91 09       	st.w	r8[0x0],r9
8000a7da:	c0 e8       	rjmp	8000a7f6 <_Balloc+0x66>
8000a7dc:	0e 9c       	mov	r12,r7
8000a7de:	30 17       	mov	r7,1
8000a7e0:	0e 9b       	mov	r11,r7
8000a7e2:	ee 06 09 47 	lsl	r7,r7,r6
8000a7e6:	ee ca ff fb 	sub	r10,r7,-5
8000a7ea:	a3 6a       	lsl	r10,0x2
8000a7ec:	e0 a0 02 84 	rcall	8000acf4 <_calloc_r>
8000a7f0:	c0 60       	breq	8000a7fc <_Balloc+0x6c>
8000a7f2:	99 16       	st.w	r12[0x4],r6
8000a7f4:	99 27       	st.w	r12[0x8],r7
8000a7f6:	30 08       	mov	r8,0
8000a7f8:	99 38       	st.w	r12[0xc],r8
8000a7fa:	99 48       	st.w	r12[0x10],r8
8000a7fc:	d8 22       	popm	r4-r7,pc
8000a7fe:	d7 03       	nop

8000a800 <__d2b>:
8000a800:	d4 31       	pushm	r0-r7,lr
8000a802:	20 2d       	sub	sp,8
8000a804:	16 93       	mov	r3,r11
8000a806:	12 96       	mov	r6,r9
8000a808:	10 95       	mov	r5,r8
8000a80a:	14 92       	mov	r2,r10
8000a80c:	30 1b       	mov	r11,1
8000a80e:	cc 1f       	rcall	8000a790 <_Balloc>
8000a810:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000a814:	50 09       	stdsp	sp[0x0],r9
8000a816:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000a81a:	b5 a9       	sbr	r9,0x14
8000a81c:	f0 01 16 14 	lsr	r1,r8,0x14
8000a820:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a824:	18 94       	mov	r4,r12
8000a826:	58 02       	cp.w	r2,0
8000a828:	c1 d0       	breq	8000a862 <__d2b+0x62>
8000a82a:	fa cc ff f8 	sub	r12,sp,-8
8000a82e:	18 d2       	st.w	--r12,r2
8000a830:	c3 6f       	rcall	8000a69c <__lo0bits>
8000a832:	40 18       	lddsp	r8,sp[0x4]
8000a834:	c0 d0       	breq	8000a84e <__d2b+0x4e>
8000a836:	40 09       	lddsp	r9,sp[0x0]
8000a838:	f8 0a 11 20 	rsub	r10,r12,32
8000a83c:	f2 0a 09 4a 	lsl	r10,r9,r10
8000a840:	f5 e8 10 08 	or	r8,r10,r8
8000a844:	89 58       	st.w	r4[0x14],r8
8000a846:	f2 0c 0a 49 	lsr	r9,r9,r12
8000a84a:	50 09       	stdsp	sp[0x0],r9
8000a84c:	c0 28       	rjmp	8000a850 <__d2b+0x50>
8000a84e:	89 58       	st.w	r4[0x14],r8
8000a850:	40 08       	lddsp	r8,sp[0x0]
8000a852:	58 08       	cp.w	r8,0
8000a854:	f9 b3 01 02 	movne	r3,2
8000a858:	f9 b3 00 01 	moveq	r3,1
8000a85c:	89 68       	st.w	r4[0x18],r8
8000a85e:	89 43       	st.w	r4[0x10],r3
8000a860:	c0 88       	rjmp	8000a870 <__d2b+0x70>
8000a862:	1a 9c       	mov	r12,sp
8000a864:	c1 cf       	rcall	8000a69c <__lo0bits>
8000a866:	30 13       	mov	r3,1
8000a868:	40 08       	lddsp	r8,sp[0x0]
8000a86a:	2e 0c       	sub	r12,-32
8000a86c:	89 43       	st.w	r4[0x10],r3
8000a86e:	89 58       	st.w	r4[0x14],r8
8000a870:	58 01       	cp.w	r1,0
8000a872:	c0 90       	breq	8000a884 <__d2b+0x84>
8000a874:	e2 c1 04 33 	sub	r1,r1,1075
8000a878:	18 01       	add	r1,r12
8000a87a:	8d 01       	st.w	r6[0x0],r1
8000a87c:	f8 0c 11 35 	rsub	r12,r12,53
8000a880:	8b 0c       	st.w	r5[0x0],r12
8000a882:	c0 c8       	rjmp	8000a89a <__d2b+0x9a>
8000a884:	e6 c8 ff fc 	sub	r8,r3,-4
8000a888:	f8 cc 04 32 	sub	r12,r12,1074
8000a88c:	a5 73       	lsl	r3,0x5
8000a88e:	8d 0c       	st.w	r6[0x0],r12
8000a890:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000a894:	cd 4e       	rcall	8000a63c <__hi0bits>
8000a896:	18 13       	sub	r3,r12
8000a898:	8b 03       	st.w	r5[0x0],r3
8000a89a:	08 9c       	mov	r12,r4
8000a89c:	2f ed       	sub	sp,-8
8000a89e:	d8 32       	popm	r0-r7,pc

8000a8a0 <__mdiff>:
8000a8a0:	d4 31       	pushm	r0-r7,lr
8000a8a2:	74 48       	ld.w	r8,r10[0x10]
8000a8a4:	76 45       	ld.w	r5,r11[0x10]
8000a8a6:	16 97       	mov	r7,r11
8000a8a8:	14 96       	mov	r6,r10
8000a8aa:	10 15       	sub	r5,r8
8000a8ac:	c1 31       	brne	8000a8d2 <__mdiff+0x32>
8000a8ae:	2f b8       	sub	r8,-5
8000a8b0:	ee ce ff ec 	sub	lr,r7,-20
8000a8b4:	a3 68       	lsl	r8,0x2
8000a8b6:	f4 08 00 0b 	add	r11,r10,r8
8000a8ba:	ee 08 00 08 	add	r8,r7,r8
8000a8be:	11 4a       	ld.w	r10,--r8
8000a8c0:	17 49       	ld.w	r9,--r11
8000a8c2:	12 3a       	cp.w	r10,r9
8000a8c4:	c0 30       	breq	8000a8ca <__mdiff+0x2a>
8000a8c6:	c0 e2       	brcc	8000a8e2 <__mdiff+0x42>
8000a8c8:	c0 78       	rjmp	8000a8d6 <__mdiff+0x36>
8000a8ca:	1c 38       	cp.w	r8,lr
8000a8cc:	fe 9b ff f9 	brhi	8000a8be <__mdiff+0x1e>
8000a8d0:	c4 98       	rjmp	8000a962 <__mdiff+0xc2>
8000a8d2:	58 05       	cp.w	r5,0
8000a8d4:	c0 64       	brge	8000a8e0 <__mdiff+0x40>
8000a8d6:	0e 98       	mov	r8,r7
8000a8d8:	30 15       	mov	r5,1
8000a8da:	0c 97       	mov	r7,r6
8000a8dc:	10 96       	mov	r6,r8
8000a8de:	c0 28       	rjmp	8000a8e2 <__mdiff+0x42>
8000a8e0:	30 05       	mov	r5,0
8000a8e2:	6e 1b       	ld.w	r11,r7[0x4]
8000a8e4:	c5 6f       	rcall	8000a790 <_Balloc>
8000a8e6:	6e 49       	ld.w	r9,r7[0x10]
8000a8e8:	6c 44       	ld.w	r4,r6[0x10]
8000a8ea:	99 35       	st.w	r12[0xc],r5
8000a8ec:	2f b4       	sub	r4,-5
8000a8ee:	f2 c5 ff fb 	sub	r5,r9,-5
8000a8f2:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000a8f6:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000a8fa:	2e c6       	sub	r6,-20
8000a8fc:	2e c7       	sub	r7,-20
8000a8fe:	f8 c8 ff ec 	sub	r8,r12,-20
8000a902:	30 0a       	mov	r10,0
8000a904:	0f 0e       	ld.w	lr,r7++
8000a906:	0d 0b       	ld.w	r11,r6++
8000a908:	fc 02 16 10 	lsr	r2,lr,0x10
8000a90c:	f6 03 16 10 	lsr	r3,r11,0x10
8000a910:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a914:	e4 03 01 03 	sub	r3,r2,r3
8000a918:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a91c:	fc 0b 01 0b 	sub	r11,lr,r11
8000a920:	f6 0a 00 0a 	add	r10,r11,r10
8000a924:	b0 1a       	st.h	r8[0x2],r10
8000a926:	b1 4a       	asr	r10,0x10
8000a928:	e6 0a 00 0a 	add	r10,r3,r10
8000a92c:	b0 0a       	st.h	r8[0x0],r10
8000a92e:	2f c8       	sub	r8,-4
8000a930:	b1 4a       	asr	r10,0x10
8000a932:	08 36       	cp.w	r6,r4
8000a934:	ce 83       	brcs	8000a904 <__mdiff+0x64>
8000a936:	c0 d8       	rjmp	8000a950 <__mdiff+0xb0>
8000a938:	0f 0b       	ld.w	r11,r7++
8000a93a:	f6 0e 16 10 	lsr	lr,r11,0x10
8000a93e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a942:	16 0a       	add	r10,r11
8000a944:	b0 1a       	st.h	r8[0x2],r10
8000a946:	b1 4a       	asr	r10,0x10
8000a948:	1c 0a       	add	r10,lr
8000a94a:	b0 0a       	st.h	r8[0x0],r10
8000a94c:	2f c8       	sub	r8,-4
8000a94e:	b1 4a       	asr	r10,0x10
8000a950:	0a 37       	cp.w	r7,r5
8000a952:	cf 33       	brcs	8000a938 <__mdiff+0x98>
8000a954:	c0 28       	rjmp	8000a958 <__mdiff+0xb8>
8000a956:	20 19       	sub	r9,1
8000a958:	11 4a       	ld.w	r10,--r8
8000a95a:	58 0a       	cp.w	r10,0
8000a95c:	cf d0       	breq	8000a956 <__mdiff+0xb6>
8000a95e:	99 49       	st.w	r12[0x10],r9
8000a960:	d8 32       	popm	r0-r7,pc
8000a962:	30 0b       	mov	r11,0
8000a964:	c1 6f       	rcall	8000a790 <_Balloc>
8000a966:	30 18       	mov	r8,1
8000a968:	99 48       	st.w	r12[0x10],r8
8000a96a:	30 08       	mov	r8,0
8000a96c:	99 58       	st.w	r12[0x14],r8
8000a96e:	d8 32       	popm	r0-r7,pc

8000a970 <__lshift>:
8000a970:	d4 31       	pushm	r0-r7,lr
8000a972:	16 97       	mov	r7,r11
8000a974:	76 46       	ld.w	r6,r11[0x10]
8000a976:	f4 02 14 05 	asr	r2,r10,0x5
8000a97a:	2f f6       	sub	r6,-1
8000a97c:	14 93       	mov	r3,r10
8000a97e:	18 94       	mov	r4,r12
8000a980:	04 06       	add	r6,r2
8000a982:	76 1b       	ld.w	r11,r11[0x4]
8000a984:	6e 28       	ld.w	r8,r7[0x8]
8000a986:	c0 38       	rjmp	8000a98c <__lshift+0x1c>
8000a988:	2f fb       	sub	r11,-1
8000a98a:	a1 78       	lsl	r8,0x1
8000a98c:	10 36       	cp.w	r6,r8
8000a98e:	fe 99 ff fd 	brgt	8000a988 <__lshift+0x18>
8000a992:	08 9c       	mov	r12,r4
8000a994:	cf ee       	rcall	8000a790 <_Balloc>
8000a996:	30 09       	mov	r9,0
8000a998:	18 95       	mov	r5,r12
8000a99a:	f8 c8 ff ec 	sub	r8,r12,-20
8000a99e:	12 9a       	mov	r10,r9
8000a9a0:	c0 38       	rjmp	8000a9a6 <__lshift+0x36>
8000a9a2:	10 aa       	st.w	r8++,r10
8000a9a4:	2f f9       	sub	r9,-1
8000a9a6:	04 39       	cp.w	r9,r2
8000a9a8:	cf d5       	brlt	8000a9a2 <__lshift+0x32>
8000a9aa:	6e 4b       	ld.w	r11,r7[0x10]
8000a9ac:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000a9b0:	2f bb       	sub	r11,-5
8000a9b2:	ee c9 ff ec 	sub	r9,r7,-20
8000a9b6:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000a9ba:	58 03       	cp.w	r3,0
8000a9bc:	c1 30       	breq	8000a9e2 <__lshift+0x72>
8000a9be:	e6 0c 11 20 	rsub	r12,r3,32
8000a9c2:	30 0a       	mov	r10,0
8000a9c4:	72 02       	ld.w	r2,r9[0x0]
8000a9c6:	e4 03 09 42 	lsl	r2,r2,r3
8000a9ca:	04 4a       	or	r10,r2
8000a9cc:	10 aa       	st.w	r8++,r10
8000a9ce:	13 0a       	ld.w	r10,r9++
8000a9d0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000a9d4:	16 39       	cp.w	r9,r11
8000a9d6:	cf 73       	brcs	8000a9c4 <__lshift+0x54>
8000a9d8:	91 0a       	st.w	r8[0x0],r10
8000a9da:	58 0a       	cp.w	r10,0
8000a9dc:	c0 70       	breq	8000a9ea <__lshift+0x7a>
8000a9de:	2f f6       	sub	r6,-1
8000a9e0:	c0 58       	rjmp	8000a9ea <__lshift+0x7a>
8000a9e2:	13 0a       	ld.w	r10,r9++
8000a9e4:	10 aa       	st.w	r8++,r10
8000a9e6:	16 39       	cp.w	r9,r11
8000a9e8:	cf d3       	brcs	8000a9e2 <__lshift+0x72>
8000a9ea:	08 9c       	mov	r12,r4
8000a9ec:	20 16       	sub	r6,1
8000a9ee:	0e 9b       	mov	r11,r7
8000a9f0:	8b 46       	st.w	r5[0x10],r6
8000a9f2:	cb 5e       	rcall	8000a75c <_Bfree>
8000a9f4:	0a 9c       	mov	r12,r5
8000a9f6:	d8 32       	popm	r0-r7,pc

8000a9f8 <__multiply>:
8000a9f8:	d4 31       	pushm	r0-r7,lr
8000a9fa:	20 2d       	sub	sp,8
8000a9fc:	76 49       	ld.w	r9,r11[0x10]
8000a9fe:	74 48       	ld.w	r8,r10[0x10]
8000aa00:	16 96       	mov	r6,r11
8000aa02:	14 95       	mov	r5,r10
8000aa04:	10 39       	cp.w	r9,r8
8000aa06:	ec 08 17 50 	movlt	r8,r6
8000aa0a:	ea 06 17 50 	movlt	r6,r5
8000aa0e:	f0 05 17 50 	movlt	r5,r8
8000aa12:	6c 28       	ld.w	r8,r6[0x8]
8000aa14:	76 43       	ld.w	r3,r11[0x10]
8000aa16:	74 42       	ld.w	r2,r10[0x10]
8000aa18:	76 1b       	ld.w	r11,r11[0x4]
8000aa1a:	e4 03 00 07 	add	r7,r2,r3
8000aa1e:	10 37       	cp.w	r7,r8
8000aa20:	f7 bb 09 ff 	subgt	r11,-1
8000aa24:	cb 6e       	rcall	8000a790 <_Balloc>
8000aa26:	ee c4 ff fb 	sub	r4,r7,-5
8000aa2a:	f8 c9 ff ec 	sub	r9,r12,-20
8000aa2e:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000aa32:	30 0a       	mov	r10,0
8000aa34:	12 98       	mov	r8,r9
8000aa36:	c0 28       	rjmp	8000aa3a <__multiply+0x42>
8000aa38:	10 aa       	st.w	r8++,r10
8000aa3a:	08 38       	cp.w	r8,r4
8000aa3c:	cf e3       	brcs	8000aa38 <__multiply+0x40>
8000aa3e:	2f b3       	sub	r3,-5
8000aa40:	2f b2       	sub	r2,-5
8000aa42:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000aa46:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000aa4a:	ec cb ff ec 	sub	r11,r6,-20
8000aa4e:	50 12       	stdsp	sp[0x4],r2
8000aa50:	ea ca ff ec 	sub	r10,r5,-20
8000aa54:	c4 48       	rjmp	8000aadc <__multiply+0xe4>
8000aa56:	94 95       	ld.uh	r5,r10[0x2]
8000aa58:	58 05       	cp.w	r5,0
8000aa5a:	c2 00       	breq	8000aa9a <__multiply+0xa2>
8000aa5c:	12 98       	mov	r8,r9
8000aa5e:	16 96       	mov	r6,r11
8000aa60:	30 0e       	mov	lr,0
8000aa62:	50 09       	stdsp	sp[0x0],r9
8000aa64:	0d 02       	ld.w	r2,r6++
8000aa66:	e4 00 16 10 	lsr	r0,r2,0x10
8000aa6a:	70 01       	ld.w	r1,r8[0x0]
8000aa6c:	70 09       	ld.w	r9,r8[0x0]
8000aa6e:	b1 81       	lsr	r1,0x10
8000aa70:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000aa74:	e0 05 03 41 	mac	r1,r0,r5
8000aa78:	ab 32       	mul	r2,r5
8000aa7a:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000aa7e:	00 02       	add	r2,r0
8000aa80:	e4 0e 00 0e 	add	lr,r2,lr
8000aa84:	b0 1e       	st.h	r8[0x2],lr
8000aa86:	b1 8e       	lsr	lr,0x10
8000aa88:	1c 01       	add	r1,lr
8000aa8a:	b0 01       	st.h	r8[0x0],r1
8000aa8c:	e2 0e 16 10 	lsr	lr,r1,0x10
8000aa90:	2f c8       	sub	r8,-4
8000aa92:	06 36       	cp.w	r6,r3
8000aa94:	ce 83       	brcs	8000aa64 <__multiply+0x6c>
8000aa96:	40 09       	lddsp	r9,sp[0x0]
8000aa98:	91 0e       	st.w	r8[0x0],lr
8000aa9a:	94 86       	ld.uh	r6,r10[0x0]
8000aa9c:	58 06       	cp.w	r6,0
8000aa9e:	c1 d0       	breq	8000aad8 <__multiply+0xe0>
8000aaa0:	72 02       	ld.w	r2,r9[0x0]
8000aaa2:	12 98       	mov	r8,r9
8000aaa4:	16 9e       	mov	lr,r11
8000aaa6:	30 05       	mov	r5,0
8000aaa8:	b0 12       	st.h	r8[0x2],r2
8000aaaa:	1d 01       	ld.w	r1,lr++
8000aaac:	90 82       	ld.uh	r2,r8[0x0]
8000aaae:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000aab2:	ad 30       	mul	r0,r6
8000aab4:	e0 02 00 02 	add	r2,r0,r2
8000aab8:	e4 05 00 05 	add	r5,r2,r5
8000aabc:	b0 05       	st.h	r8[0x0],r5
8000aabe:	b1 85       	lsr	r5,0x10
8000aac0:	b1 81       	lsr	r1,0x10
8000aac2:	2f c8       	sub	r8,-4
8000aac4:	ad 31       	mul	r1,r6
8000aac6:	90 92       	ld.uh	r2,r8[0x2]
8000aac8:	e2 02 00 02 	add	r2,r1,r2
8000aacc:	0a 02       	add	r2,r5
8000aace:	e4 05 16 10 	lsr	r5,r2,0x10
8000aad2:	06 3e       	cp.w	lr,r3
8000aad4:	ce a3       	brcs	8000aaa8 <__multiply+0xb0>
8000aad6:	91 02       	st.w	r8[0x0],r2
8000aad8:	2f ca       	sub	r10,-4
8000aada:	2f c9       	sub	r9,-4
8000aadc:	40 18       	lddsp	r8,sp[0x4]
8000aade:	10 3a       	cp.w	r10,r8
8000aae0:	cb b3       	brcs	8000aa56 <__multiply+0x5e>
8000aae2:	c0 28       	rjmp	8000aae6 <__multiply+0xee>
8000aae4:	20 17       	sub	r7,1
8000aae6:	58 07       	cp.w	r7,0
8000aae8:	e0 8a 00 05 	brle	8000aaf2 <__multiply+0xfa>
8000aaec:	09 48       	ld.w	r8,--r4
8000aaee:	58 08       	cp.w	r8,0
8000aaf0:	cf a0       	breq	8000aae4 <__multiply+0xec>
8000aaf2:	99 47       	st.w	r12[0x10],r7
8000aaf4:	2f ed       	sub	sp,-8
8000aaf6:	d8 32       	popm	r0-r7,pc

8000aaf8 <__i2b>:
8000aaf8:	d4 21       	pushm	r4-r7,lr
8000aafa:	16 97       	mov	r7,r11
8000aafc:	30 1b       	mov	r11,1
8000aafe:	c4 9e       	rcall	8000a790 <_Balloc>
8000ab00:	30 19       	mov	r9,1
8000ab02:	99 57       	st.w	r12[0x14],r7
8000ab04:	99 49       	st.w	r12[0x10],r9
8000ab06:	d8 22       	popm	r4-r7,pc

8000ab08 <__multadd>:
8000ab08:	d4 31       	pushm	r0-r7,lr
8000ab0a:	30 08       	mov	r8,0
8000ab0c:	12 95       	mov	r5,r9
8000ab0e:	16 97       	mov	r7,r11
8000ab10:	18 96       	mov	r6,r12
8000ab12:	76 44       	ld.w	r4,r11[0x10]
8000ab14:	f6 c9 ff ec 	sub	r9,r11,-20
8000ab18:	72 0b       	ld.w	r11,r9[0x0]
8000ab1a:	f6 0c 16 10 	lsr	r12,r11,0x10
8000ab1e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ab22:	f4 0c 02 4c 	mul	r12,r10,r12
8000ab26:	f4 0b 03 45 	mac	r5,r10,r11
8000ab2a:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000ab2e:	b1 85       	lsr	r5,0x10
8000ab30:	18 05       	add	r5,r12
8000ab32:	ea 0c 15 10 	lsl	r12,r5,0x10
8000ab36:	f8 0b 00 0b 	add	r11,r12,r11
8000ab3a:	12 ab       	st.w	r9++,r11
8000ab3c:	2f f8       	sub	r8,-1
8000ab3e:	b1 85       	lsr	r5,0x10
8000ab40:	08 38       	cp.w	r8,r4
8000ab42:	ce b5       	brlt	8000ab18 <__multadd+0x10>
8000ab44:	58 05       	cp.w	r5,0
8000ab46:	c1 c0       	breq	8000ab7e <__multadd+0x76>
8000ab48:	6e 28       	ld.w	r8,r7[0x8]
8000ab4a:	10 34       	cp.w	r4,r8
8000ab4c:	c1 35       	brlt	8000ab72 <__multadd+0x6a>
8000ab4e:	6e 1b       	ld.w	r11,r7[0x4]
8000ab50:	0c 9c       	mov	r12,r6
8000ab52:	2f fb       	sub	r11,-1
8000ab54:	c1 ee       	rcall	8000a790 <_Balloc>
8000ab56:	6e 4a       	ld.w	r10,r7[0x10]
8000ab58:	ee cb ff f4 	sub	r11,r7,-12
8000ab5c:	18 93       	mov	r3,r12
8000ab5e:	2f ea       	sub	r10,-2
8000ab60:	2f 4c       	sub	r12,-12
8000ab62:	a3 6a       	lsl	r10,0x2
8000ab64:	fe b0 de 42 	rcall	800067e8 <memcpy>
8000ab68:	0e 9b       	mov	r11,r7
8000ab6a:	0c 9c       	mov	r12,r6
8000ab6c:	fe b0 fd f8 	rcall	8000a75c <_Bfree>
8000ab70:	06 97       	mov	r7,r3
8000ab72:	e8 c8 ff ff 	sub	r8,r4,-1
8000ab76:	2f b4       	sub	r4,-5
8000ab78:	8f 48       	st.w	r7[0x10],r8
8000ab7a:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000ab7e:	0e 9c       	mov	r12,r7
8000ab80:	d8 32       	popm	r0-r7,pc
8000ab82:	d7 03       	nop

8000ab84 <__pow5mult>:
8000ab84:	d4 31       	pushm	r0-r7,lr
8000ab86:	14 96       	mov	r6,r10
8000ab88:	18 97       	mov	r7,r12
8000ab8a:	16 94       	mov	r4,r11
8000ab8c:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000ab90:	c0 80       	breq	8000aba0 <__pow5mult+0x1c>
8000ab92:	20 18       	sub	r8,1
8000ab94:	49 f9       	lddpc	r9,8000ac10 <__pow5mult+0x8c>
8000ab96:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000ab9a:	30 09       	mov	r9,0
8000ab9c:	cb 6f       	rcall	8000ab08 <__multadd>
8000ab9e:	18 94       	mov	r4,r12
8000aba0:	a3 46       	asr	r6,0x2
8000aba2:	c3 40       	breq	8000ac0a <__pow5mult+0x86>
8000aba4:	6e 95       	ld.w	r5,r7[0x24]
8000aba6:	58 05       	cp.w	r5,0
8000aba8:	c0 91       	brne	8000abba <__pow5mult+0x36>
8000abaa:	31 0c       	mov	r12,16
8000abac:	fe b0 db fa 	rcall	800063a0 <malloc>
8000abb0:	99 35       	st.w	r12[0xc],r5
8000abb2:	8f 9c       	st.w	r7[0x24],r12
8000abb4:	99 15       	st.w	r12[0x4],r5
8000abb6:	99 25       	st.w	r12[0x8],r5
8000abb8:	99 05       	st.w	r12[0x0],r5
8000abba:	6e 93       	ld.w	r3,r7[0x24]
8000abbc:	66 25       	ld.w	r5,r3[0x8]
8000abbe:	58 05       	cp.w	r5,0
8000abc0:	c0 c1       	brne	8000abd8 <__pow5mult+0x54>
8000abc2:	e0 6b 02 71 	mov	r11,625
8000abc6:	0e 9c       	mov	r12,r7
8000abc8:	c9 8f       	rcall	8000aaf8 <__i2b>
8000abca:	87 2c       	st.w	r3[0x8],r12
8000abcc:	30 08       	mov	r8,0
8000abce:	18 95       	mov	r5,r12
8000abd0:	99 08       	st.w	r12[0x0],r8
8000abd2:	c0 38       	rjmp	8000abd8 <__pow5mult+0x54>
8000abd4:	06 9c       	mov	r12,r3
8000abd6:	18 95       	mov	r5,r12
8000abd8:	ed b6 00 00 	bld	r6,0x0
8000abdc:	c0 b1       	brne	8000abf2 <__pow5mult+0x6e>
8000abde:	08 9b       	mov	r11,r4
8000abe0:	0a 9a       	mov	r10,r5
8000abe2:	0e 9c       	mov	r12,r7
8000abe4:	c0 af       	rcall	8000a9f8 <__multiply>
8000abe6:	08 9b       	mov	r11,r4
8000abe8:	18 93       	mov	r3,r12
8000abea:	0e 9c       	mov	r12,r7
8000abec:	06 94       	mov	r4,r3
8000abee:	fe b0 fd b7 	rcall	8000a75c <_Bfree>
8000abf2:	a1 56       	asr	r6,0x1
8000abf4:	c0 b0       	breq	8000ac0a <__pow5mult+0x86>
8000abf6:	6a 03       	ld.w	r3,r5[0x0]
8000abf8:	58 03       	cp.w	r3,0
8000abfa:	ce d1       	brne	8000abd4 <__pow5mult+0x50>
8000abfc:	0a 9a       	mov	r10,r5
8000abfe:	0a 9b       	mov	r11,r5
8000ac00:	0e 9c       	mov	r12,r7
8000ac02:	cf be       	rcall	8000a9f8 <__multiply>
8000ac04:	8b 0c       	st.w	r5[0x0],r12
8000ac06:	99 03       	st.w	r12[0x0],r3
8000ac08:	ce 7b       	rjmp	8000abd6 <__pow5mult+0x52>
8000ac0a:	08 9c       	mov	r12,r4
8000ac0c:	d8 32       	popm	r0-r7,pc
8000ac0e:	d7 03       	nop
8000ac10:	80 01       	ld.sh	r1,r0[0x0]
8000ac12:	54 58       	stdsp	sp[0x114],r8

8000ac14 <__isinfd>:
8000ac14:	14 98       	mov	r8,r10
8000ac16:	fc 19 7f f0 	movh	r9,0x7ff0
8000ac1a:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ac1e:	f0 0b 11 00 	rsub	r11,r8,0
8000ac22:	f7 e8 10 08 	or	r8,r11,r8
8000ac26:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000ac2a:	f2 08 01 08 	sub	r8,r9,r8
8000ac2e:	f0 0c 11 00 	rsub	r12,r8,0
8000ac32:	f9 e8 10 08 	or	r8,r12,r8
8000ac36:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000ac3a:	2f fc       	sub	r12,-1
8000ac3c:	5e fc       	retal	r12

8000ac3e <__isnand>:
8000ac3e:	14 98       	mov	r8,r10
8000ac40:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ac44:	f0 0c 11 00 	rsub	r12,r8,0
8000ac48:	10 4c       	or	r12,r8
8000ac4a:	fc 18 7f f0 	movh	r8,0x7ff0
8000ac4e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000ac52:	f0 0c 01 0c 	sub	r12,r8,r12
8000ac56:	bf 9c       	lsr	r12,0x1f
8000ac58:	5e fc       	retal	r12
8000ac5a:	d7 03       	nop

8000ac5c <__sclose>:
8000ac5c:	d4 01       	pushm	lr
8000ac5e:	96 7b       	ld.sh	r11,r11[0xe]
8000ac60:	c7 6c       	rcall	8000ad4c <_close_r>
8000ac62:	d8 02       	popm	pc

8000ac64 <__sseek>:
8000ac64:	d4 21       	pushm	r4-r7,lr
8000ac66:	16 97       	mov	r7,r11
8000ac68:	96 7b       	ld.sh	r11,r11[0xe]
8000ac6a:	cf 9c       	rcall	8000ae5c <_lseek_r>
8000ac6c:	8e 68       	ld.sh	r8,r7[0xc]
8000ac6e:	10 99       	mov	r9,r8
8000ac70:	ad c8       	cbr	r8,0xc
8000ac72:	ad a9       	sbr	r9,0xc
8000ac74:	5b fc       	cp.w	r12,-1
8000ac76:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000ac7a:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000ac7e:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000ac82:	d8 22       	popm	r4-r7,pc

8000ac84 <__swrite>:
8000ac84:	d4 21       	pushm	r4-r7,lr
8000ac86:	96 68       	ld.sh	r8,r11[0xc]
8000ac88:	16 97       	mov	r7,r11
8000ac8a:	14 95       	mov	r5,r10
8000ac8c:	12 94       	mov	r4,r9
8000ac8e:	e2 18 01 00 	andl	r8,0x100,COH
8000ac92:	18 96       	mov	r6,r12
8000ac94:	c0 50       	breq	8000ac9e <__swrite+0x1a>
8000ac96:	30 29       	mov	r9,2
8000ac98:	30 0a       	mov	r10,0
8000ac9a:	96 7b       	ld.sh	r11,r11[0xe]
8000ac9c:	ce 0c       	rcall	8000ae5c <_lseek_r>
8000ac9e:	8e 68       	ld.sh	r8,r7[0xc]
8000aca0:	ad c8       	cbr	r8,0xc
8000aca2:	08 99       	mov	r9,r4
8000aca4:	0a 9a       	mov	r10,r5
8000aca6:	8e 7b       	ld.sh	r11,r7[0xe]
8000aca8:	0c 9c       	mov	r12,r6
8000acaa:	ae 68       	st.h	r7[0xc],r8
8000acac:	c1 0c       	rcall	8000accc <_write_r>
8000acae:	d8 22       	popm	r4-r7,pc

8000acb0 <__sread>:
8000acb0:	d4 21       	pushm	r4-r7,lr
8000acb2:	16 97       	mov	r7,r11
8000acb4:	96 7b       	ld.sh	r11,r11[0xe]
8000acb6:	ce 7c       	rcall	8000ae84 <_read_r>
8000acb8:	c0 65       	brlt	8000acc4 <__sread+0x14>
8000acba:	6f 58       	ld.w	r8,r7[0x54]
8000acbc:	18 08       	add	r8,r12
8000acbe:	ef 48 00 54 	st.w	r7[84],r8
8000acc2:	d8 22       	popm	r4-r7,pc
8000acc4:	8e 68       	ld.sh	r8,r7[0xc]
8000acc6:	ad c8       	cbr	r8,0xc
8000acc8:	ae 68       	st.h	r7[0xc],r8
8000acca:	d8 22       	popm	r4-r7,pc

8000accc <_write_r>:
8000accc:	d4 21       	pushm	r4-r7,lr
8000acce:	16 98       	mov	r8,r11
8000acd0:	18 97       	mov	r7,r12
8000acd2:	10 9c       	mov	r12,r8
8000acd4:	30 08       	mov	r8,0
8000acd6:	14 9b       	mov	r11,r10
8000acd8:	e0 66 40 d0 	mov	r6,16592
8000acdc:	12 9a       	mov	r10,r9
8000acde:	8d 08       	st.w	r6[0x0],r8
8000ace0:	fe b0 d1 30 	rcall	80004f40 <_write>
8000ace4:	5b fc       	cp.w	r12,-1
8000ace6:	c0 51       	brne	8000acf0 <_write_r+0x24>
8000ace8:	6c 08       	ld.w	r8,r6[0x0]
8000acea:	58 08       	cp.w	r8,0
8000acec:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000acf0:	d8 22       	popm	r4-r7,pc
8000acf2:	d7 03       	nop

8000acf4 <_calloc_r>:
8000acf4:	d4 21       	pushm	r4-r7,lr
8000acf6:	f4 0b 02 4b 	mul	r11,r10,r11
8000acfa:	fe b0 db 5b 	rcall	800063b0 <_malloc_r>
8000acfe:	18 97       	mov	r7,r12
8000ad00:	c2 30       	breq	8000ad46 <_calloc_r+0x52>
8000ad02:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000ad06:	e0 1a ff fc 	andl	r10,0xfffc
8000ad0a:	20 4a       	sub	r10,4
8000ad0c:	e0 4a 00 24 	cp.w	r10,36
8000ad10:	e0 8b 00 18 	brhi	8000ad40 <_calloc_r+0x4c>
8000ad14:	18 98       	mov	r8,r12
8000ad16:	59 3a       	cp.w	r10,19
8000ad18:	e0 88 00 0f 	brls	8000ad36 <_calloc_r+0x42>
8000ad1c:	30 09       	mov	r9,0
8000ad1e:	10 a9       	st.w	r8++,r9
8000ad20:	10 a9       	st.w	r8++,r9
8000ad22:	59 ba       	cp.w	r10,27
8000ad24:	e0 88 00 09 	brls	8000ad36 <_calloc_r+0x42>
8000ad28:	10 a9       	st.w	r8++,r9
8000ad2a:	10 a9       	st.w	r8++,r9
8000ad2c:	e0 4a 00 24 	cp.w	r10,36
8000ad30:	c0 31       	brne	8000ad36 <_calloc_r+0x42>
8000ad32:	10 a9       	st.w	r8++,r9
8000ad34:	10 a9       	st.w	r8++,r9
8000ad36:	30 09       	mov	r9,0
8000ad38:	10 a9       	st.w	r8++,r9
8000ad3a:	91 19       	st.w	r8[0x4],r9
8000ad3c:	91 09       	st.w	r8[0x0],r9
8000ad3e:	c0 48       	rjmp	8000ad46 <_calloc_r+0x52>
8000ad40:	30 0b       	mov	r11,0
8000ad42:	fe b0 dd f7 	rcall	80006930 <memset>
8000ad46:	0e 9c       	mov	r12,r7
8000ad48:	d8 22       	popm	r4-r7,pc
8000ad4a:	d7 03       	nop

8000ad4c <_close_r>:
8000ad4c:	d4 21       	pushm	r4-r7,lr
8000ad4e:	30 08       	mov	r8,0
8000ad50:	18 97       	mov	r7,r12
8000ad52:	e0 66 40 d0 	mov	r6,16592
8000ad56:	16 9c       	mov	r12,r11
8000ad58:	8d 08       	st.w	r6[0x0],r8
8000ad5a:	fe b0 df a5 	rcall	80006ca4 <_close>
8000ad5e:	5b fc       	cp.w	r12,-1
8000ad60:	c0 51       	brne	8000ad6a <_close_r+0x1e>
8000ad62:	6c 08       	ld.w	r8,r6[0x0]
8000ad64:	58 08       	cp.w	r8,0
8000ad66:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ad6a:	d8 22       	popm	r4-r7,pc

8000ad6c <_fclose_r>:
8000ad6c:	d4 21       	pushm	r4-r7,lr
8000ad6e:	18 96       	mov	r6,r12
8000ad70:	16 97       	mov	r7,r11
8000ad72:	58 0b       	cp.w	r11,0
8000ad74:	c0 31       	brne	8000ad7a <_fclose_r+0xe>
8000ad76:	16 95       	mov	r5,r11
8000ad78:	c5 08       	rjmp	8000ae18 <_fclose_r+0xac>
8000ad7a:	fe b0 f8 b1 	rcall	80009edc <__sfp_lock_acquire>
8000ad7e:	58 06       	cp.w	r6,0
8000ad80:	c0 70       	breq	8000ad8e <_fclose_r+0x22>
8000ad82:	6c 68       	ld.w	r8,r6[0x18]
8000ad84:	58 08       	cp.w	r8,0
8000ad86:	c0 41       	brne	8000ad8e <_fclose_r+0x22>
8000ad88:	0c 9c       	mov	r12,r6
8000ad8a:	fe b0 f8 fd 	rcall	80009f84 <__sinit>
8000ad8e:	4a 48       	lddpc	r8,8000ae1c <_fclose_r+0xb0>
8000ad90:	10 37       	cp.w	r7,r8
8000ad92:	c0 31       	brne	8000ad98 <_fclose_r+0x2c>
8000ad94:	6c 07       	ld.w	r7,r6[0x0]
8000ad96:	c0 a8       	rjmp	8000adaa <_fclose_r+0x3e>
8000ad98:	4a 28       	lddpc	r8,8000ae20 <_fclose_r+0xb4>
8000ad9a:	10 37       	cp.w	r7,r8
8000ad9c:	c0 31       	brne	8000ada2 <_fclose_r+0x36>
8000ad9e:	6c 17       	ld.w	r7,r6[0x4]
8000ada0:	c0 58       	rjmp	8000adaa <_fclose_r+0x3e>
8000ada2:	4a 18       	lddpc	r8,8000ae24 <_fclose_r+0xb8>
8000ada4:	10 37       	cp.w	r7,r8
8000ada6:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000adaa:	8e 69       	ld.sh	r9,r7[0xc]
8000adac:	30 08       	mov	r8,0
8000adae:	f0 09 19 00 	cp.h	r9,r8
8000adb2:	c0 51       	brne	8000adbc <_fclose_r+0x50>
8000adb4:	fe b0 f8 95 	rcall	80009ede <__sfp_lock_release>
8000adb8:	30 05       	mov	r5,0
8000adba:	c2 f8       	rjmp	8000ae18 <_fclose_r+0xac>
8000adbc:	0e 9b       	mov	r11,r7
8000adbe:	0c 9c       	mov	r12,r6
8000adc0:	fe b0 f8 06 	rcall	80009dcc <_fflush_r>
8000adc4:	6e c8       	ld.w	r8,r7[0x30]
8000adc6:	18 95       	mov	r5,r12
8000adc8:	58 08       	cp.w	r8,0
8000adca:	c0 60       	breq	8000add6 <_fclose_r+0x6a>
8000adcc:	6e 8b       	ld.w	r11,r7[0x20]
8000adce:	0c 9c       	mov	r12,r6
8000add0:	5d 18       	icall	r8
8000add2:	f9 b5 05 ff 	movlt	r5,-1
8000add6:	8e 68       	ld.sh	r8,r7[0xc]
8000add8:	ed b8 00 07 	bld	r8,0x7
8000addc:	c0 51       	brne	8000ade6 <_fclose_r+0x7a>
8000adde:	6e 4b       	ld.w	r11,r7[0x10]
8000ade0:	0c 9c       	mov	r12,r6
8000ade2:	fe b0 f9 6b 	rcall	8000a0b8 <_free_r>
8000ade6:	6e db       	ld.w	r11,r7[0x34]
8000ade8:	58 0b       	cp.w	r11,0
8000adea:	c0 a0       	breq	8000adfe <_fclose_r+0x92>
8000adec:	ee c8 ff bc 	sub	r8,r7,-68
8000adf0:	10 3b       	cp.w	r11,r8
8000adf2:	c0 40       	breq	8000adfa <_fclose_r+0x8e>
8000adf4:	0c 9c       	mov	r12,r6
8000adf6:	fe b0 f9 61 	rcall	8000a0b8 <_free_r>
8000adfa:	30 08       	mov	r8,0
8000adfc:	8f d8       	st.w	r7[0x34],r8
8000adfe:	6f 2b       	ld.w	r11,r7[0x48]
8000ae00:	58 0b       	cp.w	r11,0
8000ae02:	c0 70       	breq	8000ae10 <_fclose_r+0xa4>
8000ae04:	0c 9c       	mov	r12,r6
8000ae06:	fe b0 f9 59 	rcall	8000a0b8 <_free_r>
8000ae0a:	30 08       	mov	r8,0
8000ae0c:	ef 48 00 48 	st.w	r7[72],r8
8000ae10:	30 08       	mov	r8,0
8000ae12:	ae 68       	st.h	r7[0xc],r8
8000ae14:	fe b0 f8 65 	rcall	80009ede <__sfp_lock_release>
8000ae18:	0a 9c       	mov	r12,r5
8000ae1a:	d8 22       	popm	r4-r7,pc
8000ae1c:	80 01       	ld.sh	r1,r0[0x0]
8000ae1e:	53 b4       	stdsp	sp[0xec],r4
8000ae20:	80 01       	ld.sh	r1,r0[0x0]
8000ae22:	53 d4       	stdsp	sp[0xf4],r4
8000ae24:	80 01       	ld.sh	r1,r0[0x0]
8000ae26:	53 f4       	stdsp	sp[0xfc],r4

8000ae28 <fclose>:
8000ae28:	d4 01       	pushm	lr
8000ae2a:	e0 68 0a 30 	mov	r8,2608
8000ae2e:	18 9b       	mov	r11,r12
8000ae30:	70 0c       	ld.w	r12,r8[0x0]
8000ae32:	c9 df       	rcall	8000ad6c <_fclose_r>
8000ae34:	d8 02       	popm	pc
8000ae36:	d7 03       	nop

8000ae38 <_fstat_r>:
8000ae38:	d4 21       	pushm	r4-r7,lr
8000ae3a:	16 98       	mov	r8,r11
8000ae3c:	18 97       	mov	r7,r12
8000ae3e:	10 9c       	mov	r12,r8
8000ae40:	30 08       	mov	r8,0
8000ae42:	e0 66 40 d0 	mov	r6,16592
8000ae46:	14 9b       	mov	r11,r10
8000ae48:	8d 08       	st.w	r6[0x0],r8
8000ae4a:	fe b0 df 55 	rcall	80006cf4 <_fstat>
8000ae4e:	5b fc       	cp.w	r12,-1
8000ae50:	c0 51       	brne	8000ae5a <_fstat_r+0x22>
8000ae52:	6c 08       	ld.w	r8,r6[0x0]
8000ae54:	58 08       	cp.w	r8,0
8000ae56:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ae5a:	d8 22       	popm	r4-r7,pc

8000ae5c <_lseek_r>:
8000ae5c:	d4 21       	pushm	r4-r7,lr
8000ae5e:	16 98       	mov	r8,r11
8000ae60:	18 97       	mov	r7,r12
8000ae62:	10 9c       	mov	r12,r8
8000ae64:	30 08       	mov	r8,0
8000ae66:	14 9b       	mov	r11,r10
8000ae68:	e0 66 40 d0 	mov	r6,16592
8000ae6c:	12 9a       	mov	r10,r9
8000ae6e:	8d 08       	st.w	r6[0x0],r8
8000ae70:	fe b0 df 24 	rcall	80006cb8 <_lseek>
8000ae74:	5b fc       	cp.w	r12,-1
8000ae76:	c0 51       	brne	8000ae80 <_lseek_r+0x24>
8000ae78:	6c 08       	ld.w	r8,r6[0x0]
8000ae7a:	58 08       	cp.w	r8,0
8000ae7c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ae80:	d8 22       	popm	r4-r7,pc
8000ae82:	d7 03       	nop

8000ae84 <_read_r>:
8000ae84:	d4 21       	pushm	r4-r7,lr
8000ae86:	16 98       	mov	r8,r11
8000ae88:	18 97       	mov	r7,r12
8000ae8a:	10 9c       	mov	r12,r8
8000ae8c:	30 08       	mov	r8,0
8000ae8e:	14 9b       	mov	r11,r10
8000ae90:	e0 66 40 d0 	mov	r6,16592
8000ae94:	12 9a       	mov	r10,r9
8000ae96:	8d 08       	st.w	r6[0x0],r8
8000ae98:	fe b0 d0 34 	rcall	80004f00 <_read>
8000ae9c:	5b fc       	cp.w	r12,-1
8000ae9e:	c0 51       	brne	8000aea8 <_read_r+0x24>
8000aea0:	6c 08       	ld.w	r8,r6[0x0]
8000aea2:	58 08       	cp.w	r8,0
8000aea4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000aea8:	d8 22       	popm	r4-r7,pc
8000aeaa:	d7 03       	nop

8000aeac <__avr32_f64_mul>:
8000aeac:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000aeb0:	e0 80 00 dc 	breq	8000b068 <__avr32_f64_mul_op1_zero>
8000aeb4:	d4 21       	pushm	r4-r7,lr
8000aeb6:	f7 e9 20 0e 	eor	lr,r11,r9
8000aeba:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000aebe:	30 15       	mov	r5,1
8000aec0:	c4 30       	breq	8000af46 <__avr32_f64_mul_op1_subnormal>
8000aec2:	ab 6b       	lsl	r11,0xa
8000aec4:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000aec8:	ab 6a       	lsl	r10,0xa
8000aeca:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000aece:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000aed2:	c5 c0       	breq	8000af8a <__avr32_f64_mul_op2_subnormal>
8000aed4:	a1 78       	lsl	r8,0x1
8000aed6:	5c f9       	rol	r9
8000aed8:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000aedc:	e0 47 07 ff 	cp.w	r7,2047
8000aee0:	c7 70       	breq	8000afce <__avr32_f64_mul_op_nan_or_inf>
8000aee2:	e0 46 07 ff 	cp.w	r6,2047
8000aee6:	c7 40       	breq	8000afce <__avr32_f64_mul_op_nan_or_inf>
8000aee8:	ee 06 00 0c 	add	r12,r7,r6
8000aeec:	e0 2c 03 fe 	sub	r12,1022
8000aef0:	f6 08 06 44 	mulu.d	r4,r11,r8
8000aef4:	f4 09 07 44 	macu.d	r4,r10,r9
8000aef8:	f4 08 06 46 	mulu.d	r6,r10,r8
8000aefc:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000af00:	08 07       	add	r7,r4
8000af02:	f4 05 00 4a 	adc	r10,r10,r5
8000af06:	5c 0b       	acr	r11
8000af08:	ed bb 00 14 	bld	r11,0x14
8000af0c:	c0 50       	breq	8000af16 <__avr32_f64_mul+0x6a>
8000af0e:	a1 77       	lsl	r7,0x1
8000af10:	5c fa       	rol	r10
8000af12:	5c fb       	rol	r11
8000af14:	20 1c       	sub	r12,1
8000af16:	58 0c       	cp.w	r12,0
8000af18:	e0 8a 00 6f 	brle	8000aff6 <__avr32_f64_mul_res_subnormal>
8000af1c:	e0 4c 07 ff 	cp.w	r12,2047
8000af20:	e0 84 00 9c 	brge	8000b058 <__avr32_f64_mul_res_inf>
8000af24:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000af28:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000af2c:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000af30:	ee 17 80 00 	eorh	r7,0x8000
8000af34:	f1 b7 04 20 	satu	r7,0x1
8000af38:	0e 0a       	add	r10,r7
8000af3a:	5c 0b       	acr	r11
8000af3c:	ed be 00 1f 	bld	lr,0x1f
8000af40:	ef bb 00 1f 	bst	r11,0x1f
8000af44:	d8 22       	popm	r4-r7,pc

8000af46 <__avr32_f64_mul_op1_subnormal>:
8000af46:	e4 1b 00 0f 	andh	r11,0xf
8000af4a:	f4 0c 12 00 	clz	r12,r10
8000af4e:	f6 06 12 00 	clz	r6,r11
8000af52:	f7 bc 03 e1 	sublo	r12,-31
8000af56:	f8 06 17 30 	movlo	r6,r12
8000af5a:	f7 b6 02 01 	subhs	r6,1
8000af5e:	e0 46 00 20 	cp.w	r6,32
8000af62:	c0 d4       	brge	8000af7c <__avr32_f64_mul_op1_subnormal+0x36>
8000af64:	ec 0c 11 20 	rsub	r12,r6,32
8000af68:	f6 06 09 4b 	lsl	r11,r11,r6
8000af6c:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000af70:	18 4b       	or	r11,r12
8000af72:	f4 06 09 4a 	lsl	r10,r10,r6
8000af76:	20 b6       	sub	r6,11
8000af78:	0c 17       	sub	r7,r6
8000af7a:	ca ab       	rjmp	8000aece <__avr32_f64_mul+0x22>
8000af7c:	f4 06 09 4b 	lsl	r11,r10,r6
8000af80:	c6 40       	breq	8000b048 <__avr32_f64_mul_res_zero>
8000af82:	30 0a       	mov	r10,0
8000af84:	20 b6       	sub	r6,11
8000af86:	0c 17       	sub	r7,r6
8000af88:	ca 3b       	rjmp	8000aece <__avr32_f64_mul+0x22>

8000af8a <__avr32_f64_mul_op2_subnormal>:
8000af8a:	e4 19 00 0f 	andh	r9,0xf
8000af8e:	f0 0c 12 00 	clz	r12,r8
8000af92:	f2 05 12 00 	clz	r5,r9
8000af96:	f7 bc 03 ea 	sublo	r12,-22
8000af9a:	f8 05 17 30 	movlo	r5,r12
8000af9e:	f7 b5 02 0a 	subhs	r5,10
8000afa2:	e0 45 00 20 	cp.w	r5,32
8000afa6:	c0 d4       	brge	8000afc0 <__avr32_f64_mul_op2_subnormal+0x36>
8000afa8:	ea 0c 11 20 	rsub	r12,r5,32
8000afac:	f2 05 09 49 	lsl	r9,r9,r5
8000afb0:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000afb4:	18 49       	or	r9,r12
8000afb6:	f0 05 09 48 	lsl	r8,r8,r5
8000afba:	20 25       	sub	r5,2
8000afbc:	0a 16       	sub	r6,r5
8000afbe:	c8 fb       	rjmp	8000aedc <__avr32_f64_mul+0x30>
8000afc0:	f0 05 09 49 	lsl	r9,r8,r5
8000afc4:	c4 20       	breq	8000b048 <__avr32_f64_mul_res_zero>
8000afc6:	30 08       	mov	r8,0
8000afc8:	20 25       	sub	r5,2
8000afca:	0a 16       	sub	r6,r5
8000afcc:	c8 8b       	rjmp	8000aedc <__avr32_f64_mul+0x30>

8000afce <__avr32_f64_mul_op_nan_or_inf>:
8000afce:	e4 19 00 0f 	andh	r9,0xf
8000afd2:	e4 1b 00 0f 	andh	r11,0xf
8000afd6:	14 4b       	or	r11,r10
8000afd8:	10 49       	or	r9,r8
8000afda:	e0 47 07 ff 	cp.w	r7,2047
8000afde:	c0 91       	brne	8000aff0 <__avr32_f64_mul_op1_not_naninf>
8000afe0:	58 0b       	cp.w	r11,0
8000afe2:	c3 81       	brne	8000b052 <__avr32_f64_mul_res_nan>
8000afe4:	e0 46 07 ff 	cp.w	r6,2047
8000afe8:	c3 81       	brne	8000b058 <__avr32_f64_mul_res_inf>
8000afea:	58 09       	cp.w	r9,0
8000afec:	c3 60       	breq	8000b058 <__avr32_f64_mul_res_inf>
8000afee:	c3 28       	rjmp	8000b052 <__avr32_f64_mul_res_nan>

8000aff0 <__avr32_f64_mul_op1_not_naninf>:
8000aff0:	58 09       	cp.w	r9,0
8000aff2:	c3 30       	breq	8000b058 <__avr32_f64_mul_res_inf>
8000aff4:	c2 f8       	rjmp	8000b052 <__avr32_f64_mul_res_nan>

8000aff6 <__avr32_f64_mul_res_subnormal>:
8000aff6:	5c 3c       	neg	r12
8000aff8:	2f fc       	sub	r12,-1
8000affa:	f1 bc 04 c0 	satu	r12,0x6
8000affe:	e0 4c 00 20 	cp.w	r12,32
8000b002:	c1 14       	brge	8000b024 <__avr32_f64_mul_res_subnormal+0x2e>
8000b004:	f8 08 11 20 	rsub	r8,r12,32
8000b008:	0e 46       	or	r6,r7
8000b00a:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b00e:	f4 08 09 49 	lsl	r9,r10,r8
8000b012:	12 47       	or	r7,r9
8000b014:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b018:	f6 08 09 49 	lsl	r9,r11,r8
8000b01c:	12 4a       	or	r10,r9
8000b01e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b022:	c8 3b       	rjmp	8000af28 <__avr32_f64_mul+0x7c>
8000b024:	f8 08 11 20 	rsub	r8,r12,32
8000b028:	f9 b9 00 00 	moveq	r9,0
8000b02c:	c0 30       	breq	8000b032 <__avr32_f64_mul_res_subnormal+0x3c>
8000b02e:	f6 08 09 49 	lsl	r9,r11,r8
8000b032:	0e 46       	or	r6,r7
8000b034:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b038:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b03c:	f3 ea 10 07 	or	r7,r9,r10
8000b040:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b044:	30 0b       	mov	r11,0
8000b046:	c7 1b       	rjmp	8000af28 <__avr32_f64_mul+0x7c>

8000b048 <__avr32_f64_mul_res_zero>:
8000b048:	1c 9b       	mov	r11,lr
8000b04a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b04e:	30 0a       	mov	r10,0
8000b050:	d8 22       	popm	r4-r7,pc

8000b052 <__avr32_f64_mul_res_nan>:
8000b052:	3f fb       	mov	r11,-1
8000b054:	3f fa       	mov	r10,-1
8000b056:	d8 22       	popm	r4-r7,pc

8000b058 <__avr32_f64_mul_res_inf>:
8000b058:	f0 6b 00 00 	mov	r11,-1048576
8000b05c:	ed be 00 1f 	bld	lr,0x1f
8000b060:	ef bb 00 1f 	bst	r11,0x1f
8000b064:	30 0a       	mov	r10,0
8000b066:	d8 22       	popm	r4-r7,pc

8000b068 <__avr32_f64_mul_op1_zero>:
8000b068:	f7 e9 20 0b 	eor	r11,r11,r9
8000b06c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b070:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b074:	e0 4c 07 ff 	cp.w	r12,2047
8000b078:	5e 1c       	retne	r12
8000b07a:	3f fa       	mov	r10,-1
8000b07c:	3f fb       	mov	r11,-1
8000b07e:	5e fc       	retal	r12

8000b080 <__avr32_f64_sub_from_add>:
8000b080:	ee 19 80 00 	eorh	r9,0x8000

8000b084 <__avr32_f64_sub>:
8000b084:	f7 e9 20 0c 	eor	r12,r11,r9
8000b088:	e0 86 00 ca 	brmi	8000b21c <__avr32_f64_add_from_sub>
8000b08c:	eb cd 40 e0 	pushm	r5-r7,lr
8000b090:	16 9c       	mov	r12,r11
8000b092:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b096:	bf db       	cbr	r11,0x1f
8000b098:	bf d9       	cbr	r9,0x1f
8000b09a:	10 3a       	cp.w	r10,r8
8000b09c:	f2 0b 13 00 	cpc	r11,r9
8000b0a0:	c0 92       	brcc	8000b0b2 <__avr32_f64_sub+0x2e>
8000b0a2:	16 97       	mov	r7,r11
8000b0a4:	12 9b       	mov	r11,r9
8000b0a6:	0e 99       	mov	r9,r7
8000b0a8:	14 97       	mov	r7,r10
8000b0aa:	10 9a       	mov	r10,r8
8000b0ac:	0e 98       	mov	r8,r7
8000b0ae:	ee 1c 80 00 	eorh	r12,0x8000
8000b0b2:	f6 07 16 14 	lsr	r7,r11,0x14
8000b0b6:	ab 7b       	lsl	r11,0xb
8000b0b8:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b0bc:	ab 7a       	lsl	r10,0xb
8000b0be:	bf bb       	sbr	r11,0x1f
8000b0c0:	f2 06 16 14 	lsr	r6,r9,0x14
8000b0c4:	c4 40       	breq	8000b14c <__avr32_f64_sub_opL_subnormal>
8000b0c6:	ab 79       	lsl	r9,0xb
8000b0c8:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b0cc:	ab 78       	lsl	r8,0xb
8000b0ce:	bf b9       	sbr	r9,0x1f

8000b0d0 <__avr32_f64_sub_opL_subnormal_done>:
8000b0d0:	e0 47 07 ff 	cp.w	r7,2047
8000b0d4:	c4 f0       	breq	8000b172 <__avr32_f64_sub_opH_nan_or_inf>
8000b0d6:	0e 26       	rsub	r6,r7
8000b0d8:	c1 20       	breq	8000b0fc <__avr32_f64_sub_shift_done>
8000b0da:	ec 05 11 20 	rsub	r5,r6,32
8000b0de:	e0 46 00 20 	cp.w	r6,32
8000b0e2:	c7 c2       	brcc	8000b1da <__avr32_f64_sub_longshift>
8000b0e4:	f0 05 09 4e 	lsl	lr,r8,r5
8000b0e8:	f2 05 09 45 	lsl	r5,r9,r5
8000b0ec:	f0 06 0a 48 	lsr	r8,r8,r6
8000b0f0:	f2 06 0a 49 	lsr	r9,r9,r6
8000b0f4:	0a 48       	or	r8,r5
8000b0f6:	58 0e       	cp.w	lr,0
8000b0f8:	5f 1e       	srne	lr
8000b0fa:	1c 48       	or	r8,lr

8000b0fc <__avr32_f64_sub_shift_done>:
8000b0fc:	10 1a       	sub	r10,r8
8000b0fe:	f6 09 01 4b 	sbc	r11,r11,r9
8000b102:	f6 06 12 00 	clz	r6,r11
8000b106:	c0 e0       	breq	8000b122 <__avr32_f64_sub_longnormalize_done>
8000b108:	c7 83       	brcs	8000b1f8 <__avr32_f64_sub_longnormalize>
8000b10a:	ec 0e 11 20 	rsub	lr,r6,32
8000b10e:	f6 06 09 4b 	lsl	r11,r11,r6
8000b112:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b116:	1c 4b       	or	r11,lr
8000b118:	f4 06 09 4a 	lsl	r10,r10,r6
8000b11c:	0c 17       	sub	r7,r6
8000b11e:	e0 8a 00 39 	brle	8000b190 <__avr32_f64_sub_subnormal_result>

8000b122 <__avr32_f64_sub_longnormalize_done>:
8000b122:	f4 09 15 15 	lsl	r9,r10,0x15
8000b126:	ab 9a       	lsr	r10,0xb
8000b128:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b12c:	ab 9b       	lsr	r11,0xb
8000b12e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b132:	18 4b       	or	r11,r12

8000b134 <__avr32_f64_sub_round>:
8000b134:	fc 17 80 00 	movh	r7,0x8000
8000b138:	ed ba 00 00 	bld	r10,0x0
8000b13c:	f7 b7 01 ff 	subne	r7,-1
8000b140:	0e 39       	cp.w	r9,r7
8000b142:	5f 29       	srhs	r9
8000b144:	12 0a       	add	r10,r9
8000b146:	5c 0b       	acr	r11
8000b148:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b14c <__avr32_f64_sub_opL_subnormal>:
8000b14c:	ab 79       	lsl	r9,0xb
8000b14e:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b152:	ab 78       	lsl	r8,0xb
8000b154:	f3 e8 10 0e 	or	lr,r9,r8
8000b158:	f9 b6 01 01 	movne	r6,1
8000b15c:	ee 0e 11 00 	rsub	lr,r7,0
8000b160:	f9 b7 00 01 	moveq	r7,1
8000b164:	ef bb 00 1f 	bst	r11,0x1f
8000b168:	f7 ea 10 0e 	or	lr,r11,r10
8000b16c:	f9 b7 00 00 	moveq	r7,0
8000b170:	cb 0b       	rjmp	8000b0d0 <__avr32_f64_sub_opL_subnormal_done>

8000b172 <__avr32_f64_sub_opH_nan_or_inf>:
8000b172:	bf db       	cbr	r11,0x1f
8000b174:	f7 ea 10 0e 	or	lr,r11,r10
8000b178:	c0 81       	brne	8000b188 <__avr32_f64_sub_return_nan>
8000b17a:	e0 46 07 ff 	cp.w	r6,2047
8000b17e:	c0 50       	breq	8000b188 <__avr32_f64_sub_return_nan>
8000b180:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b184:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b188 <__avr32_f64_sub_return_nan>:
8000b188:	3f fa       	mov	r10,-1
8000b18a:	3f fb       	mov	r11,-1
8000b18c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b190 <__avr32_f64_sub_subnormal_result>:
8000b190:	5c 37       	neg	r7
8000b192:	2f f7       	sub	r7,-1
8000b194:	f1 b7 04 c0 	satu	r7,0x6
8000b198:	e0 47 00 20 	cp.w	r7,32
8000b19c:	c1 14       	brge	8000b1be <__avr32_f64_sub_subnormal_result+0x2e>
8000b19e:	ee 08 11 20 	rsub	r8,r7,32
8000b1a2:	f4 08 09 49 	lsl	r9,r10,r8
8000b1a6:	5f 16       	srne	r6
8000b1a8:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b1ac:	0c 4a       	or	r10,r6
8000b1ae:	f6 08 09 49 	lsl	r9,r11,r8
8000b1b2:	f5 e9 10 0a 	or	r10,r10,r9
8000b1b6:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b1ba:	30 07       	mov	r7,0
8000b1bc:	cb 3b       	rjmp	8000b122 <__avr32_f64_sub_longnormalize_done>
8000b1be:	ee 08 11 40 	rsub	r8,r7,64
8000b1c2:	f6 08 09 49 	lsl	r9,r11,r8
8000b1c6:	14 49       	or	r9,r10
8000b1c8:	5f 16       	srne	r6
8000b1ca:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b1ce:	0c 4a       	or	r10,r6
8000b1d0:	30 0b       	mov	r11,0
8000b1d2:	30 07       	mov	r7,0
8000b1d4:	ca 7b       	rjmp	8000b122 <__avr32_f64_sub_longnormalize_done>
8000b1d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b1da <__avr32_f64_sub_longshift>:
8000b1da:	f1 b6 04 c0 	satu	r6,0x6
8000b1de:	f0 0e 17 00 	moveq	lr,r8
8000b1e2:	c0 40       	breq	8000b1ea <__avr32_f64_sub_longshift+0x10>
8000b1e4:	f2 05 09 4e 	lsl	lr,r9,r5
8000b1e8:	10 4e       	or	lr,r8
8000b1ea:	f2 06 0a 48 	lsr	r8,r9,r6
8000b1ee:	30 09       	mov	r9,0
8000b1f0:	58 0e       	cp.w	lr,0
8000b1f2:	5f 1e       	srne	lr
8000b1f4:	1c 48       	or	r8,lr
8000b1f6:	c8 3b       	rjmp	8000b0fc <__avr32_f64_sub_shift_done>

8000b1f8 <__avr32_f64_sub_longnormalize>:
8000b1f8:	f4 06 12 00 	clz	r6,r10
8000b1fc:	f9 b7 03 00 	movlo	r7,0
8000b200:	f9 b6 03 00 	movlo	r6,0
8000b204:	f9 bc 03 00 	movlo	r12,0
8000b208:	f7 b6 02 e0 	subhs	r6,-32
8000b20c:	f4 06 09 4b 	lsl	r11,r10,r6
8000b210:	30 0a       	mov	r10,0
8000b212:	0c 17       	sub	r7,r6
8000b214:	fe 9a ff be 	brle	8000b190 <__avr32_f64_sub_subnormal_result>
8000b218:	c8 5b       	rjmp	8000b122 <__avr32_f64_sub_longnormalize_done>
8000b21a:	d7 03       	nop

8000b21c <__avr32_f64_add_from_sub>:
8000b21c:	ee 19 80 00 	eorh	r9,0x8000

8000b220 <__avr32_f64_add>:
8000b220:	f7 e9 20 0c 	eor	r12,r11,r9
8000b224:	fe 96 ff 2e 	brmi	8000b080 <__avr32_f64_sub_from_add>
8000b228:	eb cd 40 e0 	pushm	r5-r7,lr
8000b22c:	16 9c       	mov	r12,r11
8000b22e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b232:	bf db       	cbr	r11,0x1f
8000b234:	bf d9       	cbr	r9,0x1f
8000b236:	12 3b       	cp.w	r11,r9
8000b238:	c0 72       	brcc	8000b246 <__avr32_f64_add+0x26>
8000b23a:	16 97       	mov	r7,r11
8000b23c:	12 9b       	mov	r11,r9
8000b23e:	0e 99       	mov	r9,r7
8000b240:	14 97       	mov	r7,r10
8000b242:	10 9a       	mov	r10,r8
8000b244:	0e 98       	mov	r8,r7
8000b246:	30 0e       	mov	lr,0
8000b248:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b24c:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000b250:	b5 ab       	sbr	r11,0x14
8000b252:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b256:	c6 20       	breq	8000b31a <__avr32_f64_add_op2_subnormal>
8000b258:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b25c:	b5 a9       	sbr	r9,0x14
8000b25e:	e0 47 07 ff 	cp.w	r7,2047
8000b262:	c2 80       	breq	8000b2b2 <__avr32_f64_add_opH_nan_or_inf>
8000b264:	0e 26       	rsub	r6,r7
8000b266:	c1 20       	breq	8000b28a <__avr32_f64_add_shift_done>
8000b268:	e0 46 00 36 	cp.w	r6,54
8000b26c:	c1 52       	brcc	8000b296 <__avr32_f64_add_res_of_done>
8000b26e:	ec 05 11 20 	rsub	r5,r6,32
8000b272:	e0 46 00 20 	cp.w	r6,32
8000b276:	c3 52       	brcc	8000b2e0 <__avr32_f64_add_longshift>
8000b278:	f0 05 09 4e 	lsl	lr,r8,r5
8000b27c:	f2 05 09 45 	lsl	r5,r9,r5
8000b280:	f0 06 0a 48 	lsr	r8,r8,r6
8000b284:	f2 06 0a 49 	lsr	r9,r9,r6
8000b288:	0a 48       	or	r8,r5

8000b28a <__avr32_f64_add_shift_done>:
8000b28a:	10 0a       	add	r10,r8
8000b28c:	f6 09 00 4b 	adc	r11,r11,r9
8000b290:	ed bb 00 15 	bld	r11,0x15
8000b294:	c3 40       	breq	8000b2fc <__avr32_f64_add_res_of>

8000b296 <__avr32_f64_add_res_of_done>:
8000b296:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b29a:	18 4b       	or	r11,r12

8000b29c <__avr32_f64_add_round>:
8000b29c:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000b2a0:	18 4e       	or	lr,r12
8000b2a2:	ee 1e 80 00 	eorh	lr,0x8000
8000b2a6:	f1 be 04 20 	satu	lr,0x1
8000b2aa:	1c 0a       	add	r10,lr
8000b2ac:	5c 0b       	acr	r11
8000b2ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b2b2 <__avr32_f64_add_opH_nan_or_inf>:
8000b2b2:	b5 cb       	cbr	r11,0x14
8000b2b4:	f7 ea 10 0e 	or	lr,r11,r10
8000b2b8:	c1 01       	brne	8000b2d8 <__avr32_f64_add_return_nan>
8000b2ba:	e0 46 07 ff 	cp.w	r6,2047
8000b2be:	c0 30       	breq	8000b2c4 <__avr32_f64_add_opL_nan_or_inf>
8000b2c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b2c4 <__avr32_f64_add_opL_nan_or_inf>:
8000b2c4:	b5 c9       	cbr	r9,0x14
8000b2c6:	f3 e8 10 0e 	or	lr,r9,r8
8000b2ca:	c0 71       	brne	8000b2d8 <__avr32_f64_add_return_nan>
8000b2cc:	30 0a       	mov	r10,0
8000b2ce:	fc 1b 7f f0 	movh	r11,0x7ff0
8000b2d2:	18 4b       	or	r11,r12
8000b2d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b2d8 <__avr32_f64_add_return_nan>:
8000b2d8:	3f fa       	mov	r10,-1
8000b2da:	3f fb       	mov	r11,-1
8000b2dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b2e0 <__avr32_f64_add_longshift>:
8000b2e0:	f1 b6 04 c0 	satu	r6,0x6
8000b2e4:	f0 0e 17 00 	moveq	lr,r8
8000b2e8:	c0 60       	breq	8000b2f4 <__avr32_f64_add_longshift+0x14>
8000b2ea:	f2 05 09 4e 	lsl	lr,r9,r5
8000b2ee:	58 08       	cp.w	r8,0
8000b2f0:	5f 18       	srne	r8
8000b2f2:	10 4e       	or	lr,r8
8000b2f4:	f2 06 0a 48 	lsr	r8,r9,r6
8000b2f8:	30 09       	mov	r9,0
8000b2fa:	cc 8b       	rjmp	8000b28a <__avr32_f64_add_shift_done>

8000b2fc <__avr32_f64_add_res_of>:
8000b2fc:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000b300:	a1 9b       	lsr	r11,0x1
8000b302:	5d 0a       	ror	r10
8000b304:	5d 0e       	ror	lr
8000b306:	2f f7       	sub	r7,-1
8000b308:	e0 47 07 ff 	cp.w	r7,2047
8000b30c:	f9 ba 00 00 	moveq	r10,0
8000b310:	f9 bb 00 00 	moveq	r11,0
8000b314:	f9 be 00 00 	moveq	lr,0
8000b318:	cb fb       	rjmp	8000b296 <__avr32_f64_add_res_of_done>

8000b31a <__avr32_f64_add_op2_subnormal>:
8000b31a:	30 16       	mov	r6,1
8000b31c:	58 07       	cp.w	r7,0
8000b31e:	ca 01       	brne	8000b25e <__avr32_f64_add+0x3e>
8000b320:	b5 cb       	cbr	r11,0x14
8000b322:	10 0a       	add	r10,r8
8000b324:	f6 09 00 4b 	adc	r11,r11,r9
8000b328:	18 4b       	or	r11,r12
8000b32a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b32e:	d7 03       	nop

8000b330 <__avr32_f64_to_u32>:
8000b330:	58 0b       	cp.w	r11,0
8000b332:	5e 6d       	retmi	0

8000b334 <__avr32_f64_to_s32>:
8000b334:	f6 0c 15 01 	lsl	r12,r11,0x1
8000b338:	b5 9c       	lsr	r12,0x15
8000b33a:	e0 2c 03 ff 	sub	r12,1023
8000b33e:	5e 3d       	retlo	0
8000b340:	f8 0c 11 1f 	rsub	r12,r12,31
8000b344:	16 99       	mov	r9,r11
8000b346:	ab 7b       	lsl	r11,0xb
8000b348:	bf bb       	sbr	r11,0x1f
8000b34a:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b34e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b352:	a1 79       	lsl	r9,0x1
8000b354:	5e 2b       	reths	r11
8000b356:	5c 3b       	neg	r11
8000b358:	5e fb       	retal	r11

8000b35a <__avr32_u32_to_f64>:
8000b35a:	f8 cb 00 00 	sub	r11,r12,0
8000b35e:	30 0c       	mov	r12,0
8000b360:	c0 38       	rjmp	8000b366 <__avr32_s32_to_f64+0x4>

8000b362 <__avr32_s32_to_f64>:
8000b362:	18 9b       	mov	r11,r12
8000b364:	5c 4b       	abs	r11
8000b366:	30 0a       	mov	r10,0
8000b368:	5e 0b       	reteq	r11
8000b36a:	d4 01       	pushm	lr
8000b36c:	e0 69 04 1e 	mov	r9,1054
8000b370:	f6 08 12 00 	clz	r8,r11
8000b374:	c1 70       	breq	8000b3a2 <__avr32_s32_to_f64+0x40>
8000b376:	c0 c3       	brcs	8000b38e <__avr32_s32_to_f64+0x2c>
8000b378:	f0 0e 11 20 	rsub	lr,r8,32
8000b37c:	f6 08 09 4b 	lsl	r11,r11,r8
8000b380:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b384:	1c 4b       	or	r11,lr
8000b386:	f4 08 09 4a 	lsl	r10,r10,r8
8000b38a:	10 19       	sub	r9,r8
8000b38c:	c0 b8       	rjmp	8000b3a2 <__avr32_s32_to_f64+0x40>
8000b38e:	f4 08 12 00 	clz	r8,r10
8000b392:	f9 b8 03 00 	movlo	r8,0
8000b396:	f7 b8 02 e0 	subhs	r8,-32
8000b39a:	f4 08 09 4b 	lsl	r11,r10,r8
8000b39e:	30 0a       	mov	r10,0
8000b3a0:	10 19       	sub	r9,r8
8000b3a2:	58 09       	cp.w	r9,0
8000b3a4:	e0 89 00 30 	brgt	8000b404 <__avr32_s32_to_f64+0xa2>
8000b3a8:	5c 39       	neg	r9
8000b3aa:	2f f9       	sub	r9,-1
8000b3ac:	e0 49 00 36 	cp.w	r9,54
8000b3b0:	c0 43       	brcs	8000b3b8 <__avr32_s32_to_f64+0x56>
8000b3b2:	30 0b       	mov	r11,0
8000b3b4:	30 0a       	mov	r10,0
8000b3b6:	c2 68       	rjmp	8000b402 <__avr32_s32_to_f64+0xa0>
8000b3b8:	2f 69       	sub	r9,-10
8000b3ba:	f2 08 11 20 	rsub	r8,r9,32
8000b3be:	e0 49 00 20 	cp.w	r9,32
8000b3c2:	c0 b2       	brcc	8000b3d8 <__avr32_s32_to_f64+0x76>
8000b3c4:	f4 08 09 4e 	lsl	lr,r10,r8
8000b3c8:	f6 08 09 48 	lsl	r8,r11,r8
8000b3cc:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b3d0:	f6 09 0a 4b 	lsr	r11,r11,r9
8000b3d4:	10 4b       	or	r11,r8
8000b3d6:	c0 88       	rjmp	8000b3e6 <__avr32_s32_to_f64+0x84>
8000b3d8:	f6 08 09 4e 	lsl	lr,r11,r8
8000b3dc:	14 4e       	or	lr,r10
8000b3de:	16 9a       	mov	r10,r11
8000b3e0:	30 0b       	mov	r11,0
8000b3e2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b3e6:	ed ba 00 00 	bld	r10,0x0
8000b3ea:	c0 92       	brcc	8000b3fc <__avr32_s32_to_f64+0x9a>
8000b3ec:	1c 7e       	tst	lr,lr
8000b3ee:	c0 41       	brne	8000b3f6 <__avr32_s32_to_f64+0x94>
8000b3f0:	ed ba 00 01 	bld	r10,0x1
8000b3f4:	c0 42       	brcc	8000b3fc <__avr32_s32_to_f64+0x9a>
8000b3f6:	2f fa       	sub	r10,-1
8000b3f8:	f7 bb 02 ff 	subhs	r11,-1
8000b3fc:	5c fc       	rol	r12
8000b3fe:	5d 0b       	ror	r11
8000b400:	5d 0a       	ror	r10
8000b402:	d8 02       	popm	pc
8000b404:	e0 68 03 ff 	mov	r8,1023
8000b408:	ed ba 00 0b 	bld	r10,0xb
8000b40c:	f7 b8 00 ff 	subeq	r8,-1
8000b410:	10 0a       	add	r10,r8
8000b412:	5c 0b       	acr	r11
8000b414:	f7 b9 03 fe 	sublo	r9,-2
8000b418:	e0 49 07 ff 	cp.w	r9,2047
8000b41c:	c0 55       	brlt	8000b426 <__avr32_s32_to_f64+0xc4>
8000b41e:	30 0a       	mov	r10,0
8000b420:	fc 1b ff e0 	movh	r11,0xffe0
8000b424:	c0 c8       	rjmp	8000b43c <__floatsidf_return_op1>
8000b426:	ed bb 00 1f 	bld	r11,0x1f
8000b42a:	f7 b9 01 01 	subne	r9,1
8000b42e:	ab 9a       	lsr	r10,0xb
8000b430:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b434:	a1 7b       	lsl	r11,0x1
8000b436:	ab 9b       	lsr	r11,0xb
8000b438:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000b43c <__floatsidf_return_op1>:
8000b43c:	a1 7c       	lsl	r12,0x1
8000b43e:	5d 0b       	ror	r11
8000b440:	d8 02       	popm	pc

8000b442 <__avr32_f64_cmp_eq>:
8000b442:	10 3a       	cp.w	r10,r8
8000b444:	f2 0b 13 00 	cpc	r11,r9
8000b448:	c0 80       	breq	8000b458 <__avr32_f64_cmp_eq+0x16>
8000b44a:	a1 7b       	lsl	r11,0x1
8000b44c:	a1 79       	lsl	r9,0x1
8000b44e:	14 4b       	or	r11,r10
8000b450:	12 4b       	or	r11,r9
8000b452:	10 4b       	or	r11,r8
8000b454:	5e 0f       	reteq	1
8000b456:	5e fd       	retal	0
8000b458:	a1 7b       	lsl	r11,0x1
8000b45a:	fc 1c ff e0 	movh	r12,0xffe0
8000b45e:	58 0a       	cp.w	r10,0
8000b460:	f8 0b 13 00 	cpc	r11,r12
8000b464:	5e 8f       	retls	1
8000b466:	5e fd       	retal	0

8000b468 <__avr32_f64_cmp_ge>:
8000b468:	1a de       	st.w	--sp,lr
8000b46a:	1a d7       	st.w	--sp,r7
8000b46c:	a1 7b       	lsl	r11,0x1
8000b46e:	5f 3c       	srlo	r12
8000b470:	a1 79       	lsl	r9,0x1
8000b472:	5f 37       	srlo	r7
8000b474:	5c fc       	rol	r12
8000b476:	fc 1e ff e0 	movh	lr,0xffe0
8000b47a:	58 0a       	cp.w	r10,0
8000b47c:	fc 0b 13 00 	cpc	r11,lr
8000b480:	e0 8b 00 1d 	brhi	8000b4ba <__avr32_f64_cmp_ge+0x52>
8000b484:	58 08       	cp.w	r8,0
8000b486:	fc 09 13 00 	cpc	r9,lr
8000b48a:	e0 8b 00 18 	brhi	8000b4ba <__avr32_f64_cmp_ge+0x52>
8000b48e:	58 0b       	cp.w	r11,0
8000b490:	f5 ba 00 00 	subfeq	r10,0
8000b494:	c1 50       	breq	8000b4be <__avr32_f64_cmp_ge+0x56>
8000b496:	1b 07       	ld.w	r7,sp++
8000b498:	1b 0e       	ld.w	lr,sp++
8000b49a:	58 3c       	cp.w	r12,3
8000b49c:	c0 a0       	breq	8000b4b0 <__avr32_f64_cmp_ge+0x48>
8000b49e:	58 1c       	cp.w	r12,1
8000b4a0:	c0 33       	brcs	8000b4a6 <__avr32_f64_cmp_ge+0x3e>
8000b4a2:	5e 0f       	reteq	1
8000b4a4:	5e 1d       	retne	0
8000b4a6:	10 3a       	cp.w	r10,r8
8000b4a8:	f2 0b 13 00 	cpc	r11,r9
8000b4ac:	5e 2f       	reths	1
8000b4ae:	5e 3d       	retlo	0
8000b4b0:	14 38       	cp.w	r8,r10
8000b4b2:	f6 09 13 00 	cpc	r9,r11
8000b4b6:	5e 2f       	reths	1
8000b4b8:	5e 3d       	retlo	0
8000b4ba:	1b 07       	ld.w	r7,sp++
8000b4bc:	d8 0a       	popm	pc,r12=0
8000b4be:	58 17       	cp.w	r7,1
8000b4c0:	5f 0c       	sreq	r12
8000b4c2:	58 09       	cp.w	r9,0
8000b4c4:	f5 b8 00 00 	subfeq	r8,0
8000b4c8:	1b 07       	ld.w	r7,sp++
8000b4ca:	1b 0e       	ld.w	lr,sp++
8000b4cc:	5e 0f       	reteq	1
8000b4ce:	5e fc       	retal	r12

8000b4d0 <__avr32_f64_cmp_lt>:
8000b4d0:	1a de       	st.w	--sp,lr
8000b4d2:	1a d7       	st.w	--sp,r7
8000b4d4:	a1 7b       	lsl	r11,0x1
8000b4d6:	5f 3c       	srlo	r12
8000b4d8:	a1 79       	lsl	r9,0x1
8000b4da:	5f 37       	srlo	r7
8000b4dc:	5c fc       	rol	r12
8000b4de:	fc 1e ff e0 	movh	lr,0xffe0
8000b4e2:	58 0a       	cp.w	r10,0
8000b4e4:	fc 0b 13 00 	cpc	r11,lr
8000b4e8:	e0 8b 00 1d 	brhi	8000b522 <__avr32_f64_cmp_lt+0x52>
8000b4ec:	58 08       	cp.w	r8,0
8000b4ee:	fc 09 13 00 	cpc	r9,lr
8000b4f2:	e0 8b 00 18 	brhi	8000b522 <__avr32_f64_cmp_lt+0x52>
8000b4f6:	58 0b       	cp.w	r11,0
8000b4f8:	f5 ba 00 00 	subfeq	r10,0
8000b4fc:	c1 50       	breq	8000b526 <__avr32_f64_cmp_lt+0x56>
8000b4fe:	1b 07       	ld.w	r7,sp++
8000b500:	1b 0e       	ld.w	lr,sp++
8000b502:	58 3c       	cp.w	r12,3
8000b504:	c0 a0       	breq	8000b518 <__avr32_f64_cmp_lt+0x48>
8000b506:	58 1c       	cp.w	r12,1
8000b508:	c0 33       	brcs	8000b50e <__avr32_f64_cmp_lt+0x3e>
8000b50a:	5e 0d       	reteq	0
8000b50c:	5e 1f       	retne	1
8000b50e:	10 3a       	cp.w	r10,r8
8000b510:	f2 0b 13 00 	cpc	r11,r9
8000b514:	5e 2d       	reths	0
8000b516:	5e 3f       	retlo	1
8000b518:	14 38       	cp.w	r8,r10
8000b51a:	f6 09 13 00 	cpc	r9,r11
8000b51e:	5e 2d       	reths	0
8000b520:	5e 3f       	retlo	1
8000b522:	1b 07       	ld.w	r7,sp++
8000b524:	d8 0a       	popm	pc,r12=0
8000b526:	58 17       	cp.w	r7,1
8000b528:	5f 1c       	srne	r12
8000b52a:	58 09       	cp.w	r9,0
8000b52c:	f5 b8 00 00 	subfeq	r8,0
8000b530:	1b 07       	ld.w	r7,sp++
8000b532:	1b 0e       	ld.w	lr,sp++
8000b534:	5e 0d       	reteq	0
8000b536:	5e fc       	retal	r12

8000b538 <__avr32_f64_div>:
8000b538:	eb cd 40 ff 	pushm	r0-r7,lr
8000b53c:	f7 e9 20 0e 	eor	lr,r11,r9
8000b540:	f6 07 16 14 	lsr	r7,r11,0x14
8000b544:	a9 7b       	lsl	r11,0x9
8000b546:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000b54a:	a9 7a       	lsl	r10,0x9
8000b54c:	bd bb       	sbr	r11,0x1d
8000b54e:	e4 1b 3f ff 	andh	r11,0x3fff
8000b552:	ab d7       	cbr	r7,0xb
8000b554:	e0 80 00 cc 	breq	8000b6ec <__avr32_f64_div_round_subnormal+0x54>
8000b558:	e0 47 07 ff 	cp.w	r7,2047
8000b55c:	e0 84 00 b5 	brge	8000b6c6 <__avr32_f64_div_round_subnormal+0x2e>
8000b560:	f2 06 16 14 	lsr	r6,r9,0x14
8000b564:	a9 79       	lsl	r9,0x9
8000b566:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000b56a:	a9 78       	lsl	r8,0x9
8000b56c:	bd b9       	sbr	r9,0x1d
8000b56e:	e4 19 3f ff 	andh	r9,0x3fff
8000b572:	ab d6       	cbr	r6,0xb
8000b574:	e0 80 00 e2 	breq	8000b738 <__avr32_f64_div_round_subnormal+0xa0>
8000b578:	e0 46 07 ff 	cp.w	r6,2047
8000b57c:	e0 84 00 b2 	brge	8000b6e0 <__avr32_f64_div_round_subnormal+0x48>
8000b580:	0c 17       	sub	r7,r6
8000b582:	fe 37 fc 01 	sub	r7,-1023
8000b586:	fc 1c 80 00 	movh	r12,0x8000
8000b58a:	f8 03 16 01 	lsr	r3,r12,0x1
8000b58e:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000b592:	5c d4       	com	r4
8000b594:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000b598:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b59c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b5a0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b5a4:	ea 03 15 02 	lsl	r3,r5,0x2
8000b5a8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b5ac:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b5b0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b5b4:	ea 03 15 02 	lsl	r3,r5,0x2
8000b5b8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b5bc:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b5c0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b5c4:	ea 03 15 02 	lsl	r3,r5,0x2
8000b5c8:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b5cc:	e4 09 07 40 	macu.d	r0,r2,r9
8000b5d0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b5d4:	02 04       	add	r4,r1
8000b5d6:	5c 05       	acr	r5
8000b5d8:	a3 65       	lsl	r5,0x2
8000b5da:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b5de:	a3 64       	lsl	r4,0x2
8000b5e0:	5c 34       	neg	r4
8000b5e2:	f8 05 01 45 	sbc	r5,r12,r5
8000b5e6:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b5ea:	e4 05 07 40 	macu.d	r0,r2,r5
8000b5ee:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b5f2:	02 04       	add	r4,r1
8000b5f4:	5c 05       	acr	r5
8000b5f6:	ea 03 15 02 	lsl	r3,r5,0x2
8000b5fa:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b5fe:	e8 02 15 02 	lsl	r2,r4,0x2
8000b602:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b606:	e4 09 07 40 	macu.d	r0,r2,r9
8000b60a:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b60e:	02 04       	add	r4,r1
8000b610:	5c 05       	acr	r5
8000b612:	a3 65       	lsl	r5,0x2
8000b614:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b618:	a3 64       	lsl	r4,0x2
8000b61a:	5c 34       	neg	r4
8000b61c:	f8 05 01 45 	sbc	r5,r12,r5
8000b620:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b624:	e4 05 07 40 	macu.d	r0,r2,r5
8000b628:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b62c:	02 04       	add	r4,r1
8000b62e:	5c 05       	acr	r5
8000b630:	ea 03 15 02 	lsl	r3,r5,0x2
8000b634:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b638:	e8 02 15 02 	lsl	r2,r4,0x2
8000b63c:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000b640:	e4 0b 07 40 	macu.d	r0,r2,r11
8000b644:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000b648:	02 02       	add	r2,r1
8000b64a:	5c 03       	acr	r3
8000b64c:	ed b3 00 1c 	bld	r3,0x1c
8000b650:	c0 90       	breq	8000b662 <__avr32_f64_div+0x12a>
8000b652:	a1 72       	lsl	r2,0x1
8000b654:	5c f3       	rol	r3
8000b656:	20 17       	sub	r7,1
8000b658:	a3 9a       	lsr	r10,0x3
8000b65a:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000b65e:	a3 9b       	lsr	r11,0x3
8000b660:	c0 58       	rjmp	8000b66a <__avr32_f64_div+0x132>
8000b662:	a5 8a       	lsr	r10,0x4
8000b664:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000b668:	a5 8b       	lsr	r11,0x4
8000b66a:	58 07       	cp.w	r7,0
8000b66c:	e0 8a 00 8b 	brle	8000b782 <__avr32_f64_div_res_subnormal>
8000b670:	e0 12 ff 00 	andl	r2,0xff00
8000b674:	e8 12 00 80 	orl	r2,0x80
8000b678:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b67c:	e4 09 07 40 	macu.d	r0,r2,r9
8000b680:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b684:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b688:	00 05       	add	r5,r0
8000b68a:	f0 01 00 48 	adc	r8,r8,r1
8000b68e:	5c 09       	acr	r9
8000b690:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b694:	58 04       	cp.w	r4,0
8000b696:	5c 25       	cpc	r5

8000b698 <__avr32_f64_div_round_subnormal>:
8000b698:	f4 08 13 00 	cpc	r8,r10
8000b69c:	f6 09 13 00 	cpc	r9,r11
8000b6a0:	5f 36       	srlo	r6
8000b6a2:	f8 06 17 00 	moveq	r6,r12
8000b6a6:	e4 0a 16 08 	lsr	r10,r2,0x8
8000b6aa:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000b6ae:	e6 0b 16 08 	lsr	r11,r3,0x8
8000b6b2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b6b6:	ed be 00 1f 	bld	lr,0x1f
8000b6ba:	ef bb 00 1f 	bst	r11,0x1f
8000b6be:	0c 0a       	add	r10,r6
8000b6c0:	5c 0b       	acr	r11
8000b6c2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b6c6:	e4 1b 00 0f 	andh	r11,0xf
8000b6ca:	14 4b       	or	r11,r10
8000b6cc:	e0 81 00 a7 	brne	8000b81a <__avr32_f64_div_res_subnormal+0x98>
8000b6d0:	f2 06 16 14 	lsr	r6,r9,0x14
8000b6d4:	ab d6       	cbr	r6,0xb
8000b6d6:	e0 46 07 ff 	cp.w	r6,2047
8000b6da:	e0 81 00 a4 	brne	8000b822 <__avr32_f64_div_res_subnormal+0xa0>
8000b6de:	c9 e8       	rjmp	8000b81a <__avr32_f64_div_res_subnormal+0x98>
8000b6e0:	e4 19 00 0f 	andh	r9,0xf
8000b6e4:	10 49       	or	r9,r8
8000b6e6:	e0 81 00 9a 	brne	8000b81a <__avr32_f64_div_res_subnormal+0x98>
8000b6ea:	c9 28       	rjmp	8000b80e <__avr32_f64_div_res_subnormal+0x8c>
8000b6ec:	a3 7b       	lsl	r11,0x3
8000b6ee:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000b6f2:	a3 7a       	lsl	r10,0x3
8000b6f4:	f5 eb 10 04 	or	r4,r10,r11
8000b6f8:	e0 80 00 a0 	breq	8000b838 <__avr32_f64_div_op1_zero>
8000b6fc:	f6 04 12 00 	clz	r4,r11
8000b700:	c1 70       	breq	8000b72e <__avr32_f64_div_round_subnormal+0x96>
8000b702:	c0 c3       	brcs	8000b71a <__avr32_f64_div_round_subnormal+0x82>
8000b704:	e8 05 11 20 	rsub	r5,r4,32
8000b708:	f6 04 09 4b 	lsl	r11,r11,r4
8000b70c:	f4 05 0a 45 	lsr	r5,r10,r5
8000b710:	0a 4b       	or	r11,r5
8000b712:	f4 04 09 4a 	lsl	r10,r10,r4
8000b716:	08 17       	sub	r7,r4
8000b718:	c0 b8       	rjmp	8000b72e <__avr32_f64_div_round_subnormal+0x96>
8000b71a:	f4 04 12 00 	clz	r4,r10
8000b71e:	f9 b4 03 00 	movlo	r4,0
8000b722:	f7 b4 02 e0 	subhs	r4,-32
8000b726:	f4 04 09 4b 	lsl	r11,r10,r4
8000b72a:	30 0a       	mov	r10,0
8000b72c:	08 17       	sub	r7,r4
8000b72e:	a3 8a       	lsr	r10,0x2
8000b730:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000b734:	a3 8b       	lsr	r11,0x2
8000b736:	c1 1b       	rjmp	8000b558 <__avr32_f64_div+0x20>
8000b738:	a3 79       	lsl	r9,0x3
8000b73a:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000b73e:	a3 78       	lsl	r8,0x3
8000b740:	f3 e8 10 04 	or	r4,r9,r8
8000b744:	c6 f0       	breq	8000b822 <__avr32_f64_div_res_subnormal+0xa0>
8000b746:	f2 04 12 00 	clz	r4,r9
8000b74a:	c1 70       	breq	8000b778 <__avr32_f64_div_round_subnormal+0xe0>
8000b74c:	c0 c3       	brcs	8000b764 <__avr32_f64_div_round_subnormal+0xcc>
8000b74e:	e8 05 11 20 	rsub	r5,r4,32
8000b752:	f2 04 09 49 	lsl	r9,r9,r4
8000b756:	f0 05 0a 45 	lsr	r5,r8,r5
8000b75a:	0a 49       	or	r9,r5
8000b75c:	f0 04 09 48 	lsl	r8,r8,r4
8000b760:	08 16       	sub	r6,r4
8000b762:	c0 b8       	rjmp	8000b778 <__avr32_f64_div_round_subnormal+0xe0>
8000b764:	f0 04 12 00 	clz	r4,r8
8000b768:	f9 b4 03 00 	movlo	r4,0
8000b76c:	f7 b4 02 e0 	subhs	r4,-32
8000b770:	f0 04 09 49 	lsl	r9,r8,r4
8000b774:	30 08       	mov	r8,0
8000b776:	08 16       	sub	r6,r4
8000b778:	a3 88       	lsr	r8,0x2
8000b77a:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000b77e:	a3 89       	lsr	r9,0x2
8000b780:	cf ca       	rjmp	8000b578 <__avr32_f64_div+0x40>

8000b782 <__avr32_f64_div_res_subnormal>:
8000b782:	5c 37       	neg	r7
8000b784:	2f f7       	sub	r7,-1
8000b786:	f1 b7 04 c0 	satu	r7,0x6
8000b78a:	e0 47 00 20 	cp.w	r7,32
8000b78e:	c1 54       	brge	8000b7b8 <__avr32_f64_div_res_subnormal+0x36>
8000b790:	ee 06 11 20 	rsub	r6,r7,32
8000b794:	e4 07 0a 42 	lsr	r2,r2,r7
8000b798:	e6 06 09 4c 	lsl	r12,r3,r6
8000b79c:	18 42       	or	r2,r12
8000b79e:	e6 07 0a 43 	lsr	r3,r3,r7
8000b7a2:	f4 06 09 41 	lsl	r1,r10,r6
8000b7a6:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b7aa:	f6 06 09 4c 	lsl	r12,r11,r6
8000b7ae:	18 4a       	or	r10,r12
8000b7b0:	f6 07 0a 4b 	lsr	r11,r11,r7
8000b7b4:	30 00       	mov	r0,0
8000b7b6:	c1 58       	rjmp	8000b7e0 <__avr32_f64_div_res_subnormal+0x5e>
8000b7b8:	ee 06 11 20 	rsub	r6,r7,32
8000b7bc:	f9 b0 00 00 	moveq	r0,0
8000b7c0:	f9 bc 00 00 	moveq	r12,0
8000b7c4:	c0 50       	breq	8000b7ce <__avr32_f64_div_res_subnormal+0x4c>
8000b7c6:	f4 06 09 40 	lsl	r0,r10,r6
8000b7ca:	f6 06 09 4c 	lsl	r12,r11,r6
8000b7ce:	e6 07 0a 42 	lsr	r2,r3,r7
8000b7d2:	30 03       	mov	r3,0
8000b7d4:	f4 07 0a 41 	lsr	r1,r10,r7
8000b7d8:	18 41       	or	r1,r12
8000b7da:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b7de:	30 0b       	mov	r11,0
8000b7e0:	e0 12 ff 00 	andl	r2,0xff00
8000b7e4:	e8 12 00 80 	orl	r2,0x80
8000b7e8:	e6 08 06 46 	mulu.d	r6,r3,r8
8000b7ec:	e4 09 07 46 	macu.d	r6,r2,r9
8000b7f0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b7f4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b7f8:	0c 05       	add	r5,r6
8000b7fa:	f0 07 00 48 	adc	r8,r8,r7
8000b7fe:	5c 09       	acr	r9
8000b800:	30 07       	mov	r7,0
8000b802:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b806:	00 34       	cp.w	r4,r0
8000b808:	e2 05 13 00 	cpc	r5,r1
8000b80c:	c4 6b       	rjmp	8000b698 <__avr32_f64_div_round_subnormal>
8000b80e:	1c 9b       	mov	r11,lr
8000b810:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b814:	30 0a       	mov	r10,0
8000b816:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b81a:	3f fb       	mov	r11,-1
8000b81c:	30 0a       	mov	r10,0
8000b81e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b822:	f5 eb 10 04 	or	r4,r10,r11
8000b826:	c0 90       	breq	8000b838 <__avr32_f64_div_op1_zero>
8000b828:	1c 9b       	mov	r11,lr
8000b82a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b82e:	ea 1b 7f f0 	orh	r11,0x7ff0
8000b832:	30 0a       	mov	r10,0
8000b834:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000b838 <__avr32_f64_div_op1_zero>:
8000b838:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000b83c:	ce f0       	breq	8000b81a <__avr32_f64_div_res_subnormal+0x98>
8000b83e:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000b842:	e0 44 07 ff 	cp.w	r4,2047
8000b846:	ce 41       	brne	8000b80e <__avr32_f64_div_res_subnormal+0x8c>
8000b848:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000b84c:	ce 10       	breq	8000b80e <__avr32_f64_div_res_subnormal+0x8c>
8000b84e:	ce 6b       	rjmp	8000b81a <__avr32_f64_div_res_subnormal+0x98>

8000b850 <__avr32_udiv64>:
8000b850:	d4 31       	pushm	r0-r7,lr
8000b852:	1a 97       	mov	r7,sp
8000b854:	20 3d       	sub	sp,12
8000b856:	10 9c       	mov	r12,r8
8000b858:	12 9e       	mov	lr,r9
8000b85a:	14 93       	mov	r3,r10
8000b85c:	58 09       	cp.w	r9,0
8000b85e:	e0 81 00 bd 	brne	8000b9d8 <__avr32_udiv64+0x188>
8000b862:	16 38       	cp.w	r8,r11
8000b864:	e0 88 00 40 	brls	8000b8e4 <__avr32_udiv64+0x94>
8000b868:	f0 08 12 00 	clz	r8,r8
8000b86c:	c0 d0       	breq	8000b886 <__avr32_udiv64+0x36>
8000b86e:	f6 08 09 4b 	lsl	r11,r11,r8
8000b872:	f0 09 11 20 	rsub	r9,r8,32
8000b876:	f8 08 09 4c 	lsl	r12,r12,r8
8000b87a:	f4 09 0a 49 	lsr	r9,r10,r9
8000b87e:	f4 08 09 43 	lsl	r3,r10,r8
8000b882:	f3 eb 10 0b 	or	r11,r9,r11
8000b886:	f8 0e 16 10 	lsr	lr,r12,0x10
8000b88a:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000b88e:	f6 0e 0d 00 	divu	r0,r11,lr
8000b892:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b896:	00 99       	mov	r9,r0
8000b898:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b89c:	e0 0a 02 48 	mul	r8,r0,r10
8000b8a0:	10 3b       	cp.w	r11,r8
8000b8a2:	c0 a2       	brcc	8000b8b6 <__avr32_udiv64+0x66>
8000b8a4:	20 19       	sub	r9,1
8000b8a6:	18 0b       	add	r11,r12
8000b8a8:	18 3b       	cp.w	r11,r12
8000b8aa:	c0 63       	brcs	8000b8b6 <__avr32_udiv64+0x66>
8000b8ac:	10 3b       	cp.w	r11,r8
8000b8ae:	f7 b9 03 01 	sublo	r9,1
8000b8b2:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b8b6:	f6 08 01 01 	sub	r1,r11,r8
8000b8ba:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000b8be:	e2 0e 0d 00 	divu	r0,r1,lr
8000b8c2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000b8c6:	00 98       	mov	r8,r0
8000b8c8:	e0 0a 02 4a 	mul	r10,r0,r10
8000b8cc:	14 33       	cp.w	r3,r10
8000b8ce:	c0 82       	brcc	8000b8de <__avr32_udiv64+0x8e>
8000b8d0:	20 18       	sub	r8,1
8000b8d2:	18 03       	add	r3,r12
8000b8d4:	18 33       	cp.w	r3,r12
8000b8d6:	c0 43       	brcs	8000b8de <__avr32_udiv64+0x8e>
8000b8d8:	14 33       	cp.w	r3,r10
8000b8da:	f7 b8 03 01 	sublo	r8,1
8000b8de:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000b8e2:	cd f8       	rjmp	8000baa0 <__avr32_udiv64+0x250>
8000b8e4:	58 08       	cp.w	r8,0
8000b8e6:	c0 51       	brne	8000b8f0 <__avr32_udiv64+0xa0>
8000b8e8:	30 19       	mov	r9,1
8000b8ea:	f2 08 0d 08 	divu	r8,r9,r8
8000b8ee:	10 9c       	mov	r12,r8
8000b8f0:	f8 06 12 00 	clz	r6,r12
8000b8f4:	c0 41       	brne	8000b8fc <__avr32_udiv64+0xac>
8000b8f6:	18 1b       	sub	r11,r12
8000b8f8:	30 19       	mov	r9,1
8000b8fa:	c4 08       	rjmp	8000b97a <__avr32_udiv64+0x12a>
8000b8fc:	ec 01 11 20 	rsub	r1,r6,32
8000b900:	f4 01 0a 49 	lsr	r9,r10,r1
8000b904:	f8 06 09 4c 	lsl	r12,r12,r6
8000b908:	f6 06 09 48 	lsl	r8,r11,r6
8000b90c:	f6 01 0a 41 	lsr	r1,r11,r1
8000b910:	f3 e8 10 08 	or	r8,r9,r8
8000b914:	f8 03 16 10 	lsr	r3,r12,0x10
8000b918:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000b91c:	e2 03 0d 00 	divu	r0,r1,r3
8000b920:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b924:	00 9e       	mov	lr,r0
8000b926:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b92a:	e0 05 02 49 	mul	r9,r0,r5
8000b92e:	12 3b       	cp.w	r11,r9
8000b930:	c0 a2       	brcc	8000b944 <__avr32_udiv64+0xf4>
8000b932:	20 1e       	sub	lr,1
8000b934:	18 0b       	add	r11,r12
8000b936:	18 3b       	cp.w	r11,r12
8000b938:	c0 63       	brcs	8000b944 <__avr32_udiv64+0xf4>
8000b93a:	12 3b       	cp.w	r11,r9
8000b93c:	f7 be 03 01 	sublo	lr,1
8000b940:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b944:	12 1b       	sub	r11,r9
8000b946:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000b94a:	f6 03 0d 02 	divu	r2,r11,r3
8000b94e:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000b952:	04 99       	mov	r9,r2
8000b954:	e4 05 02 4b 	mul	r11,r2,r5
8000b958:	16 38       	cp.w	r8,r11
8000b95a:	c0 a2       	brcc	8000b96e <__avr32_udiv64+0x11e>
8000b95c:	20 19       	sub	r9,1
8000b95e:	18 08       	add	r8,r12
8000b960:	18 38       	cp.w	r8,r12
8000b962:	c0 63       	brcs	8000b96e <__avr32_udiv64+0x11e>
8000b964:	16 38       	cp.w	r8,r11
8000b966:	f7 b9 03 01 	sublo	r9,1
8000b96a:	f1 dc e3 08 	addcs	r8,r8,r12
8000b96e:	f4 06 09 43 	lsl	r3,r10,r6
8000b972:	f0 0b 01 0b 	sub	r11,r8,r11
8000b976:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000b97a:	f8 06 16 10 	lsr	r6,r12,0x10
8000b97e:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000b982:	f6 06 0d 00 	divu	r0,r11,r6
8000b986:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b98a:	00 9a       	mov	r10,r0
8000b98c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b990:	e0 0e 02 48 	mul	r8,r0,lr
8000b994:	10 3b       	cp.w	r11,r8
8000b996:	c0 a2       	brcc	8000b9aa <__avr32_udiv64+0x15a>
8000b998:	20 1a       	sub	r10,1
8000b99a:	18 0b       	add	r11,r12
8000b99c:	18 3b       	cp.w	r11,r12
8000b99e:	c0 63       	brcs	8000b9aa <__avr32_udiv64+0x15a>
8000b9a0:	10 3b       	cp.w	r11,r8
8000b9a2:	f7 ba 03 01 	sublo	r10,1
8000b9a6:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b9aa:	f6 08 01 01 	sub	r1,r11,r8
8000b9ae:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000b9b2:	e2 06 0d 00 	divu	r0,r1,r6
8000b9b6:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000b9ba:	00 98       	mov	r8,r0
8000b9bc:	e0 0e 02 4b 	mul	r11,r0,lr
8000b9c0:	16 33       	cp.w	r3,r11
8000b9c2:	c0 82       	brcc	8000b9d2 <__avr32_udiv64+0x182>
8000b9c4:	20 18       	sub	r8,1
8000b9c6:	18 03       	add	r3,r12
8000b9c8:	18 33       	cp.w	r3,r12
8000b9ca:	c0 43       	brcs	8000b9d2 <__avr32_udiv64+0x182>
8000b9cc:	16 33       	cp.w	r3,r11
8000b9ce:	f7 b8 03 01 	sublo	r8,1
8000b9d2:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000b9d6:	c6 98       	rjmp	8000baa8 <__avr32_udiv64+0x258>
8000b9d8:	16 39       	cp.w	r9,r11
8000b9da:	e0 8b 00 65 	brhi	8000baa4 <__avr32_udiv64+0x254>
8000b9de:	f2 09 12 00 	clz	r9,r9
8000b9e2:	c0 b1       	brne	8000b9f8 <__avr32_udiv64+0x1a8>
8000b9e4:	10 3a       	cp.w	r10,r8
8000b9e6:	5f 2a       	srhs	r10
8000b9e8:	1c 3b       	cp.w	r11,lr
8000b9ea:	5f b8       	srhi	r8
8000b9ec:	10 4a       	or	r10,r8
8000b9ee:	f2 0a 18 00 	cp.b	r10,r9
8000b9f2:	c5 90       	breq	8000baa4 <__avr32_udiv64+0x254>
8000b9f4:	30 18       	mov	r8,1
8000b9f6:	c5 98       	rjmp	8000baa8 <__avr32_udiv64+0x258>
8000b9f8:	f0 09 09 46 	lsl	r6,r8,r9
8000b9fc:	f2 03 11 20 	rsub	r3,r9,32
8000ba00:	fc 09 09 4e 	lsl	lr,lr,r9
8000ba04:	f0 03 0a 48 	lsr	r8,r8,r3
8000ba08:	f6 09 09 4c 	lsl	r12,r11,r9
8000ba0c:	f4 03 0a 42 	lsr	r2,r10,r3
8000ba10:	ef 46 ff f4 	st.w	r7[-12],r6
8000ba14:	f6 03 0a 43 	lsr	r3,r11,r3
8000ba18:	18 42       	or	r2,r12
8000ba1a:	f1 ee 10 0c 	or	r12,r8,lr
8000ba1e:	f8 01 16 10 	lsr	r1,r12,0x10
8000ba22:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000ba26:	e6 01 0d 04 	divu	r4,r3,r1
8000ba2a:	e4 03 16 10 	lsr	r3,r2,0x10
8000ba2e:	08 9e       	mov	lr,r4
8000ba30:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000ba34:	e8 06 02 48 	mul	r8,r4,r6
8000ba38:	10 33       	cp.w	r3,r8
8000ba3a:	c0 a2       	brcc	8000ba4e <__avr32_udiv64+0x1fe>
8000ba3c:	20 1e       	sub	lr,1
8000ba3e:	18 03       	add	r3,r12
8000ba40:	18 33       	cp.w	r3,r12
8000ba42:	c0 63       	brcs	8000ba4e <__avr32_udiv64+0x1fe>
8000ba44:	10 33       	cp.w	r3,r8
8000ba46:	f7 be 03 01 	sublo	lr,1
8000ba4a:	e7 dc e3 03 	addcs	r3,r3,r12
8000ba4e:	10 13       	sub	r3,r8
8000ba50:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000ba54:	e6 01 0d 00 	divu	r0,r3,r1
8000ba58:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ba5c:	00 98       	mov	r8,r0
8000ba5e:	e0 06 02 46 	mul	r6,r0,r6
8000ba62:	0c 3b       	cp.w	r11,r6
8000ba64:	c0 a2       	brcc	8000ba78 <__avr32_udiv64+0x228>
8000ba66:	20 18       	sub	r8,1
8000ba68:	18 0b       	add	r11,r12
8000ba6a:	18 3b       	cp.w	r11,r12
8000ba6c:	c0 63       	brcs	8000ba78 <__avr32_udiv64+0x228>
8000ba6e:	0c 3b       	cp.w	r11,r6
8000ba70:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ba74:	f7 b8 03 01 	sublo	r8,1
8000ba78:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000ba7c:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000ba80:	0c 1b       	sub	r11,r6
8000ba82:	f0 04 06 42 	mulu.d	r2,r8,r4
8000ba86:	06 95       	mov	r5,r3
8000ba88:	16 35       	cp.w	r5,r11
8000ba8a:	e0 8b 00 0a 	brhi	8000ba9e <__avr32_udiv64+0x24e>
8000ba8e:	5f 0b       	sreq	r11
8000ba90:	f4 09 09 49 	lsl	r9,r10,r9
8000ba94:	12 32       	cp.w	r2,r9
8000ba96:	5f b9       	srhi	r9
8000ba98:	f7 e9 00 09 	and	r9,r11,r9
8000ba9c:	c0 60       	breq	8000baa8 <__avr32_udiv64+0x258>
8000ba9e:	20 18       	sub	r8,1
8000baa0:	30 09       	mov	r9,0
8000baa2:	c0 38       	rjmp	8000baa8 <__avr32_udiv64+0x258>
8000baa4:	30 09       	mov	r9,0
8000baa6:	12 98       	mov	r8,r9
8000baa8:	10 9a       	mov	r10,r8
8000baaa:	12 93       	mov	r3,r9
8000baac:	10 92       	mov	r2,r8
8000baae:	12 9b       	mov	r11,r9
8000bab0:	2f dd       	sub	sp,-12
8000bab2:	d8 32       	popm	r0-r7,pc

8000bab4 <__avr32_umod64>:
8000bab4:	d4 31       	pushm	r0-r7,lr
8000bab6:	1a 97       	mov	r7,sp
8000bab8:	20 3d       	sub	sp,12
8000baba:	10 9c       	mov	r12,r8
8000babc:	12 95       	mov	r5,r9
8000babe:	14 9e       	mov	lr,r10
8000bac0:	16 91       	mov	r1,r11
8000bac2:	16 96       	mov	r6,r11
8000bac4:	58 09       	cp.w	r9,0
8000bac6:	e0 81 00 81 	brne	8000bbc8 <__avr32_umod64+0x114>
8000baca:	16 38       	cp.w	r8,r11
8000bacc:	e0 88 00 12 	brls	8000baf0 <__avr32_umod64+0x3c>
8000bad0:	f0 08 12 00 	clz	r8,r8
8000bad4:	c4 e0       	breq	8000bb70 <__avr32_umod64+0xbc>
8000bad6:	f6 08 09 46 	lsl	r6,r11,r8
8000bada:	f8 08 09 4c 	lsl	r12,r12,r8
8000bade:	f0 0b 11 20 	rsub	r11,r8,32
8000bae2:	f4 08 09 4e 	lsl	lr,r10,r8
8000bae6:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000baea:	f7 e6 10 06 	or	r6,r11,r6
8000baee:	c4 18       	rjmp	8000bb70 <__avr32_umod64+0xbc>
8000baf0:	58 08       	cp.w	r8,0
8000baf2:	c0 51       	brne	8000bafc <__avr32_umod64+0x48>
8000baf4:	30 19       	mov	r9,1
8000baf6:	f2 08 0d 08 	divu	r8,r9,r8
8000bafa:	10 9c       	mov	r12,r8
8000bafc:	f8 08 12 00 	clz	r8,r12
8000bb00:	c0 31       	brne	8000bb06 <__avr32_umod64+0x52>
8000bb02:	18 16       	sub	r6,r12
8000bb04:	c3 68       	rjmp	8000bb70 <__avr32_umod64+0xbc>
8000bb06:	f0 03 11 20 	rsub	r3,r8,32
8000bb0a:	f4 03 0a 4b 	lsr	r11,r10,r3
8000bb0e:	f8 08 09 4c 	lsl	r12,r12,r8
8000bb12:	ec 08 09 49 	lsl	r9,r6,r8
8000bb16:	ec 03 0a 43 	lsr	r3,r6,r3
8000bb1a:	f7 e9 10 09 	or	r9,r11,r9
8000bb1e:	f8 05 16 10 	lsr	r5,r12,0x10
8000bb22:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bb26:	e6 05 0d 02 	divu	r2,r3,r5
8000bb2a:	f2 0e 16 10 	lsr	lr,r9,0x10
8000bb2e:	ec 02 02 4b 	mul	r11,r6,r2
8000bb32:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000bb36:	16 3e       	cp.w	lr,r11
8000bb38:	c0 72       	brcc	8000bb46 <__avr32_umod64+0x92>
8000bb3a:	18 0e       	add	lr,r12
8000bb3c:	18 3e       	cp.w	lr,r12
8000bb3e:	c0 43       	brcs	8000bb46 <__avr32_umod64+0x92>
8000bb40:	16 3e       	cp.w	lr,r11
8000bb42:	fd dc e3 0e 	addcs	lr,lr,r12
8000bb46:	fc 0b 01 03 	sub	r3,lr,r11
8000bb4a:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000bb4e:	e6 05 0d 02 	divu	r2,r3,r5
8000bb52:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bb56:	a5 36       	mul	r6,r2
8000bb58:	0c 39       	cp.w	r9,r6
8000bb5a:	c0 72       	brcc	8000bb68 <__avr32_umod64+0xb4>
8000bb5c:	18 09       	add	r9,r12
8000bb5e:	18 39       	cp.w	r9,r12
8000bb60:	c0 43       	brcs	8000bb68 <__avr32_umod64+0xb4>
8000bb62:	0c 39       	cp.w	r9,r6
8000bb64:	f3 dc e3 09 	addcs	r9,r9,r12
8000bb68:	f2 06 01 06 	sub	r6,r9,r6
8000bb6c:	f4 08 09 4e 	lsl	lr,r10,r8
8000bb70:	f8 0a 16 10 	lsr	r10,r12,0x10
8000bb74:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000bb78:	ec 0a 0d 02 	divu	r2,r6,r10
8000bb7c:	fc 09 16 10 	lsr	r9,lr,0x10
8000bb80:	ea 02 02 4b 	mul	r11,r5,r2
8000bb84:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bb88:	16 39       	cp.w	r9,r11
8000bb8a:	c0 72       	brcc	8000bb98 <__avr32_umod64+0xe4>
8000bb8c:	18 09       	add	r9,r12
8000bb8e:	18 39       	cp.w	r9,r12
8000bb90:	c0 43       	brcs	8000bb98 <__avr32_umod64+0xe4>
8000bb92:	16 39       	cp.w	r9,r11
8000bb94:	f3 dc e3 09 	addcs	r9,r9,r12
8000bb98:	f2 0b 01 0b 	sub	r11,r9,r11
8000bb9c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000bba0:	f6 0a 0d 0a 	divu	r10,r11,r10
8000bba4:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000bba8:	ea 0a 02 4a 	mul	r10,r5,r10
8000bbac:	14 3e       	cp.w	lr,r10
8000bbae:	c0 72       	brcc	8000bbbc <__avr32_umod64+0x108>
8000bbb0:	18 0e       	add	lr,r12
8000bbb2:	18 3e       	cp.w	lr,r12
8000bbb4:	c0 43       	brcs	8000bbbc <__avr32_umod64+0x108>
8000bbb6:	14 3e       	cp.w	lr,r10
8000bbb8:	fd dc e3 0e 	addcs	lr,lr,r12
8000bbbc:	fc 0a 01 0a 	sub	r10,lr,r10
8000bbc0:	30 0b       	mov	r11,0
8000bbc2:	f4 08 0a 4a 	lsr	r10,r10,r8
8000bbc6:	c7 b8       	rjmp	8000bcbc <__avr32_umod64+0x208>
8000bbc8:	16 39       	cp.w	r9,r11
8000bbca:	e0 8b 00 79 	brhi	8000bcbc <__avr32_umod64+0x208>
8000bbce:	f2 09 12 00 	clz	r9,r9
8000bbd2:	c1 21       	brne	8000bbf6 <__avr32_umod64+0x142>
8000bbd4:	10 3a       	cp.w	r10,r8
8000bbd6:	5f 2b       	srhs	r11
8000bbd8:	0a 31       	cp.w	r1,r5
8000bbda:	5f ba       	srhi	r10
8000bbdc:	f7 ea 10 0a 	or	r10,r11,r10
8000bbe0:	f2 0a 18 00 	cp.b	r10,r9
8000bbe4:	c0 60       	breq	8000bbf0 <__avr32_umod64+0x13c>
8000bbe6:	fc 08 01 0c 	sub	r12,lr,r8
8000bbea:	e2 05 01 46 	sbc	r6,r1,r5
8000bbee:	18 9e       	mov	lr,r12
8000bbf0:	0c 9b       	mov	r11,r6
8000bbf2:	1c 9a       	mov	r10,lr
8000bbf4:	c6 48       	rjmp	8000bcbc <__avr32_umod64+0x208>
8000bbf6:	ea 09 09 4c 	lsl	r12,r5,r9
8000bbfa:	f2 06 11 20 	rsub	r6,r9,32
8000bbfe:	f6 09 09 4b 	lsl	r11,r11,r9
8000bc02:	f0 09 09 42 	lsl	r2,r8,r9
8000bc06:	ef 46 ff f4 	st.w	r7[-12],r6
8000bc0a:	f0 06 0a 48 	lsr	r8,r8,r6
8000bc0e:	18 48       	or	r8,r12
8000bc10:	e2 06 0a 4c 	lsr	r12,r1,r6
8000bc14:	f4 09 09 43 	lsl	r3,r10,r9
8000bc18:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000bc1c:	f4 06 0a 4a 	lsr	r10,r10,r6
8000bc20:	16 4a       	or	r10,r11
8000bc22:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bc26:	f8 0b 0d 04 	divu	r4,r12,r11
8000bc2a:	f4 0c 16 10 	lsr	r12,r10,0x10
8000bc2e:	08 91       	mov	r1,r4
8000bc30:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000bc34:	e8 0e 02 46 	mul	r6,r4,lr
8000bc38:	0c 3c       	cp.w	r12,r6
8000bc3a:	c0 a2       	brcc	8000bc4e <__avr32_umod64+0x19a>
8000bc3c:	20 11       	sub	r1,1
8000bc3e:	10 0c       	add	r12,r8
8000bc40:	10 3c       	cp.w	r12,r8
8000bc42:	c0 63       	brcs	8000bc4e <__avr32_umod64+0x19a>
8000bc44:	0c 3c       	cp.w	r12,r6
8000bc46:	f7 b1 03 01 	sublo	r1,1
8000bc4a:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000bc4e:	0c 1c       	sub	r12,r6
8000bc50:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000bc54:	f8 0b 0d 04 	divu	r4,r12,r11
8000bc58:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000bc5c:	08 96       	mov	r6,r4
8000bc5e:	e8 0e 02 4e 	mul	lr,r4,lr
8000bc62:	1c 3b       	cp.w	r11,lr
8000bc64:	c0 a2       	brcc	8000bc78 <__avr32_umod64+0x1c4>
8000bc66:	20 16       	sub	r6,1
8000bc68:	10 0b       	add	r11,r8
8000bc6a:	10 3b       	cp.w	r11,r8
8000bc6c:	c0 63       	brcs	8000bc78 <__avr32_umod64+0x1c4>
8000bc6e:	1c 3b       	cp.w	r11,lr
8000bc70:	f7 b6 03 01 	sublo	r6,1
8000bc74:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000bc78:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000bc7c:	1c 1b       	sub	r11,lr
8000bc7e:	e2 02 06 40 	mulu.d	r0,r1,r2
8000bc82:	00 9e       	mov	lr,r0
8000bc84:	02 9c       	mov	r12,r1
8000bc86:	16 3c       	cp.w	r12,r11
8000bc88:	e0 8b 00 08 	brhi	8000bc98 <__avr32_umod64+0x1e4>
8000bc8c:	5f 06       	sreq	r6
8000bc8e:	06 30       	cp.w	r0,r3
8000bc90:	5f ba       	srhi	r10
8000bc92:	ed ea 00 0a 	and	r10,r6,r10
8000bc96:	c0 60       	breq	8000bca2 <__avr32_umod64+0x1ee>
8000bc98:	fc 02 01 04 	sub	r4,lr,r2
8000bc9c:	f8 08 01 4c 	sbc	r12,r12,r8
8000bca0:	08 9e       	mov	lr,r4
8000bca2:	e6 0e 01 0a 	sub	r10,r3,lr
8000bca6:	f6 0c 01 4c 	sbc	r12,r11,r12
8000bcaa:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000bcae:	f8 09 0a 4b 	lsr	r11,r12,r9
8000bcb2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bcb6:	f8 01 09 4c 	lsl	r12,r12,r1
8000bcba:	18 4a       	or	r10,r12
8000bcbc:	2f dd       	sub	sp,-12
8000bcbe:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000be00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000be00:	c0 08       	rjmp	8000be00 <_evba>
	...

8000be04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000be04:	c0 08       	rjmp	8000be04 <_handle_TLB_Multiple_Hit>
	...

8000be08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000be08:	c0 08       	rjmp	8000be08 <_handle_Bus_Error_Data_Fetch>
	...

8000be0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000be0c:	c0 08       	rjmp	8000be0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000be10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000be10:	c0 08       	rjmp	8000be10 <_handle_NMI>
	...

8000be14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000be14:	c0 08       	rjmp	8000be14 <_handle_Instruction_Address>
	...

8000be18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000be18:	c0 08       	rjmp	8000be18 <_handle_ITLB_Protection>
	...

8000be1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000be1c:	c0 08       	rjmp	8000be1c <_handle_Breakpoint>
	...

8000be20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000be20:	c0 08       	rjmp	8000be20 <_handle_Illegal_Opcode>
	...

8000be24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000be24:	c0 08       	rjmp	8000be24 <_handle_Unimplemented_Instruction>
	...

8000be28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000be28:	c0 08       	rjmp	8000be28 <_handle_Privilege_Violation>
	...

8000be2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000be2c:	c0 08       	rjmp	8000be2c <_handle_Floating_Point>
	...

8000be30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000be30:	c0 08       	rjmp	8000be30 <_handle_Coprocessor_Absent>
	...

8000be34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000be34:	c0 08       	rjmp	8000be34 <_handle_Data_Address_Read>
	...

8000be38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000be38:	c0 08       	rjmp	8000be38 <_handle_Data_Address_Write>
	...

8000be3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000be3c:	c0 08       	rjmp	8000be3c <_handle_DTLB_Protection_Read>
	...

8000be40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000be40:	c0 08       	rjmp	8000be40 <_handle_DTLB_Protection_Write>
	...

8000be44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000be44:	c0 08       	rjmp	8000be44 <_handle_DTLB_Modified>
	...

8000be50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000be50:	c0 08       	rjmp	8000be50 <_handle_ITLB_Miss>
	...

8000be60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000be60:	c0 08       	rjmp	8000be60 <_handle_DTLB_Miss_Read>
	...

8000be70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000be70:	c0 08       	rjmp	8000be70 <_handle_DTLB_Miss_Write>
	...

8000bf00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000bf00:	fe cf 71 60 	sub	pc,pc,29024

8000bf04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000bf04:	30 0c       	mov	r12,0
8000bf06:	fe b0 c4 69 	rcall	800047d8 <_get_interrupt_handler>
8000bf0a:	58 0c       	cp.w	r12,0
8000bf0c:	f8 0f 17 10 	movne	pc,r12
8000bf10:	d6 03       	rete

8000bf12 <_int1>:
8000bf12:	30 1c       	mov	r12,1
8000bf14:	fe b0 c4 62 	rcall	800047d8 <_get_interrupt_handler>
8000bf18:	58 0c       	cp.w	r12,0
8000bf1a:	f8 0f 17 10 	movne	pc,r12
8000bf1e:	d6 03       	rete

8000bf20 <_int2>:
8000bf20:	30 2c       	mov	r12,2
8000bf22:	fe b0 c4 5b 	rcall	800047d8 <_get_interrupt_handler>
8000bf26:	58 0c       	cp.w	r12,0
8000bf28:	f8 0f 17 10 	movne	pc,r12
8000bf2c:	d6 03       	rete

8000bf2e <_int3>:
8000bf2e:	30 3c       	mov	r12,3
8000bf30:	fe b0 c4 54 	rcall	800047d8 <_get_interrupt_handler>
8000bf34:	58 0c       	cp.w	r12,0
8000bf36:	f8 0f 17 10 	movne	pc,r12
8000bf3a:	d6 03       	rete

8000bf3c <ipr_val>:
8000bf3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000bf4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bffc:	d7 03 d7 03                                         ....
