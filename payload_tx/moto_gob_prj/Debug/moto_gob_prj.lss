
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00009f74  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c000  8000c000  0000c400  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       0000179c  8000c200  8000c200  0000c600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .lalign       00000004  8000d99c  8000d99c  0000dd9c  2**0
                  ALLOC
  6 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  7 .data         00000a2c  00000008  8000d9a0  0000e008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .balign       00000004  00000a34  8000e3cc  0000ea34  2**0
                  ALLOC
  9 .bss          000036c8  00000a38  00000a38  00000000  2**2
                  ALLOC
 10 .heap         00012f00  00004100  00004100  00000000  2**0
                  ALLOC
 11 .comment      00000030  00000000  00000000  0000ea34  2**0
                  CONTENTS, READONLY
 12 .debug_aranges 00001140  00000000  00000000  0000ea68  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubnames 000024aa  00000000  00000000  0000fba8  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_info   00028243  00000000  00000000  00012052  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_abbrev 000067e5  00000000  00000000  0003a295  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_line   0000c151  00000000  00000000  00040a7a  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_frame  00002d38  00000000  00000000  0004cbcc  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    00006c7e  00000000  00000000  0004f904  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_loc    0000ca64  00000000  00000000  00056582  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 21 .debug_ranges 00001228  00000000  00000000  00062fe8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf 99 a8 	sub	pc,pc,-26200

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf b9 ac 	sub	pc,pc,-18004

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d 90       	ld.ub	r0,r6[0x1]

8000202c <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
8000202c:	5e fc       	retal	r12
8000202e:	d7 03       	nop

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 50       	eor	r0,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	20 94       	sub	r4,9
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 b0       	sub	r0,-117
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	29 98       	sub	r8,-103
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	3d 84       	mov	r4,-40
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	c2 00       	breq	800020c6 <FD_reply_func+0xa>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	27 f8       	sub	r8,127
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	5d cc       	*unknown*
80002090:	00 00       	add	r0,r0
80002092:	0a 40       	or	r0,r5

80002094 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002094:	d4 01       	pushm	lr
  log("R");
80002096:	48 3c       	lddpc	r12,800020a0 <app_payload_tx_proc+0xc>
80002098:	f0 1f 00 03 	mcall	800020a4 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
8000209c:	d8 02       	popm	pc
8000209e:	00 00       	add	r0,r0
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	c2 08       	rjmp	800020e2 <FD_request_func+0x12>
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	61 90       	ld.w	r0,r0[0x64]

800020a8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020a8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020aa:	48 3c       	lddpc	r12,800020b4 <FD_brdcst_func+0xc>
800020ac:	f0 1f 00 03 	mcall	800020b8 <FD_brdcst_func+0x10>
	
}
800020b0:	d8 02       	popm	pc
800020b2:	00 00       	add	r0,r0
800020b4:	80 00       	ld.sh	r0,r0[0x0]
800020b6:	c2 0c       	rcall	800020f6 <EnOB_brdcst_func+0x12>
800020b8:	80 00       	ld.sh	r0,r0[0x0]
800020ba:	61 90       	ld.w	r0,r0[0x64]

800020bc <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020bc:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020be:	48 3c       	lddpc	r12,800020c8 <FD_reply_func+0xc>
800020c0:	f0 1f 00 03 	mcall	800020cc <FD_reply_func+0x10>
	
	
}
800020c4:	d8 02       	popm	pc
800020c6:	00 00       	add	r0,r0
800020c8:	80 00       	ld.sh	r0,r0[0x0]
800020ca:	c2 2c       	rcall	8000210e <EnOB_reply_func+0x16>
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	61 90       	ld.w	r0,r0[0x64]

800020d0 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020d0:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020d2:	48 3c       	lddpc	r12,800020dc <FD_request_func+0xc>
800020d4:	f0 1f 00 03 	mcall	800020e0 <FD_request_func+0x10>
	
	
}
800020d8:	d8 02       	popm	pc
800020da:	00 00       	add	r0,r0
800020dc:	80 00       	ld.sh	r0,r0[0x0]
800020de:	c2 48       	rjmp	80002126 <EnOB_reply_func+0x2e>
800020e0:	80 00       	ld.sh	r0,r0[0x0]
800020e2:	61 90       	ld.w	r0,r0[0x64]

800020e4 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020e4:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020e6:	48 3c       	lddpc	r12,800020f0 <EnOB_brdcst_func+0xc>
800020e8:	f0 1f 00 03 	mcall	800020f4 <EnOB_brdcst_func+0x10>
}
800020ec:	d8 02       	popm	pc
800020ee:	00 00       	add	r0,r0
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	c2 64       	brge	8000213e <EnOB_reply_func+0x46>
800020f4:	80 00       	ld.sh	r0,r0[0x0]
800020f6:	61 90       	ld.w	r0,r0[0x64]

800020f8 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020f8:	eb cd 40 80 	pushm	r7,lr
800020fc:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020fe:	19 a9       	ld.ub	r9,r12[0x2]
80002100:	30 08       	mov	r8,0
80002102:	f0 09 18 00 	cp.b	r9,r8
80002106:	c1 91       	brne	80002138 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002108:	19 b8       	ld.ub	r8,r12[0x3]
8000210a:	30 19       	mov	r9,1
8000210c:	f2 08 18 00 	cp.b	r8,r9
80002110:	c0 61       	brne	8000211c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002112:	49 0c       	lddpc	r12,80002150 <EnOB_reply_func+0x58>
80002114:	f0 1f 00 10 	mcall	80002154 <EnOB_reply_func+0x5c>
80002118:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000211c:	58 08       	cp.w	r8,0
8000211e:	c0 61       	brne	8000212a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002120:	48 ec       	lddpc	r12,80002158 <EnOB_reply_func+0x60>
80002122:	f0 1f 00 0d 	mcall	80002154 <EnOB_reply_func+0x5c>
80002126:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000212a:	1a d8       	st.w	--sp,r8
8000212c:	48 cc       	lddpc	r12,8000215c <EnOB_reply_func+0x64>
8000212e:	f0 1f 00 0a 	mcall	80002154 <EnOB_reply_func+0x5c>
80002132:	2f fd       	sub	sp,-4
80002134:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002138:	48 ac       	lddpc	r12,80002160 <EnOB_reply_func+0x68>
8000213a:	f0 1f 00 07 	mcall	80002154 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000213e:	0f a8       	ld.ub	r8,r7[0x2]
80002140:	1a d8       	st.w	--sp,r8
80002142:	48 9c       	lddpc	r12,80002164 <EnOB_reply_func+0x6c>
80002144:	f0 1f 00 04 	mcall	80002154 <EnOB_reply_func+0x5c>
80002148:	2f fd       	sub	sp,-4
8000214a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000214e:	00 00       	add	r0,r0
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	c2 7c       	rcall	800021a0 <SingleDetection_brdcst_func+0x38>
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	61 90       	ld.w	r0,r0[0x64]
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	c2 94       	brge	800021ac <ButtonConfig_brdcst_func+0x4>
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	c2 a8       	rjmp	800021b2 <ButtonConfig_brdcst_func+0xa>
80002160:	80 00       	ld.sh	r0,r0[0x0]
80002162:	c2 c0       	breq	800021ba <ButtonConfig_brdcst_func+0x12>
80002164:	80 00       	ld.sh	r0,r0[0x0]
80002166:	c2 dc       	rcall	800021c0 <ButtonConfig_brdcst_func+0x18>

80002168 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002168:	eb cd 40 80 	pushm	r7,lr
8000216c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000216e:	19 a9       	ld.ub	r9,r12[0x2]
80002170:	31 18       	mov	r8,17
80002172:	f0 09 18 00 	cp.b	r9,r8
80002176:	c0 61       	brne	80002182 <SingleDetection_brdcst_func+0x1a>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002178:	48 8c       	lddpc	r12,80002198 <SingleDetection_brdcst_func+0x30>
8000217a:	f0 1f 00 09 	mcall	8000219c <SingleDetection_brdcst_func+0x34>
8000217e:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error");
80002182:	48 8c       	lddpc	r12,800021a0 <SingleDetection_brdcst_func+0x38>
80002184:	f0 1f 00 06 	mcall	8000219c <SingleDetection_brdcst_func+0x34>
		log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
80002188:	0f a8       	ld.ub	r8,r7[0x2]
8000218a:	1a d8       	st.w	--sp,r8
8000218c:	48 6c       	lddpc	r12,800021a4 <SingleDetection_brdcst_func+0x3c>
8000218e:	f0 1f 00 04 	mcall	8000219c <SingleDetection_brdcst_func+0x34>
80002192:	2f fd       	sub	sp,-4
80002194:	e3 cd 80 80 	ldm	sp++,r7,pc
80002198:	80 00       	ld.sh	r0,r0[0x0]
8000219a:	c2 f4       	brge	800021f8 <ButtonConfig_brdcst_func+0x50>
8000219c:	80 00       	ld.sh	r0,r0[0x0]
8000219e:	61 90       	ld.w	r0,r0[0x64]
800021a0:	80 00       	ld.sh	r0,r0[0x0]
800021a2:	c3 08       	rjmp	80002202 <ButtonConfig_brdcst_func+0x5a>
800021a4:	80 00       	ld.sh	r0,r0[0x0]
800021a6:	c3 18       	rjmp	80002208 <ButtonConfig_brdcst_func+0x60>

800021a8 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021a8:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021aa:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ae:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021b0:	4a bc       	lddpc	r12,8000225c <ButtonConfig_brdcst_func+0xb4>
800021b2:	f0 1f 00 2c 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021b6:	0f 88       	ld.ub	r8,r7[0x0]
800021b8:	1a d8       	st.w	--sp,r8
800021ba:	4a bc       	lddpc	r12,80002264 <ButtonConfig_brdcst_func+0xbc>
800021bc:	f0 1f 00 29 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021c0:	1a d5       	st.w	--sp,r5
800021c2:	4a ac       	lddpc	r12,80002268 <ButtonConfig_brdcst_func+0xc0>
800021c4:	f0 1f 00 27 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021c8:	0f a8       	ld.ub	r8,r7[0x2]
800021ca:	1a d8       	st.w	--sp,r8
800021cc:	4a 8c       	lddpc	r12,8000226c <ButtonConfig_brdcst_func+0xc4>
800021ce:	f0 1f 00 25 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021d2:	2f dd       	sub	sp,-12
800021d4:	58 05       	cp.w	r5,0
800021d6:	c4 10       	breq	80002258 <ButtonConfig_brdcst_func+0xb0>
800021d8:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021da:	4a 64       	lddpc	r4,80002270 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021dc:	4a 63       	lddpc	r3,80002274 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021de:	4a 72       	lddpc	r2,80002278 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021e0:	4a 71       	lddpc	r1,8000227c <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021e2:	4a 80       	lddpc	r0,80002280 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021e4:	0f b9       	ld.ub	r9,r7[0x3]
800021e6:	0f c8       	ld.ub	r8,r7[0x4]
800021e8:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021ec:	1a d8       	st.w	--sp,r8
800021ee:	1a d6       	st.w	--sp,r6
800021f0:	08 9c       	mov	r12,r4
800021f2:	f0 1f 00 1c 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021f6:	0f d9       	ld.ub	r9,r7[0x5]
800021f8:	0f e8       	ld.ub	r8,r7[0x6]
800021fa:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021fe:	1a d8       	st.w	--sp,r8
80002200:	1a d6       	st.w	--sp,r6
80002202:	06 9c       	mov	r12,r3
80002204:	f0 1f 00 17 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002208:	0f f9       	ld.ub	r9,r7[0x7]
8000220a:	ef 38 00 08 	ld.ub	r8,r7[8]
8000220e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002212:	1a d8       	st.w	--sp,r8
80002214:	1a d6       	st.w	--sp,r6
80002216:	04 9c       	mov	r12,r2
80002218:	f0 1f 00 12 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	ef 39 00 09 	ld.ub	r9,r7[9]
80002220:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	02 9c       	mov	r12,r1
8000222e:	f0 1f 00 0d 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002232:	2f 8d       	sub	sp,-32
80002234:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002238:	ef 38 00 0c 	ld.ub	r8,r7[12]
8000223c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002240:	1a d8       	st.w	--sp,r8
80002242:	1a d6       	st.w	--sp,r6
80002244:	00 9c       	mov	r12,r0
80002246:	f0 1f 00 07 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
8000224a:	2f f6       	sub	r6,-1
8000224c:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000224e:	2f ed       	sub	sp,-8
80002250:	ec 05 18 00 	cp.b	r5,r6
80002254:	fe 9b ff c8 	brhi	800021e4 <ButtonConfig_brdcst_func+0x3c>
80002258:	d8 32       	popm	r0-r7,pc
8000225a:	00 00       	add	r0,r0
8000225c:	80 00       	ld.sh	r0,r0[0x0]
8000225e:	c3 30       	breq	800022c4 <Phyuserinput_brdcst_func+0x40>
80002260:	80 00       	ld.sh	r0,r0[0x0]
80002262:	61 90       	ld.w	r0,r0[0x64]
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	c3 50       	breq	800022d0 <Phyuserinput_brdcst_func+0x4c>
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	c3 64       	brge	800022d6 <Phyuserinput_brdcst_func+0x52>
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	c3 7c       	rcall	800022dc <Phyuserinput_brdcst_func+0x58>
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	c3 9c       	rcall	800022e4 <Phyuserinput_brdcst_func+0x60>
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	c3 c4       	brge	800022ee <Phyuserinput_brdcst_func+0x6a>
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	c3 ec       	rcall	800022f6 <Phyuserinput_brdcst_func+0x72>
8000227c:	80 00       	ld.sh	r0,r0[0x0]
8000227e:	c4 10       	breq	80002300 <ButtonConfig_reply_func+0x4>
80002280:	80 00       	ld.sh	r0,r0[0x0]
80002282:	c4 38       	rjmp	80002308 <ButtonConfig_reply_func+0xc>

80002284 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002284:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
80002288:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
8000228a:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
8000228c:	19 c7       	ld.ub	r7,r12[0x4]
8000228e:	19 d8       	ld.ub	r8,r12[0x5]
80002290:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002294:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
80002296:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
80002298:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
8000229c:	49 0c       	lddpc	r12,800022dc <Phyuserinput_brdcst_func+0x58>
8000229e:	f0 1f 00 11 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
800022a2:	1a d6       	st.w	--sp,r6
800022a4:	49 0c       	lddpc	r12,800022e4 <Phyuserinput_brdcst_func+0x60>
800022a6:	f0 1f 00 0f 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
800022aa:	1a d5       	st.w	--sp,r5
800022ac:	48 fc       	lddpc	r12,800022e8 <Phyuserinput_brdcst_func+0x64>
800022ae:	f0 1f 00 0d 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
800022b2:	5c 77       	castu.h	r7
800022b4:	1a d7       	st.w	--sp,r7
800022b6:	48 ec       	lddpc	r12,800022ec <Phyuserinput_brdcst_func+0x68>
800022b8:	f0 1f 00 0a 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
800022bc:	1a d4       	st.w	--sp,r4
800022be:	48 dc       	lddpc	r12,800022f0 <Phyuserinput_brdcst_func+0x6c>
800022c0:	f0 1f 00 08 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
800022c4:	1a d3       	st.w	--sp,r3
800022c6:	48 cc       	lddpc	r12,800022f4 <Phyuserinput_brdcst_func+0x70>
800022c8:	f0 1f 00 06 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
800022cc:	1a d2       	st.w	--sp,r2
800022ce:	48 bc       	lddpc	r12,800022f8 <Phyuserinput_brdcst_func+0x74>
800022d0:	f0 1f 00 04 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
800022d4:	2f ad       	sub	sp,-24
	
	
	
	
	
}
800022d6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800022da:	00 00       	add	r0,r0
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	c4 5c       	rcall	80002368 <DataSession_brdcst_func+0x28>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	61 90       	ld.w	r0,r0[0x64]
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	c4 80       	breq	80002376 <DataSession_brdcst_func+0x36>
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	c4 98       	rjmp	8000237c <DataSession_brdcst_func+0x3c>
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	c4 ac       	rcall	80002382 <DataSession_brdcst_func+0x42>
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	c4 c0       	breq	8000238a <DataSession_brdcst_func+0x4a>
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	c4 d4       	brge	80002390 <DataSession_brdcst_func+0x50>
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	c4 f4       	brge	80002398 <DataSession_brdcst_func+0x58>

800022fc <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022fc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002300:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002304:	0f 89       	ld.ub	r9,r7[0x0]
80002306:	30 08       	mov	r8,0
80002308:	f0 09 18 00 	cp.b	r9,r8
8000230c:	c0 c1       	brne	80002324 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000230e:	48 9c       	lddpc	r12,80002330 <ButtonConfig_reply_func+0x34>
80002310:	f0 1f 00 09 	mcall	80002334 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002314:	0f 98       	ld.ub	r8,r7[0x1]
80002316:	1a d8       	st.w	--sp,r8
80002318:	48 8c       	lddpc	r12,80002338 <ButtonConfig_reply_func+0x3c>
8000231a:	f0 1f 00 07 	mcall	80002334 <ButtonConfig_reply_func+0x38>
8000231e:	2f fd       	sub	sp,-4
80002320:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002324:	48 6c       	lddpc	r12,8000233c <ButtonConfig_reply_func+0x40>
80002326:	f0 1f 00 04 	mcall	80002334 <ButtonConfig_reply_func+0x38>
8000232a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000232e:	00 00       	add	r0,r0
80002330:	80 00       	ld.sh	r0,r0[0x0]
80002332:	c5 14       	brge	800023d4 <DataSession_reply_func+0x10>
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	61 90       	ld.w	r0,r0[0x64]
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	c3 50       	breq	800023a4 <DataSession_brdcst_func+0x64>
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	c5 2c       	rcall	800023e2 <DataSession_reply_func+0x1e>

80002340 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002340:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002342:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
80002346:	0d 88       	ld.ub	r8,r6[0x0]
80002348:	32 49       	mov	r9,36
8000234a:	f2 08 18 00 	cp.b	r8,r9
8000234e:	c2 91       	brne	800023a0 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002350:	49 7c       	lddpc	r12,800023ac <DataSession_brdcst_func+0x6c>
80002352:	f0 1f 00 18 	mcall	800023b0 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002356:	0d a5       	ld.ub	r5,r6[0x2]
80002358:	0d b8       	ld.ub	r8,r6[0x3]
8000235a:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000235e:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002360:	0d 98       	ld.ub	r8,r6[0x1]
80002362:	1a d8       	st.w	--sp,r8
80002364:	49 4c       	lddpc	r12,800023b4 <DataSession_brdcst_func+0x74>
80002366:	f0 1f 00 13 	mcall	800023b0 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000236a:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000236e:	1a d8       	st.w	--sp,r8
80002370:	49 2c       	lddpc	r12,800023b8 <DataSession_brdcst_func+0x78>
80002372:	f0 1f 00 10 	mcall	800023b0 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
80002376:	2f ed       	sub	sp,-8
80002378:	58 05       	cp.w	r5,0
8000237a:	c1 80       	breq	800023aa <DataSession_brdcst_func+0x6a>
8000237c:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000237e:	49 04       	lddpc	r4,800023bc <DataSession_brdcst_func+0x7c>
80002380:	ec 07 00 08 	add	r8,r6,r7
80002384:	11 c8       	ld.ub	r8,r8[0x4]
80002386:	1a d8       	st.w	--sp,r8
80002388:	1a d7       	st.w	--sp,r7
8000238a:	08 9c       	mov	r12,r4
8000238c:	f0 1f 00 09 	mcall	800023b0 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002390:	2f f7       	sub	r7,-1
80002392:	5c 57       	castu.b	r7
80002394:	2f ed       	sub	sp,-8
80002396:	ee 05 19 00 	cp.h	r5,r7
8000239a:	fe 9b ff f3 	brhi	80002380 <DataSession_brdcst_func+0x40>
8000239e:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
800023a0:	1a d8       	st.w	--sp,r8
800023a2:	48 8c       	lddpc	r12,800023c0 <DataSession_brdcst_func+0x80>
800023a4:	f0 1f 00 03 	mcall	800023b0 <DataSession_brdcst_func+0x70>
800023a8:	2f fd       	sub	sp,-4
800023aa:	d8 22       	popm	r4-r7,pc
800023ac:	80 00       	ld.sh	r0,r0[0x0]
800023ae:	c5 48       	rjmp	80002456 <TransmitControl_brdcst_func+0x3a>
800023b0:	80 00       	ld.sh	r0,r0[0x0]
800023b2:	61 90       	ld.w	r0,r0[0x64]
800023b4:	80 00       	ld.sh	r0,r0[0x0]
800023b6:	c5 5c       	rcall	80002460 <TransmitControl_brdcst_func+0x44>
800023b8:	80 00       	ld.sh	r0,r0[0x0]
800023ba:	c5 74       	brge	80002468 <TransmitControl_reply_func+0x4>
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	c5 90       	breq	80002470 <TransmitControl_reply_func+0xc>
800023c0:	80 00       	ld.sh	r0,r0[0x0]
800023c2:	c5 a8       	rjmp	80002476 <TransmitControl_reply_func+0x12>

800023c4 <DataSession_reply_func>:
	
}


void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800023c4:	eb cd 40 80 	pushm	r7,lr
800023c8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023ca:	19 a8       	ld.ub	r8,r12[0x2]
800023cc:	58 08       	cp.w	r8,0
800023ce:	c0 61       	brne	800023da <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
800023d0:	48 dc       	lddpc	r12,80002404 <DataSession_reply_func+0x40>
800023d2:	f0 1f 00 0e 	mcall	80002408 <DataSession_reply_func+0x44>
800023d6:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
800023da:	1a d8       	st.w	--sp,r8
800023dc:	48 cc       	lddpc	r12,8000240c <DataSession_reply_func+0x48>
800023de:	f0 1f 00 0b 	mcall	80002408 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
800023e2:	48 cc       	lddpc	r12,80002410 <DataSession_reply_func+0x4c>
800023e4:	f0 1f 00 09 	mcall	80002408 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
800023e8:	0f b8       	ld.ub	r8,r7[0x3]
800023ea:	1a d8       	st.w	--sp,r8
800023ec:	48 ac       	lddpc	r12,80002414 <DataSession_reply_func+0x50>
800023ee:	f0 1f 00 07 	mcall	80002408 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
800023f2:	0f c8       	ld.ub	r8,r7[0x4]
800023f4:	1a d8       	st.w	--sp,r8
800023f6:	48 9c       	lddpc	r12,80002418 <DataSession_reply_func+0x54>
800023f8:	f0 1f 00 04 	mcall	80002408 <DataSession_reply_func+0x44>
800023fc:	2f dd       	sub	sp,-12
800023fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002402:	00 00       	add	r0,r0
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	c5 bc       	rcall	800024bc <TransmitControl_reply_func+0x58>
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	61 90       	ld.w	r0,r0[0x64]
8000240c:	80 00       	ld.sh	r0,r0[0x0]
8000240e:	c5 d0       	breq	800024c8 <TransmitControl_reply_func+0x64>
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	c5 e4       	brge	800024ce <TransmitControl_reply_func+0x6a>
80002414:	80 00       	ld.sh	r0,r0[0x0]
80002416:	c5 f8       	rjmp	800024d4 <TransmitControl_reply_func+0x70>
80002418:	80 00       	ld.sh	r0,r0[0x0]
8000241a:	c6 08       	rjmp	800024da <TransmitControl_reply_func+0x76>

8000241c <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000241c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002420:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002424:	0f 99       	ld.ub	r9,r7[0x1]
80002426:	30 08       	mov	r8,0
80002428:	f0 09 18 00 	cp.b	r9,r8
8000242c:	c0 71       	brne	8000243a <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
8000242e:	48 ac       	lddpc	r12,80002454 <TransmitControl_brdcst_func+0x38>
80002430:	f0 1f 00 0a 	mcall	80002458 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002434:	30 09       	mov	r9,0
80002436:	48 a8       	lddpc	r8,8000245c <TransmitControl_brdcst_func+0x40>
80002438:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000243a:	0f 99       	ld.ub	r9,r7[0x1]
8000243c:	30 18       	mov	r8,1
8000243e:	f0 09 18 00 	cp.b	r9,r8
80002442:	c0 71       	brne	80002450 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002444:	48 7c       	lddpc	r12,80002460 <TransmitControl_brdcst_func+0x44>
80002446:	f0 1f 00 05 	mcall	80002458 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000244a:	30 19       	mov	r9,1
8000244c:	48 48       	lddpc	r8,8000245c <TransmitControl_brdcst_func+0x40>
8000244e:	b0 89       	st.b	r8[0x0],r9
80002450:	e3 cd 80 80 	ldm	sp++,r7,pc
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	c6 18       	rjmp	80002518 <AudioRoutingControl_brdcst_func+0x38>
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	61 90       	ld.w	r0,r0[0x64]
8000245c:	00 00       	add	r0,r0
8000245e:	0a 45       	or	r5,r5
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	c6 30       	breq	80002528 <AudioRoutingControl_brdcst_func+0x48>

80002464 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002464:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002468:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000246c:	0f 89       	ld.ub	r9,r7[0x0]
8000246e:	30 08       	mov	r8,0
80002470:	f0 09 18 00 	cp.b	r9,r8
80002474:	c2 21       	brne	800024b8 <TransmitControl_reply_func+0x54>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002476:	49 4c       	lddpc	r12,800024c4 <TransmitControl_reply_func+0x60>
80002478:	f0 1f 00 14 	mcall	800024c8 <TransmitControl_reply_func+0x64>
		log("\n\r Function: %x \n\r", ptr->Function);
8000247c:	0f 98       	ld.ub	r8,r7[0x1]
8000247e:	1a d8       	st.w	--sp,r8
80002480:	49 3c       	lddpc	r12,800024cc <TransmitControl_reply_func+0x68>
80002482:	f0 1f 00 12 	mcall	800024c8 <TransmitControl_reply_func+0x64>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002486:	0f a8       	ld.ub	r8,r7[0x2]
80002488:	1a d8       	st.w	--sp,r8
8000248a:	49 2c       	lddpc	r12,800024d0 <TransmitControl_reply_func+0x6c>
8000248c:	f0 1f 00 0f 	mcall	800024c8 <TransmitControl_reply_func+0x64>
		log("\n\r State: %x \n\r", ptr->State);
80002490:	0f b8       	ld.ub	r8,r7[0x3]
80002492:	1a d8       	st.w	--sp,r8
80002494:	49 0c       	lddpc	r12,800024d4 <TransmitControl_reply_func+0x70>
80002496:	f0 1f 00 0d 	mcall	800024c8 <TransmitControl_reply_func+0x64>
		
		if (ptr->Function == KEY_UP)
8000249a:	0f 98       	ld.ub	r8,r7[0x1]
8000249c:	2f dd       	sub	sp,-12
8000249e:	30 19       	mov	r9,1
800024a0:	f2 08 18 00 	cp.b	r8,r9
800024a4:	c0 d0       	breq	800024be <TransmitControl_reply_func+0x5a>
		{
			//is_unmute = 1;
		}
		else if (ptr->Function ==DE_KEY)
800024a6:	30 29       	mov	r9,2
800024a8:	f2 08 18 00 	cp.b	r8,r9
800024ac:	c0 91       	brne	800024be <TransmitControl_reply_func+0x5a>
		{
			is_unmute = 0;
800024ae:	30 09       	mov	r9,0
800024b0:	48 a8       	lddpc	r8,800024d8 <TransmitControl_reply_func+0x74>
800024b2:	b0 89       	st.b	r8[0x0],r9
800024b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800024b8:	48 9c       	lddpc	r12,800024dc <TransmitControl_reply_func+0x78>
800024ba:	f0 1f 00 04 	mcall	800024c8 <TransmitControl_reply_func+0x64>
800024be:	e3 cd 80 80 	ldm	sp++,r7,pc
800024c2:	00 00       	add	r0,r0
800024c4:	80 00       	ld.sh	r0,r0[0x0]
800024c6:	c6 44       	brge	8000258e <Volume_reply_func+0x2e>
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	61 90       	ld.w	r0,r0[0x64]
800024cc:	80 00       	ld.sh	r0,r0[0x0]
800024ce:	c6 60       	breq	8000259a <Volume_reply_func+0x3a>
800024d0:	80 00       	ld.sh	r0,r0[0x0]
800024d2:	c6 74       	brge	800025a0 <Volume_reply_func+0x40>
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	c6 90       	breq	800025a8 <Volume_reply_func+0x48>
800024d8:	00 00       	add	r0,r0
800024da:	0a 49       	or	r9,r5
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	c6 a0       	breq	800025b2 <Volume_reply_func+0x52>

800024e0 <AudioRoutingControl_brdcst_func>:
	}
}


void AudioRoutingControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024e0:	eb cd 40 f8 	pushm	r3-r7,lr
800024e4:	18 96       	mov	r6,r12
	
	U16 num_routings = 0;
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
800024e6:	19 a5       	ld.ub	r5,r12[0x2]
800024e8:	19 b8       	ld.ub	r8,r12[0x3]
800024ea:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800024ee:	5c 85       	casts.h	r5
	log("\n\r num_routings: %d \n\r", num_routings);
800024f0:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800024f4:	1a d8       	st.w	--sp,r8
800024f6:	49 6c       	lddpc	r12,8000254c <AudioRoutingControl_brdcst_func+0x6c>
800024f8:	f0 1f 00 16 	mcall	80002550 <AudioRoutingControl_brdcst_func+0x70>
	
	for(j = 0; j< num_routings ; j++ )
800024fc:	2f fd       	sub	sp,-4
800024fe:	58 05       	cp.w	r5,0
80002500:	c0 31       	brne	80002506 <AudioRoutingControl_brdcst_func+0x26>
80002502:	30 07       	mov	r7,0
80002504:	c1 98       	rjmp	80002536 <AudioRoutingControl_brdcst_func+0x56>
80002506:	30 07       	mov	r7,0
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
80002508:	49 34       	lddpc	r4,80002554 <AudioRoutingControl_brdcst_func+0x74>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
8000250a:	49 43       	lddpc	r3,80002558 <AudioRoutingControl_brdcst_func+0x78>
	
	for(j = 0; j< num_routings ; j++ )
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
8000250c:	ec 07 00 18 	add	r8,r6,r7<<0x1
80002510:	11 c8       	ld.ub	r8,r8[0x4]
80002512:	1a d8       	st.w	--sp,r8
80002514:	08 9c       	mov	r12,r4
80002516:	f0 1f 00 0f 	mcall	80002550 <AudioRoutingControl_brdcst_func+0x70>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
8000251a:	ec 07 00 18 	add	r8,r6,r7<<0x1
8000251e:	11 d8       	ld.ub	r8,r8[0x5]
80002520:	1a d8       	st.w	--sp,r8
80002522:	06 9c       	mov	r12,r3
80002524:	f0 1f 00 0b 	mcall	80002550 <AudioRoutingControl_brdcst_func+0x70>
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
	log("\n\r num_routings: %d \n\r", num_routings);
	
	for(j = 0; j< num_routings ; j++ )
80002528:	2f f7       	sub	r7,-1
8000252a:	5c 57       	castu.b	r7
8000252c:	2f ed       	sub	sp,-8
8000252e:	ee 05 19 00 	cp.h	r5,r7
80002532:	fe 9b ff ed 	brhi	8000250c <AudioRoutingControl_brdcst_func+0x2c>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
		
		
	}
	
	log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
80002536:	ec 07 00 17 	add	r7,r6,r7<<0x1
8000253a:	0f c8       	ld.ub	r8,r7[0x4]
8000253c:	1a d8       	st.w	--sp,r8
8000253e:	48 8c       	lddpc	r12,8000255c <AudioRoutingControl_brdcst_func+0x7c>
80002540:	f0 1f 00 04 	mcall	80002550 <AudioRoutingControl_brdcst_func+0x70>
80002544:	2f fd       	sub	sp,-4
	
	
	
}
80002546:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000254a:	00 00       	add	r0,r0
8000254c:	80 00       	ld.sh	r0,r0[0x0]
8000254e:	c6 b8       	rjmp	80002624 <spk_reply_func+0x20>
80002550:	80 00       	ld.sh	r0,r0[0x0]
80002552:	61 90       	ld.w	r0,r0[0x64]
80002554:	80 00       	ld.sh	r0,r0[0x0]
80002556:	c6 d0       	breq	80002630 <spk_reply_func+0x2c>
80002558:	80 00       	ld.sh	r0,r0[0x0]
8000255a:	c6 e8       	rjmp	80002636 <spk_reply_func+0x32>
8000255c:	80 00       	ld.sh	r0,r0[0x0]
8000255e:	c7 00       	breq	8000263e <spk_reply_func+0x3a>

80002560 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002560:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002564:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002568:	0f 89       	ld.ub	r9,r7[0x0]
8000256a:	30 08       	mov	r8,0
8000256c:	f0 09 18 00 	cp.b	r9,r8
80002570:	c1 b1       	brne	800025a6 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002572:	0f b8       	ld.ub	r8,r7[0x3]
80002574:	31 09       	mov	r9,16
80002576:	f2 08 18 00 	cp.b	r8,r9
8000257a:	c0 f1       	brne	80002598 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
8000257c:	48 dc       	lddpc	r12,800025b0 <Volume_reply_func+0x50>
8000257e:	f0 1f 00 0e 	mcall	800025b4 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002582:	0f 99       	ld.ub	r9,r7[0x1]
80002584:	0f a8       	ld.ub	r8,r7[0x2]
80002586:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000258a:	1a d8       	st.w	--sp,r8
8000258c:	48 bc       	lddpc	r12,800025b8 <Volume_reply_func+0x58>
8000258e:	f0 1f 00 0a 	mcall	800025b4 <Volume_reply_func+0x54>
80002592:	2f fd       	sub	sp,-4
80002594:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002598:	1a d8       	st.w	--sp,r8
8000259a:	48 9c       	lddpc	r12,800025bc <Volume_reply_func+0x5c>
8000259c:	f0 1f 00 06 	mcall	800025b4 <Volume_reply_func+0x54>
800025a0:	2f fd       	sub	sp,-4
800025a2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025a6:	48 7c       	lddpc	r12,800025c0 <Volume_reply_func+0x60>
800025a8:	f0 1f 00 03 	mcall	800025b4 <Volume_reply_func+0x54>
800025ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800025b0:	80 00       	ld.sh	r0,r0[0x0]
800025b2:	c7 1c       	rcall	80002694 <mic_reply_func+0x8>
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	61 90       	ld.w	r0,r0[0x64]
800025b8:	80 00       	ld.sh	r0,r0[0x0]
800025ba:	c7 30       	breq	800026a0 <mic_reply_func+0x14>
800025bc:	80 00       	ld.sh	r0,r0[0x0]
800025be:	c7 4c       	rcall	800026a6 <mic_reply_func+0x1a>
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	c7 64       	brge	800026ae <mic_reply_func+0x22>

800025c4 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025c4:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025c6:	19 d9       	ld.ub	r9,r12[0x5]
800025c8:	30 08       	mov	r8,0
800025ca:	f0 09 18 00 	cp.b	r9,r8
800025ce:	c0 91       	brne	800025e0 <spk_brdcst_func+0x1c>
	{
		is_unmute =0;
800025d0:	48 89       	lddpc	r9,800025f0 <spk_brdcst_func+0x2c>
800025d2:	b2 88       	st.b	r9[0x0],r8
		Silent_flag = 0;
800025d4:	48 89       	lddpc	r9,800025f4 <spk_brdcst_func+0x30>
800025d6:	b2 88       	st.b	r9[0x0],r8
		log("spk_s_close ");
800025d8:	48 8c       	lddpc	r12,800025f8 <spk_brdcst_func+0x34>
800025da:	f0 1f 00 09 	mcall	800025fc <spk_brdcst_func+0x38>
800025de:	d8 02       	popm	pc
		
		
	}
	else
	{
		Silent_flag = 1;
800025e0:	30 19       	mov	r9,1
800025e2:	48 58       	lddpc	r8,800025f4 <spk_brdcst_func+0x30>
800025e4:	b0 89       	st.b	r8[0x0],r9
		//is_unmute = 1;
		log("spk_s_open ");
800025e6:	48 7c       	lddpc	r12,80002600 <spk_brdcst_func+0x3c>
800025e8:	f0 1f 00 05 	mcall	800025fc <spk_brdcst_func+0x38>
800025ec:	d8 02       	popm	pc
800025ee:	00 00       	add	r0,r0
800025f0:	00 00       	add	r0,r0
800025f2:	0a 49       	or	r9,r5
800025f4:	00 00       	add	r0,r0
800025f6:	0a 4b       	or	r11,r5
800025f8:	80 00       	ld.sh	r0,r0[0x0]
800025fa:	c7 7c       	rcall	800026e8 <mic_reply_func+0x5c>
800025fc:	80 00       	ld.sh	r0,r0[0x0]
800025fe:	61 90       	ld.w	r0,r0[0x64]
80002600:	80 00       	ld.sh	r0,r0[0x0]
80002602:	c7 8c       	rcall	800026f2 <mic_reply_func+0x66>

80002604 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002604:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002606:	19 a9       	ld.ub	r9,r12[0x2]
80002608:	30 08       	mov	r8,0
8000260a:	f0 09 18 00 	cp.b	r9,r8
8000260e:	c0 f1       	brne	8000262c <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002610:	19 e9       	ld.ub	r9,r12[0x6]
80002612:	f0 09 18 00 	cp.b	r9,r8
80002616:	c0 40       	breq	8000261e <spk_reply_func+0x1a>
		{
			is_unmute = 1;
80002618:	30 19       	mov	r9,1
8000261a:	48 78       	lddpc	r8,80002634 <spk_reply_func+0x30>
8000261c:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000261e:	19 e8       	ld.ub	r8,r12[0x6]
80002620:	1a d8       	st.w	--sp,r8
80002622:	48 6c       	lddpc	r12,80002638 <spk_reply_func+0x34>
80002624:	f0 1f 00 06 	mcall	8000263c <spk_reply_func+0x38>
80002628:	2f fd       	sub	sp,-4
8000262a:	d8 02       	popm	pc
		
	}
	else
	{
		log("spk error");
8000262c:	48 5c       	lddpc	r12,80002640 <spk_reply_func+0x3c>
8000262e:	f0 1f 00 04 	mcall	8000263c <spk_reply_func+0x38>
80002632:	d8 02       	popm	pc
80002634:	00 00       	add	r0,r0
80002636:	0a 49       	or	r9,r5
80002638:	80 00       	ld.sh	r0,r0[0x0]
8000263a:	c7 98       	rjmp	8000272c <dcm_brdcst_func+0xc>
8000263c:	80 00       	ld.sh	r0,r0[0x0]
8000263e:	61 90       	ld.w	r0,r0[0x64]
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	c7 a8       	rjmp	80002736 <dcm_brdcst_func+0x16>

80002644 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002644:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002648:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
8000264c:	0f a9       	ld.ub	r9,r7[0x2]
8000264e:	30 08       	mov	r8,0
80002650:	f0 09 18 00 	cp.b	r9,r8
80002654:	c0 71       	brne	80002662 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002656:	48 ac       	lddpc	r12,8000267c <mic_brdcst_func+0x38>
80002658:	f0 1f 00 0a 	mcall	80002680 <mic_brdcst_func+0x3c>
		Mic_is_Enabled = 0;
8000265c:	30 09       	mov	r9,0
8000265e:	48 a8       	lddpc	r8,80002684 <mic_brdcst_func+0x40>
80002660:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002662:	0f a9       	ld.ub	r9,r7[0x2]
80002664:	31 18       	mov	r8,17
80002666:	f0 09 18 00 	cp.b	r9,r8
8000266a:	c0 71       	brne	80002678 <mic_brdcst_func+0x34>
	{
		log("\n\r Mic_Enabled \n\r");	
8000266c:	48 7c       	lddpc	r12,80002688 <mic_brdcst_func+0x44>
8000266e:	f0 1f 00 05 	mcall	80002680 <mic_brdcst_func+0x3c>
		Mic_is_Enabled = 1;
80002672:	30 19       	mov	r9,1
80002674:	48 48       	lddpc	r8,80002684 <mic_brdcst_func+0x40>
80002676:	b0 89       	st.b	r8[0x0],r9
80002678:	e3 cd 80 80 	ldm	sp++,r7,pc
8000267c:	80 00       	ld.sh	r0,r0[0x0]
8000267e:	c7 b4       	brge	80002774 <dcm_reply_func+0xc>
80002680:	80 00       	ld.sh	r0,r0[0x0]
80002682:	61 90       	ld.w	r0,r0[0x64]
80002684:	00 00       	add	r0,r0
80002686:	0a 4a       	or	r10,r5
80002688:	80 00       	ld.sh	r0,r0[0x0]
8000268a:	c7 c8       	rjmp	80002782 <dcm_reply_func+0x1a>

8000268c <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
8000268c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002690:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002694:	49 ac       	lddpc	r12,800026fc <mic_reply_func+0x70>
80002696:	f0 1f 00 1b 	mcall	80002700 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000269a:	0f 89       	ld.ub	r9,r7[0x0]
8000269c:	30 08       	mov	r8,0
8000269e:	f0 09 18 00 	cp.b	r9,r8
800026a2:	c2 71       	brne	800026f0 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800026a4:	0f 98       	ld.ub	r8,r7[0x1]
800026a6:	30 29       	mov	r9,2
800026a8:	f2 08 18 00 	cp.b	r8,r9
800026ac:	c1 b1       	brne	800026e2 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800026ae:	49 6c       	lddpc	r12,80002704 <mic_reply_func+0x78>
800026b0:	f0 1f 00 14 	mcall	80002700 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800026b4:	0f a8       	ld.ub	r8,r7[0x2]
800026b6:	1a d8       	st.w	--sp,r8
800026b8:	49 4c       	lddpc	r12,80002708 <mic_reply_func+0x7c>
800026ba:	f0 1f 00 12 	mcall	80002700 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800026be:	0f b8       	ld.ub	r8,r7[0x3]
800026c0:	1a d8       	st.w	--sp,r8
800026c2:	49 3c       	lddpc	r12,8000270c <mic_reply_func+0x80>
800026c4:	f0 1f 00 0f 	mcall	80002700 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800026c8:	0f c8       	ld.ub	r8,r7[0x4]
800026ca:	1a d8       	st.w	--sp,r8
800026cc:	49 1c       	lddpc	r12,80002710 <mic_reply_func+0x84>
800026ce:	f0 1f 00 0d 	mcall	80002700 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800026d2:	0f d8       	ld.ub	r8,r7[0x5]
800026d4:	1a d8       	st.w	--sp,r8
800026d6:	49 0c       	lddpc	r12,80002714 <mic_reply_func+0x88>
800026d8:	f0 1f 00 0a 	mcall	80002700 <mic_reply_func+0x74>
800026dc:	2f cd       	sub	sp,-16
800026de:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026e2:	1a d8       	st.w	--sp,r8
800026e4:	48 dc       	lddpc	r12,80002718 <mic_reply_func+0x8c>
800026e6:	f0 1f 00 07 	mcall	80002700 <mic_reply_func+0x74>
800026ea:	2f fd       	sub	sp,-4
800026ec:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026f0:	48 bc       	lddpc	r12,8000271c <mic_reply_func+0x90>
800026f2:	f0 1f 00 04 	mcall	80002700 <mic_reply_func+0x74>
800026f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026fa:	00 00       	add	r0,r0
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	c7 dc       	rcall	800027f8 <app_cfg>
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	61 90       	ld.w	r0,r0[0x64]
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	c7 ec       	rcall	80002802 <app_cfg+0xa>
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	c8 00       	breq	8000260a <spk_reply_func+0x6>
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	c8 14       	brge	80002610 <spk_reply_func+0xc>
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	c8 30       	breq	80002618 <spk_reply_func+0x14>
80002714:	80 00       	ld.sh	r0,r0[0x0]
80002716:	c8 48       	rjmp	8000281e <app_cfg+0x26>
80002718:	80 00       	ld.sh	r0,r0[0x0]
8000271a:	c8 60       	breq	80002626 <spk_reply_func+0x22>
8000271c:	80 00       	ld.sh	r0,r0[0x0]
8000271e:	c8 78       	rjmp	8000282c <app_cfg+0x34>

80002720 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002720:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002724:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002728:	48 bc       	lddpc	r12,80002754 <dcm_brdcst_func+0x34>
8000272a:	f0 1f 00 0c 	mcall	80002758 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000272e:	0f 88       	ld.ub	r8,r7[0x0]
80002730:	1a d8       	st.w	--sp,r8
80002732:	48 bc       	lddpc	r12,8000275c <dcm_brdcst_func+0x3c>
80002734:	f0 1f 00 09 	mcall	80002758 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002738:	0f a8       	ld.ub	r8,r7[0x2]
8000273a:	1a d8       	st.w	--sp,r8
8000273c:	48 9c       	lddpc	r12,80002760 <dcm_brdcst_func+0x40>
8000273e:	f0 1f 00 07 	mcall	80002758 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002742:	0f 98       	ld.ub	r8,r7[0x1]
80002744:	1a d8       	st.w	--sp,r8
80002746:	48 8c       	lddpc	r12,80002764 <dcm_brdcst_func+0x44>
80002748:	f0 1f 00 04 	mcall	80002758 <dcm_brdcst_func+0x38>
8000274c:	2f dd       	sub	sp,-12
	
	
}
8000274e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002752:	00 00       	add	r0,r0
80002754:	80 00       	ld.sh	r0,r0[0x0]
80002756:	c8 88       	rjmp	80002866 <app_cfg+0x6e>
80002758:	80 00       	ld.sh	r0,r0[0x0]
8000275a:	61 90       	ld.w	r0,r0[0x64]
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	c8 9c       	rcall	80002870 <app_cfg+0x78>
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	c8 b0       	breq	80002678 <mic_brdcst_func+0x34>
80002764:	80 00       	ld.sh	r0,r0[0x0]
80002766:	c8 c8       	rjmp	8000287e <app_cfg+0x86>

80002768 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002768:	eb cd 40 80 	pushm	r7,lr
8000276c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000276e:	19 a9       	ld.ub	r9,r12[0x2]
80002770:	30 08       	mov	r8,0
80002772:	f0 09 18 00 	cp.b	r9,r8
80002776:	c1 b1       	brne	800027ac <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002778:	19 b8       	ld.ub	r8,r12[0x3]
8000277a:	30 19       	mov	r9,1
8000277c:	f2 08 18 00 	cp.b	r8,r9
80002780:	c0 51       	brne	8000278a <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002782:	48 ec       	lddpc	r12,800027b8 <dcm_reply_func+0x50>
80002784:	f0 1f 00 0e 	mcall	800027bc <dcm_reply_func+0x54>
80002788:	c0 a8       	rjmp	8000279c <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000278a:	58 08       	cp.w	r8,0
8000278c:	c0 51       	brne	80002796 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
8000278e:	48 dc       	lddpc	r12,800027c0 <dcm_reply_func+0x58>
80002790:	f0 1f 00 0b 	mcall	800027bc <dcm_reply_func+0x54>
80002794:	c0 48       	rjmp	8000279c <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
80002796:	48 cc       	lddpc	r12,800027c4 <dcm_reply_func+0x5c>
80002798:	f0 1f 00 09 	mcall	800027bc <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
8000279c:	0f d8       	ld.ub	r8,r7[0x5]
8000279e:	1a d8       	st.w	--sp,r8
800027a0:	48 ac       	lddpc	r12,800027c8 <dcm_reply_func+0x60>
800027a2:	f0 1f 00 07 	mcall	800027bc <dcm_reply_func+0x54>
800027a6:	2f fd       	sub	sp,-4
800027a8:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800027ac:	48 8c       	lddpc	r12,800027cc <dcm_reply_func+0x64>
800027ae:	f0 1f 00 04 	mcall	800027bc <dcm_reply_func+0x54>
800027b2:	e3 cd 80 80 	ldm	sp++,r7,pc
800027b6:	00 00       	add	r0,r0
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	c8 e4       	brge	800026d6 <mic_reply_func+0x4a>
800027bc:	80 00       	ld.sh	r0,r0[0x0]
800027be:	61 90       	ld.w	r0,r0[0x64]
800027c0:	80 00       	ld.sh	r0,r0[0x0]
800027c2:	c8 f8       	rjmp	800028e0 <app_payload_rx_proc+0x30>
800027c4:	80 00       	ld.sh	r0,r0[0x0]
800027c6:	c9 0c       	rcall	800028e6 <app_payload_rx_proc+0x36>
800027c8:	80 00       	ld.sh	r0,r0[0x0]
800027ca:	c9 20       	breq	800026ee <mic_reply_func+0x62>
800027cc:	80 00       	ld.sh	r0,r0[0x0]
800027ce:	c9 2c       	rcall	800028f2 <app_payload_rx_proc+0x42>

800027d0 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800027d0:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800027d2:	19 a9       	ld.ub	r9,r12[0x2]
800027d4:	30 08       	mov	r8,0
800027d6:	f0 09 18 00 	cp.b	r9,r8
800027da:	c0 51       	brne	800027e4 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
800027dc:	48 4c       	lddpc	r12,800027ec <ToneControl_reply_func+0x1c>
800027de:	f0 1f 00 05 	mcall	800027f0 <ToneControl_reply_func+0x20>
800027e2:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027e4:	48 4c       	lddpc	r12,800027f4 <ToneControl_reply_func+0x24>
800027e6:	f0 1f 00 03 	mcall	800027f0 <ToneControl_reply_func+0x20>
800027ea:	d8 02       	popm	pc
800027ec:	80 00       	ld.sh	r0,r0[0x0]
800027ee:	c9 38       	rjmp	80002914 <AudioRoutingControl_reply_func+0x20>
800027f0:	80 00       	ld.sh	r0,r0[0x0]
800027f2:	61 90       	ld.w	r0,r0[0x64]
800027f4:	80 00       	ld.sh	r0,r0[0x0]
800027f6:	c9 40       	breq	8000271e <mic_reply_func+0x92>

800027f8 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
800027f8:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
800027fa:	f0 1f 00 20 	mcall	80002878 <app_cfg+0x80>
800027fe:	4a 08       	lddpc	r8,8000287c <app_cfg+0x84>
80002800:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
80002802:	4a 07       	lddpc	r7,80002880 <app_cfg+0x88>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
80002804:	4a 06       	lddpc	r6,80002884 <app_cfg+0x8c>
				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				//log("\n\r un: %d \n\r", is_unmute);
				//log("\n\r S_flag: %d \n\r", Silent_flag);
				//log("\n\r Tend_flag: %d \n\r", Terminator_Flag);			
			
				log("\n\r AMBE_Rx_flag: %d \n\r", AMBE_rx_flag);
80002806:	4a 15       	lddpc	r5,80002888 <app_cfg+0x90>
80002808:	4a 14       	lddpc	r4,8000288c <app_cfg+0x94>
				log("\n\r AMBE_Tx_flag: %d \n\r", AMBE_tx_flag);
8000280a:	4a 23       	lddpc	r3,80002890 <app_cfg+0x98>
8000280c:	4a 22       	lddpc	r2,80002894 <app_cfg+0x9c>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
8000280e:	30 30       	mov	r0,3
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
80002810:	30 21       	mov	r1,2
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
80002812:	6e 08       	ld.w	r8,r7[0x0]
80002814:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002818:	58 38       	cp.w	r8,3
8000281a:	c2 91       	brne	8000286c <app_cfg+0x74>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
8000281c:	6c 08       	ld.w	r8,r6[0x0]
8000281e:	58 08       	cp.w	r8,0
80002820:	c0 61       	brne	8000282c <app_cfg+0x34>
				{
					//xcmp_data_session();
					//xcmp_audio_route_mic();
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					xcmp_enter_device_control_mode();//调换3个命令的顺序，则不会导致掉线。。。奇葩
80002822:	f0 1f 00 1e 	mcall	80002898 <app_cfg+0xa0>
					//xcmp_unmute_speaker();
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
80002826:	30 18       	mov	r8,1
80002828:	8d 08       	st.w	r6[0x0],r8
8000282a:	c1 68       	rjmp	80002856 <app_cfg+0x5e>
				}
				else if(isAudioRouting == 1)
8000282c:	58 18       	cp.w	r8,1
8000282e:	c0 51       	brne	80002838 <app_cfg+0x40>
				{
					//xcmp_function_mic();
					//xcmp_data_session();
				    //xcmp_transmit_control();
					//xcmp_volume_control();
					xcmp_enter_enhanced_OB_mode();
80002830:	f0 1f 00 1b 	mcall	8000289c <app_cfg+0xa4>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
80002834:	8d 01       	st.w	r6[0x0],r1
80002836:	c1 08       	rjmp	80002856 <app_cfg+0x5e>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
80002838:	58 28       	cp.w	r8,2
8000283a:	c0 51       	brne	80002844 <app_cfg+0x4c>
				{
					
					xcmp_exit_device_control_mode();
8000283c:	f0 1f 00 19 	mcall	800028a0 <app_cfg+0xa8>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
80002840:	8d 00       	st.w	r6[0x0],r0
80002842:	c0 a8       	rjmp	80002856 <app_cfg+0x5e>
					
				}
				else if(isAudioRouting == 3)
80002844:	58 38       	cp.w	r8,3
80002846:	c0 61       	brne	80002852 <app_cfg+0x5a>
				{
					xcmp_audio_route_AMBE();
80002848:	f0 1f 00 17 	mcall	800028a4 <app_cfg+0xac>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
8000284c:	30 48       	mov	r8,4
8000284e:	8d 08       	st.w	r6[0x0],r8
80002850:	c0 38       	rjmp	80002856 <app_cfg+0x5e>
					
				}
				else
				{
					isAudioRouting++;
80002852:	2f f8       	sub	r8,-1
80002854:	8d 08       	st.w	r6[0x0],r8
				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				//log("\n\r un: %d \n\r", is_unmute);
				//log("\n\r S_flag: %d \n\r", Silent_flag);
				//log("\n\r Tend_flag: %d \n\r", Terminator_Flag);			
			
				log("\n\r AMBE_Rx_flag: %d \n\r", AMBE_rx_flag);
80002856:	09 88       	ld.ub	r8,r4[0x0]
80002858:	1a d8       	st.w	--sp,r8
8000285a:	0a 9c       	mov	r12,r5
8000285c:	f0 1f 00 13 	mcall	800028a8 <app_cfg+0xb0>
				log("\n\r AMBE_Tx_flag: %d \n\r", AMBE_tx_flag);
80002860:	05 88       	ld.ub	r8,r2[0x0]
80002862:	1a d8       	st.w	--sp,r8
80002864:	06 9c       	mov	r12,r3
80002866:	f0 1f 00 11 	mcall	800028a8 <app_cfg+0xb0>
8000286a:	2f ed       	sub	sp,-8
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以2000ms为周期执行。
8000286c:	e0 6b 0f a0 	mov	r11,4000
80002870:	48 3c       	lddpc	r12,8000287c <app_cfg+0x84>
80002872:	f0 1f 00 0f 	mcall	800028ac <app_cfg+0xb4>
	}
80002876:	cc eb       	rjmp	80002812 <app_cfg+0x1a>
80002878:	80 00       	ld.sh	r0,r0[0x0]
8000287a:	5b 04       	cp.w	r4,-16
8000287c:	00 00       	add	r0,r0
8000287e:	0a 38       	cp.w	r8,r5
80002880:	00 00       	add	r0,r0
80002882:	0d 90       	ld.ub	r0,r6[0x1]
80002884:	00 00       	add	r0,r0
80002886:	0a 4c       	or	r12,r5
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	c9 4c       	rcall	800029b2 <payload_init+0x1a>
8000288c:	00 00       	add	r0,r0
8000288e:	0a 3c       	cp.w	r12,r5
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	c9 64       	brge	800027be <dcm_reply_func+0x56>
80002894:	00 00       	add	r0,r0
80002896:	0a 44       	or	r4,r5
80002898:	80 00       	ld.sh	r0,r0[0x0]
8000289a:	3e 08       	mov	r8,-32
8000289c:	80 00       	ld.sh	r0,r0[0x0]
8000289e:	3e 94       	mov	r4,-23
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	3d d8       	mov	r8,-35
800028a4:	80 00       	ld.sh	r0,r0[0x0]
800028a6:	3e 34       	mov	r4,-29
800028a8:	80 00       	ld.sh	r0,r0[0x0]
800028aa:	61 90       	ld.w	r0,r0[0x64]
800028ac:	80 00       	ld.sh	r0,r0[0x0]
800028ae:	5c 6c       	casts.b	r12

800028b0 <app_payload_rx_proc>:
}


static void app_payload_rx_proc(void  * payload)
{
800028b0:	eb cd 40 80 	pushm	r7,lr
800028b4:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
800028b6:	48 b9       	lddpc	r9,800028e0 <app_payload_rx_proc+0x30>
800028b8:	13 88       	ld.ub	r8,r9[0x0]
800028ba:	2f f8       	sub	r8,-1
800028bc:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800028be:	30 39       	mov	r9,3
800028c0:	f2 08 18 00 	cp.b	r8,r9
800028c4:	c0 71       	brne	800028d2 <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
800028c6:	30 09       	mov	r9,0
800028c8:	48 68       	lddpc	r8,800028e0 <app_payload_rx_proc+0x30>
800028ca:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800028cc:	48 6c       	lddpc	r12,800028e4 <app_payload_rx_proc+0x34>
800028ce:	f0 1f 00 07 	mcall	800028e8 <app_payload_rx_proc+0x38>
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
800028d2:	48 78       	lddpc	r8,800028ec <app_payload_rx_proc+0x3c>
800028d4:	70 0c       	ld.w	r12,r8[0x0]
800028d6:	0e 9b       	mov	r11,r7
800028d8:	f0 1f 00 06 	mcall	800028f0 <app_payload_rx_proc+0x40>

}
800028dc:	e3 cd 80 80 	ldm	sp++,r7,pc
800028e0:	00 00       	add	r0,r0
800028e2:	0a 46       	or	r6,r5
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	c9 7c       	rcall	80002a14 <payload_rx_process+0x44>
800028e8:	80 00       	ld.sh	r0,r0[0x0]
800028ea:	61 90       	ld.w	r0,r0[0x64]
800028ec:	00 00       	add	r0,r0
800028ee:	0a 88       	andn	r8,r5
800028f0:	80 00       	ld.sh	r0,r0[0x0]
800028f2:	2a 70       	sub	r0,-89

800028f4 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800028f4:	eb cd 40 80 	pushm	r7,lr
800028f8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800028fa:	19 a9       	ld.ub	r9,r12[0x2]
800028fc:	30 08       	mov	r8,0
800028fe:	f0 09 18 00 	cp.b	r9,r8
80002902:	c0 c1       	brne	8000291a <AudioRoutingControl_reply_func+0x26>
	{
		log("AudioRouting OK");
80002904:	48 bc       	lddpc	r12,80002930 <AudioRoutingControl_reply_func+0x3c>
80002906:	f0 1f 00 0c 	mcall	80002934 <AudioRoutingControl_reply_func+0x40>
		xcmp_IdleTestTone();//提示通道配置成功
8000290a:	f0 1f 00 0c 	mcall	80002938 <AudioRoutingControl_reply_func+0x44>
		xcmp_IdleTestTone();
8000290e:	f0 1f 00 0b 	mcall	80002938 <AudioRoutingControl_reply_func+0x44>
		xcmp_IdleTestTone();
80002912:	f0 1f 00 0a 	mcall	80002938 <AudioRoutingControl_reply_func+0x44>
80002916:	e3 cd 80 80 	ldm	sp++,r7,pc
		//is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
8000291a:	48 9c       	lddpc	r12,8000293c <AudioRoutingControl_reply_func+0x48>
8000291c:	f0 1f 00 06 	mcall	80002934 <AudioRoutingControl_reply_func+0x40>
		log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
80002920:	0f a8       	ld.ub	r8,r7[0x2]
80002922:	1a d8       	st.w	--sp,r8
80002924:	48 7c       	lddpc	r12,80002940 <AudioRoutingControl_reply_func+0x4c>
80002926:	f0 1f 00 04 	mcall	80002934 <AudioRoutingControl_reply_func+0x40>
8000292a:	2f fd       	sub	sp,-4
8000292c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002930:	80 00       	ld.sh	r0,r0[0x0]
80002932:	c9 88       	rjmp	80002a62 <phy_rx+0x2a>
80002934:	80 00       	ld.sh	r0,r0[0x0]
80002936:	61 90       	ld.w	r0,r0[0x64]
80002938:	80 00       	ld.sh	r0,r0[0x0]
8000293a:	3f 64       	mov	r4,-10
8000293c:	80 00       	ld.sh	r0,r0[0x0]
8000293e:	c9 98       	rjmp	80002a70 <set_idle_store>
80002940:	80 00       	ld.sh	r0,r0[0x0]
80002942:	c9 ac       	rcall	80002a76 <set_idle_store+0x6>

80002944 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002944:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002946:	19 e8       	ld.ub	r8,r12[0x6]
80002948:	30 19       	mov	r9,1
8000294a:	f2 08 18 00 	cp.b	r8,r9
8000294e:	c0 61       	brne	8000295a <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002950:	48 98       	lddpc	r8,80002974 <DeviceInitializationStatus_brdcst_func+0x30>
80002952:	70 09       	ld.w	r9,r8[0x0]
80002954:	a1 a9       	sbr	r9,0x0
80002956:	91 09       	st.w	r8[0x0],r9
80002958:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
8000295a:	30 29       	mov	r9,2
8000295c:	f2 08 18 00 	cp.b	r8,r9
80002960:	c0 80       	breq	80002970 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002962:	48 58       	lddpc	r8,80002974 <DeviceInitializationStatus_brdcst_func+0x30>
80002964:	70 09       	ld.w	r9,r8[0x0]
80002966:	e0 19 ff fc 	andl	r9,0xfffc
8000296a:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
8000296c:	f0 1f 00 03 	mcall	80002978 <DeviceInitializationStatus_brdcst_func+0x34>
80002970:	d8 02       	popm	pc
80002972:	00 00       	add	r0,r0
80002974:	00 00       	add	r0,r0
80002976:	0d 90       	ld.ub	r0,r6[0x1]
80002978:	80 00       	ld.sh	r0,r0[0x0]
8000297a:	3e b8       	mov	r8,-21

8000297c <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
8000297c:	20 1c       	sub	r12,1
8000297e:	5c 5c       	castu.b	r12
80002980:	31 18       	mov	r8,17
80002982:	f0 0c 18 00 	cp.b	r12,r8
80002986:	e0 88 00 03 	brls	8000298c <CalculateBurst+0x10>
8000298a:	5e fd       	retal	0
8000298c:	48 28       	lddpc	r8,80002994 <CalculateBurst+0x18>
8000298e:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002992:	5e fc       	retal	r12
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	c9 cc       	rcall	80002ace <phy_tx+0x3e>

80002998 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80002998:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
8000299a:	48 98       	lddpc	r8,800029bc <payload_init+0x24>
8000299c:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
8000299e:	48 98       	lddpc	r8,800029c0 <payload_init+0x28>
800029a0:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800029a2:	30 09       	mov	r9,0
800029a4:	1a d9       	st.w	--sp,r9
800029a6:	1a d9       	st.w	--sp,r9
800029a8:	1a d9       	st.w	--sp,r9
800029aa:	30 28       	mov	r8,2
800029ac:	e0 6a 04 00 	mov	r10,1024
800029b0:	48 5b       	lddpc	r11,800029c4 <payload_init+0x2c>
800029b2:	48 6c       	lddpc	r12,800029c8 <payload_init+0x30>
800029b4:	f0 1f 00 06 	mcall	800029cc <payload_init+0x34>
800029b8:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
800029ba:	d8 02       	popm	pc
800029bc:	00 00       	add	r0,r0
800029be:	0a 54       	eor	r4,r5
800029c0:	00 00       	add	r0,r0
800029c2:	0a 58       	eor	r8,r5
800029c4:	80 00       	ld.sh	r0,r0[0x0]
800029c6:	cf c4       	brge	800029be <payload_init+0x26>
800029c8:	80 00       	ld.sh	r0,r0[0x0]
800029ca:	29 d0       	sub	r0,-99
800029cc:	80 00       	ld.sh	r0,r0[0x0]
800029ce:	5d cc       	*unknown*

800029d0 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
800029d0:	eb cd 40 f8 	pushm	r3-r7,lr
800029d4:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
800029d6:	48 e8       	lddpc	r8,80002a0c <payload_rx_process+0x3c>
800029d8:	70 08       	ld.w	r8,r8[0x0]
800029da:	58 08       	cp.w	r8,0
800029dc:	c0 71       	brne	800029ea <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
800029de:	30 4b       	mov	r11,4
800029e0:	30 5c       	mov	r12,5
800029e2:	f0 1f 00 0c 	mcall	80002a10 <payload_rx_process+0x40>
800029e6:	48 a8       	lddpc	r8,80002a0c <payload_rx_process+0x3c>
800029e8:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
800029ea:	48 96       	lddpc	r6,80002a0c <payload_rx_process+0x3c>
800029ec:	30 05       	mov	r5,0
800029ee:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
800029f0:	48 93       	lddpc	r3,80002a14 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
800029f2:	6c 0c       	ld.w	r12,r6[0x0]
800029f4:	0a 99       	mov	r9,r5
800029f6:	08 9a       	mov	r10,r4
800029f8:	1a 9b       	mov	r11,sp
800029fa:	f0 1f 00 08 	mcall	80002a18 <payload_rx_process+0x48>
800029fe:	58 1c       	cp.w	r12,1
80002a00:	cf 91       	brne	800029f2 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002a02:	66 08       	ld.w	r8,r3[0x0]
80002a04:	40 0c       	lddsp	r12,sp[0x0]
80002a06:	5d 18       	icall	r8
80002a08:	cf 5b       	rjmp	800029f2 <payload_rx_process+0x22>
80002a0a:	00 00       	add	r0,r0
80002a0c:	00 00       	add	r0,r0
80002a0e:	0a 74       	tst	r4,r5
80002a10:	80 00       	ld.sh	r0,r0[0x0]
80002a12:	56 f8       	stdsp	sp[0x1bc],r8
80002a14:	00 00       	add	r0,r0
80002a16:	0a 54       	eor	r4,r5
80002a18:	80 00       	ld.sh	r0,r0[0x0]
80002a1a:	53 94       	stdsp	sp[0xe4],r4

80002a1c <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002a1c:	d4 01       	pushm	lr
80002a1e:	20 2d       	sub	sp,8
80002a20:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a22:	30 09       	mov	r9,0
80002a24:	fa ca ff f8 	sub	r10,sp,-8
80002a28:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002a2a:	1a 9b       	mov	r11,sp
80002a2c:	f0 1f 00 02 	mcall	80002a34 <set_idle_store_isr+0x18>
}
80002a30:	2f ed       	sub	sp,-8
80002a32:	d8 02       	popm	pc
80002a34:	80 00       	ld.sh	r0,r0[0x0]
80002a36:	55 50       	stdsp	sp[0x154],r0

80002a38 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002a38:	d4 01       	pushm	lr
80002a3a:	20 2d       	sub	sp,8
80002a3c:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002a3e:	58 0c       	cp.w	r12,0
80002a40:	c1 10       	breq	80002a62 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a42:	30 08       	mov	r8,0
80002a44:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002a46:	98 88       	ld.uh	r8,r12[0x0]
80002a48:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a4c:	e0 48 40 00 	cp.w	r8,16384
80002a50:	c0 91       	brne	80002a62 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002a52:	48 68       	lddpc	r8,80002a68 <phy_rx+0x30>
80002a54:	70 0c       	ld.w	r12,r8[0x0]
80002a56:	30 09       	mov	r9,0
80002a58:	fa ca ff fc 	sub	r10,sp,-4
80002a5c:	1a 9b       	mov	r11,sp
80002a5e:	f0 1f 00 04 	mcall	80002a6c <phy_rx+0x34>
		}	

    }
		
 
}
80002a62:	2f ed       	sub	sp,-8
80002a64:	d8 02       	popm	pc
80002a66:	00 00       	add	r0,r0
80002a68:	00 00       	add	r0,r0
80002a6a:	0a ac       	st.w	r5++,r12
80002a6c:	80 00       	ld.sh	r0,r0[0x0]
80002a6e:	55 50       	stdsp	sp[0x154],r0

80002a70 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002a70:	eb cd 40 80 	pushm	r7,lr
80002a74:	20 1d       	sub	sp,4
80002a76:	fa c7 ff fc 	sub	r7,sp,-4
80002a7a:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002a7c:	30 09       	mov	r9,0
80002a7e:	12 9a       	mov	r10,r9
80002a80:	1a 9b       	mov	r11,sp
80002a82:	f0 1f 00 03 	mcall	80002a8c <set_idle_store+0x1c>
}
80002a86:	2f fd       	sub	sp,-4
80002a88:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a8c:	80 00       	ld.sh	r0,r0[0x0]
80002a8e:	55 a0       	stdsp	sp[0x168],r0

80002a90 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002a90:	d4 01       	pushm	lr
80002a92:	20 1d       	sub	sp,4
80002a94:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002a96:	98 88       	ld.uh	r8,r12[0x0]
80002a98:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a9c:	e0 48 40 00 	cp.w	r8,16384
80002aa0:	c0 d1       	brne	80002aba <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002aa2:	49 08       	lddpc	r8,80002ae0 <phy_tx+0x50>
80002aa4:	70 08       	ld.w	r8,r8[0x0]
80002aa6:	58 08       	cp.w	r8,0
80002aa8:	c1 a0       	breq	80002adc <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002aaa:	48 e8       	lddpc	r8,80002ae0 <phy_tx+0x50>
80002aac:	70 0c       	ld.w	r12,r8[0x0]
80002aae:	30 09       	mov	r9,0
80002ab0:	12 9a       	mov	r10,r9
80002ab2:	1a 9b       	mov	r11,sp
80002ab4:	f0 1f 00 0c 	mcall	80002ae4 <phy_tx+0x54>
80002ab8:	c1 28       	rjmp	80002adc <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002aba:	e0 48 10 00 	cp.w	r8,4096
80002abe:	5f 0a       	sreq	r10
80002ac0:	e0 48 20 00 	cp.w	r8,8192
80002ac4:	5f 09       	sreq	r9
80002ac6:	f5 e9 10 09 	or	r9,r10,r9
80002aca:	c0 71       	brne	80002ad8 <phy_tx+0x48>
80002acc:	e0 48 50 00 	cp.w	r8,20480
80002ad0:	c0 40       	breq	80002ad8 <phy_tx+0x48>
80002ad2:	e0 48 60 00 	cp.w	r8,24576
80002ad6:	c0 31       	brne	80002adc <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002ad8:	48 48       	lddpc	r8,80002ae8 <phy_tx+0x58>
80002ada:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002adc:	2f fd       	sub	sp,-4
80002ade:	d8 02       	popm	pc
80002ae0:	00 00       	add	r0,r0
80002ae2:	0a b8       	st.h	r5++,r8
80002ae4:	80 00       	ld.sh	r0,r0[0x0]
80002ae6:	55 a0       	stdsp	sp[0x168],r0
80002ae8:	00 00       	add	r0,r0
80002aea:	0a a8       	st.w	r5++,r8

80002aec <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002aec:	d4 01       	pushm	lr
80002aee:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002af0:	30 08       	mov	r8,0
80002af2:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002af4:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002af6:	1a 9a       	mov	r10,sp
80002af8:	fa cb ff fc 	sub	r11,sp,-4
80002afc:	f0 1f 00 05 	mcall	80002b10 <get_idle_store_isr+0x24>
80002b00:	58 1c       	cp.w	r12,1
80002b02:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002b06:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002b0a:	2f ed       	sub	sp,-8
80002b0c:	d8 02       	popm	pc
80002b0e:	00 00       	add	r0,r0
80002b10:	80 00       	ld.sh	r0,r0[0x0]
80002b12:	52 a4       	stdsp	sp[0xa8],r4

80002b14 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002b14:	eb cd 40 c0 	pushm	r6-r7,lr
80002b18:	20 1d       	sub	sp,4
80002b1a:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002b1c:	fe f8 03 8c 	ld.w	r8,pc[908]
80002b20:	70 08       	ld.w	r8,r8[0x0]
80002b22:	58 08       	cp.w	r8,0
80002b24:	c7 40       	breq	80002c0c <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002b26:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b28:	30 08       	mov	r8,0
80002b2a:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002b2c:	fe f8 03 80 	ld.w	r8,pc[896]
80002b30:	70 08       	ld.w	r8,r8[0x0]
80002b32:	58 18       	cp.w	r8,1
80002b34:	c2 90       	breq	80002b86 <phy_tx_func+0x72>
80002b36:	c0 43       	brcs	80002b3e <phy_tx_func+0x2a>
80002b38:	58 28       	cp.w	r8,2
80002b3a:	c6 91       	brne	80002c0c <phy_tx_func+0xf8>
80002b3c:	c6 18       	rjmp	80002bfe <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002b3e:	fe f8 03 6a 	ld.w	r8,pc[874]
80002b42:	70 0c       	ld.w	r12,r8[0x0]
80002b44:	1a 9a       	mov	r10,sp
80002b46:	fe fb 03 6a 	ld.w	r11,pc[874]
80002b4a:	f0 1f 00 db 	mcall	80002eb4 <phy_tx_func+0x3a0>
80002b4e:	58 1c       	cp.w	r12,1
80002b50:	c1 51       	brne	80002b7a <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002b52:	fe f8 03 5e 	ld.w	r8,pc[862]
80002b56:	70 08       	ld.w	r8,r8[0x0]
80002b58:	11 9a       	ld.ub	r10,r8[0x1]
80002b5a:	fe f9 03 5e 	ld.w	r9,pc[862]
80002b5e:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002b60:	90 88       	ld.uh	r8,r8[0x0]
80002b62:	ea 18 ab cd 	orh	r8,0xabcd
80002b66:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002b68:	30 19       	mov	r9,1
80002b6a:	fe f8 03 52 	ld.w	r8,pc[850]
80002b6e:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002b70:	30 19       	mov	r9,1
80002b72:	fe f8 03 3a 	ld.w	r8,pc[826]
80002b76:	91 09       	st.w	r8[0x0],r9
80002b78:	c4 a8       	rjmp	80002c0c <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002b7a:	e0 68 5a 5a 	mov	r8,23130
80002b7e:	ea 18 ab cd 	orh	r8,0xabcd
80002b82:	8f 18       	st.w	r7[0x4],r8
80002b84:	c4 48       	rjmp	80002c0c <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b86:	fe f9 03 36 	ld.w	r9,pc[822]
80002b8a:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002b8c:	fe fa 03 24 	ld.w	r10,pc[804]
80002b90:	74 0a       	ld.w	r10,r10[0x0]
80002b92:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002b96:	b1 6a       	lsl	r10,0x10
80002b98:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b9a:	2f f8       	sub	r8,-1
80002b9c:	5c 58       	castu.b	r8
80002b9e:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002ba0:	fe fa 03 18 	ld.w	r10,pc[792]
80002ba4:	94 09       	ld.sh	r9,r10[0x0]
80002ba6:	20 29       	sub	r9,2
80002ba8:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002baa:	30 0a       	mov	r10,0
80002bac:	f4 09 19 00 	cp.h	r9,r10
80002bb0:	e0 89 00 0b 	brgt	80002bc6 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002bb4:	78 18       	ld.w	r8,r12[0x4]
80002bb6:	e8 18 00 ba 	orl	r8,0xba
80002bba:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80002bbc:	30 09       	mov	r9,0
80002bbe:	fe f8 02 ee 	ld.w	r8,pc[750]
80002bc2:	91 09       	st.w	r8[0x0],r9
80002bc4:	c2 48       	rjmp	80002c0c <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002bc6:	fe f9 02 ea 	ld.w	r9,pc[746]
80002bca:	72 09       	ld.w	r9,r9[0x0]
80002bcc:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002bd0:	78 1a       	ld.w	r10,r12[0x4]
80002bd2:	f5 e9 10 09 	or	r9,r10,r9
80002bd6:	99 19       	st.w	r12[0x4],r9
80002bd8:	2f f8       	sub	r8,-1
80002bda:	fe f9 02 e2 	ld.w	r9,pc[738]
80002bde:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002be0:	fe f9 02 d8 	ld.w	r9,pc[728]
80002be4:	92 08       	ld.sh	r8,r9[0x0]
80002be6:	20 28       	sub	r8,2
80002be8:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002bea:	30 09       	mov	r9,0
80002bec:	f2 08 19 00 	cp.h	r8,r9
80002bf0:	e0 89 00 0e 	brgt	80002c0c <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002bf4:	30 29       	mov	r9,2
80002bf6:	fe f8 02 b6 	ld.w	r8,pc[694]
80002bfa:	91 09       	st.w	r8[0x0],r9
80002bfc:	c0 88       	rjmp	80002c0c <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002bfe:	fc 18 00 ba 	movh	r8,0xba
80002c02:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002c04:	30 09       	mov	r9,0
80002c06:	fe f8 02 a6 	ld.w	r8,pc[678]
80002c0a:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80002c0c:	fe f8 02 b4 	ld.w	r8,pc[692]
80002c10:	11 89       	ld.ub	r9,r8[0x0]
80002c12:	30 18       	mov	r8,1
80002c14:	f0 09 18 00 	cp.b	r9,r8
80002c18:	e0 81 01 3e 	brne	80002e94 <phy_tx_func+0x380>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80002c1c:	fe f8 02 a8 	ld.w	r8,pc[680]
80002c20:	70 08       	ld.w	r8,r8[0x0]
80002c22:	e0 48 05 b0 	cp.w	r8,1456
80002c26:	f9 b8 02 00 	movhs	r8,0
80002c2a:	fe f9 02 9a 	ld.w	r9,pc[666]
80002c2e:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80002c30:	fe f9 02 98 	ld.w	r9,pc[664]
80002c34:	72 09       	ld.w	r9,r9[0x0]
80002c36:	58 29       	cp.w	r9,2
80002c38:	e0 80 00 89 	breq	80002d4a <phy_tx_func+0x236>
80002c3c:	e0 8b 00 08 	brhi	80002c4c <phy_tx_func+0x138>
80002c40:	58 09       	cp.w	r9,0
80002c42:	c0 e0       	breq	80002c5e <phy_tx_func+0x14a>
80002c44:	58 19       	cp.w	r9,1
80002c46:	e0 81 01 1d 	brne	80002e80 <phy_tx_func+0x36c>
80002c4a:	c5 28       	rjmp	80002cee <phy_tx_func+0x1da>
80002c4c:	58 49       	cp.w	r9,4
80002c4e:	e0 80 00 b0 	breq	80002dae <phy_tx_func+0x29a>
80002c52:	e0 83 00 8f 	brlo	80002d70 <phy_tx_func+0x25c>
80002c56:	58 59       	cp.w	r9,5
80002c58:	e0 81 01 14 	brne	80002e80 <phy_tx_func+0x36c>
80002c5c:	c0 79       	rjmp	80002e6a <phy_tx_func+0x356>
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80002c5e:	fe f8 02 6e 	ld.w	r8,pc[622]
80002c62:	70 08       	ld.w	r8,r8[0x0]
80002c64:	58 08       	cp.w	r8,0
80002c66:	c0 b0       	breq	80002c7c <phy_tx_func+0x168>
80002c68:	fe f8 02 64 	ld.w	r8,pc[612]
80002c6c:	70 08       	ld.w	r8,r8[0x0]
80002c6e:	58 a8       	cp.w	r8,10
80002c70:	c0 60       	breq	80002c7c <phy_tx_func+0x168>
80002c72:	fe f8 02 5a 	ld.w	r8,pc[602]
80002c76:	70 08       	ld.w	r8,r8[0x0]
80002c78:	58 18       	cp.w	r8,1
80002c7a:	c0 91       	brne	80002c8c <phy_tx_func+0x178>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002c7c:	e0 68 5a 5a 	mov	r8,23130
80002c80:	ea 18 ab cd 	orh	r8,0xabcd
80002c84:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002c86:	30 08       	mov	r8,0
80002c88:	8f 38       	st.w	r7[0xc],r8
80002c8a:	c0 c9       	rjmp	80002ea2 <phy_tx_func+0x38e>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80002c8c:	fe f8 02 40 	ld.w	r8,pc[576]
80002c90:	70 08       	ld.w	r8,r8[0x0]
80002c92:	58 38       	cp.w	r8,3
80002c94:	c0 81       	brne	80002ca4 <phy_tx_func+0x190>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80002c96:	fe f8 02 3a 	ld.w	r8,pc[570]
80002c9a:	70 09       	ld.w	r9,r8[0x0]
80002c9c:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80002c9e:	70 18       	ld.w	r8,r8[0x4]
80002ca0:	8f 38       	st.w	r7[0xc],r8
80002ca2:	c0 09       	rjmp	80002ea2 <phy_tx_func+0x38e>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 3 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
80002ca4:	fe f8 02 28 	ld.w	r8,pc[552]
80002ca8:	70 08       	ld.w	r8,r8[0x0]
80002caa:	58 28       	cp.w	r8,2
80002cac:	c1 21       	brne	80002cd0 <phy_tx_func+0x1bc>
					{
						//0xABCDCO14
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//20bytes
80002cae:	e0 68 c0 14 	mov	r8,49172
80002cb2:	ea 18 ab cd 	orh	r8,0xabcd
80002cb6:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80002cb8:	fe 78 84 7f 	mov	r8,-31617
80002cbc:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80002cbe:	fe f8 02 16 	ld.w	r8,pc[534]
80002cc2:	90 08       	ld.sh	r8,r8[0x0]
80002cc4:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80002cc6:	30 39       	mov	r9,3
80002cc8:	fe f8 02 00 	ld.w	r8,pc[512]
80002ccc:	91 09       	st.w	r8[0x0],r9
80002cce:	ce a8       	rjmp	80002ea2 <phy_tx_func+0x38e>
					
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80002cd0:	e0 68 c0 0e 	mov	r8,49166
80002cd4:	ea 18 ab cd 	orh	r8,0xabcd
80002cd8:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80002cda:	fe f8 01 fe 	ld.w	r8,pc[510]
80002cde:	90 09       	ld.sh	r9,r8[0x0]
80002ce0:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80002ce2:	90 18       	ld.sh	r8,r8[0x2]
80002ce4:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80002ce6:	30 19       	mov	r9,1
80002ce8:	4f 88       	lddpc	r8,80002ec8 <phy_tx_func+0x3b4>
80002cea:	91 09       	st.w	r8[0x0],r9
80002cec:	cd b8       	rjmp	80002ea2 <phy_tx_func+0x38e>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80002cee:	fe 78 88 f2 	mov	r8,-30478
80002cf2:	ae 48       	st.h	r7[0x8],r8
				
				payload_tx_channel->word[1] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80002cf4:	4f 48       	lddpc	r8,80002ec4 <phy_tx_func+0x3b0>
80002cf6:	70 0a       	ld.w	r10,r8[0x0]
80002cf8:	4f 99       	lddpc	r9,80002edc <phy_tx_func+0x3c8>
80002cfa:	f2 0a 00 0b 	add	r11,r9,r10
80002cfe:	17 9b       	ld.ub	r11,r11[0x1]
80002d00:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
80002d04:	a9 6a       	lsl	r10,0x8
80002d06:	f6 0a 00 0a 	add	r10,r11,r10
80002d0a:	ae 5a       	st.h	r7[0xa],r10
				A_index+=2;
80002d0c:	70 0a       	ld.w	r10,r8[0x0]
80002d0e:	2f ea       	sub	r10,-2
80002d10:	91 0a       	st.w	r8[0x0],r10
				
				payload_tx_channel->word[2] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80002d12:	f2 0a 00 0b 	add	r11,r9,r10
80002d16:	17 9b       	ld.ub	r11,r11[0x1]
80002d18:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
80002d1c:	a9 6a       	lsl	r10,0x8
80002d1e:	f6 0a 00 0a 	add	r10,r11,r10
80002d22:	ae 6a       	st.h	r7[0xc],r10
				A_index+=2;
80002d24:	70 0a       	ld.w	r10,r8[0x0]
80002d26:	2f ea       	sub	r10,-2
80002d28:	91 0a       	st.w	r8[0x0],r10
				
				payload_tx_channel->word[3] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80002d2a:	f2 0a 00 0b 	add	r11,r9,r10
80002d2e:	17 9b       	ld.ub	r11,r11[0x1]
80002d30:	f2 0a 07 09 	ld.ub	r9,r9[r10]
80002d34:	a9 69       	lsl	r9,0x8
80002d36:	f6 09 00 09 	add	r9,r11,r9
80002d3a:	ae 79       	st.h	r7[0xe],r9
				A_index+=2;
80002d3c:	70 09       	ld.w	r9,r8[0x0]
80002d3e:	2f e9       	sub	r9,-2
80002d40:	91 09       	st.w	r8[0x0],r9
				
				AMBEpayload_tx_state = AMBE_EN_LAST;
80002d42:	30 29       	mov	r9,2
80002d44:	4e 18       	lddpc	r8,80002ec8 <phy_tx_func+0x3b4>
80002d46:	91 09       	st.w	r8[0x0],r9
80002d48:	ca d8       	rjmp	80002ea2 <phy_tx_func+0x38e>
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3]) ^ (AMBEBurst_rawdata[3])) ;
					
					}
					
					***/
					payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
80002d4a:	4e 59       	lddpc	r9,80002edc <phy_tx_func+0x3c8>
80002d4c:	f2 08 07 08 	ld.ub	r8,r9[r8]
80002d50:	a9 68       	lsl	r8,0x8
80002d52:	ae 48       	st.h	r7[0x8],r8
					A_index+=1;
80002d54:	4d c8       	lddpc	r8,80002ec4 <phy_tx_func+0x3b0>
80002d56:	70 09       	ld.w	r9,r8[0x0]
80002d58:	2f f9       	sub	r9,-1
80002d5a:	91 09       	st.w	r8[0x0],r9
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80002d5c:	e0 68 00 ba 	mov	r8,186
80002d60:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002d62:	30 08       	mov	r8,0
80002d64:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002d66:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80002d68:	30 09       	mov	r9,0
80002d6a:	4d 88       	lddpc	r8,80002ec8 <phy_tx_func+0x3b4>
80002d6c:	91 09       	st.w	r8[0x0],r9
80002d6e:	c9 a8       	rjmp	80002ea2 <phy_tx_func+0x38e>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80002d70:	4d 98       	lddpc	r8,80002ed4 <phy_tx_func+0x3c0>
80002d72:	90 18       	ld.sh	r8,r8[0x2]
80002d74:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80002d76:	4d 98       	lddpc	r8,80002ed8 <phy_tx_func+0x3c4>
80002d78:	90 08       	ld.sh	r8,r8[0x0]
80002d7a:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80002d7c:	4d 48       	lddpc	r8,80002ecc <phy_tx_func+0x3b8>
80002d7e:	70 08       	ld.w	r8,r8[0x0]
80002d80:	58 48       	cp.w	r8,4
80002d82:	c0 c1       	brne	80002d9a <phy_tx_func+0x286>
80002d84:	4d 78       	lddpc	r8,80002ee0 <phy_tx_func+0x3cc>
80002d86:	11 89       	ld.ub	r9,r8[0x0]
80002d88:	30 18       	mov	r8,1
80002d8a:	f0 09 18 00 	cp.b	r9,r8
80002d8e:	c0 61       	brne	80002d9a <phy_tx_func+0x286>
					{
						// Vocoder Bits Stream Parameter("E" flag = 1)
						//0xF08x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0080));
80002d90:	4d 28       	lddpc	r8,80002ed8 <phy_tx_func+0x3c4>
80002d92:	90 18       	ld.sh	r8,r8[0x2]
80002d94:	a7 b8       	sbr	r8,0x7
80002d96:	ae 68       	st.h	r7[0xc],r8
80002d98:	c0 48       	rjmp	80002da0 <phy_tx_func+0x28c>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80002d9a:	4d 08       	lddpc	r8,80002ed8 <phy_tx_func+0x3c4>
80002d9c:	90 18       	ld.sh	r8,r8[0x2]
80002d9e:	ae 68       	st.h	r7[0xc],r8
					
					//0x88F3
					payload_tx_channel->word[3] = DECODER_PAYLOAD;
80002da0:	fe 78 88 f3 	mov	r8,-30477
80002da4:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80002da6:	30 49       	mov	r9,4
80002da8:	4c 88       	lddpc	r8,80002ec8 <phy_tx_func+0x3b4>
80002daa:	91 09       	st.w	r8[0x0],r9
80002dac:	c7 b8       	rjmp	80002ea2 <phy_tx_func+0x38e>
					
				break;
			case AMBE_DE_SECOND:
					
				switch (m_RxBurstType)//在发送函数中去做解密处理
80002dae:	4c 88       	lddpc	r8,80002ecc <phy_tx_func+0x3b8>
80002db0:	70 08       	ld.w	r8,r8[0x0]
80002db2:	58 48       	cp.w	r8,4
80002db4:	c0 60       	breq	80002dc0 <phy_tx_func+0x2ac>
80002db6:	c5 03       	brcs	80002e56 <phy_tx_func+0x342>
80002db8:	58 98       	cp.w	r8,9
80002dba:	e0 8b 00 4e 	brhi	80002e56 <phy_tx_func+0x342>
80002dbe:	c3 38       	rjmp	80002e24 <phy_tx_func+0x310>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80002dc0:	4c 88       	lddpc	r8,80002ee0 <phy_tx_func+0x3cc>
80002dc2:	11 89       	ld.ub	r9,r8[0x0]
80002dc4:	30 18       	mov	r8,1
80002dc6:	f0 09 18 00 	cp.b	r9,r8
80002dca:	c1 41       	brne	80002df2 <phy_tx_func+0x2de>
							{	
								//Pick up public key
								
								AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80002dcc:	4c 68       	lddpc	r8,80002ee4 <phy_tx_func+0x3d0>
80002dce:	90 0a       	ld.sh	r10,r8[0x0]
80002dd0:	4c 69       	lddpc	r9,80002ee8 <phy_tx_func+0x3d4>
80002dd2:	b2 0a       	st.h	r9[0x0],r10
								AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80002dd4:	90 1a       	ld.sh	r10,r8[0x2]
80002dd6:	b2 1a       	st.h	r9[0x2],r10
								AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80002dd8:	90 2a       	ld.sh	r10,r8[0x4]
80002dda:	b2 2a       	st.h	r9[0x4],r10
								AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80002ddc:	90 3a       	ld.sh	r10,r8[0x6]
80002dde:	b2 3a       	st.h	r9[0x6],r10
								
								//Post back data
								payload_tx_channel->word[0] = AMBEBurst_rawdata[0] ;
80002de0:	90 09       	ld.sh	r9,r8[0x0]
80002de2:	ae 49       	st.h	r7[0x8],r9
								payload_tx_channel->word[1] = AMBEBurst_rawdata[1] ;
80002de4:	90 19       	ld.sh	r9,r8[0x2]
80002de6:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = AMBEBurst_rawdata[2] ;
80002de8:	90 29       	ld.sh	r9,r8[0x4]
80002dea:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = AMBEBurst_rawdata[3] ;
80002dec:	90 38       	ld.sh	r8,r8[0x6]
80002dee:	ae 78       	st.h	r7[0xe],r8
80002df0:	c1 68       	rjmp	80002e1c <phy_tx_func+0x308>
								
								
						
								//Decrypt AMBE data(XOR) 
								//Recover data
								payload_tx_channel->word[0] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002df2:	4b e9       	lddpc	r9,80002ee8 <phy_tx_func+0x3d4>
80002df4:	92 0a       	ld.sh	r10,r9[0x0]
80002df6:	4b c8       	lddpc	r8,80002ee4 <phy_tx_func+0x3d0>
80002df8:	90 0b       	ld.sh	r11,r8[0x0]
80002dfa:	f7 ea 20 0a 	eor	r10,r11,r10
80002dfe:	ae 4a       	st.h	r7[0x8],r10
								payload_tx_channel->word[1] = ((AMBE_DecryptionKey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002e00:	92 1a       	ld.sh	r10,r9[0x2]
80002e02:	90 1b       	ld.sh	r11,r8[0x2]
80002e04:	f7 ea 20 0a 	eor	r10,r11,r10
80002e08:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((AMBE_DecryptionKey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002e0a:	92 2a       	ld.sh	r10,r9[0x4]
80002e0c:	90 2b       	ld.sh	r11,r8[0x4]
80002e0e:	f7 ea 20 0a 	eor	r10,r11,r10
80002e12:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[3]) ^ (AMBEBurst_rawdata[3])) ;
80002e14:	92 39       	ld.sh	r9,r9[0x6]
80002e16:	90 38       	ld.sh	r8,r8[0x6]
80002e18:	12 58       	eor	r8,r9
80002e1a:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_DE_LAST;
80002e1c:	30 59       	mov	r9,5
80002e1e:	4a b8       	lddpc	r8,80002ec8 <phy_tx_func+0x3b4>
80002e20:	91 09       	st.w	r8[0x0],r9
80002e22:	c4 08       	rjmp	80002ea2 <phy_tx_func+0x38e>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002e24:	4b 19       	lddpc	r9,80002ee8 <phy_tx_func+0x3d4>
80002e26:	92 0a       	ld.sh	r10,r9[0x0]
80002e28:	4a f8       	lddpc	r8,80002ee4 <phy_tx_func+0x3d0>
80002e2a:	90 0b       	ld.sh	r11,r8[0x0]
80002e2c:	f7 ea 20 0a 	eor	r10,r11,r10
80002e30:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = ((AMBE_DecryptionKey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002e32:	92 1a       	ld.sh	r10,r9[0x2]
80002e34:	90 1b       	ld.sh	r11,r8[0x2]
80002e36:	f7 ea 20 0a 	eor	r10,r11,r10
80002e3a:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((AMBE_DecryptionKey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002e3c:	92 2a       	ld.sh	r10,r9[0x4]
80002e3e:	90 2b       	ld.sh	r11,r8[0x4]
80002e40:	f7 ea 20 0a 	eor	r10,r11,r10
80002e44:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((AMBE_DecryptionKey[3]) ^ (AMBEBurst_rawdata[3])) ;
80002e46:	92 39       	ld.sh	r9,r9[0x6]
80002e48:	90 38       	ld.sh	r8,r8[0x6]
80002e4a:	12 58       	eor	r8,r9
80002e4c:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_DE_LAST;
80002e4e:	30 59       	mov	r9,5
80002e50:	49 e8       	lddpc	r8,80002ec8 <phy_tx_func+0x3b4>
80002e52:	91 09       	st.w	r8[0x0],r9
80002e54:	c2 78       	rjmp	80002ea2 <phy_tx_func+0x38e>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e56:	e0 68 5a 5a 	mov	r8,23130
80002e5a:	ea 18 ab cd 	orh	r8,0xabcd
80002e5e:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e60:	30 08       	mov	r8,0
80002e62:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
80002e64:	49 99       	lddpc	r9,80002ec8 <phy_tx_func+0x3b4>
80002e66:	93 08       	st.w	r9[0x0],r8
80002e68:	c1 d8       	rjmp	80002ea2 <phy_tx_func+0x38e>
		
				break;
				
			case AMBE_DE_LAST:
				
					payload_tx_channel->word[0]	= 0x00BA ;
80002e6a:	e0 68 00 ba 	mov	r8,186
80002e6e:	ae 48       	st.h	r7[0x8],r8
					payload_tx_channel->word[1]	= 0x0000 ;
80002e70:	30 08       	mov	r8,0
80002e72:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002e74:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002e76:	ae 78       	st.h	r7[0xe],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;  
80002e78:	30 09       	mov	r9,0
80002e7a:	49 48       	lddpc	r8,80002ec8 <phy_tx_func+0x3b4>
80002e7c:	91 09       	st.w	r8[0x0],r9
80002e7e:	c1 28       	rjmp	80002ea2 <phy_tx_func+0x38e>
				
				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e80:	e0 68 5a 5a 	mov	r8,23130
80002e84:	ea 18 ab cd 	orh	r8,0xabcd
80002e88:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e8a:	30 08       	mov	r8,0
80002e8c:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002e8e:	48 f9       	lddpc	r9,80002ec8 <phy_tx_func+0x3b4>
80002e90:	93 08       	st.w	r9[0x0],r8
80002e92:	c0 88       	rjmp	80002ea2 <phy_tx_func+0x38e>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e94:	e0 68 5a 5a 	mov	r8,23130
80002e98:	ea 18 ab cd 	orh	r8,0xabcd
80002e9c:	8f 28       	st.w	r7[0x8],r8
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e9e:	30 08       	mov	r8,0
80002ea0:	8f 38       	st.w	r7[0xc],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80002ea2:	2f fd       	sub	sp,-4
80002ea4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002ea8:	00 00       	add	r0,r0
80002eaa:	0a b8       	st.h	r5++,r8
80002eac:	00 00       	add	r0,r0
80002eae:	0a b0       	st.h	r5++,r0
80002eb0:	00 00       	add	r0,r0
80002eb2:	0a 7c       	tst	r12,r5
80002eb4:	80 00       	ld.sh	r0,r0[0x0]
80002eb6:	52 a4       	stdsp	sp[0xa8],r4
80002eb8:	00 00       	add	r0,r0
80002eba:	0a 98       	mov	r8,r5
80002ebc:	00 00       	add	r0,r0
80002ebe:	0a 84       	andn	r4,r5
80002ec0:	00 00       	add	r0,r0
80002ec2:	0a 47       	or	r7,r5
80002ec4:	00 00       	add	r0,r0
80002ec6:	0a 78       	tst	r8,r5
80002ec8:	00 00       	add	r0,r0
80002eca:	0a a0       	st.w	r5++,r0
80002ecc:	00 00       	add	r0,r0
80002ece:	0a 68       	and	r8,r5
80002ed0:	00 00       	add	r0,r0
80002ed2:	0a 8c       	andn	r12,r5
80002ed4:	00 00       	add	r0,r0
80002ed6:	0d a4       	ld.ub	r4,r6[0x2]
80002ed8:	00 00       	add	r0,r0
80002eda:	0e a0       	st.w	r7++,r0
80002edc:	80 00       	ld.sh	r0,r0[0x0]
80002ede:	ca 14       	brge	80002e20 <phy_tx_func+0x30c>
80002ee0:	00 00       	add	r0,r0
80002ee2:	0a 48       	or	r8,r5
80002ee4:	00 00       	add	r0,r0
80002ee6:	0d 9c       	ld.ub	r12,r6[0x1]
80002ee8:	00 00       	add	r0,r0
80002eea:	0d a8       	ld.ub	r8,r6[0x2]

80002eec <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002eec:	d4 01       	pushm	lr
80002eee:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002ef0:	30 0a       	mov	r10,0
80002ef2:	fa cb ff fc 	sub	r11,sp,-4
80002ef6:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002ef8:	14 99       	mov	r9,r10
80002efa:	1a 9b       	mov	r11,sp
80002efc:	f0 1f 00 05 	mcall	80002f10 <get_idle_store+0x24>
80002f00:	58 1c       	cp.w	r12,1
80002f02:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002f06:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002f0a:	2f fd       	sub	sp,-4
80002f0c:	d8 02       	popm	pc
80002f0e:	00 00       	add	r0,r0
80002f10:	80 00       	ld.sh	r0,r0[0x0]
80002f12:	53 94       	stdsp	sp[0xe4],r4

80002f14 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002f14:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80002f18:	f0 1f 00 21 	mcall	80002f9c <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002f1c:	4a 1b       	lddpc	r11,80002fa0 <phy_init+0x8c>
80002f1e:	4a 2c       	lddpc	r12,80002fa4 <phy_init+0x90>
80002f20:	f0 1f 00 22 	mcall	80002fa8 <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80002f24:	30 4b       	mov	r11,4
80002f26:	31 ec       	mov	r12,30
80002f28:	f0 1f 00 21 	mcall	80002fac <phy_init+0x98>
80002f2c:	4a 18       	lddpc	r8,80002fb0 <phy_init+0x9c>
80002f2e:	91 0c       	st.w	r8[0x0],r12
80002f30:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80002f32:	10 96       	mov	r6,r8
80002f34:	4a 05       	lddpc	r5,80002fb4 <phy_init+0xa0>
80002f36:	6c 0c       	ld.w	r12,r6[0x0]
80002f38:	ea 07 00 0b 	add	r11,r5,r7
80002f3c:	f0 1f 00 1f 	mcall	80002fb8 <phy_init+0xa4>
80002f40:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80002f44:	e0 47 1e 00 	cp.w	r7,7680
80002f48:	cf 71       	brne	80002f36 <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f4a:	30 4b       	mov	r11,4
80002f4c:	31 4c       	mov	r12,20
80002f4e:	f0 1f 00 18 	mcall	80002fac <phy_init+0x98>
80002f52:	49 b8       	lddpc	r8,80002fbc <phy_init+0xa8>
80002f54:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f56:	30 4b       	mov	r11,4
80002f58:	30 ac       	mov	r12,10
80002f5a:	f0 1f 00 15 	mcall	80002fac <phy_init+0x98>
80002f5e:	49 98       	lddpc	r8,80002fc0 <phy_init+0xac>
80002f60:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80002f62:	30 4b       	mov	r11,4
80002f64:	30 ac       	mov	r12,10
80002f66:	f0 1f 00 12 	mcall	80002fac <phy_init+0x98>
80002f6a:	49 78       	lddpc	r8,80002fc4 <phy_init+0xb0>
80002f6c:	91 0c       	st.w	r8[0x0],r12
80002f6e:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80002f70:	10 96       	mov	r6,r8
80002f72:	49 65       	lddpc	r5,80002fc8 <phy_init+0xb4>
80002f74:	6c 0c       	ld.w	r12,r6[0x0]
80002f76:	ea 07 00 0b 	add	r11,r5,r7
80002f7a:	f0 1f 00 10 	mcall	80002fb8 <phy_init+0xa4>
80002f7e:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80002f82:	e0 47 14 00 	cp.w	r7,5120
80002f86:	cf 71       	brne	80002f74 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
80002f88:	e0 6b 01 00 	mov	r11,256
80002f8c:	30 5c       	mov	r12,5
80002f8e:	f0 1f 00 08 	mcall	80002fac <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
80002f92:	48 f8       	lddpc	r8,80002fcc <phy_init+0xb8>
80002f94:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
80002f96:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002f9a:	00 00       	add	r0,r0
80002f9c:	80 00       	ld.sh	r0,r0[0x0]
80002f9e:	3d 1c       	mov	r12,-47
80002fa0:	80 00       	ld.sh	r0,r0[0x0]
80002fa2:	2b 14       	sub	r4,-79
80002fa4:	80 00       	ld.sh	r0,r0[0x0]
80002fa6:	30 30       	mov	r0,3
80002fa8:	80 00       	ld.sh	r0,r0[0x0]
80002faa:	3d 08       	mov	r8,-48
80002fac:	80 00       	ld.sh	r0,r0[0x0]
80002fae:	56 f8       	stdsp	sp[0x1bc],r8
80002fb0:	00 00       	add	r0,r0
80002fb2:	0a 94       	mov	r4,r5
80002fb4:	00 00       	add	r0,r0
80002fb6:	22 a4       	sub	r4,42
80002fb8:	80 00       	ld.sh	r0,r0[0x0]
80002fba:	2a 70       	sub	r0,-89
80002fbc:	00 00       	add	r0,r0
80002fbe:	0a b8       	st.h	r5++,r8
80002fc0:	00 00       	add	r0,r0
80002fc2:	0a ac       	st.w	r5++,r12
80002fc4:	00 00       	add	r0,r0
80002fc6:	0a 88       	andn	r8,r5
80002fc8:	00 00       	add	r0,r0
80002fca:	0e a4       	st.w	r7++,r4
80002fcc:	00 00       	add	r0,r0
80002fce:	0a a8       	st.w	r5++,r8

80002fd0 <payload_rx>:




static void payload_rx(void * payload)
{
80002fd0:	d4 01       	pushm	lr
80002fd2:	20 2d       	sub	sp,8
80002fd4:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002fd6:	30 08       	mov	r8,0
80002fd8:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
80002fda:	48 f8       	lddpc	r8,80003014 <payload_rx+0x44>
80002fdc:	70 08       	ld.w	r8,r8[0x0]
80002fde:	58 08       	cp.w	r8,0
80002fe0:	c0 71       	brne	80002fee <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80002fe2:	30 4b       	mov	r11,4
80002fe4:	30 5c       	mov	r12,5
80002fe6:	f0 1f 00 0d 	mcall	80003018 <payload_rx+0x48>
80002fea:	48 b8       	lddpc	r8,80003014 <payload_rx+0x44>
80002fec:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80002fee:	48 a8       	lddpc	r8,80003014 <payload_rx+0x44>
80002ff0:	70 0c       	ld.w	r12,r8[0x0]
80002ff2:	30 09       	mov	r9,0
80002ff4:	fa ca ff fc 	sub	r10,sp,-4
80002ff8:	1a 9b       	mov	r11,sp
80002ffa:	f0 1f 00 09 	mcall	8000301c <payload_rx+0x4c>
80002ffe:	c0 91       	brne	80003010 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80003000:	48 88       	lddpc	r8,80003020 <payload_rx+0x50>
80003002:	70 0c       	ld.w	r12,r8[0x0]
80003004:	40 0b       	lddsp	r11,sp[0x0]
80003006:	f0 1f 00 08 	mcall	80003024 <payload_rx+0x54>
		logFromISR("mm");
8000300a:	48 8c       	lddpc	r12,80003028 <payload_rx+0x58>
8000300c:	f0 1f 00 08 	mcall	8000302c <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
80003010:	2f ed       	sub	sp,-8
80003012:	d8 02       	popm	pc
80003014:	00 00       	add	r0,r0
80003016:	0a 74       	tst	r4,r5
80003018:	80 00       	ld.sh	r0,r0[0x0]
8000301a:	56 f8       	stdsp	sp[0x1bc],r8
8000301c:	80 00       	ld.sh	r0,r0[0x0]
8000301e:	55 50       	stdsp	sp[0x154],r0
80003020:	00 00       	add	r0,r0
80003022:	0a 88       	andn	r8,r5
80003024:	80 00       	ld.sh	r0,r0[0x0]
80003026:	2a 1c       	sub	r12,-95
80003028:	80 00       	ld.sh	r0,r0[0x0]
8000302a:	cf d0       	breq	80003024 <payload_rx+0x54>
8000302c:	80 00       	ld.sh	r0,r0[0x0]
8000302e:	63 1c       	ld.w	r12,r1[0x44]

80003030 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80003030:	eb cd 40 e0 	pushm	r5-r7,lr
80003034:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80003036:	fe f8 0b 1e 	ld.w	r8,pc[2846]
8000303a:	70 08       	ld.w	r8,r8[0x0]
8000303c:	58 08       	cp.w	r8,0
8000303e:	e0 80 01 05 	breq	80003248 <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80003042:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003044:	fe f8 0b 14 	ld.w	r8,pc[2836]
80003048:	70 09       	ld.w	r9,r8[0x0]
8000304a:	2f f9       	sub	r9,-1
8000304c:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
8000304e:	fe f8 0b 0e 	ld.w	r8,pc[2830]
80003052:	70 08       	ld.w	r8,r8[0x0]
80003054:	58 18       	cp.w	r8,1
80003056:	e0 80 00 84 	breq	8000315e <phy_rx_func+0x12e>
8000305a:	c0 73       	brcs	80003068 <phy_rx_func+0x38>
8000305c:	58 28       	cp.w	r8,2
8000305e:	c5 b0       	breq	80003114 <phy_rx_func+0xe4>
80003060:	58 38       	cp.w	r8,3
80003062:	e0 81 00 f3 	brne	80003248 <phy_rx_func+0x218>
80003066:	cd 38       	rjmp	8000320c <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80003068:	e0 6a 5a 5a 	mov	r10,23130
8000306c:	ea 1a ab cd 	orh	r10,0xabcd
80003070:	14 36       	cp.w	r6,r10
80003072:	e0 80 00 eb 	breq	80003248 <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80003076:	ec 08 16 10 	lsr	r8,r6,0x10
8000307a:	e0 48 ab cd 	cp.w	r8,43981
8000307e:	e0 81 00 e5 	brne	80003248 <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80003082:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80003086:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000308a:	20 28       	sub	r8,2
8000308c:	fe f9 0a d4 	ld.w	r9,pc[2772]
80003090:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80003092:	30 09       	mov	r9,0
80003094:	f2 08 19 00 	cp.h	r8,r9
80003098:	e0 8a 00 d8 	brle	80003248 <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
8000309c:	fe f8 0a c8 	ld.w	r8,pc[2760]
800030a0:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
800030a2:	fe f8 0a c6 	ld.w	r8,pc[2758]
800030a6:	70 0c       	ld.w	r12,r8[0x0]
800030a8:	f0 1f 02 b1 	mcall	80003b6c <phy_rx_func+0xb3c>
800030ac:	fe f8 0a c4 	ld.w	r8,pc[2756]
800030b0:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
800030b2:	58 0c       	cp.w	r12,0
800030b4:	e0 80 00 ca 	breq	80003248 <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800030b8:	fe f8 0a ac 	ld.w	r8,pc[2732]
800030bc:	90 09       	ld.sh	r9,r8[0x0]
800030be:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
800030c2:	2f f9       	sub	r9,-1
800030c4:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800030c6:	fe fa 0a aa 	ld.w	r10,pc[2730]
800030ca:	74 0a       	ld.w	r10,r10[0x0]
800030cc:	fe fb 0a 8c 	ld.w	r11,pc[2700]
800030d0:	76 0b       	ld.w	r11,r11[0x0]
800030d2:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
800030d6:	2f f9       	sub	r9,-1
800030d8:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
800030da:	e2 16 0f 00 	andl	r6,0xf00,COH
800030de:	e0 46 01 00 	cp.w	r6,256
800030e2:	c0 c0       	breq	800030fa <phy_rx_func+0xca>
800030e4:	e0 8b 00 05 	brhi	800030ee <phy_rx_func+0xbe>
800030e8:	58 06       	cp.w	r6,0
800030ea:	c0 80       	breq	800030fa <phy_rx_func+0xca>
800030ec:	c0 c8       	rjmp	80003104 <phy_rx_func+0xd4>
800030ee:	e0 46 02 00 	cp.w	r6,512
800030f2:	c0 40       	breq	800030fa <phy_rx_func+0xca>
800030f4:	e0 46 03 00 	cp.w	r6,768
800030f8:	c0 61       	brne	80003104 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
800030fa:	30 29       	mov	r9,2
800030fc:	fe f8 0a 60 	ld.w	r8,pc[2656]
80003100:	91 09       	st.w	r8[0x0],r9
80003102:	ca 38       	rjmp	80003248 <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
80003104:	fe f6 0a 6c 	ld.w	r6,pc[2668]
80003108:	6c 0c       	ld.w	r12,r6[0x0]
8000310a:	f0 1f 02 9b 	mcall	80003b74 <phy_rx_func+0xb44>
					phy_frame_ptr = NULL;					
8000310e:	30 08       	mov	r8,0
80003110:	8d 08       	st.w	r6[0x0],r8
80003112:	c9 b8       	rjmp	80003248 <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003114:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80003118:	b1 86       	lsr	r6,0x10
8000311a:	14 06       	add	r6,r10
8000311c:	fe f8 0a 5c 	ld.w	r8,pc[2652]
80003120:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003122:	fe f8 0a 42 	ld.w	r8,pc[2626]
80003126:	90 09       	ld.sh	r9,r8[0x0]
80003128:	fe fb 0a 48 	ld.w	r11,pc[2632]
8000312c:	76 0b       	ld.w	r11,r11[0x0]
8000312e:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80003132:	2f f9       	sub	r9,-1
80003134:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80003136:	fe f9 0a 2a 	ld.w	r9,pc[2602]
8000313a:	92 08       	ld.sh	r8,r9[0x0]
8000313c:	20 28       	sub	r8,2
8000313e:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80003140:	30 09       	mov	r9,0
80003142:	f2 08 19 00 	cp.h	r8,r9
80003146:	e0 8a 00 07 	brle	80003154 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
8000314a:	30 19       	mov	r9,1
8000314c:	fe f8 0a 10 	ld.w	r8,pc[2576]
80003150:	91 09       	st.w	r8[0x0],r9
80003152:	c7 b8       	rjmp	80003248 <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80003154:	30 39       	mov	r9,3
80003156:	fe f8 0a 06 	ld.w	r8,pc[2566]
8000315a:	91 09       	st.w	r8[0x0],r9
8000315c:	c7 68       	rjmp	80003248 <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
8000315e:	ec 0a 14 10 	asr	r10,r6,0x10
80003162:	fe f8 0a 16 	ld.w	r8,pc[2582]
80003166:	90 09       	ld.sh	r9,r8[0x0]
80003168:	14 09       	add	r9,r10
8000316a:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000316c:	fe f9 09 f8 	ld.w	r9,pc[2552]
80003170:	92 08       	ld.sh	r8,r9[0x0]
80003172:	fe fb 09 fe 	ld.w	r11,pc[2558]
80003176:	76 0b       	ld.w	r11,r11[0x0]
80003178:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
8000317c:	2f f8       	sub	r8,-1
8000317e:	5c 88       	casts.h	r8
80003180:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003182:	fe fa 09 de 	ld.w	r10,pc[2526]
80003186:	94 09       	ld.sh	r9,r10[0x0]
80003188:	20 29       	sub	r9,2
8000318a:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
8000318c:	30 0a       	mov	r10,0
8000318e:	f4 09 19 00 	cp.h	r9,r10
80003192:	e0 89 00 1f 	brgt	800031d0 <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003196:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
8000319a:	e0 46 00 ba 	cp.w	r6,186
8000319e:	c0 d1       	brne	800031b8 <phy_rx_func+0x188>
800031a0:	fe f8 09 d8 	ld.w	r8,pc[2520]
800031a4:	90 09       	ld.sh	r9,r8[0x0]
800031a6:	f4 09 19 00 	cp.h	r9,r10
800031aa:	c0 71       	brne	800031b8 <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
800031ac:	fe f8 09 c4 	ld.w	r8,pc[2500]
800031b0:	70 0c       	ld.w	r12,r8[0x0]
800031b2:	f0 1f 02 73 	mcall	80003b7c <phy_rx_func+0xb4c>
800031b6:	c0 88       	rjmp	800031c6 <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
800031b8:	fe f6 09 b8 	ld.w	r6,pc[2488]
800031bc:	6c 0c       	ld.w	r12,r6[0x0]
800031be:	f0 1f 02 6e 	mcall	80003b74 <phy_rx_func+0xb44>
					phy_frame_ptr = NULL;
800031c2:	30 08       	mov	r8,0
800031c4:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
800031c6:	30 09       	mov	r9,0
800031c8:	fe f8 09 94 	ld.w	r8,pc[2452]
800031cc:	91 09       	st.w	r8[0x0],r9
800031ce:	c3 d8       	rjmp	80003248 <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
800031d0:	5c 86       	casts.h	r6
800031d2:	fe f9 09 a6 	ld.w	r9,pc[2470]
800031d6:	92 0a       	ld.sh	r10,r9[0x0]
800031d8:	0c 0a       	add	r10,r6
800031da:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800031dc:	fe f9 09 94 	ld.w	r9,pc[2452]
800031e0:	72 09       	ld.w	r9,r9[0x0]
800031e2:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
800031e6:	2f f8       	sub	r8,-1
800031e8:	fe f9 09 7c 	ld.w	r9,pc[2428]
800031ec:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
800031ee:	fe f9 09 72 	ld.w	r9,pc[2418]
800031f2:	92 08       	ld.sh	r8,r9[0x0]
800031f4:	20 28       	sub	r8,2
800031f6:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
800031f8:	30 09       	mov	r9,0
800031fa:	f2 08 19 00 	cp.h	r8,r9
800031fe:	e0 89 00 25 	brgt	80003248 <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003202:	30 39       	mov	r9,3
80003204:	fe f8 09 58 	ld.w	r8,pc[2392]
80003208:	91 09       	st.w	r8[0x0],r9
8000320a:	c1 f8       	rjmp	80003248 <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
8000320c:	e6 16 00 ff 	andh	r6,0xff,COH
80003210:	fc 19 00 ba 	movh	r9,0xba
80003214:	12 36       	cp.w	r6,r9
80003216:	c0 e1       	brne	80003232 <phy_rx_func+0x202>
80003218:	fe f8 09 60 	ld.w	r8,pc[2400]
8000321c:	90 09       	ld.sh	r9,r8[0x0]
8000321e:	30 08       	mov	r8,0
80003220:	f0 09 19 00 	cp.h	r9,r8
80003224:	c0 71       	brne	80003232 <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003226:	fe f8 09 4a 	ld.w	r8,pc[2378]
8000322a:	70 0c       	ld.w	r12,r8[0x0]
8000322c:	f0 1f 02 54 	mcall	80003b7c <phy_rx_func+0xb4c>
80003230:	c0 88       	rjmp	80003240 <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
80003232:	fe f6 09 3e 	ld.w	r6,pc[2366]
80003236:	6c 0c       	ld.w	r12,r6[0x0]
80003238:	f0 1f 02 4f 	mcall	80003b74 <phy_rx_func+0xb44>
				phy_frame_ptr = NULL;
8000323c:	30 08       	mov	r8,0
8000323e:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80003240:	30 09       	mov	r9,0
80003242:	fe f8 09 1a 	ld.w	r8,pc[2330]
80003246:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
80003248:	fe f8 09 38 	ld.w	r8,pc[2360]
8000324c:	11 89       	ld.ub	r9,r8[0x0]
8000324e:	30 08       	mov	r8,0
80003250:	f0 09 18 00 	cp.b	r9,r8
80003254:	c0 d1       	brne	8000326e <phy_rx_func+0x23e>
	{
		//payload_ptr = get_payload_idle_isr();
		AMBE_payload_ptr = get_payload_idle_isr();
80003256:	fe f8 09 2e 	ld.w	r8,pc[2350]
8000325a:	70 0c       	ld.w	r12,r8[0x0]
8000325c:	f0 1f 02 44 	mcall	80003b6c <phy_rx_func+0xb3c>
80003260:	fe f8 09 28 	ld.w	r8,pc[2344]
80003264:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003266:	30 19       	mov	r9,1
80003268:	fe f8 09 18 	ld.w	r8,pc[2328]
8000326c:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
8000326e:	fe f8 09 1e 	ld.w	r8,pc[2334]
80003272:	70 08       	ld.w	r8,r8[0x0]
80003274:	58 38       	cp.w	r8,3
80003276:	e0 80 04 28 	breq	80003ac6 <phy_rx_func+0xa96>
8000327a:	58 48       	cp.w	r8,4
8000327c:	e0 80 01 0a 	breq	80003490 <phy_rx_func+0x460>
80003280:	58 08       	cp.w	r8,0
80003282:	e0 81 04 66 	brne	80003b4e <phy_rx_func+0xb1e>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003286:	6e 28       	ld.w	r8,r7[0x8]
80003288:	e0 6a 5a 5a 	mov	r10,23130
8000328c:	ea 1a ab cd 	orh	r10,0xabcd
80003290:	14 38       	cp.w	r8,r10
80003292:	c0 71       	brne	800032a0 <phy_rx_func+0x270>
			{
				m_RxBurstType = VOICE_WATING;
80003294:	30 09       	mov	r9,0
80003296:	fe f8 08 fa 	ld.w	r8,pc[2298]
8000329a:	91 09       	st.w	r8[0x0],r9
8000329c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800032a0:	10 99       	mov	r9,r8
800032a2:	e0 19 00 00 	andl	r9,0x0
800032a6:	fc 1a ab cd 	movh	r10,0xabcd
800032aa:	14 39       	cp.w	r9,r10
800032ac:	e0 81 04 51 	brne	80003b4e <phy_rx_func+0xb1e>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800032b0:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800032b4:	fe f9 08 e0 	ld.w	r9,pc[2272]
800032b8:	93 08       	st.w	r9[0x0],r8
		
			if( (NULL== AMBE_payload_ptr))
800032ba:	fe f8 08 ce 	ld.w	r8,pc[2254]
800032be:	70 08       	ld.w	r8,r8[0x0]
800032c0:	58 08       	cp.w	r8,0
800032c2:	c1 11       	brne	800032e4 <phy_rx_func+0x2b4>
			{
				//payload_ptr = get_payload_idle_isr();
				AMBE_payload_ptr = get_payload_idle_isr();
800032c4:	fe f8 08 c0 	ld.w	r8,pc[2240]
800032c8:	70 0c       	ld.w	r12,r8[0x0]
800032ca:	f0 1f 02 29 	mcall	80003b6c <phy_rx_func+0xb3c>
800032ce:	fe f8 08 ba 	ld.w	r8,pc[2234]
800032d2:	91 0c       	st.w	r8[0x0],r12
				
				if (NULL== AMBE_payload_ptr)
800032d4:	58 0c       	cp.w	r12,0
800032d6:	c0 71       	brne	800032e4 <phy_rx_func+0x2b4>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800032d8:	fe fc 08 c0 	ld.w	r12,pc[2240]
800032dc:	f0 1f 02 30 	mcall	80003b9c <phy_rx_func+0xb6c>
800032e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800032e4:	6e 28       	ld.w	r8,r7[0x8]
800032e6:	e2 18 f0 00 	andl	r8,0xf000,COH
800032ea:	e0 48 c0 00 	cp.w	r8,49152
800032ee:	e0 81 00 cb 	brne	80003484 <phy_rx_func+0x454>
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
			{
				AMBE_Media = 1;	
800032f2:	30 19       	mov	r9,1
800032f4:	fe f8 08 ac 	ld.w	r8,pc[2220]
800032f8:	b0 89       	st.b	r8[0x0],r9
											
				Item_ID = payload_rx_channel->byte[5];
800032fa:	ef 39 00 0d 	ld.ub	r9,r7[13]
800032fe:	fe f8 08 a6 	ld.w	r8,pc[2214]
80003302:	b0 89       	st.b	r8[0x0],r9
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003304:	ef 3a 00 0c 	ld.ub	r10,r7[12]
80003308:	f5 da c0 07 	bfextu	r10,r10,0x0,0x7
8000330c:	fe f9 08 9c 	ld.w	r9,pc[2204]
80003310:	93 0a       	st.w	r9[0x0],r10
								
				switch(Item_ID)
80003312:	11 88       	ld.ub	r8,r8[0x0]
80003314:	37 f9       	mov	r9,127
80003316:	f2 08 18 00 	cp.b	r8,r9
8000331a:	c6 b0       	breq	800033f0 <phy_rx_func+0x3c0>
8000331c:	e0 8b 00 0c 	brhi	80003334 <phy_rx_func+0x304>
80003320:	31 29       	mov	r9,18
80003322:	f2 08 18 00 	cp.b	r8,r9
80003326:	c4 20       	breq	800033aa <phy_rx_func+0x37a>
80003328:	31 39       	mov	r9,19
8000332a:	f2 08 18 00 	cp.b	r8,r9
8000332e:	e0 81 00 8b 	brne	80003444 <phy_rx_func+0x414>
80003332:	c5 98       	rjmp	800033e4 <phy_rx_func+0x3b4>
80003334:	2f 08       	sub	r8,-16
80003336:	30 19       	mov	r9,1
80003338:	f2 08 18 00 	cp.b	r8,r9
8000333c:	e0 8b 00 84 	brhi	80003444 <phy_rx_func+0x414>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003340:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003344:	e2 18 00 f0 	andl	r8,0xf0,COH
80003348:	59 08       	cp.w	r8,16
8000334a:	c0 71       	brne	80003358 <phy_rx_func+0x328>
							{
								m_RxBurstType = VOICEHEADER;
8000334c:	30 19       	mov	r9,1
8000334e:	fe f8 08 42 	ld.w	r8,pc[2114]
80003352:	91 09       	st.w	r8[0x0],r9
80003354:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003358:	e0 48 00 20 	cp.w	r8,32
8000335c:	c2 11       	brne	8000339e <phy_rx_func+0x36e>
							{
								m_RxBurstType = VOICETERMINATOR;
8000335e:	30 a9       	mov	r9,10
80003360:	fe f8 08 30 	ld.w	r8,pc[2096]
80003364:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003366:	fe f6 08 46 	ld.w	r6,pc[2118]
8000336a:	6c 08       	ld.w	r8,r6[0x0]
8000336c:	f0 0a 11 ff 	rsub	r10,r8,-1
80003370:	fe f7 08 18 	ld.w	r7,pc[2072]
80003374:	2f f8       	sub	r8,-1
80003376:	6e 0c       	ld.w	r12,r7[0x0]
80003378:	f4 ca fe 00 	sub	r10,r10,-512
8000337c:	30 0b       	mov	r11,0
8000337e:	10 0c       	add	r12,r8
80003380:	f0 1f 02 0c 	mcall	80003bb0 <phy_rx_func+0xb80>
								
								RxAMBE_IsFillingNext8 = 0;
80003384:	30 08       	mov	r8,0
80003386:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003388:	6e 0c       	ld.w	r12,r7[0x0]
8000338a:	f0 1f 02 0b 	mcall	80003bb4 <phy_rx_func+0xb84>
								AMBE_payload_ptr = get_payload_idle_isr();
8000338e:	fe f8 07 f6 	ld.w	r8,pc[2038]
80003392:	70 0c       	ld.w	r12,r8[0x0]
80003394:	f0 1f 01 f6 	mcall	80003b6c <phy_rx_func+0xb3c>
80003398:	8f 0c       	st.w	r7[0x0],r12
8000339a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
8000339e:	30 09       	mov	r9,0
800033a0:	fe f8 07 f0 	ld.w	r8,pc[2032]
800033a4:	91 09       	st.w	r8[0x0],r9
800033a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800033aa:	fe f9 07 ea 	ld.w	r9,pc[2026]
800033ae:	72 08       	ld.w	r8,r9[0x0]
800033b0:	20 48       	sub	r8,4
800033b2:	93 08       	st.w	r9[0x0],r8
800033b4:	e0 80 03 cd 	breq	80003b4e <phy_rx_func+0xb1e>
					
							//Vocoder Bits Stream Parameter
							VF_SN = payload_rx_channel->byte[7];//This parameter is very important to the loop back Radio, as a reference.
800033b8:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800033bc:	fe f8 07 fc 	ld.w	r8,pc[2044]
800033c0:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
800033c2:	8e 69       	ld.sh	r9,r7[0xc]
800033c4:	fe f8 07 f8 	ld.w	r8,pc[2040]
800033c8:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
800033ca:	8e 79       	ld.sh	r9,r7[0xe]
800033cc:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
800033ce:	f0 1f 01 fd 	mcall	80003bc0 <phy_rx_func+0xb90>
800033d2:	fe f8 07 be 	ld.w	r8,pc[1982]
800033d6:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
800033d8:	30 49       	mov	r9,4
800033da:	fe f8 07 b2 	ld.w	r8,pc[1970]
800033de:	91 09       	st.w	r8[0x0],r9
800033e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800033e4:	30 09       	mov	r9,0
800033e6:	fe f8 07 aa 	ld.w	r8,pc[1962]
800033ea:	91 09       	st.w	r8[0x0],r9
800033ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
							
								
					case Radio_Internal_Parameter://0x7F
							
							logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
800033f0:	fe f8 07 b8 	ld.w	r8,pc[1976]
800033f4:	70 08       	ld.w	r8,r8[0x0]
800033f6:	1a d8       	st.w	--sp,r8
800033f8:	fe fc 07 cc 	ld.w	r12,pc[1996]
800033fc:	f0 1f 01 e8 	mcall	80003b9c <phy_rx_func+0xb6c>
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003400:	fe f9 07 94 	ld.w	r9,pc[1940]
80003404:	72 08       	ld.w	r8,r9[0x0]
80003406:	20 48       	sub	r8,4
80003408:	93 08       	st.w	r9[0x0],r8
8000340a:	2f fd       	sub	sp,-4
8000340c:	58 08       	cp.w	r8,0
8000340e:	e0 80 03 a0 	breq	80003b4e <phy_rx_func+0xb1e>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003412:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003416:	70 09       	ld.w	r9,r8[0x0]
80003418:	8e 7b       	ld.sh	r11,r7[0xe]
8000341a:	fe fa 07 b2 	ld.w	r10,pc[1970]
8000341e:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003422:	2f f9       	sub	r9,-1
80003424:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003426:	fe f8 07 82 	ld.w	r8,pc[1922]
8000342a:	70 09       	ld.w	r9,r8[0x0]
8000342c:	20 29       	sub	r9,2
8000342e:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003430:	30 29       	mov	r9,2
80003432:	fe f8 07 5e 	ld.w	r8,pc[1886]
80003436:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003438:	30 39       	mov	r9,3
8000343a:	fe f8 07 52 	ld.w	r8,pc[1874]
8000343e:	91 09       	st.w	r8[0x0],r9
80003440:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003444:	30 39       	mov	r9,3
80003446:	fe f8 07 4a 	ld.w	r8,pc[1866]
8000344a:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
8000344c:	6e 29       	ld.w	r9,r7[0x8]
8000344e:	fe f8 07 82 	ld.w	r8,pc[1922]
80003452:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003454:	6e 39       	ld.w	r9,r7[0xc]
80003456:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
80003458:	fe f8 07 3c 	ld.w	r8,pc[1852]
8000345c:	70 08       	ld.w	r8,r8[0x0]
8000345e:	59 48       	cp.w	r8,20
80003460:	c0 61       	brne	8000346c <phy_rx_func+0x43c>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003462:	31 89       	mov	r9,24
80003464:	fe f8 07 30 	ld.w	r8,pc[1840]
80003468:	91 09       	st.w	r8[0x0],r9
8000346a:	c0 78       	rjmp	80003478 <phy_rx_func+0x448>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
8000346c:	59 08       	cp.w	r8,16
8000346e:	c0 51       	brne	80003478 <phy_rx_func+0x448>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003470:	31 09       	mov	r9,16
80003472:	fe f8 07 22 	ld.w	r8,pc[1826]
80003476:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003478:	30 49       	mov	r9,4
8000347a:	fe f8 07 12 	ld.w	r8,pc[1810]
8000347e:	91 09       	st.w	r8[0x0],r9
80003480:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				break;
			}
			
			else
			{
				AMBE_Media = 0;	
80003484:	30 09       	mov	r9,0
80003486:	fe f8 07 1a 	ld.w	r8,pc[1818]
8000348a:	b0 89       	st.b	r8[0x0],r9
8000348c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003490:	fe f8 07 14 	ld.w	r8,pc[1812]
80003494:	11 89       	ld.ub	r9,r8[0x0]
80003496:	31 28       	mov	r8,18
80003498:	f0 09 18 00 	cp.b	r9,r8
8000349c:	e0 81 01 4c 	brne	80003734 <phy_rx_func+0x704>
					{
						Item_ID = payload_rx_channel->byte[1];
800034a0:	ef 39 00 09 	ld.ub	r9,r7[9]
800034a4:	fe f8 07 00 	ld.w	r8,pc[1792]
800034a8:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
800034aa:	11 89       	ld.ub	r9,r8[0x0]
800034ac:	3f 28       	mov	r8,-14
800034ae:	f0 09 18 00 	cp.b	r9,r8
800034b2:	e0 81 01 3b 	brne	80003728 <phy_rx_func+0x6f8>
						{
							AMBE_tx_flag = 1;
800034b6:	30 19       	mov	r9,1
800034b8:	fe f8 07 1c 	ld.w	r8,pc[1820]
800034bc:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
800034be:	6e 29       	ld.w	r9,r7[0x8]
800034c0:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
800034c4:	fe f8 06 d0 	ld.w	r8,pc[1744]
800034c8:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
800034ca:	8e 59       	ld.sh	r9,r7[0xa]
800034cc:	fe f8 07 0c 	ld.w	r8,pc[1804]
800034d0:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
800034d2:	8e 69       	ld.sh	r9,r7[0xc]
800034d4:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
800034d6:	8e 79       	ld.sh	r9,r7[0xe]
800034d8:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
800034da:	fe f8 06 d2 	ld.w	r8,pc[1746]
800034de:	fe f9 06 aa 	ld.w	r9,pc[1706]
800034e2:	72 0a       	ld.w	r10,r9[0x0]
800034e4:	70 09       	ld.w	r9,r8[0x0]
800034e6:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800034ea:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800034ee:	70 09       	ld.w	r9,r8[0x0]
800034f0:	2f f9       	sub	r9,-1
800034f2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800034f4:	e0 49 01 ff 	cp.w	r9,511
800034f8:	e0 88 00 16 	brls	80003524 <phy_rx_func+0x4f4>
							{
								RxAMBE_IsFillingNext8 = 0;
800034fc:	30 09       	mov	r9,0
800034fe:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003500:	fe f6 06 88 	ld.w	r6,pc[1672]
80003504:	6c 0c       	ld.w	r12,r6[0x0]
80003506:	f0 1f 01 ac 	mcall	80003bb4 <phy_rx_func+0xb84>
								AMBE_payload_ptr = get_payload_idle_isr();
8000350a:	fe f8 06 7a 	ld.w	r8,pc[1658]
8000350e:	70 0c       	ld.w	r12,r8[0x0]
80003510:	f0 1f 01 97 	mcall	80003b6c <phy_rx_func+0xb3c>
80003514:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003516:	c0 71       	brne	80003524 <phy_rx_func+0x4f4>
								{
									RxMediaState = WAITINGABAB;
80003518:	30 09       	mov	r9,0
8000351a:	fe f8 06 72 	ld.w	r8,pc[1650]
8000351e:	91 09       	st.w	r8[0x0],r9
80003520:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003524:	fe f9 06 70 	ld.w	r9,pc[1648]
80003528:	72 08       	ld.w	r8,r9[0x0]
8000352a:	20 18       	sub	r8,1
8000352c:	93 08       	st.w	r9[0x0],r8
8000352e:	c0 71       	brne	8000353c <phy_rx_func+0x50c>
								RxMediaState = WAITINGABAB;
80003530:	30 09       	mov	r9,0
80003532:	fe f8 06 5a 	ld.w	r8,pc[1626]
80003536:	91 09       	st.w	r8[0x0],r9
80003538:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
8000353c:	fe f8 06 70 	ld.w	r8,pc[1648]
80003540:	fe f9 06 48 	ld.w	r9,pc[1608]
80003544:	72 0a       	ld.w	r10,r9[0x0]
80003546:	70 09       	ld.w	r9,r8[0x0]
80003548:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000354c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003550:	70 09       	ld.w	r9,r8[0x0]
80003552:	2f f9       	sub	r9,-1
80003554:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003556:	e0 49 01 ff 	cp.w	r9,511
8000355a:	e0 88 00 16 	brls	80003586 <phy_rx_func+0x556>
							{
								RxAMBE_IsFillingNext8 = 0;
8000355e:	30 09       	mov	r9,0
80003560:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003562:	fe f6 06 26 	ld.w	r6,pc[1574]
80003566:	6c 0c       	ld.w	r12,r6[0x0]
80003568:	f0 1f 01 93 	mcall	80003bb4 <phy_rx_func+0xb84>
								AMBE_payload_ptr = get_payload_idle_isr();
8000356c:	fe f8 06 18 	ld.w	r8,pc[1560]
80003570:	70 0c       	ld.w	r12,r8[0x0]
80003572:	f0 1f 01 7f 	mcall	80003b6c <phy_rx_func+0xb3c>
80003576:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003578:	c0 71       	brne	80003586 <phy_rx_func+0x556>
								{
									RxMediaState = WAITINGABAB;
8000357a:	30 09       	mov	r9,0
8000357c:	fe f8 06 10 	ld.w	r8,pc[1552]
80003580:	91 09       	st.w	r8[0x0],r9
80003582:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003586:	fe f9 06 0e 	ld.w	r9,pc[1550]
8000358a:	72 08       	ld.w	r8,r9[0x0]
8000358c:	20 18       	sub	r8,1
8000358e:	93 08       	st.w	r9[0x0],r8
80003590:	c0 71       	brne	8000359e <phy_rx_func+0x56e>
								RxMediaState = WAITINGABAB;
80003592:	30 09       	mov	r9,0
80003594:	fe f8 05 f8 	ld.w	r8,pc[1528]
80003598:	91 09       	st.w	r8[0x0],r9
8000359a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
8000359e:	fe f8 06 0e 	ld.w	r8,pc[1550]
800035a2:	fe f9 05 e6 	ld.w	r9,pc[1510]
800035a6:	72 0a       	ld.w	r10,r9[0x0]
800035a8:	70 09       	ld.w	r9,r8[0x0]
800035aa:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800035ae:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035b2:	70 09       	ld.w	r9,r8[0x0]
800035b4:	2f f9       	sub	r9,-1
800035b6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035b8:	e0 49 01 ff 	cp.w	r9,511
800035bc:	e0 88 00 16 	brls	800035e8 <phy_rx_func+0x5b8>
							{
								RxAMBE_IsFillingNext8 = 0;
800035c0:	30 09       	mov	r9,0
800035c2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035c4:	fe f6 05 c4 	ld.w	r6,pc[1476]
800035c8:	6c 0c       	ld.w	r12,r6[0x0]
800035ca:	f0 1f 01 7b 	mcall	80003bb4 <phy_rx_func+0xb84>
								AMBE_payload_ptr = get_payload_idle_isr();
800035ce:	fe f8 05 b6 	ld.w	r8,pc[1462]
800035d2:	70 0c       	ld.w	r12,r8[0x0]
800035d4:	f0 1f 01 66 	mcall	80003b6c <phy_rx_func+0xb3c>
800035d8:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035da:	c0 71       	brne	800035e8 <phy_rx_func+0x5b8>
								{
									RxMediaState = WAITINGABAB;
800035dc:	30 09       	mov	r9,0
800035de:	fe f8 05 ae 	ld.w	r8,pc[1454]
800035e2:	91 09       	st.w	r8[0x0],r9
800035e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035e8:	fe f9 05 ac 	ld.w	r9,pc[1452]
800035ec:	72 08       	ld.w	r8,r9[0x0]
800035ee:	20 18       	sub	r8,1
800035f0:	93 08       	st.w	r9[0x0],r8
800035f2:	c0 71       	brne	80003600 <phy_rx_func+0x5d0>
								RxMediaState = WAITINGABAB;
800035f4:	30 09       	mov	r9,0
800035f6:	fe f8 05 96 	ld.w	r8,pc[1430]
800035fa:	91 09       	st.w	r8[0x0],r9
800035fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003600:	fe f8 05 ac 	ld.w	r8,pc[1452]
80003604:	fe f9 05 84 	ld.w	r9,pc[1412]
80003608:	72 0a       	ld.w	r10,r9[0x0]
8000360a:	70 09       	ld.w	r9,r8[0x0]
8000360c:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003610:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003614:	70 09       	ld.w	r9,r8[0x0]
80003616:	2f f9       	sub	r9,-1
80003618:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000361a:	e0 49 01 ff 	cp.w	r9,511
8000361e:	e0 88 00 16 	brls	8000364a <phy_rx_func+0x61a>
							{
								RxAMBE_IsFillingNext8 = 0;
80003622:	30 09       	mov	r9,0
80003624:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003626:	fe f6 05 62 	ld.w	r6,pc[1378]
8000362a:	6c 0c       	ld.w	r12,r6[0x0]
8000362c:	f0 1f 01 62 	mcall	80003bb4 <phy_rx_func+0xb84>
								AMBE_payload_ptr = get_payload_idle_isr();
80003630:	fe f8 05 54 	ld.w	r8,pc[1364]
80003634:	70 0c       	ld.w	r12,r8[0x0]
80003636:	f0 1f 01 4e 	mcall	80003b6c <phy_rx_func+0xb3c>
8000363a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000363c:	c0 71       	brne	8000364a <phy_rx_func+0x61a>
								{
									RxMediaState = WAITINGABAB;
8000363e:	30 09       	mov	r9,0
80003640:	fe f8 05 4c 	ld.w	r8,pc[1356]
80003644:	91 09       	st.w	r8[0x0],r9
80003646:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000364a:	fe f9 05 4a 	ld.w	r9,pc[1354]
8000364e:	72 08       	ld.w	r8,r9[0x0]
80003650:	20 18       	sub	r8,1
80003652:	93 08       	st.w	r9[0x0],r8
80003654:	c0 71       	brne	80003662 <phy_rx_func+0x632>
								RxMediaState = WAITINGABAB;
80003656:	30 09       	mov	r9,0
80003658:	fe f8 05 34 	ld.w	r8,pc[1332]
8000365c:	91 09       	st.w	r8[0x0],r9
8000365e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003662:	fe f8 05 4a 	ld.w	r8,pc[1354]
80003666:	fe f9 05 22 	ld.w	r9,pc[1314]
8000366a:	72 0a       	ld.w	r10,r9[0x0]
8000366c:	70 09       	ld.w	r9,r8[0x0]
8000366e:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003672:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003676:	70 09       	ld.w	r9,r8[0x0]
80003678:	2f f9       	sub	r9,-1
8000367a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000367c:	e0 49 01 ff 	cp.w	r9,511
80003680:	e0 88 00 16 	brls	800036ac <phy_rx_func+0x67c>
							{
								RxAMBE_IsFillingNext8 = 0;
80003684:	30 09       	mov	r9,0
80003686:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003688:	fe f6 05 00 	ld.w	r6,pc[1280]
8000368c:	6c 0c       	ld.w	r12,r6[0x0]
8000368e:	f0 1f 01 4a 	mcall	80003bb4 <phy_rx_func+0xb84>
								AMBE_payload_ptr = get_payload_idle_isr();
80003692:	fe f8 04 f2 	ld.w	r8,pc[1266]
80003696:	70 0c       	ld.w	r12,r8[0x0]
80003698:	f0 1f 01 35 	mcall	80003b6c <phy_rx_func+0xb3c>
8000369c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000369e:	c0 71       	brne	800036ac <phy_rx_func+0x67c>
								{
									RxMediaState = WAITINGABAB;
800036a0:	30 09       	mov	r9,0
800036a2:	fe f8 04 ea 	ld.w	r8,pc[1258]
800036a6:	91 09       	st.w	r8[0x0],r9
800036a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036ac:	fe f9 04 e8 	ld.w	r9,pc[1256]
800036b0:	72 08       	ld.w	r8,r9[0x0]
800036b2:	20 18       	sub	r8,1
800036b4:	93 08       	st.w	r9[0x0],r8
800036b6:	c0 71       	brne	800036c4 <phy_rx_func+0x694>
								RxMediaState = WAITINGABAB;
800036b8:	30 09       	mov	r9,0
800036ba:	fe f8 04 d2 	ld.w	r8,pc[1234]
800036be:	91 09       	st.w	r8[0x0],r9
800036c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
800036c4:	fe f8 04 e8 	ld.w	r8,pc[1256]
800036c8:	fe f9 04 c0 	ld.w	r9,pc[1216]
800036cc:	72 0a       	ld.w	r10,r9[0x0]
800036ce:	70 09       	ld.w	r9,r8[0x0]
800036d0:	ef 3b 00 0f 	ld.ub	r11,r7[15]
800036d4:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036d8:	70 09       	ld.w	r9,r8[0x0]
800036da:	2f f9       	sub	r9,-1
800036dc:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036de:	e0 49 01 ff 	cp.w	r9,511
800036e2:	e0 88 00 16 	brls	8000370e <phy_rx_func+0x6de>
							{
								RxAMBE_IsFillingNext8 = 0;
800036e6:	30 09       	mov	r9,0
800036e8:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036ea:	fe f7 04 9e 	ld.w	r7,pc[1182]
800036ee:	6e 0c       	ld.w	r12,r7[0x0]
800036f0:	f0 1f 01 31 	mcall	80003bb4 <phy_rx_func+0xb84>
								AMBE_payload_ptr = get_payload_idle_isr();
800036f4:	fe f8 04 90 	ld.w	r8,pc[1168]
800036f8:	70 0c       	ld.w	r12,r8[0x0]
800036fa:	f0 1f 01 1d 	mcall	80003b6c <phy_rx_func+0xb3c>
800036fe:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003700:	c0 71       	brne	8000370e <phy_rx_func+0x6de>
								{
									RxMediaState = WAITINGABAB;
80003702:	30 09       	mov	r9,0
80003704:	fe f8 04 88 	ld.w	r8,pc[1160]
80003708:	91 09       	st.w	r8[0x0],r9
8000370a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000370e:	fe f9 04 86 	ld.w	r9,pc[1158]
80003712:	72 08       	ld.w	r8,r9[0x0]
80003714:	20 18       	sub	r8,1
80003716:	93 08       	st.w	r9[0x0],r8
80003718:	e0 81 02 1b 	brne	80003b4e <phy_rx_func+0xb1e>
								RxMediaState = WAITINGABAB;
8000371c:	30 09       	mov	r9,0
8000371e:	fe f8 04 6e 	ld.w	r8,pc[1134]
80003722:	91 09       	st.w	r8[0x0],r9
80003724:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003728:	30 09       	mov	r9,0
8000372a:	fe f8 04 62 	ld.w	r8,pc[1122]
8000372e:	91 09       	st.w	r8[0x0],r9
80003730:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003734:	fe f8 04 70 	ld.w	r8,pc[1136]
80003738:	11 89       	ld.ub	r9,r8[0x0]
8000373a:	3f 28       	mov	r8,-14
8000373c:	f0 09 18 00 	cp.b	r9,r8
80003740:	c4 31       	brne	800037c6 <phy_rx_func+0x796>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003742:	8e 49       	ld.sh	r9,r7[0x8]
80003744:	fe f8 04 94 	ld.w	r8,pc[1172]
80003748:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
8000374a:	fe f8 04 62 	ld.w	r8,pc[1122]
8000374e:	fe f9 04 3a 	ld.w	r9,pc[1082]
80003752:	72 0a       	ld.w	r10,r9[0x0]
80003754:	70 09       	ld.w	r9,r8[0x0]
80003756:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000375a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000375e:	70 09       	ld.w	r9,r8[0x0]
80003760:	2f f9       	sub	r9,-1
80003762:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003764:	e0 49 01 ff 	cp.w	r9,511
80003768:	e0 88 00 16 	brls	80003794 <phy_rx_func+0x764>
						{
							RxAMBE_IsFillingNext8 = 0;
8000376c:	30 09       	mov	r9,0
8000376e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003770:	fe f7 04 18 	ld.w	r7,pc[1048]
80003774:	6e 0c       	ld.w	r12,r7[0x0]
80003776:	f0 1f 01 10 	mcall	80003bb4 <phy_rx_func+0xb84>
							AMBE_payload_ptr = get_payload_idle_isr();
8000377a:	fe f8 04 0a 	ld.w	r8,pc[1034]
8000377e:	70 0c       	ld.w	r12,r8[0x0]
80003780:	f0 1f 00 fb 	mcall	80003b6c <phy_rx_func+0xb3c>
80003784:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003786:	c0 71       	brne	80003794 <phy_rx_func+0x764>
							{
								RxMediaState = WAITINGABAB;
80003788:	30 09       	mov	r9,0
8000378a:	fe f8 04 02 	ld.w	r8,pc[1026]
8000378e:	91 09       	st.w	r8[0x0],r9
80003790:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003794:	fe f9 04 00 	ld.w	r9,pc[1024]
80003798:	72 08       	ld.w	r8,r9[0x0]
8000379a:	20 18       	sub	r8,1
8000379c:	93 08       	st.w	r9[0x0],r8
8000379e:	c0 71       	brne	800037ac <phy_rx_func+0x77c>
							RxMediaState = WAITINGABAB;
800037a0:	30 09       	mov	r9,0
800037a2:	fe f8 03 ea 	ld.w	r8,pc[1002]
800037a6:	91 09       	st.w	r8[0x0],r9
800037a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
800037ac:	20 18       	sub	r8,1
800037ae:	fe f9 03 e6 	ld.w	r9,pc[998]
800037b2:	93 08       	st.w	r9[0x0],r8
800037b4:	58 08       	cp.w	r8,0
800037b6:	e0 81 01 cc 	brne	80003b4e <phy_rx_func+0xb1e>
							RxMediaState = WAITINGABAB;
800037ba:	30 09       	mov	r9,0
800037bc:	fe f8 03 d0 	ld.w	r8,pc[976]
800037c0:	91 09       	st.w	r8[0x0],r9
800037c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit0~bit63
800037c6:	fe f8 03 de 	ld.w	r8,pc[990]
800037ca:	11 89       	ld.ub	r9,r8[0x0]
800037cc:	3f 38       	mov	r8,-13
800037ce:	f0 09 18 00 	cp.b	r9,r8
800037d2:	e0 81 01 5a 	brne	80003a86 <phy_rx_func+0xa56>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[0] = payload_rx_channel->word[0];
800037d6:	8e 49       	ld.sh	r9,r7[0x8]
800037d8:	fe f8 04 00 	ld.w	r8,pc[1024]
800037dc:	b0 09       	st.h	r8[0x0],r9
						AMBEBurst_rawdata[1] = payload_rx_channel->word[1];
800037de:	8e 59       	ld.sh	r9,r7[0xa]
800037e0:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[2];
800037e2:	8e 69       	ld.sh	r9,r7[0xc]
800037e4:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[3];
800037e6:	8e 79       	ld.sh	r9,r7[0xe]
800037e8:	b0 39       	st.h	r8[0x6],r9
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//1
800037ea:	fe f8 03 c2 	ld.w	r8,pc[962]
800037ee:	fe f9 03 9a 	ld.w	r9,pc[922]
800037f2:	72 0a       	ld.w	r10,r9[0x0]
800037f4:	70 09       	ld.w	r9,r8[0x0]
800037f6:	ef 3b 00 08 	ld.ub	r11,r7[8]
800037fa:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037fe:	70 09       	ld.w	r9,r8[0x0]
80003800:	2f f9       	sub	r9,-1
80003802:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003804:	e0 49 01 ff 	cp.w	r9,511
80003808:	e0 88 00 16 	brls	80003834 <phy_rx_func+0x804>
						{
							RxAMBE_IsFillingNext8 = 0;
8000380c:	30 09       	mov	r9,0
8000380e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003810:	fe f6 03 78 	ld.w	r6,pc[888]
80003814:	6c 0c       	ld.w	r12,r6[0x0]
80003816:	f0 1f 00 e8 	mcall	80003bb4 <phy_rx_func+0xb84>
							AMBE_payload_ptr = get_payload_idle_isr();
8000381a:	fe f8 03 6a 	ld.w	r8,pc[874]
8000381e:	70 0c       	ld.w	r12,r8[0x0]
80003820:	f0 1f 00 d3 	mcall	80003b6c <phy_rx_func+0xb3c>
80003824:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003826:	c0 71       	brne	80003834 <phy_rx_func+0x804>
							{
								RxMediaState = WAITINGABAB;
80003828:	30 09       	mov	r9,0
8000382a:	fe f8 03 62 	ld.w	r8,pc[866]
8000382e:	91 09       	st.w	r8[0x0],r9
80003830:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003834:	fe f9 03 60 	ld.w	r9,pc[864]
80003838:	72 08       	ld.w	r8,r9[0x0]
8000383a:	20 18       	sub	r8,1
8000383c:	93 08       	st.w	r9[0x0],r8
8000383e:	c0 71       	brne	8000384c <phy_rx_func+0x81c>
							RxMediaState = WAITINGABAB;
80003840:	30 09       	mov	r9,0
80003842:	fe f8 03 4a 	ld.w	r8,pc[842]
80003846:	91 09       	st.w	r8[0x0],r9
80003848:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//2
8000384c:	fe f8 03 60 	ld.w	r8,pc[864]
80003850:	fe f9 03 38 	ld.w	r9,pc[824]
80003854:	72 0a       	ld.w	r10,r9[0x0]
80003856:	70 09       	ld.w	r9,r8[0x0]
80003858:	ef 3b 00 09 	ld.ub	r11,r7[9]
8000385c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003860:	70 09       	ld.w	r9,r8[0x0]
80003862:	2f f9       	sub	r9,-1
80003864:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003866:	e0 49 01 ff 	cp.w	r9,511
8000386a:	e0 88 00 16 	brls	80003896 <phy_rx_func+0x866>
						{
							RxAMBE_IsFillingNext8 = 0;
8000386e:	30 09       	mov	r9,0
80003870:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003872:	fe f6 03 16 	ld.w	r6,pc[790]
80003876:	6c 0c       	ld.w	r12,r6[0x0]
80003878:	f0 1f 00 cf 	mcall	80003bb4 <phy_rx_func+0xb84>
							AMBE_payload_ptr = get_payload_idle_isr();
8000387c:	fe f8 03 08 	ld.w	r8,pc[776]
80003880:	70 0c       	ld.w	r12,r8[0x0]
80003882:	f0 1f 00 bb 	mcall	80003b6c <phy_rx_func+0xb3c>
80003886:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003888:	c0 71       	brne	80003896 <phy_rx_func+0x866>
							{
								RxMediaState = WAITINGABAB;
8000388a:	30 09       	mov	r9,0
8000388c:	fe f8 03 00 	ld.w	r8,pc[768]
80003890:	91 09       	st.w	r8[0x0],r9
80003892:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003896:	fe f9 02 fe 	ld.w	r9,pc[766]
8000389a:	72 08       	ld.w	r8,r9[0x0]
8000389c:	20 18       	sub	r8,1
8000389e:	93 08       	st.w	r9[0x0],r8
800038a0:	c0 71       	brne	800038ae <phy_rx_func+0x87e>
							RxMediaState = WAITINGABAB;
800038a2:	30 09       	mov	r9,0
800038a4:	fe f8 02 e8 	ld.w	r8,pc[744]
800038a8:	91 09       	st.w	r8[0x0],r9
800038aa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//3
800038ae:	fe f8 02 fe 	ld.w	r8,pc[766]
800038b2:	fe f9 02 d6 	ld.w	r9,pc[726]
800038b6:	72 0a       	ld.w	r10,r9[0x0]
800038b8:	70 09       	ld.w	r9,r8[0x0]
800038ba:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800038be:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038c2:	70 09       	ld.w	r9,r8[0x0]
800038c4:	2f f9       	sub	r9,-1
800038c6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038c8:	e0 49 01 ff 	cp.w	r9,511
800038cc:	e0 88 00 16 	brls	800038f8 <phy_rx_func+0x8c8>
						{
							RxAMBE_IsFillingNext8 = 0;
800038d0:	30 09       	mov	r9,0
800038d2:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038d4:	fe f6 02 b4 	ld.w	r6,pc[692]
800038d8:	6c 0c       	ld.w	r12,r6[0x0]
800038da:	f0 1f 00 b7 	mcall	80003bb4 <phy_rx_func+0xb84>
							AMBE_payload_ptr = get_payload_idle_isr();
800038de:	fe f8 02 a6 	ld.w	r8,pc[678]
800038e2:	70 0c       	ld.w	r12,r8[0x0]
800038e4:	f0 1f 00 a2 	mcall	80003b6c <phy_rx_func+0xb3c>
800038e8:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038ea:	c0 71       	brne	800038f8 <phy_rx_func+0x8c8>
							{
								RxMediaState = WAITINGABAB;
800038ec:	30 09       	mov	r9,0
800038ee:	fe f8 02 9e 	ld.w	r8,pc[670]
800038f2:	91 09       	st.w	r8[0x0],r9
800038f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038f8:	fe f9 02 9c 	ld.w	r9,pc[668]
800038fc:	72 08       	ld.w	r8,r9[0x0]
800038fe:	20 18       	sub	r8,1
80003900:	93 08       	st.w	r9[0x0],r8
80003902:	c0 71       	brne	80003910 <phy_rx_func+0x8e0>
							RxMediaState = WAITINGABAB;
80003904:	30 09       	mov	r9,0
80003906:	fe f8 02 86 	ld.w	r8,pc[646]
8000390a:	91 09       	st.w	r8[0x0],r9
8000390c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//4
80003910:	fe f8 02 9c 	ld.w	r8,pc[668]
80003914:	fe f9 02 74 	ld.w	r9,pc[628]
80003918:	72 0a       	ld.w	r10,r9[0x0]
8000391a:	70 09       	ld.w	r9,r8[0x0]
8000391c:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003920:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003924:	70 09       	ld.w	r9,r8[0x0]
80003926:	2f f9       	sub	r9,-1
80003928:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000392a:	e0 49 01 ff 	cp.w	r9,511
8000392e:	e0 88 00 16 	brls	8000395a <phy_rx_func+0x92a>
						{
							RxAMBE_IsFillingNext8 = 0;
80003932:	30 09       	mov	r9,0
80003934:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003936:	fe f6 02 52 	ld.w	r6,pc[594]
8000393a:	6c 0c       	ld.w	r12,r6[0x0]
8000393c:	f0 1f 00 9e 	mcall	80003bb4 <phy_rx_func+0xb84>
							AMBE_payload_ptr = get_payload_idle_isr();
80003940:	fe f8 02 44 	ld.w	r8,pc[580]
80003944:	70 0c       	ld.w	r12,r8[0x0]
80003946:	f0 1f 00 8a 	mcall	80003b6c <phy_rx_func+0xb3c>
8000394a:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000394c:	c0 71       	brne	8000395a <phy_rx_func+0x92a>
							{
								RxMediaState = WAITINGABAB;
8000394e:	30 09       	mov	r9,0
80003950:	fe f8 02 3c 	ld.w	r8,pc[572]
80003954:	91 09       	st.w	r8[0x0],r9
80003956:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000395a:	fe f9 02 3a 	ld.w	r9,pc[570]
8000395e:	72 08       	ld.w	r8,r9[0x0]
80003960:	20 18       	sub	r8,1
80003962:	93 08       	st.w	r9[0x0],r8
80003964:	c0 71       	brne	80003972 <phy_rx_func+0x942>
							RxMediaState = WAITINGABAB;
80003966:	30 09       	mov	r9,0
80003968:	fe f8 02 24 	ld.w	r8,pc[548]
8000396c:	91 09       	st.w	r8[0x0],r9
8000396e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//5
80003972:	fe f8 02 3a 	ld.w	r8,pc[570]
80003976:	fe f9 02 12 	ld.w	r9,pc[530]
8000397a:	72 0a       	ld.w	r10,r9[0x0]
8000397c:	70 09       	ld.w	r9,r8[0x0]
8000397e:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003982:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003986:	70 09       	ld.w	r9,r8[0x0]
80003988:	2f f9       	sub	r9,-1
8000398a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000398c:	e0 49 01 ff 	cp.w	r9,511
80003990:	e0 88 00 13 	brls	800039b6 <phy_rx_func+0x986>
						{
							RxAMBE_IsFillingNext8 = 0;
80003994:	30 09       	mov	r9,0
80003996:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003998:	4f c6       	lddpc	r6,80003b88 <phy_rx_func+0xb58>
8000399a:	6c 0c       	ld.w	r12,r6[0x0]
8000399c:	f0 1f 00 86 	mcall	80003bb4 <phy_rx_func+0xb84>
							AMBE_payload_ptr = get_payload_idle_isr();
800039a0:	4f 98       	lddpc	r8,80003b84 <phy_rx_func+0xb54>
800039a2:	70 0c       	ld.w	r12,r8[0x0]
800039a4:	f0 1f 00 72 	mcall	80003b6c <phy_rx_func+0xb3c>
800039a8:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039aa:	c0 61       	brne	800039b6 <phy_rx_func+0x986>
							{
								RxMediaState = WAITINGABAB;
800039ac:	30 09       	mov	r9,0
800039ae:	4f 88       	lddpc	r8,80003b8c <phy_rx_func+0xb5c>
800039b0:	91 09       	st.w	r8[0x0],r9
800039b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039b6:	4f 89       	lddpc	r9,80003b94 <phy_rx_func+0xb64>
800039b8:	72 08       	ld.w	r8,r9[0x0]
800039ba:	20 18       	sub	r8,1
800039bc:	93 08       	st.w	r9[0x0],r8
800039be:	c0 61       	brne	800039ca <phy_rx_func+0x99a>
							RxMediaState = WAITINGABAB;
800039c0:	30 09       	mov	r9,0
800039c2:	4f 38       	lddpc	r8,80003b8c <phy_rx_func+0xb5c>
800039c4:	91 09       	st.w	r8[0x0],r9
800039c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//6
800039ca:	4f 98       	lddpc	r8,80003bac <phy_rx_func+0xb7c>
800039cc:	4e f9       	lddpc	r9,80003b88 <phy_rx_func+0xb58>
800039ce:	72 0a       	ld.w	r10,r9[0x0]
800039d0:	70 09       	ld.w	r9,r8[0x0]
800039d2:	ef 3b 00 0d 	ld.ub	r11,r7[13]
800039d6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039da:	70 09       	ld.w	r9,r8[0x0]
800039dc:	2f f9       	sub	r9,-1
800039de:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039e0:	e0 49 01 ff 	cp.w	r9,511
800039e4:	e0 88 00 13 	brls	80003a0a <phy_rx_func+0x9da>
						{
							RxAMBE_IsFillingNext8 = 0;
800039e8:	30 09       	mov	r9,0
800039ea:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039ec:	4e 76       	lddpc	r6,80003b88 <phy_rx_func+0xb58>
800039ee:	6c 0c       	ld.w	r12,r6[0x0]
800039f0:	f0 1f 00 71 	mcall	80003bb4 <phy_rx_func+0xb84>
							AMBE_payload_ptr = get_payload_idle_isr();
800039f4:	4e 48       	lddpc	r8,80003b84 <phy_rx_func+0xb54>
800039f6:	70 0c       	ld.w	r12,r8[0x0]
800039f8:	f0 1f 00 5d 	mcall	80003b6c <phy_rx_func+0xb3c>
800039fc:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039fe:	c0 61       	brne	80003a0a <phy_rx_func+0x9da>
							{
								RxMediaState = WAITINGABAB;
80003a00:	30 09       	mov	r9,0
80003a02:	4e 38       	lddpc	r8,80003b8c <phy_rx_func+0xb5c>
80003a04:	91 09       	st.w	r8[0x0],r9
80003a06:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a0a:	4e 39       	lddpc	r9,80003b94 <phy_rx_func+0xb64>
80003a0c:	72 08       	ld.w	r8,r9[0x0]
80003a0e:	20 18       	sub	r8,1
80003a10:	93 08       	st.w	r9[0x0],r8
80003a12:	c0 61       	brne	80003a1e <phy_rx_func+0x9ee>
							RxMediaState = WAITINGABAB;
80003a14:	30 09       	mov	r9,0
80003a16:	4d e8       	lddpc	r8,80003b8c <phy_rx_func+0xb5c>
80003a18:	91 09       	st.w	r8[0x0],r9
80003a1a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//7
80003a1e:	4e 48       	lddpc	r8,80003bac <phy_rx_func+0xb7c>
80003a20:	4d a9       	lddpc	r9,80003b88 <phy_rx_func+0xb58>
80003a22:	72 0a       	ld.w	r10,r9[0x0]
80003a24:	70 09       	ld.w	r9,r8[0x0]
80003a26:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003a2a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a2e:	70 09       	ld.w	r9,r8[0x0]
80003a30:	2f f9       	sub	r9,-1
80003a32:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a34:	e0 49 01 ff 	cp.w	r9,511
80003a38:	e0 88 00 13 	brls	80003a5e <phy_rx_func+0xa2e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a3c:	30 09       	mov	r9,0
80003a3e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a40:	4d 27       	lddpc	r7,80003b88 <phy_rx_func+0xb58>
80003a42:	6e 0c       	ld.w	r12,r7[0x0]
80003a44:	f0 1f 00 5c 	mcall	80003bb4 <phy_rx_func+0xb84>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a48:	4c f8       	lddpc	r8,80003b84 <phy_rx_func+0xb54>
80003a4a:	70 0c       	ld.w	r12,r8[0x0]
80003a4c:	f0 1f 00 48 	mcall	80003b6c <phy_rx_func+0xb3c>
80003a50:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a52:	c0 61       	brne	80003a5e <phy_rx_func+0xa2e>
							{
								RxMediaState = WAITINGABAB;
80003a54:	30 09       	mov	r9,0
80003a56:	4c e8       	lddpc	r8,80003b8c <phy_rx_func+0xb5c>
80003a58:	91 09       	st.w	r8[0x0],r9
80003a5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a5e:	4c e9       	lddpc	r9,80003b94 <phy_rx_func+0xb64>
80003a60:	72 08       	ld.w	r8,r9[0x0]
80003a62:	20 18       	sub	r8,1
80003a64:	93 08       	st.w	r9[0x0],r8
80003a66:	c0 61       	brne	80003a72 <phy_rx_func+0xa42>
							RxMediaState = WAITINGABAB;
80003a68:	30 09       	mov	r9,0
80003a6a:	4c 98       	lddpc	r8,80003b8c <phy_rx_func+0xb5c>
80003a6c:	91 09       	st.w	r8[0x0],r9
80003a6e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003a72:	20 18       	sub	r8,1
80003a74:	4c 89       	lddpc	r9,80003b94 <phy_rx_func+0xb64>
80003a76:	93 08       	st.w	r9[0x0],r8
80003a78:	58 08       	cp.w	r8,0
80003a7a:	c6 a1       	brne	80003b4e <phy_rx_func+0xb1e>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003a7c:	30 09       	mov	r9,0
80003a7e:	4c 48       	lddpc	r8,80003b8c <phy_rx_func+0xb5c>
80003a80:	91 09       	st.w	r8[0x0],r9
80003a82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003a86:	4c 88       	lddpc	r8,80003ba4 <phy_rx_func+0xb74>
80003a88:	11 89       	ld.ub	r9,r8[0x0]
80003a8a:	30 48       	mov	r8,4
80003a8c:	f0 09 18 00 	cp.b	r9,r8
80003a90:	c0 70       	breq	80003a9e <phy_rx_func+0xa6e>
80003a92:	4c 58       	lddpc	r8,80003ba4 <phy_rx_func+0xb74>
80003a94:	11 89       	ld.ub	r9,r8[0x0]
80003a96:	30 38       	mov	r8,3
80003a98:	f0 09 18 00 	cp.b	r9,r8
80003a9c:	c1 01       	brne	80003abc <phy_rx_func+0xa8c>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003a9e:	6e 29       	ld.w	r9,r7[0x8]
80003aa0:	4c c8       	lddpc	r8,80003bd0 <phy_rx_func+0xba0>
80003aa2:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003aa4:	6e 39       	ld.w	r9,r7[0xc]
80003aa6:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003aa8:	4b b9       	lddpc	r9,80003b94 <phy_rx_func+0xb64>
80003aaa:	72 08       	ld.w	r8,r9[0x0]
80003aac:	20 88       	sub	r8,8
80003aae:	93 08       	st.w	r9[0x0],r8
80003ab0:	c4 f1       	brne	80003b4e <phy_rx_func+0xb1e>
						{
					
							RxBytesWaiting = 0;
80003ab2:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003ab4:	4b 69       	lddpc	r9,80003b8c <phy_rx_func+0xb5c>
80003ab6:	93 08       	st.w	r9[0x0],r8
80003ab8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003abc:	30 09       	mov	r9,0
80003abe:	4b 48       	lddpc	r8,80003b8c <phy_rx_func+0xb5c>
80003ac0:	91 09       	st.w	r8[0x0],r9
80003ac2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003ac6:	4c 18       	lddpc	r8,80003bc8 <phy_rx_func+0xb98>
80003ac8:	70 09       	ld.w	r9,r8[0x0]
80003aca:	8e 4b       	ld.sh	r11,r7[0x8]
80003acc:	4c 0a       	lddpc	r10,80003bcc <phy_rx_func+0xb9c>
80003ace:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003ad2:	2f f9       	sub	r9,-1
80003ad4:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003ad6:	4b 58       	lddpc	r8,80003ba8 <phy_rx_func+0xb78>
80003ad8:	70 09       	ld.w	r9,r8[0x0]
80003ada:	20 29       	sub	r9,2
80003adc:	91 09       	st.w	r8[0x0],r9
80003ade:	70 08       	ld.w	r8,r8[0x0]
80003ae0:	58 08       	cp.w	r8,0
80003ae2:	c3 01       	brne	80003b42 <phy_rx_func+0xb12>
				{
					RxData_IsFillingNext16 = 0;
80003ae4:	30 09       	mov	r9,0
80003ae6:	4b 98       	lddpc	r8,80003bc8 <phy_rx_func+0xb98>
80003ae8:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003aea:	8e 59       	ld.sh	r9,r7[0xa]
80003aec:	fe 78 82 12 	mov	r8,-32238
80003af0:	f0 09 19 00 	cp.h	r9,r8
80003af4:	c2 21       	brne	80003b38 <phy_rx_func+0xb08>
				
					if (payload_rx_channel->word[1] == 0x8212 )
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						VF_SN = payload_rx_channel->byte[5];//This parameter is very important to the loop back Radio, as a reference.
80003af6:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003afa:	4b 08       	lddpc	r8,80003bb8 <phy_rx_func+0xb88>
80003afc:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003afe:	8e 59       	ld.sh	r9,r7[0xa]
80003b00:	4a f8       	lddpc	r8,80003bbc <phy_rx_func+0xb8c>
80003b02:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003b04:	8e 69       	ld.sh	r9,r7[0xc]
80003b06:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003b08:	f0 1f 00 2e 	mcall	80003bc0 <phy_rx_func+0xb90>
80003b0c:	4a 18       	lddpc	r8,80003b90 <phy_rx_func+0xb60>
80003b0e:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003b10:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003b14:	3f 38       	mov	r8,-13
80003b16:	f0 09 18 00 	cp.b	r9,r8
80003b1a:	c0 a1       	brne	80003b2e <phy_rx_func+0xafe>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Pre_Voice_Decoder_Data)//0xF3
						{
							Item_ID = Pre_Voice_Decoder_Data;
80003b1c:	10 99       	mov	r9,r8
80003b1e:	4a 28       	lddpc	r8,80003ba4 <phy_rx_func+0xb74>
80003b20:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 8
80003b22:	30 09       	mov	r9,0
80003b24:	49 c8       	lddpc	r8,80003b94 <phy_rx_func+0xb64>
80003b26:	91 09       	st.w	r8[0x0],r9
							AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003b28:	30 19       	mov	r9,1
80003b2a:	4a d8       	lddpc	r8,80003bdc <phy_rx_func+0xbac>
80003b2c:	b0 89       	st.b	r8[0x0],r9
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003b2e:	30 49       	mov	r9,4
80003b30:	49 78       	lddpc	r8,80003b8c <phy_rx_func+0xb5c>
80003b32:	91 09       	st.w	r8[0x0],r9
80003b34:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003b38:	30 09       	mov	r9,0
80003b3a:	49 58       	lddpc	r8,80003b8c <phy_rx_func+0xb5c>
80003b3c:	91 09       	st.w	r8[0x0],r9
80003b3e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003b42:	4a 8c       	lddpc	r12,80003be0 <phy_rx_func+0xbb0>
80003b44:	f0 1f 00 16 	mcall	80003b9c <phy_rx_func+0xb6c>
					RxMediaState = WAITINGABAB;//Jump
80003b48:	30 09       	mov	r9,0
80003b4a:	49 18       	lddpc	r8,80003b8c <phy_rx_func+0xb5c>
80003b4c:	91 09       	st.w	r8[0x0],r9
80003b4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003b52:	00 00       	add	r0,r0
80003b54:	00 00       	add	r0,r0
80003b56:	0a ac       	st.w	r5++,r12
80003b58:	00 00       	add	r0,r0
80003b5a:	0a a4       	st.w	r5++,r4
80003b5c:	00 00       	add	r0,r0
80003b5e:	0a 64       	and	r4,r5
80003b60:	00 00       	add	r0,r0
80003b62:	0a 5c       	eor	r12,r5
80003b64:	00 00       	add	r0,r0
80003b66:	0a c8       	st.b	r5++,r8
80003b68:	00 00       	add	r0,r0
80003b6a:	0a 94       	mov	r4,r5
80003b6c:	80 00       	ld.sh	r0,r0[0x0]
80003b6e:	2a ec       	sub	r12,-82
80003b70:	00 00       	add	r0,r0
80003b72:	0a 70       	tst	r0,r5
80003b74:	80 00       	ld.sh	r0,r0[0x0]
80003b76:	52 24       	stdsp	sp[0x88],r4
80003b78:	00 00       	add	r0,r0
80003b7a:	0a c0       	st.b	r5++,r0
80003b7c:	80 00       	ld.sh	r0,r0[0x0]
80003b7e:	2a 38       	sub	r8,-93
80003b80:	00 00       	add	r0,r0
80003b82:	0a 6c       	and	r12,r5
80003b84:	00 00       	add	r0,r0
80003b86:	0a 88       	andn	r8,r5
80003b88:	00 00       	add	r0,r0
80003b8a:	0a 9c       	mov	r12,r5
80003b8c:	00 00       	add	r0,r0
80003b8e:	0a b4       	st.h	r5++,r4
80003b90:	00 00       	add	r0,r0
80003b92:	0a 68       	and	r8,r5
80003b94:	00 00       	add	r0,r0
80003b96:	0a c4       	st.b	r5++,r4
80003b98:	80 00       	ld.sh	r0,r0[0x0]
80003b9a:	cf d4       	brge	80003b94 <phy_rx_func+0xb64>
80003b9c:	80 00       	ld.sh	r0,r0[0x0]
80003b9e:	63 1c       	ld.w	r12,r1[0x44]
80003ba0:	00 00       	add	r0,r0
80003ba2:	0a 47       	or	r7,r5
80003ba4:	00 00       	add	r0,r0
80003ba6:	0a c2       	st.b	r5++,r2
80003ba8:	00 00       	add	r0,r0
80003baa:	0a bc       	st.h	r5++,r12
80003bac:	00 00       	add	r0,r0
80003bae:	0a 60       	and	r0,r5
80003bb0:	80 00       	ld.sh	r0,r0[0x0]
80003bb2:	6c 38       	ld.w	r8,r6[0xc]
80003bb4:	80 00       	ld.sh	r0,r0[0x0]
80003bb6:	2f d0       	sub	r0,-3
80003bb8:	00 00       	add	r0,r0
80003bba:	0a 48       	or	r8,r5
80003bbc:	00 00       	add	r0,r0
80003bbe:	0e a0       	st.w	r7++,r0
80003bc0:	80 00       	ld.sh	r0,r0[0x0]
80003bc2:	29 7c       	sub	r12,-105
80003bc4:	80 00       	ld.sh	r0,r0[0x0]
80003bc6:	cf ec       	rcall	80003dc2 <xcmp_tx+0x32>
80003bc8:	00 00       	add	r0,r0
80003bca:	0a 80       	andn	r0,r5
80003bcc:	00 00       	add	r0,r0
80003bce:	0d a4       	ld.ub	r4,r6[0x2]
80003bd0:	00 00       	add	r0,r0
80003bd2:	0a 8c       	andn	r12,r5
80003bd4:	00 00       	add	r0,r0
80003bd6:	0a 44       	or	r4,r5
80003bd8:	00 00       	add	r0,r0
80003bda:	0d 9c       	ld.ub	r12,r6[0x1]
80003bdc:	00 00       	add	r0,r0
80003bde:	0a 3c       	cp.w	r12,r5
80003be0:	80 00       	ld.sh	r0,r0[0x0]
80003be2:	d0 00       	acall	0x0

80003be4 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003be4:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003be6:	49 88       	lddpc	r8,80003c44 <pdca_int_handler+0x60>
80003be8:	11 89       	ld.ub	r9,r8[0x0]
80003bea:	ec 19 00 01 	eorl	r9,0x1
80003bee:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003bf0:	11 89       	ld.ub	r9,r8[0x0]
80003bf2:	a5 69       	lsl	r9,0x4
80003bf4:	2f c9       	sub	r9,-4
80003bf6:	49 5a       	lddpc	r10,80003c48 <pdca_int_handler+0x64>
80003bf8:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003bfa:	fe 7a 00 40 	mov	r10,-65472
80003bfe:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003c00:	30 39       	mov	r9,3
80003c02:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003c04:	11 8a       	ld.ub	r10,r8[0x0]
80003c06:	a5 6a       	lsl	r10,0x4
80003c08:	2f ca       	sub	r10,-4
80003c0a:	49 18       	lddpc	r8,80003c4c <pdca_int_handler+0x68>
80003c0c:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003c0e:	fe 78 00 00 	mov	r8,-65536
80003c12:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003c14:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003c16:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003c18:	48 e8       	lddpc	r8,80003c50 <pdca_int_handler+0x6c>
80003c1a:	70 08       	ld.w	r8,r8[0x0]
80003c1c:	58 08       	cp.w	r8,0
80003c1e:	c0 70       	breq	80003c2c <pdca_int_handler+0x48>
80003c20:	48 99       	lddpc	r9,80003c44 <pdca_int_handler+0x60>
80003c22:	13 89       	ld.ub	r9,r9[0x0]
80003c24:	a5 69       	lsl	r9,0x4
80003c26:	48 ac       	lddpc	r12,80003c4c <pdca_int_handler+0x68>
80003c28:	12 0c       	add	r12,r9
80003c2a:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003c2c:	48 a8       	lddpc	r8,80003c54 <pdca_int_handler+0x70>
80003c2e:	70 08       	ld.w	r8,r8[0x0]
80003c30:	58 08       	cp.w	r8,0
80003c32:	c0 70       	breq	80003c40 <pdca_int_handler+0x5c>
80003c34:	48 49       	lddpc	r9,80003c44 <pdca_int_handler+0x60>
80003c36:	13 89       	ld.ub	r9,r9[0x0]
80003c38:	a5 69       	lsl	r9,0x4
80003c3a:	48 4c       	lddpc	r12,80003c48 <pdca_int_handler+0x64>
80003c3c:	12 0c       	add	r12,r9
80003c3e:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003c40:	d4 02       	popm	lr
80003c42:	d6 03       	rete
80003c44:	00 00       	add	r0,r0
80003c46:	40 a8       	lddsp	r8,sp[0x28]
80003c48:	00 00       	add	r0,r0
80003c4a:	40 d0       	lddsp	r0,sp[0x34]
80003c4c:	00 00       	add	r0,r0
80003c4e:	40 b0       	lddsp	r0,sp[0x2c]
80003c50:	00 00       	add	r0,r0
80003c52:	0a cc       	st.b	r5++,r12
80003c54:	00 00       	add	r0,r0
80003c56:	0a d0       	st.w	--r5,r0

80003c58 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003c58:	fe 78 10 00 	mov	r8,-61440
80003c5c:	e0 69 0d c0 	mov	r9,3520
80003c60:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003c64:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003c68:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003c6c:	fe 78 34 00 	mov	r8,-52224
80003c70:	e0 69 80 00 	mov	r9,32768
80003c74:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003c76:	30 09       	mov	r9,0
80003c78:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003c7a:	e0 69 04 21 	mov	r9,1057
80003c7e:	ea 19 3f 20 	orh	r9,0x3f20
80003c82:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80003c84:	e0 69 02 9f 	mov	r9,671
80003c88:	ea 19 01 00 	orh	r9,0x100
80003c8c:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80003c8e:	e0 6a 04 02 	mov	r10,1026
80003c92:	ea 1a 3f 20 	orh	r10,0x3f20
80003c96:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80003c98:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003c9a:	5e fc       	retal	r12

80003c9c <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003c9c:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003c9e:	30 19       	mov	r9,1
80003ca0:	49 78       	lddpc	r8,80003cfc <local_start_PDC+0x60>
80003ca2:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003ca4:	fe 78 00 00 	mov	r8,-65536
80003ca8:	30 7b       	mov	r11,7
80003caa:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003cac:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003cae:	49 59       	lddpc	r9,80003d00 <local_start_PDC+0x64>
80003cb0:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003cb4:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003cb6:	30 3a       	mov	r10,3
80003cb8:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003cba:	30 1c       	mov	r12,1
80003cbc:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003cbe:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003cc0:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003cc2:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003cc4:	30 2c       	mov	r12,2
80003cc6:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003cc8:	48 f9       	lddpc	r9,80003d04 <local_start_PDC+0x68>
80003cca:	e0 68 5a 5a 	mov	r8,23130
80003cce:	ea 18 ab cd 	orh	r8,0xabcd
80003cd2:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003cd4:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003cd6:	30 0e       	mov	lr,0
80003cd8:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003cda:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003cdc:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003cde:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003ce0:	fe 78 00 40 	mov	r8,-65472
80003ce4:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003ce6:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003ce8:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003cec:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003cee:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003cf0:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003cf2:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003cf4:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003cf6:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003cf8:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003cfa:	d8 02       	popm	pc
80003cfc:	00 00       	add	r0,r0
80003cfe:	40 a8       	lddsp	r8,sp[0x28]
80003d00:	00 00       	add	r0,r0
80003d02:	40 b0       	lddsp	r0,sp[0x2c]
80003d04:	00 00       	add	r0,r0
80003d06:	40 d0       	lddsp	r0,sp[0x34]

80003d08 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003d08:	48 38       	lddpc	r8,80003d14 <register_rx_tx_func+0xc>
80003d0a:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003d0c:	48 38       	lddpc	r8,80003d18 <register_rx_tx_func+0x10>
80003d0e:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003d10:	5e fc       	retal	r12
80003d12:	00 00       	add	r0,r0
80003d14:	00 00       	add	r0,r0
80003d16:	0a cc       	st.b	r5++,r12
80003d18:	00 00       	add	r0,r0
80003d1a:	0a d0       	st.w	--r5,r0

80003d1c <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003d1c:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003d1e:	fe 78 10 00 	mov	r8,-61440
80003d22:	30 29       	mov	r9,2
80003d24:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003d28:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003d2c:	10 99       	mov	r9,r8
80003d2e:	f2 f8 01 60 	ld.w	r8,r9[352]
80003d32:	e2 18 00 02 	andl	r8,0x2,COH
80003d36:	cf c0       	breq	80003d2e <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003d38:	fe 79 10 00 	mov	r9,-61440
80003d3c:	f2 f8 01 60 	ld.w	r8,r9[352]
80003d40:	e2 18 00 02 	andl	r8,0x2,COH
80003d44:	cf c1       	brne	80003d3c <ssc_init+0x20>
				
    INTC_register_interrupt (
80003d46:	30 3a       	mov	r10,3
80003d48:	36 0b       	mov	r11,96
80003d4a:	48 bc       	lddpc	r12,80003d74 <ssc_init+0x58>
80003d4c:	f0 1f 00 0b 	mcall	80003d78 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80003d50:	f0 1f 00 0b 	mcall	80003d7c <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80003d54:	f0 1f 00 0b 	mcall	80003d80 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003d58:	fe 79 00 00 	mov	r9,-65536
80003d5c:	30 18       	mov	r8,1
80003d5e:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003d60:	fe 7a 00 40 	mov	r10,-65472
80003d64:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003d66:	e0 6b 01 01 	mov	r11,257
80003d6a:	fe 7a 34 00 	mov	r10,-52224
80003d6e:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80003d70:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80003d72:	d8 02       	popm	pc
80003d74:	80 00       	ld.sh	r0,r0[0x0]
80003d76:	3b e4       	mov	r4,-66
80003d78:	80 00       	ld.sh	r0,r0[0x0]
80003d7a:	48 5c       	lddpc	r12,80003d8c <xcmp_register_app_list+0x8>
80003d7c:	80 00       	ld.sh	r0,r0[0x0]
80003d7e:	3c 58       	mov	r8,-59
80003d80:	80 00       	ld.sh	r0,r0[0x0]
80003d82:	3c 9c       	mov	r12,-55

80003d84 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003d84:	48 28       	lddpc	r8,80003d8c <xcmp_register_app_list+0x8>
80003d86:	91 0c       	st.w	r8[0x0],r12
}
80003d88:	5e fc       	retal	r12
80003d8a:	00 00       	add	r0,r0
80003d8c:	00 00       	add	r0,r0
80003d8e:	40 f0       	lddsp	r0,sp[0x3c]

80003d90 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003d90:	eb cd 40 80 	pushm	r7,lr
80003d94:	fa cd 01 00 	sub	sp,sp,256
80003d98:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003d9a:	16 98       	mov	r8,r11
80003d9c:	2f 08       	sub	r8,-16
80003d9e:	af a8       	sbr	r8,0xe
80003da0:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003da2:	3f f8       	mov	r8,-1
80003da4:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003da6:	30 b9       	mov	r9,11
80003da8:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003daa:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003dac:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003dae:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003db0:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003db2:	f6 ca ff fe 	sub	r10,r11,-2
80003db6:	18 9b       	mov	r11,r12
80003db8:	fa cc ff f0 	sub	r12,sp,-16
80003dbc:	f0 1f 00 05 	mcall	80003dd0 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003dc0:	2f e7       	sub	r7,-2
80003dc2:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003dc4:	1a 9c       	mov	r12,sp
80003dc6:	f0 1f 00 04 	mcall	80003dd4 <xcmp_tx+0x44>
}
80003dca:	2c 0d       	sub	sp,-256
80003dcc:	e3 cd 80 80 	ldm	sp++,r7,pc
80003dd0:	80 00       	ld.sh	r0,r0[0x0]
80003dd2:	6a f0       	ld.w	r0,r5[0x3c]
80003dd4:	80 00       	ld.sh	r0,r0[0x0]
80003dd6:	42 c0       	lddsp	r0,sp[0xb0]

80003dd8 <xcmp_exit_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_exit_device_control_mode(void)
{
80003dd8:	d4 01       	pushm	lr
80003dda:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
80003dde:	e0 68 04 21 	mov	r8,1057
80003de2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
80003de4:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_EXIT;
80003de8:	30 09       	mov	r9,0
80003dea:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
80003dec:	30 19       	mov	r9,1
80003dee:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;//DCM_SPEAKER_CTRL;
80003df0:	30 39       	mov	r9,3
80003df2:	b0 a9       	st.b	r8[0x2],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80003df4:	30 3b       	mov	r11,3
80003df6:	fa cc ff fe 	sub	r12,sp,-2
80003dfa:	f0 1f 00 03 	mcall	80003e04 <xcmp_exit_device_control_mode+0x2c>
}
80003dfe:	2c dd       	sub	sp,-204
80003e00:	d8 02       	popm	pc
80003e02:	00 00       	add	r0,r0
80003e04:	80 00       	ld.sh	r0,r0[0x0]
80003e06:	3d 90       	mov	r0,-39

80003e08 <xcmp_enter_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_device_control_mode(void)
{
80003e08:	d4 01       	pushm	lr
80003e0a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
80003e0e:	e0 68 04 21 	mov	r8,1057
80003e12:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
80003e14:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_ENTER;
80003e18:	30 19       	mov	r9,1
80003e1a:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
80003e1c:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;// 0xEB;//user-input
80003e1e:	30 39       	mov	r9,3
80003e20:	b0 a9       	st.b	r8[0x2],r9
	//ptr->ControlType = DCM_SPEAKER_CTRL;
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80003e22:	30 3b       	mov	r11,3
80003e24:	fa cc ff fe 	sub	r12,sp,-2
80003e28:	f0 1f 00 02 	mcall	80003e30 <xcmp_enter_device_control_mode+0x28>
}
80003e2c:	2c dd       	sub	sp,-204
80003e2e:	d8 02       	popm	pc
80003e30:	80 00       	ld.sh	r0,r0[0x0]
80003e32:	3d 90       	mov	r0,-39

80003e34 <xcmp_audio_route_AMBE>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_audio_route_AMBE(void)
{
80003e34:	d4 01       	pushm	lr
80003e36:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
80003e3a:	e0 68 04 14 	mov	r8,1044
80003e3e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
80003e40:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = Routing_Func_Update_Source;
80003e44:	30 19       	mov	r9,1
80003e46:	b0 89       	st.b	r8[0x0],r9
	
	
	unsigned short NumberofRoutings = 6;//4;//2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
80003e48:	30 09       	mov	r9,0
80003e4a:	b0 99       	st.b	r8[0x1],r9
	ptr->NumberofRoutings[1] =  NumberofRoutings & 0xFF;
80003e4c:	30 69       	mov	r9,6
80003e4e:	b0 a9       	st.b	r8[0x2],r9
	
	//ptr->RoutingData[0].audioInput = IN_Microphone;//Post_AMBE_Encoder;//IN_Pre_Speaker_Audio_Data;//IN_Microphone;//IN_Option_Board;
	//ptr->RoutingData[0].audioOutput = OUT_Option_Board;//Post_AMBE_Encoder;//OUT_Microphone_Data;//测试
	//注意：经测试发现，这里的路径配置，需要特别注意先后顺序，否则会提示参数错误。
	ptr->RoutingData[0].audioInput = Post_AMBE_Encoder;//IN_Option_Board;
80003e50:	30 fa       	mov	r10,15
80003e52:	b0 ba       	st.b	r8[0x3],r10
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;// OUT_Speaker;
80003e54:	30 c9       	mov	r9,12
80003e56:	b0 c9       	st.b	r8[0x4],r9
	ptr->RoutingData[1].audioInput = IN_Option_Board;//IN_Option_Board;
80003e58:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = Post_AMBE_Encoder;// OUT_Speaker;
80003e5a:	b0 ea       	st.b	r8[0x6],r10
	
	ptr->RoutingData[2].audioInput = Pre_AMBE_Decoder;//IN_Option_Board;
80003e5c:	31 0a       	mov	r10,16
80003e5e:	b0 fa       	st.b	r8[0x7],r10
	ptr->RoutingData[2].audioOutput = OUT_Option_Board;// OUT_Speaker;
80003e60:	f1 69 00 08 	st.b	r8[8],r9
	ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
80003e64:	f1 69 00 09 	st.b	r8[9],r9
	ptr->RoutingData[3].audioOutput = Pre_AMBE_Decoder;// OUT_Speaker;
80003e68:	f1 6a 00 0a 	st.b	r8[10],r10

	
	ptr->RoutingData[4].audioInput = Tx_Voice_Header;//IN_Option_Board;
80003e6c:	31 1a       	mov	r10,17
80003e6e:	f1 6a 00 0b 	st.b	r8[11],r10
	ptr->RoutingData[4].audioOutput = OUT_Option_Board;// OUT_Speaker;
80003e72:	f1 69 00 0c 	st.b	r8[12],r9
	//ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
	//ptr->RoutingData[3].audioOutput = Tx_Voice_Header;// OUT_Speaker;
	
	ptr->RoutingData[5].audioInput = Tx_Voice_Terminator;//IN_Option_Board;
80003e76:	31 3a       	mov	r10,19
80003e78:	f1 6a 00 0d 	st.b	r8[13],r10
	ptr->RoutingData[5].audioOutput = OUT_Option_Board;// OUT_Speaker;
80003e7c:	f1 69 00 0e 	st.b	r8[14],r9
	
	//ptr->RoutingData[1].audioInput = IN_Option_Board;
	//ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;//测试OUT_Speaker;//
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
80003e80:	30 fb       	mov	r11,15
80003e82:	fa cc ff fe 	sub	r12,sp,-2
80003e86:	f0 1f 00 03 	mcall	80003e90 <xcmp_audio_route_AMBE+0x5c>
}
80003e8a:	2c dd       	sub	sp,-204
80003e8c:	d8 02       	popm	pc
80003e8e:	00 00       	add	r0,r0
80003e90:	80 00       	ld.sh	r0,r0[0x0]
80003e92:	3d 90       	mov	r0,-39

80003e94 <xcmp_enter_enhanced_OB_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_enhanced_OB_mode(void)
{
80003e94:	d4 01       	pushm	lr
80003e96:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | EN_OB_CONTROL;
80003e9a:	e0 68 04 65 	mov	r8,1125
80003e9e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	En_OB_Control_req_t * ptr = (En_OB_Control_req_t *)xcmp_farme.u8;
	
	ptr->Function = EN_OB_Enter;
80003ea0:	fa cc ff fe 	sub	r12,sp,-2
80003ea4:	30 18       	mov	r8,1
80003ea6:	b8 a8       	st.b	r12[0x2],r8
		
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(En_OB_Control_req_t));
80003ea8:	30 1b       	mov	r11,1
80003eaa:	f0 1f 00 03 	mcall	80003eb4 <xcmp_enter_enhanced_OB_mode+0x20>
}
80003eae:	2c dd       	sub	sp,-204
80003eb0:	d8 02       	popm	pc
80003eb2:	00 00       	add	r0,r0
80003eb4:	80 00       	ld.sh	r0,r0[0x0]
80003eb6:	3d 90       	mov	r0,-39

80003eb8 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003eb8:	d4 01       	pushm	lr
80003eba:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003ebe:	fe 78 b4 00 	mov	r8,-19456
80003ec2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003ec4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003ec8:	30 89       	mov	r9,8
80003eca:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003ecc:	30 19       	mov	r9,1
80003ece:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003ed0:	30 09       	mov	r9,0
80003ed2:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003ed4:	30 5a       	mov	r10,5
80003ed6:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003ed8:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003eda:	30 7a       	mov	r10,7
80003edc:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003ede:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003ee0:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003ee2:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003ee6:	30 9b       	mov	r11,9
80003ee8:	fa cc ff fe 	sub	r12,sp,-2
80003eec:	f0 1f 00 02 	mcall	80003ef4 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003ef0:	2c dd       	sub	sp,-204
80003ef2:	d8 02       	popm	pc
80003ef4:	80 00       	ld.sh	r0,r0[0x0]
80003ef6:	3d 90       	mov	r0,-39

80003ef8 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003ef8:	d4 01       	pushm	lr
80003efa:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003efe:	fe 78 80 00 	mov	r8,-32768
80003f02:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003f04:	30 38       	mov	r8,3
80003f06:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003f08:	30 1b       	mov	r11,1
80003f0a:	fa cc ff fe 	sub	r12,sp,-2
80003f0e:	f0 1f 00 03 	mcall	80003f18 <xcmp_opcode_not_supported+0x20>
}
80003f12:	2c dd       	sub	sp,-204
80003f14:	d8 02       	popm	pc
80003f16:	00 00       	add	r0,r0
80003f18:	80 00       	ld.sh	r0,r0[0x0]
80003f1a:	3d 90       	mov	r0,-39

80003f1c <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003f1c:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003f1e:	96 88       	ld.uh	r8,r11[0x0]
80003f20:	e2 18 f0 00 	andl	r8,0xf000,COH
80003f24:	e0 48 80 00 	cp.w	r8,32768
80003f28:	c0 f0       	breq	80003f46 <xcmp_exec_func+0x2a>
80003f2a:	e0 48 b0 00 	cp.w	r8,45056
80003f2e:	c1 20       	breq	80003f52 <xcmp_exec_func+0x36>
80003f30:	58 08       	cp.w	r8,0
80003f32:	c1 51       	brne	80003f5c <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003f34:	78 08       	ld.w	r8,r12[0x0]
80003f36:	58 08       	cp.w	r8,0
80003f38:	c0 40       	breq	80003f40 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003f3a:	16 9c       	mov	r12,r11
80003f3c:	5d 18       	icall	r8
80003f3e:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80003f40:	f0 1f 00 08 	mcall	80003f60 <xcmp_exec_func+0x44>
80003f44:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003f46:	78 18       	ld.w	r8,r12[0x4]
80003f48:	58 08       	cp.w	r8,0
80003f4a:	c0 90       	breq	80003f5c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003f4c:	16 9c       	mov	r12,r11
80003f4e:	5d 18       	icall	r8
80003f50:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003f52:	78 28       	ld.w	r8,r12[0x8]
80003f54:	58 08       	cp.w	r8,0
80003f56:	c0 30       	breq	80003f5c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003f58:	16 9c       	mov	r12,r11
80003f5a:	5d 18       	icall	r8
80003f5c:	d8 02       	popm	pc
80003f5e:	00 00       	add	r0,r0
80003f60:	80 00       	ld.sh	r0,r0[0x0]
80003f62:	3e f8       	mov	r8,-17

80003f64 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80003f64:	d4 01       	pushm	lr
80003f66:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003f6a:	e0 68 04 09 	mov	r8,1033
80003f6e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003f70:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80003f74:	30 19       	mov	r9,1
80003f76:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
80003f78:	30 09       	mov	r9,0
80003f7a:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
80003f7c:	30 ca       	mov	r10,12
80003f7e:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003f80:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003f82:	fb 69 00 08 	st.b	sp[8],r9
80003f86:	fa c8 ff f7 	sub	r8,sp,-9
80003f8a:	b0 89       	st.b	r8[0x0],r9
80003f8c:	fa c8 ff f6 	sub	r8,sp,-10
80003f90:	b0 89       	st.b	r8[0x0],r9
80003f92:	fa c8 ff f5 	sub	r8,sp,-11
80003f96:	b0 89       	st.b	r8[0x0],r9
80003f98:	fa c8 ff f4 	sub	r8,sp,-12
80003f9c:	b0 89       	st.b	r8[0x0],r9
80003f9e:	fa c8 ff f3 	sub	r8,sp,-13
80003fa2:	b0 89       	st.b	r8[0x0],r9
80003fa4:	fa c8 ff f2 	sub	r8,sp,-14
80003fa8:	b0 89       	st.b	r8[0x0],r9
80003faa:	fa c8 ff f1 	sub	r8,sp,-15
80003fae:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003fb0:	30 cb       	mov	r11,12
80003fb2:	fa cc ff fe 	sub	r12,sp,-2
80003fb6:	f0 1f 00 03 	mcall	80003fc0 <xcmp_IdleTestTone+0x5c>
}
80003fba:	2c dd       	sub	sp,-204
80003fbc:	d8 02       	popm	pc
80003fbe:	00 00       	add	r0,r0
80003fc0:	80 00       	ld.sh	r0,r0[0x0]
80003fc2:	3d 90       	mov	r0,-39

80003fc4 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80003fc4:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
80003fc6:	f0 1f 00 0d 	mcall	80003ff8 <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80003fca:	48 dc       	lddpc	r12,80003ffc <xcmp_init+0x38>
80003fcc:	f0 1f 00 0d 	mcall	80004000 <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80003fd0:	30 4b       	mov	r11,4
80003fd2:	31 4c       	mov	r12,20
80003fd4:	f0 1f 00 0c 	mcall	80004004 <xcmp_init+0x40>
80003fd8:	48 c8       	lddpc	r8,80004008 <xcmp_init+0x44>
80003fda:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80003fdc:	30 09       	mov	r9,0
80003fde:	1a d9       	st.w	--sp,r9
80003fe0:	1a d9       	st.w	--sp,r9
80003fe2:	1a d9       	st.w	--sp,r9
80003fe4:	30 38       	mov	r8,3
80003fe6:	e0 6a 01 80 	mov	r10,384
80003fea:	48 9b       	lddpc	r11,8000400c <xcmp_init+0x48>
80003fec:	48 9c       	lddpc	r12,80004010 <xcmp_init+0x4c>
80003fee:	f0 1f 00 0a 	mcall	80004014 <xcmp_init+0x50>
80003ff2:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
80003ff4:	d8 02       	popm	pc
80003ff6:	00 00       	add	r0,r0
80003ff8:	80 00       	ld.sh	r0,r0[0x0]
80003ffa:	43 a4       	lddsp	r4,sp[0xe8]
80003ffc:	80 00       	ld.sh	r0,r0[0x0]
80003ffe:	41 14       	lddsp	r4,sp[0x44]
80004000:	80 00       	ld.sh	r0,r0[0x0]
80004002:	41 60       	lddsp	r0,sp[0x58]
80004004:	80 00       	ld.sh	r0,r0[0x0]
80004006:	56 f8       	stdsp	sp[0x1bc],r8
80004008:	00 00       	add	r0,r0
8000400a:	0a e0       	st.h	--r5,r0
8000400c:	80 00       	ld.sh	r0,r0[0x0]
8000400e:	d0 2c       	*unknown*
80004010:	80 00       	ld.sh	r0,r0[0x0]
80004012:	40 18       	lddsp	r8,sp[0x4]
80004014:	80 00       	ld.sh	r0,r0[0x0]
80004016:	5d cc       	*unknown*

80004018 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004018:	d4 31       	pushm	r0-r7,lr
8000401a:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000401c:	4b 16       	lddpc	r6,800040e0 <xcmp_rx_process+0xc8>
8000401e:	30 05       	mov	r5,0
80004020:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004022:	4b 13       	lddpc	r3,800040e4 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004024:	4b 12       	lddpc	r2,800040e8 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004026:	4b 21       	lddpc	r1,800040ec <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004028:	4b 20       	lddpc	r0,800040f0 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000402a:	6c 0c       	ld.w	r12,r6[0x0]
8000402c:	0a 99       	mov	r9,r5
8000402e:	08 9a       	mov	r10,r4
80004030:	1a 9b       	mov	r11,sp
80004032:	f0 1f 00 31 	mcall	800040f4 <xcmp_rx_process+0xdc>
80004036:	58 1c       	cp.w	r12,1
80004038:	cf 91       	brne	8000402a <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000403a:	40 0b       	lddsp	r11,sp[0x0]
8000403c:	58 0b       	cp.w	r11,0
8000403e:	cf 60       	breq	8000402a <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80004040:	96 0a       	ld.sh	r10,r11[0x0]
80004042:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004046:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000404a:	59 c8       	cp.w	r8,28
8000404c:	c1 e0       	breq	80004088 <xcmp_rx_process+0x70>
8000404e:	e0 89 00 07 	brgt	8000405c <xcmp_rx_process+0x44>
80004052:	58 e8       	cp.w	r8,14
80004054:	c0 e0       	breq	80004070 <xcmp_rx_process+0x58>
80004056:	58 f8       	cp.w	r8,15
80004058:	c2 41       	brne	800040a0 <xcmp_rx_process+0x88>
8000405a:	c0 f8       	rjmp	80004078 <xcmp_rx_process+0x60>
8000405c:	e0 48 01 09 	cp.w	r8,265
80004060:	c1 80       	breq	80004090 <xcmp_rx_process+0x78>
80004062:	e0 48 01 0a 	cp.w	r8,266
80004066:	c1 90       	breq	80004098 <xcmp_rx_process+0x80>
80004068:	e0 48 00 2c 	cp.w	r8,44
8000406c:	c1 a1       	brne	800040a0 <xcmp_rx_process+0x88>
8000406e:	c0 98       	rjmp	80004080 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004070:	4a 2c       	lddpc	r12,800040f8 <xcmp_rx_process+0xe0>
80004072:	f0 1f 00 23 	mcall	800040fc <xcmp_rx_process+0xe4>
					break;
80004076:	c2 f8       	rjmp	800040d4 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004078:	4a 2c       	lddpc	r12,80004100 <xcmp_rx_process+0xe8>
8000407a:	f0 1f 00 21 	mcall	800040fc <xcmp_rx_process+0xe4>
					break;
8000407e:	c2 b8       	rjmp	800040d4 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004080:	4a 1c       	lddpc	r12,80004104 <xcmp_rx_process+0xec>
80004082:	f0 1f 00 1f 	mcall	800040fc <xcmp_rx_process+0xe4>
					break;
80004086:	c2 78       	rjmp	800040d4 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004088:	04 9c       	mov	r12,r2
8000408a:	f0 1f 00 1d 	mcall	800040fc <xcmp_rx_process+0xe4>
						, ptr);
					break;
8000408e:	c2 38       	rjmp	800040d4 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004090:	02 9c       	mov	r12,r1
80004092:	f0 1f 00 1b 	mcall	800040fc <xcmp_rx_process+0xe4>
					break;
80004096:	c1 f8       	rjmp	800040d4 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004098:	00 9c       	mov	r12,r0
8000409a:	f0 1f 00 19 	mcall	800040fc <xcmp_rx_process+0xe4>
					break;
8000409e:	c1 b8       	rjmp	800040d4 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800040a0:	12 98       	mov	r8,r9
800040a2:	e2 18 04 00 	andl	r8,0x400,COH
800040a6:	c0 70       	breq	800040b4 <xcmp_rx_process+0x9c>
800040a8:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800040ac:	e0 48 00 68 	cp.w	r8,104
800040b0:	e0 8a 00 08 	brle	800040c0 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800040b4:	e2 19 f0 00 	andl	r9,0xf000,COH
800040b8:	c0 e1       	brne	800040d4 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800040ba:	f0 1f 00 14 	mcall	80004108 <xcmp_rx_process+0xf0>
800040be:	c0 b8       	rjmp	800040d4 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800040c0:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800040c4:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800040c8:	49 19       	lddpc	r9,8000410c <xcmp_rx_process+0xf4>
800040ca:	72 08       	ld.w	r8,r9[0x0]
800040cc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800040d0:	f0 1f 00 0b 	mcall	800040fc <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800040d4:	66 0c       	ld.w	r12,r3[0x0]
800040d6:	40 0b       	lddsp	r11,sp[0x0]
800040d8:	f0 1f 00 0e 	mcall	80004110 <xcmp_rx_process+0xf8>
800040dc:	ca 7b       	rjmp	8000402a <xcmp_rx_process+0x12>
800040de:	00 00       	add	r0,r0
800040e0:	00 00       	add	r0,r0
800040e2:	0a e0       	st.h	--r5,r0
800040e4:	00 00       	add	r0,r0
800040e6:	0a 94       	mov	r4,r5
800040e8:	00 00       	add	r0,r0
800040ea:	0a f0       	st.b	--r5,r0
800040ec:	00 00       	add	r0,r0
800040ee:	0a e4       	st.h	--r5,r4
800040f0:	00 00       	add	r0,r0
800040f2:	0a fc       	st.b	--r5,r12
800040f4:	80 00       	ld.sh	r0,r0[0x0]
800040f6:	53 94       	stdsp	sp[0xe4],r4
800040f8:	00 00       	add	r0,r0
800040fa:	0b 14       	ld.sh	r4,r5++
800040fc:	80 00       	ld.sh	r0,r0[0x0]
800040fe:	3f 1c       	mov	r12,-15
80004100:	00 00       	add	r0,r0
80004102:	0a d4       	st.w	--r5,r4
80004104:	00 00       	add	r0,r0
80004106:	0b 08       	ld.w	r8,r5++
80004108:	80 00       	ld.sh	r0,r0[0x0]
8000410a:	3e f8       	mov	r8,-17
8000410c:	00 00       	add	r0,r0
8000410e:	40 f0       	lddsp	r0,sp[0x3c]
80004110:	80 00       	ld.sh	r0,r0[0x0]
80004112:	2a 70       	sub	r0,-89

80004114 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004114:	eb cd 40 90 	pushm	r4,r7,lr
80004118:	20 1d       	sub	sp,4
8000411a:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000411e:	48 c8       	lddpc	r8,8000414c <xcmp_rx+0x38>
80004120:	70 0c       	ld.w	r12,r8[0x0]
80004122:	f0 1f 00 0c 	mcall	80004150 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004126:	c1 00       	breq	80004146 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004128:	fa c7 ff fc 	sub	r7,sp,-4
8000412c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000412e:	e0 6a 00 ca 	mov	r10,202
80004132:	08 9b       	mov	r11,r4
80004134:	f0 1f 00 08 	mcall	80004154 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004138:	48 88       	lddpc	r8,80004158 <xcmp_rx+0x44>
8000413a:	70 0c       	ld.w	r12,r8[0x0]
8000413c:	30 09       	mov	r9,0
8000413e:	12 9a       	mov	r10,r9
80004140:	1a 9b       	mov	r11,sp
80004142:	f0 1f 00 07 	mcall	8000415c <xcmp_rx+0x48>
	}	
}
80004146:	2f fd       	sub	sp,-4
80004148:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
8000414c:	00 00       	add	r0,r0
8000414e:	0a 94       	mov	r4,r5
80004150:	80 00       	ld.sh	r0,r0[0x0]
80004152:	2e ec       	sub	r12,-18
80004154:	80 00       	ld.sh	r0,r0[0x0]
80004156:	6a f0       	ld.w	r0,r5[0x3c]
80004158:	00 00       	add	r0,r0
8000415a:	0a e0       	st.h	--r5,r0
8000415c:	80 00       	ld.sh	r0,r0[0x0]
8000415e:	55 a0       	stdsp	sp[0x168],r0

80004160 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004160:	48 28       	lddpc	r8,80004168 <xnl_register_xcmp_func+0x8>
80004162:	91 0c       	st.w	r8[0x0],r12
}
80004164:	5e fc       	retal	r12
80004166:	00 00       	add	r0,r0
80004168:	00 00       	add	r0,r0
8000416a:	0b 44       	ld.w	r4,--r5

8000416c <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
8000416c:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000416e:	48 88       	lddpc	r8,8000418c <xnl_get_msg_ack_func+0x20>
80004170:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004172:	98 49       	ld.sh	r9,r12[0x8]
80004174:	f0 09 19 00 	cp.h	r9,r8
80004178:	c0 81       	brne	80004188 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000417a:	48 68       	lddpc	r8,80004190 <xnl_get_msg_ack_func+0x24>
8000417c:	70 0c       	ld.w	r12,r8[0x0]
8000417e:	30 09       	mov	r9,0
80004180:	12 9a       	mov	r10,r9
80004182:	12 9b       	mov	r11,r9
80004184:	f0 1f 00 04 	mcall	80004194 <xnl_get_msg_ack_func+0x28>
80004188:	d8 02       	popm	pc
8000418a:	00 00       	add	r0,r0
8000418c:	00 00       	add	r0,r0
8000418e:	0b 24       	ld.uh	r4,r5++
80004190:	00 00       	add	r0,r0
80004192:	0b 20       	ld.uh	r0,r5++
80004194:	80 00       	ld.sh	r0,r0[0x0]
80004196:	55 a0       	stdsp	sp[0x168],r0

80004198 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004198:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000419a:	4a 86       	lddpc	r6,80004238 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000419c:	4a 82       	lddpc	r2,8000423c <xnl_tx_process+0xa4>
8000419e:	4a 94       	lddpc	r4,80004240 <xnl_tx_process+0xa8>
800041a0:	30 07       	mov	r7,0
800041a2:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800041a4:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800041a6:	4a 85       	lddpc	r5,80004244 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800041a8:	4a 83       	lddpc	r3,80004248 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800041aa:	6c 08       	ld.w	r8,r6[0x0]
800041ac:	58 08       	cp.w	r8,0
800041ae:	c0 40       	breq	800041b6 <xnl_tx_process+0x1e>
800041b0:	58 18       	cp.w	r8,1
800041b2:	cf d1       	brne	800041ac <xnl_tx_process+0x14>
800041b4:	c2 08       	rjmp	800041f4 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800041b6:	64 0c       	ld.w	r12,r2[0x0]
800041b8:	0e 99       	mov	r9,r7
800041ba:	02 9a       	mov	r10,r1
800041bc:	08 9b       	mov	r11,r4
800041be:	f0 1f 00 24 	mcall	8000424c <xnl_tx_process+0xb4>
800041c2:	58 1c       	cp.w	r12,1
800041c4:	cf 31       	brne	800041aa <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800041c6:	68 0c       	ld.w	r12,r4[0x0]
800041c8:	58 0c       	cp.w	r12,0
800041ca:	cf 00       	breq	800041aa <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800041cc:	98 28       	ld.sh	r8,r12[0x4]
800041ce:	e0 08 19 00 	cp.h	r8,r0
800041d2:	c0 41       	brne	800041da <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
800041d4:	f0 1f 00 1f 	mcall	80004250 <xnl_tx_process+0xb8>
						break;
800041d8:	ce 9b       	rjmp	800041aa <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800041da:	f0 1f 00 1f 	mcall	80004254 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800041de:	30 18       	mov	r8,1
800041e0:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800041e2:	66 0c       	ld.w	r12,r3[0x0]
800041e4:	0e 99       	mov	r9,r7
800041e6:	0e 9a       	mov	r10,r7
800041e8:	0e 9b       	mov	r11,r7
800041ea:	f0 1f 00 19 	mcall	8000424c <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
800041ee:	30 18       	mov	r8,1
800041f0:	8d 08       	st.w	r6[0x0],r8
800041f2:	cd cb       	rjmp	800041aa <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800041f4:	66 0c       	ld.w	r12,r3[0x0]
800041f6:	0e 99       	mov	r9,r7
800041f8:	36 4a       	mov	r10,100
800041fa:	0e 9b       	mov	r11,r7
800041fc:	f0 1f 00 14 	mcall	8000424c <xnl_tx_process+0xb4>
80004200:	58 1c       	cp.w	r12,1
80004202:	c0 81       	brne	80004212 <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
80004204:	49 58       	lddpc	r8,80004258 <xnl_tx_process+0xc0>
80004206:	70 0c       	ld.w	r12,r8[0x0]
80004208:	68 0b       	ld.w	r11,r4[0x0]
8000420a:	f0 1f 00 15 	mcall	8000425c <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000420e:	8d 07       	st.w	r6[0x0],r7
80004210:	cc db       	rjmp	800041aa <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004212:	6a 08       	ld.w	r8,r5[0x0]
80004214:	58 38       	cp.w	r8,3
80004216:	e0 89 00 09 	brgt	80004228 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000421a:	68 0c       	ld.w	r12,r4[0x0]
8000421c:	f0 1f 00 0e 	mcall	80004254 <xnl_tx_process+0xbc>
						xnl_send_times++;
80004220:	6a 08       	ld.w	r8,r5[0x0]
80004222:	2f f8       	sub	r8,-1
80004224:	8b 08       	st.w	r5[0x0],r8
80004226:	cc 2b       	rjmp	800041aa <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004228:	48 c8       	lddpc	r8,80004258 <xnl_tx_process+0xc0>
8000422a:	70 0c       	ld.w	r12,r8[0x0]
8000422c:	68 0b       	ld.w	r11,r4[0x0]
8000422e:	f0 1f 00 0c 	mcall	8000425c <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004232:	8d 07       	st.w	r6[0x0],r7
80004234:	cb bb       	rjmp	800041aa <xnl_tx_process+0x12>
80004236:	00 00       	add	r0,r0
80004238:	00 00       	add	r0,r0
8000423a:	0b 40       	ld.w	r0,--r5
8000423c:	00 00       	add	r0,r0
8000423e:	0b 34       	ld.ub	r4,r5++
80004240:	00 00       	add	r0,r0
80004242:	0b 38       	ld.ub	r8,r5++
80004244:	00 00       	add	r0,r0
80004246:	0b 30       	ld.ub	r0,r5++
80004248:	00 00       	add	r0,r0
8000424a:	0b 20       	ld.uh	r0,r5++
8000424c:	80 00       	ld.sh	r0,r0[0x0]
8000424e:	53 94       	stdsp	sp[0xe4],r4
80004250:	80 00       	ld.sh	r0,r0[0x0]
80004252:	52 24       	stdsp	sp[0x88],r4
80004254:	80 00       	ld.sh	r0,r0[0x0]
80004256:	2a 90       	sub	r0,-87
80004258:	00 00       	add	r0,r0
8000425a:	0a 94       	mov	r4,r5
8000425c:	80 00       	ld.sh	r0,r0[0x0]
8000425e:	2a 70       	sub	r0,-89

80004260 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80004260:	eb cd 40 fe 	pushm	r1-r7,lr
80004264:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004266:	49 26       	lddpc	r6,800042ac <xnl_rx_process+0x4c>
80004268:	30 05       	mov	r5,0
8000426a:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
8000426c:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000426e:	49 11       	lddpc	r1,800042b0 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004270:	49 12       	lddpc	r2,800042b4 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004272:	6c 0c       	ld.w	r12,r6[0x0]
80004274:	0a 99       	mov	r9,r5
80004276:	08 9a       	mov	r10,r4
80004278:	1a 9b       	mov	r11,sp
8000427a:	f0 1f 00 10 	mcall	800042b8 <xnl_rx_process+0x58>
8000427e:	58 1c       	cp.w	r12,1
80004280:	cf 91       	brne	80004272 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004282:	40 0c       	lddsp	r12,sp[0x0]
80004284:	58 0c       	cp.w	r12,0
80004286:	cf 60       	breq	80004272 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004288:	98 28       	ld.sh	r8,r12[0x4]
8000428a:	e6 08 19 00 	cp.h	r8,r3
8000428e:	e0 8b 00 0a 	brhi	800042a2 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004292:	5c 78       	castu.h	r8
80004294:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004298:	58 09       	cp.w	r9,0
8000429a:	c0 40       	breq	800042a2 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
8000429c:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800042a0:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800042a2:	62 0c       	ld.w	r12,r1[0x0]
800042a4:	40 0b       	lddsp	r11,sp[0x0]
800042a6:	f0 1f 00 06 	mcall	800042bc <xnl_rx_process+0x5c>
800042aa:	ce 4b       	rjmp	80004272 <xnl_rx_process+0x12>
800042ac:	00 00       	add	r0,r0
800042ae:	0a ac       	st.w	r5++,r12
800042b0:	00 00       	add	r0,r0
800042b2:	0a 94       	mov	r4,r5
800042b4:	00 00       	add	r0,r0
800042b6:	04 f4       	st.b	--r2,r4
800042b8:	80 00       	ld.sh	r0,r0[0x0]
800042ba:	53 94       	stdsp	sp[0xe4],r4
800042bc:	80 00       	ld.sh	r0,r0[0x0]
800042be:	2a 70       	sub	r0,-89

800042c0 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800042c0:	eb cd 40 c0 	pushm	r6-r7,lr
800042c4:	20 1d       	sub	sp,4
800042c6:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800042c8:	98 39       	ld.sh	r9,r12[0x6]
800042ca:	3f f8       	mov	r8,-1
800042cc:	f0 09 19 00 	cp.h	r9,r8
800042d0:	c0 a1       	brne	800042e4 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800042d2:	4a e9       	lddpc	r9,80004388 <xnl_tx+0xc8>
800042d4:	13 88       	ld.ub	r8,r9[0x0]
800042d6:	2f f8       	sub	r8,-1
800042d8:	5c 58       	castu.b	r8
800042da:	b2 88       	st.b	r9[0x0],r8
800042dc:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800042e0:	a9 a8       	sbr	r8,0x8
800042e2:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800042e4:	8c 49       	ld.sh	r9,r6[0x8]
800042e6:	3f f8       	mov	r8,-1
800042e8:	f0 09 19 00 	cp.h	r9,r8
800042ec:	c0 41       	brne	800042f4 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800042ee:	4a 88       	lddpc	r8,8000438c <xnl_tx+0xcc>
800042f0:	90 18       	ld.sh	r8,r8[0x2]
800042f2:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800042f4:	8c 59       	ld.sh	r9,r6[0xa]
800042f6:	3f f8       	mov	r8,-1
800042f8:	f0 09 19 00 	cp.h	r9,r8
800042fc:	c0 41       	brne	80004304 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800042fe:	4a 48       	lddpc	r8,8000438c <xnl_tx+0xcc>
80004300:	90 28       	ld.sh	r8,r8[0x4]
80004302:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004304:	8c 69       	ld.sh	r9,r6[0xc]
80004306:	3f f8       	mov	r8,-1
80004308:	f0 09 19 00 	cp.h	r9,r8
8000430c:	c0 e1       	brne	80004328 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000430e:	4a 08       	lddpc	r8,8000438c <xnl_tx+0xcc>
80004310:	90 49       	ld.sh	r9,r8[0x8]
80004312:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004314:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004316:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004318:	90 49       	ld.sh	r9,r8[0x8]
8000431a:	e0 19 ff 00 	andl	r9,0xff00
8000431e:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004322:	f3 e8 10 08 	or	r8,r9,r8
80004326:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004328:	0d 98       	ld.ub	r8,r6[0x1]
8000432a:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
8000432c:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004330:	10 0c       	add	r12,r8
80004332:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004334:	58 0c       	cp.w	r12,0
80004336:	e0 89 00 04 	brgt	8000433e <xnl_tx+0x7e>
8000433a:	30 09       	mov	r9,0
8000433c:	c0 d8       	rjmp	80004356 <xnl_tx+0x96>
8000433e:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004342:	2f ec       	sub	r12,-2
80004344:	30 09       	mov	r9,0
80004346:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004348:	15 1b       	ld.sh	r11,r10++
8000434a:	f6 09 00 09 	add	r9,r11,r9
8000434e:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004350:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004352:	18 38       	cp.w	r8,r12
80004354:	cf a1       	brne	80004348 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004356:	5c 39       	neg	r9
80004358:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000435a:	48 e8       	lddpc	r8,80004390 <xnl_tx+0xd0>
8000435c:	70 0c       	ld.w	r12,r8[0x0]
8000435e:	f0 1f 00 0e 	mcall	80004394 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004362:	c1 00       	breq	80004382 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004364:	fa c7 ff fc 	sub	r7,sp,-4
80004368:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
8000436a:	e0 6a 01 00 	mov	r10,256
8000436e:	0c 9b       	mov	r11,r6
80004370:	f0 1f 00 0a 	mcall	80004398 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004374:	48 a8       	lddpc	r8,8000439c <xnl_tx+0xdc>
80004376:	70 0c       	ld.w	r12,r8[0x0]
80004378:	30 09       	mov	r9,0
8000437a:	12 9a       	mov	r10,r9
8000437c:	1a 9b       	mov	r11,sp
8000437e:	f0 1f 00 09 	mcall	800043a0 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004382:	2f fd       	sub	sp,-4
80004384:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004388:	00 00       	add	r0,r0
8000438a:	0b 3c       	ld.ub	r12,r5++
8000438c:	00 00       	add	r0,r0
8000438e:	0b 24       	ld.uh	r4,r5++
80004390:	00 00       	add	r0,r0
80004392:	0a 94       	mov	r4,r5
80004394:	80 00       	ld.sh	r0,r0[0x0]
80004396:	2e ec       	sub	r12,-18
80004398:	80 00       	ld.sh	r0,r0[0x0]
8000439a:	6a f0       	ld.w	r0,r5[0x3c]
8000439c:	00 00       	add	r0,r0
8000439e:	0b 34       	ld.ub	r4,r5++
800043a0:	80 00       	ld.sh	r0,r0[0x0]
800043a2:	55 a0       	stdsp	sp[0x168],r0

800043a4 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800043a4:	eb cd 40 80 	pushm	r7,lr
800043a8:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
800043ac:	f0 1f 00 27 	mcall	80004448 <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
800043b0:	30 09       	mov	r9,0
800043b2:	4a 78       	lddpc	r8,8000444c <xnl_init+0xa8>
800043b4:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800043b6:	30 0b       	mov	r11,0
800043b8:	30 1c       	mov	r12,1
800043ba:	f0 1f 00 26 	mcall	80004450 <xnl_init+0xac>
800043be:	4a 68       	lddpc	r8,80004454 <xnl_init+0xb0>
800043c0:	91 0c       	st.w	r8[0x0],r12
800043c2:	70 08       	ld.w	r8,r8[0x0]
800043c4:	58 08       	cp.w	r8,0
800043c6:	c0 80       	breq	800043d6 <xnl_init+0x32>
800043c8:	4a 38       	lddpc	r8,80004454 <xnl_init+0xb0>
800043ca:	70 0c       	ld.w	r12,r8[0x0]
800043cc:	30 09       	mov	r9,0
800043ce:	12 9a       	mov	r10,r9
800043d0:	12 9b       	mov	r11,r9
800043d2:	f0 1f 00 22 	mcall	80004458 <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800043d6:	30 4b       	mov	r11,4
800043d8:	31 4c       	mov	r12,20
800043da:	f0 1f 00 1e 	mcall	80004450 <xnl_init+0xac>
800043de:	4a 08       	lddpc	r8,8000445c <xnl_init+0xb8>
800043e0:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800043e2:	30 07       	mov	r7,0
800043e4:	1a d7       	st.w	--sp,r7
800043e6:	1a d7       	st.w	--sp,r7
800043e8:	1a d7       	st.w	--sp,r7
800043ea:	30 38       	mov	r8,3
800043ec:	0e 99       	mov	r9,r7
800043ee:	e0 6a 02 00 	mov	r10,512
800043f2:	49 cb       	lddpc	r11,80004460 <xnl_init+0xbc>
800043f4:	49 cc       	lddpc	r12,80004464 <xnl_init+0xc0>
800043f6:	f0 1f 00 1d 	mcall	80004468 <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
800043fa:	1a d7       	st.w	--sp,r7
800043fc:	1a d7       	st.w	--sp,r7
800043fe:	1a d7       	st.w	--sp,r7
80004400:	30 38       	mov	r8,3
80004402:	0e 99       	mov	r9,r7
80004404:	e0 6a 03 20 	mov	r10,800
80004408:	49 9b       	lddpc	r11,8000446c <xnl_init+0xc8>
8000440a:	49 ac       	lddpc	r12,80004470 <xnl_init+0xcc>
8000440c:	f0 1f 00 17 	mcall	80004468 <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004410:	e0 68 40 0e 	mov	r8,16398
80004414:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004418:	3f f8       	mov	r8,-1
8000441a:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
8000441e:	30 38       	mov	r8,3
80004420:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004424:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004428:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000442c:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004430:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004434:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004438:	fa cc ff e8 	sub	r12,sp,-24
8000443c:	f0 1f 00 0e 	mcall	80004474 <xnl_init+0xd0>
80004440:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
80004442:	2c 0d       	sub	sp,-256
80004444:	e3 cd 80 80 	ldm	sp++,r7,pc
80004448:	80 00       	ld.sh	r0,r0[0x0]
8000444a:	2f 14       	sub	r4,-15
8000444c:	00 00       	add	r0,r0
8000444e:	0b 24       	ld.uh	r4,r5++
80004450:	80 00       	ld.sh	r0,r0[0x0]
80004452:	56 f8       	stdsp	sp[0x1bc],r8
80004454:	00 00       	add	r0,r0
80004456:	0b 20       	ld.uh	r0,r5++
80004458:	80 00       	ld.sh	r0,r0[0x0]
8000445a:	55 a0       	stdsp	sp[0x168],r0
8000445c:	00 00       	add	r0,r0
8000445e:	0b 34       	ld.ub	r4,r5++
80004460:	80 00       	ld.sh	r0,r0[0x0]
80004462:	d0 34       	*unknown*
80004464:	80 00       	ld.sh	r0,r0[0x0]
80004466:	42 60       	lddsp	r0,sp[0x98]
80004468:	80 00       	ld.sh	r0,r0[0x0]
8000446a:	5d cc       	*unknown*
8000446c:	80 00       	ld.sh	r0,r0[0x0]
8000446e:	c2 00       	breq	800044ae <xnl_data_msg_func+0x36>
80004470:	80 00       	ld.sh	r0,r0[0x0]
80004472:	41 98       	lddsp	r8,sp[0x64]
80004474:	80 00       	ld.sh	r0,r0[0x0]
80004476:	42 c0       	lddsp	r0,sp[0xb0]

80004478 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004478:	eb cd 40 80 	pushm	r7,lr
8000447c:	fa cd 01 00 	sub	sp,sp,256
80004480:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004482:	e0 68 40 0e 	mov	r8,16398
80004486:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004488:	3f f8       	mov	r8,-1
8000448a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
8000448c:	30 c8       	mov	r8,12
8000448e:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004490:	98 38       	ld.sh	r8,r12[0x6]
80004492:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004494:	98 58       	ld.sh	r8,r12[0xa]
80004496:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004498:	98 48       	ld.sh	r8,r12[0x8]
8000449a:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
8000449c:	98 68       	ld.sh	r8,r12[0xc]
8000449e:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800044a0:	30 08       	mov	r8,0
800044a2:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800044a4:	1a 9c       	mov	r12,sp
800044a6:	f0 1f 00 0a 	mcall	800044cc <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800044aa:	fa cd 00 cc 	sub	sp,sp,204
800044ae:	e0 6a 00 ca 	mov	r10,202
800044b2:	ee cb ff f0 	sub	r11,r7,-16
800044b6:	1a 9c       	mov	r12,sp
800044b8:	f0 1f 00 06 	mcall	800044d0 <xnl_data_msg_func+0x58>
800044bc:	48 68       	lddpc	r8,800044d4 <xnl_data_msg_func+0x5c>
800044be:	70 08       	ld.w	r8,r8[0x0]
800044c0:	5d 18       	icall	r8
800044c2:	fa cd ff 34 	sub	sp,sp,-204
}
800044c6:	2c 0d       	sub	sp,-256
800044c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800044cc:	80 00       	ld.sh	r0,r0[0x0]
800044ce:	42 c0       	lddsp	r0,sp[0xb0]
800044d0:	80 00       	ld.sh	r0,r0[0x0]
800044d2:	6a f0       	ld.w	r0,r5[0x3c]
800044d4:	00 00       	add	r0,r0
800044d6:	0b 44       	ld.w	r4,--r5

800044d8 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
800044d8:	d4 21       	pushm	r4-r7,lr
800044da:	fa cd 01 00 	sub	sp,sp,256
800044de:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
800044e0:	4c 28       	lddpc	r8,800045e8 <xnl_device_auth_reply_func+0x110>
800044e2:	11 88       	ld.ub	r8,r8[0x0]
800044e4:	58 08       	cp.w	r8,0
800044e6:	e0 81 00 7f 	brne	800045e4 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
800044ea:	4c 18       	lddpc	r8,800045ec <xnl_device_auth_reply_func+0x114>
800044ec:	70 0c       	ld.w	r12,r8[0x0]
800044ee:	30 09       	mov	r9,0
800044f0:	12 9a       	mov	r10,r9
800044f2:	12 9b       	mov	r11,r9
800044f4:	f0 1f 00 3f 	mcall	800045f0 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
800044f8:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
800044fc:	4b b8       	lddpc	r8,800045e8 <xnl_device_auth_reply_func+0x110>
800044fe:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004500:	ef 39 00 12 	ld.ub	r9,r7[18]
80004504:	ef 38 00 13 	ld.ub	r8,r7[19]
80004508:	b1 68       	lsl	r8,0x10
8000450a:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000450e:	ef 38 00 15 	ld.ub	r8,r7[21]
80004512:	f3 e8 10 08 	or	r8,r9,r8
80004516:	ef 39 00 14 	ld.ub	r9,r7[20]
8000451a:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
8000451e:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004522:	ef 38 00 17 	ld.ub	r8,r7[23]
80004526:	b1 68       	lsl	r8,0x10
80004528:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
8000452c:	ef 38 00 19 	ld.ub	r8,r7[25]
80004530:	f5 e8 10 08 	or	r8,r10,r8
80004534:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004538:	f1 ea 10 88 	or	r8,r8,r10<<0x8
8000453c:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000453e:	e0 64 79 b9 	mov	r4,31161
80004542:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004546:	e0 65 45 07 	mov	r5,17671
8000454a:	ea 15 8a bd 	orh	r5,0x8abd
8000454e:	e0 66 f9 3d 	mov	r6,63805
80004552:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004556:	e0 6e b8 cf 	mov	lr,47311
8000455a:	ea 1e 36 83 	orh	lr,0x3683
8000455e:	e0 67 aa 1c 	mov	r7,43548
80004562:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004566:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004568:	f4 08 00 0c 	add	r12,r10,r8
8000456c:	f0 0b 15 04 	lsl	r11,r8,0x4
80004570:	0a 0b       	add	r11,r5
80004572:	f9 eb 20 0b 	eor	r11,r12,r11
80004576:	f0 0c 16 05 	lsr	r12,r8,0x5
8000457a:	0c 0c       	add	r12,r6
8000457c:	18 5b       	eor	r11,r12
8000457e:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004580:	f2 0c 15 04 	lsl	r12,r9,0x4
80004584:	1c 0c       	add	r12,lr
80004586:	f2 0b 16 05 	lsr	r11,r9,0x5
8000458a:	0e 0b       	add	r11,r7
8000458c:	f9 eb 20 0b 	eor	r11,r12,r11
80004590:	f2 0a 00 0c 	add	r12,r9,r10
80004594:	18 5b       	eor	r11,r12
80004596:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004598:	e0 6b 37 20 	mov	r11,14112
8000459c:	ea 1b c6 ef 	orh	r11,0xc6ef
800045a0:	16 3a       	cp.w	r10,r11
800045a2:	ce 21       	brne	80004566 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800045a4:	e0 6a 40 1a 	mov	r10,16410
800045a8:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800045aa:	3f fa       	mov	r10,-1
800045ac:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800045ae:	30 6b       	mov	r11,6
800045b0:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800045b2:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800045b4:	48 db       	lddpc	r11,800045e8 <xnl_device_auth_reply_func+0x110>
800045b6:	96 1c       	ld.sh	r12,r11[0x2]
800045b8:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800045ba:	96 2b       	ld.sh	r11,r11[0x4]
800045bc:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800045be:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800045c0:	30 ca       	mov	r10,12
800045c2:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800045c4:	30 0a       	mov	r10,0
800045c6:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
800045ca:	30 7a       	mov	r10,7
800045cc:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
800045d0:	30 2a       	mov	r10,2
800045d2:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800045d6:	fa ca ff ec 	sub	r10,sp,-20
800045da:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800045dc:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
800045de:	1a 9c       	mov	r12,sp
800045e0:	f0 1f 00 05 	mcall	800045f4 <xnl_device_auth_reply_func+0x11c>
}
800045e4:	2c 0d       	sub	sp,-256
800045e6:	d8 22       	popm	r4-r7,pc
800045e8:	00 00       	add	r0,r0
800045ea:	0b 24       	ld.uh	r4,r5++
800045ec:	00 00       	add	r0,r0
800045ee:	0b 20       	ld.uh	r0,r5++
800045f0:	80 00       	ld.sh	r0,r0[0x0]
800045f2:	55 a0       	stdsp	sp[0x168],r0
800045f4:	80 00       	ld.sh	r0,r0[0x0]
800045f6:	42 c0       	lddsp	r0,sp[0xb0]

800045f8 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
800045f8:	eb cd 40 80 	pushm	r7,lr
800045fc:	fa cd 01 00 	sub	sp,sp,256
80004600:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004602:	49 28       	lddpc	r8,80004648 <xnl_master_status_brdcst_func+0x50>
80004604:	11 88       	ld.ub	r8,r8[0x0]
80004606:	58 08       	cp.w	r8,0
80004608:	c1 c1       	brne	80004640 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000460a:	49 18       	lddpc	r8,8000464c <xnl_master_status_brdcst_func+0x54>
8000460c:	70 0c       	ld.w	r12,r8[0x0]
8000460e:	30 09       	mov	r9,0
80004610:	12 9a       	mov	r10,r9
80004612:	12 9b       	mov	r11,r9
80004614:	f0 1f 00 0f 	mcall	80004650 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004618:	8e 58       	ld.sh	r8,r7[0xa]
8000461a:	48 c9       	lddpc	r9,80004648 <xnl_master_status_brdcst_func+0x50>
8000461c:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000461e:	e0 68 40 0e 	mov	r8,16398
80004622:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004624:	3f f8       	mov	r8,-1
80004626:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004628:	30 4a       	mov	r10,4
8000462a:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000462c:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000462e:	92 19       	ld.sh	r9,r9[0x2]
80004630:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004632:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004634:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004636:	30 08       	mov	r8,0
80004638:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
8000463a:	1a 9c       	mov	r12,sp
8000463c:	f0 1f 00 06 	mcall	80004654 <xnl_master_status_brdcst_func+0x5c>
}
80004640:	2c 0d       	sub	sp,-256
80004642:	e3 cd 80 80 	ldm	sp++,r7,pc
80004646:	00 00       	add	r0,r0
80004648:	00 00       	add	r0,r0
8000464a:	0b 24       	ld.uh	r4,r5++
8000464c:	00 00       	add	r0,r0
8000464e:	0b 20       	ld.uh	r0,r5++
80004650:	80 00       	ld.sh	r0,r0[0x0]
80004652:	55 a0       	stdsp	sp[0x168],r0
80004654:	80 00       	ld.sh	r0,r0[0x0]
80004656:	42 c0       	lddsp	r0,sp[0xb0]

80004658 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004658:	eb cd 40 80 	pushm	r7,lr
8000465c:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
8000465e:	49 38       	lddpc	r8,800046a8 <xnl_device_conn_reply_func+0x50>
80004660:	70 0c       	ld.w	r12,r8[0x0]
80004662:	30 09       	mov	r9,0
80004664:	12 9a       	mov	r10,r9
80004666:	12 9b       	mov	r11,r9
80004668:	f0 1f 00 11 	mcall	800046ac <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
8000466c:	ef 18 00 10 	ld.uh	r8,r7[16]
80004670:	10 99       	mov	r9,r8
80004672:	e2 19 ff 00 	andl	r9,0xff00,COH
80004676:	e0 49 01 00 	cp.w	r9,256
8000467a:	c0 60       	breq	80004686 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
8000467c:	0e 9c       	mov	r12,r7
8000467e:	f0 1f 00 0d 	mcall	800046b0 <xnl_device_conn_reply_func+0x58>
80004682:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004686:	a9 68       	lsl	r8,0x8
80004688:	48 b9       	lddpc	r9,800046b4 <xnl_device_conn_reply_func+0x5c>
8000468a:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
8000468c:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004690:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004692:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004696:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004698:	30 18       	mov	r8,1
8000469a:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
8000469c:	48 7c       	lddpc	r12,800046b8 <xnl_device_conn_reply_func+0x60>
8000469e:	f0 1f 00 08 	mcall	800046bc <xnl_device_conn_reply_func+0x64>
800046a2:	e3 cd 80 80 	ldm	sp++,r7,pc
800046a6:	00 00       	add	r0,r0
800046a8:	00 00       	add	r0,r0
800046aa:	0b 20       	ld.uh	r0,r5++
800046ac:	80 00       	ld.sh	r0,r0[0x0]
800046ae:	55 a0       	stdsp	sp[0x168],r0
800046b0:	80 00       	ld.sh	r0,r0[0x0]
800046b2:	45 f8       	lddsp	r8,sp[0x17c]
800046b4:	00 00       	add	r0,r0
800046b6:	0b 24       	ld.uh	r4,r5++
800046b8:	80 00       	ld.sh	r0,r0[0x0]
800046ba:	d0 3c       	*unknown*
800046bc:	80 00       	ld.sh	r0,r0[0x0]
800046be:	61 90       	ld.w	r0,r0[0x64]

800046c0 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
800046c0:	fe 78 0c 00 	mov	r8,-62464
800046c4:	e0 69 03 07 	mov	r9,775
800046c8:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
800046ca:	30 49       	mov	r9,4
800046cc:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800046ce:	71 59       	ld.w	r9,r8[0x54]
800046d0:	e2 19 00 80 	andl	r9,0x80,COH
800046d4:	cf d0       	breq	800046ce <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
800046d6:	fe 78 0c 00 	mov	r8,-62464
800046da:	30 59       	mov	r9,5
800046dc:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
800046de:	e0 69 01 0d 	mov	r9,269
800046e2:	ea 19 10 07 	orh	r9,0x1007
800046e6:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800046e8:	71 59       	ld.w	r9,r8[0x54]
800046ea:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800046ee:	cf d0       	breq	800046e8 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
800046f0:	fe 78 0c 00 	mov	r8,-62464
800046f4:	fc 19 00 80 	movh	r9,0x80
800046f8:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
800046fa:	34 0a       	mov	r10,64
800046fc:	fe 69 14 00 	mov	r9,-125952
80004700:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80004702:	30 69       	mov	r9,6
80004704:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80004706:	30 19       	mov	r9,1
80004708:	fe 68 10 00 	mov	r8,-126976
8000470c:	91 19       	st.w	r8[0x4],r9
}
8000470e:	5e fc       	retal	r12

80004710 <rtc_init>:
    PCF8563_init
Called By: ..
Return:rtc_err_t
*/
rtc_err_t rtc_init(void)
{
80004710:	eb cd 40 c0 	pushm	r6-r7,lr
80004714:	20 3d       	sub	sp,12
	/* Create the mutex semaphore to guard a shared RTC(TWI).*/	
	rtc_mutex = xSemaphoreCreateMutex();
80004716:	f0 1f 00 1a 	mcall	8000477c <rtc_init+0x6c>
8000471a:	49 a8       	lddpc	r8,80004780 <rtc_init+0x70>
8000471c:	91 0c       	st.w	r8[0x0],r12
	
	if(NULL != rtc_mutex)
8000471e:	70 08       	ld.w	r8,r8[0x0]
80004720:	58 08       	cp.w	r8,0
80004722:	c0 31       	brne	80004728 <rtc_init+0x18>
80004724:	30 3c       	mov	r12,3
80004726:	c2 78       	rjmp	80004774 <rtc_init+0x64>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80004728:	49 66       	lddpc	r6,80004780 <rtc_init+0x70>
8000472a:	6c 0c       	ld.w	r12,r6[0x0]
8000472c:	30 09       	mov	r9,0
8000472e:	3f fa       	mov	r10,-1
80004730:	12 9b       	mov	r11,r9
80004732:	f0 1f 00 15 	mcall	80004784 <rtc_init+0x74>
	
	/*twi_package_t packet, packet_received*/
	static int status;

	/*TWI gpio pins configuration*/	
	gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
80004736:	30 2b       	mov	r11,2
80004738:	49 4c       	lddpc	r12,80004788 <rtc_init+0x78>
8000473a:	f0 1f 00 15 	mcall	8000478c <rtc_init+0x7c>
	
	/* options settings*/
	opt.pba_hz = RTC_PBACLK_FREQ_HZ;//FOSC0;24Mhz
8000473e:	e0 68 36 00 	mov	r8,13824
80004742:	ea 18 01 6e 	orh	r8,0x16e
80004746:	50 08       	stdsp	sp[0x0],r8
	opt.speed  = TWI_SPEED;//200Khz
80004748:	e2 78 0d 40 	mov	r8,200000
8000474c:	50 18       	stdsp	sp[0x4],r8
	opt.chip   = PCF8563_ADDRESS;
8000474e:	35 18       	mov	r8,81
80004750:	fb 68 00 08 	st.b	sp[8],r8

	/*initialize TWI driver with options*/
	status = twi_master_init(&AVR32_TWI, &opt);
80004754:	1a 9b       	mov	r11,sp
80004756:	fe 7c 2c 00 	mov	r12,-54272
8000475a:	f0 1f 00 0e 	mcall	80004790 <rtc_init+0x80>
8000475e:	48 e7       	lddpc	r7,80004794 <rtc_init+0x84>
80004760:	8f 0c       	st.w	r7[0x0],r12
	
	/*finished accessing the shared resource.Release the semaphore.*/
	xSemaphoreGive(rtc_mutex);		
80004762:	6c 0c       	ld.w	r12,r6[0x0]
80004764:	30 09       	mov	r9,0
80004766:	12 9a       	mov	r10,r9
80004768:	12 9b       	mov	r11,r9
8000476a:	f0 1f 00 0c 	mcall	80004798 <rtc_init+0x88>
8000476e:	6e 08       	ld.w	r8,r7[0x0]
80004770:	58 08       	cp.w	r8,0
80004772:	5f 1c       	srne	r12
	{
		return rtc_success;
	}
		
	return rtc_init_err;
}
80004774:	2f dd       	sub	sp,-12
80004776:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000477a:	00 00       	add	r0,r0
8000477c:	80 00       	ld.sh	r0,r0[0x0]
8000477e:	56 a0       	stdsp	sp[0x1a8],r0
80004780:	00 00       	add	r0,r0
80004782:	0b 4c       	ld.w	r12,--r5
80004784:	80 00       	ld.sh	r0,r0[0x0]
80004786:	53 94       	stdsp	sp[0xe4],r4
80004788:	80 00       	ld.sh	r0,r0[0x0]
8000478a:	d0 50       	acall	0x5
8000478c:	80 00       	ld.sh	r0,r0[0x0]
8000478e:	66 28       	ld.w	r8,r3[0x8]
80004790:	80 00       	ld.sh	r0,r0[0x0]
80004792:	4c 20       	lddpc	r0,80004898 <INTC_register_interrupt+0x3c>
80004794:	00 00       	add	r0,r0
80004796:	0b 48       	ld.w	r8,--r5
80004798:	80 00       	ld.sh	r0,r0[0x0]
8000479a:	55 a0       	stdsp	sp[0x168],r0

8000479c <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
8000479c:	fe 78 10 00 	mov	r8,-61440
800047a0:	fc 19 00 10 	movh	r9,0x10
800047a4:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
800047a6:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
800047a8:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
800047aa:	30 39       	mov	r9,3
800047ac:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
800047b0:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
800047b4:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
800047b8:	fe 78 38 00 	mov	r8,-51200
800047bc:	30 49       	mov	r9,4
800047be:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
800047c2:	e0 69 91 0d 	mov	r9,37133
800047c6:	ea 19 00 52 	orh	r9,0x52
800047ca:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800047cc:	32 09       	mov	r9,32
800047ce:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800047d0:	30 59       	mov	r9,5
800047d2:	91 09       	st.w	r8[0x0],r9
}
800047d4:	5e fc       	retal	r12
800047d6:	d7 03       	nop

800047d8 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
800047d8:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
800047da:	30 2a       	mov	r10,2
800047dc:	e0 6b 01 c1 	mov	r11,449
800047e0:	48 ec       	lddpc	r12,80004818 <tc_init+0x40>
800047e2:	f0 1f 00 0f 	mcall	8000481c <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
800047e6:	48 fb       	lddpc	r11,80004820 <tc_init+0x48>
800047e8:	fe 7c 38 00 	mov	r12,-51200
800047ec:	f0 1f 00 0e 	mcall	80004824 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
800047f0:	e0 6a 75 30 	mov	r10,30000
800047f4:	30 1b       	mov	r11,1
800047f6:	fe 7c 38 00 	mov	r12,-51200
800047fa:	f0 1f 00 0c 	mcall	80004828 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
800047fe:	48 ca       	lddpc	r10,8000482c <tc_init+0x54>
80004800:	30 1b       	mov	r11,1
80004802:	fe 7c 38 00 	mov	r12,-51200
80004806:	f0 1f 00 0b 	mcall	80004830 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
8000480a:	30 1b       	mov	r11,1
8000480c:	fe 7c 38 00 	mov	r12,-51200
80004810:	f0 1f 00 09 	mcall	80004834 <tc_init+0x5c>
80004814:	d8 02       	popm	pc
80004816:	00 00       	add	r0,r0
80004818:	80 00       	ld.sh	r0,r0[0x0]
8000481a:	48 38       	lddpc	r8,80004824 <tc_init+0x4c>
8000481c:	80 00       	ld.sh	r0,r0[0x0]
8000481e:	48 5c       	lddpc	r12,80004830 <tc_init+0x58>
80004820:	80 00       	ld.sh	r0,r0[0x0]
80004822:	d0 64       	*unknown*
80004824:	80 00       	ld.sh	r0,r0[0x0]
80004826:	49 68       	lddpc	r8,8000487c <INTC_register_interrupt+0x20>
80004828:	80 00       	ld.sh	r0,r0[0x0]
8000482a:	4a 28       	lddpc	r8,800048b0 <INTC_register_interrupt+0x54>
8000482c:	80 00       	ld.sh	r0,r0[0x0]
8000482e:	d0 60       	acall	0x6
80004830:	80 00       	ld.sh	r0,r0[0x0]
80004832:	4a 5c       	lddpc	r12,800048c4 <INTC_register_interrupt+0x68>
80004834:	80 00       	ld.sh	r0,r0[0x0]
80004836:	4a 04       	lddpc	r4,800048b4 <INTC_register_interrupt+0x58>

80004838 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80004838:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
8000483a:	48 68       	lddpc	r8,80004850 <_tc_interrupt+0x18>
8000483c:	70 09       	ld.w	r9,r8[0x0]
8000483e:	2f f9       	sub	r9,-1
80004840:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80004842:	30 1b       	mov	r11,1
80004844:	fe 7c 38 00 	mov	r12,-51200
80004848:	f0 1f 00 03 	mcall	80004854 <_tc_interrupt+0x1c>
	
}
8000484c:	d4 02       	popm	lr
8000484e:	d6 03       	rete
80004850:	00 00       	add	r0,r0
80004852:	0b 50       	ld.sh	r0,--r5
80004854:	80 00       	ld.sh	r0,r0[0x0]
80004856:	4a 16       	lddpc	r6,800048d8 <INTC_register_interrupt+0x7c>

80004858 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004858:	c0 08       	rjmp	80004858 <_unhandled_interrupt>
8000485a:	d7 03       	nop

8000485c <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000485c:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004860:	49 99       	lddpc	r9,800048c4 <INTC_register_interrupt+0x68>
80004862:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004866:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000486a:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000486c:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004870:	58 0a       	cp.w	r10,0
80004872:	c0 91       	brne	80004884 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004874:	49 59       	lddpc	r9,800048c8 <INTC_register_interrupt+0x6c>
80004876:	49 6a       	lddpc	r10,800048cc <INTC_register_interrupt+0x70>
80004878:	12 1a       	sub	r10,r9
8000487a:	fe 79 08 00 	mov	r9,-63488
8000487e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004882:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004884:	58 1a       	cp.w	r10,1
80004886:	c0 a1       	brne	8000489a <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004888:	49 09       	lddpc	r9,800048c8 <INTC_register_interrupt+0x6c>
8000488a:	49 2a       	lddpc	r10,800048d0 <INTC_register_interrupt+0x74>
8000488c:	12 1a       	sub	r10,r9
8000488e:	bf aa       	sbr	r10,0x1e
80004890:	fe 79 08 00 	mov	r9,-63488
80004894:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004898:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000489a:	58 2a       	cp.w	r10,2
8000489c:	c0 a1       	brne	800048b0 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000489e:	48 b9       	lddpc	r9,800048c8 <INTC_register_interrupt+0x6c>
800048a0:	48 da       	lddpc	r10,800048d4 <INTC_register_interrupt+0x78>
800048a2:	12 1a       	sub	r10,r9
800048a4:	bf ba       	sbr	r10,0x1f
800048a6:	fe 79 08 00 	mov	r9,-63488
800048aa:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800048ae:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800048b0:	48 69       	lddpc	r9,800048c8 <INTC_register_interrupt+0x6c>
800048b2:	48 aa       	lddpc	r10,800048d8 <INTC_register_interrupt+0x7c>
800048b4:	12 1a       	sub	r10,r9
800048b6:	ea 1a c0 00 	orh	r10,0xc000
800048ba:	fe 79 08 00 	mov	r9,-63488
800048be:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800048c2:	5e fc       	retal	r12
800048c4:	80 00       	ld.sh	r0,r0[0x0]
800048c6:	d0 6c       	*unknown*
800048c8:	80 00       	ld.sh	r0,r0[0x0]
800048ca:	c0 00       	breq	800048ca <INTC_register_interrupt+0x6e>
800048cc:	80 00       	ld.sh	r0,r0[0x0]
800048ce:	c1 04       	brge	800048ee <INTC_init_interrupts+0x12>
800048d0:	80 00       	ld.sh	r0,r0[0x0]
800048d2:	c1 12       	brcc	800048f4 <INTC_init_interrupts+0x18>
800048d4:	80 00       	ld.sh	r0,r0[0x0]
800048d6:	c1 20       	breq	800048fa <INTC_init_interrupts+0x1e>
800048d8:	80 00       	ld.sh	r0,r0[0x0]
800048da:	c1 2e       	rcall	800044fe <xnl_device_auth_reply_func+0x26>

800048dc <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800048dc:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800048de:	49 18       	lddpc	r8,80004920 <INTC_init_interrupts+0x44>
800048e0:	e3 b8 00 01 	mtsr	0x4,r8
800048e4:	49 0e       	lddpc	lr,80004924 <INTC_init_interrupts+0x48>
800048e6:	30 07       	mov	r7,0
800048e8:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800048ea:	49 0c       	lddpc	r12,80004928 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800048ec:	49 05       	lddpc	r5,8000492c <INTC_init_interrupts+0x50>
800048ee:	10 15       	sub	r5,r8
800048f0:	fe 76 08 00 	mov	r6,-63488
800048f4:	c1 08       	rjmp	80004914 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800048f6:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800048f8:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800048fa:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800048fc:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004900:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004902:	10 3a       	cp.w	r10,r8
80004904:	fe 9b ff fc 	brhi	800048fc <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004908:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
8000490c:	2f f7       	sub	r7,-1
8000490e:	2f 8e       	sub	lr,-8
80004910:	59 37       	cp.w	r7,19
80004912:	c0 50       	breq	8000491c <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004914:	7c 08       	ld.w	r8,lr[0x0]
80004916:	58 08       	cp.w	r8,0
80004918:	ce f1       	brne	800048f6 <INTC_init_interrupts+0x1a>
8000491a:	cf 7b       	rjmp	80004908 <INTC_init_interrupts+0x2c>
8000491c:	d8 22       	popm	r4-r7,pc
8000491e:	00 00       	add	r0,r0
80004920:	80 00       	ld.sh	r0,r0[0x0]
80004922:	c0 00       	breq	80004922 <INTC_init_interrupts+0x46>
80004924:	80 00       	ld.sh	r0,r0[0x0]
80004926:	d0 6c       	*unknown*
80004928:	80 00       	ld.sh	r0,r0[0x0]
8000492a:	48 58       	lddpc	r8,8000493c <_get_interrupt_handler+0xc>
8000492c:	80 00       	ld.sh	r0,r0[0x0]
8000492e:	c1 04       	brge	8000494e <_get_interrupt_handler+0x1e>

80004930 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004930:	fe 78 08 00 	mov	r8,-63488
80004934:	e0 69 00 83 	mov	r9,131
80004938:	f2 0c 01 0c 	sub	r12,r9,r12
8000493c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004940:	f2 ca ff c0 	sub	r10,r9,-64
80004944:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004948:	58 08       	cp.w	r8,0
8000494a:	c0 21       	brne	8000494e <_get_interrupt_handler+0x1e>
8000494c:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000494e:	f0 08 12 00 	clz	r8,r8
80004952:	48 5a       	lddpc	r10,80004964 <_get_interrupt_handler+0x34>
80004954:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004958:	f0 08 11 1f 	rsub	r8,r8,31
8000495c:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
8000495e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004962:	5e fc       	retal	r12
80004964:	80 00       	ld.sh	r0,r0[0x0]
80004966:	d0 6c       	*unknown*

80004968 <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80004968:	76 09       	ld.w	r9,r11[0x0]
8000496a:	58 29       	cp.w	r9,2
8000496c:	e0 88 00 03 	brls	80004972 <tc_init_waveform+0xa>
80004970:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80004972:	76 18       	ld.w	r8,r11[0x4]
80004974:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80004978:	af ba       	sbr	r10,0xf
8000497a:	10 9b       	mov	r11,r8
8000497c:	e6 1b c0 00 	andh	r11,0xc000,COH
80004980:	16 4a       	or	r10,r11
80004982:	10 9b       	mov	r11,r8
80004984:	e6 1b 30 00 	andh	r11,0x3000,COH
80004988:	16 4a       	or	r10,r11
8000498a:	10 9b       	mov	r11,r8
8000498c:	e6 1b 0c 00 	andh	r11,0xc00,COH
80004990:	16 4a       	or	r10,r11
80004992:	10 9b       	mov	r11,r8
80004994:	e6 1b 03 00 	andh	r11,0x300,COH
80004998:	16 4a       	or	r10,r11
8000499a:	10 9b       	mov	r11,r8
8000499c:	e6 1b 00 c0 	andh	r11,0xc0,COH
800049a0:	16 4a       	or	r10,r11
800049a2:	10 9b       	mov	r11,r8
800049a4:	e6 1b 00 30 	andh	r11,0x30,COH
800049a8:	16 4a       	or	r10,r11
800049aa:	10 9b       	mov	r11,r8
800049ac:	e6 1b 00 0c 	andh	r11,0xc,COH
800049b0:	16 4a       	or	r10,r11
800049b2:	10 9b       	mov	r11,r8
800049b4:	e6 1b 00 03 	andh	r11,0x3,COH
800049b8:	16 4a       	or	r10,r11
800049ba:	10 9b       	mov	r11,r8
800049bc:	e2 1b 60 00 	andl	r11,0x6000,COH
800049c0:	16 4a       	or	r10,r11
800049c2:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
800049c6:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
800049ca:	10 9b       	mov	r11,r8
800049cc:	e2 1b 0c 00 	andl	r11,0xc00,COH
800049d0:	16 4a       	or	r10,r11
800049d2:	10 9b       	mov	r11,r8
800049d4:	e2 1b 03 00 	andl	r11,0x300,COH
800049d8:	16 4a       	or	r10,r11
800049da:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
800049de:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
800049e2:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
800049e6:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
800049ea:	10 9b       	mov	r11,r8
800049ec:	e2 1b 00 30 	andl	r11,0x30,COH
800049f0:	16 4a       	or	r10,r11
800049f2:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
800049f6:	f5 e8 10 38 	or	r8,r10,r8<<0x3
800049fa:	a5 69       	lsl	r9,0x4
800049fc:	2f f9       	sub	r9,-1
800049fe:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80004a02:	5e fd       	retal	0

80004a04 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004a04:	58 2b       	cp.w	r11,2
80004a06:	e0 88 00 03 	brls	80004a0c <tc_start+0x8>
80004a0a:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004a0c:	a7 6b       	lsl	r11,0x6
80004a0e:	16 0c       	add	r12,r11
80004a10:	30 58       	mov	r8,5
80004a12:	99 08       	st.w	r12[0x0],r8
80004a14:	5e fd       	retal	0

80004a16 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004a16:	58 2b       	cp.w	r11,2
80004a18:	e0 88 00 03 	brls	80004a1e <tc_read_sr+0x8>
80004a1c:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80004a1e:	a7 6b       	lsl	r11,0x6
80004a20:	2e 0b       	sub	r11,-32
80004a22:	16 0c       	add	r12,r11
80004a24:	78 0c       	ld.w	r12,r12[0x0]
}
80004a26:	5e fc       	retal	r12

80004a28 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004a28:	58 2b       	cp.w	r11,2
80004a2a:	e0 88 00 03 	brls	80004a30 <tc_write_rc+0x8>
80004a2e:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80004a30:	f6 08 15 04 	lsl	r8,r11,0x4
80004a34:	2f f8       	sub	r8,-1
80004a36:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80004a3a:	e2 18 80 00 	andl	r8,0x8000,COH
80004a3e:	c0 c0       	breq	80004a56 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80004a40:	a7 6b       	lsl	r11,0x6
80004a42:	16 0c       	add	r12,r11
80004a44:	2e 4c       	sub	r12,-28
80004a46:	78 08       	ld.w	r8,r12[0x0]
80004a48:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004a4c:	e0 18 00 00 	andl	r8,0x0
80004a50:	f3 e8 10 08 	or	r8,r9,r8
80004a54:	99 08       	st.w	r12[0x0],r8

  return value;
80004a56:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80004a5a:	5e fc       	retal	r12

80004a5c <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80004a5c:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80004a60:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004a64:	58 2b       	cp.w	r11,2
80004a66:	e0 88 00 04 	brls	80004a6e <tc_configure_interrupts+0x12>
80004a6a:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80004a6e:	ee 19 00 01 	eorh	r9,0x1
80004a72:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80004a76:	74 08       	ld.w	r8,r10[0x0]
80004a78:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80004a7c:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80004a80:	a7 6e       	lsl	lr,0x6
80004a82:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80004a86:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80004a8a:	0e 4e       	or	lr,r7
80004a8c:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80004a90:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80004a94:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80004a98:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80004a9c:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80004aa0:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80004aa4:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80004aa8:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80004aac:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004ab0:	fd e8 10 18 	or	r8,lr,r8<<0x1
80004ab4:	f6 0e 15 06 	lsl	lr,r11,0x6
80004ab8:	f8 0e 00 0e 	add	lr,r12,lr
80004abc:	2d ce       	sub	lr,-36
80004abe:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80004ac0:	58 09       	cp.w	r9,0
80004ac2:	c0 20       	breq	80004ac6 <tc_configure_interrupts+0x6a>
80004ac4:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004ac6:	74 08       	ld.w	r8,r10[0x0]
80004ac8:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80004acc:	e0 65 00 80 	mov	r5,128
80004ad0:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80004ad4:	74 08       	ld.w	r8,r10[0x0]
80004ad6:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80004ada:	f9 b4 00 40 	moveq	r4,64
80004ade:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80004ae2:	74 08       	ld.w	r8,r10[0x0]
80004ae4:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80004ae8:	f9 b3 00 20 	moveq	r3,32
80004aec:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80004af0:	74 08       	ld.w	r8,r10[0x0]
80004af2:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80004af6:	f9 b2 00 10 	moveq	r2,16
80004afa:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80004afe:	74 08       	ld.w	r8,r10[0x0]
80004b00:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80004b04:	f9 b6 00 08 	moveq	r6,8
80004b08:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80004b0c:	74 08       	ld.w	r8,r10[0x0]
80004b0e:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80004b12:	f9 b7 00 04 	moveq	r7,4
80004b16:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80004b1a:	74 08       	ld.w	r8,r10[0x0]
80004b1c:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004b20:	f9 be 00 02 	moveq	lr,2
80004b24:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004b28:	74 08       	ld.w	r8,r10[0x0]
80004b2a:	ec 18 00 01 	eorl	r8,0x1
80004b2e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004b32:	eb e8 10 08 	or	r8,r5,r8
80004b36:	08 48       	or	r8,r4
80004b38:	06 48       	or	r8,r3
80004b3a:	04 48       	or	r8,r2
80004b3c:	0c 48       	or	r8,r6
80004b3e:	0e 48       	or	r8,r7
80004b40:	1c 48       	or	r8,lr
80004b42:	f6 0a 15 06 	lsl	r10,r11,0x6
80004b46:	f8 0a 00 0a 	add	r10,r12,r10
80004b4a:	2d 8a       	sub	r10,-40
80004b4c:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80004b4e:	a7 6b       	lsl	r11,0x6
80004b50:	2e 0b       	sub	r11,-32
80004b52:	16 0c       	add	r12,r11
80004b54:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80004b56:	58 09       	cp.w	r9,0
80004b58:	c0 31       	brne	80004b5e <tc_configure_interrupts+0x102>
80004b5a:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80004b5e:	d5 03       	csrf	0x10
80004b60:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

80004b64 <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
80004b64:	4a 78       	lddpc	r8,80004c00 <twi_master_interrupt_handler+0x9c>
80004b66:	70 08       	ld.w	r8,r8[0x0]
80004b68:	70 89       	ld.w	r9,r8[0x20]
80004b6a:	4a 7a       	lddpc	r10,80004c04 <twi_master_interrupt_handler+0xa0>
80004b6c:	74 0a       	ld.w	r10,r10[0x0]
80004b6e:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
80004b72:	12 9a       	mov	r10,r9
80004b74:	e2 1a 01 00 	andl	r10,0x100,COH
80004b78:	c3 91       	brne	80004bea <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
80004b7a:	12 9a       	mov	r10,r9
80004b7c:	e2 1a 00 02 	andl	r10,0x2,COH
80004b80:	c1 70       	breq	80004bae <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
80004b82:	4a 29       	lddpc	r9,80004c08 <twi_master_interrupt_handler+0xa4>
80004b84:	72 0a       	ld.w	r10,r9[0x0]
80004b86:	70 cb       	ld.w	r11,r8[0x30]
80004b88:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
80004b8a:	72 0a       	ld.w	r10,r9[0x0]
80004b8c:	2f fa       	sub	r10,-1
80004b8e:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
80004b90:	49 f9       	lddpc	r9,80004c0c <twi_master_interrupt_handler+0xa8>
80004b92:	72 0a       	ld.w	r10,r9[0x0]
80004b94:	20 1a       	sub	r10,1
80004b96:	93 0a       	st.w	r9[0x0],r10
80004b98:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
80004b9a:	58 19       	cp.w	r9,1
80004b9c:	f9 b9 00 02 	moveq	r9,2
80004ba0:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
80004ba4:	49 a9       	lddpc	r9,80004c0c <twi_master_interrupt_handler+0xa8>
80004ba6:	72 09       	ld.w	r9,r9[0x0]
80004ba8:	58 09       	cp.w	r9,0
80004baa:	c2 30       	breq	80004bf0 <twi_master_interrupt_handler+0x8c>
80004bac:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
80004bae:	12 9a       	mov	r10,r9
80004bb0:	e2 1a 00 04 	andl	r10,0x4,COH
80004bb4:	c1 70       	breq	80004be2 <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
80004bb6:	49 79       	lddpc	r9,80004c10 <twi_master_interrupt_handler+0xac>
80004bb8:	72 0a       	ld.w	r10,r9[0x0]
80004bba:	20 1a       	sub	r10,1
80004bbc:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
80004bbe:	72 09       	ld.w	r9,r9[0x0]
80004bc0:	58 09       	cp.w	r9,0
80004bc2:	e0 89 00 0a 	brgt	80004bd6 <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
80004bc6:	49 09       	lddpc	r9,80004c04 <twi_master_interrupt_handler+0xa0>
80004bc8:	30 1a       	mov	r10,1
80004bca:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
80004bcc:	3f fa       	mov	r10,-1
80004bce:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
80004bd0:	72 09       	ld.w	r9,r9[0x0]
80004bd2:	91 99       	st.w	r8[0x24],r9
80004bd4:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
80004bd6:	49 0a       	lddpc	r10,80004c14 <twi_master_interrupt_handler+0xb0>
80004bd8:	74 09       	ld.w	r9,r10[0x0]
80004bda:	13 3b       	ld.ub	r11,r9++
80004bdc:	91 db       	st.w	r8[0x34],r11
80004bde:	95 09       	st.w	r10[0x0],r9
80004be0:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
80004be2:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004be6:	c0 51       	brne	80004bf0 <twi_master_interrupt_handler+0x8c>
80004be8:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
80004bea:	30 1a       	mov	r10,1
80004bec:	48 b9       	lddpc	r9,80004c18 <twi_master_interrupt_handler+0xb4>
80004bee:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
80004bf0:	3f f9       	mov	r9,-1
80004bf2:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
80004bf4:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
80004bf6:	30 09       	mov	r9,0
80004bf8:	48 98       	lddpc	r8,80004c1c <twi_master_interrupt_handler+0xb8>
80004bfa:	b0 89       	st.b	r8[0x0],r9
80004bfc:	d6 03       	rete
80004bfe:	00 00       	add	r0,r0
80004c00:	00 00       	add	r0,r0
80004c02:	0c 08       	add	r8,r6
80004c04:	00 00       	add	r0,r0
80004c06:	0c 04       	add	r4,r6
80004c08:	00 00       	add	r0,r0
80004c0a:	0c 14       	sub	r4,r6
80004c0c:	00 00       	add	r0,r0
80004c0e:	0c 10       	sub	r0,r6
80004c10:	00 00       	add	r0,r0
80004c12:	0c 00       	add	r0,r6
80004c14:	00 00       	add	r0,r0
80004c16:	0c 0c       	add	r12,r6
80004c18:	00 00       	add	r0,r0
80004c1a:	0b fd       	ld.ub	sp,r5[0x7]
80004c1c:	00 00       	add	r0,r0
80004c1e:	0b fc       	ld.ub	r12,r5[0x7]

80004c20 <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
80004c20:	eb cd 40 e0 	pushm	r5-r7,lr
80004c24:	18 97       	mov	r7,r12
80004c26:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
80004c28:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
80004c2c:	49 f9       	lddpc	r9,80004ca8 <twi_master_init+0x88>
80004c2e:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
80004c30:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
80004c32:	3f f9       	mov	r9,-1
80004c34:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
80004c36:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
80004c38:	e0 69 00 80 	mov	r9,128
80004c3c:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004c3e:	e6 18 00 01 	andh	r8,0x1,COH
80004c42:	c0 21       	brne	80004c46 <twi_master_init+0x26>
      cpu_irq_enable();
80004c44:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
80004c46:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004c48:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80004c4c:	d3 03       	ssrf	0x10
	
	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();

	irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL);
80004c4e:	30 3a       	mov	r10,3
80004c50:	e0 6b 01 60 	mov	r11,352
80004c54:	49 6c       	lddpc	r12,80004cac <twi_master_init+0x8c>
80004c56:	f0 1f 00 17 	mcall	80004cb0 <twi_master_init+0x90>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004c5a:	e6 16 00 01 	andh	r6,0x1,COH
80004c5e:	c0 21       	brne	80004c62 <twi_master_init+0x42>
      cpu_irq_enable();
80004c60:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
80004c62:	6a 19       	ld.w	r9,r5[0x4]
80004c64:	a1 79       	lsl	r9,0x1
80004c66:	6a 08       	ld.w	r8,r5[0x0]
80004c68:	f0 09 0d 08 	divu	r8,r8,r9
80004c6c:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80004c6e:	e0 48 00 ff 	cp.w	r8,255
80004c72:	e0 8b 00 04 	brhi	80004c7a <twi_master_init+0x5a>
80004c76:	30 09       	mov	r9,0
80004c78:	c0 f8       	rjmp	80004c96 <twi_master_init+0x76>
80004c7a:	30 09       	mov	r9,0
80004c7c:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
80004c7e:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
80004c80:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80004c82:	e0 48 00 ff 	cp.w	r8,255
80004c86:	5f bb       	srhi	r11
80004c88:	58 69       	cp.w	r9,6
80004c8a:	5f 8a       	srls	r10
80004c8c:	f7 ea 00 0a 	and	r10,r11,r10
80004c90:	f8 0a 18 00 	cp.b	r10,r12
80004c94:	cf 51       	brne	80004c7e <twi_master_init+0x5e>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
80004c96:	b1 69       	lsl	r9,0x10
80004c98:	f3 e8 10 89 	or	r9,r9,r8<<0x8
80004c9c:	f3 e8 10 08 	or	r8,r9,r8
80004ca0:	8f 48       	st.w	r7[0x10],r8

	//Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
80004ca2:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80004ca6:	00 00       	add	r0,r0
80004ca8:	00 00       	add	r0,r0
80004caa:	0c 08       	add	r8,r6
80004cac:	80 00       	ld.sh	r0,r0[0x0]
80004cae:	4b 64       	lddpc	r4,80004d84 <usart_getchar+0x10>
80004cb0:	80 00       	ld.sh	r0,r0[0x0]
80004cb2:	48 5c       	lddpc	r12,80004cc4 <usart_set_async_baudrate+0x10>

80004cb4 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80004cb4:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80004cb6:	f6 08 15 04 	lsl	r8,r11,0x4
80004cba:	14 38       	cp.w	r8,r10
80004cbc:	f9 b8 08 10 	movls	r8,16
80004cc0:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80004cc4:	f0 0b 02 4b 	mul	r11,r8,r11
80004cc8:	f6 09 16 01 	lsr	r9,r11,0x1
80004ccc:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80004cd0:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80004cd4:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004cd8:	f2 cb 00 01 	sub	r11,r9,1
80004cdc:	e0 4b ff fe 	cp.w	r11,65534
80004ce0:	e0 88 00 03 	brls	80004ce6 <usart_set_async_baudrate+0x32>
80004ce4:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004ce6:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004ce8:	e8 6e 00 00 	mov	lr,524288
80004cec:	59 08       	cp.w	r8,16
80004cee:	fc 08 17 10 	movne	r8,lr
80004cf2:	f9 b8 00 00 	moveq	r8,0
80004cf6:	e4 1b ff f7 	andh	r11,0xfff7
80004cfa:	e0 1b fe cf 	andl	r11,0xfecf
80004cfe:	16 48       	or	r8,r11
80004d00:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80004d02:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80004d06:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80004d0a:	99 89       	st.w	r12[0x20],r9
80004d0c:	d8 0a       	popm	pc,r12=0

80004d0e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004d0e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80004d10:	e2 18 00 02 	andl	r8,0x2,COH
80004d14:	c0 31       	brne	80004d1a <usart_write_char+0xc>
80004d16:	30 2c       	mov	r12,2
80004d18:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004d1a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80004d1e:	99 7b       	st.w	r12[0x1c],r11
80004d20:	5e fd       	retal	0
80004d22:	d7 03       	nop

80004d24 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004d24:	eb cd 40 e0 	pushm	r5-r7,lr
80004d28:	18 96       	mov	r6,r12
80004d2a:	16 95       	mov	r5,r11
80004d2c:	e0 67 27 0f 	mov	r7,9999
80004d30:	c0 68       	rjmp	80004d3c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80004d32:	58 07       	cp.w	r7,0
80004d34:	c0 31       	brne	80004d3a <usart_putchar+0x16>
80004d36:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80004d3a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004d3c:	0a 9b       	mov	r11,r5
80004d3e:	0c 9c       	mov	r12,r6
80004d40:	f0 1f 00 03 	mcall	80004d4c <usart_putchar+0x28>
80004d44:	cf 71       	brne	80004d32 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80004d46:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004d4a:	00 00       	add	r0,r0
80004d4c:	80 00       	ld.sh	r0,r0[0x0]
80004d4e:	4d 0e       	lddpc	lr,80004e8c <usart_init_rs232+0x9c>

80004d50 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004d50:	78 58       	ld.w	r8,r12[0x14]
80004d52:	e2 18 00 e0 	andl	r8,0xe0,COH
80004d56:	c0 30       	breq	80004d5c <usart_read_char+0xc>
80004d58:	30 4c       	mov	r12,4
80004d5a:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004d5c:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004d5e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004d62:	c0 31       	brne	80004d68 <usart_read_char+0x18>
80004d64:	30 3c       	mov	r12,3
80004d66:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004d68:	78 68       	ld.w	r8,r12[0x18]
80004d6a:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80004d6e:	97 08       	st.w	r11[0x0],r8
80004d70:	5e fd       	retal	0
80004d72:	d7 03       	nop

80004d74 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80004d74:	eb cd 40 c0 	pushm	r6-r7,lr
80004d78:	20 1d       	sub	sp,4
80004d7a:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004d7c:	1a 97       	mov	r7,sp
80004d7e:	1a 9b       	mov	r11,sp
80004d80:	0c 9c       	mov	r12,r6
80004d82:	f0 1f 00 07 	mcall	80004d9c <usart_getchar+0x28>
80004d86:	58 3c       	cp.w	r12,3
80004d88:	cf b0       	breq	80004d7e <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80004d8a:	58 4c       	cp.w	r12,4
80004d8c:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80004d90:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80004d94:	2f fd       	sub	sp,-4
80004d96:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d9a:	00 00       	add	r0,r0
80004d9c:	80 00       	ld.sh	r0,r0[0x0]
80004d9e:	4d 50       	lddpc	r0,80004ef0 <vListInsertEnd+0x1a>

80004da0 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80004da0:	eb cd 40 c0 	pushm	r6-r7,lr
80004da4:	18 96       	mov	r6,r12
80004da6:	16 97       	mov	r7,r11
  while (*string != '\0')
80004da8:	17 8b       	ld.ub	r11,r11[0x0]
80004daa:	58 0b       	cp.w	r11,0
80004dac:	c0 80       	breq	80004dbc <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80004dae:	2f f7       	sub	r7,-1
80004db0:	0c 9c       	mov	r12,r6
80004db2:	f0 1f 00 04 	mcall	80004dc0 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80004db6:	0f 8b       	ld.ub	r11,r7[0x0]
80004db8:	58 0b       	cp.w	r11,0
80004dba:	cf a1       	brne	80004dae <usart_write_line+0xe>
80004dbc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004dc0:	80 00       	ld.sh	r0,r0[0x0]
80004dc2:	4d 24       	lddpc	r4,80004f08 <vListInsert+0x16>

80004dc4 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80004dc4:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80004dc8:	e6 18 00 01 	andh	r8,0x1,COH
80004dcc:	c0 71       	brne	80004dda <usart_reset+0x16>
80004dce:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80004dd0:	3f f8       	mov	r8,-1
80004dd2:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004dd4:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80004dd6:	d5 03       	csrf	0x10
80004dd8:	c0 48       	rjmp	80004de0 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80004dda:	3f f8       	mov	r8,-1
80004ddc:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004dde:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004de0:	30 08       	mov	r8,0
80004de2:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80004de4:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80004de6:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80004de8:	ea 68 61 0c 	mov	r8,680204
80004dec:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004dee:	5e fc       	retal	r12

80004df0 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004df0:	eb cd 40 e0 	pushm	r5-r7,lr
80004df4:	18 96       	mov	r6,r12
80004df6:	16 97       	mov	r7,r11
80004df8:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004dfa:	f0 1f 00 2f 	mcall	80004eb4 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80004dfe:	58 07       	cp.w	r7,0
80004e00:	c5 80       	breq	80004eb0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80004e02:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004e04:	30 49       	mov	r9,4
80004e06:	f2 08 18 00 	cp.b	r8,r9
80004e0a:	e0 88 00 53 	brls	80004eb0 <usart_init_rs232+0xc0>
80004e0e:	30 99       	mov	r9,9
80004e10:	f2 08 18 00 	cp.b	r8,r9
80004e14:	e0 8b 00 4e 	brhi	80004eb0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004e18:	0f d9       	ld.ub	r9,r7[0x5]
80004e1a:	30 78       	mov	r8,7
80004e1c:	f0 09 18 00 	cp.b	r9,r8
80004e20:	e0 8b 00 48 	brhi	80004eb0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80004e24:	8e 39       	ld.sh	r9,r7[0x6]
80004e26:	e0 68 01 01 	mov	r8,257
80004e2a:	f0 09 19 00 	cp.h	r9,r8
80004e2e:	e0 8b 00 41 	brhi	80004eb0 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80004e32:	ef 39 00 08 	ld.ub	r9,r7[8]
80004e36:	30 38       	mov	r8,3
80004e38:	f0 09 18 00 	cp.b	r9,r8
80004e3c:	e0 8b 00 3a 	brhi	80004eb0 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004e40:	0a 9a       	mov	r10,r5
80004e42:	6e 0b       	ld.w	r11,r7[0x0]
80004e44:	0c 9c       	mov	r12,r6
80004e46:	f0 1f 00 1d 	mcall	80004eb8 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004e4a:	58 1c       	cp.w	r12,1
80004e4c:	c3 20       	breq	80004eb0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80004e4e:	0f c8       	ld.ub	r8,r7[0x4]
80004e50:	30 99       	mov	r9,9
80004e52:	f2 08 18 00 	cp.b	r8,r9
80004e56:	c0 51       	brne	80004e60 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004e58:	6c 18       	ld.w	r8,r6[0x4]
80004e5a:	b1 b8       	sbr	r8,0x11
80004e5c:	8d 18       	st.w	r6[0x4],r8
80004e5e:	c0 68       	rjmp	80004e6a <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004e60:	6c 19       	ld.w	r9,r6[0x4]
80004e62:	20 58       	sub	r8,5
80004e64:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80004e68:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004e6a:	6c 19       	ld.w	r9,r6[0x4]
80004e6c:	ef 3a 00 08 	ld.ub	r10,r7[8]
80004e70:	0f d8       	ld.ub	r8,r7[0x5]
80004e72:	a9 78       	lsl	r8,0x9
80004e74:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80004e78:	12 48       	or	r8,r9
80004e7a:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004e7c:	8e 38       	ld.sh	r8,r7[0x6]
80004e7e:	30 29       	mov	r9,2
80004e80:	f2 08 19 00 	cp.h	r8,r9
80004e84:	e0 88 00 09 	brls	80004e96 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004e88:	6c 18       	ld.w	r8,r6[0x4]
80004e8a:	ad b8       	sbr	r8,0xd
80004e8c:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004e8e:	8e b8       	ld.uh	r8,r7[0x6]
80004e90:	20 28       	sub	r8,2
80004e92:	8d a8       	st.w	r6[0x28],r8
80004e94:	c0 68       	rjmp	80004ea0 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004e96:	6c 19       	ld.w	r9,r6[0x4]
80004e98:	5c 78       	castu.h	r8
80004e9a:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80004e9e:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004ea0:	6c 18       	ld.w	r8,r6[0x4]
80004ea2:	e0 18 ff f0 	andl	r8,0xfff0
80004ea6:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004ea8:	35 08       	mov	r8,80
80004eaa:	8d 08       	st.w	r6[0x0],r8
80004eac:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004eb0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80004eb4:	80 00       	ld.sh	r0,r0[0x0]
80004eb6:	4d c4       	lddpc	r4,80005024 <xPortStartScheduler+0x34>
80004eb8:	80 00       	ld.sh	r0,r0[0x0]
80004eba:	4c b4       	lddpc	r4,80004fe4 <vPortEnterCritical+0x4>

80004ebc <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004ebc:	f8 c8 ff f8 	sub	r8,r12,-8
80004ec0:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004ec2:	3f f9       	mov	r9,-1
80004ec4:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004ec6:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004ec8:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004eca:	30 08       	mov	r8,0
80004ecc:	99 08       	st.w	r12[0x0],r8
}
80004ece:	5e fc       	retal	r12

80004ed0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004ed0:	30 08       	mov	r8,0
80004ed2:	99 48       	st.w	r12[0x10],r8
}
80004ed4:	5e fc       	retal	r12

80004ed6 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004ed6:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80004ed8:	70 19       	ld.w	r9,r8[0x4]
80004eda:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004edc:	78 19       	ld.w	r9,r12[0x4]
80004ede:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004ee0:	70 19       	ld.w	r9,r8[0x4]
80004ee2:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004ee4:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004ee6:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004ee8:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004eea:	78 08       	ld.w	r8,r12[0x0]
80004eec:	2f f8       	sub	r8,-1
80004eee:	99 08       	st.w	r12[0x0],r8
}
80004ef0:	5e fc       	retal	r12

80004ef2 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004ef2:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004ef4:	5b fa       	cp.w	r10,-1
80004ef6:	c0 31       	brne	80004efc <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004ef8:	78 48       	ld.w	r8,r12[0x10]
80004efa:	c0 c8       	rjmp	80004f12 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004efc:	f8 c8 ff f8 	sub	r8,r12,-8
80004f00:	70 19       	ld.w	r9,r8[0x4]
80004f02:	72 09       	ld.w	r9,r9[0x0]
80004f04:	12 3a       	cp.w	r10,r9
80004f06:	c0 63       	brcs	80004f12 <vListInsert+0x20>
80004f08:	70 18       	ld.w	r8,r8[0x4]
80004f0a:	70 19       	ld.w	r9,r8[0x4]
80004f0c:	72 09       	ld.w	r9,r9[0x0]
80004f0e:	12 3a       	cp.w	r10,r9
80004f10:	cf c2       	brcc	80004f08 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80004f12:	70 19       	ld.w	r9,r8[0x4]
80004f14:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004f16:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80004f18:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80004f1a:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004f1c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004f1e:	78 08       	ld.w	r8,r12[0x0]
80004f20:	2f f8       	sub	r8,-1
80004f22:	99 08       	st.w	r12[0x0],r8
}
80004f24:	5e fc       	retal	r12

80004f26 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80004f26:	78 18       	ld.w	r8,r12[0x4]
80004f28:	78 29       	ld.w	r9,r12[0x8]
80004f2a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80004f2c:	78 28       	ld.w	r8,r12[0x8]
80004f2e:	78 19       	ld.w	r9,r12[0x4]
80004f30:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80004f32:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80004f34:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80004f36:	18 39       	cp.w	r9,r12
80004f38:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80004f3c:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004f40:	30 09       	mov	r9,0
80004f42:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80004f44:	70 09       	ld.w	r9,r8[0x0]
80004f46:	20 19       	sub	r9,1
80004f48:	91 09       	st.w	r8[0x0],r9
}
80004f4a:	5e fc       	retal	r12

80004f4c <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80004f4c:	e0 68 08 08 	mov	r8,2056
80004f50:	ea 18 08 08 	orh	r8,0x808
80004f54:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80004f56:	e0 68 09 09 	mov	r8,2313
80004f5a:	ea 18 09 09 	orh	r8,0x909
80004f5e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80004f60:	e0 68 0a 0a 	mov	r8,2570
80004f64:	ea 18 0a 0a 	orh	r8,0xa0a
80004f68:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80004f6a:	e0 68 0b 0b 	mov	r8,2827
80004f6e:	ea 18 0b 0b 	orh	r8,0xb0b
80004f72:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80004f74:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80004f76:	e0 68 be ef 	mov	r8,48879
80004f7a:	ea 18 de ad 	orh	r8,0xdead
80004f7e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80004f80:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80004f82:	fc 18 00 40 	movh	r8,0x40
80004f86:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80004f88:	e0 68 00 ff 	mov	r8,255
80004f8c:	ea 18 ff 00 	orh	r8,0xff00
80004f90:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80004f92:	e0 68 01 01 	mov	r8,257
80004f96:	ea 18 01 01 	orh	r8,0x101
80004f9a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80004f9c:	e0 68 02 02 	mov	r8,514
80004fa0:	ea 18 02 02 	orh	r8,0x202
80004fa4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80004fa6:	e0 68 03 03 	mov	r8,771
80004faa:	ea 18 03 03 	orh	r8,0x303
80004fae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80004fb0:	e0 68 04 04 	mov	r8,1028
80004fb4:	ea 18 04 04 	orh	r8,0x404
80004fb8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80004fba:	e0 68 05 05 	mov	r8,1285
80004fbe:	ea 18 05 05 	orh	r8,0x505
80004fc2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80004fc4:	e0 68 06 06 	mov	r8,1542
80004fc8:	ea 18 06 06 	orh	r8,0x606
80004fcc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80004fce:	e0 68 07 07 	mov	r8,1799
80004fd2:	ea 18 07 07 	orh	r8,0x707
80004fd6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80004fd8:	30 08       	mov	r8,0
80004fda:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80004fdc:	5e fc       	retal	r12
80004fde:	d7 03       	nop

80004fe0 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80004fe0:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80004fe2:	48 38       	lddpc	r8,80004fec <vPortEnterCritical+0xc>
80004fe4:	70 09       	ld.w	r9,r8[0x0]
80004fe6:	2f f9       	sub	r9,-1
80004fe8:	91 09       	st.w	r8[0x0],r9
}
80004fea:	5e fc       	retal	r12
80004fec:	00 00       	add	r0,r0
80004fee:	05 28       	ld.uh	r8,r2++

80004ff0 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80004ff0:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80004ff2:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80004ff4:	30 0a       	mov	r10,0
80004ff6:	14 9b       	mov	r11,r10
80004ff8:	49 2c       	lddpc	r12,80005040 <xPortStartScheduler+0x50>
80004ffa:	f0 1f 00 13 	mcall	80005044 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80004ffe:	e0 68 5d c0 	mov	r8,24000
80005002:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005006:	30 08       	mov	r8,0
80005008:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000500c:	e0 68 0c e8 	mov	r8,3304
80005010:	ea 18 00 00 	orh	r8,0x0
80005014:	70 00       	ld.w	r0,r8[0x0]
80005016:	60 0d       	ld.w	sp,r0[0x0]
80005018:	1b 00       	ld.w	r0,sp++
8000501a:	e0 68 05 28 	mov	r8,1320
8000501e:	ea 18 00 00 	orh	r8,0x0
80005022:	91 00       	st.w	r8[0x0],r0
80005024:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005028:	2f ed       	sub	sp,-8
8000502a:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000502e:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005032:	e3 b0 00 00 	mtsr	0x0,r0
80005036:	fa f0 ff dc 	ld.w	r0,sp[-36]
8000503a:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
8000503e:	d8 0a       	popm	pc,r12=0
80005040:	80 00       	ld.sh	r0,r0[0x0]
80005042:	51 0c       	stdsp	sp[0x40],r12
80005044:	80 00       	ld.sh	r0,r0[0x0]
80005046:	48 5c       	lddpc	r12,80005058 <SCALLYield+0x10>

80005048 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005048:	20 6d       	sub	sp,24
8000504a:	eb cd 00 ff 	pushm	r0-r7
8000504e:	fa c7 ff c0 	sub	r7,sp,-64
80005052:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005056:	ef 40 ff e0 	st.w	r7[-32],r0
8000505a:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000505e:	ef 40 ff e4 	st.w	r7[-28],r0
80005062:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005066:	e0 68 05 28 	mov	r8,1320
8000506a:	ea 18 00 00 	orh	r8,0x0
8000506e:	70 00       	ld.w	r0,r8[0x0]
80005070:	1a d0       	st.w	--sp,r0
80005072:	f0 1f 00 1a 	mcall	800050d8 <LABEL_RET_SCALL_263+0x14>
80005076:	e0 68 0c e8 	mov	r8,3304
8000507a:	ea 18 00 00 	orh	r8,0x0
8000507e:	70 00       	ld.w	r0,r8[0x0]
80005080:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005082:	f0 1f 00 17 	mcall	800050dc <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005086:	e0 68 0c e8 	mov	r8,3304
8000508a:	ea 18 00 00 	orh	r8,0x0
8000508e:	70 00       	ld.w	r0,r8[0x0]
80005090:	60 0d       	ld.w	sp,r0[0x0]
80005092:	1b 00       	ld.w	r0,sp++
80005094:	e0 68 05 28 	mov	r8,1320
80005098:	ea 18 00 00 	orh	r8,0x0
8000509c:	91 00       	st.w	r8[0x0],r0
8000509e:	fa c7 ff d8 	sub	r7,sp,-40
800050a2:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800050a6:	ee f0 ff e0 	ld.w	r0,r7[-32]
800050aa:	e0 61 05 28 	mov	r1,1320
800050ae:	ea 11 00 00 	orh	r1,0x0
800050b2:	62 02       	ld.w	r2,r1[0x0]
800050b4:	58 02       	cp.w	r2,0
800050b6:	c0 70       	breq	800050c4 <LABEL_RET_SCALL_263>
800050b8:	e4 c2 00 01 	sub	r2,r2,1
800050bc:	83 02       	st.w	r1[0x0],r2
800050be:	58 02       	cp.w	r2,0
800050c0:	c0 21       	brne	800050c4 <LABEL_RET_SCALL_263>
800050c2:	b1 c0       	cbr	r0,0x10

800050c4 <LABEL_RET_SCALL_263>:
800050c4:	ef 40 ff f8 	st.w	r7[-8],r0
800050c8:	ee f0 ff e4 	ld.w	r0,r7[-28]
800050cc:	ef 40 ff fc 	st.w	r7[-4],r0
800050d0:	e3 cd 00 ff 	ldm	sp++,r0-r7
800050d4:	2f ad       	sub	sp,-24
800050d6:	d6 13       	rets
800050d8:	80 00       	ld.sh	r0,r0[0x0]
800050da:	4f e0       	lddpc	r0,800052d0 <xQueueReceiveFromISR+0x2c>
800050dc:	80 00       	ld.sh	r0,r0[0x0]
800050de:	57 7c       	stdsp	sp[0x1dc],r12

800050e0 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800050e0:	e1 b8 00 43 	mfsr	r8,0x10c
800050e4:	e3 b8 00 43 	mtsr	0x10c,r8
	}
800050e8:	5e fc       	retal	r12
800050ea:	d7 03       	nop

800050ec <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
800050ec:	48 78       	lddpc	r8,80005108 <vPortExitCritical+0x1c>
800050ee:	70 08       	ld.w	r8,r8[0x0]
800050f0:	58 08       	cp.w	r8,0
800050f2:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
800050f4:	48 58       	lddpc	r8,80005108 <vPortExitCritical+0x1c>
800050f6:	70 09       	ld.w	r9,r8[0x0]
800050f8:	20 19       	sub	r9,1
800050fa:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
800050fc:	70 08       	ld.w	r8,r8[0x0]
800050fe:	58 08       	cp.w	r8,0
80005100:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005102:	d5 03       	csrf	0x10
80005104:	5e fc       	retal	r12
80005106:	00 00       	add	r0,r0
80005108:	00 00       	add	r0,r0
8000510a:	05 28       	ld.uh	r8,r2++

8000510c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
8000510c:	eb cd 00 ff 	pushm	r0-r7
80005110:	e0 68 05 28 	mov	r8,1320
80005114:	ea 18 00 00 	orh	r8,0x0
80005118:	70 00       	ld.w	r0,r8[0x0]
8000511a:	1a d0       	st.w	--sp,r0
8000511c:	7a 90       	ld.w	r0,sp[0x24]
8000511e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005122:	58 10       	cp.w	r0,1
80005124:	e0 8b 00 08 	brhi	80005134 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005128:	e0 68 0c e8 	mov	r8,3304
8000512c:	ea 18 00 00 	orh	r8,0x0
80005130:	70 00       	ld.w	r0,r8[0x0]
80005132:	81 0d       	st.w	r0[0x0],sp

80005134 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005134:	f0 1f 00 12 	mcall	8000517c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005138:	f0 1f 00 12 	mcall	80005180 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
8000513c:	f0 1f 00 12 	mcall	80005184 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005140:	f0 1f 00 12 	mcall	80005188 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005144:	7a 90       	ld.w	r0,sp[0x24]
80005146:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000514a:	58 10       	cp.w	r0,1
8000514c:	e0 8b 00 0e 	brhi	80005168 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005150:	f0 1f 00 0c 	mcall	80005180 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005154:	f0 1f 00 0e 	mcall	8000518c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005158:	f0 1f 00 0c 	mcall	80005188 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
8000515c:	e0 68 0c e8 	mov	r8,3304
80005160:	ea 18 00 00 	orh	r8,0x0
80005164:	70 00       	ld.w	r0,r8[0x0]
80005166:	60 0d       	ld.w	sp,r0[0x0]

80005168 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005168:	1b 00       	ld.w	r0,sp++
8000516a:	e0 68 05 28 	mov	r8,1320
8000516e:	ea 18 00 00 	orh	r8,0x0
80005172:	91 00       	st.w	r8[0x0],r0
80005174:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005178:	d6 03       	rete
8000517a:	00 00       	add	r0,r0
8000517c:	80 00       	ld.sh	r0,r0[0x0]
8000517e:	50 e0       	stdsp	sp[0x38],r0
80005180:	80 00       	ld.sh	r0,r0[0x0]
80005182:	4f e0       	lddpc	r0,80005378 <prvUnlockQueue+0x84>
80005184:	80 00       	ld.sh	r0,r0[0x0]
80005186:	59 80       	cp.w	r0,24
80005188:	80 00       	ld.sh	r0,r0[0x0]
8000518a:	50 ec       	stdsp	sp[0x38],r12
8000518c:	80 00       	ld.sh	r0,r0[0x0]
8000518e:	57 7c       	stdsp	sp[0x1dc],r12

80005190 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005190:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005192:	f0 1f 00 02 	mcall	80005198 <__malloc_lock+0x8>
}
80005196:	d8 02       	popm	pc
80005198:	80 00       	ld.sh	r0,r0[0x0]
8000519a:	57 6c       	stdsp	sp[0x1d8],r12

8000519c <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
8000519c:	d4 01       	pushm	lr
	xTaskResumeAll();
8000519e:	f0 1f 00 02 	mcall	800051a4 <__malloc_unlock+0x8>
}
800051a2:	d8 02       	popm	pc
800051a4:	80 00       	ld.sh	r0,r0[0x0]
800051a6:	5b 28       	cp.w	r8,-14

800051a8 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
800051a8:	d4 21       	pushm	r4-r7,lr
800051aa:	16 95       	mov	r5,r11
800051ac:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
800051ae:	58 0c       	cp.w	r12,0
800051b0:	c0 30       	breq	800051b6 <_read+0xe>
800051b2:	3f f7       	mov	r7,-1
800051b4:	c1 48       	rjmp	800051dc <_read+0x34>
    return -1;

  for (; len > 0; --len)
800051b6:	58 0a       	cp.w	r10,0
800051b8:	e0 89 00 04 	brgt	800051c0 <_read+0x18>
800051bc:	30 07       	mov	r7,0
800051be:	c0 f8       	rjmp	800051dc <_read+0x34>
800051c0:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
800051c2:	48 84       	lddpc	r4,800051e0 <_read+0x38>
800051c4:	68 0c       	ld.w	r12,r4[0x0]
800051c6:	f0 1f 00 08 	mcall	800051e4 <_read+0x3c>
    if (c < 0)
800051ca:	c0 95       	brlt	800051dc <_read+0x34>
      break;

    *ptr++ = c;
800051cc:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
800051d0:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
800051d2:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
800051d6:	58 08       	cp.w	r8,0
800051d8:	fe 99 ff f6 	brgt	800051c4 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
800051dc:	0e 9c       	mov	r12,r7
800051de:	d8 22       	popm	r4-r7,pc
800051e0:	00 00       	add	r0,r0
800051e2:	40 f4       	lddsp	r4,sp[0x3c]
800051e4:	80 00       	ld.sh	r0,r0[0x0]
800051e6:	4d 74       	lddpc	r4,80005340 <prvUnlockQueue+0x4c>

800051e8 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
800051e8:	d4 21       	pushm	r4-r7,lr
800051ea:	16 95       	mov	r5,r11
800051ec:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
800051ee:	20 1c       	sub	r12,1
800051f0:	58 2c       	cp.w	r12,2
800051f2:	e0 8b 00 12 	brhi	80005216 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800051f6:	58 0a       	cp.w	r10,0
800051f8:	c0 31       	brne	800051fe <_write+0x16>
800051fa:	30 07       	mov	r7,0
800051fc:	c0 e8       	rjmp	80005218 <_write+0x30>
800051fe:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005200:	48 74       	lddpc	r4,8000521c <_write+0x34>
80005202:	68 0c       	ld.w	r12,r4[0x0]
80005204:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005208:	f0 1f 00 06 	mcall	80005220 <_write+0x38>
8000520c:	c0 55       	brlt	80005216 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
8000520e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005210:	0e 36       	cp.w	r6,r7
80005212:	cf 81       	brne	80005202 <_write+0x1a>
80005214:	c0 28       	rjmp	80005218 <_write+0x30>
80005216:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005218:	0e 9c       	mov	r12,r7
8000521a:	d8 22       	popm	r4-r7,pc
8000521c:	00 00       	add	r0,r0
8000521e:	40 f4       	lddsp	r4,sp[0x3c]
80005220:	80 00       	ld.sh	r0,r0[0x0]
80005222:	4d 24       	lddpc	r4,80005368 <prvUnlockQueue+0x74>

80005224 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005224:	eb cd 40 80 	pushm	r7,lr
80005228:	18 97       	mov	r7,r12
	if( pv )
8000522a:	58 0c       	cp.w	r12,0
8000522c:	c0 80       	breq	8000523c <vPortFree+0x18>
	{
		vTaskSuspendAll();
8000522e:	f0 1f 00 05 	mcall	80005240 <vPortFree+0x1c>
		{
			free( pv );
80005232:	0e 9c       	mov	r12,r7
80005234:	f0 1f 00 04 	mcall	80005244 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005238:	f0 1f 00 04 	mcall	80005248 <vPortFree+0x24>
8000523c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005240:	80 00       	ld.sh	r0,r0[0x0]
80005242:	57 6c       	stdsp	sp[0x1d8],r12
80005244:	80 00       	ld.sh	r0,r0[0x0]
80005246:	66 98       	ld.w	r8,r3[0x24]
80005248:	80 00       	ld.sh	r0,r0[0x0]
8000524a:	5b 28       	cp.w	r8,-14

8000524c <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
8000524c:	eb cd 40 80 	pushm	r7,lr
80005250:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005252:	f0 1f 00 06 	mcall	80005268 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005256:	0e 9c       	mov	r12,r7
80005258:	f0 1f 00 05 	mcall	8000526c <pvPortMalloc+0x20>
8000525c:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000525e:	f0 1f 00 05 	mcall	80005270 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005262:	0e 9c       	mov	r12,r7
80005264:	e3 cd 80 80 	ldm	sp++,r7,pc
80005268:	80 00       	ld.sh	r0,r0[0x0]
8000526a:	57 6c       	stdsp	sp[0x1d8],r12
8000526c:	80 00       	ld.sh	r0,r0[0x0]
8000526e:	66 a8       	ld.w	r8,r3[0x28]
80005270:	80 00       	ld.sh	r0,r0[0x0]
80005272:	5b 28       	cp.w	r8,-14

80005274 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005274:	d4 01       	pushm	lr
80005276:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005278:	78 09       	ld.w	r9,r12[0x0]
8000527a:	58 09       	cp.w	r9,0
8000527c:	c1 10       	breq	8000529e <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000527e:	78 3a       	ld.w	r10,r12[0xc]
80005280:	79 09       	ld.w	r9,r12[0x40]
80005282:	f4 09 00 09 	add	r9,r10,r9
80005286:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005288:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000528a:	14 39       	cp.w	r9,r10
8000528c:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005290:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005294:	79 0a       	ld.w	r10,r12[0x40]
80005296:	78 3b       	ld.w	r11,r12[0xc]
80005298:	10 9c       	mov	r12,r8
8000529a:	f0 1f 00 02 	mcall	800052a0 <prvCopyDataFromQueue+0x2c>
8000529e:	d8 02       	popm	pc
800052a0:	80 00       	ld.sh	r0,r0[0x0]
800052a2:	6a f0       	ld.w	r0,r5[0x3c]

800052a4 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
800052a4:	eb cd 40 c0 	pushm	r6-r7,lr
800052a8:	18 97       	mov	r7,r12
800052aa:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800052ac:	78 e8       	ld.w	r8,r12[0x38]
800052ae:	58 08       	cp.w	r8,0
800052b0:	c0 31       	brne	800052b6 <xQueueReceiveFromISR+0x12>
800052b2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
800052b6:	f0 1f 00 0e 	mcall	800052ec <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
800052ba:	6e e8       	ld.w	r8,r7[0x38]
800052bc:	20 18       	sub	r8,1
800052be:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
800052c0:	6f 18       	ld.w	r8,r7[0x44]
800052c2:	5b f8       	cp.w	r8,-1
800052c4:	c0 d1       	brne	800052de <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800052c6:	6e 48       	ld.w	r8,r7[0x10]
800052c8:	58 08       	cp.w	r8,0
800052ca:	c0 f0       	breq	800052e8 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800052cc:	ee cc ff f0 	sub	r12,r7,-16
800052d0:	f0 1f 00 08 	mcall	800052f0 <xQueueReceiveFromISR+0x4c>
800052d4:	c0 a0       	breq	800052e8 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
800052d6:	30 1c       	mov	r12,1
800052d8:	8d 0c       	st.w	r6[0x0],r12
800052da:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
800052de:	2f f8       	sub	r8,-1
800052e0:	ef 48 00 44 	st.w	r7[68],r8
800052e4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800052e8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800052ec:	80 00       	ld.sh	r0,r0[0x0]
800052ee:	52 74       	stdsp	sp[0x9c],r4
800052f0:	80 00       	ld.sh	r0,r0[0x0]
800052f2:	59 04       	cp.w	r4,16

800052f4 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
800052f4:	eb cd 40 c0 	pushm	r6-r7,lr
800052f8:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
800052fa:	f0 1f 00 23 	mcall	80005384 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800052fe:	6f 28       	ld.w	r8,r7[0x48]
80005300:	58 08       	cp.w	r8,0
80005302:	e0 8a 00 18 	brle	80005332 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005306:	6e 98       	ld.w	r8,r7[0x24]
80005308:	58 08       	cp.w	r8,0
8000530a:	c1 40       	breq	80005332 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000530c:	ee c6 ff dc 	sub	r6,r7,-36
80005310:	c0 48       	rjmp	80005318 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005312:	6e 98       	ld.w	r8,r7[0x24]
80005314:	58 08       	cp.w	r8,0
80005316:	c0 e0       	breq	80005332 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005318:	0c 9c       	mov	r12,r6
8000531a:	f0 1f 00 1c 	mcall	80005388 <prvUnlockQueue+0x94>
8000531e:	c0 30       	breq	80005324 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005320:	f0 1f 00 1b 	mcall	8000538c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005324:	6f 28       	ld.w	r8,r7[0x48]
80005326:	20 18       	sub	r8,1
80005328:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000532c:	58 08       	cp.w	r8,0
8000532e:	fe 99 ff f2 	brgt	80005312 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005332:	3f f8       	mov	r8,-1
80005334:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005338:	f0 1f 00 16 	mcall	80005390 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
8000533c:	f0 1f 00 12 	mcall	80005384 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005340:	6f 18       	ld.w	r8,r7[0x44]
80005342:	58 08       	cp.w	r8,0
80005344:	e0 8a 00 18 	brle	80005374 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005348:	6e 48       	ld.w	r8,r7[0x10]
8000534a:	58 08       	cp.w	r8,0
8000534c:	c1 40       	breq	80005374 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000534e:	ee c6 ff f0 	sub	r6,r7,-16
80005352:	c0 48       	rjmp	8000535a <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005354:	6e 48       	ld.w	r8,r7[0x10]
80005356:	58 08       	cp.w	r8,0
80005358:	c0 e0       	breq	80005374 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000535a:	0c 9c       	mov	r12,r6
8000535c:	f0 1f 00 0b 	mcall	80005388 <prvUnlockQueue+0x94>
80005360:	c0 30       	breq	80005366 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005362:	f0 1f 00 0b 	mcall	8000538c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005366:	6f 18       	ld.w	r8,r7[0x44]
80005368:	20 18       	sub	r8,1
8000536a:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000536e:	58 08       	cp.w	r8,0
80005370:	fe 99 ff f2 	brgt	80005354 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005374:	3f f8       	mov	r8,-1
80005376:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
8000537a:	f0 1f 00 06 	mcall	80005390 <prvUnlockQueue+0x9c>
}
8000537e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005382:	00 00       	add	r0,r0
80005384:	80 00       	ld.sh	r0,r0[0x0]
80005386:	4f e0       	lddpc	r0,8000557c <xQueueGenericSendFromISR+0x2c>
80005388:	80 00       	ld.sh	r0,r0[0x0]
8000538a:	59 04       	cp.w	r4,16
8000538c:	80 00       	ld.sh	r0,r0[0x0]
8000538e:	58 10       	cp.w	r0,1
80005390:	80 00       	ld.sh	r0,r0[0x0]
80005392:	50 ec       	stdsp	sp[0x38],r12

80005394 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005394:	d4 31       	pushm	r0-r7,lr
80005396:	20 5d       	sub	sp,20
80005398:	18 97       	mov	r7,r12
8000539a:	50 0b       	stdsp	sp[0x0],r11
8000539c:	50 2a       	stdsp	sp[0x8],r10
8000539e:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800053a0:	f8 c2 ff dc 	sub	r2,r12,-36
800053a4:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800053a6:	fa c4 ff f4 	sub	r4,sp,-12
800053aa:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800053ac:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800053ae:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800053b2:	f0 1f 00 3e 	mcall	800054a8 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800053b6:	6e e8       	ld.w	r8,r7[0x38]
800053b8:	58 08       	cp.w	r8,0
800053ba:	c2 a0       	breq	8000540e <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800053bc:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800053be:	40 0b       	lddsp	r11,sp[0x0]
800053c0:	0e 9c       	mov	r12,r7
800053c2:	f0 1f 00 3b 	mcall	800054ac <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800053c6:	40 18       	lddsp	r8,sp[0x4]
800053c8:	58 08       	cp.w	r8,0
800053ca:	c1 51       	brne	800053f4 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800053cc:	6e e8       	ld.w	r8,r7[0x38]
800053ce:	20 18       	sub	r8,1
800053d0:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800053d2:	6e 08       	ld.w	r8,r7[0x0]
800053d4:	58 08       	cp.w	r8,0
800053d6:	c0 41       	brne	800053de <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800053d8:	f0 1f 00 36 	mcall	800054b0 <xQueueGenericReceive+0x11c>
800053dc:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800053de:	6e 48       	ld.w	r8,r7[0x10]
800053e0:	58 08       	cp.w	r8,0
800053e2:	c1 20       	breq	80005406 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800053e4:	ee cc ff f0 	sub	r12,r7,-16
800053e8:	f0 1f 00 33 	mcall	800054b4 <xQueueGenericReceive+0x120>
800053ec:	58 1c       	cp.w	r12,1
800053ee:	c0 c1       	brne	80005406 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800053f0:	d7 33       	scall
800053f2:	c0 a8       	rjmp	80005406 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800053f4:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800053f6:	6e 98       	ld.w	r8,r7[0x24]
800053f8:	58 08       	cp.w	r8,0
800053fa:	c0 60       	breq	80005406 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800053fc:	04 9c       	mov	r12,r2
800053fe:	f0 1f 00 2e 	mcall	800054b4 <xQueueGenericReceive+0x120>
80005402:	c0 20       	breq	80005406 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005404:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005406:	f0 1f 00 2d 	mcall	800054b8 <xQueueGenericReceive+0x124>
8000540a:	30 1c       	mov	r12,1
				return pdPASS;
8000540c:	c4 c8       	rjmp	800054a4 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000540e:	40 28       	lddsp	r8,sp[0x8]
80005410:	58 08       	cp.w	r8,0
80005412:	c0 51       	brne	8000541c <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005414:	f0 1f 00 29 	mcall	800054b8 <xQueueGenericReceive+0x124>
80005418:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000541a:	c4 58       	rjmp	800054a4 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
8000541c:	58 05       	cp.w	r5,0
8000541e:	c0 51       	brne	80005428 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005420:	08 9c       	mov	r12,r4
80005422:	f0 1f 00 27 	mcall	800054bc <xQueueGenericReceive+0x128>
80005426:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005428:	f0 1f 00 24 	mcall	800054b8 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000542c:	f0 1f 00 25 	mcall	800054c0 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005430:	f0 1f 00 1e 	mcall	800054a8 <xQueueGenericReceive+0x114>
80005434:	6f 18       	ld.w	r8,r7[0x44]
80005436:	5b f8       	cp.w	r8,-1
80005438:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000543c:	6f 28       	ld.w	r8,r7[0x48]
8000543e:	5b f8       	cp.w	r8,-1
80005440:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005444:	f0 1f 00 1d 	mcall	800054b8 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005448:	06 9b       	mov	r11,r3
8000544a:	08 9c       	mov	r12,r4
8000544c:	f0 1f 00 1e 	mcall	800054c4 <xQueueGenericReceive+0x130>
80005450:	c2 41       	brne	80005498 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005452:	f0 1f 00 16 	mcall	800054a8 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005456:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005458:	f0 1f 00 18 	mcall	800054b8 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
8000545c:	58 06       	cp.w	r6,0
8000545e:	c1 71       	brne	8000548c <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005460:	6e 08       	ld.w	r8,r7[0x0]
80005462:	58 08       	cp.w	r8,0
80005464:	c0 81       	brne	80005474 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005466:	f0 1f 00 11 	mcall	800054a8 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000546a:	6e 1c       	ld.w	r12,r7[0x4]
8000546c:	f0 1f 00 17 	mcall	800054c8 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005470:	f0 1f 00 12 	mcall	800054b8 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005474:	40 2b       	lddsp	r11,sp[0x8]
80005476:	04 9c       	mov	r12,r2
80005478:	f0 1f 00 15 	mcall	800054cc <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
8000547c:	0e 9c       	mov	r12,r7
8000547e:	f0 1f 00 15 	mcall	800054d0 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005482:	f0 1f 00 15 	mcall	800054d4 <xQueueGenericReceive+0x140>
80005486:	c9 61       	brne	800053b2 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005488:	d7 33       	scall
8000548a:	c9 4b       	rjmp	800053b2 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000548c:	0e 9c       	mov	r12,r7
8000548e:	f0 1f 00 11 	mcall	800054d0 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005492:	f0 1f 00 11 	mcall	800054d4 <xQueueGenericReceive+0x140>
80005496:	c8 eb       	rjmp	800053b2 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005498:	0e 9c       	mov	r12,r7
8000549a:	f0 1f 00 0e 	mcall	800054d0 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000549e:	f0 1f 00 0e 	mcall	800054d4 <xQueueGenericReceive+0x140>
800054a2:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800054a4:	2f bd       	sub	sp,-20
800054a6:	d8 32       	popm	r0-r7,pc
800054a8:	80 00       	ld.sh	r0,r0[0x0]
800054aa:	4f e0       	lddpc	r0,800056a0 <xQueueCreateMutex>
800054ac:	80 00       	ld.sh	r0,r0[0x0]
800054ae:	52 74       	stdsp	sp[0x9c],r4
800054b0:	80 00       	ld.sh	r0,r0[0x0]
800054b2:	58 1c       	cp.w	r12,1
800054b4:	80 00       	ld.sh	r0,r0[0x0]
800054b6:	59 04       	cp.w	r4,16
800054b8:	80 00       	ld.sh	r0,r0[0x0]
800054ba:	50 ec       	stdsp	sp[0x38],r12
800054bc:	80 00       	ld.sh	r0,r0[0x0]
800054be:	57 f8       	stdsp	sp[0x1fc],r8
800054c0:	80 00       	ld.sh	r0,r0[0x0]
800054c2:	57 6c       	stdsp	sp[0x1d8],r12
800054c4:	80 00       	ld.sh	r0,r0[0x0]
800054c6:	5a 94       	cp.w	r4,-23
800054c8:	80 00       	ld.sh	r0,r0[0x0]
800054ca:	58 80       	cp.w	r0,8
800054cc:	80 00       	ld.sh	r0,r0[0x0]
800054ce:	5c ec       	tnbz	r12
800054d0:	80 00       	ld.sh	r0,r0[0x0]
800054d2:	52 f4       	stdsp	sp[0xbc],r4
800054d4:	80 00       	ld.sh	r0,r0[0x0]
800054d6:	5b 28       	cp.w	r8,-14

800054d8 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800054d8:	eb cd 40 80 	pushm	r7,lr
800054dc:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800054de:	79 08       	ld.w	r8,r12[0x40]
800054e0:	58 08       	cp.w	r8,0
800054e2:	c0 a1       	brne	800054f6 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800054e4:	78 08       	ld.w	r8,r12[0x0]
800054e6:	58 08       	cp.w	r8,0
800054e8:	c2 b1       	brne	8000553e <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800054ea:	78 1c       	ld.w	r12,r12[0x4]
800054ec:	f0 1f 00 17 	mcall	80005548 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800054f0:	30 08       	mov	r8,0
800054f2:	8f 18       	st.w	r7[0x4],r8
800054f4:	c2 58       	rjmp	8000553e <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800054f6:	58 0a       	cp.w	r10,0
800054f8:	c1 01       	brne	80005518 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800054fa:	10 9a       	mov	r10,r8
800054fc:	78 2c       	ld.w	r12,r12[0x8]
800054fe:	f0 1f 00 14 	mcall	8000554c <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005502:	6e 29       	ld.w	r9,r7[0x8]
80005504:	6f 08       	ld.w	r8,r7[0x40]
80005506:	f2 08 00 08 	add	r8,r9,r8
8000550a:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000550c:	6e 19       	ld.w	r9,r7[0x4]
8000550e:	12 38       	cp.w	r8,r9
80005510:	c1 73       	brcs	8000553e <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005512:	6e 08       	ld.w	r8,r7[0x0]
80005514:	8f 28       	st.w	r7[0x8],r8
80005516:	c1 48       	rjmp	8000553e <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005518:	10 9a       	mov	r10,r8
8000551a:	78 3c       	ld.w	r12,r12[0xc]
8000551c:	f0 1f 00 0c 	mcall	8000554c <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005520:	6f 08       	ld.w	r8,r7[0x40]
80005522:	6e 39       	ld.w	r9,r7[0xc]
80005524:	f2 08 01 08 	sub	r8,r9,r8
80005528:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000552a:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
8000552c:	12 38       	cp.w	r8,r9
8000552e:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005532:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005536:	f3 d8 e3 19 	subcs	r9,r9,r8
8000553a:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000553e:	6e e8       	ld.w	r8,r7[0x38]
80005540:	2f f8       	sub	r8,-1
80005542:	8f e8       	st.w	r7[0x38],r8
}
80005544:	e3 cd 80 80 	ldm	sp++,r7,pc
80005548:	80 00       	ld.sh	r0,r0[0x0]
8000554a:	58 28       	cp.w	r8,2
8000554c:	80 00       	ld.sh	r0,r0[0x0]
8000554e:	6a f0       	ld.w	r0,r5[0x3c]

80005550 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80005550:	eb cd 40 c0 	pushm	r6-r7,lr
80005554:	18 97       	mov	r7,r12
80005556:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005558:	78 ec       	ld.w	r12,r12[0x38]
8000555a:	6e f8       	ld.w	r8,r7[0x3c]
8000555c:	10 3c       	cp.w	r12,r8
8000555e:	c0 33       	brcs	80005564 <xQueueGenericSendFromISR+0x14>
80005560:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005564:	12 9a       	mov	r10,r9
80005566:	0e 9c       	mov	r12,r7
80005568:	f0 1f 00 0c 	mcall	80005598 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
8000556c:	6f 28       	ld.w	r8,r7[0x48]
8000556e:	5b f8       	cp.w	r8,-1
80005570:	c0 d1       	brne	8000558a <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005572:	6e 98       	ld.w	r8,r7[0x24]
80005574:	58 08       	cp.w	r8,0
80005576:	c0 f0       	breq	80005594 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005578:	ee cc ff dc 	sub	r12,r7,-36
8000557c:	f0 1f 00 08 	mcall	8000559c <xQueueGenericSendFromISR+0x4c>
80005580:	c0 a0       	breq	80005594 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80005582:	30 1c       	mov	r12,1
80005584:	8d 0c       	st.w	r6[0x0],r12
80005586:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000558a:	2f f8       	sub	r8,-1
8000558c:	ef 48 00 48 	st.w	r7[72],r8
80005590:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005594:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005598:	80 00       	ld.sh	r0,r0[0x0]
8000559a:	54 d8       	stdsp	sp[0x134],r8
8000559c:	80 00       	ld.sh	r0,r0[0x0]
8000559e:	59 04       	cp.w	r4,16

800055a0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800055a0:	d4 31       	pushm	r0-r7,lr
800055a2:	20 5d       	sub	sp,20
800055a4:	18 97       	mov	r7,r12
800055a6:	50 0b       	stdsp	sp[0x0],r11
800055a8:	50 2a       	stdsp	sp[0x8],r10
800055aa:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800055ac:	f8 c0 ff f0 	sub	r0,r12,-16
800055b0:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800055b2:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800055b6:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800055b8:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800055bc:	f0 1f 00 2f 	mcall	80005678 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800055c0:	6e e9       	ld.w	r9,r7[0x38]
800055c2:	6e f8       	ld.w	r8,r7[0x3c]
800055c4:	10 39       	cp.w	r9,r8
800055c6:	c1 42       	brcc	800055ee <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800055c8:	40 1a       	lddsp	r10,sp[0x4]
800055ca:	40 0b       	lddsp	r11,sp[0x0]
800055cc:	0e 9c       	mov	r12,r7
800055ce:	f0 1f 00 2c 	mcall	8000567c <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800055d2:	6e 98       	ld.w	r8,r7[0x24]
800055d4:	58 08       	cp.w	r8,0
800055d6:	c0 80       	breq	800055e6 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800055d8:	ee cc ff dc 	sub	r12,r7,-36
800055dc:	f0 1f 00 29 	mcall	80005680 <xQueueGenericSend+0xe0>
800055e0:	58 1c       	cp.w	r12,1
800055e2:	c0 21       	brne	800055e6 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800055e4:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800055e6:	f0 1f 00 28 	mcall	80005684 <xQueueGenericSend+0xe4>
800055ea:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800055ec:	c4 38       	rjmp	80005672 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800055ee:	40 28       	lddsp	r8,sp[0x8]
800055f0:	58 08       	cp.w	r8,0
800055f2:	c0 51       	brne	800055fc <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800055f4:	f0 1f 00 24 	mcall	80005684 <xQueueGenericSend+0xe4>
800055f8:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800055fa:	c3 c8       	rjmp	80005672 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800055fc:	58 04       	cp.w	r4,0
800055fe:	c0 51       	brne	80005608 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005600:	06 9c       	mov	r12,r3
80005602:	f0 1f 00 22 	mcall	80005688 <xQueueGenericSend+0xe8>
80005606:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005608:	f0 1f 00 1f 	mcall	80005684 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000560c:	f0 1f 00 20 	mcall	8000568c <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005610:	f0 1f 00 1a 	mcall	80005678 <xQueueGenericSend+0xd8>
80005614:	6f 18       	ld.w	r8,r7[0x44]
80005616:	5b f8       	cp.w	r8,-1
80005618:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000561c:	6f 28       	ld.w	r8,r7[0x48]
8000561e:	5b f8       	cp.w	r8,-1
80005620:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005624:	f0 1f 00 18 	mcall	80005684 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005628:	04 9b       	mov	r11,r2
8000562a:	06 9c       	mov	r12,r3
8000562c:	f0 1f 00 19 	mcall	80005690 <xQueueGenericSend+0xf0>
80005630:	c1 b1       	brne	80005666 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005632:	f0 1f 00 12 	mcall	80005678 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005636:	6e e5       	ld.w	r5,r7[0x38]
80005638:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
8000563a:	f0 1f 00 13 	mcall	80005684 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000563e:	0c 35       	cp.w	r5,r6
80005640:	c0 d1       	brne	8000565a <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005642:	40 2b       	lddsp	r11,sp[0x8]
80005644:	00 9c       	mov	r12,r0
80005646:	f0 1f 00 14 	mcall	80005694 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
8000564a:	0e 9c       	mov	r12,r7
8000564c:	f0 1f 00 13 	mcall	80005698 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005650:	f0 1f 00 13 	mcall	8000569c <xQueueGenericSend+0xfc>
80005654:	cb 41       	brne	800055bc <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005656:	d7 33       	scall
80005658:	cb 2b       	rjmp	800055bc <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000565a:	0e 9c       	mov	r12,r7
8000565c:	f0 1f 00 0f 	mcall	80005698 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005660:	f0 1f 00 0f 	mcall	8000569c <xQueueGenericSend+0xfc>
80005664:	ca cb       	rjmp	800055bc <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005666:	0e 9c       	mov	r12,r7
80005668:	f0 1f 00 0c 	mcall	80005698 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
8000566c:	f0 1f 00 0c 	mcall	8000569c <xQueueGenericSend+0xfc>
80005670:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80005672:	2f bd       	sub	sp,-20
80005674:	d8 32       	popm	r0-r7,pc
80005676:	00 00       	add	r0,r0
80005678:	80 00       	ld.sh	r0,r0[0x0]
8000567a:	4f e0       	lddpc	r0,80005870 <vTaskPriorityDisinherit+0x48>
8000567c:	80 00       	ld.sh	r0,r0[0x0]
8000567e:	54 d8       	stdsp	sp[0x134],r8
80005680:	80 00       	ld.sh	r0,r0[0x0]
80005682:	59 04       	cp.w	r4,16
80005684:	80 00       	ld.sh	r0,r0[0x0]
80005686:	50 ec       	stdsp	sp[0x38],r12
80005688:	80 00       	ld.sh	r0,r0[0x0]
8000568a:	57 f8       	stdsp	sp[0x1fc],r8
8000568c:	80 00       	ld.sh	r0,r0[0x0]
8000568e:	57 6c       	stdsp	sp[0x1d8],r12
80005690:	80 00       	ld.sh	r0,r0[0x0]
80005692:	5a 94       	cp.w	r4,-23
80005694:	80 00       	ld.sh	r0,r0[0x0]
80005696:	5c ec       	tnbz	r12
80005698:	80 00       	ld.sh	r0,r0[0x0]
8000569a:	52 f4       	stdsp	sp[0xbc],r4
8000569c:	80 00       	ld.sh	r0,r0[0x0]
8000569e:	5b 28       	cp.w	r8,-14

800056a0 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
800056a0:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800056a4:	34 cc       	mov	r12,76
800056a6:	f0 1f 00 12 	mcall	800056ec <xQueueCreateMutex+0x4c>
800056aa:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
800056ac:	c1 d0       	breq	800056e6 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
800056ae:	30 06       	mov	r6,0
800056b0:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
800056b2:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
800056b4:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
800056b6:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800056b8:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
800056ba:	30 18       	mov	r8,1
800056bc:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
800056be:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
800056c2:	3f f8       	mov	r8,-1
800056c4:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
800056c8:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800056cc:	2f 0c       	sub	r12,-16
800056ce:	f0 1f 00 09 	mcall	800056f0 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800056d2:	ee cc ff dc 	sub	r12,r7,-36
800056d6:	f0 1f 00 07 	mcall	800056f0 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
800056da:	0c 99       	mov	r9,r6
800056dc:	0c 9a       	mov	r10,r6
800056de:	0c 9b       	mov	r11,r6
800056e0:	0e 9c       	mov	r12,r7
800056e2:	f0 1f 00 05 	mcall	800056f4 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
800056e6:	0e 9c       	mov	r12,r7
800056e8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800056ec:	80 00       	ld.sh	r0,r0[0x0]
800056ee:	52 4c       	stdsp	sp[0x90],r12
800056f0:	80 00       	ld.sh	r0,r0[0x0]
800056f2:	4e bc       	lddpc	r12,8000589c <vTaskPriorityInherit+0x1c>
800056f4:	80 00       	ld.sh	r0,r0[0x0]
800056f6:	55 a0       	stdsp	sp[0x168],r0

800056f8 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800056f8:	d4 21       	pushm	r4-r7,lr
800056fa:	18 97       	mov	r7,r12
800056fc:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800056fe:	58 0c       	cp.w	r12,0
80005700:	c2 f0       	breq	8000575e <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005702:	34 cc       	mov	r12,76
80005704:	f0 1f 00 17 	mcall	80005760 <xQueueCreate+0x68>
80005708:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000570a:	c2 a0       	breq	8000575e <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000570c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005710:	e8 cc ff ff 	sub	r12,r4,-1
80005714:	f0 1f 00 13 	mcall	80005760 <xQueueCreate+0x68>
80005718:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000571a:	c1 e0       	breq	80005756 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000571c:	f8 04 00 04 	add	r4,r12,r4
80005720:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005722:	30 08       	mov	r8,0
80005724:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005726:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005728:	ee c8 00 01 	sub	r8,r7,1
8000572c:	ad 38       	mul	r8,r6
8000572e:	10 0c       	add	r12,r8
80005730:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005732:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005734:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005738:	3f f8       	mov	r8,-1
8000573a:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000573e:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005742:	ea cc ff f0 	sub	r12,r5,-16
80005746:	f0 1f 00 08 	mcall	80005764 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000574a:	ea cc ff dc 	sub	r12,r5,-36
8000574e:	f0 1f 00 06 	mcall	80005764 <xQueueCreate+0x6c>
80005752:	0a 9c       	mov	r12,r5
80005754:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005756:	0a 9c       	mov	r12,r5
80005758:	f0 1f 00 04 	mcall	80005768 <xQueueCreate+0x70>
8000575c:	d8 2a       	popm	r4-r7,pc,r12=0
8000575e:	d8 2a       	popm	r4-r7,pc,r12=0
80005760:	80 00       	ld.sh	r0,r0[0x0]
80005762:	52 4c       	stdsp	sp[0x90],r12
80005764:	80 00       	ld.sh	r0,r0[0x0]
80005766:	4e bc       	lddpc	r12,80005910 <xTaskRemoveFromEventList+0xc>
80005768:	80 00       	ld.sh	r0,r0[0x0]
8000576a:	52 24       	stdsp	sp[0x88],r4

8000576c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
8000576c:	48 38       	lddpc	r8,80005778 <vTaskSuspendAll+0xc>
8000576e:	70 09       	ld.w	r9,r8[0x0]
80005770:	2f f9       	sub	r9,-1
80005772:	91 09       	st.w	r8[0x0],r9
}
80005774:	5e fc       	retal	r12
80005776:	00 00       	add	r0,r0
80005778:	00 00       	add	r0,r0
8000577a:	0d 18       	ld.sh	r8,r6++

8000577c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
8000577c:	49 a8       	lddpc	r8,800057e4 <vTaskSwitchContext+0x68>
8000577e:	70 08       	ld.w	r8,r8[0x0]
80005780:	58 08       	cp.w	r8,0
80005782:	c0 b1       	brne	80005798 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005784:	49 98       	lddpc	r8,800057e8 <vTaskSwitchContext+0x6c>
80005786:	70 08       	ld.w	r8,r8[0x0]
80005788:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000578c:	49 89       	lddpc	r9,800057ec <vTaskSwitchContext+0x70>
8000578e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005792:	58 08       	cp.w	r8,0
80005794:	c0 60       	breq	800057a0 <vTaskSwitchContext+0x24>
80005796:	c1 18       	rjmp	800057b8 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005798:	30 19       	mov	r9,1
8000579a:	49 68       	lddpc	r8,800057f0 <vTaskSwitchContext+0x74>
8000579c:	91 09       	st.w	r8[0x0],r9
8000579e:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800057a0:	49 28       	lddpc	r8,800057e8 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800057a2:	49 3a       	lddpc	r10,800057ec <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800057a4:	70 09       	ld.w	r9,r8[0x0]
800057a6:	20 19       	sub	r9,1
800057a8:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800057aa:	70 09       	ld.w	r9,r8[0x0]
800057ac:	f2 09 00 29 	add	r9,r9,r9<<0x2
800057b0:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800057b4:	58 09       	cp.w	r9,0
800057b6:	cf 70       	breq	800057a4 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800057b8:	48 c8       	lddpc	r8,800057e8 <vTaskSwitchContext+0x6c>
800057ba:	70 08       	ld.w	r8,r8[0x0]
800057bc:	f0 08 00 28 	add	r8,r8,r8<<0x2
800057c0:	48 b9       	lddpc	r9,800057ec <vTaskSwitchContext+0x70>
800057c2:	f2 08 00 28 	add	r8,r9,r8<<0x2
800057c6:	70 19       	ld.w	r9,r8[0x4]
800057c8:	72 19       	ld.w	r9,r9[0x4]
800057ca:	91 19       	st.w	r8[0x4],r9
800057cc:	f0 ca ff f8 	sub	r10,r8,-8
800057d0:	14 39       	cp.w	r9,r10
800057d2:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800057d6:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800057da:	70 18       	ld.w	r8,r8[0x4]
800057dc:	70 39       	ld.w	r9,r8[0xc]
800057de:	48 68       	lddpc	r8,800057f4 <vTaskSwitchContext+0x78>
800057e0:	91 09       	st.w	r8[0x0],r9
800057e2:	5e fc       	retal	r12
800057e4:	00 00       	add	r0,r0
800057e6:	0d 18       	ld.sh	r8,r6++
800057e8:	00 00       	add	r0,r0
800057ea:	0d 50       	ld.sh	r0,--r6
800057ec:	00 00       	add	r0,r0
800057ee:	0c 34       	cp.w	r4,r6
800057f0:	00 00       	add	r0,r0
800057f2:	0d 38       	ld.ub	r8,r6++
800057f4:	00 00       	add	r0,r0
800057f6:	0c e8       	st.h	--r6,r8

800057f8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800057f8:	48 48       	lddpc	r8,80005808 <vTaskSetTimeOutState+0x10>
800057fa:	70 08       	ld.w	r8,r8[0x0]
800057fc:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800057fe:	48 48       	lddpc	r8,8000580c <vTaskSetTimeOutState+0x14>
80005800:	70 08       	ld.w	r8,r8[0x0]
80005802:	99 18       	st.w	r12[0x4],r8
}
80005804:	5e fc       	retal	r12
80005806:	00 00       	add	r0,r0
80005808:	00 00       	add	r0,r0
8000580a:	0c 2c       	rsub	r12,r6
8000580c:	00 00       	add	r0,r0
8000580e:	0d 14       	ld.sh	r4,r6++

80005810 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80005810:	30 19       	mov	r9,1
80005812:	48 28       	lddpc	r8,80005818 <vTaskMissedYield+0x8>
80005814:	91 09       	st.w	r8[0x0],r9
}
80005816:	5e fc       	retal	r12
80005818:	00 00       	add	r0,r0
8000581a:	0d 38       	ld.ub	r8,r6++

8000581c <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
8000581c:	48 28       	lddpc	r8,80005824 <xTaskGetCurrentTaskHandle+0x8>
8000581e:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80005820:	5e fc       	retal	r12
80005822:	00 00       	add	r0,r0
80005824:	00 00       	add	r0,r0
80005826:	0c e8       	st.h	--r6,r8

80005828 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80005828:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
8000582c:	58 0c       	cp.w	r12,0
8000582e:	c1 f0       	breq	8000586c <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005830:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80005832:	78 b9       	ld.w	r9,r12[0x2c]
80005834:	79 18       	ld.w	r8,r12[0x44]
80005836:	10 39       	cp.w	r9,r8
80005838:	c1 a0       	breq	8000586c <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000583a:	f8 c6 ff fc 	sub	r6,r12,-4
8000583e:	0c 9c       	mov	r12,r6
80005840:	f0 1f 00 0c 	mcall	80005870 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80005844:	6f 1c       	ld.w	r12,r7[0x44]
80005846:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005848:	f8 08 11 08 	rsub	r8,r12,8
8000584c:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000584e:	48 a8       	lddpc	r8,80005874 <vTaskPriorityDisinherit+0x4c>
80005850:	70 08       	ld.w	r8,r8[0x0]
80005852:	10 3c       	cp.w	r12,r8
80005854:	e0 88 00 04 	brls	8000585c <vTaskPriorityDisinherit+0x34>
80005858:	48 78       	lddpc	r8,80005874 <vTaskPriorityDisinherit+0x4c>
8000585a:	91 0c       	st.w	r8[0x0],r12
8000585c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005860:	0c 9b       	mov	r11,r6
80005862:	48 68       	lddpc	r8,80005878 <vTaskPriorityDisinherit+0x50>
80005864:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005868:	f0 1f 00 05 	mcall	8000587c <vTaskPriorityDisinherit+0x54>
8000586c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005870:	80 00       	ld.sh	r0,r0[0x0]
80005872:	4f 26       	lddpc	r6,80005a38 <vTaskIncrementTick+0xb8>
80005874:	00 00       	add	r0,r0
80005876:	0d 50       	ld.sh	r0,--r6
80005878:	00 00       	add	r0,r0
8000587a:	0c 34       	cp.w	r4,r6
8000587c:	80 00       	ld.sh	r0,r0[0x0]
8000587e:	4e d6       	lddpc	r6,80005a30 <vTaskIncrementTick+0xb0>

80005880 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005880:	eb cd 40 c0 	pushm	r6-r7,lr
80005884:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80005886:	49 b8       	lddpc	r8,800058f0 <vTaskPriorityInherit+0x70>
80005888:	70 08       	ld.w	r8,r8[0x0]
8000588a:	78 b9       	ld.w	r9,r12[0x2c]
8000588c:	70 b8       	ld.w	r8,r8[0x2c]
8000588e:	10 39       	cp.w	r9,r8
80005890:	c2 d2       	brcc	800058ea <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80005892:	49 88       	lddpc	r8,800058f0 <vTaskPriorityInherit+0x70>
80005894:	70 08       	ld.w	r8,r8[0x0]
80005896:	70 b8       	ld.w	r8,r8[0x2c]
80005898:	f0 08 11 08 	rsub	r8,r8,8
8000589c:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000589e:	f2 09 00 28 	add	r8,r9,r9<<0x2
800058a2:	49 59       	lddpc	r9,800058f4 <vTaskPriorityInherit+0x74>
800058a4:	f2 08 00 28 	add	r8,r9,r8<<0x2
800058a8:	78 59       	ld.w	r9,r12[0x14]
800058aa:	10 39       	cp.w	r9,r8
800058ac:	c1 b1       	brne	800058e2 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800058ae:	f8 c6 ff fc 	sub	r6,r12,-4
800058b2:	0c 9c       	mov	r12,r6
800058b4:	f0 1f 00 11 	mcall	800058f8 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800058b8:	48 e8       	lddpc	r8,800058f0 <vTaskPriorityInherit+0x70>
800058ba:	70 08       	ld.w	r8,r8[0x0]
800058bc:	70 bc       	ld.w	r12,r8[0x2c]
800058be:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800058c0:	48 f8       	lddpc	r8,800058fc <vTaskPriorityInherit+0x7c>
800058c2:	70 08       	ld.w	r8,r8[0x0]
800058c4:	10 3c       	cp.w	r12,r8
800058c6:	e0 88 00 04 	brls	800058ce <vTaskPriorityInherit+0x4e>
800058ca:	48 d8       	lddpc	r8,800058fc <vTaskPriorityInherit+0x7c>
800058cc:	91 0c       	st.w	r8[0x0],r12
800058ce:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800058d2:	0c 9b       	mov	r11,r6
800058d4:	48 88       	lddpc	r8,800058f4 <vTaskPriorityInherit+0x74>
800058d6:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800058da:	f0 1f 00 0a 	mcall	80005900 <vTaskPriorityInherit+0x80>
800058de:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800058e2:	48 48       	lddpc	r8,800058f0 <vTaskPriorityInherit+0x70>
800058e4:	70 08       	ld.w	r8,r8[0x0]
800058e6:	70 b8       	ld.w	r8,r8[0x2c]
800058e8:	99 b8       	st.w	r12[0x2c],r8
800058ea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800058ee:	00 00       	add	r0,r0
800058f0:	00 00       	add	r0,r0
800058f2:	0c e8       	st.h	--r6,r8
800058f4:	00 00       	add	r0,r0
800058f6:	0c 34       	cp.w	r4,r6
800058f8:	80 00       	ld.sh	r0,r0[0x0]
800058fa:	4f 26       	lddpc	r6,80005ac0 <xTaskCheckForTimeOut+0x2c>
800058fc:	00 00       	add	r0,r0
800058fe:	0d 50       	ld.sh	r0,--r6
80005900:	80 00       	ld.sh	r0,r0[0x0]
80005902:	4e d6       	lddpc	r6,80005ab4 <xTaskCheckForTimeOut+0x20>

80005904 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80005904:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80005908:	78 38       	ld.w	r8,r12[0xc]
8000590a:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
8000590c:	ee c6 ff e8 	sub	r6,r7,-24
80005910:	0c 9c       	mov	r12,r6
80005912:	f0 1f 00 15 	mcall	80005964 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005916:	49 58       	lddpc	r8,80005968 <xTaskRemoveFromEventList+0x64>
80005918:	70 08       	ld.w	r8,r8[0x0]
8000591a:	58 08       	cp.w	r8,0
8000591c:	c1 71       	brne	8000594a <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000591e:	ee c6 ff fc 	sub	r6,r7,-4
80005922:	0c 9c       	mov	r12,r6
80005924:	f0 1f 00 10 	mcall	80005964 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005928:	6e bc       	ld.w	r12,r7[0x2c]
8000592a:	49 18       	lddpc	r8,8000596c <xTaskRemoveFromEventList+0x68>
8000592c:	70 08       	ld.w	r8,r8[0x0]
8000592e:	10 3c       	cp.w	r12,r8
80005930:	e0 88 00 04 	brls	80005938 <xTaskRemoveFromEventList+0x34>
80005934:	48 e8       	lddpc	r8,8000596c <xTaskRemoveFromEventList+0x68>
80005936:	91 0c       	st.w	r8[0x0],r12
80005938:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000593c:	0c 9b       	mov	r11,r6
8000593e:	48 d8       	lddpc	r8,80005970 <xTaskRemoveFromEventList+0x6c>
80005940:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005944:	f0 1f 00 0c 	mcall	80005974 <xTaskRemoveFromEventList+0x70>
80005948:	c0 58       	rjmp	80005952 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000594a:	0c 9b       	mov	r11,r6
8000594c:	48 bc       	lddpc	r12,80005978 <xTaskRemoveFromEventList+0x74>
8000594e:	f0 1f 00 0a 	mcall	80005974 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005952:	48 b8       	lddpc	r8,8000597c <xTaskRemoveFromEventList+0x78>
80005954:	70 08       	ld.w	r8,r8[0x0]
80005956:	6e b9       	ld.w	r9,r7[0x2c]
80005958:	70 b8       	ld.w	r8,r8[0x2c]
8000595a:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
8000595c:	5f 2c       	srhs	r12
8000595e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005962:	00 00       	add	r0,r0
80005964:	80 00       	ld.sh	r0,r0[0x0]
80005966:	4f 26       	lddpc	r6,80005b2c <xTaskResumeAll+0x4>
80005968:	00 00       	add	r0,r0
8000596a:	0d 18       	ld.sh	r8,r6++
8000596c:	00 00       	add	r0,r0
8000596e:	0d 50       	ld.sh	r0,--r6
80005970:	00 00       	add	r0,r0
80005972:	0c 34       	cp.w	r4,r6
80005974:	80 00       	ld.sh	r0,r0[0x0]
80005976:	4e d6       	lddpc	r6,80005b28 <xTaskResumeAll>
80005978:	00 00       	add	r0,r0
8000597a:	0c ec       	st.h	--r6,r12
8000597c:	00 00       	add	r0,r0
8000597e:	0c e8       	st.h	--r6,r8

80005980 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005980:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005984:	4b 98       	lddpc	r8,80005a68 <vTaskIncrementTick+0xe8>
80005986:	70 08       	ld.w	r8,r8[0x0]
80005988:	58 08       	cp.w	r8,0
8000598a:	c6 91       	brne	80005a5c <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
8000598c:	4b 88       	lddpc	r8,80005a6c <vTaskIncrementTick+0xec>
8000598e:	70 09       	ld.w	r9,r8[0x0]
80005990:	2f f9       	sub	r9,-1
80005992:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005994:	70 08       	ld.w	r8,r8[0x0]
80005996:	58 08       	cp.w	r8,0
80005998:	c1 a1       	brne	800059cc <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
8000599a:	4b 68       	lddpc	r8,80005a70 <vTaskIncrementTick+0xf0>
8000599c:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000599e:	4b 69       	lddpc	r9,80005a74 <vTaskIncrementTick+0xf4>
800059a0:	72 0b       	ld.w	r11,r9[0x0]
800059a2:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800059a4:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800059a6:	4b 59       	lddpc	r9,80005a78 <vTaskIncrementTick+0xf8>
800059a8:	72 0a       	ld.w	r10,r9[0x0]
800059aa:	2f fa       	sub	r10,-1
800059ac:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800059ae:	70 08       	ld.w	r8,r8[0x0]
800059b0:	70 08       	ld.w	r8,r8[0x0]
800059b2:	58 08       	cp.w	r8,0
800059b4:	c0 51       	brne	800059be <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800059b6:	3f f9       	mov	r9,-1
800059b8:	4b 18       	lddpc	r8,80005a7c <vTaskIncrementTick+0xfc>
800059ba:	91 09       	st.w	r8[0x0],r9
800059bc:	c0 88       	rjmp	800059cc <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800059be:	4a d8       	lddpc	r8,80005a70 <vTaskIncrementTick+0xf0>
800059c0:	70 08       	ld.w	r8,r8[0x0]
800059c2:	70 38       	ld.w	r8,r8[0xc]
800059c4:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800059c6:	70 19       	ld.w	r9,r8[0x4]
800059c8:	4a d8       	lddpc	r8,80005a7c <vTaskIncrementTick+0xfc>
800059ca:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800059cc:	4a 88       	lddpc	r8,80005a6c <vTaskIncrementTick+0xec>
800059ce:	70 09       	ld.w	r9,r8[0x0]
800059d0:	4a b8       	lddpc	r8,80005a7c <vTaskIncrementTick+0xfc>
800059d2:	70 08       	ld.w	r8,r8[0x0]
800059d4:	10 39       	cp.w	r9,r8
800059d6:	c4 73       	brcs	80005a64 <vTaskIncrementTick+0xe4>
800059d8:	4a 68       	lddpc	r8,80005a70 <vTaskIncrementTick+0xf0>
800059da:	70 08       	ld.w	r8,r8[0x0]
800059dc:	70 08       	ld.w	r8,r8[0x0]
800059de:	58 08       	cp.w	r8,0
800059e0:	c0 c0       	breq	800059f8 <vTaskIncrementTick+0x78>
800059e2:	4a 48       	lddpc	r8,80005a70 <vTaskIncrementTick+0xf0>
800059e4:	70 08       	ld.w	r8,r8[0x0]
800059e6:	70 38       	ld.w	r8,r8[0xc]
800059e8:	70 37       	ld.w	r7,r8[0xc]
800059ea:	6e 18       	ld.w	r8,r7[0x4]
800059ec:	4a 09       	lddpc	r9,80005a6c <vTaskIncrementTick+0xec>
800059ee:	72 09       	ld.w	r9,r9[0x0]
800059f0:	12 38       	cp.w	r8,r9
800059f2:	e0 88 00 14 	brls	80005a1a <vTaskIncrementTick+0x9a>
800059f6:	c0 e8       	rjmp	80005a12 <vTaskIncrementTick+0x92>
800059f8:	3f f9       	mov	r9,-1
800059fa:	4a 18       	lddpc	r8,80005a7c <vTaskIncrementTick+0xfc>
800059fc:	91 09       	st.w	r8[0x0],r9
800059fe:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005a02:	6a 08       	ld.w	r8,r5[0x0]
80005a04:	70 38       	ld.w	r8,r8[0xc]
80005a06:	70 37       	ld.w	r7,r8[0xc]
80005a08:	6e 18       	ld.w	r8,r7[0x4]
80005a0a:	64 09       	ld.w	r9,r2[0x0]
80005a0c:	12 38       	cp.w	r8,r9
80005a0e:	e0 88 00 0a 	brls	80005a22 <vTaskIncrementTick+0xa2>
80005a12:	49 b9       	lddpc	r9,80005a7c <vTaskIncrementTick+0xfc>
80005a14:	93 08       	st.w	r9[0x0],r8
80005a16:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005a1a:	49 a4       	lddpc	r4,80005a80 <vTaskIncrementTick+0x100>
80005a1c:	49 a3       	lddpc	r3,80005a84 <vTaskIncrementTick+0x104>
80005a1e:	49 55       	lddpc	r5,80005a70 <vTaskIncrementTick+0xf0>
80005a20:	49 32       	lddpc	r2,80005a6c <vTaskIncrementTick+0xec>
80005a22:	ee c6 ff fc 	sub	r6,r7,-4
80005a26:	0c 9c       	mov	r12,r6
80005a28:	f0 1f 00 18 	mcall	80005a88 <vTaskIncrementTick+0x108>
80005a2c:	6e a8       	ld.w	r8,r7[0x28]
80005a2e:	58 08       	cp.w	r8,0
80005a30:	c0 50       	breq	80005a3a <vTaskIncrementTick+0xba>
80005a32:	ee cc ff e8 	sub	r12,r7,-24
80005a36:	f0 1f 00 15 	mcall	80005a88 <vTaskIncrementTick+0x108>
80005a3a:	6e bc       	ld.w	r12,r7[0x2c]
80005a3c:	68 08       	ld.w	r8,r4[0x0]
80005a3e:	10 3c       	cp.w	r12,r8
80005a40:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005a44:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005a48:	0c 9b       	mov	r11,r6
80005a4a:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005a4e:	f0 1f 00 10 	mcall	80005a8c <vTaskIncrementTick+0x10c>
80005a52:	6a 08       	ld.w	r8,r5[0x0]
80005a54:	70 08       	ld.w	r8,r8[0x0]
80005a56:	58 08       	cp.w	r8,0
80005a58:	cd 51       	brne	80005a02 <vTaskIncrementTick+0x82>
80005a5a:	cc fb       	rjmp	800059f8 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005a5c:	48 d8       	lddpc	r8,80005a90 <vTaskIncrementTick+0x110>
80005a5e:	70 09       	ld.w	r9,r8[0x0]
80005a60:	2f f9       	sub	r9,-1
80005a62:	91 09       	st.w	r8[0x0],r9
80005a64:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005a68:	00 00       	add	r0,r0
80005a6a:	0d 18       	ld.sh	r8,r6++
80005a6c:	00 00       	add	r0,r0
80005a6e:	0d 14       	ld.sh	r4,r6++
80005a70:	00 00       	add	r0,r0
80005a72:	0c 20       	rsub	r0,r6
80005a74:	00 00       	add	r0,r0
80005a76:	0c 30       	cp.w	r0,r6
80005a78:	00 00       	add	r0,r0
80005a7a:	0c 2c       	rsub	r12,r6
80005a7c:	00 00       	add	r0,r0
80005a7e:	05 2c       	ld.uh	r12,r2++
80005a80:	00 00       	add	r0,r0
80005a82:	0d 50       	ld.sh	r0,--r6
80005a84:	00 00       	add	r0,r0
80005a86:	0c 34       	cp.w	r4,r6
80005a88:	80 00       	ld.sh	r0,r0[0x0]
80005a8a:	4f 26       	lddpc	r6,80005c50 <prvAddCurrentTaskToDelayedList+0x40>
80005a8c:	80 00       	ld.sh	r0,r0[0x0]
80005a8e:	4e d6       	lddpc	r6,80005c40 <prvAddCurrentTaskToDelayedList+0x30>
80005a90:	00 00       	add	r0,r0
80005a92:	0c 18       	sub	r8,r6

80005a94 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80005a94:	eb cd 40 c0 	pushm	r6-r7,lr
80005a98:	18 97       	mov	r7,r12
80005a9a:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80005a9c:	f0 1f 00 15 	mcall	80005af0 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005aa0:	6c 08       	ld.w	r8,r6[0x0]
80005aa2:	5b f8       	cp.w	r8,-1
80005aa4:	c0 31       	brne	80005aaa <xTaskCheckForTimeOut+0x16>
80005aa6:	30 07       	mov	r7,0
80005aa8:	c1 f8       	rjmp	80005ae6 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80005aaa:	49 39       	lddpc	r9,80005af4 <xTaskCheckForTimeOut+0x60>
80005aac:	72 09       	ld.w	r9,r9[0x0]
80005aae:	6e 0a       	ld.w	r10,r7[0x0]
80005ab0:	12 3a       	cp.w	r10,r9
80005ab2:	c0 70       	breq	80005ac0 <xTaskCheckForTimeOut+0x2c>
80005ab4:	49 19       	lddpc	r9,80005af8 <xTaskCheckForTimeOut+0x64>
80005ab6:	72 09       	ld.w	r9,r9[0x0]
80005ab8:	6e 1a       	ld.w	r10,r7[0x4]
80005aba:	12 3a       	cp.w	r10,r9
80005abc:	e0 88 00 14 	brls	80005ae4 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80005ac0:	48 e9       	lddpc	r9,80005af8 <xTaskCheckForTimeOut+0x64>
80005ac2:	72 0a       	ld.w	r10,r9[0x0]
80005ac4:	6e 19       	ld.w	r9,r7[0x4]
80005ac6:	12 1a       	sub	r10,r9
80005ac8:	14 38       	cp.w	r8,r10
80005aca:	e0 88 00 0d 	brls	80005ae4 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80005ace:	48 ba       	lddpc	r10,80005af8 <xTaskCheckForTimeOut+0x64>
80005ad0:	74 0a       	ld.w	r10,r10[0x0]
80005ad2:	14 19       	sub	r9,r10
80005ad4:	f2 08 00 08 	add	r8,r9,r8
80005ad8:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80005ada:	0e 9c       	mov	r12,r7
80005adc:	f0 1f 00 08 	mcall	80005afc <xTaskCheckForTimeOut+0x68>
80005ae0:	30 07       	mov	r7,0
80005ae2:	c0 28       	rjmp	80005ae6 <xTaskCheckForTimeOut+0x52>
80005ae4:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80005ae6:	f0 1f 00 07 	mcall	80005b00 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80005aea:	0e 9c       	mov	r12,r7
80005aec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005af0:	80 00       	ld.sh	r0,r0[0x0]
80005af2:	4f e0       	lddpc	r0,80005ce8 <vTaskDelayUntil+0x7c>
80005af4:	00 00       	add	r0,r0
80005af6:	0c 2c       	rsub	r12,r6
80005af8:	00 00       	add	r0,r0
80005afa:	0d 14       	ld.sh	r4,r6++
80005afc:	80 00       	ld.sh	r0,r0[0x0]
80005afe:	57 f8       	stdsp	sp[0x1fc],r8
80005b00:	80 00       	ld.sh	r0,r0[0x0]
80005b02:	50 ec       	stdsp	sp[0x38],r12

80005b04 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005b04:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005b08:	f0 1f 00 05 	mcall	80005b1c <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80005b0c:	48 58       	lddpc	r8,80005b20 <xTaskGetTickCount+0x1c>
80005b0e:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80005b10:	f0 1f 00 05 	mcall	80005b24 <xTaskGetTickCount+0x20>

	return xTicks;
}
80005b14:	0e 9c       	mov	r12,r7
80005b16:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b1a:	00 00       	add	r0,r0
80005b1c:	80 00       	ld.sh	r0,r0[0x0]
80005b1e:	4f e0       	lddpc	r0,80005d14 <vTaskPlaceOnEventList+0x28>
80005b20:	00 00       	add	r0,r0
80005b22:	0d 14       	ld.sh	r4,r6++
80005b24:	80 00       	ld.sh	r0,r0[0x0]
80005b26:	50 ec       	stdsp	sp[0x38],r12

80005b28 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005b28:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005b2c:	f0 1f 00 2c 	mcall	80005bdc <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80005b30:	4a c8       	lddpc	r8,80005be0 <xTaskResumeAll+0xb8>
80005b32:	70 09       	ld.w	r9,r8[0x0]
80005b34:	20 19       	sub	r9,1
80005b36:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005b38:	70 08       	ld.w	r8,r8[0x0]
80005b3a:	58 08       	cp.w	r8,0
80005b3c:	c4 91       	brne	80005bce <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005b3e:	4a a8       	lddpc	r8,80005be4 <xTaskResumeAll+0xbc>
80005b40:	70 08       	ld.w	r8,r8[0x0]
80005b42:	58 08       	cp.w	r8,0
80005b44:	c4 50       	breq	80005bce <xTaskResumeAll+0xa6>
80005b46:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005b48:	4a 85       	lddpc	r5,80005be8 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80005b4a:	4a 93       	lddpc	r3,80005bec <xTaskResumeAll+0xc4>
80005b4c:	4a 92       	lddpc	r2,80005bf0 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005b4e:	4a a1       	lddpc	r1,80005bf4 <xTaskResumeAll+0xcc>
80005b50:	c1 e8       	rjmp	80005b8c <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005b52:	6a 38       	ld.w	r8,r5[0xc]
80005b54:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80005b56:	ee cc ff e8 	sub	r12,r7,-24
80005b5a:	f0 1f 00 28 	mcall	80005bf8 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005b5e:	ee c6 ff fc 	sub	r6,r7,-4
80005b62:	0c 9c       	mov	r12,r6
80005b64:	f0 1f 00 25 	mcall	80005bf8 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80005b68:	6e bc       	ld.w	r12,r7[0x2c]
80005b6a:	66 08       	ld.w	r8,r3[0x0]
80005b6c:	10 3c       	cp.w	r12,r8
80005b6e:	e7 fc ba 00 	st.whi	r3[0x0],r12
80005b72:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005b76:	0c 9b       	mov	r11,r6
80005b78:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80005b7c:	f0 1f 00 20 	mcall	80005bfc <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005b80:	62 08       	ld.w	r8,r1[0x0]
80005b82:	6e b9       	ld.w	r9,r7[0x2c]
80005b84:	70 b8       	ld.w	r8,r8[0x2c]
80005b86:	10 39       	cp.w	r9,r8
80005b88:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005b8c:	6a 08       	ld.w	r8,r5[0x0]
80005b8e:	58 08       	cp.w	r8,0
80005b90:	ce 11       	brne	80005b52 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005b92:	49 c8       	lddpc	r8,80005c00 <xTaskResumeAll+0xd8>
80005b94:	70 08       	ld.w	r8,r8[0x0]
80005b96:	58 08       	cp.w	r8,0
80005b98:	c0 f0       	breq	80005bb6 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005b9a:	49 a8       	lddpc	r8,80005c00 <xTaskResumeAll+0xd8>
80005b9c:	70 08       	ld.w	r8,r8[0x0]
80005b9e:	58 08       	cp.w	r8,0
80005ba0:	c1 10       	breq	80005bc2 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80005ba2:	49 87       	lddpc	r7,80005c00 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80005ba4:	f0 1f 00 18 	mcall	80005c04 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80005ba8:	6e 08       	ld.w	r8,r7[0x0]
80005baa:	20 18       	sub	r8,1
80005bac:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005bae:	6e 08       	ld.w	r8,r7[0x0]
80005bb0:	58 08       	cp.w	r8,0
80005bb2:	cf 91       	brne	80005ba4 <xTaskResumeAll+0x7c>
80005bb4:	c0 78       	rjmp	80005bc2 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80005bb6:	58 14       	cp.w	r4,1
80005bb8:	c0 50       	breq	80005bc2 <xTaskResumeAll+0x9a>
80005bba:	49 48       	lddpc	r8,80005c08 <xTaskResumeAll+0xe0>
80005bbc:	70 08       	ld.w	r8,r8[0x0]
80005bbe:	58 18       	cp.w	r8,1
80005bc0:	c0 71       	brne	80005bce <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80005bc2:	30 09       	mov	r9,0
80005bc4:	49 18       	lddpc	r8,80005c08 <xTaskResumeAll+0xe0>
80005bc6:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005bc8:	d7 33       	scall
80005bca:	30 17       	mov	r7,1
80005bcc:	c0 28       	rjmp	80005bd0 <xTaskResumeAll+0xa8>
80005bce:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005bd0:	f0 1f 00 0f 	mcall	80005c0c <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005bd4:	0e 9c       	mov	r12,r7
80005bd6:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80005bda:	00 00       	add	r0,r0
80005bdc:	80 00       	ld.sh	r0,r0[0x0]
80005bde:	4f e0       	lddpc	r0,80005dd4 <xTaskGenericCreate+0x8>
80005be0:	00 00       	add	r0,r0
80005be2:	0d 18       	ld.sh	r8,r6++
80005be4:	00 00       	add	r0,r0
80005be6:	0d 34       	ld.ub	r4,r6++
80005be8:	00 00       	add	r0,r0
80005bea:	0c ec       	st.h	--r6,r12
80005bec:	00 00       	add	r0,r0
80005bee:	0d 50       	ld.sh	r0,--r6
80005bf0:	00 00       	add	r0,r0
80005bf2:	0c 34       	cp.w	r4,r6
80005bf4:	00 00       	add	r0,r0
80005bf6:	0c e8       	st.h	--r6,r8
80005bf8:	80 00       	ld.sh	r0,r0[0x0]
80005bfa:	4f 26       	lddpc	r6,80005dc0 <prvIdleTask+0x7c>
80005bfc:	80 00       	ld.sh	r0,r0[0x0]
80005bfe:	4e d6       	lddpc	r6,80005db0 <prvIdleTask+0x6c>
80005c00:	00 00       	add	r0,r0
80005c02:	0c 18       	sub	r8,r6
80005c04:	80 00       	ld.sh	r0,r0[0x0]
80005c06:	59 80       	cp.w	r0,24
80005c08:	00 00       	add	r0,r0
80005c0a:	0d 38       	ld.ub	r8,r6++
80005c0c:	80 00       	ld.sh	r0,r0[0x0]
80005c0e:	50 ec       	stdsp	sp[0x38],r12

80005c10 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80005c10:	eb cd 40 80 	pushm	r7,lr
80005c14:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005c16:	49 08       	lddpc	r8,80005c54 <prvAddCurrentTaskToDelayedList+0x44>
80005c18:	70 08       	ld.w	r8,r8[0x0]
80005c1a:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80005c1c:	48 f8       	lddpc	r8,80005c58 <prvAddCurrentTaskToDelayedList+0x48>
80005c1e:	70 08       	ld.w	r8,r8[0x0]
80005c20:	10 3c       	cp.w	r12,r8
80005c22:	c0 a2       	brcc	80005c36 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005c24:	48 c8       	lddpc	r8,80005c54 <prvAddCurrentTaskToDelayedList+0x44>
80005c26:	70 0b       	ld.w	r11,r8[0x0]
80005c28:	48 d8       	lddpc	r8,80005c5c <prvAddCurrentTaskToDelayedList+0x4c>
80005c2a:	70 0c       	ld.w	r12,r8[0x0]
80005c2c:	2f cb       	sub	r11,-4
80005c2e:	f0 1f 00 0d 	mcall	80005c60 <prvAddCurrentTaskToDelayedList+0x50>
80005c32:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005c36:	48 88       	lddpc	r8,80005c54 <prvAddCurrentTaskToDelayedList+0x44>
80005c38:	70 0b       	ld.w	r11,r8[0x0]
80005c3a:	48 b8       	lddpc	r8,80005c64 <prvAddCurrentTaskToDelayedList+0x54>
80005c3c:	70 0c       	ld.w	r12,r8[0x0]
80005c3e:	2f cb       	sub	r11,-4
80005c40:	f0 1f 00 08 	mcall	80005c60 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005c44:	48 98       	lddpc	r8,80005c68 <prvAddCurrentTaskToDelayedList+0x58>
80005c46:	70 08       	ld.w	r8,r8[0x0]
80005c48:	10 37       	cp.w	r7,r8
80005c4a:	c0 32       	brcc	80005c50 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005c4c:	48 78       	lddpc	r8,80005c68 <prvAddCurrentTaskToDelayedList+0x58>
80005c4e:	91 07       	st.w	r8[0x0],r7
80005c50:	e3 cd 80 80 	ldm	sp++,r7,pc
80005c54:	00 00       	add	r0,r0
80005c56:	0c e8       	st.h	--r6,r8
80005c58:	00 00       	add	r0,r0
80005c5a:	0d 14       	ld.sh	r4,r6++
80005c5c:	00 00       	add	r0,r0
80005c5e:	0c 30       	cp.w	r0,r6
80005c60:	80 00       	ld.sh	r0,r0[0x0]
80005c62:	4e f2       	lddpc	r2,80005e1c <xTaskGenericCreate+0x50>
80005c64:	00 00       	add	r0,r0
80005c66:	0c 20       	rsub	r0,r6
80005c68:	00 00       	add	r0,r0
80005c6a:	05 2c       	ld.uh	r12,r2++

80005c6c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005c6c:	eb cd 40 c0 	pushm	r6-r7,lr
80005c70:	18 96       	mov	r6,r12
80005c72:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80005c74:	f0 1f 00 18 	mcall	80005cd4 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005c78:	6c 08       	ld.w	r8,r6[0x0]
80005c7a:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005c7c:	49 79       	lddpc	r9,80005cd8 <vTaskDelayUntil+0x6c>
80005c7e:	72 09       	ld.w	r9,r9[0x0]
80005c80:	12 38       	cp.w	r8,r9
80005c82:	e0 88 00 0c 	brls	80005c9a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005c86:	0e 38       	cp.w	r8,r7
80005c88:	e0 88 00 22 	brls	80005ccc <vTaskDelayUntil+0x60>
80005c8c:	49 38       	lddpc	r8,80005cd8 <vTaskDelayUntil+0x6c>
80005c8e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005c90:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80005c92:	10 37       	cp.w	r7,r8
80005c94:	e0 88 00 14 	brls	80005cbc <vTaskDelayUntil+0x50>
80005c98:	c0 a8       	rjmp	80005cac <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005c9a:	0e 38       	cp.w	r8,r7
80005c9c:	e0 8b 00 16 	brhi	80005cc8 <vTaskDelayUntil+0x5c>
80005ca0:	48 e8       	lddpc	r8,80005cd8 <vTaskDelayUntil+0x6c>
80005ca2:	70 08       	ld.w	r8,r8[0x0]
80005ca4:	10 37       	cp.w	r7,r8
80005ca6:	e0 8b 00 11 	brhi	80005cc8 <vTaskDelayUntil+0x5c>
80005caa:	c1 18       	rjmp	80005ccc <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005cac:	48 c8       	lddpc	r8,80005cdc <vTaskDelayUntil+0x70>
80005cae:	70 0c       	ld.w	r12,r8[0x0]
80005cb0:	2f cc       	sub	r12,-4
80005cb2:	f0 1f 00 0c 	mcall	80005ce0 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005cb6:	0e 9c       	mov	r12,r7
80005cb8:	f0 1f 00 0b 	mcall	80005ce4 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005cbc:	f0 1f 00 0b 	mcall	80005ce8 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005cc0:	c0 81       	brne	80005cd0 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80005cc2:	d7 33       	scall
80005cc4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005cc8:	8d 07       	st.w	r6[0x0],r7
80005cca:	cf 1b       	rjmp	80005cac <vTaskDelayUntil+0x40>
80005ccc:	8d 07       	st.w	r6[0x0],r7
80005cce:	cf 7b       	rjmp	80005cbc <vTaskDelayUntil+0x50>
80005cd0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005cd4:	80 00       	ld.sh	r0,r0[0x0]
80005cd6:	57 6c       	stdsp	sp[0x1d8],r12
80005cd8:	00 00       	add	r0,r0
80005cda:	0d 14       	ld.sh	r4,r6++
80005cdc:	00 00       	add	r0,r0
80005cde:	0c e8       	st.h	--r6,r8
80005ce0:	80 00       	ld.sh	r0,r0[0x0]
80005ce2:	4f 26       	lddpc	r6,80005ea8 <xTaskGenericCreate+0xdc>
80005ce4:	80 00       	ld.sh	r0,r0[0x0]
80005ce6:	5c 10       	scr	r0
80005ce8:	80 00       	ld.sh	r0,r0[0x0]
80005cea:	5b 28       	cp.w	r8,-14

80005cec <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80005cec:	eb cd 40 c0 	pushm	r6-r7,lr
80005cf0:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80005cf2:	48 e7       	lddpc	r7,80005d28 <vTaskPlaceOnEventList+0x3c>
80005cf4:	6e 0b       	ld.w	r11,r7[0x0]
80005cf6:	2e 8b       	sub	r11,-24
80005cf8:	f0 1f 00 0d 	mcall	80005d2c <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005cfc:	6e 0c       	ld.w	r12,r7[0x0]
80005cfe:	2f cc       	sub	r12,-4
80005d00:	f0 1f 00 0c 	mcall	80005d30 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80005d04:	5b f6       	cp.w	r6,-1
80005d06:	c0 81       	brne	80005d16 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005d08:	6e 0b       	ld.w	r11,r7[0x0]
80005d0a:	2f cb       	sub	r11,-4
80005d0c:	48 ac       	lddpc	r12,80005d34 <vTaskPlaceOnEventList+0x48>
80005d0e:	f0 1f 00 0b 	mcall	80005d38 <vTaskPlaceOnEventList+0x4c>
80005d12:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80005d16:	48 a8       	lddpc	r8,80005d3c <vTaskPlaceOnEventList+0x50>
80005d18:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80005d1a:	ec 0c 00 0c 	add	r12,r6,r12
80005d1e:	f0 1f 00 09 	mcall	80005d40 <vTaskPlaceOnEventList+0x54>
80005d22:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005d26:	00 00       	add	r0,r0
80005d28:	00 00       	add	r0,r0
80005d2a:	0c e8       	st.h	--r6,r8
80005d2c:	80 00       	ld.sh	r0,r0[0x0]
80005d2e:	4e f2       	lddpc	r2,80005ee8 <xTaskGenericCreate+0x11c>
80005d30:	80 00       	ld.sh	r0,r0[0x0]
80005d32:	4f 26       	lddpc	r6,80005ef8 <xTaskGenericCreate+0x12c>
80005d34:	00 00       	add	r0,r0
80005d36:	0d 3c       	ld.ub	r12,r6++
80005d38:	80 00       	ld.sh	r0,r0[0x0]
80005d3a:	4e d6       	lddpc	r6,80005eec <xTaskGenericCreate+0x120>
80005d3c:	00 00       	add	r0,r0
80005d3e:	0d 14       	ld.sh	r4,r6++
80005d40:	80 00       	ld.sh	r0,r0[0x0]
80005d42:	5c 10       	scr	r0

80005d44 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80005d44:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005d48:	49 67       	lddpc	r7,80005da0 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005d4a:	49 74       	lddpc	r4,80005da4 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005d4c:	49 73       	lddpc	r3,80005da8 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005d4e:	49 85       	lddpc	r5,80005dac <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005d50:	6e 08       	ld.w	r8,r7[0x0]
80005d52:	58 08       	cp.w	r8,0
80005d54:	c1 e0       	breq	80005d90 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80005d56:	f0 1f 00 17 	mcall	80005db0 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005d5a:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005d5c:	f0 1f 00 16 	mcall	80005db4 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80005d60:	58 06       	cp.w	r6,0
80005d62:	c1 70       	breq	80005d90 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80005d64:	f0 1f 00 15 	mcall	80005db8 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80005d68:	68 38       	ld.w	r8,r4[0xc]
80005d6a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80005d6c:	ec cc ff fc 	sub	r12,r6,-4
80005d70:	f0 1f 00 13 	mcall	80005dbc <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80005d74:	66 08       	ld.w	r8,r3[0x0]
80005d76:	20 18       	sub	r8,1
80005d78:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80005d7a:	6e 08       	ld.w	r8,r7[0x0]
80005d7c:	20 18       	sub	r8,1
80005d7e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80005d80:	f0 1f 00 10 	mcall	80005dc0 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80005d84:	6c cc       	ld.w	r12,r6[0x30]
80005d86:	f0 1f 00 10 	mcall	80005dc4 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80005d8a:	0c 9c       	mov	r12,r6
80005d8c:	f0 1f 00 0e 	mcall	80005dc4 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005d90:	6a 08       	ld.w	r8,r5[0x0]
80005d92:	58 18       	cp.w	r8,1
80005d94:	e0 88 00 03 	brls	80005d9a <prvIdleTask+0x56>
			{
				taskYIELD();
80005d98:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80005d9a:	f0 1f 00 0c 	mcall	80005dc8 <prvIdleTask+0x84>
		}
		#endif
	}
80005d9e:	cd 9b       	rjmp	80005d50 <prvIdleTask+0xc>
80005da0:	00 00       	add	r0,r0
80005da2:	0c 28       	rsub	r8,r6
80005da4:	00 00       	add	r0,r0
80005da6:	0c d4       	st.w	--r6,r4
80005da8:	00 00       	add	r0,r0
80005daa:	0d 34       	ld.ub	r4,r6++
80005dac:	00 00       	add	r0,r0
80005dae:	0c 34       	cp.w	r4,r6
80005db0:	80 00       	ld.sh	r0,r0[0x0]
80005db2:	57 6c       	stdsp	sp[0x1d8],r12
80005db4:	80 00       	ld.sh	r0,r0[0x0]
80005db6:	5b 28       	cp.w	r8,-14
80005db8:	80 00       	ld.sh	r0,r0[0x0]
80005dba:	4f e0       	lddpc	r0,80005fb0 <xTaskGenericCreate+0x1e4>
80005dbc:	80 00       	ld.sh	r0,r0[0x0]
80005dbe:	4f 26       	lddpc	r6,80005f84 <xTaskGenericCreate+0x1b8>
80005dc0:	80 00       	ld.sh	r0,r0[0x0]
80005dc2:	50 ec       	stdsp	sp[0x38],r12
80005dc4:	80 00       	ld.sh	r0,r0[0x0]
80005dc6:	52 24       	stdsp	sp[0x88],r4
80005dc8:	80 00       	ld.sh	r0,r0[0x0]
80005dca:	20 30       	sub	r0,3

80005dcc <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005dcc:	d4 31       	pushm	r0-r7,lr
80005dce:	20 1d       	sub	sp,4
80005dd0:	fa c4 ff d8 	sub	r4,sp,-40
80005dd4:	50 0c       	stdsp	sp[0x0],r12
80005dd6:	16 91       	mov	r1,r11
80005dd8:	14 97       	mov	r7,r10
80005dda:	12 90       	mov	r0,r9
80005ddc:	10 93       	mov	r3,r8
80005dde:	68 02       	ld.w	r2,r4[0x0]
80005de0:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80005de2:	34 8c       	mov	r12,72
80005de4:	f0 1f 00 5c 	mcall	80005f54 <xTaskGenericCreate+0x188>
80005de8:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80005dea:	c0 31       	brne	80005df0 <xTaskGenericCreate+0x24>
80005dec:	3f fc       	mov	r12,-1
80005dee:	ca f8       	rjmp	80005f4c <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005df0:	58 06       	cp.w	r6,0
80005df2:	e0 81 00 af 	brne	80005f50 <xTaskGenericCreate+0x184>
80005df6:	0e 9c       	mov	r12,r7
80005df8:	5c 7c       	castu.h	r12
80005dfa:	a3 6c       	lsl	r12,0x2
80005dfc:	f0 1f 00 56 	mcall	80005f54 <xTaskGenericCreate+0x188>
80005e00:	18 96       	mov	r6,r12
80005e02:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80005e04:	c0 61       	brne	80005e10 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80005e06:	0a 9c       	mov	r12,r5
80005e08:	f0 1f 00 54 	mcall	80005f58 <xTaskGenericCreate+0x18c>
80005e0c:	3f fc       	mov	r12,-1
80005e0e:	c9 f8       	rjmp	80005f4c <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80005e10:	5c 77       	castu.h	r7
80005e12:	ee 0a 15 02 	lsl	r10,r7,0x2
80005e16:	e0 6b 00 a5 	mov	r11,165
80005e1a:	0c 9c       	mov	r12,r6
80005e1c:	f0 1f 00 50 	mcall	80005f5c <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80005e20:	ee c6 00 01 	sub	r6,r7,1
80005e24:	6a c8       	ld.w	r8,r5[0x30]
80005e26:	f0 06 00 26 	add	r6,r8,r6<<0x2
80005e2a:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80005e2e:	31 0a       	mov	r10,16
80005e30:	02 9b       	mov	r11,r1
80005e32:	ea cc ff cc 	sub	r12,r5,-52
80005e36:	f0 1f 00 4b 	mcall	80005f60 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80005e3a:	30 08       	mov	r8,0
80005e3c:	eb 68 00 43 	st.b	r5[67],r8
80005e40:	58 73       	cp.w	r3,7
80005e42:	e6 07 17 80 	movls	r7,r3
80005e46:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80005e4a:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80005e4c:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80005e50:	ea c4 ff fc 	sub	r4,r5,-4
80005e54:	08 9c       	mov	r12,r4
80005e56:	f0 1f 00 44 	mcall	80005f64 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80005e5a:	ea cc ff e8 	sub	r12,r5,-24
80005e5e:	f0 1f 00 42 	mcall	80005f64 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80005e62:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80005e64:	ee 07 11 08 	rsub	r7,r7,8
80005e68:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80005e6a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005e6c:	00 9a       	mov	r10,r0
80005e6e:	40 0b       	lddsp	r11,sp[0x0]
80005e70:	0c 9c       	mov	r12,r6
80005e72:	f0 1f 00 3e 	mcall	80005f68 <xTaskGenericCreate+0x19c>
80005e76:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005e78:	58 02       	cp.w	r2,0
80005e7a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005e7e:	f0 1f 00 3c 	mcall	80005f6c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80005e82:	4b c8       	lddpc	r8,80005f70 <xTaskGenericCreate+0x1a4>
80005e84:	70 09       	ld.w	r9,r8[0x0]
80005e86:	2f f9       	sub	r9,-1
80005e88:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005e8a:	4b b8       	lddpc	r8,80005f74 <xTaskGenericCreate+0x1a8>
80005e8c:	70 08       	ld.w	r8,r8[0x0]
80005e8e:	58 08       	cp.w	r8,0
80005e90:	c2 61       	brne	80005edc <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80005e92:	4b 98       	lddpc	r8,80005f74 <xTaskGenericCreate+0x1a8>
80005e94:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005e96:	4b 78       	lddpc	r8,80005f70 <xTaskGenericCreate+0x1a4>
80005e98:	70 08       	ld.w	r8,r8[0x0]
80005e9a:	58 18       	cp.w	r8,1
80005e9c:	c2 b1       	brne	80005ef2 <xTaskGenericCreate+0x126>
80005e9e:	4b 77       	lddpc	r7,80005f78 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80005ea0:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80005ea4:	0e 9c       	mov	r12,r7
80005ea6:	f0 1f 00 36 	mcall	80005f7c <xTaskGenericCreate+0x1b0>
80005eaa:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80005eac:	0c 37       	cp.w	r7,r6
80005eae:	cf b1       	brne	80005ea4 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80005eb0:	4b 47       	lddpc	r7,80005f80 <xTaskGenericCreate+0x1b4>
80005eb2:	0e 9c       	mov	r12,r7
80005eb4:	f0 1f 00 32 	mcall	80005f7c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80005eb8:	4b 36       	lddpc	r6,80005f84 <xTaskGenericCreate+0x1b8>
80005eba:	0c 9c       	mov	r12,r6
80005ebc:	f0 1f 00 30 	mcall	80005f7c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80005ec0:	4b 2c       	lddpc	r12,80005f88 <xTaskGenericCreate+0x1bc>
80005ec2:	f0 1f 00 2f 	mcall	80005f7c <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80005ec6:	4b 2c       	lddpc	r12,80005f8c <xTaskGenericCreate+0x1c0>
80005ec8:	f0 1f 00 2d 	mcall	80005f7c <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80005ecc:	4b 1c       	lddpc	r12,80005f90 <xTaskGenericCreate+0x1c4>
80005ece:	f0 1f 00 2c 	mcall	80005f7c <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80005ed2:	4b 18       	lddpc	r8,80005f94 <xTaskGenericCreate+0x1c8>
80005ed4:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80005ed6:	4b 18       	lddpc	r8,80005f98 <xTaskGenericCreate+0x1cc>
80005ed8:	91 06       	st.w	r8[0x0],r6
80005eda:	c0 c8       	rjmp	80005ef2 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005edc:	4b 08       	lddpc	r8,80005f9c <xTaskGenericCreate+0x1d0>
80005ede:	70 08       	ld.w	r8,r8[0x0]
80005ee0:	58 08       	cp.w	r8,0
80005ee2:	c0 81       	brne	80005ef2 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005ee4:	4a 48       	lddpc	r8,80005f74 <xTaskGenericCreate+0x1a8>
80005ee6:	70 08       	ld.w	r8,r8[0x0]
80005ee8:	70 b8       	ld.w	r8,r8[0x2c]
80005eea:	10 33       	cp.w	r3,r8
80005eec:	c0 33       	brcs	80005ef2 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80005eee:	4a 28       	lddpc	r8,80005f74 <xTaskGenericCreate+0x1a8>
80005ef0:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80005ef2:	6a b8       	ld.w	r8,r5[0x2c]
80005ef4:	4a b9       	lddpc	r9,80005fa0 <xTaskGenericCreate+0x1d4>
80005ef6:	72 09       	ld.w	r9,r9[0x0]
80005ef8:	12 38       	cp.w	r8,r9
80005efa:	e0 88 00 04 	brls	80005f02 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005efe:	4a 99       	lddpc	r9,80005fa0 <xTaskGenericCreate+0x1d4>
80005f00:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80005f02:	4a 98       	lddpc	r8,80005fa4 <xTaskGenericCreate+0x1d8>
80005f04:	70 09       	ld.w	r9,r8[0x0]
80005f06:	2f f9       	sub	r9,-1
80005f08:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80005f0a:	6a b8       	ld.w	r8,r5[0x2c]
80005f0c:	4a 79       	lddpc	r9,80005fa8 <xTaskGenericCreate+0x1dc>
80005f0e:	72 09       	ld.w	r9,r9[0x0]
80005f10:	12 38       	cp.w	r8,r9
80005f12:	e0 88 00 04 	brls	80005f1a <xTaskGenericCreate+0x14e>
80005f16:	4a 59       	lddpc	r9,80005fa8 <xTaskGenericCreate+0x1dc>
80005f18:	93 08       	st.w	r9[0x0],r8
80005f1a:	6a bc       	ld.w	r12,r5[0x2c]
80005f1c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005f20:	08 9b       	mov	r11,r4
80005f22:	49 68       	lddpc	r8,80005f78 <xTaskGenericCreate+0x1ac>
80005f24:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005f28:	f0 1f 00 21 	mcall	80005fac <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80005f2c:	f0 1f 00 21 	mcall	80005fb0 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80005f30:	49 b8       	lddpc	r8,80005f9c <xTaskGenericCreate+0x1d0>
80005f32:	70 08       	ld.w	r8,r8[0x0]
80005f34:	58 08       	cp.w	r8,0
80005f36:	c0 a0       	breq	80005f4a <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80005f38:	48 f8       	lddpc	r8,80005f74 <xTaskGenericCreate+0x1a8>
80005f3a:	70 08       	ld.w	r8,r8[0x0]
80005f3c:	70 b8       	ld.w	r8,r8[0x2c]
80005f3e:	10 33       	cp.w	r3,r8
80005f40:	e0 88 00 05 	brls	80005f4a <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80005f44:	d7 33       	scall
80005f46:	30 1c       	mov	r12,1
80005f48:	c0 28       	rjmp	80005f4c <xTaskGenericCreate+0x180>
80005f4a:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80005f4c:	2f fd       	sub	sp,-4
80005f4e:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005f50:	99 c6       	st.w	r12[0x30],r6
80005f52:	c5 fb       	rjmp	80005e10 <xTaskGenericCreate+0x44>
80005f54:	80 00       	ld.sh	r0,r0[0x0]
80005f56:	52 4c       	stdsp	sp[0x90],r12
80005f58:	80 00       	ld.sh	r0,r0[0x0]
80005f5a:	52 24       	stdsp	sp[0x88],r4
80005f5c:	80 00       	ld.sh	r0,r0[0x0]
80005f5e:	6c 38       	ld.w	r8,r6[0xc]
80005f60:	80 00       	ld.sh	r0,r0[0x0]
80005f62:	6f 7c       	ld.w	r12,r7[0x5c]
80005f64:	80 00       	ld.sh	r0,r0[0x0]
80005f66:	4e d0       	lddpc	r0,80006118 <PrintDec+0x62>
80005f68:	80 00       	ld.sh	r0,r0[0x0]
80005f6a:	4f 4c       	lddpc	r12,80006138 <PrintDec+0x82>
80005f6c:	80 00       	ld.sh	r0,r0[0x0]
80005f6e:	4f e0       	lddpc	r0,80006164 <PrintDec+0xae>
80005f70:	00 00       	add	r0,r0
80005f72:	0d 34       	ld.ub	r4,r6++
80005f74:	00 00       	add	r0,r0
80005f76:	0c e8       	st.h	--r6,r8
80005f78:	00 00       	add	r0,r0
80005f7a:	0c 34       	cp.w	r4,r6
80005f7c:	80 00       	ld.sh	r0,r0[0x0]
80005f7e:	4e bc       	lddpc	r12,80006128 <PrintDec+0x72>
80005f80:	00 00       	add	r0,r0
80005f82:	0d 00       	ld.w	r0,r6++
80005f84:	00 00       	add	r0,r0
80005f86:	0d 1c       	ld.sh	r12,r6++
80005f88:	00 00       	add	r0,r0
80005f8a:	0c ec       	st.h	--r6,r12
80005f8c:	00 00       	add	r0,r0
80005f8e:	0c d4       	st.w	--r6,r4
80005f90:	00 00       	add	r0,r0
80005f92:	0d 3c       	ld.ub	r12,r6++
80005f94:	00 00       	add	r0,r0
80005f96:	0c 20       	rsub	r0,r6
80005f98:	00 00       	add	r0,r0
80005f9a:	0c 30       	cp.w	r0,r6
80005f9c:	00 00       	add	r0,r0
80005f9e:	0c 24       	rsub	r4,r6
80005fa0:	00 00       	add	r0,r0
80005fa2:	0c 1c       	sub	r12,r6
80005fa4:	00 00       	add	r0,r0
80005fa6:	0d 30       	ld.ub	r0,r6++
80005fa8:	00 00       	add	r0,r0
80005faa:	0d 50       	ld.sh	r0,--r6
80005fac:	80 00       	ld.sh	r0,r0[0x0]
80005fae:	4e d6       	lddpc	r6,80006160 <PrintDec+0xaa>
80005fb0:	80 00       	ld.sh	r0,r0[0x0]
80005fb2:	50 ec       	stdsp	sp[0x38],r12

80005fb4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80005fb4:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80005fb6:	30 09       	mov	r9,0
80005fb8:	1a d9       	st.w	--sp,r9
80005fba:	1a d9       	st.w	--sp,r9
80005fbc:	1a d9       	st.w	--sp,r9
80005fbe:	12 98       	mov	r8,r9
80005fc0:	e0 6a 01 00 	mov	r10,256
80005fc4:	48 9b       	lddpc	r11,80005fe8 <vTaskStartScheduler+0x34>
80005fc6:	48 ac       	lddpc	r12,80005fec <vTaskStartScheduler+0x38>
80005fc8:	f0 1f 00 0a 	mcall	80005ff0 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005fcc:	2f dd       	sub	sp,-12
80005fce:	58 1c       	cp.w	r12,1
80005fd0:	c0 a1       	brne	80005fe4 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80005fd2:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80005fd4:	30 19       	mov	r9,1
80005fd6:	48 88       	lddpc	r8,80005ff4 <vTaskStartScheduler+0x40>
80005fd8:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80005fda:	30 09       	mov	r9,0
80005fdc:	48 78       	lddpc	r8,80005ff8 <vTaskStartScheduler+0x44>
80005fde:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80005fe0:	f0 1f 00 07 	mcall	80005ffc <vTaskStartScheduler+0x48>
80005fe4:	d8 02       	popm	pc
80005fe6:	00 00       	add	r0,r0
80005fe8:	80 00       	ld.sh	r0,r0[0x0]
80005fea:	d1 04       	*unknown*
80005fec:	80 00       	ld.sh	r0,r0[0x0]
80005fee:	5d 44       	*unknown*
80005ff0:	80 00       	ld.sh	r0,r0[0x0]
80005ff2:	5d cc       	*unknown*
80005ff4:	00 00       	add	r0,r0
80005ff6:	0c 24       	rsub	r4,r6
80005ff8:	00 00       	add	r0,r0
80005ffa:	0d 14       	ld.sh	r4,r6++
80005ffc:	80 00       	ld.sh	r0,r0[0x0]
80005ffe:	4f f0       	lddpc	r0,800061f8 <log+0x68>

80006000 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006000:	16 cc       	st.b	r11++,r12
	return str;
}
80006002:	5e fb       	retal	r11

80006004 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006004:	eb cd 40 c0 	pushm	r6-r7,lr
80006008:	20 3d       	sub	sp,12
8000600a:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
8000600c:	30 06       	mov	r6,0
8000600e:	30 07       	mov	r7,0
80006010:	fa e7 00 00 	st.d	sp[0],r6
80006014:	30 0c       	mov	r12,0
80006016:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006018:	58 08       	cp.w	r8,0
8000601a:	c1 30       	breq	80006040 <PrintHex+0x3c>
8000601c:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
8000601e:	1a 9c       	mov	r12,sp
80006020:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006024:	58 9e       	cp.w	lr,9
80006026:	e0 8a 00 04 	brle	8000602e <PrintHex+0x2a>
8000602a:	2c 9e       	sub	lr,-55
8000602c:	c0 48       	rjmp	80006034 <PrintHex+0x30>
8000602e:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006032:	2d 0e       	sub	lr,-48
80006034:	f8 09 0b 0e 	st.b	r12[r9],lr
80006038:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
8000603a:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
8000603c:	cf 21       	brne	80006020 <PrintHex+0x1c>
8000603e:	c0 48       	rjmp	80006046 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006040:	33 08       	mov	r8,48
80006042:	ba 88       	st.b	sp[0x0],r8
80006044:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006046:	f6 09 01 08 	sub	r8,r11,r9
8000604a:	58 08       	cp.w	r8,0
8000604c:	e0 8a 00 13 	brle	80006072 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006050:	12 1b       	sub	r11,r9
80006052:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006056:	18 9e       	mov	lr,r12
80006058:	58 0c       	cp.w	r12,0
8000605a:	e0 8a 00 0c 	brle	80006072 <PrintHex+0x6e>
8000605e:	1a 9b       	mov	r11,sp
80006060:	12 0b       	add	r11,r9
80006062:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006064:	33 07       	mov	r7,48
80006066:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006068:	2f f8       	sub	r8,-1
8000606a:	1c 38       	cp.w	r8,lr
8000606c:	cf d5       	brlt	80006066 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000606e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006072:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006076:	f0 cb ff ff 	sub	r11,r8,-1
8000607a:	58 0b       	cp.w	r11,0
8000607c:	e0 8a 00 19 	brle	800060ae <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006080:	fa cb ff f4 	sub	r11,sp,-12
80006084:	f6 09 00 09 	add	r9,r11,r9
80006088:	37 8b       	mov	r11,120
8000608a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
8000608e:	fa c9 ff f4 	sub	r9,sp,-12
80006092:	10 09       	add	r9,r8
80006094:	33 0b       	mov	r11,48
80006096:	f3 6b ff f4 	st.b	r9[-12],r11
8000609a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000609e:	fa ce 00 01 	sub	lr,sp,1
800060a2:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
800060a4:	11 8b       	ld.ub	r11,r8[0x0]
800060a6:	12 cb       	st.b	r9++,r11
800060a8:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
800060aa:	1c 38       	cp.w	r8,lr
800060ac:	cf c1       	brne	800060a4 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
800060ae:	14 9c       	mov	r12,r10
800060b0:	2f dd       	sub	sp,-12
800060b2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800060b6 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
800060b6:	d4 21       	pushm	r4-r7,lr
800060b8:	20 3d       	sub	sp,12
800060ba:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
800060bc:	30 06       	mov	r6,0
800060be:	30 07       	mov	r7,0
800060c0:	fa e7 00 00 	st.d	sp[0],r6
800060c4:	30 0c       	mov	r12,0
800060c6:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
800060c8:	58 08       	cp.w	r8,0
800060ca:	c0 35       	brlt	800060d0 <PrintDec+0x1a>
800060cc:	14 97       	mov	r7,r10
800060ce:	c0 58       	rjmp	800060d8 <PrintDec+0x22>
	{
		*p++ = '-';
800060d0:	14 97       	mov	r7,r10
800060d2:	32 d9       	mov	r9,45
800060d4:	0e c9       	st.b	r7++,r9
		i = -i;
800060d6:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
800060d8:	58 08       	cp.w	r8,0
800060da:	c0 51       	brne	800060e4 <PrintDec+0x2e>
800060dc:	33 08       	mov	r8,48
800060de:	ba 88       	st.b	sp[0x0],r8
800060e0:	30 1e       	mov	lr,1
800060e2:	c2 f8       	rjmp	80006140 <PrintDec+0x8a>
	
	int ten = i%10;
800060e4:	e0 65 66 67 	mov	r5,26215
800060e8:	ea 15 66 66 	orh	r5,0x6666
800060ec:	f0 05 04 44 	muls.d	r4,r8,r5
800060f0:	ea 0c 14 02 	asr	r12,r5,0x2
800060f4:	f0 09 14 1f 	asr	r9,r8,0x1f
800060f8:	f8 09 01 09 	sub	r9,r12,r9
800060fc:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006100:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006104:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006106:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006108:	e0 66 66 67 	mov	r6,26215
8000610c:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006110:	2d 09       	sub	r9,-48
80006112:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006116:	2f fe       	sub	lr,-1
		i /= 10;
80006118:	f0 06 04 44 	muls.d	r4,r8,r6
8000611c:	ea 09 14 02 	asr	r9,r5,0x2
80006120:	bf 58       	asr	r8,0x1f
80006122:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006126:	f0 06 04 44 	muls.d	r4,r8,r6
8000612a:	ea 09 14 02 	asr	r9,r5,0x2
8000612e:	f0 05 14 1f 	asr	r5,r8,0x1f
80006132:	0a 19       	sub	r9,r5
80006134:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006138:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
8000613c:	58 08       	cp.w	r8,0
8000613e:	ce 91       	brne	80006110 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006140:	f6 0e 01 08 	sub	r8,r11,lr
80006144:	58 08       	cp.w	r8,0
80006146:	e0 89 00 06 	brgt	80006152 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000614a:	58 0e       	cp.w	lr,0
8000614c:	e0 89 00 14 	brgt	80006174 <PrintDec+0xbe>
80006150:	c1 d8       	rjmp	8000618a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006152:	1c 1b       	sub	r11,lr
80006154:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006156:	16 9c       	mov	r12,r11
80006158:	58 0b       	cp.w	r11,0
8000615a:	fe 9a ff f8 	brle	8000614a <PrintDec+0x94>
8000615e:	1a 99       	mov	r9,sp
80006160:	1c 09       	add	r9,lr
80006162:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006164:	33 06       	mov	r6,48
80006166:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006168:	2f f8       	sub	r8,-1
8000616a:	18 38       	cp.w	r8,r12
8000616c:	cf d5       	brlt	80006166 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
8000616e:	f6 0e 00 0e 	add	lr,r11,lr
80006172:	ce cb       	rjmp	8000614a <PrintDec+0x94>
80006174:	fa c8 ff f4 	sub	r8,sp,-12
80006178:	1c 08       	add	r8,lr
8000617a:	20 d8       	sub	r8,13
8000617c:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006180:	11 89       	ld.ub	r9,r8[0x0]
80006182:	0e c9       	st.b	r7++,r9
80006184:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006186:	16 38       	cp.w	r8,r11
80006188:	cf c1       	brne	80006180 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
8000618a:	14 9c       	mov	r12,r10
8000618c:	2f dd       	sub	sp,-12
8000618e:	d8 22       	popm	r4-r7,pc

80006190 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006190:	d4 31       	pushm	r0-r7,lr
80006192:	fa cd 02 08 	sub	sp,sp,520
80006196:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006198:	e0 6a 01 00 	mov	r10,256
8000619c:	30 0b       	mov	r11,0
8000619e:	fa cc fe f8 	sub	r12,sp,-264
800061a2:	f0 1f 00 4e 	mcall	800062d8 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
800061a6:	fa c4 fd d4 	sub	r4,sp,-556
800061aa:	30 0a       	mov	r10,0
800061ac:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800061ae:	fa c3 ff fc 	sub	r3,sp,-4
800061b2:	e0 61 01 00 	mov	r1,256
800061b6:	14 90       	mov	r0,r10
			
					if(*str == '%')
800061b8:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800061ba:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800061be:	02 9a       	mov	r10,r1
800061c0:	00 9b       	mov	r11,r0
800061c2:	06 9c       	mov	r12,r3
800061c4:	f0 1f 00 45 	mcall	800062d8 <log+0x148>
			
					if(*str == '%')
800061c8:	0f 88       	ld.ub	r8,r7[0x0]
800061ca:	e4 08 18 00 	cp.b	r8,r2
800061ce:	c5 71       	brne	8000627c <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
800061d0:	ee c8 ff ff 	sub	r8,r7,-1
800061d4:	11 89       	ld.ub	r9,r8[0x0]
800061d6:	4c 2a       	lddpc	r10,800062dc <log+0x14c>
800061d8:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
800061da:	23 09       	sub	r9,48
800061dc:	30 9a       	mov	r10,9
800061de:	f4 09 18 00 	cp.b	r9,r10
800061e2:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
800061e6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800061ea:	f7 b9 08 30 	subls	r9,48
800061ee:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
800061f2:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
800061f6:	0f 88       	ld.ub	r8,r7[0x0]
800061f8:	22 58       	sub	r8,37
800061fa:	e0 48 00 53 	cp.w	r8,83
800061fe:	e0 8b 00 31 	brhi	80006260 <log+0xd0>
80006202:	4b 89       	lddpc	r9,800062e0 <log+0x150>
80006204:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006208:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
8000620c:	06 9a       	mov	r10,r3
8000620e:	40 0b       	lddsp	r11,sp[0x0]
80006210:	5c 5b       	castu.b	r11
80006212:	68 0c       	ld.w	r12,r4[0x0]
80006214:	f0 1f 00 34 	mcall	800062e4 <log+0x154>
							break;
80006218:	c2 98       	rjmp	8000626a <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
8000621a:	4b 4c       	lddpc	r12,800062e8 <log+0x158>
8000621c:	f0 1f 00 34 	mcall	800062ec <log+0x15c>
80006220:	08 95       	mov	r5,r4
80006222:	06 9c       	mov	r12,r3
							break;
80006224:	c2 38       	rjmp	8000626a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006226:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
8000622a:	06 9a       	mov	r10,r3
8000622c:	40 0b       	lddsp	r11,sp[0x0]
8000622e:	5c 5b       	castu.b	r11
80006230:	68 0c       	ld.w	r12,r4[0x0]
80006232:	f0 1f 00 30 	mcall	800062f0 <log+0x160>
80006236:	06 9c       	mov	r12,r3
							break;
80006238:	c1 98       	rjmp	8000626a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000623a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
8000623e:	06 9b       	mov	r11,r3
80006240:	09 bc       	ld.ub	r12,r4[0x3]
80006242:	f0 1f 00 2d 	mcall	800062f4 <log+0x164>
80006246:	06 9c       	mov	r12,r3
							break;
80006248:	c1 18       	rjmp	8000626a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000624a:	e8 c5 ff fc 	sub	r5,r4,-4
8000624e:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006250:	c0 d8       	rjmp	8000626a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006252:	06 9b       	mov	r11,r3
80006254:	32 5c       	mov	r12,37
80006256:	f0 1f 00 28 	mcall	800062f4 <log+0x164>
8000625a:	08 95       	mov	r5,r4
8000625c:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
8000625e:	c0 68       	rjmp	8000626a <log+0xda>
							
							default:
							log("I need relax.");
80006260:	4a 6c       	lddpc	r12,800062f8 <log+0x168>
80006262:	f0 1f 00 23 	mcall	800062ec <log+0x15c>
80006266:	08 95       	mov	r5,r4
80006268:	06 9c       	mov	r12,r3
						}
						str++;
8000626a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000626c:	1a dc       	st.w	--sp,r12
8000626e:	1a d6       	st.w	--sp,r6
80006270:	4a 3b       	lddpc	r11,800062fc <log+0x16c>
80006272:	0c 9c       	mov	r12,r6
80006274:	f0 1f 00 23 	mcall	80006300 <log+0x170>
80006278:	2f ed       	sub	sp,-8
8000627a:	c0 a8       	rjmp	8000628e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000627c:	2f f7       	sub	r7,-1
8000627e:	1a d8       	st.w	--sp,r8
80006280:	1a d6       	st.w	--sp,r6
80006282:	4a 1b       	lddpc	r11,80006304 <log+0x174>
80006284:	0c 9c       	mov	r12,r6
80006286:	f0 1f 00 1f 	mcall	80006300 <log+0x170>
8000628a:	08 95       	mov	r5,r4
8000628c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
8000628e:	0f 89       	ld.ub	r9,r7[0x0]
80006290:	30 08       	mov	r8,0
80006292:	f0 09 18 00 	cp.b	r9,r8
80006296:	c0 30       	breq	8000629c <log+0x10c>
80006298:	0a 94       	mov	r4,r5
8000629a:	c9 2b       	rjmp	800061be <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
8000629c:	fa c7 fe f8 	sub	r7,sp,-264
800062a0:	1a d7       	st.w	--sp,r7
800062a2:	49 ab       	lddpc	r11,80006308 <log+0x178>
800062a4:	0e 9c       	mov	r12,r7
800062a6:	f0 1f 00 17 	mcall	80006300 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
800062aa:	5c 5c       	castu.b	r12
800062ac:	f8 c6 ff ff 	sub	r6,r12,-1
800062b0:	0c 9c       	mov	r12,r6
800062b2:	f0 1f 00 17 	mcall	8000630c <log+0x17c>
800062b6:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
800062b8:	0c 9a       	mov	r10,r6
800062ba:	0e 9b       	mov	r11,r7
800062bc:	f0 1f 00 15 	mcall	80006310 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
800062c0:	30 09       	mov	r9,0
800062c2:	30 5a       	mov	r10,5
800062c4:	fa cb fe f8 	sub	r11,sp,-264
800062c8:	49 38       	lddpc	r8,80006314 <log+0x184>
800062ca:	70 0c       	ld.w	r12,r8[0x0]
800062cc:	f0 1f 00 13 	mcall	80006318 <log+0x188>
800062d0:	2f fd       	sub	sp,-4
}
800062d2:	fe 3d fd f8 	sub	sp,-520
800062d6:	d8 32       	popm	r0-r7,pc
800062d8:	80 00       	ld.sh	r0,r0[0x0]
800062da:	6c 38       	ld.w	r8,r6[0xc]
800062dc:	00 00       	add	r0,r0
800062de:	0d 54       	ld.sh	r4,--r6
800062e0:	80 00       	ld.sh	r0,r0[0x0]
800062e2:	d1 0c       	*unknown*
800062e4:	80 00       	ld.sh	r0,r0[0x0]
800062e6:	60 b6       	ld.w	r6,r0[0x2c]
800062e8:	80 00       	ld.sh	r0,r0[0x0]
800062ea:	d3 b8       	*unknown*
800062ec:	80 00       	ld.sh	r0,r0[0x0]
800062ee:	61 90       	ld.w	r0,r0[0x64]
800062f0:	80 00       	ld.sh	r0,r0[0x0]
800062f2:	60 04       	ld.w	r4,r0[0x0]
800062f4:	80 00       	ld.sh	r0,r0[0x0]
800062f6:	60 00       	ld.w	r0,r0[0x0]
800062f8:	80 00       	ld.sh	r0,r0[0x0]
800062fa:	d3 c8       	*unknown*
800062fc:	80 00       	ld.sh	r0,r0[0x0]
800062fe:	d3 d8       	*unknown*
80006300:	80 00       	ld.sh	r0,r0[0x0]
80006302:	6f 28       	ld.w	r8,r7[0x48]
80006304:	80 00       	ld.sh	r0,r0[0x0]
80006306:	d3 e0       	acall	0x3e
80006308:	80 00       	ld.sh	r0,r0[0x0]
8000630a:	d3 e8       	*unknown*
8000630c:	80 00       	ld.sh	r0,r0[0x0]
8000630e:	52 4c       	stdsp	sp[0x90],r12
80006310:	80 00       	ld.sh	r0,r0[0x0]
80006312:	6a f0       	ld.w	r0,r5[0x3c]
80006314:	00 00       	add	r0,r0
80006316:	40 f8       	lddsp	r8,sp[0x3c]
80006318:	80 00       	ld.sh	r0,r0[0x0]
8000631a:	55 a0       	stdsp	sp[0x168],r0

8000631c <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
8000631c:	d4 31       	pushm	r0-r7,lr
8000631e:	fa cd 02 0c 	sub	sp,sp,524
80006322:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006324:	e0 6a 01 00 	mov	r10,256
80006328:	30 0b       	mov	r11,0
8000632a:	fa cc fe f4 	sub	r12,sp,-268
8000632e:	f0 1f 00 4c 	mcall	8000645c <logFromISR+0x140>
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
}
	
	
int logFromISR(char * content, ...)
80006332:	fa c4 fd d0 	sub	r4,sp,-560
80006336:	30 0a       	mov	r10,0
80006338:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000633a:	fa c3 ff fc 	sub	r3,sp,-4
8000633e:	e0 61 01 00 	mov	r1,256
80006342:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006344:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006346:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000634a:	02 9a       	mov	r10,r1
8000634c:	00 9b       	mov	r11,r0
8000634e:	06 9c       	mov	r12,r3
80006350:	f0 1f 00 43 	mcall	8000645c <logFromISR+0x140>
			
			if(*str == '%')
80006354:	0f 88       	ld.ub	r8,r7[0x0]
80006356:	e4 08 18 00 	cp.b	r8,r2
8000635a:	c5 11       	brne	800063fc <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
8000635c:	ee c8 ff ff 	sub	r8,r7,-1
80006360:	11 89       	ld.ub	r9,r8[0x0]
80006362:	4c 0a       	lddpc	r10,80006460 <logFromISR+0x144>
80006364:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006366:	23 09       	sub	r9,48
80006368:	30 9a       	mov	r10,9
8000636a:	f4 09 18 00 	cp.b	r9,r10
8000636e:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006372:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006376:	f7 b9 08 30 	subls	r9,48
8000637a:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
8000637e:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006382:	0f 88       	ld.ub	r8,r7[0x0]
80006384:	22 58       	sub	r8,37
80006386:	e0 48 00 53 	cp.w	r8,83
8000638a:	e0 8b 00 2b 	brhi	800063e0 <logFromISR+0xc4>
8000638e:	4b 69       	lddpc	r9,80006464 <logFromISR+0x148>
80006390:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006394:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006398:	06 9a       	mov	r10,r3
8000639a:	40 0b       	lddsp	r11,sp[0x0]
8000639c:	5c 5b       	castu.b	r11
8000639e:	68 0c       	ld.w	r12,r4[0x0]
800063a0:	f0 1f 00 32 	mcall	80006468 <logFromISR+0x14c>
					break;
800063a4:	c2 38       	rjmp	800063ea <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
800063a6:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
800063aa:	06 9a       	mov	r10,r3
800063ac:	40 0b       	lddsp	r11,sp[0x0]
800063ae:	5c 5b       	castu.b	r11
800063b0:	68 0c       	ld.w	r12,r4[0x0]
800063b2:	f0 1f 00 2f 	mcall	8000646c <logFromISR+0x150>
800063b6:	06 9c       	mov	r12,r3
					break;
800063b8:	c1 98       	rjmp	800063ea <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
800063ba:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
800063be:	06 9b       	mov	r11,r3
800063c0:	09 bc       	ld.ub	r12,r4[0x3]
800063c2:	f0 1f 00 2c 	mcall	80006470 <logFromISR+0x154>
800063c6:	06 9c       	mov	r12,r3
					break;
800063c8:	c1 18       	rjmp	800063ea <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
800063ca:	e8 c5 ff fc 	sub	r5,r4,-4
800063ce:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
800063d0:	c0 d8       	rjmp	800063ea <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
800063d2:	06 9b       	mov	r11,r3
800063d4:	32 5c       	mov	r12,37
800063d6:	f0 1f 00 27 	mcall	80006470 <logFromISR+0x154>
800063da:	08 95       	mov	r5,r4
800063dc:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800063de:	c0 68       	rjmp	800063ea <logFromISR+0xce>
					default:
					log("I need relax.");
800063e0:	4a 5c       	lddpc	r12,80006474 <logFromISR+0x158>
800063e2:	f0 1f 00 26 	mcall	80006478 <logFromISR+0x15c>
800063e6:	08 95       	mov	r5,r4
800063e8:	06 9c       	mov	r12,r3
				}
				str++;
800063ea:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800063ec:	1a dc       	st.w	--sp,r12
800063ee:	1a d6       	st.w	--sp,r6
800063f0:	4a 3b       	lddpc	r11,8000647c <logFromISR+0x160>
800063f2:	0c 9c       	mov	r12,r6
800063f4:	f0 1f 00 23 	mcall	80006480 <logFromISR+0x164>
800063f8:	2f ed       	sub	sp,-8
800063fa:	c0 a8       	rjmp	8000640e <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800063fc:	2f f7       	sub	r7,-1
800063fe:	1a d8       	st.w	--sp,r8
80006400:	1a d6       	st.w	--sp,r6
80006402:	4a 1b       	lddpc	r11,80006484 <logFromISR+0x168>
80006404:	0c 9c       	mov	r12,r6
80006406:	f0 1f 00 1f 	mcall	80006480 <logFromISR+0x164>
8000640a:	08 95       	mov	r5,r4
8000640c:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
8000640e:	0f 89       	ld.ub	r9,r7[0x0]
80006410:	30 08       	mov	r8,0
80006412:	f0 09 18 00 	cp.b	r9,r8
80006416:	c0 30       	breq	8000641c <logFromISR+0x100>
80006418:	0a 94       	mov	r4,r5
8000641a:	c9 8b       	rjmp	8000634a <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
8000641c:	fa c7 fe f4 	sub	r7,sp,-268
80006420:	1a d7       	st.w	--sp,r7
80006422:	49 ab       	lddpc	r11,80006488 <logFromISR+0x16c>
80006424:	0e 9c       	mov	r12,r7
80006426:	f0 1f 00 17 	mcall	80006480 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000642a:	5c 5c       	castu.b	r12
8000642c:	f8 c6 ff ff 	sub	r6,r12,-1
80006430:	0c 9c       	mov	r12,r6
80006432:	f0 1f 00 17 	mcall	8000648c <logFromISR+0x170>
80006436:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006438:	0c 9a       	mov	r10,r6
8000643a:	0e 9b       	mov	r11,r7
8000643c:	f0 1f 00 15 	mcall	80006490 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006440:	30 09       	mov	r9,0
80006442:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006444:	fa ca fe f8 	sub	r10,sp,-264
80006448:	fa cb fe f4 	sub	r11,sp,-268
8000644c:	49 28       	lddpc	r8,80006494 <logFromISR+0x178>
8000644e:	70 0c       	ld.w	r12,r8[0x0]
80006450:	f0 1f 00 12 	mcall	80006498 <logFromISR+0x17c>
80006454:	2f fd       	sub	sp,-4
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80006456:	fe 3d fd f4 	sub	sp,-524
8000645a:	d8 32       	popm	r0-r7,pc
8000645c:	80 00       	ld.sh	r0,r0[0x0]
8000645e:	6c 38       	ld.w	r8,r6[0xc]
80006460:	00 00       	add	r0,r0
80006462:	0d 55       	ld.sh	r5,--r6
80006464:	80 00       	ld.sh	r0,r0[0x0]
80006466:	d2 5c       	*unknown*
80006468:	80 00       	ld.sh	r0,r0[0x0]
8000646a:	60 b6       	ld.w	r6,r0[0x2c]
8000646c:	80 00       	ld.sh	r0,r0[0x0]
8000646e:	60 04       	ld.w	r4,r0[0x0]
80006470:	80 00       	ld.sh	r0,r0[0x0]
80006472:	60 00       	ld.w	r0,r0[0x0]
80006474:	80 00       	ld.sh	r0,r0[0x0]
80006476:	d3 c8       	*unknown*
80006478:	80 00       	ld.sh	r0,r0[0x0]
8000647a:	61 90       	ld.w	r0,r0[0x64]
8000647c:	80 00       	ld.sh	r0,r0[0x0]
8000647e:	d3 d8       	*unknown*
80006480:	80 00       	ld.sh	r0,r0[0x0]
80006482:	6f 28       	ld.w	r8,r7[0x48]
80006484:	80 00       	ld.sh	r0,r0[0x0]
80006486:	d3 e0       	acall	0x3e
80006488:	80 00       	ld.sh	r0,r0[0x0]
8000648a:	d3 e8       	*unknown*
8000648c:	80 00       	ld.sh	r0,r0[0x0]
8000648e:	52 4c       	stdsp	sp[0x90],r12
80006490:	80 00       	ld.sh	r0,r0[0x0]
80006492:	6a f0       	ld.w	r0,r5[0x3c]
80006494:	00 00       	add	r0,r0
80006496:	40 f8       	lddsp	r8,sp[0x3c]
80006498:	80 00       	ld.sh	r0,r0[0x0]
8000649a:	55 50       	stdsp	sp[0x154],r0

8000649c <log_init>:
		
	return str;
}

void log_init(void)
{
8000649c:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000649e:	30 2b       	mov	r11,2
800064a0:	49 0c       	lddpc	r12,800064e0 <log_init+0x44>
800064a2:	f0 1f 00 11 	mcall	800064e4 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
800064a6:	e0 6a 36 00 	mov	r10,13824
800064aa:	ea 1a 01 6e 	orh	r10,0x16e
800064ae:	48 fb       	lddpc	r11,800064e8 <log_init+0x4c>
800064b0:	fe 7c 18 00 	mov	r12,-59392
800064b4:	f0 1f 00 0e 	mcall	800064ec <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
800064b8:	30 4b       	mov	r11,4
800064ba:	33 2c       	mov	r12,50
800064bc:	f0 1f 00 0d 	mcall	800064f0 <log_init+0x54>
800064c0:	48 d8       	lddpc	r8,800064f4 <log_init+0x58>
800064c2:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800064c4:	30 09       	mov	r9,0
800064c6:	1a d9       	st.w	--sp,r9
800064c8:	1a d9       	st.w	--sp,r9
800064ca:	1a d9       	st.w	--sp,r9
800064cc:	30 28       	mov	r8,2
800064ce:	e0 6a 01 80 	mov	r10,384
800064d2:	48 ab       	lddpc	r11,800064f8 <log_init+0x5c>
800064d4:	48 ac       	lddpc	r12,800064fc <log_init+0x60>
800064d6:	f0 1f 00 0b 	mcall	80006500 <log_init+0x64>
800064da:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800064dc:	d8 02       	popm	pc
800064de:	00 00       	add	r0,r0
800064e0:	80 00       	ld.sh	r0,r0[0x0]
800064e2:	d3 f4       	*unknown*
800064e4:	80 00       	ld.sh	r0,r0[0x0]
800064e6:	66 28       	ld.w	r8,r3[0x8]
800064e8:	80 00       	ld.sh	r0,r0[0x0]
800064ea:	d3 ac       	*unknown*
800064ec:	80 00       	ld.sh	r0,r0[0x0]
800064ee:	4d f0       	lddpc	r0,80006668 <_stext+0x10>
800064f0:	80 00       	ld.sh	r0,r0[0x0]
800064f2:	56 f8       	stdsp	sp[0x1bc],r8
800064f4:	00 00       	add	r0,r0
800064f6:	40 f8       	lddsp	r8,sp[0x3c]
800064f8:	80 00       	ld.sh	r0,r0[0x0]
800064fa:	d3 f0       	acall	0x3f
800064fc:	80 00       	ld.sh	r0,r0[0x0]
800064fe:	65 04       	ld.w	r4,r2[0x40]
80006500:	80 00       	ld.sh	r0,r0[0x0]
80006502:	5d cc       	*unknown*

80006504 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80006504:	eb cd 40 f8 	pushm	r3-r7,lr
80006508:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000650a:	48 c7       	lddpc	r7,80006538 <task_log+0x34>
8000650c:	30 05       	mov	r5,0
8000650e:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006510:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006514:	0a 99       	mov	r9,r5
80006516:	08 9a       	mov	r10,r4
80006518:	1a 9b       	mov	r11,sp
8000651a:	6e 0c       	ld.w	r12,r7[0x0]
8000651c:	f0 1f 00 08 	mcall	8000653c <task_log+0x38>
80006520:	58 1c       	cp.w	r12,1
80006522:	cf 91       	brne	80006514 <task_log+0x10>
		{
			if( NULL != str)
80006524:	40 0b       	lddsp	r11,sp[0x0]
80006526:	58 0b       	cp.w	r11,0
80006528:	cf 60       	breq	80006514 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
8000652a:	06 9c       	mov	r12,r3
8000652c:	f0 1f 00 05 	mcall	80006540 <task_log+0x3c>
				vPortFree(str);
80006530:	40 0c       	lddsp	r12,sp[0x0]
80006532:	f0 1f 00 05 	mcall	80006544 <task_log+0x40>
80006536:	ce fb       	rjmp	80006514 <task_log+0x10>
80006538:	00 00       	add	r0,r0
8000653a:	40 f8       	lddsp	r8,sp[0x3c]
8000653c:	80 00       	ld.sh	r0,r0[0x0]
8000653e:	53 94       	stdsp	sp[0xe4],r4
80006540:	80 00       	ld.sh	r0,r0[0x0]
80006542:	4d a0       	lddpc	r0,800066a8 <malloc>
80006544:	80 00       	ld.sh	r0,r0[0x0]
80006546:	52 24       	stdsp	sp[0x88],r4

80006548 <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
80006548:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000654a:	fe 78 10 00 	mov	r8,-61440
8000654e:	30 19       	mov	r9,1
80006550:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006554:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006558:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
8000655c:	d3 03       	ssrf	0x10
	local_start_pll0();
8000655e:	f0 1f 00 13 	mcall	800065a8 <main+0x60>
		
	INTC_init_interrupts();
80006562:	f0 1f 00 13 	mcall	800065ac <main+0x64>
	
	log_init();		
80006566:	f0 1f 00 13 	mcall	800065b0 <main+0x68>
	log("----start debug----");	
8000656a:	49 3c       	lddpc	r12,800065b4 <main+0x6c>
8000656c:	f0 1f 00 13 	mcall	800065b8 <main+0x70>
		
	rtc_init();
80006570:	f0 1f 00 13 	mcall	800065bc <main+0x74>
	
	//fs_init();//65795机器无法通过文件系统初始化

	tc_init();	
80006574:	f0 1f 00 13 	mcall	800065c0 <main+0x78>
			
	xcmp_init();
80006578:	f0 1f 00 13 	mcall	800065c4 <main+0x7c>
	
	app_init();
8000657c:	f0 1f 00 13 	mcall	800065c8 <main+0x80>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80006580:	fe 79 10 00 	mov	r9,-61440
80006584:	f2 f8 01 60 	ld.w	r8,r9[352]
80006588:	e2 18 00 02 	andl	r8,0x2,COH
8000658c:	cf c0       	breq	80006584 <main+0x3c>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000658e:	fe 79 10 00 	mov	r9,-61440
80006592:	f2 f8 01 60 	ld.w	r8,r9[352]
80006596:	e2 18 00 02 	andl	r8,0x2,COH
8000659a:	cf c1       	brne	80006592 <main+0x4a>
	local_start_timer();
8000659c:	f0 1f 00 0c 	mcall	800065cc <main+0x84>
	
	Enable_global_interrupt();
800065a0:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
800065a2:	f0 1f 00 0c 	mcall	800065d0 <main+0x88>
	return 0;
}
800065a6:	d8 0a       	popm	pc,r12=0
800065a8:	80 00       	ld.sh	r0,r0[0x0]
800065aa:	46 c0       	lddsp	r0,sp[0x1b0]
800065ac:	80 00       	ld.sh	r0,r0[0x0]
800065ae:	48 dc       	lddpc	r12,800065e0 <gpio_enable_module_pin+0xc>
800065b0:	80 00       	ld.sh	r0,r0[0x0]
800065b2:	64 9c       	ld.w	r12,r2[0x24]
800065b4:	80 00       	ld.sh	r0,r0[0x0]
800065b6:	d4 04       	*unknown*
800065b8:	80 00       	ld.sh	r0,r0[0x0]
800065ba:	61 90       	ld.w	r0,r0[0x64]
800065bc:	80 00       	ld.sh	r0,r0[0x0]
800065be:	47 10       	lddsp	r0,sp[0x1c4]
800065c0:	80 00       	ld.sh	r0,r0[0x0]
800065c2:	47 d8       	lddsp	r8,sp[0x1f4]
800065c4:	80 00       	ld.sh	r0,r0[0x0]
800065c6:	3f c4       	mov	r4,-4
800065c8:	80 00       	ld.sh	r0,r0[0x0]
800065ca:	20 40       	sub	r0,4
800065cc:	80 00       	ld.sh	r0,r0[0x0]
800065ce:	47 9c       	lddsp	r12,sp[0x1e4]
800065d0:	80 00       	ld.sh	r0,r0[0x0]
800065d2:	5f b4       	srhi	r4

800065d4 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800065d4:	f8 08 16 05 	lsr	r8,r12,0x5
800065d8:	a9 68       	lsl	r8,0x8
800065da:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800065de:	58 1b       	cp.w	r11,1
800065e0:	c0 d0       	breq	800065fa <gpio_enable_module_pin+0x26>
800065e2:	c0 63       	brcs	800065ee <gpio_enable_module_pin+0x1a>
800065e4:	58 2b       	cp.w	r11,2
800065e6:	c1 00       	breq	80006606 <gpio_enable_module_pin+0x32>
800065e8:	58 3b       	cp.w	r11,3
800065ea:	c1 40       	breq	80006612 <gpio_enable_module_pin+0x3e>
800065ec:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800065ee:	30 19       	mov	r9,1
800065f0:	f2 0c 09 49 	lsl	r9,r9,r12
800065f4:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800065f6:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800065f8:	c1 28       	rjmp	8000661c <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800065fa:	30 19       	mov	r9,1
800065fc:	f2 0c 09 49 	lsl	r9,r9,r12
80006600:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006602:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006604:	c0 c8       	rjmp	8000661c <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006606:	30 19       	mov	r9,1
80006608:	f2 0c 09 49 	lsl	r9,r9,r12
8000660c:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000660e:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006610:	c0 68       	rjmp	8000661c <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006612:	30 19       	mov	r9,1
80006614:	f2 0c 09 49 	lsl	r9,r9,r12
80006618:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000661a:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000661c:	30 19       	mov	r9,1
8000661e:	f2 0c 09 4c 	lsl	r12,r9,r12
80006622:	91 2c       	st.w	r8[0x8],r12
80006624:	5e fd       	retal	0
80006626:	d7 03       	nop

80006628 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80006628:	d4 21       	pushm	r4-r7,lr
8000662a:	18 97       	mov	r7,r12
8000662c:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000662e:	58 0b       	cp.w	r11,0
80006630:	c0 31       	brne	80006636 <gpio_enable_module+0xe>
80006632:	30 05       	mov	r5,0
80006634:	c0 d8       	rjmp	8000664e <gpio_enable_module+0x26>
80006636:	30 06       	mov	r6,0
80006638:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000663a:	6e 1b       	ld.w	r11,r7[0x4]
8000663c:	6e 0c       	ld.w	r12,r7[0x0]
8000663e:	f0 1f 00 06 	mcall	80006654 <gpio_enable_module+0x2c>
80006642:	18 45       	or	r5,r12
		gpiomap++;
80006644:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006646:	2f f6       	sub	r6,-1
80006648:	0c 34       	cp.w	r4,r6
8000664a:	fe 9b ff f8 	brhi	8000663a <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000664e:	0a 9c       	mov	r12,r5
80006650:	d8 22       	popm	r4-r7,pc
80006652:	00 00       	add	r0,r0
80006654:	80 00       	ld.sh	r0,r0[0x0]
80006656:	65 d4       	ld.w	r4,r2[0x74]

80006658 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006658:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
8000665c:	fe c0 a6 5c 	sub	r0,pc,-22948

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006660:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006664:	d5 53       	csrf	0x15
  cp      r0, r1
80006666:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80006668:	e0 61 0a 38 	mov	r1,2616
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
8000666c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000666e:	c0 72       	brcc	8000667c <idata_load_loop_end>
  cp      r0, r1
80006670:	fe c2 8c d0 	sub	r2,pc,-29488

80006674 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006674:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
80006676:	a1 24       	st.d	r0++,r4
  cp      r0, r1
80006678:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
8000667a:	cf d3       	brcs	80006674 <idata_load_loop>

8000667c <idata_load_loop_end>:
  mov     r2, 0
8000667c:	e0 60 0a 38 	mov	r0,2616
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
80006680:	e0 61 41 00 	mov	r1,16640
  cp      r0, r1
  brlo    udata_clear_loop
80006684:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80006686:	c0 62       	brcc	80006692 <udata_clear_loop_end>
80006688:	30 02       	mov	r2,0
8000668a:	30 03       	mov	r3,0

8000668c <udata_clear_loop>:
8000668c:	a1 22       	st.d	r0++,r2
8000668e:	02 30       	cp.w	r0,r1
80006690:	cf e3       	brcs	8000668c <udata_clear_loop>

80006692 <udata_clear_loop_end>:
80006692:	fe cf 01 4a 	sub	pc,pc,330
80006696:	d7 03       	nop

80006698 <free>:
80006698:	d4 01       	pushm	lr
8000669a:	e0 68 0a 30 	mov	r8,2608
8000669e:	18 9b       	mov	r11,r12
800066a0:	70 0c       	ld.w	r12,r8[0x0]
800066a2:	e0 a0 1e 6d 	rcall	8000a37c <_free_r>
800066a6:	d8 02       	popm	pc

800066a8 <malloc>:
800066a8:	d4 01       	pushm	lr
800066aa:	e0 68 0a 30 	mov	r8,2608
800066ae:	18 9b       	mov	r11,r12
800066b0:	70 0c       	ld.w	r12,r8[0x0]
800066b2:	c0 3c       	rcall	800066b8 <_malloc_r>
800066b4:	d8 02       	popm	pc
800066b6:	d7 03       	nop

800066b8 <_malloc_r>:
800066b8:	d4 31       	pushm	r0-r7,lr
800066ba:	f6 c8 ff f5 	sub	r8,r11,-11
800066be:	18 95       	mov	r5,r12
800066c0:	10 97       	mov	r7,r8
800066c2:	e0 17 ff f8 	andl	r7,0xfff8
800066c6:	59 68       	cp.w	r8,22
800066c8:	f9 b7 08 10 	movls	r7,16
800066cc:	16 37       	cp.w	r7,r11
800066ce:	5f 38       	srlo	r8
800066d0:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800066d4:	c0 50       	breq	800066de <_malloc_r+0x26>
800066d6:	30 c8       	mov	r8,12
800066d8:	99 38       	st.w	r12[0xc],r8
800066da:	e0 8f 01 fa 	bral	80006ace <_malloc_r+0x416>
800066de:	fe b0 f5 59 	rcall	80005190 <__malloc_lock>
800066e2:	e0 47 01 f7 	cp.w	r7,503
800066e6:	e0 8b 00 1d 	brhi	80006720 <_malloc_r+0x68>
800066ea:	ee 03 16 03 	lsr	r3,r7,0x3
800066ee:	e0 68 05 30 	mov	r8,1328
800066f2:	f0 03 00 38 	add	r8,r8,r3<<0x3
800066f6:	70 36       	ld.w	r6,r8[0xc]
800066f8:	10 36       	cp.w	r6,r8
800066fa:	c0 61       	brne	80006706 <_malloc_r+0x4e>
800066fc:	ec c8 ff f8 	sub	r8,r6,-8
80006700:	70 36       	ld.w	r6,r8[0xc]
80006702:	10 36       	cp.w	r6,r8
80006704:	c0 c0       	breq	8000671c <_malloc_r+0x64>
80006706:	6c 18       	ld.w	r8,r6[0x4]
80006708:	e0 18 ff fc 	andl	r8,0xfffc
8000670c:	6c 3a       	ld.w	r10,r6[0xc]
8000670e:	ec 08 00 09 	add	r9,r6,r8
80006712:	0a 9c       	mov	r12,r5
80006714:	6c 28       	ld.w	r8,r6[0x8]
80006716:	95 28       	st.w	r10[0x8],r8
80006718:	91 3a       	st.w	r8[0xc],r10
8000671a:	c4 78       	rjmp	800067a8 <_malloc_r+0xf0>
8000671c:	2f e3       	sub	r3,-2
8000671e:	c4 d8       	rjmp	800067b8 <_malloc_r+0x100>
80006720:	ee 03 16 09 	lsr	r3,r7,0x9
80006724:	c0 41       	brne	8000672c <_malloc_r+0x74>
80006726:	ee 03 16 03 	lsr	r3,r7,0x3
8000672a:	c2 68       	rjmp	80006776 <_malloc_r+0xbe>
8000672c:	58 43       	cp.w	r3,4
8000672e:	e0 8b 00 06 	brhi	8000673a <_malloc_r+0x82>
80006732:	ee 03 16 06 	lsr	r3,r7,0x6
80006736:	2c 83       	sub	r3,-56
80006738:	c1 f8       	rjmp	80006776 <_malloc_r+0xbe>
8000673a:	59 43       	cp.w	r3,20
8000673c:	e0 8b 00 04 	brhi	80006744 <_malloc_r+0x8c>
80006740:	2a 53       	sub	r3,-91
80006742:	c1 a8       	rjmp	80006776 <_malloc_r+0xbe>
80006744:	e0 43 00 54 	cp.w	r3,84
80006748:	e0 8b 00 06 	brhi	80006754 <_malloc_r+0x9c>
8000674c:	ee 03 16 0c 	lsr	r3,r7,0xc
80006750:	29 23       	sub	r3,-110
80006752:	c1 28       	rjmp	80006776 <_malloc_r+0xbe>
80006754:	e0 43 01 54 	cp.w	r3,340
80006758:	e0 8b 00 06 	brhi	80006764 <_malloc_r+0xac>
8000675c:	ee 03 16 0f 	lsr	r3,r7,0xf
80006760:	28 93       	sub	r3,-119
80006762:	c0 a8       	rjmp	80006776 <_malloc_r+0xbe>
80006764:	e0 43 05 54 	cp.w	r3,1364
80006768:	e0 88 00 04 	brls	80006770 <_malloc_r+0xb8>
8000676c:	37 e3       	mov	r3,126
8000676e:	c0 48       	rjmp	80006776 <_malloc_r+0xbe>
80006770:	ee 03 16 12 	lsr	r3,r7,0x12
80006774:	28 43       	sub	r3,-124
80006776:	e0 6a 05 30 	mov	r10,1328
8000677a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000677e:	74 36       	ld.w	r6,r10[0xc]
80006780:	c1 98       	rjmp	800067b2 <_malloc_r+0xfa>
80006782:	6c 19       	ld.w	r9,r6[0x4]
80006784:	e0 19 ff fc 	andl	r9,0xfffc
80006788:	f2 07 01 0b 	sub	r11,r9,r7
8000678c:	58 fb       	cp.w	r11,15
8000678e:	e0 8a 00 04 	brle	80006796 <_malloc_r+0xde>
80006792:	20 13       	sub	r3,1
80006794:	c1 18       	rjmp	800067b6 <_malloc_r+0xfe>
80006796:	6c 38       	ld.w	r8,r6[0xc]
80006798:	58 0b       	cp.w	r11,0
8000679a:	c0 b5       	brlt	800067b0 <_malloc_r+0xf8>
8000679c:	6c 2a       	ld.w	r10,r6[0x8]
8000679e:	ec 09 00 09 	add	r9,r6,r9
800067a2:	0a 9c       	mov	r12,r5
800067a4:	91 2a       	st.w	r8[0x8],r10
800067a6:	95 38       	st.w	r10[0xc],r8
800067a8:	72 18       	ld.w	r8,r9[0x4]
800067aa:	a1 a8       	sbr	r8,0x0
800067ac:	93 18       	st.w	r9[0x4],r8
800067ae:	cb c8       	rjmp	80006926 <_malloc_r+0x26e>
800067b0:	10 96       	mov	r6,r8
800067b2:	14 36       	cp.w	r6,r10
800067b4:	ce 71       	brne	80006782 <_malloc_r+0xca>
800067b6:	2f f3       	sub	r3,-1
800067b8:	e0 6a 05 30 	mov	r10,1328
800067bc:	f4 cc ff f8 	sub	r12,r10,-8
800067c0:	78 26       	ld.w	r6,r12[0x8]
800067c2:	18 36       	cp.w	r6,r12
800067c4:	c6 c0       	breq	8000689c <_malloc_r+0x1e4>
800067c6:	6c 19       	ld.w	r9,r6[0x4]
800067c8:	e0 19 ff fc 	andl	r9,0xfffc
800067cc:	f2 07 01 08 	sub	r8,r9,r7
800067d0:	58 f8       	cp.w	r8,15
800067d2:	e0 89 00 8f 	brgt	800068f0 <_malloc_r+0x238>
800067d6:	99 3c       	st.w	r12[0xc],r12
800067d8:	99 2c       	st.w	r12[0x8],r12
800067da:	58 08       	cp.w	r8,0
800067dc:	c0 55       	brlt	800067e6 <_malloc_r+0x12e>
800067de:	ec 09 00 09 	add	r9,r6,r9
800067e2:	0a 9c       	mov	r12,r5
800067e4:	ce 2b       	rjmp	800067a8 <_malloc_r+0xf0>
800067e6:	e0 49 01 ff 	cp.w	r9,511
800067ea:	e0 8b 00 13 	brhi	80006810 <_malloc_r+0x158>
800067ee:	a3 99       	lsr	r9,0x3
800067f0:	f4 09 00 38 	add	r8,r10,r9<<0x3
800067f4:	70 2b       	ld.w	r11,r8[0x8]
800067f6:	8d 38       	st.w	r6[0xc],r8
800067f8:	8d 2b       	st.w	r6[0x8],r11
800067fa:	97 36       	st.w	r11[0xc],r6
800067fc:	91 26       	st.w	r8[0x8],r6
800067fe:	a3 49       	asr	r9,0x2
80006800:	74 18       	ld.w	r8,r10[0x4]
80006802:	30 1b       	mov	r11,1
80006804:	f6 09 09 49 	lsl	r9,r11,r9
80006808:	f1 e9 10 09 	or	r9,r8,r9
8000680c:	95 19       	st.w	r10[0x4],r9
8000680e:	c4 78       	rjmp	8000689c <_malloc_r+0x1e4>
80006810:	f2 0a 16 09 	lsr	r10,r9,0x9
80006814:	58 4a       	cp.w	r10,4
80006816:	e0 8b 00 07 	brhi	80006824 <_malloc_r+0x16c>
8000681a:	f2 0a 16 06 	lsr	r10,r9,0x6
8000681e:	2c 8a       	sub	r10,-56
80006820:	c2 08       	rjmp	80006860 <_malloc_r+0x1a8>
80006822:	d7 03       	nop
80006824:	59 4a       	cp.w	r10,20
80006826:	e0 8b 00 04 	brhi	8000682e <_malloc_r+0x176>
8000682a:	2a 5a       	sub	r10,-91
8000682c:	c1 a8       	rjmp	80006860 <_malloc_r+0x1a8>
8000682e:	e0 4a 00 54 	cp.w	r10,84
80006832:	e0 8b 00 06 	brhi	8000683e <_malloc_r+0x186>
80006836:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000683a:	29 2a       	sub	r10,-110
8000683c:	c1 28       	rjmp	80006860 <_malloc_r+0x1a8>
8000683e:	e0 4a 01 54 	cp.w	r10,340
80006842:	e0 8b 00 06 	brhi	8000684e <_malloc_r+0x196>
80006846:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000684a:	28 9a       	sub	r10,-119
8000684c:	c0 a8       	rjmp	80006860 <_malloc_r+0x1a8>
8000684e:	e0 4a 05 54 	cp.w	r10,1364
80006852:	e0 88 00 04 	brls	8000685a <_malloc_r+0x1a2>
80006856:	37 ea       	mov	r10,126
80006858:	c0 48       	rjmp	80006860 <_malloc_r+0x1a8>
8000685a:	f2 0a 16 12 	lsr	r10,r9,0x12
8000685e:	28 4a       	sub	r10,-124
80006860:	e0 6b 05 30 	mov	r11,1328
80006864:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006868:	68 28       	ld.w	r8,r4[0x8]
8000686a:	08 38       	cp.w	r8,r4
8000686c:	c0 e1       	brne	80006888 <_malloc_r+0x1d0>
8000686e:	76 19       	ld.w	r9,r11[0x4]
80006870:	a3 4a       	asr	r10,0x2
80006872:	30 1e       	mov	lr,1
80006874:	fc 0a 09 4a 	lsl	r10,lr,r10
80006878:	f3 ea 10 0a 	or	r10,r9,r10
8000687c:	10 99       	mov	r9,r8
8000687e:	97 1a       	st.w	r11[0x4],r10
80006880:	c0 a8       	rjmp	80006894 <_malloc_r+0x1dc>
80006882:	70 28       	ld.w	r8,r8[0x8]
80006884:	08 38       	cp.w	r8,r4
80006886:	c0 60       	breq	80006892 <_malloc_r+0x1da>
80006888:	70 1a       	ld.w	r10,r8[0x4]
8000688a:	e0 1a ff fc 	andl	r10,0xfffc
8000688e:	14 39       	cp.w	r9,r10
80006890:	cf 93       	brcs	80006882 <_malloc_r+0x1ca>
80006892:	70 39       	ld.w	r9,r8[0xc]
80006894:	8d 39       	st.w	r6[0xc],r9
80006896:	8d 28       	st.w	r6[0x8],r8
80006898:	91 36       	st.w	r8[0xc],r6
8000689a:	93 26       	st.w	r9[0x8],r6
8000689c:	e6 08 14 02 	asr	r8,r3,0x2
800068a0:	30 1b       	mov	r11,1
800068a2:	e0 64 05 30 	mov	r4,1328
800068a6:	f6 08 09 4b 	lsl	r11,r11,r8
800068aa:	68 18       	ld.w	r8,r4[0x4]
800068ac:	10 3b       	cp.w	r11,r8
800068ae:	e0 8b 00 6b 	brhi	80006984 <_malloc_r+0x2cc>
800068b2:	f7 e8 00 09 	and	r9,r11,r8
800068b6:	c0 b1       	brne	800068cc <_malloc_r+0x214>
800068b8:	e0 13 ff fc 	andl	r3,0xfffc
800068bc:	a1 7b       	lsl	r11,0x1
800068be:	2f c3       	sub	r3,-4
800068c0:	c0 38       	rjmp	800068c6 <_malloc_r+0x20e>
800068c2:	2f c3       	sub	r3,-4
800068c4:	a1 7b       	lsl	r11,0x1
800068c6:	f7 e8 00 09 	and	r9,r11,r8
800068ca:	cf c0       	breq	800068c2 <_malloc_r+0x20a>
800068cc:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800068d0:	06 92       	mov	r2,r3
800068d2:	1c 91       	mov	r1,lr
800068d4:	62 36       	ld.w	r6,r1[0xc]
800068d6:	c2 e8       	rjmp	80006932 <_malloc_r+0x27a>
800068d8:	6c 1a       	ld.w	r10,r6[0x4]
800068da:	e0 1a ff fc 	andl	r10,0xfffc
800068de:	f4 07 01 08 	sub	r8,r10,r7
800068e2:	58 f8       	cp.w	r8,15
800068e4:	e0 8a 00 15 	brle	8000690e <_malloc_r+0x256>
800068e8:	6c 3a       	ld.w	r10,r6[0xc]
800068ea:	6c 29       	ld.w	r9,r6[0x8]
800068ec:	95 29       	st.w	r10[0x8],r9
800068ee:	93 3a       	st.w	r9[0xc],r10
800068f0:	0e 99       	mov	r9,r7
800068f2:	ec 07 00 07 	add	r7,r6,r7
800068f6:	a1 a9       	sbr	r9,0x0
800068f8:	99 37       	st.w	r12[0xc],r7
800068fa:	99 27       	st.w	r12[0x8],r7
800068fc:	8d 19       	st.w	r6[0x4],r9
800068fe:	ee 08 09 08 	st.w	r7[r8],r8
80006902:	8f 2c       	st.w	r7[0x8],r12
80006904:	8f 3c       	st.w	r7[0xc],r12
80006906:	a1 a8       	sbr	r8,0x0
80006908:	0a 9c       	mov	r12,r5
8000690a:	8f 18       	st.w	r7[0x4],r8
8000690c:	c0 d8       	rjmp	80006926 <_malloc_r+0x26e>
8000690e:	6c 39       	ld.w	r9,r6[0xc]
80006910:	58 08       	cp.w	r8,0
80006912:	c0 f5       	brlt	80006930 <_malloc_r+0x278>
80006914:	ec 0a 00 0a 	add	r10,r6,r10
80006918:	74 18       	ld.w	r8,r10[0x4]
8000691a:	a1 a8       	sbr	r8,0x0
8000691c:	0a 9c       	mov	r12,r5
8000691e:	95 18       	st.w	r10[0x4],r8
80006920:	6c 28       	ld.w	r8,r6[0x8]
80006922:	93 28       	st.w	r9[0x8],r8
80006924:	91 39       	st.w	r8[0xc],r9
80006926:	fe b0 f4 3b 	rcall	8000519c <__malloc_unlock>
8000692a:	ec cc ff f8 	sub	r12,r6,-8
8000692e:	d8 32       	popm	r0-r7,pc
80006930:	12 96       	mov	r6,r9
80006932:	02 36       	cp.w	r6,r1
80006934:	cd 21       	brne	800068d8 <_malloc_r+0x220>
80006936:	2f f2       	sub	r2,-1
80006938:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000693c:	c0 30       	breq	80006942 <_malloc_r+0x28a>
8000693e:	2f 81       	sub	r1,-8
80006940:	cc ab       	rjmp	800068d4 <_malloc_r+0x21c>
80006942:	1c 98       	mov	r8,lr
80006944:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006948:	c0 81       	brne	80006958 <_malloc_r+0x2a0>
8000694a:	68 19       	ld.w	r9,r4[0x4]
8000694c:	f6 08 11 ff 	rsub	r8,r11,-1
80006950:	f3 e8 00 08 	and	r8,r9,r8
80006954:	89 18       	st.w	r4[0x4],r8
80006956:	c0 78       	rjmp	80006964 <_malloc_r+0x2ac>
80006958:	f0 c9 00 08 	sub	r9,r8,8
8000695c:	20 13       	sub	r3,1
8000695e:	70 08       	ld.w	r8,r8[0x0]
80006960:	12 38       	cp.w	r8,r9
80006962:	cf 10       	breq	80006944 <_malloc_r+0x28c>
80006964:	a1 7b       	lsl	r11,0x1
80006966:	68 18       	ld.w	r8,r4[0x4]
80006968:	10 3b       	cp.w	r11,r8
8000696a:	e0 8b 00 0d 	brhi	80006984 <_malloc_r+0x2cc>
8000696e:	58 0b       	cp.w	r11,0
80006970:	c0 a0       	breq	80006984 <_malloc_r+0x2cc>
80006972:	04 93       	mov	r3,r2
80006974:	c0 38       	rjmp	8000697a <_malloc_r+0x2c2>
80006976:	2f c3       	sub	r3,-4
80006978:	a1 7b       	lsl	r11,0x1
8000697a:	f7 e8 00 09 	and	r9,r11,r8
8000697e:	ca 71       	brne	800068cc <_malloc_r+0x214>
80006980:	cf bb       	rjmp	80006976 <_malloc_r+0x2be>
80006982:	d7 03       	nop
80006984:	68 23       	ld.w	r3,r4[0x8]
80006986:	66 12       	ld.w	r2,r3[0x4]
80006988:	e0 12 ff fc 	andl	r2,0xfffc
8000698c:	0e 32       	cp.w	r2,r7
8000698e:	5f 39       	srlo	r9
80006990:	e4 07 01 08 	sub	r8,r2,r7
80006994:	58 f8       	cp.w	r8,15
80006996:	5f aa       	srle	r10
80006998:	f5 e9 10 09 	or	r9,r10,r9
8000699c:	e0 80 00 9a 	breq	80006ad0 <_malloc_r+0x418>
800069a0:	e0 68 0d 60 	mov	r8,3424
800069a4:	70 01       	ld.w	r1,r8[0x0]
800069a6:	e0 68 09 3c 	mov	r8,2364
800069aa:	2f 01       	sub	r1,-16
800069ac:	70 08       	ld.w	r8,r8[0x0]
800069ae:	0e 01       	add	r1,r7
800069b0:	5b f8       	cp.w	r8,-1
800069b2:	c0 40       	breq	800069ba <_malloc_r+0x302>
800069b4:	28 11       	sub	r1,-127
800069b6:	e0 11 ff 80 	andl	r1,0xff80
800069ba:	02 9b       	mov	r11,r1
800069bc:	0a 9c       	mov	r12,r5
800069be:	e0 a0 02 a5 	rcall	80006f08 <_sbrk_r>
800069c2:	18 96       	mov	r6,r12
800069c4:	5b fc       	cp.w	r12,-1
800069c6:	c7 50       	breq	80006ab0 <_malloc_r+0x3f8>
800069c8:	e6 02 00 08 	add	r8,r3,r2
800069cc:	10 3c       	cp.w	r12,r8
800069ce:	c0 32       	brcc	800069d4 <_malloc_r+0x31c>
800069d0:	08 33       	cp.w	r3,r4
800069d2:	c6 f1       	brne	80006ab0 <_malloc_r+0x3f8>
800069d4:	e0 6a 0d 64 	mov	r10,3428
800069d8:	74 09       	ld.w	r9,r10[0x0]
800069da:	e2 09 00 09 	add	r9,r1,r9
800069de:	95 09       	st.w	r10[0x0],r9
800069e0:	10 36       	cp.w	r6,r8
800069e2:	c0 a1       	brne	800069f6 <_malloc_r+0x33e>
800069e4:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800069e8:	c0 71       	brne	800069f6 <_malloc_r+0x33e>
800069ea:	e2 02 00 02 	add	r2,r1,r2
800069ee:	68 28       	ld.w	r8,r4[0x8]
800069f0:	a1 a2       	sbr	r2,0x0
800069f2:	91 12       	st.w	r8[0x4],r2
800069f4:	c4 f8       	rjmp	80006a92 <_malloc_r+0x3da>
800069f6:	e0 6a 09 3c 	mov	r10,2364
800069fa:	74 0b       	ld.w	r11,r10[0x0]
800069fc:	5b fb       	cp.w	r11,-1
800069fe:	c0 31       	brne	80006a04 <_malloc_r+0x34c>
80006a00:	95 06       	st.w	r10[0x0],r6
80006a02:	c0 78       	rjmp	80006a10 <_malloc_r+0x358>
80006a04:	ec 09 00 09 	add	r9,r6,r9
80006a08:	e0 6a 0d 64 	mov	r10,3428
80006a0c:	10 19       	sub	r9,r8
80006a0e:	95 09       	st.w	r10[0x0],r9
80006a10:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006a14:	f0 09 11 08 	rsub	r9,r8,8
80006a18:	58 08       	cp.w	r8,0
80006a1a:	f2 08 17 10 	movne	r8,r9
80006a1e:	ed d8 e1 06 	addne	r6,r6,r8
80006a22:	28 08       	sub	r8,-128
80006a24:	ec 01 00 01 	add	r1,r6,r1
80006a28:	0a 9c       	mov	r12,r5
80006a2a:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006a2e:	f0 01 01 01 	sub	r1,r8,r1
80006a32:	02 9b       	mov	r11,r1
80006a34:	e0 a0 02 6a 	rcall	80006f08 <_sbrk_r>
80006a38:	e0 68 0d 64 	mov	r8,3428
80006a3c:	5b fc       	cp.w	r12,-1
80006a3e:	ec 0c 17 00 	moveq	r12,r6
80006a42:	f9 b1 00 00 	moveq	r1,0
80006a46:	70 09       	ld.w	r9,r8[0x0]
80006a48:	0c 1c       	sub	r12,r6
80006a4a:	89 26       	st.w	r4[0x8],r6
80006a4c:	02 0c       	add	r12,r1
80006a4e:	12 01       	add	r1,r9
80006a50:	a1 ac       	sbr	r12,0x0
80006a52:	91 01       	st.w	r8[0x0],r1
80006a54:	8d 1c       	st.w	r6[0x4],r12
80006a56:	08 33       	cp.w	r3,r4
80006a58:	c1 d0       	breq	80006a92 <_malloc_r+0x3da>
80006a5a:	58 f2       	cp.w	r2,15
80006a5c:	e0 8b 00 05 	brhi	80006a66 <_malloc_r+0x3ae>
80006a60:	30 18       	mov	r8,1
80006a62:	8d 18       	st.w	r6[0x4],r8
80006a64:	c2 68       	rjmp	80006ab0 <_malloc_r+0x3f8>
80006a66:	30 59       	mov	r9,5
80006a68:	20 c2       	sub	r2,12
80006a6a:	e0 12 ff f8 	andl	r2,0xfff8
80006a6e:	e6 02 00 08 	add	r8,r3,r2
80006a72:	91 29       	st.w	r8[0x8],r9
80006a74:	91 19       	st.w	r8[0x4],r9
80006a76:	66 18       	ld.w	r8,r3[0x4]
80006a78:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006a7c:	e5 e8 10 08 	or	r8,r2,r8
80006a80:	87 18       	st.w	r3[0x4],r8
80006a82:	58 f2       	cp.w	r2,15
80006a84:	e0 88 00 07 	brls	80006a92 <_malloc_r+0x3da>
80006a88:	e6 cb ff f8 	sub	r11,r3,-8
80006a8c:	0a 9c       	mov	r12,r5
80006a8e:	e0 a0 1c 77 	rcall	8000a37c <_free_r>
80006a92:	e0 69 0d 5c 	mov	r9,3420
80006a96:	72 0a       	ld.w	r10,r9[0x0]
80006a98:	e0 68 0d 64 	mov	r8,3428
80006a9c:	70 08       	ld.w	r8,r8[0x0]
80006a9e:	14 38       	cp.w	r8,r10
80006aa0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006aa4:	e0 69 0d 58 	mov	r9,3416
80006aa8:	72 0a       	ld.w	r10,r9[0x0]
80006aaa:	14 38       	cp.w	r8,r10
80006aac:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006ab0:	68 28       	ld.w	r8,r4[0x8]
80006ab2:	70 18       	ld.w	r8,r8[0x4]
80006ab4:	e0 18 ff fc 	andl	r8,0xfffc
80006ab8:	0e 38       	cp.w	r8,r7
80006aba:	5f 39       	srlo	r9
80006abc:	0e 18       	sub	r8,r7
80006abe:	58 f8       	cp.w	r8,15
80006ac0:	5f aa       	srle	r10
80006ac2:	f5 e9 10 09 	or	r9,r10,r9
80006ac6:	c0 50       	breq	80006ad0 <_malloc_r+0x418>
80006ac8:	0a 9c       	mov	r12,r5
80006aca:	fe b0 f3 69 	rcall	8000519c <__malloc_unlock>
80006ace:	d8 3a       	popm	r0-r7,pc,r12=0
80006ad0:	68 26       	ld.w	r6,r4[0x8]
80006ad2:	a1 a8       	sbr	r8,0x0
80006ad4:	0e 99       	mov	r9,r7
80006ad6:	a1 a9       	sbr	r9,0x0
80006ad8:	8d 19       	st.w	r6[0x4],r9
80006ada:	ec 07 00 07 	add	r7,r6,r7
80006ade:	0a 9c       	mov	r12,r5
80006ae0:	89 27       	st.w	r4[0x8],r7
80006ae2:	8f 18       	st.w	r7[0x4],r8
80006ae4:	fe b0 f3 5c 	rcall	8000519c <__malloc_unlock>
80006ae8:	ec cc ff f8 	sub	r12,r6,-8
80006aec:	d8 32       	popm	r0-r7,pc
80006aee:	d7 03       	nop

80006af0 <memcpy>:
80006af0:	58 8a       	cp.w	r10,8
80006af2:	c2 f5       	brlt	80006b50 <memcpy+0x60>
80006af4:	f9 eb 10 09 	or	r9,r12,r11
80006af8:	e2 19 00 03 	andl	r9,0x3,COH
80006afc:	e0 81 00 97 	brne	80006c2a <memcpy+0x13a>
80006b00:	e0 4a 00 20 	cp.w	r10,32
80006b04:	c3 b4       	brge	80006b7a <memcpy+0x8a>
80006b06:	f4 08 14 02 	asr	r8,r10,0x2
80006b0a:	f0 09 11 08 	rsub	r9,r8,8
80006b0e:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80006b12:	76 69       	ld.w	r9,r11[0x18]
80006b14:	99 69       	st.w	r12[0x18],r9
80006b16:	76 59       	ld.w	r9,r11[0x14]
80006b18:	99 59       	st.w	r12[0x14],r9
80006b1a:	76 49       	ld.w	r9,r11[0x10]
80006b1c:	99 49       	st.w	r12[0x10],r9
80006b1e:	76 39       	ld.w	r9,r11[0xc]
80006b20:	99 39       	st.w	r12[0xc],r9
80006b22:	76 29       	ld.w	r9,r11[0x8]
80006b24:	99 29       	st.w	r12[0x8],r9
80006b26:	76 19       	ld.w	r9,r11[0x4]
80006b28:	99 19       	st.w	r12[0x4],r9
80006b2a:	76 09       	ld.w	r9,r11[0x0]
80006b2c:	99 09       	st.w	r12[0x0],r9
80006b2e:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80006b32:	f8 08 00 28 	add	r8,r12,r8<<0x2
80006b36:	e0 1a 00 03 	andl	r10,0x3
80006b3a:	f4 0a 11 04 	rsub	r10,r10,4
80006b3e:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006b42:	17 a9       	ld.ub	r9,r11[0x2]
80006b44:	b0 a9       	st.b	r8[0x2],r9
80006b46:	17 99       	ld.ub	r9,r11[0x1]
80006b48:	b0 99       	st.b	r8[0x1],r9
80006b4a:	17 89       	ld.ub	r9,r11[0x0]
80006b4c:	b0 89       	st.b	r8[0x0],r9
80006b4e:	5e fc       	retal	r12
80006b50:	f4 0a 11 09 	rsub	r10,r10,9
80006b54:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006b58:	17 f9       	ld.ub	r9,r11[0x7]
80006b5a:	b8 f9       	st.b	r12[0x7],r9
80006b5c:	17 e9       	ld.ub	r9,r11[0x6]
80006b5e:	b8 e9       	st.b	r12[0x6],r9
80006b60:	17 d9       	ld.ub	r9,r11[0x5]
80006b62:	b8 d9       	st.b	r12[0x5],r9
80006b64:	17 c9       	ld.ub	r9,r11[0x4]
80006b66:	b8 c9       	st.b	r12[0x4],r9
80006b68:	17 b9       	ld.ub	r9,r11[0x3]
80006b6a:	b8 b9       	st.b	r12[0x3],r9
80006b6c:	17 a9       	ld.ub	r9,r11[0x2]
80006b6e:	b8 a9       	st.b	r12[0x2],r9
80006b70:	17 99       	ld.ub	r9,r11[0x1]
80006b72:	b8 99       	st.b	r12[0x1],r9
80006b74:	17 89       	ld.ub	r9,r11[0x0]
80006b76:	b8 89       	st.b	r12[0x0],r9
80006b78:	5e fc       	retal	r12
80006b7a:	eb cd 40 c0 	pushm	r6-r7,lr
80006b7e:	18 99       	mov	r9,r12
80006b80:	22 0a       	sub	r10,32
80006b82:	b7 07       	ld.d	r6,r11++
80006b84:	b3 26       	st.d	r9++,r6
80006b86:	b7 07       	ld.d	r6,r11++
80006b88:	b3 26       	st.d	r9++,r6
80006b8a:	b7 07       	ld.d	r6,r11++
80006b8c:	b3 26       	st.d	r9++,r6
80006b8e:	b7 07       	ld.d	r6,r11++
80006b90:	b3 26       	st.d	r9++,r6
80006b92:	22 0a       	sub	r10,32
80006b94:	cf 74       	brge	80006b82 <memcpy+0x92>
80006b96:	2f 0a       	sub	r10,-16
80006b98:	c0 65       	brlt	80006ba4 <memcpy+0xb4>
80006b9a:	b7 07       	ld.d	r6,r11++
80006b9c:	b3 26       	st.d	r9++,r6
80006b9e:	b7 07       	ld.d	r6,r11++
80006ba0:	b3 26       	st.d	r9++,r6
80006ba2:	21 0a       	sub	r10,16
80006ba4:	5c 3a       	neg	r10
80006ba6:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80006baa:	d7 03       	nop
80006bac:	d7 03       	nop
80006bae:	f7 36 00 0e 	ld.ub	r6,r11[14]
80006bb2:	f3 66 00 0e 	st.b	r9[14],r6
80006bb6:	f7 36 00 0d 	ld.ub	r6,r11[13]
80006bba:	f3 66 00 0d 	st.b	r9[13],r6
80006bbe:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006bc2:	f3 66 00 0c 	st.b	r9[12],r6
80006bc6:	f7 36 00 0b 	ld.ub	r6,r11[11]
80006bca:	f3 66 00 0b 	st.b	r9[11],r6
80006bce:	f7 36 00 0a 	ld.ub	r6,r11[10]
80006bd2:	f3 66 00 0a 	st.b	r9[10],r6
80006bd6:	f7 36 00 09 	ld.ub	r6,r11[9]
80006bda:	f3 66 00 09 	st.b	r9[9],r6
80006bde:	f7 36 00 08 	ld.ub	r6,r11[8]
80006be2:	f3 66 00 08 	st.b	r9[8],r6
80006be6:	f7 36 00 07 	ld.ub	r6,r11[7]
80006bea:	f3 66 00 07 	st.b	r9[7],r6
80006bee:	f7 36 00 06 	ld.ub	r6,r11[6]
80006bf2:	f3 66 00 06 	st.b	r9[6],r6
80006bf6:	f7 36 00 05 	ld.ub	r6,r11[5]
80006bfa:	f3 66 00 05 	st.b	r9[5],r6
80006bfe:	f7 36 00 04 	ld.ub	r6,r11[4]
80006c02:	f3 66 00 04 	st.b	r9[4],r6
80006c06:	f7 36 00 03 	ld.ub	r6,r11[3]
80006c0a:	f3 66 00 03 	st.b	r9[3],r6
80006c0e:	f7 36 00 02 	ld.ub	r6,r11[2]
80006c12:	f3 66 00 02 	st.b	r9[2],r6
80006c16:	f7 36 00 01 	ld.ub	r6,r11[1]
80006c1a:	f3 66 00 01 	st.b	r9[1],r6
80006c1e:	f7 36 00 00 	ld.ub	r6,r11[0]
80006c22:	f3 66 00 00 	st.b	r9[0],r6
80006c26:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006c2a:	20 1a       	sub	r10,1
80006c2c:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006c30:	f8 0a 0b 09 	st.b	r12[r10],r9
80006c34:	cf b1       	brne	80006c2a <memcpy+0x13a>
80006c36:	5e fc       	retal	r12

80006c38 <memset>:
80006c38:	18 98       	mov	r8,r12
80006c3a:	c0 38       	rjmp	80006c40 <memset+0x8>
80006c3c:	10 cb       	st.b	r8++,r11
80006c3e:	20 1a       	sub	r10,1
80006c40:	58 0a       	cp.w	r10,0
80006c42:	cf d1       	brne	80006c3c <memset+0x4>
80006c44:	5e fc       	retal	r12
80006c46:	d7 03       	nop

80006c48 <_realloc_r>:
80006c48:	d4 31       	pushm	r0-r7,lr
80006c4a:	20 1d       	sub	sp,4
80006c4c:	16 94       	mov	r4,r11
80006c4e:	18 92       	mov	r2,r12
80006c50:	14 9b       	mov	r11,r10
80006c52:	58 04       	cp.w	r4,0
80006c54:	c0 51       	brne	80006c5e <_realloc_r+0x16>
80006c56:	fe b0 fd 31 	rcall	800066b8 <_malloc_r>
80006c5a:	18 95       	mov	r5,r12
80006c5c:	c5 39       	rjmp	80006f02 <_realloc_r+0x2ba>
80006c5e:	50 0a       	stdsp	sp[0x0],r10
80006c60:	fe b0 f2 98 	rcall	80005190 <__malloc_lock>
80006c64:	40 0b       	lddsp	r11,sp[0x0]
80006c66:	f6 c8 ff f5 	sub	r8,r11,-11
80006c6a:	e8 c1 00 08 	sub	r1,r4,8
80006c6e:	10 96       	mov	r6,r8
80006c70:	62 1c       	ld.w	r12,r1[0x4]
80006c72:	e0 16 ff f8 	andl	r6,0xfff8
80006c76:	59 68       	cp.w	r8,22
80006c78:	f9 b6 08 10 	movls	r6,16
80006c7c:	16 36       	cp.w	r6,r11
80006c7e:	5f 38       	srlo	r8
80006c80:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80006c84:	c0 50       	breq	80006c8e <_realloc_r+0x46>
80006c86:	30 c8       	mov	r8,12
80006c88:	30 05       	mov	r5,0
80006c8a:	85 38       	st.w	r2[0xc],r8
80006c8c:	c3 b9       	rjmp	80006f02 <_realloc_r+0x2ba>
80006c8e:	18 90       	mov	r0,r12
80006c90:	e0 10 ff fc 	andl	r0,0xfffc
80006c94:	0c 30       	cp.w	r0,r6
80006c96:	e0 84 01 0b 	brge	80006eac <_realloc_r+0x264>
80006c9a:	e0 68 05 30 	mov	r8,1328
80006c9e:	e2 00 00 09 	add	r9,r1,r0
80006ca2:	70 25       	ld.w	r5,r8[0x8]
80006ca4:	0a 39       	cp.w	r9,r5
80006ca6:	c0 90       	breq	80006cb8 <_realloc_r+0x70>
80006ca8:	72 1a       	ld.w	r10,r9[0x4]
80006caa:	a1 ca       	cbr	r10,0x0
80006cac:	f2 0a 00 0a 	add	r10,r9,r10
80006cb0:	74 1a       	ld.w	r10,r10[0x4]
80006cb2:	ed ba 00 00 	bld	r10,0x0
80006cb6:	c2 20       	breq	80006cfa <_realloc_r+0xb2>
80006cb8:	72 1a       	ld.w	r10,r9[0x4]
80006cba:	e0 1a ff fc 	andl	r10,0xfffc
80006cbe:	f4 00 00 03 	add	r3,r10,r0
80006cc2:	0a 39       	cp.w	r9,r5
80006cc4:	c1 31       	brne	80006cea <_realloc_r+0xa2>
80006cc6:	ec c7 ff f0 	sub	r7,r6,-16
80006cca:	0e 33       	cp.w	r3,r7
80006ccc:	c1 95       	brlt	80006cfe <_realloc_r+0xb6>
80006cce:	e2 06 00 09 	add	r9,r1,r6
80006cd2:	0c 13       	sub	r3,r6
80006cd4:	a1 a3       	sbr	r3,0x0
80006cd6:	93 13       	st.w	r9[0x4],r3
80006cd8:	91 29       	st.w	r8[0x8],r9
80006cda:	04 9c       	mov	r12,r2
80006cdc:	62 18       	ld.w	r8,r1[0x4]
80006cde:	08 95       	mov	r5,r4
80006ce0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006ce4:	10 46       	or	r6,r8
80006ce6:	83 16       	st.w	r1[0x4],r6
80006ce8:	c0 b9       	rjmp	80006efe <_realloc_r+0x2b6>
80006cea:	0c 33       	cp.w	r3,r6
80006cec:	c0 95       	brlt	80006cfe <_realloc_r+0xb6>
80006cee:	72 28       	ld.w	r8,r9[0x8]
80006cf0:	02 97       	mov	r7,r1
80006cf2:	72 39       	ld.w	r9,r9[0xc]
80006cf4:	93 28       	st.w	r9[0x8],r8
80006cf6:	91 39       	st.w	r8[0xc],r9
80006cf8:	cd c8       	rjmp	80006eb0 <_realloc_r+0x268>
80006cfa:	30 0a       	mov	r10,0
80006cfc:	14 99       	mov	r9,r10
80006cfe:	ed bc 00 00 	bld	r12,0x0
80006d02:	e0 80 00 95 	breq	80006e2c <_realloc_r+0x1e4>
80006d06:	62 07       	ld.w	r7,r1[0x0]
80006d08:	e2 07 01 07 	sub	r7,r1,r7
80006d0c:	6e 1c       	ld.w	r12,r7[0x4]
80006d0e:	e0 1c ff fc 	andl	r12,0xfffc
80006d12:	58 09       	cp.w	r9,0
80006d14:	c5 60       	breq	80006dc0 <_realloc_r+0x178>
80006d16:	f8 00 00 03 	add	r3,r12,r0
80006d1a:	0a 39       	cp.w	r9,r5
80006d1c:	c4 81       	brne	80006dac <_realloc_r+0x164>
80006d1e:	14 03       	add	r3,r10
80006d20:	ec c9 ff f0 	sub	r9,r6,-16
80006d24:	12 33       	cp.w	r3,r9
80006d26:	c4 d5       	brlt	80006dc0 <_realloc_r+0x178>
80006d28:	6e 3a       	ld.w	r10,r7[0xc]
80006d2a:	6e 29       	ld.w	r9,r7[0x8]
80006d2c:	95 29       	st.w	r10[0x8],r9
80006d2e:	93 3a       	st.w	r9[0xc],r10
80006d30:	ee c5 ff f8 	sub	r5,r7,-8
80006d34:	e0 ca 00 04 	sub	r10,r0,4
80006d38:	e0 4a 00 24 	cp.w	r10,36
80006d3c:	e0 8b 00 25 	brhi	80006d86 <_realloc_r+0x13e>
80006d40:	0a 99       	mov	r9,r5
80006d42:	59 3a       	cp.w	r10,19
80006d44:	e0 88 00 1a 	brls	80006d78 <_realloc_r+0x130>
80006d48:	09 09       	ld.w	r9,r4++
80006d4a:	8b 09       	st.w	r5[0x0],r9
80006d4c:	09 09       	ld.w	r9,r4++
80006d4e:	8f 39       	st.w	r7[0xc],r9
80006d50:	ee c9 ff f0 	sub	r9,r7,-16
80006d54:	59 ba       	cp.w	r10,27
80006d56:	e0 88 00 11 	brls	80006d78 <_realloc_r+0x130>
80006d5a:	09 0b       	ld.w	r11,r4++
80006d5c:	93 0b       	st.w	r9[0x0],r11
80006d5e:	09 09       	ld.w	r9,r4++
80006d60:	8f 59       	st.w	r7[0x14],r9
80006d62:	ee c9 ff e8 	sub	r9,r7,-24
80006d66:	e0 4a 00 24 	cp.w	r10,36
80006d6a:	c0 71       	brne	80006d78 <_realloc_r+0x130>
80006d6c:	09 0a       	ld.w	r10,r4++
80006d6e:	93 0a       	st.w	r9[0x0],r10
80006d70:	ee c9 ff e0 	sub	r9,r7,-32
80006d74:	09 0a       	ld.w	r10,r4++
80006d76:	8f 7a       	st.w	r7[0x1c],r10
80006d78:	09 0a       	ld.w	r10,r4++
80006d7a:	12 aa       	st.w	r9++,r10
80006d7c:	68 0a       	ld.w	r10,r4[0x0]
80006d7e:	93 0a       	st.w	r9[0x0],r10
80006d80:	68 1a       	ld.w	r10,r4[0x4]
80006d82:	93 1a       	st.w	r9[0x4],r10
80006d84:	c0 78       	rjmp	80006d92 <_realloc_r+0x14a>
80006d86:	50 08       	stdsp	sp[0x0],r8
80006d88:	08 9b       	mov	r11,r4
80006d8a:	0a 9c       	mov	r12,r5
80006d8c:	e0 a0 1d 9b 	rcall	8000a8c2 <memmove>
80006d90:	40 08       	lddsp	r8,sp[0x0]
80006d92:	ee 06 00 09 	add	r9,r7,r6
80006d96:	0c 13       	sub	r3,r6
80006d98:	a1 a3       	sbr	r3,0x0
80006d9a:	93 13       	st.w	r9[0x4],r3
80006d9c:	91 29       	st.w	r8[0x8],r9
80006d9e:	04 9c       	mov	r12,r2
80006da0:	6e 18       	ld.w	r8,r7[0x4]
80006da2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006da6:	10 46       	or	r6,r8
80006da8:	8f 16       	st.w	r7[0x4],r6
80006daa:	ca a8       	rjmp	80006efe <_realloc_r+0x2b6>
80006dac:	14 03       	add	r3,r10
80006dae:	0c 33       	cp.w	r3,r6
80006db0:	c0 85       	brlt	80006dc0 <_realloc_r+0x178>
80006db2:	72 28       	ld.w	r8,r9[0x8]
80006db4:	72 39       	ld.w	r9,r9[0xc]
80006db6:	93 28       	st.w	r9[0x8],r8
80006db8:	91 39       	st.w	r8[0xc],r9
80006dba:	6e 28       	ld.w	r8,r7[0x8]
80006dbc:	6e 39       	ld.w	r9,r7[0xc]
80006dbe:	c0 78       	rjmp	80006dcc <_realloc_r+0x184>
80006dc0:	f8 00 00 03 	add	r3,r12,r0
80006dc4:	0c 33       	cp.w	r3,r6
80006dc6:	c3 35       	brlt	80006e2c <_realloc_r+0x1e4>
80006dc8:	6e 39       	ld.w	r9,r7[0xc]
80006dca:	6e 28       	ld.w	r8,r7[0x8]
80006dcc:	93 28       	st.w	r9[0x8],r8
80006dce:	91 39       	st.w	r8[0xc],r9
80006dd0:	e0 ca 00 04 	sub	r10,r0,4
80006dd4:	ee cc ff f8 	sub	r12,r7,-8
80006dd8:	e0 4a 00 24 	cp.w	r10,36
80006ddc:	e0 8b 00 24 	brhi	80006e24 <_realloc_r+0x1dc>
80006de0:	59 3a       	cp.w	r10,19
80006de2:	e0 88 00 1a 	brls	80006e16 <_realloc_r+0x1ce>
80006de6:	09 08       	ld.w	r8,r4++
80006de8:	99 08       	st.w	r12[0x0],r8
80006dea:	09 08       	ld.w	r8,r4++
80006dec:	8f 38       	st.w	r7[0xc],r8
80006dee:	ee cc ff f0 	sub	r12,r7,-16
80006df2:	59 ba       	cp.w	r10,27
80006df4:	e0 88 00 11 	brls	80006e16 <_realloc_r+0x1ce>
80006df8:	09 08       	ld.w	r8,r4++
80006dfa:	99 08       	st.w	r12[0x0],r8
80006dfc:	09 08       	ld.w	r8,r4++
80006dfe:	8f 58       	st.w	r7[0x14],r8
80006e00:	ee cc ff e8 	sub	r12,r7,-24
80006e04:	e0 4a 00 24 	cp.w	r10,36
80006e08:	c0 71       	brne	80006e16 <_realloc_r+0x1ce>
80006e0a:	09 08       	ld.w	r8,r4++
80006e0c:	99 08       	st.w	r12[0x0],r8
80006e0e:	ee cc ff e0 	sub	r12,r7,-32
80006e12:	09 08       	ld.w	r8,r4++
80006e14:	8f 78       	st.w	r7[0x1c],r8
80006e16:	09 08       	ld.w	r8,r4++
80006e18:	18 a8       	st.w	r12++,r8
80006e1a:	68 08       	ld.w	r8,r4[0x0]
80006e1c:	99 08       	st.w	r12[0x0],r8
80006e1e:	68 18       	ld.w	r8,r4[0x4]
80006e20:	99 18       	st.w	r12[0x4],r8
80006e22:	c4 78       	rjmp	80006eb0 <_realloc_r+0x268>
80006e24:	08 9b       	mov	r11,r4
80006e26:	e0 a0 1d 4e 	rcall	8000a8c2 <memmove>
80006e2a:	c4 38       	rjmp	80006eb0 <_realloc_r+0x268>
80006e2c:	04 9c       	mov	r12,r2
80006e2e:	fe b0 fc 45 	rcall	800066b8 <_malloc_r>
80006e32:	18 95       	mov	r5,r12
80006e34:	c3 a0       	breq	80006ea8 <_realloc_r+0x260>
80006e36:	62 18       	ld.w	r8,r1[0x4]
80006e38:	f8 c9 00 08 	sub	r9,r12,8
80006e3c:	a1 c8       	cbr	r8,0x0
80006e3e:	e2 08 00 08 	add	r8,r1,r8
80006e42:	10 39       	cp.w	r9,r8
80006e44:	c0 71       	brne	80006e52 <_realloc_r+0x20a>
80006e46:	72 13       	ld.w	r3,r9[0x4]
80006e48:	02 97       	mov	r7,r1
80006e4a:	e0 13 ff fc 	andl	r3,0xfffc
80006e4e:	00 03       	add	r3,r0
80006e50:	c3 08       	rjmp	80006eb0 <_realloc_r+0x268>
80006e52:	e0 ca 00 04 	sub	r10,r0,4
80006e56:	e0 4a 00 24 	cp.w	r10,36
80006e5a:	e0 8b 00 20 	brhi	80006e9a <_realloc_r+0x252>
80006e5e:	08 99       	mov	r9,r4
80006e60:	18 98       	mov	r8,r12
80006e62:	59 3a       	cp.w	r10,19
80006e64:	e0 88 00 14 	brls	80006e8c <_realloc_r+0x244>
80006e68:	13 0b       	ld.w	r11,r9++
80006e6a:	10 ab       	st.w	r8++,r11
80006e6c:	13 0b       	ld.w	r11,r9++
80006e6e:	10 ab       	st.w	r8++,r11
80006e70:	59 ba       	cp.w	r10,27
80006e72:	e0 88 00 0d 	brls	80006e8c <_realloc_r+0x244>
80006e76:	13 0b       	ld.w	r11,r9++
80006e78:	10 ab       	st.w	r8++,r11
80006e7a:	13 0b       	ld.w	r11,r9++
80006e7c:	10 ab       	st.w	r8++,r11
80006e7e:	e0 4a 00 24 	cp.w	r10,36
80006e82:	c0 51       	brne	80006e8c <_realloc_r+0x244>
80006e84:	13 0a       	ld.w	r10,r9++
80006e86:	10 aa       	st.w	r8++,r10
80006e88:	13 0a       	ld.w	r10,r9++
80006e8a:	10 aa       	st.w	r8++,r10
80006e8c:	13 0a       	ld.w	r10,r9++
80006e8e:	10 aa       	st.w	r8++,r10
80006e90:	72 0a       	ld.w	r10,r9[0x0]
80006e92:	91 0a       	st.w	r8[0x0],r10
80006e94:	72 19       	ld.w	r9,r9[0x4]
80006e96:	91 19       	st.w	r8[0x4],r9
80006e98:	c0 48       	rjmp	80006ea0 <_realloc_r+0x258>
80006e9a:	08 9b       	mov	r11,r4
80006e9c:	e0 a0 1d 13 	rcall	8000a8c2 <memmove>
80006ea0:	08 9b       	mov	r11,r4
80006ea2:	04 9c       	mov	r12,r2
80006ea4:	e0 a0 1a 6c 	rcall	8000a37c <_free_r>
80006ea8:	04 9c       	mov	r12,r2
80006eaa:	c2 a8       	rjmp	80006efe <_realloc_r+0x2b6>
80006eac:	00 93       	mov	r3,r0
80006eae:	02 97       	mov	r7,r1
80006eb0:	e6 06 01 09 	sub	r9,r3,r6
80006eb4:	6e 18       	ld.w	r8,r7[0x4]
80006eb6:	58 f9       	cp.w	r9,15
80006eb8:	e0 88 00 16 	brls	80006ee4 <_realloc_r+0x29c>
80006ebc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006ec0:	ed e8 10 08 	or	r8,r6,r8
80006ec4:	8f 18       	st.w	r7[0x4],r8
80006ec6:	12 98       	mov	r8,r9
80006ec8:	a1 a8       	sbr	r8,0x0
80006eca:	ee 06 00 0b 	add	r11,r7,r6
80006ece:	f6 09 00 09 	add	r9,r11,r9
80006ed2:	97 18       	st.w	r11[0x4],r8
80006ed4:	72 18       	ld.w	r8,r9[0x4]
80006ed6:	a1 a8       	sbr	r8,0x0
80006ed8:	2f 8b       	sub	r11,-8
80006eda:	93 18       	st.w	r9[0x4],r8
80006edc:	04 9c       	mov	r12,r2
80006ede:	e0 a0 1a 4f 	rcall	8000a37c <_free_r>
80006ee2:	c0 b8       	rjmp	80006ef8 <_realloc_r+0x2b0>
80006ee4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006ee8:	e7 e8 10 08 	or	r8,r3,r8
80006eec:	8f 18       	st.w	r7[0x4],r8
80006eee:	ee 03 00 03 	add	r3,r7,r3
80006ef2:	66 18       	ld.w	r8,r3[0x4]
80006ef4:	a1 a8       	sbr	r8,0x0
80006ef6:	87 18       	st.w	r3[0x4],r8
80006ef8:	04 9c       	mov	r12,r2
80006efa:	ee c5 ff f8 	sub	r5,r7,-8
80006efe:	fe b0 f1 4f 	rcall	8000519c <__malloc_unlock>
80006f02:	0a 9c       	mov	r12,r5
80006f04:	2f fd       	sub	sp,-4
80006f06:	d8 32       	popm	r0-r7,pc

80006f08 <_sbrk_r>:
80006f08:	d4 21       	pushm	r4-r7,lr
80006f0a:	30 08       	mov	r8,0
80006f0c:	18 97       	mov	r7,r12
80006f0e:	e0 66 40 fc 	mov	r6,16636
80006f12:	16 9c       	mov	r12,r11
80006f14:	8d 08       	st.w	r6[0x0],r8
80006f16:	c9 1c       	rcall	80007038 <_sbrk>
80006f18:	5b fc       	cp.w	r12,-1
80006f1a:	c0 51       	brne	80006f24 <_sbrk_r+0x1c>
80006f1c:	6c 08       	ld.w	r8,r6[0x0]
80006f1e:	58 08       	cp.w	r8,0
80006f20:	ef f8 1a 03 	st.wne	r7[0xc],r8
80006f24:	d8 22       	popm	r4-r7,pc
80006f26:	d7 03       	nop

80006f28 <sprintf>:
80006f28:	d4 01       	pushm	lr
80006f2a:	21 7d       	sub	sp,92
80006f2c:	e0 68 ff ff 	mov	r8,65535
80006f30:	ea 18 7f ff 	orh	r8,0x7fff
80006f34:	50 58       	stdsp	sp[0x14],r8
80006f36:	50 28       	stdsp	sp[0x8],r8
80006f38:	e0 68 02 08 	mov	r8,520
80006f3c:	ba 68       	st.h	sp[0xc],r8
80006f3e:	3f f8       	mov	r8,-1
80006f40:	ba 78       	st.h	sp[0xe],r8
80006f42:	e0 68 0a 30 	mov	r8,2608
80006f46:	50 4c       	stdsp	sp[0x10],r12
80006f48:	16 9a       	mov	r10,r11
80006f4a:	50 0c       	stdsp	sp[0x0],r12
80006f4c:	fa c9 ff a0 	sub	r9,sp,-96
80006f50:	70 0c       	ld.w	r12,r8[0x0]
80006f52:	1a 9b       	mov	r11,sp
80006f54:	e0 a0 02 26 	rcall	800073a0 <_vfprintf_r>
80006f58:	30 09       	mov	r9,0
80006f5a:	40 08       	lddsp	r8,sp[0x0]
80006f5c:	b0 89       	st.b	r8[0x0],r9
80006f5e:	2e 9d       	sub	sp,-92
80006f60:	d8 02       	popm	pc
80006f62:	d7 03       	nop

80006f64 <strlen>:
80006f64:	30 09       	mov	r9,0
80006f66:	18 98       	mov	r8,r12
80006f68:	c0 28       	rjmp	80006f6c <strlen+0x8>
80006f6a:	2f f8       	sub	r8,-1
80006f6c:	11 8a       	ld.ub	r10,r8[0x0]
80006f6e:	f2 0a 18 00 	cp.b	r10,r9
80006f72:	cf c1       	brne	80006f6a <strlen+0x6>
80006f74:	f0 0c 01 0c 	sub	r12,r8,r12
80006f78:	5e fc       	retal	r12
80006f7a:	d7 03       	nop

80006f7c <strncpy>:
80006f7c:	30 08       	mov	r8,0
80006f7e:	10 3a       	cp.w	r10,r8
80006f80:	5e 0c       	reteq	r12
80006f82:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006f86:	f8 08 0b 09 	st.b	r12[r8],r9
80006f8a:	2f f8       	sub	r8,-1
80006f8c:	58 09       	cp.w	r9,0
80006f8e:	cf 81       	brne	80006f7e <strncpy+0x2>
80006f90:	10 3a       	cp.w	r10,r8
80006f92:	5e 0c       	reteq	r12
80006f94:	f8 08 0b 09 	st.b	r12[r8],r9
80006f98:	2f f8       	sub	r8,-1
80006f9a:	cf bb       	rjmp	80006f90 <strncpy+0x14>

80006f9c <_close>:
80006f9c:	30 28       	mov	r8,2
80006f9e:	d6 73       	breakpoint
80006fa0:	3f fc       	mov	r12,-1
80006fa2:	35 8b       	mov	r11,88
80006fa4:	58 0c       	cp.w	r12,0
80006fa6:	5e 4c       	retge	r12
80006fa8:	e0 6a 40 fc 	mov	r10,16636
80006fac:	95 0b       	st.w	r10[0x0],r11
80006fae:	5e fc       	retal	r12

80006fb0 <_lseek>:
80006fb0:	30 58       	mov	r8,5
80006fb2:	d6 73       	breakpoint
80006fb4:	3f fc       	mov	r12,-1
80006fb6:	35 8b       	mov	r11,88
80006fb8:	58 0c       	cp.w	r12,0
80006fba:	5e 4c       	retge	r12
80006fbc:	e0 6a 40 fc 	mov	r10,16636
80006fc0:	95 0b       	st.w	r10[0x0],r11
80006fc2:	5e fc       	retal	r12

80006fc4 <isatty>:
80006fc4:	30 b8       	mov	r8,11
80006fc6:	d6 73       	breakpoint
80006fc8:	3f fc       	mov	r12,-1
80006fca:	35 8b       	mov	r11,88
80006fcc:	58 0c       	cp.w	r12,0
80006fce:	5e 4c       	retge	r12
80006fd0:	e0 6a 40 fc 	mov	r10,16636
80006fd4:	95 0b       	st.w	r10[0x0],r11
80006fd6:	5e fc       	retal	r12

80006fd8 <_fstat_host>:
80006fd8:	30 98       	mov	r8,9
80006fda:	d6 73       	breakpoint
80006fdc:	3f fc       	mov	r12,-1
80006fde:	35 8b       	mov	r11,88
80006fe0:	58 0c       	cp.w	r12,0
80006fe2:	5e 4c       	retge	r12
80006fe4:	e0 6a 40 fc 	mov	r10,16636
80006fe8:	95 0b       	st.w	r10[0x0],r11
80006fea:	5e fc       	retal	r12

80006fec <_fstat>:
80006fec:	d4 21       	pushm	r4-r7,lr
80006fee:	21 0d       	sub	sp,64
80006ff0:	16 97       	mov	r7,r11
80006ff2:	1a 9b       	mov	r11,sp
80006ff4:	cf 2f       	rcall	80006fd8 <_fstat_host>
80006ff6:	c0 34       	brge	80006ffc <_fstat+0x10>
80006ff8:	3f fc       	mov	r12,-1
80006ffa:	c1 c8       	rjmp	80007032 <_fstat+0x46>
80006ffc:	40 08       	lddsp	r8,sp[0x0]
80006ffe:	ae 08       	st.h	r7[0x0],r8
80007000:	40 18       	lddsp	r8,sp[0x4]
80007002:	ae 18       	st.h	r7[0x2],r8
80007004:	40 28       	lddsp	r8,sp[0x8]
80007006:	8f 18       	st.w	r7[0x4],r8
80007008:	40 38       	lddsp	r8,sp[0xc]
8000700a:	ae 48       	st.h	r7[0x8],r8
8000700c:	40 48       	lddsp	r8,sp[0x10]
8000700e:	ae 58       	st.h	r7[0xa],r8
80007010:	40 58       	lddsp	r8,sp[0x14]
80007012:	ae 68       	st.h	r7[0xc],r8
80007014:	40 68       	lddsp	r8,sp[0x18]
80007016:	ae 78       	st.h	r7[0xe],r8
80007018:	40 88       	lddsp	r8,sp[0x20]
8000701a:	8f 48       	st.w	r7[0x10],r8
8000701c:	40 a8       	lddsp	r8,sp[0x28]
8000701e:	8f b8       	st.w	r7[0x2c],r8
80007020:	40 c8       	lddsp	r8,sp[0x30]
80007022:	8f c8       	st.w	r7[0x30],r8
80007024:	40 d8       	lddsp	r8,sp[0x34]
80007026:	8f 58       	st.w	r7[0x14],r8
80007028:	40 e8       	lddsp	r8,sp[0x38]
8000702a:	30 0c       	mov	r12,0
8000702c:	8f 78       	st.w	r7[0x1c],r8
8000702e:	40 f8       	lddsp	r8,sp[0x3c]
80007030:	8f 98       	st.w	r7[0x24],r8
80007032:	2f 0d       	sub	sp,-64
80007034:	d8 22       	popm	r4-r7,pc
80007036:	d7 03       	nop

80007038 <_sbrk>:
80007038:	d4 01       	pushm	lr
8000703a:	e0 68 0d 8c 	mov	r8,3468
8000703e:	70 09       	ld.w	r9,r8[0x0]
80007040:	58 09       	cp.w	r9,0
80007042:	c0 41       	brne	8000704a <_sbrk+0x12>
80007044:	e0 69 41 00 	mov	r9,16640
80007048:	91 09       	st.w	r8[0x0],r9
8000704a:	e0 69 0d 8c 	mov	r9,3468
8000704e:	e0 7a 70 00 	mov	r10,94208
80007052:	72 08       	ld.w	r8,r9[0x0]
80007054:	f0 0c 00 0c 	add	r12,r8,r12
80007058:	14 3c       	cp.w	r12,r10
8000705a:	e0 8b 00 04 	brhi	80007062 <_sbrk+0x2a>
8000705e:	93 0c       	st.w	r9[0x0],r12
80007060:	c0 68       	rjmp	8000706c <_sbrk+0x34>
80007062:	e0 a0 18 15 	rcall	8000a08c <__errno>
80007066:	30 c8       	mov	r8,12
80007068:	99 08       	st.w	r12[0x0],r8
8000706a:	3f f8       	mov	r8,-1
8000706c:	10 9c       	mov	r12,r8
8000706e:	d8 02       	popm	pc

80007070 <get_arg>:
80007070:	d4 31       	pushm	r0-r7,lr
80007072:	20 8d       	sub	sp,32
80007074:	fa c4 ff bc 	sub	r4,sp,-68
80007078:	50 4b       	stdsp	sp[0x10],r11
8000707a:	68 2e       	ld.w	lr,r4[0x8]
8000707c:	50 58       	stdsp	sp[0x14],r8
8000707e:	12 96       	mov	r6,r9
80007080:	7c 0b       	ld.w	r11,lr[0x0]
80007082:	70 05       	ld.w	r5,r8[0x0]
80007084:	50 6e       	stdsp	sp[0x18],lr
80007086:	58 0b       	cp.w	r11,0
80007088:	f4 0b 17 00 	moveq	r11,r10
8000708c:	68 03       	ld.w	r3,r4[0x0]
8000708e:	68 11       	ld.w	r1,r4[0x4]
80007090:	40 49       	lddsp	r9,sp[0x10]
80007092:	30 08       	mov	r8,0
80007094:	c2 89       	rjmp	800072e4 <get_arg+0x274>
80007096:	2f fb       	sub	r11,-1
80007098:	32 5c       	mov	r12,37
8000709a:	17 8a       	ld.ub	r10,r11[0x0]
8000709c:	f8 0a 18 00 	cp.b	r10,r12
800070a0:	5f 1e       	srne	lr
800070a2:	f0 0a 18 00 	cp.b	r10,r8
800070a6:	5f 1c       	srne	r12
800070a8:	fd ec 00 0c 	and	r12,lr,r12
800070ac:	f0 0c 18 00 	cp.b	r12,r8
800070b0:	cf 31       	brne	80007096 <get_arg+0x26>
800070b2:	58 0a       	cp.w	r10,0
800070b4:	e0 80 01 25 	breq	800072fe <get_arg+0x28e>
800070b8:	30 0c       	mov	r12,0
800070ba:	3f fa       	mov	r10,-1
800070bc:	18 90       	mov	r0,r12
800070be:	50 3a       	stdsp	sp[0xc],r10
800070c0:	18 94       	mov	r4,r12
800070c2:	18 92       	mov	r2,r12
800070c4:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
800070c8:	16 97       	mov	r7,r11
800070ca:	50 7c       	stdsp	sp[0x1c],r12
800070cc:	fe cc 99 e0 	sub	r12,pc,-26144
800070d0:	0f 3a       	ld.ub	r10,r7++
800070d2:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
800070d6:	40 7c       	lddsp	r12,sp[0x1c]
800070d8:	1c 0c       	add	r12,lr
800070da:	fe ce 9a b6 	sub	lr,pc,-25930
800070de:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
800070e2:	20 1e       	sub	lr,1
800070e4:	50 0e       	stdsp	sp[0x0],lr
800070e6:	fe ce 9b 2e 	sub	lr,pc,-25810
800070ea:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
800070ee:	50 7c       	stdsp	sp[0x1c],r12
800070f0:	40 0c       	lddsp	r12,sp[0x0]
800070f2:	58 7c       	cp.w	r12,7
800070f4:	e0 8b 00 f1 	brhi	800072d6 <get_arg+0x266>
800070f8:	fe ce 9c e0 	sub	lr,pc,-25376
800070fc:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007100:	36 8b       	mov	r11,104
80007102:	f6 0a 18 00 	cp.b	r10,r11
80007106:	e0 80 00 e8 	breq	800072d6 <get_arg+0x266>
8000710a:	37 1b       	mov	r11,113
8000710c:	f6 0a 18 00 	cp.b	r10,r11
80007110:	c0 70       	breq	8000711e <get_arg+0xae>
80007112:	34 cb       	mov	r11,76
80007114:	f6 0a 18 00 	cp.b	r10,r11
80007118:	c0 51       	brne	80007122 <get_arg+0xb2>
8000711a:	a3 b4       	sbr	r4,0x3
8000711c:	cd d8       	rjmp	800072d6 <get_arg+0x266>
8000711e:	a5 b4       	sbr	r4,0x5
80007120:	cd b8       	rjmp	800072d6 <get_arg+0x266>
80007122:	08 9a       	mov	r10,r4
80007124:	0e 9b       	mov	r11,r7
80007126:	a5 aa       	sbr	r10,0x4
80007128:	17 3c       	ld.ub	r12,r11++
8000712a:	a5 b4       	sbr	r4,0x5
8000712c:	36 ce       	mov	lr,108
8000712e:	fc 0c 18 00 	cp.b	r12,lr
80007132:	e0 80 00 d3 	breq	800072d8 <get_arg+0x268>
80007136:	14 94       	mov	r4,r10
80007138:	cc f8       	rjmp	800072d6 <get_arg+0x266>
8000713a:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000713e:	36 7c       	mov	r12,103
80007140:	f8 0a 18 00 	cp.b	r10,r12
80007144:	e0 8b 00 27 	brhi	80007192 <get_arg+0x122>
80007148:	36 5b       	mov	r11,101
8000714a:	f6 0a 18 00 	cp.b	r10,r11
8000714e:	c4 82       	brcc	800071de <get_arg+0x16e>
80007150:	34 fb       	mov	r11,79
80007152:	f6 0a 18 00 	cp.b	r10,r11
80007156:	c4 80       	breq	800071e6 <get_arg+0x176>
80007158:	e0 8b 00 0c 	brhi	80007170 <get_arg+0x100>
8000715c:	34 5b       	mov	r11,69
8000715e:	f6 0a 18 00 	cp.b	r10,r11
80007162:	c3 e0       	breq	800071de <get_arg+0x16e>
80007164:	34 7b       	mov	r11,71
80007166:	f6 0a 18 00 	cp.b	r10,r11
8000716a:	c3 a0       	breq	800071de <get_arg+0x16e>
8000716c:	34 4b       	mov	r11,68
8000716e:	c0 88       	rjmp	8000717e <get_arg+0x10e>
80007170:	35 8b       	mov	r11,88
80007172:	f6 0a 18 00 	cp.b	r10,r11
80007176:	c2 c0       	breq	800071ce <get_arg+0x15e>
80007178:	e0 8b 00 07 	brhi	80007186 <get_arg+0x116>
8000717c:	35 5b       	mov	r11,85
8000717e:	f6 0a 18 00 	cp.b	r10,r11
80007182:	c3 51       	brne	800071ec <get_arg+0x17c>
80007184:	c3 18       	rjmp	800071e6 <get_arg+0x176>
80007186:	36 3b       	mov	r11,99
80007188:	f6 0a 18 00 	cp.b	r10,r11
8000718c:	c2 f0       	breq	800071ea <get_arg+0x17a>
8000718e:	36 4b       	mov	r11,100
80007190:	c0 e8       	rjmp	800071ac <get_arg+0x13c>
80007192:	37 0b       	mov	r11,112
80007194:	f6 0a 18 00 	cp.b	r10,r11
80007198:	c2 50       	breq	800071e2 <get_arg+0x172>
8000719a:	e0 8b 00 0d 	brhi	800071b4 <get_arg+0x144>
8000719e:	36 eb       	mov	r11,110
800071a0:	f6 0a 18 00 	cp.b	r10,r11
800071a4:	c1 f0       	breq	800071e2 <get_arg+0x172>
800071a6:	e0 8b 00 14 	brhi	800071ce <get_arg+0x15e>
800071aa:	36 9b       	mov	r11,105
800071ac:	f6 0a 18 00 	cp.b	r10,r11
800071b0:	c1 e1       	brne	800071ec <get_arg+0x17c>
800071b2:	c0 e8       	rjmp	800071ce <get_arg+0x15e>
800071b4:	37 5b       	mov	r11,117
800071b6:	f6 0a 18 00 	cp.b	r10,r11
800071ba:	c0 a0       	breq	800071ce <get_arg+0x15e>
800071bc:	37 8b       	mov	r11,120
800071be:	f6 0a 18 00 	cp.b	r10,r11
800071c2:	c0 60       	breq	800071ce <get_arg+0x15e>
800071c4:	37 3b       	mov	r11,115
800071c6:	f6 0a 18 00 	cp.b	r10,r11
800071ca:	c1 11       	brne	800071ec <get_arg+0x17c>
800071cc:	c0 b8       	rjmp	800071e2 <get_arg+0x172>
800071ce:	ed b4 00 04 	bld	r4,0x4
800071d2:	c0 a0       	breq	800071e6 <get_arg+0x176>
800071d4:	ed b4 00 05 	bld	r4,0x5
800071d8:	c0 91       	brne	800071ea <get_arg+0x17a>
800071da:	30 20       	mov	r0,2
800071dc:	c0 88       	rjmp	800071ec <get_arg+0x17c>
800071de:	30 40       	mov	r0,4
800071e0:	c0 68       	rjmp	800071ec <get_arg+0x17c>
800071e2:	30 30       	mov	r0,3
800071e4:	c0 48       	rjmp	800071ec <get_arg+0x17c>
800071e6:	30 10       	mov	r0,1
800071e8:	c0 28       	rjmp	800071ec <get_arg+0x17c>
800071ea:	30 00       	mov	r0,0
800071ec:	40 3b       	lddsp	r11,sp[0xc]
800071ee:	5b fb       	cp.w	r11,-1
800071f0:	c0 40       	breq	800071f8 <get_arg+0x188>
800071f2:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
800071f6:	c7 08       	rjmp	800072d6 <get_arg+0x266>
800071f8:	58 60       	cp.w	r0,6
800071fa:	e0 8b 00 6e 	brhi	800072d6 <get_arg+0x266>
800071fe:	6c 0a       	ld.w	r10,r6[0x0]
80007200:	ea cc ff ff 	sub	r12,r5,-1
80007204:	fe ce 9d cc 	sub	lr,pc,-25140
80007208:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000720c:	f4 cb ff f8 	sub	r11,r10,-8
80007210:	8d 0b       	st.w	r6[0x0],r11
80007212:	f4 ea 00 00 	ld.d	r10,r10[0]
80007216:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000721a:	c0 f8       	rjmp	80007238 <get_arg+0x1c8>
8000721c:	f4 cb ff fc 	sub	r11,r10,-4
80007220:	8d 0b       	st.w	r6[0x0],r11
80007222:	74 0a       	ld.w	r10,r10[0x0]
80007224:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007228:	c0 88       	rjmp	80007238 <get_arg+0x1c8>
8000722a:	f4 cb ff f8 	sub	r11,r10,-8
8000722e:	8d 0b       	st.w	r6[0x0],r11
80007230:	f4 ea 00 00 	ld.d	r10,r10[0]
80007234:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007238:	0e 9b       	mov	r11,r7
8000723a:	18 95       	mov	r5,r12
8000723c:	c4 e8       	rjmp	800072d8 <get_arg+0x268>
8000723e:	62 0a       	ld.w	r10,r1[0x0]
80007240:	5b fa       	cp.w	r10,-1
80007242:	c0 b1       	brne	80007258 <get_arg+0x1e8>
80007244:	50 19       	stdsp	sp[0x4],r9
80007246:	50 28       	stdsp	sp[0x8],r8
80007248:	e0 6a 00 80 	mov	r10,128
8000724c:	30 0b       	mov	r11,0
8000724e:	02 9c       	mov	r12,r1
80007250:	fe b0 fc f4 	rcall	80006c38 <memset>
80007254:	40 28       	lddsp	r8,sp[0x8]
80007256:	40 19       	lddsp	r9,sp[0x4]
80007258:	e4 cc 00 01 	sub	r12,r2,1
8000725c:	0e 9b       	mov	r11,r7
8000725e:	50 3c       	stdsp	sp[0xc],r12
80007260:	f2 0c 0c 49 	max	r9,r9,r12
80007264:	c3 a8       	rjmp	800072d8 <get_arg+0x268>
80007266:	62 0a       	ld.w	r10,r1[0x0]
80007268:	5b fa       	cp.w	r10,-1
8000726a:	c0 b1       	brne	80007280 <get_arg+0x210>
8000726c:	50 19       	stdsp	sp[0x4],r9
8000726e:	50 28       	stdsp	sp[0x8],r8
80007270:	e0 6a 00 80 	mov	r10,128
80007274:	30 0b       	mov	r11,0
80007276:	02 9c       	mov	r12,r1
80007278:	fe b0 fc e0 	rcall	80006c38 <memset>
8000727c:	40 28       	lddsp	r8,sp[0x8]
8000727e:	40 19       	lddsp	r9,sp[0x4]
80007280:	20 12       	sub	r2,1
80007282:	30 0a       	mov	r10,0
80007284:	0e 9b       	mov	r11,r7
80007286:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000728a:	f2 02 0c 49 	max	r9,r9,r2
8000728e:	c2 58       	rjmp	800072d8 <get_arg+0x268>
80007290:	16 97       	mov	r7,r11
80007292:	6c 0a       	ld.w	r10,r6[0x0]
80007294:	f4 cb ff fc 	sub	r11,r10,-4
80007298:	8d 0b       	st.w	r6[0x0],r11
8000729a:	74 0a       	ld.w	r10,r10[0x0]
8000729c:	0e 9b       	mov	r11,r7
8000729e:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800072a2:	2f f5       	sub	r5,-1
800072a4:	c1 a8       	rjmp	800072d8 <get_arg+0x268>
800072a6:	f4 c2 00 30 	sub	r2,r10,48
800072aa:	c0 68       	rjmp	800072b6 <get_arg+0x246>
800072ac:	e4 02 00 22 	add	r2,r2,r2<<0x2
800072b0:	2f f7       	sub	r7,-1
800072b2:	f4 02 00 12 	add	r2,r10,r2<<0x1
800072b6:	0f 8a       	ld.ub	r10,r7[0x0]
800072b8:	58 0a       	cp.w	r10,0
800072ba:	c0 e0       	breq	800072d6 <get_arg+0x266>
800072bc:	23 0a       	sub	r10,48
800072be:	58 9a       	cp.w	r10,9
800072c0:	fe 98 ff f6 	brls	800072ac <get_arg+0x23c>
800072c4:	c0 98       	rjmp	800072d6 <get_arg+0x266>
800072c6:	2f f7       	sub	r7,-1
800072c8:	0f 8a       	ld.ub	r10,r7[0x0]
800072ca:	58 0a       	cp.w	r10,0
800072cc:	c0 50       	breq	800072d6 <get_arg+0x266>
800072ce:	23 0a       	sub	r10,48
800072d0:	58 9a       	cp.w	r10,9
800072d2:	fe 98 ff fa 	brls	800072c6 <get_arg+0x256>
800072d6:	0e 9b       	mov	r11,r7
800072d8:	40 7c       	lddsp	r12,sp[0x1c]
800072da:	30 ba       	mov	r10,11
800072dc:	f4 0c 18 00 	cp.b	r12,r10
800072e0:	fe 91 fe f2 	brne	800070c4 <get_arg+0x54>
800072e4:	40 42       	lddsp	r2,sp[0x10]
800072e6:	17 8c       	ld.ub	r12,r11[0x0]
800072e8:	0a 32       	cp.w	r2,r5
800072ea:	5f 4a       	srge	r10
800072ec:	f0 0c 18 00 	cp.b	r12,r8
800072f0:	5f 1c       	srne	r12
800072f2:	f9 ea 00 0a 	and	r10,r12,r10
800072f6:	f0 0a 18 00 	cp.b	r10,r8
800072fa:	fe 91 fe cf 	brne	80007098 <get_arg+0x28>
800072fe:	30 08       	mov	r8,0
80007300:	40 4e       	lddsp	lr,sp[0x10]
80007302:	17 8a       	ld.ub	r10,r11[0x0]
80007304:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007308:	f0 0a 18 00 	cp.b	r10,r8
8000730c:	fc 09 17 10 	movne	r9,lr
80007310:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007314:	06 9e       	mov	lr,r3
80007316:	c2 a8       	rjmp	8000736a <get_arg+0x2fa>
80007318:	62 0a       	ld.w	r10,r1[0x0]
8000731a:	58 3a       	cp.w	r10,3
8000731c:	c1 e0       	breq	80007358 <get_arg+0x2e8>
8000731e:	e0 89 00 07 	brgt	8000732c <get_arg+0x2bc>
80007322:	58 1a       	cp.w	r10,1
80007324:	c1 a0       	breq	80007358 <get_arg+0x2e8>
80007326:	58 2a       	cp.w	r10,2
80007328:	c1 81       	brne	80007358 <get_arg+0x2e8>
8000732a:	c0 58       	rjmp	80007334 <get_arg+0x2c4>
8000732c:	58 5a       	cp.w	r10,5
8000732e:	c0 c0       	breq	80007346 <get_arg+0x2d6>
80007330:	c0 b5       	brlt	80007346 <get_arg+0x2d6>
80007332:	c1 38       	rjmp	80007358 <get_arg+0x2e8>
80007334:	6c 0a       	ld.w	r10,r6[0x0]
80007336:	f4 cc ff f8 	sub	r12,r10,-8
8000733a:	8d 0c       	st.w	r6[0x0],r12
8000733c:	f4 e2 00 00 	ld.d	r2,r10[0]
80007340:	f0 e3 00 00 	st.d	r8[0],r2
80007344:	c1 08       	rjmp	80007364 <get_arg+0x2f4>
80007346:	6c 0a       	ld.w	r10,r6[0x0]
80007348:	f4 cc ff f8 	sub	r12,r10,-8
8000734c:	8d 0c       	st.w	r6[0x0],r12
8000734e:	f4 e2 00 00 	ld.d	r2,r10[0]
80007352:	f0 e3 00 00 	st.d	r8[0],r2
80007356:	c0 78       	rjmp	80007364 <get_arg+0x2f4>
80007358:	6c 0a       	ld.w	r10,r6[0x0]
8000735a:	f4 cc ff fc 	sub	r12,r10,-4
8000735e:	8d 0c       	st.w	r6[0x0],r12
80007360:	74 0a       	ld.w	r10,r10[0x0]
80007362:	91 0a       	st.w	r8[0x0],r10
80007364:	2f f5       	sub	r5,-1
80007366:	2f 88       	sub	r8,-8
80007368:	2f c1       	sub	r1,-4
8000736a:	12 35       	cp.w	r5,r9
8000736c:	fe 9a ff d6 	brle	80007318 <get_arg+0x2a8>
80007370:	1c 93       	mov	r3,lr
80007372:	40 52       	lddsp	r2,sp[0x14]
80007374:	40 6e       	lddsp	lr,sp[0x18]
80007376:	85 05       	st.w	r2[0x0],r5
80007378:	9d 0b       	st.w	lr[0x0],r11
8000737a:	40 4b       	lddsp	r11,sp[0x10]
8000737c:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007380:	2f 8d       	sub	sp,-32
80007382:	d8 32       	popm	r0-r7,pc

80007384 <__sprint_r>:
80007384:	d4 21       	pushm	r4-r7,lr
80007386:	14 97       	mov	r7,r10
80007388:	74 28       	ld.w	r8,r10[0x8]
8000738a:	58 08       	cp.w	r8,0
8000738c:	c0 41       	brne	80007394 <__sprint_r+0x10>
8000738e:	95 18       	st.w	r10[0x4],r8
80007390:	10 9c       	mov	r12,r8
80007392:	d8 22       	popm	r4-r7,pc
80007394:	e0 a0 18 ba 	rcall	8000a508 <__sfvwrite_r>
80007398:	30 08       	mov	r8,0
8000739a:	8f 18       	st.w	r7[0x4],r8
8000739c:	8f 28       	st.w	r7[0x8],r8
8000739e:	d8 22       	popm	r4-r7,pc

800073a0 <_vfprintf_r>:
800073a0:	d4 31       	pushm	r0-r7,lr
800073a2:	fa cd 06 bc 	sub	sp,sp,1724
800073a6:	51 09       	stdsp	sp[0x40],r9
800073a8:	16 91       	mov	r1,r11
800073aa:	14 97       	mov	r7,r10
800073ac:	18 95       	mov	r5,r12
800073ae:	e0 a0 1a 1d 	rcall	8000a7e8 <_localeconv_r>
800073b2:	78 0c       	ld.w	r12,r12[0x0]
800073b4:	50 cc       	stdsp	sp[0x30],r12
800073b6:	58 05       	cp.w	r5,0
800073b8:	c0 70       	breq	800073c6 <_vfprintf_r+0x26>
800073ba:	6a 68       	ld.w	r8,r5[0x18]
800073bc:	58 08       	cp.w	r8,0
800073be:	c0 41       	brne	800073c6 <_vfprintf_r+0x26>
800073c0:	0a 9c       	mov	r12,r5
800073c2:	e0 a0 17 43 	rcall	8000a248 <__sinit>
800073c6:	fe c8 9b ca 	sub	r8,pc,-25654
800073ca:	10 31       	cp.w	r1,r8
800073cc:	c0 31       	brne	800073d2 <_vfprintf_r+0x32>
800073ce:	6a 01       	ld.w	r1,r5[0x0]
800073d0:	c0 c8       	rjmp	800073e8 <_vfprintf_r+0x48>
800073d2:	fe c8 9b b6 	sub	r8,pc,-25674
800073d6:	10 31       	cp.w	r1,r8
800073d8:	c0 31       	brne	800073de <_vfprintf_r+0x3e>
800073da:	6a 11       	ld.w	r1,r5[0x4]
800073dc:	c0 68       	rjmp	800073e8 <_vfprintf_r+0x48>
800073de:	fe c8 9b a2 	sub	r8,pc,-25694
800073e2:	10 31       	cp.w	r1,r8
800073e4:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800073e8:	82 68       	ld.sh	r8,r1[0xc]
800073ea:	ed b8 00 03 	bld	r8,0x3
800073ee:	c0 41       	brne	800073f6 <_vfprintf_r+0x56>
800073f0:	62 48       	ld.w	r8,r1[0x10]
800073f2:	58 08       	cp.w	r8,0
800073f4:	c0 71       	brne	80007402 <_vfprintf_r+0x62>
800073f6:	02 9b       	mov	r11,r1
800073f8:	0a 9c       	mov	r12,r5
800073fa:	e0 a0 0f 5d 	rcall	800092b4 <__swsetup_r>
800073fe:	e0 81 0f 54 	brne	800092a6 <_vfprintf_r+0x1f06>
80007402:	82 68       	ld.sh	r8,r1[0xc]
80007404:	10 99       	mov	r9,r8
80007406:	e2 19 00 1a 	andl	r9,0x1a,COH
8000740a:	58 a9       	cp.w	r9,10
8000740c:	c3 c1       	brne	80007484 <_vfprintf_r+0xe4>
8000740e:	82 79       	ld.sh	r9,r1[0xe]
80007410:	30 0a       	mov	r10,0
80007412:	f4 09 19 00 	cp.h	r9,r10
80007416:	c3 75       	brlt	80007484 <_vfprintf_r+0xe4>
80007418:	a1 d8       	cbr	r8,0x1
8000741a:	fb 58 05 d0 	st.h	sp[1488],r8
8000741e:	62 88       	ld.w	r8,r1[0x20]
80007420:	fb 48 05 e4 	st.w	sp[1508],r8
80007424:	62 a8       	ld.w	r8,r1[0x28]
80007426:	fb 48 05 ec 	st.w	sp[1516],r8
8000742a:	fa c8 ff bc 	sub	r8,sp,-68
8000742e:	fb 48 05 d4 	st.w	sp[1492],r8
80007432:	fb 48 05 c4 	st.w	sp[1476],r8
80007436:	e0 68 04 00 	mov	r8,1024
8000743a:	fb 48 05 d8 	st.w	sp[1496],r8
8000743e:	fb 48 05 cc 	st.w	sp[1484],r8
80007442:	30 08       	mov	r8,0
80007444:	fb 59 05 d2 	st.h	sp[1490],r9
80007448:	0e 9a       	mov	r10,r7
8000744a:	41 09       	lddsp	r9,sp[0x40]
8000744c:	fa c7 fa 3c 	sub	r7,sp,-1476
80007450:	fb 48 05 dc 	st.w	sp[1500],r8
80007454:	0a 9c       	mov	r12,r5
80007456:	0e 9b       	mov	r11,r7
80007458:	ca 4f       	rcall	800073a0 <_vfprintf_r>
8000745a:	50 bc       	stdsp	sp[0x2c],r12
8000745c:	c0 95       	brlt	8000746e <_vfprintf_r+0xce>
8000745e:	0e 9b       	mov	r11,r7
80007460:	0a 9c       	mov	r12,r5
80007462:	e0 a0 16 1b 	rcall	8000a098 <_fflush_r>
80007466:	40 be       	lddsp	lr,sp[0x2c]
80007468:	f9 be 01 ff 	movne	lr,-1
8000746c:	50 be       	stdsp	sp[0x2c],lr
8000746e:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007472:	ed b8 00 06 	bld	r8,0x6
80007476:	e0 81 0f 1a 	brne	800092aa <_vfprintf_r+0x1f0a>
8000747a:	82 68       	ld.sh	r8,r1[0xc]
8000747c:	a7 a8       	sbr	r8,0x6
8000747e:	a2 68       	st.h	r1[0xc],r8
80007480:	e0 8f 0f 15 	bral	800092aa <_vfprintf_r+0x1f0a>
80007484:	30 08       	mov	r8,0
80007486:	fb 48 06 b4 	st.w	sp[1716],r8
8000748a:	fb 48 06 90 	st.w	sp[1680],r8
8000748e:	fb 48 06 8c 	st.w	sp[1676],r8
80007492:	fb 48 06 b0 	st.w	sp[1712],r8
80007496:	30 08       	mov	r8,0
80007498:	30 09       	mov	r9,0
8000749a:	50 a7       	stdsp	sp[0x28],r7
8000749c:	50 78       	stdsp	sp[0x1c],r8
8000749e:	fa c3 f9 e0 	sub	r3,sp,-1568
800074a2:	3f f8       	mov	r8,-1
800074a4:	50 59       	stdsp	sp[0x14],r9
800074a6:	fb 43 06 88 	st.w	sp[1672],r3
800074aa:	fb 48 05 44 	st.w	sp[1348],r8
800074ae:	12 9c       	mov	r12,r9
800074b0:	50 69       	stdsp	sp[0x18],r9
800074b2:	50 d9       	stdsp	sp[0x34],r9
800074b4:	50 e9       	stdsp	sp[0x38],r9
800074b6:	50 b9       	stdsp	sp[0x2c],r9
800074b8:	12 97       	mov	r7,r9
800074ba:	0a 94       	mov	r4,r5
800074bc:	40 a2       	lddsp	r2,sp[0x28]
800074be:	32 5a       	mov	r10,37
800074c0:	30 08       	mov	r8,0
800074c2:	c0 28       	rjmp	800074c6 <_vfprintf_r+0x126>
800074c4:	2f f2       	sub	r2,-1
800074c6:	05 89       	ld.ub	r9,r2[0x0]
800074c8:	f0 09 18 00 	cp.b	r9,r8
800074cc:	5f 1b       	srne	r11
800074ce:	f4 09 18 00 	cp.b	r9,r10
800074d2:	5f 19       	srne	r9
800074d4:	f3 eb 00 0b 	and	r11,r9,r11
800074d8:	f0 0b 18 00 	cp.b	r11,r8
800074dc:	cf 41       	brne	800074c4 <_vfprintf_r+0x124>
800074de:	40 ab       	lddsp	r11,sp[0x28]
800074e0:	e4 0b 01 06 	sub	r6,r2,r11
800074e4:	c1 e0       	breq	80007520 <_vfprintf_r+0x180>
800074e6:	fa f8 06 90 	ld.w	r8,sp[1680]
800074ea:	0c 08       	add	r8,r6
800074ec:	87 0b       	st.w	r3[0x0],r11
800074ee:	fb 48 06 90 	st.w	sp[1680],r8
800074f2:	87 16       	st.w	r3[0x4],r6
800074f4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800074f8:	2f f8       	sub	r8,-1
800074fa:	fb 48 06 8c 	st.w	sp[1676],r8
800074fe:	58 78       	cp.w	r8,7
80007500:	e0 89 00 04 	brgt	80007508 <_vfprintf_r+0x168>
80007504:	2f 83       	sub	r3,-8
80007506:	c0 a8       	rjmp	8000751a <_vfprintf_r+0x17a>
80007508:	fa ca f9 78 	sub	r10,sp,-1672
8000750c:	02 9b       	mov	r11,r1
8000750e:	08 9c       	mov	r12,r4
80007510:	c3 af       	rcall	80007384 <__sprint_r>
80007512:	e0 81 0e c6 	brne	8000929e <_vfprintf_r+0x1efe>
80007516:	fa c3 f9 e0 	sub	r3,sp,-1568
8000751a:	40 ba       	lddsp	r10,sp[0x2c]
8000751c:	0c 0a       	add	r10,r6
8000751e:	50 ba       	stdsp	sp[0x2c],r10
80007520:	05 89       	ld.ub	r9,r2[0x0]
80007522:	30 08       	mov	r8,0
80007524:	f0 09 18 00 	cp.b	r9,r8
80007528:	e0 80 0e aa 	breq	8000927c <_vfprintf_r+0x1edc>
8000752c:	30 09       	mov	r9,0
8000752e:	fb 68 06 bb 	st.b	sp[1723],r8
80007532:	0e 96       	mov	r6,r7
80007534:	e4 c8 ff ff 	sub	r8,r2,-1
80007538:	3f fe       	mov	lr,-1
8000753a:	50 93       	stdsp	sp[0x24],r3
8000753c:	50 41       	stdsp	sp[0x10],r1
8000753e:	0e 93       	mov	r3,r7
80007540:	04 91       	mov	r1,r2
80007542:	50 89       	stdsp	sp[0x20],r9
80007544:	50 a8       	stdsp	sp[0x28],r8
80007546:	50 2e       	stdsp	sp[0x8],lr
80007548:	50 39       	stdsp	sp[0xc],r9
8000754a:	12 95       	mov	r5,r9
8000754c:	12 90       	mov	r0,r9
8000754e:	10 97       	mov	r7,r8
80007550:	08 92       	mov	r2,r4
80007552:	c0 78       	rjmp	80007560 <_vfprintf_r+0x1c0>
80007554:	3f fc       	mov	r12,-1
80007556:	08 97       	mov	r7,r4
80007558:	50 2c       	stdsp	sp[0x8],r12
8000755a:	c0 38       	rjmp	80007560 <_vfprintf_r+0x1c0>
8000755c:	30 0b       	mov	r11,0
8000755e:	50 3b       	stdsp	sp[0xc],r11
80007560:	0f 38       	ld.ub	r8,r7++
80007562:	c0 28       	rjmp	80007566 <_vfprintf_r+0x1c6>
80007564:	12 90       	mov	r0,r9
80007566:	f0 c9 00 20 	sub	r9,r8,32
8000756a:	e0 49 00 58 	cp.w	r9,88
8000756e:	e0 8b 0a 30 	brhi	800089ce <_vfprintf_r+0x162e>
80007572:	fe ca a1 1e 	sub	r10,pc,-24290
80007576:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000757a:	50 a7       	stdsp	sp[0x28],r7
8000757c:	50 80       	stdsp	sp[0x20],r0
8000757e:	0c 97       	mov	r7,r6
80007580:	04 94       	mov	r4,r2
80007582:	06 96       	mov	r6,r3
80007584:	02 92       	mov	r2,r1
80007586:	fe c9 9e f6 	sub	r9,pc,-24842
8000758a:	40 93       	lddsp	r3,sp[0x24]
8000758c:	10 90       	mov	r0,r8
8000758e:	40 41       	lddsp	r1,sp[0x10]
80007590:	50 d9       	stdsp	sp[0x34],r9
80007592:	e0 8f 08 8e 	bral	800086ae <_vfprintf_r+0x130e>
80007596:	30 08       	mov	r8,0
80007598:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000759c:	f0 09 18 00 	cp.b	r9,r8
800075a0:	ce 01       	brne	80007560 <_vfprintf_r+0x1c0>
800075a2:	32 08       	mov	r8,32
800075a4:	c6 e8       	rjmp	80007680 <_vfprintf_r+0x2e0>
800075a6:	a1 a5       	sbr	r5,0x0
800075a8:	cd cb       	rjmp	80007560 <_vfprintf_r+0x1c0>
800075aa:	0f 89       	ld.ub	r9,r7[0x0]
800075ac:	f2 c8 00 30 	sub	r8,r9,48
800075b0:	58 98       	cp.w	r8,9
800075b2:	e0 8b 00 1d 	brhi	800075ec <_vfprintf_r+0x24c>
800075b6:	ee c8 ff ff 	sub	r8,r7,-1
800075ba:	30 0b       	mov	r11,0
800075bc:	23 09       	sub	r9,48
800075be:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800075c2:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800075c6:	11 39       	ld.ub	r9,r8++
800075c8:	f2 ca 00 30 	sub	r10,r9,48
800075cc:	58 9a       	cp.w	r10,9
800075ce:	fe 98 ff f7 	brls	800075bc <_vfprintf_r+0x21c>
800075d2:	e0 49 00 24 	cp.w	r9,36
800075d6:	cc 31       	brne	8000755c <_vfprintf_r+0x1bc>
800075d8:	e0 4b 00 20 	cp.w	r11,32
800075dc:	e0 89 0e 60 	brgt	8000929c <_vfprintf_r+0x1efc>
800075e0:	20 1b       	sub	r11,1
800075e2:	fa f9 06 b4 	ld.w	r9,sp[1716]
800075e6:	12 3b       	cp.w	r11,r9
800075e8:	c0 95       	brlt	800075fa <_vfprintf_r+0x25a>
800075ea:	c1 08       	rjmp	8000760a <_vfprintf_r+0x26a>
800075ec:	fa f9 06 b4 	ld.w	r9,sp[1716]
800075f0:	ec ca ff ff 	sub	r10,r6,-1
800075f4:	12 36       	cp.w	r6,r9
800075f6:	c1 f5       	brlt	80007634 <_vfprintf_r+0x294>
800075f8:	c2 68       	rjmp	80007644 <_vfprintf_r+0x2a4>
800075fa:	fa ce f9 44 	sub	lr,sp,-1724
800075fe:	10 97       	mov	r7,r8
80007600:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007604:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007608:	c3 58       	rjmp	80007672 <_vfprintf_r+0x2d2>
8000760a:	10 97       	mov	r7,r8
8000760c:	fa c8 f9 50 	sub	r8,sp,-1712
80007610:	1a d8       	st.w	--sp,r8
80007612:	fa c8 fa b8 	sub	r8,sp,-1352
80007616:	1a d8       	st.w	--sp,r8
80007618:	fa c8 fb b4 	sub	r8,sp,-1100
8000761c:	02 9a       	mov	r10,r1
8000761e:	1a d8       	st.w	--sp,r8
80007620:	04 9c       	mov	r12,r2
80007622:	fa c8 f9 40 	sub	r8,sp,-1728
80007626:	fa c9 ff b4 	sub	r9,sp,-76
8000762a:	fe b0 fd 23 	rcall	80007070 <get_arg>
8000762e:	2f dd       	sub	sp,-12
80007630:	78 00       	ld.w	r0,r12[0x0]
80007632:	c2 08       	rjmp	80007672 <_vfprintf_r+0x2d2>
80007634:	fa cc f9 44 	sub	r12,sp,-1724
80007638:	14 96       	mov	r6,r10
8000763a:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000763e:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007642:	c1 88       	rjmp	80007672 <_vfprintf_r+0x2d2>
80007644:	41 08       	lddsp	r8,sp[0x40]
80007646:	59 f9       	cp.w	r9,31
80007648:	e0 89 00 11 	brgt	8000766a <_vfprintf_r+0x2ca>
8000764c:	f0 cb ff fc 	sub	r11,r8,-4
80007650:	51 0b       	stdsp	sp[0x40],r11
80007652:	70 00       	ld.w	r0,r8[0x0]
80007654:	fa cb f9 44 	sub	r11,sp,-1724
80007658:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000765c:	f1 40 fd 88 	st.w	r8[-632],r0
80007660:	2f f9       	sub	r9,-1
80007662:	14 96       	mov	r6,r10
80007664:	fb 49 06 b4 	st.w	sp[1716],r9
80007668:	c0 58       	rjmp	80007672 <_vfprintf_r+0x2d2>
8000766a:	70 00       	ld.w	r0,r8[0x0]
8000766c:	14 96       	mov	r6,r10
8000766e:	2f c8       	sub	r8,-4
80007670:	51 08       	stdsp	sp[0x40],r8
80007672:	58 00       	cp.w	r0,0
80007674:	fe 94 ff 76 	brge	80007560 <_vfprintf_r+0x1c0>
80007678:	5c 30       	neg	r0
8000767a:	a3 a5       	sbr	r5,0x2
8000767c:	c7 2b       	rjmp	80007560 <_vfprintf_r+0x1c0>
8000767e:	32 b8       	mov	r8,43
80007680:	fb 68 06 bb 	st.b	sp[1723],r8
80007684:	c6 eb       	rjmp	80007560 <_vfprintf_r+0x1c0>
80007686:	0f 38       	ld.ub	r8,r7++
80007688:	e0 48 00 2a 	cp.w	r8,42
8000768c:	c0 30       	breq	80007692 <_vfprintf_r+0x2f2>
8000768e:	30 09       	mov	r9,0
80007690:	c7 98       	rjmp	80007782 <_vfprintf_r+0x3e2>
80007692:	0f 88       	ld.ub	r8,r7[0x0]
80007694:	f0 c9 00 30 	sub	r9,r8,48
80007698:	58 99       	cp.w	r9,9
8000769a:	e0 8b 00 1f 	brhi	800076d8 <_vfprintf_r+0x338>
8000769e:	ee c4 ff ff 	sub	r4,r7,-1
800076a2:	30 0b       	mov	r11,0
800076a4:	23 08       	sub	r8,48
800076a6:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800076aa:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800076ae:	09 38       	ld.ub	r8,r4++
800076b0:	f0 c9 00 30 	sub	r9,r8,48
800076b4:	58 99       	cp.w	r9,9
800076b6:	fe 98 ff f7 	brls	800076a4 <_vfprintf_r+0x304>
800076ba:	e0 48 00 24 	cp.w	r8,36
800076be:	fe 91 ff 4f 	brne	8000755c <_vfprintf_r+0x1bc>
800076c2:	e0 4b 00 20 	cp.w	r11,32
800076c6:	e0 89 0d eb 	brgt	8000929c <_vfprintf_r+0x1efc>
800076ca:	20 1b       	sub	r11,1
800076cc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800076d0:	10 3b       	cp.w	r11,r8
800076d2:	c0 a5       	brlt	800076e6 <_vfprintf_r+0x346>
800076d4:	c1 18       	rjmp	800076f6 <_vfprintf_r+0x356>
800076d6:	d7 03       	nop
800076d8:	fa fa 06 b4 	ld.w	r10,sp[1716]
800076dc:	ec c9 ff ff 	sub	r9,r6,-1
800076e0:	14 36       	cp.w	r6,r10
800076e2:	c1 f5       	brlt	80007720 <_vfprintf_r+0x380>
800076e4:	c2 88       	rjmp	80007734 <_vfprintf_r+0x394>
800076e6:	fa ca f9 44 	sub	r10,sp,-1724
800076ea:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800076ee:	f6 fb fd 88 	ld.w	r11,r11[-632]
800076f2:	50 2b       	stdsp	sp[0x8],r11
800076f4:	c3 c8       	rjmp	8000776c <_vfprintf_r+0x3cc>
800076f6:	fa c8 f9 50 	sub	r8,sp,-1712
800076fa:	1a d8       	st.w	--sp,r8
800076fc:	fa c8 fa b8 	sub	r8,sp,-1352
80007700:	1a d8       	st.w	--sp,r8
80007702:	fa c8 fb b4 	sub	r8,sp,-1100
80007706:	02 9a       	mov	r10,r1
80007708:	1a d8       	st.w	--sp,r8
8000770a:	04 9c       	mov	r12,r2
8000770c:	fa c8 f9 40 	sub	r8,sp,-1728
80007710:	fa c9 ff b4 	sub	r9,sp,-76
80007714:	fe b0 fc ae 	rcall	80007070 <get_arg>
80007718:	2f dd       	sub	sp,-12
8000771a:	78 0c       	ld.w	r12,r12[0x0]
8000771c:	50 2c       	stdsp	sp[0x8],r12
8000771e:	c2 78       	rjmp	8000776c <_vfprintf_r+0x3cc>
80007720:	12 96       	mov	r6,r9
80007722:	0e 94       	mov	r4,r7
80007724:	fa c9 f9 44 	sub	r9,sp,-1724
80007728:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000772c:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007730:	50 28       	stdsp	sp[0x8],r8
80007732:	c1 d8       	rjmp	8000776c <_vfprintf_r+0x3cc>
80007734:	41 08       	lddsp	r8,sp[0x40]
80007736:	59 fa       	cp.w	r10,31
80007738:	e0 89 00 14 	brgt	80007760 <_vfprintf_r+0x3c0>
8000773c:	f0 cb ff fc 	sub	r11,r8,-4
80007740:	70 08       	ld.w	r8,r8[0x0]
80007742:	51 0b       	stdsp	sp[0x40],r11
80007744:	50 28       	stdsp	sp[0x8],r8
80007746:	fa c6 f9 44 	sub	r6,sp,-1724
8000774a:	40 2e       	lddsp	lr,sp[0x8]
8000774c:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007750:	f1 4e fd 88 	st.w	r8[-632],lr
80007754:	2f fa       	sub	r10,-1
80007756:	0e 94       	mov	r4,r7
80007758:	fb 4a 06 b4 	st.w	sp[1716],r10
8000775c:	12 96       	mov	r6,r9
8000775e:	c0 78       	rjmp	8000776c <_vfprintf_r+0x3cc>
80007760:	70 0c       	ld.w	r12,r8[0x0]
80007762:	0e 94       	mov	r4,r7
80007764:	2f c8       	sub	r8,-4
80007766:	50 2c       	stdsp	sp[0x8],r12
80007768:	12 96       	mov	r6,r9
8000776a:	51 08       	stdsp	sp[0x40],r8
8000776c:	40 2b       	lddsp	r11,sp[0x8]
8000776e:	58 0b       	cp.w	r11,0
80007770:	fe 95 fe f2 	brlt	80007554 <_vfprintf_r+0x1b4>
80007774:	08 97       	mov	r7,r4
80007776:	cf 5a       	rjmp	80007560 <_vfprintf_r+0x1c0>
80007778:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000777c:	0f 38       	ld.ub	r8,r7++
8000777e:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007782:	f0 ca 00 30 	sub	r10,r8,48
80007786:	58 9a       	cp.w	r10,9
80007788:	fe 98 ff f8 	brls	80007778 <_vfprintf_r+0x3d8>
8000778c:	3f fa       	mov	r10,-1
8000778e:	f2 0a 0c 49 	max	r9,r9,r10
80007792:	50 29       	stdsp	sp[0x8],r9
80007794:	ce 9a       	rjmp	80007566 <_vfprintf_r+0x1c6>
80007796:	a7 b5       	sbr	r5,0x7
80007798:	ce 4a       	rjmp	80007560 <_vfprintf_r+0x1c0>
8000779a:	30 09       	mov	r9,0
8000779c:	23 08       	sub	r8,48
8000779e:	f2 09 00 29 	add	r9,r9,r9<<0x2
800077a2:	f0 09 00 19 	add	r9,r8,r9<<0x1
800077a6:	0f 38       	ld.ub	r8,r7++
800077a8:	f0 ca 00 30 	sub	r10,r8,48
800077ac:	58 9a       	cp.w	r10,9
800077ae:	fe 98 ff f7 	brls	8000779c <_vfprintf_r+0x3fc>
800077b2:	e0 48 00 24 	cp.w	r8,36
800077b6:	fe 91 fe d7 	brne	80007564 <_vfprintf_r+0x1c4>
800077ba:	e0 49 00 20 	cp.w	r9,32
800077be:	e0 89 0d 6f 	brgt	8000929c <_vfprintf_r+0x1efc>
800077c2:	f2 c3 00 01 	sub	r3,r9,1
800077c6:	30 19       	mov	r9,1
800077c8:	50 39       	stdsp	sp[0xc],r9
800077ca:	cc ba       	rjmp	80007560 <_vfprintf_r+0x1c0>
800077cc:	a3 b5       	sbr	r5,0x3
800077ce:	cc 9a       	rjmp	80007560 <_vfprintf_r+0x1c0>
800077d0:	a7 a5       	sbr	r5,0x6
800077d2:	cc 7a       	rjmp	80007560 <_vfprintf_r+0x1c0>
800077d4:	0a 98       	mov	r8,r5
800077d6:	a5 b5       	sbr	r5,0x5
800077d8:	a5 a8       	sbr	r8,0x4
800077da:	0f 89       	ld.ub	r9,r7[0x0]
800077dc:	36 ce       	mov	lr,108
800077de:	fc 09 18 00 	cp.b	r9,lr
800077e2:	f7 b7 00 ff 	subeq	r7,-1
800077e6:	f0 05 17 10 	movne	r5,r8
800077ea:	cb ba       	rjmp	80007560 <_vfprintf_r+0x1c0>
800077ec:	a5 b5       	sbr	r5,0x5
800077ee:	cb 9a       	rjmp	80007560 <_vfprintf_r+0x1c0>
800077f0:	50 a7       	stdsp	sp[0x28],r7
800077f2:	50 80       	stdsp	sp[0x20],r0
800077f4:	0c 97       	mov	r7,r6
800077f6:	10 90       	mov	r0,r8
800077f8:	06 96       	mov	r6,r3
800077fa:	04 94       	mov	r4,r2
800077fc:	40 93       	lddsp	r3,sp[0x24]
800077fe:	02 92       	mov	r2,r1
80007800:	0e 99       	mov	r9,r7
80007802:	40 41       	lddsp	r1,sp[0x10]
80007804:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007808:	40 3c       	lddsp	r12,sp[0xc]
8000780a:	58 0c       	cp.w	r12,0
8000780c:	c1 d0       	breq	80007846 <_vfprintf_r+0x4a6>
8000780e:	10 36       	cp.w	r6,r8
80007810:	c0 64       	brge	8000781c <_vfprintf_r+0x47c>
80007812:	fa cb f9 44 	sub	r11,sp,-1724
80007816:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000781a:	c1 d8       	rjmp	80007854 <_vfprintf_r+0x4b4>
8000781c:	fa c8 f9 50 	sub	r8,sp,-1712
80007820:	1a d8       	st.w	--sp,r8
80007822:	fa c8 fa b8 	sub	r8,sp,-1352
80007826:	1a d8       	st.w	--sp,r8
80007828:	fa c8 fb b4 	sub	r8,sp,-1100
8000782c:	1a d8       	st.w	--sp,r8
8000782e:	fa c8 f9 40 	sub	r8,sp,-1728
80007832:	fa c9 ff b4 	sub	r9,sp,-76
80007836:	04 9a       	mov	r10,r2
80007838:	0c 9b       	mov	r11,r6
8000783a:	08 9c       	mov	r12,r4
8000783c:	fe b0 fc 1a 	rcall	80007070 <get_arg>
80007840:	2f dd       	sub	sp,-12
80007842:	19 b8       	ld.ub	r8,r12[0x3]
80007844:	c2 28       	rjmp	80007888 <_vfprintf_r+0x4e8>
80007846:	2f f7       	sub	r7,-1
80007848:	10 39       	cp.w	r9,r8
8000784a:	c0 84       	brge	8000785a <_vfprintf_r+0x4ba>
8000784c:	fa ca f9 44 	sub	r10,sp,-1724
80007850:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007854:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007858:	c1 88       	rjmp	80007888 <_vfprintf_r+0x4e8>
8000785a:	41 09       	lddsp	r9,sp[0x40]
8000785c:	59 f8       	cp.w	r8,31
8000785e:	e0 89 00 12 	brgt	80007882 <_vfprintf_r+0x4e2>
80007862:	f2 ca ff fc 	sub	r10,r9,-4
80007866:	51 0a       	stdsp	sp[0x40],r10
80007868:	72 09       	ld.w	r9,r9[0x0]
8000786a:	fa c6 f9 44 	sub	r6,sp,-1724
8000786e:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007872:	2f f8       	sub	r8,-1
80007874:	f5 49 fd 88 	st.w	r10[-632],r9
80007878:	fb 48 06 b4 	st.w	sp[1716],r8
8000787c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007880:	c0 48       	rjmp	80007888 <_vfprintf_r+0x4e8>
80007882:	13 b8       	ld.ub	r8,r9[0x3]
80007884:	2f c9       	sub	r9,-4
80007886:	51 09       	stdsp	sp[0x40],r9
80007888:	fb 68 06 60 	st.b	sp[1632],r8
8000788c:	30 0e       	mov	lr,0
8000788e:	30 08       	mov	r8,0
80007890:	30 12       	mov	r2,1
80007892:	fb 68 06 bb 	st.b	sp[1723],r8
80007896:	50 2e       	stdsp	sp[0x8],lr
80007898:	e0 8f 08 ad 	bral	800089f2 <_vfprintf_r+0x1652>
8000789c:	50 a7       	stdsp	sp[0x28],r7
8000789e:	50 80       	stdsp	sp[0x20],r0
800078a0:	0c 97       	mov	r7,r6
800078a2:	04 94       	mov	r4,r2
800078a4:	06 96       	mov	r6,r3
800078a6:	02 92       	mov	r2,r1
800078a8:	40 93       	lddsp	r3,sp[0x24]
800078aa:	10 90       	mov	r0,r8
800078ac:	40 41       	lddsp	r1,sp[0x10]
800078ae:	a5 a5       	sbr	r5,0x4
800078b0:	c0 a8       	rjmp	800078c4 <_vfprintf_r+0x524>
800078b2:	50 a7       	stdsp	sp[0x28],r7
800078b4:	50 80       	stdsp	sp[0x20],r0
800078b6:	0c 97       	mov	r7,r6
800078b8:	04 94       	mov	r4,r2
800078ba:	06 96       	mov	r6,r3
800078bc:	02 92       	mov	r2,r1
800078be:	40 93       	lddsp	r3,sp[0x24]
800078c0:	10 90       	mov	r0,r8
800078c2:	40 41       	lddsp	r1,sp[0x10]
800078c4:	ed b5 00 05 	bld	r5,0x5
800078c8:	c5 11       	brne	8000796a <_vfprintf_r+0x5ca>
800078ca:	fa f8 06 b4 	ld.w	r8,sp[1716]
800078ce:	40 3c       	lddsp	r12,sp[0xc]
800078d0:	58 0c       	cp.w	r12,0
800078d2:	c1 e0       	breq	8000790e <_vfprintf_r+0x56e>
800078d4:	10 36       	cp.w	r6,r8
800078d6:	c0 64       	brge	800078e2 <_vfprintf_r+0x542>
800078d8:	fa cb f9 44 	sub	r11,sp,-1724
800078dc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800078e0:	c2 08       	rjmp	80007920 <_vfprintf_r+0x580>
800078e2:	fa c8 f9 50 	sub	r8,sp,-1712
800078e6:	1a d8       	st.w	--sp,r8
800078e8:	fa c8 fa b8 	sub	r8,sp,-1352
800078ec:	0c 9b       	mov	r11,r6
800078ee:	1a d8       	st.w	--sp,r8
800078f0:	fa c8 fb b4 	sub	r8,sp,-1100
800078f4:	1a d8       	st.w	--sp,r8
800078f6:	fa c9 ff b4 	sub	r9,sp,-76
800078fa:	fa c8 f9 40 	sub	r8,sp,-1728
800078fe:	04 9a       	mov	r10,r2
80007900:	08 9c       	mov	r12,r4
80007902:	fe b0 fb b7 	rcall	80007070 <get_arg>
80007906:	2f dd       	sub	sp,-12
80007908:	78 1b       	ld.w	r11,r12[0x4]
8000790a:	78 09       	ld.w	r9,r12[0x0]
8000790c:	c2 b8       	rjmp	80007962 <_vfprintf_r+0x5c2>
8000790e:	ee ca ff ff 	sub	r10,r7,-1
80007912:	10 37       	cp.w	r7,r8
80007914:	c0 b4       	brge	8000792a <_vfprintf_r+0x58a>
80007916:	fa c9 f9 44 	sub	r9,sp,-1724
8000791a:	14 97       	mov	r7,r10
8000791c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007920:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007924:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007928:	c1 d8       	rjmp	80007962 <_vfprintf_r+0x5c2>
8000792a:	41 09       	lddsp	r9,sp[0x40]
8000792c:	59 f8       	cp.w	r8,31
8000792e:	e0 89 00 14 	brgt	80007956 <_vfprintf_r+0x5b6>
80007932:	f2 cb ff f8 	sub	r11,r9,-8
80007936:	51 0b       	stdsp	sp[0x40],r11
80007938:	fa c6 f9 44 	sub	r6,sp,-1724
8000793c:	72 1b       	ld.w	r11,r9[0x4]
8000793e:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007942:	72 09       	ld.w	r9,r9[0x0]
80007944:	f9 4b fd 8c 	st.w	r12[-628],r11
80007948:	f9 49 fd 88 	st.w	r12[-632],r9
8000794c:	2f f8       	sub	r8,-1
8000794e:	14 97       	mov	r7,r10
80007950:	fb 48 06 b4 	st.w	sp[1716],r8
80007954:	c0 78       	rjmp	80007962 <_vfprintf_r+0x5c2>
80007956:	f2 c8 ff f8 	sub	r8,r9,-8
8000795a:	72 1b       	ld.w	r11,r9[0x4]
8000795c:	14 97       	mov	r7,r10
8000795e:	51 08       	stdsp	sp[0x40],r8
80007960:	72 09       	ld.w	r9,r9[0x0]
80007962:	16 98       	mov	r8,r11
80007964:	fa e9 00 00 	st.d	sp[0],r8
80007968:	ca e8       	rjmp	80007ac4 <_vfprintf_r+0x724>
8000796a:	ed b5 00 04 	bld	r5,0x4
8000796e:	c1 71       	brne	8000799c <_vfprintf_r+0x5fc>
80007970:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007974:	40 3e       	lddsp	lr,sp[0xc]
80007976:	58 0e       	cp.w	lr,0
80007978:	c0 80       	breq	80007988 <_vfprintf_r+0x5e8>
8000797a:	10 36       	cp.w	r6,r8
8000797c:	c6 94       	brge	80007a4e <_vfprintf_r+0x6ae>
8000797e:	fa cc f9 44 	sub	r12,sp,-1724
80007982:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007986:	c8 28       	rjmp	80007a8a <_vfprintf_r+0x6ea>
80007988:	ee ca ff ff 	sub	r10,r7,-1
8000798c:	10 37       	cp.w	r7,r8
8000798e:	e0 84 00 81 	brge	80007a90 <_vfprintf_r+0x6f0>
80007992:	fa cb f9 44 	sub	r11,sp,-1724
80007996:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000799a:	c7 78       	rjmp	80007a88 <_vfprintf_r+0x6e8>
8000799c:	ed b5 00 06 	bld	r5,0x6
800079a0:	c4 b1       	brne	80007a36 <_vfprintf_r+0x696>
800079a2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800079a6:	40 3c       	lddsp	r12,sp[0xc]
800079a8:	58 0c       	cp.w	r12,0
800079aa:	c1 d0       	breq	800079e4 <_vfprintf_r+0x644>
800079ac:	10 36       	cp.w	r6,r8
800079ae:	c0 64       	brge	800079ba <_vfprintf_r+0x61a>
800079b0:	fa cb f9 44 	sub	r11,sp,-1724
800079b4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800079b8:	c1 f8       	rjmp	800079f6 <_vfprintf_r+0x656>
800079ba:	fa c8 f9 50 	sub	r8,sp,-1712
800079be:	1a d8       	st.w	--sp,r8
800079c0:	fa c8 fa b8 	sub	r8,sp,-1352
800079c4:	1a d8       	st.w	--sp,r8
800079c6:	fa c8 fb b4 	sub	r8,sp,-1100
800079ca:	1a d8       	st.w	--sp,r8
800079cc:	fa c8 f9 40 	sub	r8,sp,-1728
800079d0:	fa c9 ff b4 	sub	r9,sp,-76
800079d4:	04 9a       	mov	r10,r2
800079d6:	0c 9b       	mov	r11,r6
800079d8:	08 9c       	mov	r12,r4
800079da:	fe b0 fb 4b 	rcall	80007070 <get_arg>
800079de:	2f dd       	sub	sp,-12
800079e0:	98 18       	ld.sh	r8,r12[0x2]
800079e2:	c2 68       	rjmp	80007a2e <_vfprintf_r+0x68e>
800079e4:	ee ca ff ff 	sub	r10,r7,-1
800079e8:	10 37       	cp.w	r7,r8
800079ea:	c0 94       	brge	800079fc <_vfprintf_r+0x65c>
800079ec:	fa c9 f9 44 	sub	r9,sp,-1724
800079f0:	14 97       	mov	r7,r10
800079f2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800079f6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800079fa:	c1 a8       	rjmp	80007a2e <_vfprintf_r+0x68e>
800079fc:	41 09       	lddsp	r9,sp[0x40]
800079fe:	59 f8       	cp.w	r8,31
80007a00:	e0 89 00 13 	brgt	80007a26 <_vfprintf_r+0x686>
80007a04:	f2 cb ff fc 	sub	r11,r9,-4
80007a08:	51 0b       	stdsp	sp[0x40],r11
80007a0a:	72 09       	ld.w	r9,r9[0x0]
80007a0c:	fa c6 f9 44 	sub	r6,sp,-1724
80007a10:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007a14:	2f f8       	sub	r8,-1
80007a16:	f7 49 fd 88 	st.w	r11[-632],r9
80007a1a:	fb 48 06 b4 	st.w	sp[1716],r8
80007a1e:	14 97       	mov	r7,r10
80007a20:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007a24:	c0 58       	rjmp	80007a2e <_vfprintf_r+0x68e>
80007a26:	92 18       	ld.sh	r8,r9[0x2]
80007a28:	14 97       	mov	r7,r10
80007a2a:	2f c9       	sub	r9,-4
80007a2c:	51 09       	stdsp	sp[0x40],r9
80007a2e:	50 18       	stdsp	sp[0x4],r8
80007a30:	bf 58       	asr	r8,0x1f
80007a32:	50 08       	stdsp	sp[0x0],r8
80007a34:	c4 88       	rjmp	80007ac4 <_vfprintf_r+0x724>
80007a36:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007a3a:	40 3c       	lddsp	r12,sp[0xc]
80007a3c:	58 0c       	cp.w	r12,0
80007a3e:	c1 d0       	breq	80007a78 <_vfprintf_r+0x6d8>
80007a40:	10 36       	cp.w	r6,r8
80007a42:	c0 64       	brge	80007a4e <_vfprintf_r+0x6ae>
80007a44:	fa cb f9 44 	sub	r11,sp,-1724
80007a48:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007a4c:	c1 f8       	rjmp	80007a8a <_vfprintf_r+0x6ea>
80007a4e:	fa c8 f9 50 	sub	r8,sp,-1712
80007a52:	1a d8       	st.w	--sp,r8
80007a54:	fa c8 fa b8 	sub	r8,sp,-1352
80007a58:	0c 9b       	mov	r11,r6
80007a5a:	1a d8       	st.w	--sp,r8
80007a5c:	fa c8 fb b4 	sub	r8,sp,-1100
80007a60:	04 9a       	mov	r10,r2
80007a62:	1a d8       	st.w	--sp,r8
80007a64:	08 9c       	mov	r12,r4
80007a66:	fa c8 f9 40 	sub	r8,sp,-1728
80007a6a:	fa c9 ff b4 	sub	r9,sp,-76
80007a6e:	fe b0 fb 01 	rcall	80007070 <get_arg>
80007a72:	2f dd       	sub	sp,-12
80007a74:	78 0b       	ld.w	r11,r12[0x0]
80007a76:	c2 48       	rjmp	80007abe <_vfprintf_r+0x71e>
80007a78:	ee ca ff ff 	sub	r10,r7,-1
80007a7c:	10 37       	cp.w	r7,r8
80007a7e:	c0 94       	brge	80007a90 <_vfprintf_r+0x6f0>
80007a80:	fa c9 f9 44 	sub	r9,sp,-1724
80007a84:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007a88:	14 97       	mov	r7,r10
80007a8a:	ec fb fd 88 	ld.w	r11,r6[-632]
80007a8e:	c1 88       	rjmp	80007abe <_vfprintf_r+0x71e>
80007a90:	41 09       	lddsp	r9,sp[0x40]
80007a92:	59 f8       	cp.w	r8,31
80007a94:	e0 89 00 11 	brgt	80007ab6 <_vfprintf_r+0x716>
80007a98:	f2 cb ff fc 	sub	r11,r9,-4
80007a9c:	51 0b       	stdsp	sp[0x40],r11
80007a9e:	fa c6 f9 44 	sub	r6,sp,-1724
80007aa2:	72 0b       	ld.w	r11,r9[0x0]
80007aa4:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007aa8:	f3 4b fd 88 	st.w	r9[-632],r11
80007aac:	2f f8       	sub	r8,-1
80007aae:	14 97       	mov	r7,r10
80007ab0:	fb 48 06 b4 	st.w	sp[1716],r8
80007ab4:	c0 58       	rjmp	80007abe <_vfprintf_r+0x71e>
80007ab6:	72 0b       	ld.w	r11,r9[0x0]
80007ab8:	14 97       	mov	r7,r10
80007aba:	2f c9       	sub	r9,-4
80007abc:	51 09       	stdsp	sp[0x40],r9
80007abe:	50 1b       	stdsp	sp[0x4],r11
80007ac0:	bf 5b       	asr	r11,0x1f
80007ac2:	50 0b       	stdsp	sp[0x0],r11
80007ac4:	fa ea 00 00 	ld.d	r10,sp[0]
80007ac8:	58 0a       	cp.w	r10,0
80007aca:	5c 2b       	cpc	r11
80007acc:	c0 e4       	brge	80007ae8 <_vfprintf_r+0x748>
80007ace:	30 08       	mov	r8,0
80007ad0:	fa ea 00 00 	ld.d	r10,sp[0]
80007ad4:	30 09       	mov	r9,0
80007ad6:	f0 0a 01 0a 	sub	r10,r8,r10
80007ada:	f2 0b 01 4b 	sbc	r11,r9,r11
80007ade:	32 d8       	mov	r8,45
80007ae0:	fa eb 00 00 	st.d	sp[0],r10
80007ae4:	fb 68 06 bb 	st.b	sp[1723],r8
80007ae8:	30 18       	mov	r8,1
80007aea:	e0 8f 06 fa 	bral	800088de <_vfprintf_r+0x153e>
80007aee:	50 a7       	stdsp	sp[0x28],r7
80007af0:	50 80       	stdsp	sp[0x20],r0
80007af2:	0c 97       	mov	r7,r6
80007af4:	04 94       	mov	r4,r2
80007af6:	06 96       	mov	r6,r3
80007af8:	02 92       	mov	r2,r1
80007afa:	40 93       	lddsp	r3,sp[0x24]
80007afc:	10 90       	mov	r0,r8
80007afe:	40 41       	lddsp	r1,sp[0x10]
80007b00:	0e 99       	mov	r9,r7
80007b02:	ed b5 00 03 	bld	r5,0x3
80007b06:	c4 11       	brne	80007b88 <_vfprintf_r+0x7e8>
80007b08:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007b0c:	40 3a       	lddsp	r10,sp[0xc]
80007b0e:	58 0a       	cp.w	r10,0
80007b10:	c1 90       	breq	80007b42 <_vfprintf_r+0x7a2>
80007b12:	10 36       	cp.w	r6,r8
80007b14:	c6 45       	brlt	80007bdc <_vfprintf_r+0x83c>
80007b16:	fa c8 f9 50 	sub	r8,sp,-1712
80007b1a:	1a d8       	st.w	--sp,r8
80007b1c:	fa c8 fa b8 	sub	r8,sp,-1352
80007b20:	1a d8       	st.w	--sp,r8
80007b22:	fa c8 fb b4 	sub	r8,sp,-1100
80007b26:	0c 9b       	mov	r11,r6
80007b28:	1a d8       	st.w	--sp,r8
80007b2a:	04 9a       	mov	r10,r2
80007b2c:	fa c8 f9 40 	sub	r8,sp,-1728
80007b30:	fa c9 ff b4 	sub	r9,sp,-76
80007b34:	08 9c       	mov	r12,r4
80007b36:	fe b0 fa 9d 	rcall	80007070 <get_arg>
80007b3a:	2f dd       	sub	sp,-12
80007b3c:	78 16       	ld.w	r6,r12[0x4]
80007b3e:	50 76       	stdsp	sp[0x1c],r6
80007b40:	c4 88       	rjmp	80007bd0 <_vfprintf_r+0x830>
80007b42:	2f f7       	sub	r7,-1
80007b44:	10 39       	cp.w	r9,r8
80007b46:	c0 c4       	brge	80007b5e <_vfprintf_r+0x7be>
80007b48:	fa ce f9 44 	sub	lr,sp,-1724
80007b4c:	fc 06 00 36 	add	r6,lr,r6<<0x3
80007b50:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007b54:	50 7c       	stdsp	sp[0x1c],r12
80007b56:	ec f6 fd 88 	ld.w	r6,r6[-632]
80007b5a:	50 56       	stdsp	sp[0x14],r6
80007b5c:	c6 68       	rjmp	80007c28 <_vfprintf_r+0x888>
80007b5e:	41 09       	lddsp	r9,sp[0x40]
80007b60:	59 f8       	cp.w	r8,31
80007b62:	e0 89 00 10 	brgt	80007b82 <_vfprintf_r+0x7e2>
80007b66:	f2 ca ff f8 	sub	r10,r9,-8
80007b6a:	72 1b       	ld.w	r11,r9[0x4]
80007b6c:	51 0a       	stdsp	sp[0x40],r10
80007b6e:	72 09       	ld.w	r9,r9[0x0]
80007b70:	fa ca f9 44 	sub	r10,sp,-1724
80007b74:	50 7b       	stdsp	sp[0x1c],r11
80007b76:	50 59       	stdsp	sp[0x14],r9
80007b78:	f4 08 00 39 	add	r9,r10,r8<<0x3
80007b7c:	40 5b       	lddsp	r11,sp[0x14]
80007b7e:	40 7a       	lddsp	r10,sp[0x1c]
80007b80:	c4 78       	rjmp	80007c0e <_vfprintf_r+0x86e>
80007b82:	72 18       	ld.w	r8,r9[0x4]
80007b84:	50 78       	stdsp	sp[0x1c],r8
80007b86:	c4 c8       	rjmp	80007c1e <_vfprintf_r+0x87e>
80007b88:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007b8c:	40 3e       	lddsp	lr,sp[0xc]
80007b8e:	58 0e       	cp.w	lr,0
80007b90:	c2 30       	breq	80007bd6 <_vfprintf_r+0x836>
80007b92:	10 36       	cp.w	r6,r8
80007b94:	c0 94       	brge	80007ba6 <_vfprintf_r+0x806>
80007b96:	fa cc f9 44 	sub	r12,sp,-1724
80007b9a:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007b9e:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007ba2:	50 7b       	stdsp	sp[0x1c],r11
80007ba4:	cd 9b       	rjmp	80007b56 <_vfprintf_r+0x7b6>
80007ba6:	fa c8 f9 50 	sub	r8,sp,-1712
80007baa:	1a d8       	st.w	--sp,r8
80007bac:	fa c8 fa b8 	sub	r8,sp,-1352
80007bb0:	04 9a       	mov	r10,r2
80007bb2:	1a d8       	st.w	--sp,r8
80007bb4:	fa c8 fb b4 	sub	r8,sp,-1100
80007bb8:	0c 9b       	mov	r11,r6
80007bba:	1a d8       	st.w	--sp,r8
80007bbc:	08 9c       	mov	r12,r4
80007bbe:	fa c8 f9 40 	sub	r8,sp,-1728
80007bc2:	fa c9 ff b4 	sub	r9,sp,-76
80007bc6:	fe b0 fa 55 	rcall	80007070 <get_arg>
80007bca:	2f dd       	sub	sp,-12
80007bcc:	78 1a       	ld.w	r10,r12[0x4]
80007bce:	50 7a       	stdsp	sp[0x1c],r10
80007bd0:	78 0c       	ld.w	r12,r12[0x0]
80007bd2:	50 5c       	stdsp	sp[0x14],r12
80007bd4:	c2 a8       	rjmp	80007c28 <_vfprintf_r+0x888>
80007bd6:	2f f7       	sub	r7,-1
80007bd8:	10 39       	cp.w	r9,r8
80007bda:	c0 94       	brge	80007bec <_vfprintf_r+0x84c>
80007bdc:	fa c9 f9 44 	sub	r9,sp,-1724
80007be0:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007be4:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80007be8:	50 78       	stdsp	sp[0x1c],r8
80007bea:	cb 6b       	rjmp	80007b56 <_vfprintf_r+0x7b6>
80007bec:	41 09       	lddsp	r9,sp[0x40]
80007bee:	59 f8       	cp.w	r8,31
80007bf0:	e0 89 00 15 	brgt	80007c1a <_vfprintf_r+0x87a>
80007bf4:	f2 ca ff f8 	sub	r10,r9,-8
80007bf8:	72 16       	ld.w	r6,r9[0x4]
80007bfa:	72 09       	ld.w	r9,r9[0x0]
80007bfc:	51 0a       	stdsp	sp[0x40],r10
80007bfe:	50 59       	stdsp	sp[0x14],r9
80007c00:	fa ce f9 44 	sub	lr,sp,-1724
80007c04:	50 76       	stdsp	sp[0x1c],r6
80007c06:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007c0a:	40 5b       	lddsp	r11,sp[0x14]
80007c0c:	0c 9a       	mov	r10,r6
80007c0e:	f2 eb fd 88 	st.d	r9[-632],r10
80007c12:	2f f8       	sub	r8,-1
80007c14:	fb 48 06 b4 	st.w	sp[1716],r8
80007c18:	c0 88       	rjmp	80007c28 <_vfprintf_r+0x888>
80007c1a:	72 1c       	ld.w	r12,r9[0x4]
80007c1c:	50 7c       	stdsp	sp[0x1c],r12
80007c1e:	f2 c8 ff f8 	sub	r8,r9,-8
80007c22:	51 08       	stdsp	sp[0x40],r8
80007c24:	72 09       	ld.w	r9,r9[0x0]
80007c26:	50 59       	stdsp	sp[0x14],r9
80007c28:	40 5b       	lddsp	r11,sp[0x14]
80007c2a:	40 7a       	lddsp	r10,sp[0x1c]
80007c2c:	e0 a0 19 54 	rcall	8000aed4 <__isinfd>
80007c30:	18 96       	mov	r6,r12
80007c32:	c1 70       	breq	80007c60 <_vfprintf_r+0x8c0>
80007c34:	30 08       	mov	r8,0
80007c36:	30 09       	mov	r9,0
80007c38:	40 5b       	lddsp	r11,sp[0x14]
80007c3a:	40 7a       	lddsp	r10,sp[0x1c]
80007c3c:	e0 a0 1d a8 	rcall	8000b78c <__avr32_f64_cmp_lt>
80007c40:	c0 40       	breq	80007c48 <_vfprintf_r+0x8a8>
80007c42:	32 d8       	mov	r8,45
80007c44:	fb 68 06 bb 	st.b	sp[1723],r8
80007c48:	fe c8 a5 a4 	sub	r8,pc,-23132
80007c4c:	fe c6 a5 a4 	sub	r6,pc,-23132
80007c50:	a7 d5       	cbr	r5,0x7
80007c52:	e0 40 00 47 	cp.w	r0,71
80007c56:	f0 06 17 a0 	movle	r6,r8
80007c5a:	30 32       	mov	r2,3
80007c5c:	e0 8f 06 ce 	bral	800089f8 <_vfprintf_r+0x1658>
80007c60:	40 5b       	lddsp	r11,sp[0x14]
80007c62:	40 7a       	lddsp	r10,sp[0x1c]
80007c64:	e0 a0 19 4d 	rcall	8000aefe <__isnand>
80007c68:	c0 e0       	breq	80007c84 <_vfprintf_r+0x8e4>
80007c6a:	50 26       	stdsp	sp[0x8],r6
80007c6c:	fe c8 a5 c0 	sub	r8,pc,-23104
80007c70:	fe c6 a5 c0 	sub	r6,pc,-23104
80007c74:	a7 d5       	cbr	r5,0x7
80007c76:	e0 40 00 47 	cp.w	r0,71
80007c7a:	f0 06 17 a0 	movle	r6,r8
80007c7e:	30 32       	mov	r2,3
80007c80:	e0 8f 06 c2 	bral	80008a04 <_vfprintf_r+0x1664>
80007c84:	40 2a       	lddsp	r10,sp[0x8]
80007c86:	5b fa       	cp.w	r10,-1
80007c88:	c0 41       	brne	80007c90 <_vfprintf_r+0x8f0>
80007c8a:	30 69       	mov	r9,6
80007c8c:	50 29       	stdsp	sp[0x8],r9
80007c8e:	c1 18       	rjmp	80007cb0 <_vfprintf_r+0x910>
80007c90:	e0 40 00 47 	cp.w	r0,71
80007c94:	5f 09       	sreq	r9
80007c96:	e0 40 00 67 	cp.w	r0,103
80007c9a:	5f 08       	sreq	r8
80007c9c:	f3 e8 10 08 	or	r8,r9,r8
80007ca0:	f8 08 18 00 	cp.b	r8,r12
80007ca4:	c0 60       	breq	80007cb0 <_vfprintf_r+0x910>
80007ca6:	40 28       	lddsp	r8,sp[0x8]
80007ca8:	58 08       	cp.w	r8,0
80007caa:	f9 b8 00 01 	moveq	r8,1
80007cae:	50 28       	stdsp	sp[0x8],r8
80007cb0:	40 78       	lddsp	r8,sp[0x1c]
80007cb2:	40 59       	lddsp	r9,sp[0x14]
80007cb4:	fa e9 06 94 	st.d	sp[1684],r8
80007cb8:	a9 a5       	sbr	r5,0x8
80007cba:	fa f8 06 94 	ld.w	r8,sp[1684]
80007cbe:	58 08       	cp.w	r8,0
80007cc0:	c0 65       	brlt	80007ccc <_vfprintf_r+0x92c>
80007cc2:	40 5e       	lddsp	lr,sp[0x14]
80007cc4:	30 0c       	mov	r12,0
80007cc6:	50 6e       	stdsp	sp[0x18],lr
80007cc8:	50 9c       	stdsp	sp[0x24],r12
80007cca:	c0 78       	rjmp	80007cd8 <_vfprintf_r+0x938>
80007ccc:	40 5b       	lddsp	r11,sp[0x14]
80007cce:	32 da       	mov	r10,45
80007cd0:	ee 1b 80 00 	eorh	r11,0x8000
80007cd4:	50 9a       	stdsp	sp[0x24],r10
80007cd6:	50 6b       	stdsp	sp[0x18],r11
80007cd8:	e0 40 00 46 	cp.w	r0,70
80007cdc:	5f 09       	sreq	r9
80007cde:	e0 40 00 66 	cp.w	r0,102
80007ce2:	5f 08       	sreq	r8
80007ce4:	f3 e8 10 08 	or	r8,r9,r8
80007ce8:	50 48       	stdsp	sp[0x10],r8
80007cea:	c0 40       	breq	80007cf2 <_vfprintf_r+0x952>
80007cec:	40 22       	lddsp	r2,sp[0x8]
80007cee:	30 39       	mov	r9,3
80007cf0:	c1 08       	rjmp	80007d10 <_vfprintf_r+0x970>
80007cf2:	e0 40 00 45 	cp.w	r0,69
80007cf6:	5f 09       	sreq	r9
80007cf8:	e0 40 00 65 	cp.w	r0,101
80007cfc:	5f 08       	sreq	r8
80007cfe:	40 22       	lddsp	r2,sp[0x8]
80007d00:	10 49       	or	r9,r8
80007d02:	2f f2       	sub	r2,-1
80007d04:	40 46       	lddsp	r6,sp[0x10]
80007d06:	ec 09 18 00 	cp.b	r9,r6
80007d0a:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80007d0e:	30 29       	mov	r9,2
80007d10:	fa c8 f9 5c 	sub	r8,sp,-1700
80007d14:	1a d8       	st.w	--sp,r8
80007d16:	fa c8 f9 54 	sub	r8,sp,-1708
80007d1a:	1a d8       	st.w	--sp,r8
80007d1c:	fa c8 f9 4c 	sub	r8,sp,-1716
80007d20:	08 9c       	mov	r12,r4
80007d22:	1a d8       	st.w	--sp,r8
80007d24:	04 98       	mov	r8,r2
80007d26:	40 9b       	lddsp	r11,sp[0x24]
80007d28:	40 aa       	lddsp	r10,sp[0x28]
80007d2a:	e0 a0 0b c3 	rcall	800094b0 <_dtoa_r>
80007d2e:	e0 40 00 47 	cp.w	r0,71
80007d32:	5f 19       	srne	r9
80007d34:	e0 40 00 67 	cp.w	r0,103
80007d38:	5f 18       	srne	r8
80007d3a:	18 96       	mov	r6,r12
80007d3c:	2f dd       	sub	sp,-12
80007d3e:	f3 e8 00 08 	and	r8,r9,r8
80007d42:	c0 41       	brne	80007d4a <_vfprintf_r+0x9aa>
80007d44:	ed b5 00 00 	bld	r5,0x0
80007d48:	c3 01       	brne	80007da8 <_vfprintf_r+0xa08>
80007d4a:	ec 02 00 0e 	add	lr,r6,r2
80007d4e:	50 3e       	stdsp	sp[0xc],lr
80007d50:	40 4c       	lddsp	r12,sp[0x10]
80007d52:	58 0c       	cp.w	r12,0
80007d54:	c1 50       	breq	80007d7e <_vfprintf_r+0x9de>
80007d56:	0d 89       	ld.ub	r9,r6[0x0]
80007d58:	33 08       	mov	r8,48
80007d5a:	f0 09 18 00 	cp.b	r9,r8
80007d5e:	c0 b1       	brne	80007d74 <_vfprintf_r+0x9d4>
80007d60:	30 08       	mov	r8,0
80007d62:	30 09       	mov	r9,0
80007d64:	40 6b       	lddsp	r11,sp[0x18]
80007d66:	40 7a       	lddsp	r10,sp[0x1c]
80007d68:	e0 a0 1c cb 	rcall	8000b6fe <__avr32_f64_cmp_eq>
80007d6c:	fb b2 00 01 	rsubeq	r2,1
80007d70:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80007d74:	40 3b       	lddsp	r11,sp[0xc]
80007d76:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007d7a:	10 0b       	add	r11,r8
80007d7c:	50 3b       	stdsp	sp[0xc],r11
80007d7e:	40 6b       	lddsp	r11,sp[0x18]
80007d80:	30 08       	mov	r8,0
80007d82:	30 09       	mov	r9,0
80007d84:	40 7a       	lddsp	r10,sp[0x1c]
80007d86:	e0 a0 1c bc 	rcall	8000b6fe <__avr32_f64_cmp_eq>
80007d8a:	c0 90       	breq	80007d9c <_vfprintf_r+0x9fc>
80007d8c:	40 3a       	lddsp	r10,sp[0xc]
80007d8e:	fb 4a 06 a4 	st.w	sp[1700],r10
80007d92:	c0 58       	rjmp	80007d9c <_vfprintf_r+0x9fc>
80007d94:	10 c9       	st.b	r8++,r9
80007d96:	fb 48 06 a4 	st.w	sp[1700],r8
80007d9a:	c0 28       	rjmp	80007d9e <_vfprintf_r+0x9fe>
80007d9c:	33 09       	mov	r9,48
80007d9e:	fa f8 06 a4 	ld.w	r8,sp[1700]
80007da2:	40 3e       	lddsp	lr,sp[0xc]
80007da4:	1c 38       	cp.w	r8,lr
80007da6:	cf 73       	brcs	80007d94 <_vfprintf_r+0x9f4>
80007da8:	e0 40 00 47 	cp.w	r0,71
80007dac:	5f 09       	sreq	r9
80007dae:	e0 40 00 67 	cp.w	r0,103
80007db2:	5f 08       	sreq	r8
80007db4:	f3 e8 10 08 	or	r8,r9,r8
80007db8:	fa f9 06 a4 	ld.w	r9,sp[1700]
80007dbc:	0c 19       	sub	r9,r6
80007dbe:	50 69       	stdsp	sp[0x18],r9
80007dc0:	58 08       	cp.w	r8,0
80007dc2:	c0 b0       	breq	80007dd8 <_vfprintf_r+0xa38>
80007dc4:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007dc8:	5b d8       	cp.w	r8,-3
80007dca:	c0 55       	brlt	80007dd4 <_vfprintf_r+0xa34>
80007dcc:	40 2c       	lddsp	r12,sp[0x8]
80007dce:	18 38       	cp.w	r8,r12
80007dd0:	e0 8a 00 6a 	brle	80007ea4 <_vfprintf_r+0xb04>
80007dd4:	20 20       	sub	r0,2
80007dd6:	c0 58       	rjmp	80007de0 <_vfprintf_r+0xa40>
80007dd8:	e0 40 00 65 	cp.w	r0,101
80007ddc:	e0 89 00 46 	brgt	80007e68 <_vfprintf_r+0xac8>
80007de0:	fa fb 06 ac 	ld.w	r11,sp[1708]
80007de4:	fb 60 06 9c 	st.b	sp[1692],r0
80007de8:	20 1b       	sub	r11,1
80007dea:	fb 4b 06 ac 	st.w	sp[1708],r11
80007dee:	c0 47       	brpl	80007df6 <_vfprintf_r+0xa56>
80007df0:	5c 3b       	neg	r11
80007df2:	32 d8       	mov	r8,45
80007df4:	c0 28       	rjmp	80007df8 <_vfprintf_r+0xa58>
80007df6:	32 b8       	mov	r8,43
80007df8:	fb 68 06 9d 	st.b	sp[1693],r8
80007dfc:	58 9b       	cp.w	r11,9
80007dfe:	e0 8a 00 1d 	brle	80007e38 <_vfprintf_r+0xa98>
80007e02:	fa c9 fa 35 	sub	r9,sp,-1483
80007e06:	30 aa       	mov	r10,10
80007e08:	12 98       	mov	r8,r9
80007e0a:	0e 9c       	mov	r12,r7
80007e0c:	0c 92       	mov	r2,r6
80007e0e:	f6 0a 0c 06 	divs	r6,r11,r10
80007e12:	0e 9b       	mov	r11,r7
80007e14:	2d 0b       	sub	r11,-48
80007e16:	10 fb       	st.b	--r8,r11
80007e18:	0c 9b       	mov	r11,r6
80007e1a:	58 96       	cp.w	r6,9
80007e1c:	fe 99 ff f9 	brgt	80007e0e <_vfprintf_r+0xa6e>
80007e20:	2d 0b       	sub	r11,-48
80007e22:	18 97       	mov	r7,r12
80007e24:	04 96       	mov	r6,r2
80007e26:	10 fb       	st.b	--r8,r11
80007e28:	fa ca f9 62 	sub	r10,sp,-1694
80007e2c:	c0 38       	rjmp	80007e32 <_vfprintf_r+0xa92>
80007e2e:	11 3b       	ld.ub	r11,r8++
80007e30:	14 cb       	st.b	r10++,r11
80007e32:	12 38       	cp.w	r8,r9
80007e34:	cf d3       	brcs	80007e2e <_vfprintf_r+0xa8e>
80007e36:	c0 98       	rjmp	80007e48 <_vfprintf_r+0xaa8>
80007e38:	2d 0b       	sub	r11,-48
80007e3a:	33 08       	mov	r8,48
80007e3c:	fb 6b 06 9f 	st.b	sp[1695],r11
80007e40:	fb 68 06 9e 	st.b	sp[1694],r8
80007e44:	fa ca f9 60 	sub	r10,sp,-1696
80007e48:	fa c8 f9 64 	sub	r8,sp,-1692
80007e4c:	f4 08 01 08 	sub	r8,r10,r8
80007e50:	50 e8       	stdsp	sp[0x38],r8
80007e52:	10 92       	mov	r2,r8
80007e54:	40 6b       	lddsp	r11,sp[0x18]
80007e56:	16 02       	add	r2,r11
80007e58:	58 1b       	cp.w	r11,1
80007e5a:	e0 89 00 05 	brgt	80007e64 <_vfprintf_r+0xac4>
80007e5e:	ed b5 00 00 	bld	r5,0x0
80007e62:	c3 51       	brne	80007ecc <_vfprintf_r+0xb2c>
80007e64:	2f f2       	sub	r2,-1
80007e66:	c3 38       	rjmp	80007ecc <_vfprintf_r+0xb2c>
80007e68:	e0 40 00 66 	cp.w	r0,102
80007e6c:	c1 c1       	brne	80007ea4 <_vfprintf_r+0xb04>
80007e6e:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007e72:	58 02       	cp.w	r2,0
80007e74:	e0 8a 00 0c 	brle	80007e8c <_vfprintf_r+0xaec>
80007e78:	40 2a       	lddsp	r10,sp[0x8]
80007e7a:	58 0a       	cp.w	r10,0
80007e7c:	c0 41       	brne	80007e84 <_vfprintf_r+0xae4>
80007e7e:	ed b5 00 00 	bld	r5,0x0
80007e82:	c2 51       	brne	80007ecc <_vfprintf_r+0xb2c>
80007e84:	2f f2       	sub	r2,-1
80007e86:	40 29       	lddsp	r9,sp[0x8]
80007e88:	12 02       	add	r2,r9
80007e8a:	c0 b8       	rjmp	80007ea0 <_vfprintf_r+0xb00>
80007e8c:	40 28       	lddsp	r8,sp[0x8]
80007e8e:	58 08       	cp.w	r8,0
80007e90:	c0 61       	brne	80007e9c <_vfprintf_r+0xafc>
80007e92:	ed b5 00 00 	bld	r5,0x0
80007e96:	c0 30       	breq	80007e9c <_vfprintf_r+0xafc>
80007e98:	30 12       	mov	r2,1
80007e9a:	c1 98       	rjmp	80007ecc <_vfprintf_r+0xb2c>
80007e9c:	40 22       	lddsp	r2,sp[0x8]
80007e9e:	2f e2       	sub	r2,-2
80007ea0:	36 60       	mov	r0,102
80007ea2:	c1 58       	rjmp	80007ecc <_vfprintf_r+0xb2c>
80007ea4:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007ea8:	40 6e       	lddsp	lr,sp[0x18]
80007eaa:	1c 32       	cp.w	r2,lr
80007eac:	c0 65       	brlt	80007eb8 <_vfprintf_r+0xb18>
80007eae:	ed b5 00 00 	bld	r5,0x0
80007eb2:	f7 b2 00 ff 	subeq	r2,-1
80007eb6:	c0 a8       	rjmp	80007eca <_vfprintf_r+0xb2a>
80007eb8:	e4 08 11 02 	rsub	r8,r2,2
80007ebc:	40 6c       	lddsp	r12,sp[0x18]
80007ebe:	58 02       	cp.w	r2,0
80007ec0:	f0 02 17 a0 	movle	r2,r8
80007ec4:	f9 b2 09 01 	movgt	r2,1
80007ec8:	18 02       	add	r2,r12
80007eca:	36 70       	mov	r0,103
80007ecc:	40 9b       	lddsp	r11,sp[0x24]
80007ece:	58 0b       	cp.w	r11,0
80007ed0:	e0 80 05 94 	breq	800089f8 <_vfprintf_r+0x1658>
80007ed4:	32 d8       	mov	r8,45
80007ed6:	fb 68 06 bb 	st.b	sp[1723],r8
80007eda:	e0 8f 05 93 	bral	80008a00 <_vfprintf_r+0x1660>
80007ede:	50 a7       	stdsp	sp[0x28],r7
80007ee0:	04 94       	mov	r4,r2
80007ee2:	0c 97       	mov	r7,r6
80007ee4:	02 92       	mov	r2,r1
80007ee6:	06 96       	mov	r6,r3
80007ee8:	40 41       	lddsp	r1,sp[0x10]
80007eea:	40 93       	lddsp	r3,sp[0x24]
80007eec:	0e 99       	mov	r9,r7
80007eee:	ed b5 00 05 	bld	r5,0x5
80007ef2:	c4 81       	brne	80007f82 <_vfprintf_r+0xbe2>
80007ef4:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ef8:	40 3e       	lddsp	lr,sp[0xc]
80007efa:	58 0e       	cp.w	lr,0
80007efc:	c1 d0       	breq	80007f36 <_vfprintf_r+0xb96>
80007efe:	10 36       	cp.w	r6,r8
80007f00:	c0 64       	brge	80007f0c <_vfprintf_r+0xb6c>
80007f02:	fa cc f9 44 	sub	r12,sp,-1724
80007f06:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007f0a:	c1 d8       	rjmp	80007f44 <_vfprintf_r+0xba4>
80007f0c:	fa c8 f9 50 	sub	r8,sp,-1712
80007f10:	1a d8       	st.w	--sp,r8
80007f12:	fa c8 fa b8 	sub	r8,sp,-1352
80007f16:	04 9a       	mov	r10,r2
80007f18:	1a d8       	st.w	--sp,r8
80007f1a:	fa c8 fb b4 	sub	r8,sp,-1100
80007f1e:	0c 9b       	mov	r11,r6
80007f20:	1a d8       	st.w	--sp,r8
80007f22:	08 9c       	mov	r12,r4
80007f24:	fa c8 f9 40 	sub	r8,sp,-1728
80007f28:	fa c9 ff b4 	sub	r9,sp,-76
80007f2c:	fe b0 f8 a2 	rcall	80007070 <get_arg>
80007f30:	2f dd       	sub	sp,-12
80007f32:	78 0a       	ld.w	r10,r12[0x0]
80007f34:	c2 08       	rjmp	80007f74 <_vfprintf_r+0xbd4>
80007f36:	2f f7       	sub	r7,-1
80007f38:	10 39       	cp.w	r9,r8
80007f3a:	c0 84       	brge	80007f4a <_vfprintf_r+0xbaa>
80007f3c:	fa cb f9 44 	sub	r11,sp,-1724
80007f40:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f44:	ec fa fd 88 	ld.w	r10,r6[-632]
80007f48:	c1 68       	rjmp	80007f74 <_vfprintf_r+0xbd4>
80007f4a:	41 09       	lddsp	r9,sp[0x40]
80007f4c:	59 f8       	cp.w	r8,31
80007f4e:	e0 89 00 10 	brgt	80007f6e <_vfprintf_r+0xbce>
80007f52:	f2 ca ff fc 	sub	r10,r9,-4
80007f56:	51 0a       	stdsp	sp[0x40],r10
80007f58:	fa c6 f9 44 	sub	r6,sp,-1724
80007f5c:	72 0a       	ld.w	r10,r9[0x0]
80007f5e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007f62:	f3 4a fd 88 	st.w	r9[-632],r10
80007f66:	2f f8       	sub	r8,-1
80007f68:	fb 48 06 b4 	st.w	sp[1716],r8
80007f6c:	c0 48       	rjmp	80007f74 <_vfprintf_r+0xbd4>
80007f6e:	72 0a       	ld.w	r10,r9[0x0]
80007f70:	2f c9       	sub	r9,-4
80007f72:	51 09       	stdsp	sp[0x40],r9
80007f74:	40 be       	lddsp	lr,sp[0x2c]
80007f76:	1c 98       	mov	r8,lr
80007f78:	95 1e       	st.w	r10[0x4],lr
80007f7a:	bf 58       	asr	r8,0x1f
80007f7c:	95 08       	st.w	r10[0x0],r8
80007f7e:	fe 9f fa 9f 	bral	800074bc <_vfprintf_r+0x11c>
80007f82:	ed b5 00 04 	bld	r5,0x4
80007f86:	c4 80       	breq	80008016 <_vfprintf_r+0xc76>
80007f88:	e2 15 00 40 	andl	r5,0x40,COH
80007f8c:	c4 50       	breq	80008016 <_vfprintf_r+0xc76>
80007f8e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f92:	40 3c       	lddsp	r12,sp[0xc]
80007f94:	58 0c       	cp.w	r12,0
80007f96:	c1 d0       	breq	80007fd0 <_vfprintf_r+0xc30>
80007f98:	10 36       	cp.w	r6,r8
80007f9a:	c0 64       	brge	80007fa6 <_vfprintf_r+0xc06>
80007f9c:	fa cb f9 44 	sub	r11,sp,-1724
80007fa0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007fa4:	c1 d8       	rjmp	80007fde <_vfprintf_r+0xc3e>
80007fa6:	fa c8 f9 50 	sub	r8,sp,-1712
80007faa:	1a d8       	st.w	--sp,r8
80007fac:	fa c8 fa b8 	sub	r8,sp,-1352
80007fb0:	04 9a       	mov	r10,r2
80007fb2:	1a d8       	st.w	--sp,r8
80007fb4:	fa c8 fb b4 	sub	r8,sp,-1100
80007fb8:	0c 9b       	mov	r11,r6
80007fba:	1a d8       	st.w	--sp,r8
80007fbc:	08 9c       	mov	r12,r4
80007fbe:	fa c8 f9 40 	sub	r8,sp,-1728
80007fc2:	fa c9 ff b4 	sub	r9,sp,-76
80007fc6:	fe b0 f8 55 	rcall	80007070 <get_arg>
80007fca:	2f dd       	sub	sp,-12
80007fcc:	78 0a       	ld.w	r10,r12[0x0]
80007fce:	c2 08       	rjmp	8000800e <_vfprintf_r+0xc6e>
80007fd0:	2f f7       	sub	r7,-1
80007fd2:	10 39       	cp.w	r9,r8
80007fd4:	c0 84       	brge	80007fe4 <_vfprintf_r+0xc44>
80007fd6:	fa ca f9 44 	sub	r10,sp,-1724
80007fda:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007fde:	ec fa fd 88 	ld.w	r10,r6[-632]
80007fe2:	c1 68       	rjmp	8000800e <_vfprintf_r+0xc6e>
80007fe4:	41 09       	lddsp	r9,sp[0x40]
80007fe6:	59 f8       	cp.w	r8,31
80007fe8:	e0 89 00 10 	brgt	80008008 <_vfprintf_r+0xc68>
80007fec:	f2 ca ff fc 	sub	r10,r9,-4
80007ff0:	51 0a       	stdsp	sp[0x40],r10
80007ff2:	fa c6 f9 44 	sub	r6,sp,-1724
80007ff6:	72 0a       	ld.w	r10,r9[0x0]
80007ff8:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007ffc:	f3 4a fd 88 	st.w	r9[-632],r10
80008000:	2f f8       	sub	r8,-1
80008002:	fb 48 06 b4 	st.w	sp[1716],r8
80008006:	c0 48       	rjmp	8000800e <_vfprintf_r+0xc6e>
80008008:	72 0a       	ld.w	r10,r9[0x0]
8000800a:	2f c9       	sub	r9,-4
8000800c:	51 09       	stdsp	sp[0x40],r9
8000800e:	40 be       	lddsp	lr,sp[0x2c]
80008010:	b4 0e       	st.h	r10[0x0],lr
80008012:	fe 9f fa 55 	bral	800074bc <_vfprintf_r+0x11c>
80008016:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000801a:	40 3c       	lddsp	r12,sp[0xc]
8000801c:	58 0c       	cp.w	r12,0
8000801e:	c1 d0       	breq	80008058 <_vfprintf_r+0xcb8>
80008020:	10 36       	cp.w	r6,r8
80008022:	c0 64       	brge	8000802e <_vfprintf_r+0xc8e>
80008024:	fa cb f9 44 	sub	r11,sp,-1724
80008028:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000802c:	c1 d8       	rjmp	80008066 <_vfprintf_r+0xcc6>
8000802e:	fa c8 f9 50 	sub	r8,sp,-1712
80008032:	1a d8       	st.w	--sp,r8
80008034:	fa c8 fa b8 	sub	r8,sp,-1352
80008038:	04 9a       	mov	r10,r2
8000803a:	1a d8       	st.w	--sp,r8
8000803c:	fa c8 fb b4 	sub	r8,sp,-1100
80008040:	0c 9b       	mov	r11,r6
80008042:	1a d8       	st.w	--sp,r8
80008044:	08 9c       	mov	r12,r4
80008046:	fa c8 f9 40 	sub	r8,sp,-1728
8000804a:	fa c9 ff b4 	sub	r9,sp,-76
8000804e:	fe b0 f8 11 	rcall	80007070 <get_arg>
80008052:	2f dd       	sub	sp,-12
80008054:	78 0a       	ld.w	r10,r12[0x0]
80008056:	c2 08       	rjmp	80008096 <_vfprintf_r+0xcf6>
80008058:	2f f7       	sub	r7,-1
8000805a:	10 39       	cp.w	r9,r8
8000805c:	c0 84       	brge	8000806c <_vfprintf_r+0xccc>
8000805e:	fa ca f9 44 	sub	r10,sp,-1724
80008062:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008066:	ec fa fd 88 	ld.w	r10,r6[-632]
8000806a:	c1 68       	rjmp	80008096 <_vfprintf_r+0xcf6>
8000806c:	41 09       	lddsp	r9,sp[0x40]
8000806e:	59 f8       	cp.w	r8,31
80008070:	e0 89 00 10 	brgt	80008090 <_vfprintf_r+0xcf0>
80008074:	f2 ca ff fc 	sub	r10,r9,-4
80008078:	51 0a       	stdsp	sp[0x40],r10
8000807a:	fa c6 f9 44 	sub	r6,sp,-1724
8000807e:	72 0a       	ld.w	r10,r9[0x0]
80008080:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008084:	f3 4a fd 88 	st.w	r9[-632],r10
80008088:	2f f8       	sub	r8,-1
8000808a:	fb 48 06 b4 	st.w	sp[1716],r8
8000808e:	c0 48       	rjmp	80008096 <_vfprintf_r+0xcf6>
80008090:	72 0a       	ld.w	r10,r9[0x0]
80008092:	2f c9       	sub	r9,-4
80008094:	51 09       	stdsp	sp[0x40],r9
80008096:	40 be       	lddsp	lr,sp[0x2c]
80008098:	95 0e       	st.w	r10[0x0],lr
8000809a:	fe 9f fa 11 	bral	800074bc <_vfprintf_r+0x11c>
8000809e:	50 a7       	stdsp	sp[0x28],r7
800080a0:	50 80       	stdsp	sp[0x20],r0
800080a2:	0c 97       	mov	r7,r6
800080a4:	04 94       	mov	r4,r2
800080a6:	06 96       	mov	r6,r3
800080a8:	02 92       	mov	r2,r1
800080aa:	40 93       	lddsp	r3,sp[0x24]
800080ac:	10 90       	mov	r0,r8
800080ae:	40 41       	lddsp	r1,sp[0x10]
800080b0:	a5 a5       	sbr	r5,0x4
800080b2:	c0 a8       	rjmp	800080c6 <_vfprintf_r+0xd26>
800080b4:	50 a7       	stdsp	sp[0x28],r7
800080b6:	50 80       	stdsp	sp[0x20],r0
800080b8:	0c 97       	mov	r7,r6
800080ba:	04 94       	mov	r4,r2
800080bc:	06 96       	mov	r6,r3
800080be:	02 92       	mov	r2,r1
800080c0:	40 93       	lddsp	r3,sp[0x24]
800080c2:	10 90       	mov	r0,r8
800080c4:	40 41       	lddsp	r1,sp[0x10]
800080c6:	ed b5 00 05 	bld	r5,0x5
800080ca:	c5 d1       	brne	80008184 <_vfprintf_r+0xde4>
800080cc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080d0:	40 3c       	lddsp	r12,sp[0xc]
800080d2:	58 0c       	cp.w	r12,0
800080d4:	c2 60       	breq	80008120 <_vfprintf_r+0xd80>
800080d6:	10 36       	cp.w	r6,r8
800080d8:	c0 a4       	brge	800080ec <_vfprintf_r+0xd4c>
800080da:	fa cb f9 44 	sub	r11,sp,-1724
800080de:	f6 06 00 36 	add	r6,r11,r6<<0x3
800080e2:	ec e8 fd 88 	ld.d	r8,r6[-632]
800080e6:	fa e9 00 00 	st.d	sp[0],r8
800080ea:	c1 88       	rjmp	8000811a <_vfprintf_r+0xd7a>
800080ec:	fa c8 f9 50 	sub	r8,sp,-1712
800080f0:	1a d8       	st.w	--sp,r8
800080f2:	fa c8 fa b8 	sub	r8,sp,-1352
800080f6:	04 9a       	mov	r10,r2
800080f8:	1a d8       	st.w	--sp,r8
800080fa:	0c 9b       	mov	r11,r6
800080fc:	fa c8 fb b4 	sub	r8,sp,-1100
80008100:	08 9c       	mov	r12,r4
80008102:	1a d8       	st.w	--sp,r8
80008104:	fa c8 f9 40 	sub	r8,sp,-1728
80008108:	fa c9 ff b4 	sub	r9,sp,-76
8000810c:	fe b0 f7 b2 	rcall	80007070 <get_arg>
80008110:	2f dd       	sub	sp,-12
80008112:	f8 ea 00 00 	ld.d	r10,r12[0]
80008116:	fa eb 00 00 	st.d	sp[0],r10
8000811a:	30 08       	mov	r8,0
8000811c:	e0 8f 03 de 	bral	800088d8 <_vfprintf_r+0x1538>
80008120:	ee ca ff ff 	sub	r10,r7,-1
80008124:	10 37       	cp.w	r7,r8
80008126:	c0 b4       	brge	8000813c <_vfprintf_r+0xd9c>
80008128:	fa c9 f9 44 	sub	r9,sp,-1724
8000812c:	14 97       	mov	r7,r10
8000812e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008132:	ec ea fd 88 	ld.d	r10,r6[-632]
80008136:	fa eb 00 00 	st.d	sp[0],r10
8000813a:	c1 88       	rjmp	8000816a <_vfprintf_r+0xdca>
8000813c:	41 09       	lddsp	r9,sp[0x40]
8000813e:	59 f8       	cp.w	r8,31
80008140:	e0 89 00 18 	brgt	80008170 <_vfprintf_r+0xdd0>
80008144:	f2 e6 00 00 	ld.d	r6,r9[0]
80008148:	f2 cb ff f8 	sub	r11,r9,-8
8000814c:	fa e7 00 00 	st.d	sp[0],r6
80008150:	51 0b       	stdsp	sp[0x40],r11
80008152:	fa c6 f9 44 	sub	r6,sp,-1724
80008156:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000815a:	fa e6 00 00 	ld.d	r6,sp[0]
8000815e:	f2 e7 fd 88 	st.d	r9[-632],r6
80008162:	2f f8       	sub	r8,-1
80008164:	14 97       	mov	r7,r10
80008166:	fb 48 06 b4 	st.w	sp[1716],r8
8000816a:	40 38       	lddsp	r8,sp[0xc]
8000816c:	e0 8f 03 b6 	bral	800088d8 <_vfprintf_r+0x1538>
80008170:	f2 e6 00 00 	ld.d	r6,r9[0]
80008174:	40 38       	lddsp	r8,sp[0xc]
80008176:	fa e7 00 00 	st.d	sp[0],r6
8000817a:	2f 89       	sub	r9,-8
8000817c:	14 97       	mov	r7,r10
8000817e:	51 09       	stdsp	sp[0x40],r9
80008180:	e0 8f 03 ac 	bral	800088d8 <_vfprintf_r+0x1538>
80008184:	ed b5 00 04 	bld	r5,0x4
80008188:	c1 61       	brne	800081b4 <_vfprintf_r+0xe14>
8000818a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000818e:	40 3e       	lddsp	lr,sp[0xc]
80008190:	58 0e       	cp.w	lr,0
80008192:	c0 80       	breq	800081a2 <_vfprintf_r+0xe02>
80008194:	10 36       	cp.w	r6,r8
80008196:	c6 74       	brge	80008264 <_vfprintf_r+0xec4>
80008198:	fa cc f9 44 	sub	r12,sp,-1724
8000819c:	f8 06 00 36 	add	r6,r12,r6<<0x3
800081a0:	c8 08       	rjmp	800082a0 <_vfprintf_r+0xf00>
800081a2:	ee ca ff ff 	sub	r10,r7,-1
800081a6:	10 37       	cp.w	r7,r8
800081a8:	c7 f4       	brge	800082a6 <_vfprintf_r+0xf06>
800081aa:	fa cb f9 44 	sub	r11,sp,-1724
800081ae:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081b2:	c7 68       	rjmp	8000829e <_vfprintf_r+0xefe>
800081b4:	ed b5 00 06 	bld	r5,0x6
800081b8:	c4 a1       	brne	8000824c <_vfprintf_r+0xeac>
800081ba:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081be:	40 3c       	lddsp	r12,sp[0xc]
800081c0:	58 0c       	cp.w	r12,0
800081c2:	c1 d0       	breq	800081fc <_vfprintf_r+0xe5c>
800081c4:	10 36       	cp.w	r6,r8
800081c6:	c0 64       	brge	800081d2 <_vfprintf_r+0xe32>
800081c8:	fa cb f9 44 	sub	r11,sp,-1724
800081cc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081d0:	c1 f8       	rjmp	8000820e <_vfprintf_r+0xe6e>
800081d2:	fa c8 f9 50 	sub	r8,sp,-1712
800081d6:	1a d8       	st.w	--sp,r8
800081d8:	fa c8 fa b8 	sub	r8,sp,-1352
800081dc:	1a d8       	st.w	--sp,r8
800081de:	fa c8 fb b4 	sub	r8,sp,-1100
800081e2:	1a d8       	st.w	--sp,r8
800081e4:	fa c8 f9 40 	sub	r8,sp,-1728
800081e8:	fa c9 ff b4 	sub	r9,sp,-76
800081ec:	04 9a       	mov	r10,r2
800081ee:	0c 9b       	mov	r11,r6
800081f0:	08 9c       	mov	r12,r4
800081f2:	fe b0 f7 3f 	rcall	80007070 <get_arg>
800081f6:	2f dd       	sub	sp,-12
800081f8:	98 18       	ld.sh	r8,r12[0x2]
800081fa:	c2 68       	rjmp	80008246 <_vfprintf_r+0xea6>
800081fc:	ee ca ff ff 	sub	r10,r7,-1
80008200:	10 37       	cp.w	r7,r8
80008202:	c0 94       	brge	80008214 <_vfprintf_r+0xe74>
80008204:	fa c9 f9 44 	sub	r9,sp,-1724
80008208:	14 97       	mov	r7,r10
8000820a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000820e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008212:	c1 a8       	rjmp	80008246 <_vfprintf_r+0xea6>
80008214:	41 09       	lddsp	r9,sp[0x40]
80008216:	59 f8       	cp.w	r8,31
80008218:	e0 89 00 13 	brgt	8000823e <_vfprintf_r+0xe9e>
8000821c:	f2 cb ff fc 	sub	r11,r9,-4
80008220:	51 0b       	stdsp	sp[0x40],r11
80008222:	72 09       	ld.w	r9,r9[0x0]
80008224:	fa c6 f9 44 	sub	r6,sp,-1724
80008228:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000822c:	2f f8       	sub	r8,-1
8000822e:	f7 49 fd 88 	st.w	r11[-632],r9
80008232:	fb 48 06 b4 	st.w	sp[1716],r8
80008236:	14 97       	mov	r7,r10
80008238:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000823c:	c0 58       	rjmp	80008246 <_vfprintf_r+0xea6>
8000823e:	92 18       	ld.sh	r8,r9[0x2]
80008240:	14 97       	mov	r7,r10
80008242:	2f c9       	sub	r9,-4
80008244:	51 09       	stdsp	sp[0x40],r9
80008246:	5c 78       	castu.h	r8
80008248:	50 18       	stdsp	sp[0x4],r8
8000824a:	c4 68       	rjmp	800082d6 <_vfprintf_r+0xf36>
8000824c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008250:	40 3c       	lddsp	r12,sp[0xc]
80008252:	58 0c       	cp.w	r12,0
80008254:	c1 d0       	breq	8000828e <_vfprintf_r+0xeee>
80008256:	10 36       	cp.w	r6,r8
80008258:	c0 64       	brge	80008264 <_vfprintf_r+0xec4>
8000825a:	fa cb f9 44 	sub	r11,sp,-1724
8000825e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008262:	c1 f8       	rjmp	800082a0 <_vfprintf_r+0xf00>
80008264:	fa c8 f9 50 	sub	r8,sp,-1712
80008268:	1a d8       	st.w	--sp,r8
8000826a:	fa c8 fa b8 	sub	r8,sp,-1352
8000826e:	0c 9b       	mov	r11,r6
80008270:	1a d8       	st.w	--sp,r8
80008272:	fa c8 fb b4 	sub	r8,sp,-1100
80008276:	04 9a       	mov	r10,r2
80008278:	1a d8       	st.w	--sp,r8
8000827a:	08 9c       	mov	r12,r4
8000827c:	fa c8 f9 40 	sub	r8,sp,-1728
80008280:	fa c9 ff b4 	sub	r9,sp,-76
80008284:	fe b0 f6 f6 	rcall	80007070 <get_arg>
80008288:	2f dd       	sub	sp,-12
8000828a:	78 0b       	ld.w	r11,r12[0x0]
8000828c:	c2 48       	rjmp	800082d4 <_vfprintf_r+0xf34>
8000828e:	ee ca ff ff 	sub	r10,r7,-1
80008292:	10 37       	cp.w	r7,r8
80008294:	c0 94       	brge	800082a6 <_vfprintf_r+0xf06>
80008296:	fa c9 f9 44 	sub	r9,sp,-1724
8000829a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000829e:	14 97       	mov	r7,r10
800082a0:	ec fb fd 88 	ld.w	r11,r6[-632]
800082a4:	c1 88       	rjmp	800082d4 <_vfprintf_r+0xf34>
800082a6:	41 09       	lddsp	r9,sp[0x40]
800082a8:	59 f8       	cp.w	r8,31
800082aa:	e0 89 00 11 	brgt	800082cc <_vfprintf_r+0xf2c>
800082ae:	f2 cb ff fc 	sub	r11,r9,-4
800082b2:	51 0b       	stdsp	sp[0x40],r11
800082b4:	fa c6 f9 44 	sub	r6,sp,-1724
800082b8:	72 0b       	ld.w	r11,r9[0x0]
800082ba:	ec 08 00 39 	add	r9,r6,r8<<0x3
800082be:	f3 4b fd 88 	st.w	r9[-632],r11
800082c2:	2f f8       	sub	r8,-1
800082c4:	14 97       	mov	r7,r10
800082c6:	fb 48 06 b4 	st.w	sp[1716],r8
800082ca:	c0 58       	rjmp	800082d4 <_vfprintf_r+0xf34>
800082cc:	72 0b       	ld.w	r11,r9[0x0]
800082ce:	14 97       	mov	r7,r10
800082d0:	2f c9       	sub	r9,-4
800082d2:	51 09       	stdsp	sp[0x40],r9
800082d4:	50 1b       	stdsp	sp[0x4],r11
800082d6:	30 0e       	mov	lr,0
800082d8:	50 0e       	stdsp	sp[0x0],lr
800082da:	1c 98       	mov	r8,lr
800082dc:	e0 8f 02 fe 	bral	800088d8 <_vfprintf_r+0x1538>
800082e0:	50 a7       	stdsp	sp[0x28],r7
800082e2:	50 80       	stdsp	sp[0x20],r0
800082e4:	0c 97       	mov	r7,r6
800082e6:	04 94       	mov	r4,r2
800082e8:	06 96       	mov	r6,r3
800082ea:	02 92       	mov	r2,r1
800082ec:	40 93       	lddsp	r3,sp[0x24]
800082ee:	40 41       	lddsp	r1,sp[0x10]
800082f0:	0e 99       	mov	r9,r7
800082f2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800082f6:	40 3c       	lddsp	r12,sp[0xc]
800082f8:	58 0c       	cp.w	r12,0
800082fa:	c1 d0       	breq	80008334 <_vfprintf_r+0xf94>
800082fc:	10 36       	cp.w	r6,r8
800082fe:	c0 64       	brge	8000830a <_vfprintf_r+0xf6a>
80008300:	fa cb f9 44 	sub	r11,sp,-1724
80008304:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008308:	c1 d8       	rjmp	80008342 <_vfprintf_r+0xfa2>
8000830a:	fa c8 f9 50 	sub	r8,sp,-1712
8000830e:	1a d8       	st.w	--sp,r8
80008310:	fa c8 fa b8 	sub	r8,sp,-1352
80008314:	1a d8       	st.w	--sp,r8
80008316:	fa c8 fb b4 	sub	r8,sp,-1100
8000831a:	1a d8       	st.w	--sp,r8
8000831c:	fa c9 ff b4 	sub	r9,sp,-76
80008320:	fa c8 f9 40 	sub	r8,sp,-1728
80008324:	04 9a       	mov	r10,r2
80008326:	0c 9b       	mov	r11,r6
80008328:	08 9c       	mov	r12,r4
8000832a:	fe b0 f6 a3 	rcall	80007070 <get_arg>
8000832e:	2f dd       	sub	sp,-12
80008330:	78 09       	ld.w	r9,r12[0x0]
80008332:	c2 18       	rjmp	80008374 <_vfprintf_r+0xfd4>
80008334:	2f f7       	sub	r7,-1
80008336:	10 39       	cp.w	r9,r8
80008338:	c0 84       	brge	80008348 <_vfprintf_r+0xfa8>
8000833a:	fa ca f9 44 	sub	r10,sp,-1724
8000833e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008342:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008346:	c1 78       	rjmp	80008374 <_vfprintf_r+0xfd4>
80008348:	41 09       	lddsp	r9,sp[0x40]
8000834a:	59 f8       	cp.w	r8,31
8000834c:	e0 89 00 10 	brgt	8000836c <_vfprintf_r+0xfcc>
80008350:	f2 ca ff fc 	sub	r10,r9,-4
80008354:	51 0a       	stdsp	sp[0x40],r10
80008356:	fa c6 f9 44 	sub	r6,sp,-1724
8000835a:	72 09       	ld.w	r9,r9[0x0]
8000835c:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008360:	f5 49 fd 88 	st.w	r10[-632],r9
80008364:	2f f8       	sub	r8,-1
80008366:	fb 48 06 b4 	st.w	sp[1716],r8
8000836a:	c0 58       	rjmp	80008374 <_vfprintf_r+0xfd4>
8000836c:	f2 c8 ff fc 	sub	r8,r9,-4
80008370:	51 08       	stdsp	sp[0x40],r8
80008372:	72 09       	ld.w	r9,r9[0x0]
80008374:	33 08       	mov	r8,48
80008376:	fb 68 06 b8 	st.b	sp[1720],r8
8000837a:	37 88       	mov	r8,120
8000837c:	30 0e       	mov	lr,0
8000837e:	fb 68 06 b9 	st.b	sp[1721],r8
80008382:	fe cc ac ce 	sub	r12,pc,-21298
80008386:	50 19       	stdsp	sp[0x4],r9
80008388:	a1 b5       	sbr	r5,0x1
8000838a:	50 0e       	stdsp	sp[0x0],lr
8000838c:	50 dc       	stdsp	sp[0x34],r12
8000838e:	30 28       	mov	r8,2
80008390:	37 80       	mov	r0,120
80008392:	e0 8f 02 a3 	bral	800088d8 <_vfprintf_r+0x1538>
80008396:	50 a7       	stdsp	sp[0x28],r7
80008398:	50 80       	stdsp	sp[0x20],r0
8000839a:	10 90       	mov	r0,r8
8000839c:	30 08       	mov	r8,0
8000839e:	fb 68 06 bb 	st.b	sp[1723],r8
800083a2:	0c 97       	mov	r7,r6
800083a4:	04 94       	mov	r4,r2
800083a6:	06 96       	mov	r6,r3
800083a8:	02 92       	mov	r2,r1
800083aa:	40 93       	lddsp	r3,sp[0x24]
800083ac:	40 41       	lddsp	r1,sp[0x10]
800083ae:	0e 99       	mov	r9,r7
800083b0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800083b4:	40 3b       	lddsp	r11,sp[0xc]
800083b6:	58 0b       	cp.w	r11,0
800083b8:	c1 d0       	breq	800083f2 <_vfprintf_r+0x1052>
800083ba:	10 36       	cp.w	r6,r8
800083bc:	c0 64       	brge	800083c8 <_vfprintf_r+0x1028>
800083be:	fa ca f9 44 	sub	r10,sp,-1724
800083c2:	f4 06 00 36 	add	r6,r10,r6<<0x3
800083c6:	c1 d8       	rjmp	80008400 <_vfprintf_r+0x1060>
800083c8:	fa c8 f9 50 	sub	r8,sp,-1712
800083cc:	1a d8       	st.w	--sp,r8
800083ce:	fa c8 fa b8 	sub	r8,sp,-1352
800083d2:	1a d8       	st.w	--sp,r8
800083d4:	fa c8 fb b4 	sub	r8,sp,-1100
800083d8:	0c 9b       	mov	r11,r6
800083da:	1a d8       	st.w	--sp,r8
800083dc:	04 9a       	mov	r10,r2
800083de:	fa c8 f9 40 	sub	r8,sp,-1728
800083e2:	fa c9 ff b4 	sub	r9,sp,-76
800083e6:	08 9c       	mov	r12,r4
800083e8:	fe b0 f6 44 	rcall	80007070 <get_arg>
800083ec:	2f dd       	sub	sp,-12
800083ee:	78 06       	ld.w	r6,r12[0x0]
800083f0:	c2 08       	rjmp	80008430 <_vfprintf_r+0x1090>
800083f2:	2f f7       	sub	r7,-1
800083f4:	10 39       	cp.w	r9,r8
800083f6:	c0 84       	brge	80008406 <_vfprintf_r+0x1066>
800083f8:	fa c9 f9 44 	sub	r9,sp,-1724
800083fc:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008400:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008404:	c1 68       	rjmp	80008430 <_vfprintf_r+0x1090>
80008406:	41 09       	lddsp	r9,sp[0x40]
80008408:	59 f8       	cp.w	r8,31
8000840a:	e0 89 00 10 	brgt	8000842a <_vfprintf_r+0x108a>
8000840e:	f2 ca ff fc 	sub	r10,r9,-4
80008412:	51 0a       	stdsp	sp[0x40],r10
80008414:	72 06       	ld.w	r6,r9[0x0]
80008416:	fa ce f9 44 	sub	lr,sp,-1724
8000841a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000841e:	f3 46 fd 88 	st.w	r9[-632],r6
80008422:	2f f8       	sub	r8,-1
80008424:	fb 48 06 b4 	st.w	sp[1716],r8
80008428:	c0 48       	rjmp	80008430 <_vfprintf_r+0x1090>
8000842a:	72 06       	ld.w	r6,r9[0x0]
8000842c:	2f c9       	sub	r9,-4
8000842e:	51 09       	stdsp	sp[0x40],r9
80008430:	40 2c       	lddsp	r12,sp[0x8]
80008432:	58 0c       	cp.w	r12,0
80008434:	c1 05       	brlt	80008454 <_vfprintf_r+0x10b4>
80008436:	18 9a       	mov	r10,r12
80008438:	30 0b       	mov	r11,0
8000843a:	0c 9c       	mov	r12,r6
8000843c:	e0 a0 12 38 	rcall	8000a8ac <memchr>
80008440:	e0 80 02 df 	breq	800089fe <_vfprintf_r+0x165e>
80008444:	f8 06 01 02 	sub	r2,r12,r6
80008448:	40 2b       	lddsp	r11,sp[0x8]
8000844a:	16 32       	cp.w	r2,r11
8000844c:	e0 89 02 d9 	brgt	800089fe <_vfprintf_r+0x165e>
80008450:	e0 8f 02 d4 	bral	800089f8 <_vfprintf_r+0x1658>
80008454:	30 0a       	mov	r10,0
80008456:	0c 9c       	mov	r12,r6
80008458:	50 2a       	stdsp	sp[0x8],r10
8000845a:	fe b0 f5 85 	rcall	80006f64 <strlen>
8000845e:	18 92       	mov	r2,r12
80008460:	e0 8f 02 d2 	bral	80008a04 <_vfprintf_r+0x1664>
80008464:	50 a7       	stdsp	sp[0x28],r7
80008466:	50 80       	stdsp	sp[0x20],r0
80008468:	0c 97       	mov	r7,r6
8000846a:	04 94       	mov	r4,r2
8000846c:	06 96       	mov	r6,r3
8000846e:	02 92       	mov	r2,r1
80008470:	40 93       	lddsp	r3,sp[0x24]
80008472:	10 90       	mov	r0,r8
80008474:	40 41       	lddsp	r1,sp[0x10]
80008476:	a5 a5       	sbr	r5,0x4
80008478:	c0 a8       	rjmp	8000848c <_vfprintf_r+0x10ec>
8000847a:	50 a7       	stdsp	sp[0x28],r7
8000847c:	50 80       	stdsp	sp[0x20],r0
8000847e:	0c 97       	mov	r7,r6
80008480:	04 94       	mov	r4,r2
80008482:	06 96       	mov	r6,r3
80008484:	02 92       	mov	r2,r1
80008486:	40 93       	lddsp	r3,sp[0x24]
80008488:	10 90       	mov	r0,r8
8000848a:	40 41       	lddsp	r1,sp[0x10]
8000848c:	ed b5 00 05 	bld	r5,0x5
80008490:	c5 61       	brne	8000853c <_vfprintf_r+0x119c>
80008492:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008496:	40 39       	lddsp	r9,sp[0xc]
80008498:	58 09       	cp.w	r9,0
8000849a:	c2 10       	breq	800084dc <_vfprintf_r+0x113c>
8000849c:	10 36       	cp.w	r6,r8
8000849e:	c0 74       	brge	800084ac <_vfprintf_r+0x110c>
800084a0:	fa c8 f9 44 	sub	r8,sp,-1724
800084a4:	f0 06 00 36 	add	r6,r8,r6<<0x3
800084a8:	c2 38       	rjmp	800084ee <_vfprintf_r+0x114e>
800084aa:	d7 03       	nop
800084ac:	fa c8 f9 50 	sub	r8,sp,-1712
800084b0:	1a d8       	st.w	--sp,r8
800084b2:	fa c8 fa b8 	sub	r8,sp,-1352
800084b6:	1a d8       	st.w	--sp,r8
800084b8:	fa c8 fb b4 	sub	r8,sp,-1100
800084bc:	1a d8       	st.w	--sp,r8
800084be:	fa c8 f9 40 	sub	r8,sp,-1728
800084c2:	fa c9 ff b4 	sub	r9,sp,-76
800084c6:	04 9a       	mov	r10,r2
800084c8:	0c 9b       	mov	r11,r6
800084ca:	08 9c       	mov	r12,r4
800084cc:	fe b0 f5 d2 	rcall	80007070 <get_arg>
800084d0:	2f dd       	sub	sp,-12
800084d2:	f8 e8 00 00 	ld.d	r8,r12[0]
800084d6:	fa e9 00 00 	st.d	sp[0],r8
800084da:	c2 e8       	rjmp	80008536 <_vfprintf_r+0x1196>
800084dc:	ee ca ff ff 	sub	r10,r7,-1
800084e0:	10 37       	cp.w	r7,r8
800084e2:	c0 b4       	brge	800084f8 <_vfprintf_r+0x1158>
800084e4:	fa c8 f9 44 	sub	r8,sp,-1724
800084e8:	14 97       	mov	r7,r10
800084ea:	f0 06 00 36 	add	r6,r8,r6<<0x3
800084ee:	ec ea fd 88 	ld.d	r10,r6[-632]
800084f2:	fa eb 00 00 	st.d	sp[0],r10
800084f6:	c2 08       	rjmp	80008536 <_vfprintf_r+0x1196>
800084f8:	41 09       	lddsp	r9,sp[0x40]
800084fa:	59 f8       	cp.w	r8,31
800084fc:	e0 89 00 16 	brgt	80008528 <_vfprintf_r+0x1188>
80008500:	f2 e6 00 00 	ld.d	r6,r9[0]
80008504:	f2 cb ff f8 	sub	r11,r9,-8
80008508:	fa e7 00 00 	st.d	sp[0],r6
8000850c:	51 0b       	stdsp	sp[0x40],r11
8000850e:	fa c6 f9 44 	sub	r6,sp,-1724
80008512:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008516:	fa e6 00 00 	ld.d	r6,sp[0]
8000851a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000851e:	2f f8       	sub	r8,-1
80008520:	14 97       	mov	r7,r10
80008522:	fb 48 06 b4 	st.w	sp[1716],r8
80008526:	c0 88       	rjmp	80008536 <_vfprintf_r+0x1196>
80008528:	f2 e6 00 00 	ld.d	r6,r9[0]
8000852c:	2f 89       	sub	r9,-8
8000852e:	fa e7 00 00 	st.d	sp[0],r6
80008532:	51 09       	stdsp	sp[0x40],r9
80008534:	14 97       	mov	r7,r10
80008536:	30 18       	mov	r8,1
80008538:	e0 8f 01 d0 	bral	800088d8 <_vfprintf_r+0x1538>
8000853c:	ed b5 00 04 	bld	r5,0x4
80008540:	c1 61       	brne	8000856c <_vfprintf_r+0x11cc>
80008542:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008546:	40 3e       	lddsp	lr,sp[0xc]
80008548:	58 0e       	cp.w	lr,0
8000854a:	c0 80       	breq	8000855a <_vfprintf_r+0x11ba>
8000854c:	10 36       	cp.w	r6,r8
8000854e:	c6 74       	brge	8000861c <_vfprintf_r+0x127c>
80008550:	fa cc f9 44 	sub	r12,sp,-1724
80008554:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008558:	c8 08       	rjmp	80008658 <_vfprintf_r+0x12b8>
8000855a:	ee ca ff ff 	sub	r10,r7,-1
8000855e:	10 37       	cp.w	r7,r8
80008560:	c7 f4       	brge	8000865e <_vfprintf_r+0x12be>
80008562:	fa cb f9 44 	sub	r11,sp,-1724
80008566:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000856a:	c7 68       	rjmp	80008656 <_vfprintf_r+0x12b6>
8000856c:	ed b5 00 06 	bld	r5,0x6
80008570:	c4 a1       	brne	80008604 <_vfprintf_r+0x1264>
80008572:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008576:	40 3c       	lddsp	r12,sp[0xc]
80008578:	58 0c       	cp.w	r12,0
8000857a:	c1 d0       	breq	800085b4 <_vfprintf_r+0x1214>
8000857c:	10 36       	cp.w	r6,r8
8000857e:	c0 64       	brge	8000858a <_vfprintf_r+0x11ea>
80008580:	fa cb f9 44 	sub	r11,sp,-1724
80008584:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008588:	c1 f8       	rjmp	800085c6 <_vfprintf_r+0x1226>
8000858a:	fa c8 f9 50 	sub	r8,sp,-1712
8000858e:	1a d8       	st.w	--sp,r8
80008590:	fa c8 fa b8 	sub	r8,sp,-1352
80008594:	1a d8       	st.w	--sp,r8
80008596:	fa c8 fb b4 	sub	r8,sp,-1100
8000859a:	1a d8       	st.w	--sp,r8
8000859c:	fa c8 f9 40 	sub	r8,sp,-1728
800085a0:	fa c9 ff b4 	sub	r9,sp,-76
800085a4:	04 9a       	mov	r10,r2
800085a6:	0c 9b       	mov	r11,r6
800085a8:	08 9c       	mov	r12,r4
800085aa:	fe b0 f5 63 	rcall	80007070 <get_arg>
800085ae:	2f dd       	sub	sp,-12
800085b0:	98 18       	ld.sh	r8,r12[0x2]
800085b2:	c2 68       	rjmp	800085fe <_vfprintf_r+0x125e>
800085b4:	ee ca ff ff 	sub	r10,r7,-1
800085b8:	10 37       	cp.w	r7,r8
800085ba:	c0 94       	brge	800085cc <_vfprintf_r+0x122c>
800085bc:	fa c9 f9 44 	sub	r9,sp,-1724
800085c0:	14 97       	mov	r7,r10
800085c2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800085c6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800085ca:	c1 a8       	rjmp	800085fe <_vfprintf_r+0x125e>
800085cc:	41 09       	lddsp	r9,sp[0x40]
800085ce:	59 f8       	cp.w	r8,31
800085d0:	e0 89 00 13 	brgt	800085f6 <_vfprintf_r+0x1256>
800085d4:	f2 cb ff fc 	sub	r11,r9,-4
800085d8:	51 0b       	stdsp	sp[0x40],r11
800085da:	72 09       	ld.w	r9,r9[0x0]
800085dc:	fa c6 f9 44 	sub	r6,sp,-1724
800085e0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800085e4:	2f f8       	sub	r8,-1
800085e6:	f7 49 fd 88 	st.w	r11[-632],r9
800085ea:	fb 48 06 b4 	st.w	sp[1716],r8
800085ee:	14 97       	mov	r7,r10
800085f0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800085f4:	c0 58       	rjmp	800085fe <_vfprintf_r+0x125e>
800085f6:	92 18       	ld.sh	r8,r9[0x2]
800085f8:	14 97       	mov	r7,r10
800085fa:	2f c9       	sub	r9,-4
800085fc:	51 09       	stdsp	sp[0x40],r9
800085fe:	5c 78       	castu.h	r8
80008600:	50 18       	stdsp	sp[0x4],r8
80008602:	c4 68       	rjmp	8000868e <_vfprintf_r+0x12ee>
80008604:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008608:	40 3c       	lddsp	r12,sp[0xc]
8000860a:	58 0c       	cp.w	r12,0
8000860c:	c1 d0       	breq	80008646 <_vfprintf_r+0x12a6>
8000860e:	10 36       	cp.w	r6,r8
80008610:	c0 64       	brge	8000861c <_vfprintf_r+0x127c>
80008612:	fa cb f9 44 	sub	r11,sp,-1724
80008616:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000861a:	c1 f8       	rjmp	80008658 <_vfprintf_r+0x12b8>
8000861c:	fa c8 f9 50 	sub	r8,sp,-1712
80008620:	1a d8       	st.w	--sp,r8
80008622:	fa c8 fa b8 	sub	r8,sp,-1352
80008626:	0c 9b       	mov	r11,r6
80008628:	1a d8       	st.w	--sp,r8
8000862a:	fa c8 fb b4 	sub	r8,sp,-1100
8000862e:	04 9a       	mov	r10,r2
80008630:	1a d8       	st.w	--sp,r8
80008632:	08 9c       	mov	r12,r4
80008634:	fa c8 f9 40 	sub	r8,sp,-1728
80008638:	fa c9 ff b4 	sub	r9,sp,-76
8000863c:	fe b0 f5 1a 	rcall	80007070 <get_arg>
80008640:	2f dd       	sub	sp,-12
80008642:	78 0b       	ld.w	r11,r12[0x0]
80008644:	c2 48       	rjmp	8000868c <_vfprintf_r+0x12ec>
80008646:	ee ca ff ff 	sub	r10,r7,-1
8000864a:	10 37       	cp.w	r7,r8
8000864c:	c0 94       	brge	8000865e <_vfprintf_r+0x12be>
8000864e:	fa c9 f9 44 	sub	r9,sp,-1724
80008652:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008656:	14 97       	mov	r7,r10
80008658:	ec fb fd 88 	ld.w	r11,r6[-632]
8000865c:	c1 88       	rjmp	8000868c <_vfprintf_r+0x12ec>
8000865e:	41 09       	lddsp	r9,sp[0x40]
80008660:	59 f8       	cp.w	r8,31
80008662:	e0 89 00 11 	brgt	80008684 <_vfprintf_r+0x12e4>
80008666:	f2 cb ff fc 	sub	r11,r9,-4
8000866a:	51 0b       	stdsp	sp[0x40],r11
8000866c:	fa c6 f9 44 	sub	r6,sp,-1724
80008670:	72 0b       	ld.w	r11,r9[0x0]
80008672:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008676:	f3 4b fd 88 	st.w	r9[-632],r11
8000867a:	2f f8       	sub	r8,-1
8000867c:	14 97       	mov	r7,r10
8000867e:	fb 48 06 b4 	st.w	sp[1716],r8
80008682:	c0 58       	rjmp	8000868c <_vfprintf_r+0x12ec>
80008684:	72 0b       	ld.w	r11,r9[0x0]
80008686:	14 97       	mov	r7,r10
80008688:	2f c9       	sub	r9,-4
8000868a:	51 09       	stdsp	sp[0x40],r9
8000868c:	50 1b       	stdsp	sp[0x4],r11
8000868e:	30 0e       	mov	lr,0
80008690:	30 18       	mov	r8,1
80008692:	50 0e       	stdsp	sp[0x0],lr
80008694:	c2 29       	rjmp	800088d8 <_vfprintf_r+0x1538>
80008696:	50 a7       	stdsp	sp[0x28],r7
80008698:	50 80       	stdsp	sp[0x20],r0
8000869a:	0c 97       	mov	r7,r6
8000869c:	04 94       	mov	r4,r2
8000869e:	06 96       	mov	r6,r3
800086a0:	02 92       	mov	r2,r1
800086a2:	fe cc af ee 	sub	r12,pc,-20498
800086a6:	40 93       	lddsp	r3,sp[0x24]
800086a8:	10 90       	mov	r0,r8
800086aa:	40 41       	lddsp	r1,sp[0x10]
800086ac:	50 dc       	stdsp	sp[0x34],r12
800086ae:	ed b5 00 05 	bld	r5,0x5
800086b2:	c5 51       	brne	8000875c <_vfprintf_r+0x13bc>
800086b4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086b8:	40 3b       	lddsp	r11,sp[0xc]
800086ba:	58 0b       	cp.w	r11,0
800086bc:	c2 20       	breq	80008700 <_vfprintf_r+0x1360>
800086be:	10 36       	cp.w	r6,r8
800086c0:	c0 a4       	brge	800086d4 <_vfprintf_r+0x1334>
800086c2:	fa ca f9 44 	sub	r10,sp,-1724
800086c6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800086ca:	ec e8 fd 88 	ld.d	r8,r6[-632]
800086ce:	fa e9 00 00 	st.d	sp[0],r8
800086d2:	cf 28       	rjmp	800088b6 <_vfprintf_r+0x1516>
800086d4:	fa c8 f9 50 	sub	r8,sp,-1712
800086d8:	1a d8       	st.w	--sp,r8
800086da:	fa c8 fa b8 	sub	r8,sp,-1352
800086de:	04 9a       	mov	r10,r2
800086e0:	1a d8       	st.w	--sp,r8
800086e2:	0c 9b       	mov	r11,r6
800086e4:	fa c8 fb b4 	sub	r8,sp,-1100
800086e8:	08 9c       	mov	r12,r4
800086ea:	1a d8       	st.w	--sp,r8
800086ec:	fa c8 f9 40 	sub	r8,sp,-1728
800086f0:	fa c9 ff b4 	sub	r9,sp,-76
800086f4:	fe b0 f4 be 	rcall	80007070 <get_arg>
800086f8:	2f dd       	sub	sp,-12
800086fa:	f8 ea 00 00 	ld.d	r10,r12[0]
800086fe:	c0 c8       	rjmp	80008716 <_vfprintf_r+0x1376>
80008700:	ee ca ff ff 	sub	r10,r7,-1
80008704:	10 37       	cp.w	r7,r8
80008706:	c0 b4       	brge	8000871c <_vfprintf_r+0x137c>
80008708:	fa c9 f9 44 	sub	r9,sp,-1724
8000870c:	14 97       	mov	r7,r10
8000870e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008712:	ec ea fd 88 	ld.d	r10,r6[-632]
80008716:	fa eb 00 00 	st.d	sp[0],r10
8000871a:	cc e8       	rjmp	800088b6 <_vfprintf_r+0x1516>
8000871c:	41 09       	lddsp	r9,sp[0x40]
8000871e:	59 f8       	cp.w	r8,31
80008720:	e0 89 00 16 	brgt	8000874c <_vfprintf_r+0x13ac>
80008724:	f2 e6 00 00 	ld.d	r6,r9[0]
80008728:	f2 cb ff f8 	sub	r11,r9,-8
8000872c:	fa e7 00 00 	st.d	sp[0],r6
80008730:	51 0b       	stdsp	sp[0x40],r11
80008732:	fa c6 f9 44 	sub	r6,sp,-1724
80008736:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000873a:	fa e6 00 00 	ld.d	r6,sp[0]
8000873e:	f2 e7 fd 88 	st.d	r9[-632],r6
80008742:	2f f8       	sub	r8,-1
80008744:	14 97       	mov	r7,r10
80008746:	fb 48 06 b4 	st.w	sp[1716],r8
8000874a:	cb 68       	rjmp	800088b6 <_vfprintf_r+0x1516>
8000874c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008750:	2f 89       	sub	r9,-8
80008752:	fa e7 00 00 	st.d	sp[0],r6
80008756:	51 09       	stdsp	sp[0x40],r9
80008758:	14 97       	mov	r7,r10
8000875a:	ca e8       	rjmp	800088b6 <_vfprintf_r+0x1516>
8000875c:	ed b5 00 04 	bld	r5,0x4
80008760:	c1 71       	brne	8000878e <_vfprintf_r+0x13ee>
80008762:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008766:	40 3e       	lddsp	lr,sp[0xc]
80008768:	58 0e       	cp.w	lr,0
8000876a:	c0 80       	breq	8000877a <_vfprintf_r+0x13da>
8000876c:	10 36       	cp.w	r6,r8
8000876e:	c6 94       	brge	80008840 <_vfprintf_r+0x14a0>
80008770:	fa cc f9 44 	sub	r12,sp,-1724
80008774:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008778:	c8 28       	rjmp	8000887c <_vfprintf_r+0x14dc>
8000877a:	ee ca ff ff 	sub	r10,r7,-1
8000877e:	10 37       	cp.w	r7,r8
80008780:	e0 84 00 81 	brge	80008882 <_vfprintf_r+0x14e2>
80008784:	fa cb f9 44 	sub	r11,sp,-1724
80008788:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000878c:	c7 78       	rjmp	8000887a <_vfprintf_r+0x14da>
8000878e:	ed b5 00 06 	bld	r5,0x6
80008792:	c4 b1       	brne	80008828 <_vfprintf_r+0x1488>
80008794:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008798:	40 3c       	lddsp	r12,sp[0xc]
8000879a:	58 0c       	cp.w	r12,0
8000879c:	c1 d0       	breq	800087d6 <_vfprintf_r+0x1436>
8000879e:	10 36       	cp.w	r6,r8
800087a0:	c0 64       	brge	800087ac <_vfprintf_r+0x140c>
800087a2:	fa cb f9 44 	sub	r11,sp,-1724
800087a6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800087aa:	c1 f8       	rjmp	800087e8 <_vfprintf_r+0x1448>
800087ac:	fa c8 f9 50 	sub	r8,sp,-1712
800087b0:	1a d8       	st.w	--sp,r8
800087b2:	fa c8 fa b8 	sub	r8,sp,-1352
800087b6:	1a d8       	st.w	--sp,r8
800087b8:	fa c8 fb b4 	sub	r8,sp,-1100
800087bc:	1a d8       	st.w	--sp,r8
800087be:	fa c8 f9 40 	sub	r8,sp,-1728
800087c2:	fa c9 ff b4 	sub	r9,sp,-76
800087c6:	04 9a       	mov	r10,r2
800087c8:	0c 9b       	mov	r11,r6
800087ca:	08 9c       	mov	r12,r4
800087cc:	fe b0 f4 52 	rcall	80007070 <get_arg>
800087d0:	2f dd       	sub	sp,-12
800087d2:	98 18       	ld.sh	r8,r12[0x2]
800087d4:	c2 78       	rjmp	80008822 <_vfprintf_r+0x1482>
800087d6:	ee ca ff ff 	sub	r10,r7,-1
800087da:	10 37       	cp.w	r7,r8
800087dc:	c0 a4       	brge	800087f0 <_vfprintf_r+0x1450>
800087de:	fa c9 f9 44 	sub	r9,sp,-1724
800087e2:	14 97       	mov	r7,r10
800087e4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800087e8:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800087ec:	c1 b8       	rjmp	80008822 <_vfprintf_r+0x1482>
800087ee:	d7 03       	nop
800087f0:	41 09       	lddsp	r9,sp[0x40]
800087f2:	59 f8       	cp.w	r8,31
800087f4:	e0 89 00 13 	brgt	8000881a <_vfprintf_r+0x147a>
800087f8:	f2 cb ff fc 	sub	r11,r9,-4
800087fc:	51 0b       	stdsp	sp[0x40],r11
800087fe:	72 09       	ld.w	r9,r9[0x0]
80008800:	fa c6 f9 44 	sub	r6,sp,-1724
80008804:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008808:	2f f8       	sub	r8,-1
8000880a:	f7 49 fd 88 	st.w	r11[-632],r9
8000880e:	fb 48 06 b4 	st.w	sp[1716],r8
80008812:	14 97       	mov	r7,r10
80008814:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008818:	c0 58       	rjmp	80008822 <_vfprintf_r+0x1482>
8000881a:	92 18       	ld.sh	r8,r9[0x2]
8000881c:	14 97       	mov	r7,r10
8000881e:	2f c9       	sub	r9,-4
80008820:	51 09       	stdsp	sp[0x40],r9
80008822:	5c 78       	castu.h	r8
80008824:	50 18       	stdsp	sp[0x4],r8
80008826:	c4 68       	rjmp	800088b2 <_vfprintf_r+0x1512>
80008828:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000882c:	40 3c       	lddsp	r12,sp[0xc]
8000882e:	58 0c       	cp.w	r12,0
80008830:	c1 d0       	breq	8000886a <_vfprintf_r+0x14ca>
80008832:	10 36       	cp.w	r6,r8
80008834:	c0 64       	brge	80008840 <_vfprintf_r+0x14a0>
80008836:	fa cb f9 44 	sub	r11,sp,-1724
8000883a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000883e:	c1 f8       	rjmp	8000887c <_vfprintf_r+0x14dc>
80008840:	fa c8 f9 50 	sub	r8,sp,-1712
80008844:	1a d8       	st.w	--sp,r8
80008846:	fa c8 fa b8 	sub	r8,sp,-1352
8000884a:	0c 9b       	mov	r11,r6
8000884c:	1a d8       	st.w	--sp,r8
8000884e:	fa c8 fb b4 	sub	r8,sp,-1100
80008852:	04 9a       	mov	r10,r2
80008854:	1a d8       	st.w	--sp,r8
80008856:	08 9c       	mov	r12,r4
80008858:	fa c8 f9 40 	sub	r8,sp,-1728
8000885c:	fa c9 ff b4 	sub	r9,sp,-76
80008860:	fe b0 f4 08 	rcall	80007070 <get_arg>
80008864:	2f dd       	sub	sp,-12
80008866:	78 0b       	ld.w	r11,r12[0x0]
80008868:	c2 48       	rjmp	800088b0 <_vfprintf_r+0x1510>
8000886a:	ee ca ff ff 	sub	r10,r7,-1
8000886e:	10 37       	cp.w	r7,r8
80008870:	c0 94       	brge	80008882 <_vfprintf_r+0x14e2>
80008872:	fa c9 f9 44 	sub	r9,sp,-1724
80008876:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000887a:	14 97       	mov	r7,r10
8000887c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008880:	c1 88       	rjmp	800088b0 <_vfprintf_r+0x1510>
80008882:	41 09       	lddsp	r9,sp[0x40]
80008884:	59 f8       	cp.w	r8,31
80008886:	e0 89 00 11 	brgt	800088a8 <_vfprintf_r+0x1508>
8000888a:	f2 cb ff fc 	sub	r11,r9,-4
8000888e:	51 0b       	stdsp	sp[0x40],r11
80008890:	fa c6 f9 44 	sub	r6,sp,-1724
80008894:	72 0b       	ld.w	r11,r9[0x0]
80008896:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000889a:	f3 4b fd 88 	st.w	r9[-632],r11
8000889e:	2f f8       	sub	r8,-1
800088a0:	14 97       	mov	r7,r10
800088a2:	fb 48 06 b4 	st.w	sp[1716],r8
800088a6:	c0 58       	rjmp	800088b0 <_vfprintf_r+0x1510>
800088a8:	72 0b       	ld.w	r11,r9[0x0]
800088aa:	14 97       	mov	r7,r10
800088ac:	2f c9       	sub	r9,-4
800088ae:	51 09       	stdsp	sp[0x40],r9
800088b0:	50 1b       	stdsp	sp[0x4],r11
800088b2:	30 0e       	mov	lr,0
800088b4:	50 0e       	stdsp	sp[0x0],lr
800088b6:	40 08       	lddsp	r8,sp[0x0]
800088b8:	40 1c       	lddsp	r12,sp[0x4]
800088ba:	18 48       	or	r8,r12
800088bc:	5f 19       	srne	r9
800088be:	0a 98       	mov	r8,r5
800088c0:	eb e9 00 09 	and	r9,r5,r9
800088c4:	a1 b8       	sbr	r8,0x1
800088c6:	58 09       	cp.w	r9,0
800088c8:	c0 70       	breq	800088d6 <_vfprintf_r+0x1536>
800088ca:	10 95       	mov	r5,r8
800088cc:	fb 60 06 b9 	st.b	sp[1721],r0
800088d0:	33 08       	mov	r8,48
800088d2:	fb 68 06 b8 	st.b	sp[1720],r8
800088d6:	30 28       	mov	r8,2
800088d8:	30 09       	mov	r9,0
800088da:	fb 69 06 bb 	st.b	sp[1723],r9
800088de:	0a 99       	mov	r9,r5
800088e0:	a7 d9       	cbr	r9,0x7
800088e2:	40 2b       	lddsp	r11,sp[0x8]
800088e4:	40 16       	lddsp	r6,sp[0x4]
800088e6:	58 0b       	cp.w	r11,0
800088e8:	5f 1a       	srne	r10
800088ea:	f2 05 17 40 	movge	r5,r9
800088ee:	fa c2 f9 78 	sub	r2,sp,-1672
800088f2:	40 09       	lddsp	r9,sp[0x0]
800088f4:	0c 49       	or	r9,r6
800088f6:	5f 19       	srne	r9
800088f8:	f5 e9 10 09 	or	r9,r10,r9
800088fc:	c5 c0       	breq	800089b4 <_vfprintf_r+0x1614>
800088fe:	30 19       	mov	r9,1
80008900:	f2 08 18 00 	cp.b	r8,r9
80008904:	c0 60       	breq	80008910 <_vfprintf_r+0x1570>
80008906:	30 29       	mov	r9,2
80008908:	f2 08 18 00 	cp.b	r8,r9
8000890c:	c0 41       	brne	80008914 <_vfprintf_r+0x1574>
8000890e:	c3 c8       	rjmp	80008986 <_vfprintf_r+0x15e6>
80008910:	04 96       	mov	r6,r2
80008912:	c3 08       	rjmp	80008972 <_vfprintf_r+0x15d2>
80008914:	04 96       	mov	r6,r2
80008916:	fa e8 00 00 	ld.d	r8,sp[0]
8000891a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000891e:	2d 0a       	sub	r10,-48
80008920:	0c fa       	st.b	--r6,r10
80008922:	f0 0b 16 03 	lsr	r11,r8,0x3
80008926:	f2 0c 16 03 	lsr	r12,r9,0x3
8000892a:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000892e:	18 99       	mov	r9,r12
80008930:	16 98       	mov	r8,r11
80008932:	58 08       	cp.w	r8,0
80008934:	5c 29       	cpc	r9
80008936:	cf 21       	brne	8000891a <_vfprintf_r+0x157a>
80008938:	fa e9 00 00 	st.d	sp[0],r8
8000893c:	ed b5 00 00 	bld	r5,0x0
80008940:	c4 51       	brne	800089ca <_vfprintf_r+0x162a>
80008942:	33 09       	mov	r9,48
80008944:	f2 0a 18 00 	cp.b	r10,r9
80008948:	c4 10       	breq	800089ca <_vfprintf_r+0x162a>
8000894a:	0c f9       	st.b	--r6,r9
8000894c:	c3 f8       	rjmp	800089ca <_vfprintf_r+0x162a>
8000894e:	fa ea 00 00 	ld.d	r10,sp[0]
80008952:	30 a8       	mov	r8,10
80008954:	30 09       	mov	r9,0
80008956:	e0 a0 1a 0d 	rcall	8000bd70 <__avr32_umod64>
8000895a:	30 a8       	mov	r8,10
8000895c:	2d 0a       	sub	r10,-48
8000895e:	30 09       	mov	r9,0
80008960:	ac 8a       	st.b	r6[0x0],r10
80008962:	fa ea 00 00 	ld.d	r10,sp[0]
80008966:	e0 a0 18 d3 	rcall	8000bb0c <__avr32_udiv64>
8000896a:	16 99       	mov	r9,r11
8000896c:	14 98       	mov	r8,r10
8000896e:	fa e9 00 00 	st.d	sp[0],r8
80008972:	20 16       	sub	r6,1
80008974:	fa ea 00 00 	ld.d	r10,sp[0]
80008978:	58 9a       	cp.w	r10,9
8000897a:	5c 2b       	cpc	r11
8000897c:	fe 9b ff e9 	brhi	8000894e <_vfprintf_r+0x15ae>
80008980:	1b f8       	ld.ub	r8,sp[0x7]
80008982:	2d 08       	sub	r8,-48
80008984:	c2 08       	rjmp	800089c4 <_vfprintf_r+0x1624>
80008986:	04 96       	mov	r6,r2
80008988:	fa e8 00 00 	ld.d	r8,sp[0]
8000898c:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80008990:	40 de       	lddsp	lr,sp[0x34]
80008992:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80008996:	0c fa       	st.b	--r6,r10
80008998:	f2 0b 16 04 	lsr	r11,r9,0x4
8000899c:	f0 0a 16 04 	lsr	r10,r8,0x4
800089a0:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800089a4:	16 99       	mov	r9,r11
800089a6:	14 98       	mov	r8,r10
800089a8:	58 08       	cp.w	r8,0
800089aa:	5c 29       	cpc	r9
800089ac:	cf 01       	brne	8000898c <_vfprintf_r+0x15ec>
800089ae:	fa e9 00 00 	st.d	sp[0],r8
800089b2:	c0 c8       	rjmp	800089ca <_vfprintf_r+0x162a>
800089b4:	58 08       	cp.w	r8,0
800089b6:	c0 91       	brne	800089c8 <_vfprintf_r+0x1628>
800089b8:	ed b5 00 00 	bld	r5,0x0
800089bc:	c0 61       	brne	800089c8 <_vfprintf_r+0x1628>
800089be:	fa c6 f9 79 	sub	r6,sp,-1671
800089c2:	33 08       	mov	r8,48
800089c4:	ac 88       	st.b	r6[0x0],r8
800089c6:	c0 28       	rjmp	800089ca <_vfprintf_r+0x162a>
800089c8:	04 96       	mov	r6,r2
800089ca:	0c 12       	sub	r2,r6
800089cc:	c1 c8       	rjmp	80008a04 <_vfprintf_r+0x1664>
800089ce:	50 a7       	stdsp	sp[0x28],r7
800089d0:	50 80       	stdsp	sp[0x20],r0
800089d2:	40 93       	lddsp	r3,sp[0x24]
800089d4:	0c 97       	mov	r7,r6
800089d6:	10 90       	mov	r0,r8
800089d8:	04 94       	mov	r4,r2
800089da:	40 41       	lddsp	r1,sp[0x10]
800089dc:	58 08       	cp.w	r8,0
800089de:	e0 80 04 4f 	breq	8000927c <_vfprintf_r+0x1edc>
800089e2:	fb 68 06 60 	st.b	sp[1632],r8
800089e6:	30 0c       	mov	r12,0
800089e8:	30 08       	mov	r8,0
800089ea:	30 12       	mov	r2,1
800089ec:	fb 68 06 bb 	st.b	sp[1723],r8
800089f0:	50 2c       	stdsp	sp[0x8],r12
800089f2:	fa c6 f9 a0 	sub	r6,sp,-1632
800089f6:	c0 78       	rjmp	80008a04 <_vfprintf_r+0x1664>
800089f8:	30 0b       	mov	r11,0
800089fa:	50 2b       	stdsp	sp[0x8],r11
800089fc:	c0 48       	rjmp	80008a04 <_vfprintf_r+0x1664>
800089fe:	40 22       	lddsp	r2,sp[0x8]
80008a00:	30 0a       	mov	r10,0
80008a02:	50 2a       	stdsp	sp[0x8],r10
80008a04:	40 29       	lddsp	r9,sp[0x8]
80008a06:	e4 09 0c 49 	max	r9,r2,r9
80008a0a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008a0e:	50 39       	stdsp	sp[0xc],r9
80008a10:	0a 9e       	mov	lr,r5
80008a12:	30 09       	mov	r9,0
80008a14:	e2 1e 00 02 	andl	lr,0x2,COH
80008a18:	f2 08 18 00 	cp.b	r8,r9
80008a1c:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80008a20:	f7 b8 01 ff 	subne	r8,-1
80008a24:	fb f8 1a 03 	st.wne	sp[0xc],r8
80008a28:	0a 9b       	mov	r11,r5
80008a2a:	58 0e       	cp.w	lr,0
80008a2c:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80008a30:	f7 bc 01 fe 	subne	r12,-2
80008a34:	fb fc 1a 03 	st.wne	sp[0xc],r12
80008a38:	e2 1b 00 84 	andl	r11,0x84,COH
80008a3c:	50 fe       	stdsp	sp[0x3c],lr
80008a3e:	50 9b       	stdsp	sp[0x24],r11
80008a40:	c4 71       	brne	80008ace <_vfprintf_r+0x172e>
80008a42:	40 8a       	lddsp	r10,sp[0x20]
80008a44:	40 39       	lddsp	r9,sp[0xc]
80008a46:	12 1a       	sub	r10,r9
80008a48:	50 4a       	stdsp	sp[0x10],r10
80008a4a:	58 0a       	cp.w	r10,0
80008a4c:	e0 89 00 20 	brgt	80008a8c <_vfprintf_r+0x16ec>
80008a50:	c3 f8       	rjmp	80008ace <_vfprintf_r+0x172e>
80008a52:	2f 09       	sub	r9,-16
80008a54:	2f f8       	sub	r8,-1
80008a56:	fe ce b3 8a 	sub	lr,pc,-19574
80008a5a:	31 0c       	mov	r12,16
80008a5c:	fb 49 06 90 	st.w	sp[1680],r9
80008a60:	87 0e       	st.w	r3[0x0],lr
80008a62:	87 1c       	st.w	r3[0x4],r12
80008a64:	fb 48 06 8c 	st.w	sp[1676],r8
80008a68:	58 78       	cp.w	r8,7
80008a6a:	e0 89 00 04 	brgt	80008a72 <_vfprintf_r+0x16d2>
80008a6e:	2f 83       	sub	r3,-8
80008a70:	c0 b8       	rjmp	80008a86 <_vfprintf_r+0x16e6>
80008a72:	fa ca f9 78 	sub	r10,sp,-1672
80008a76:	02 9b       	mov	r11,r1
80008a78:	08 9c       	mov	r12,r4
80008a7a:	fe b0 f4 85 	rcall	80007384 <__sprint_r>
80008a7e:	e0 81 04 10 	brne	8000929e <_vfprintf_r+0x1efe>
80008a82:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a86:	40 4b       	lddsp	r11,sp[0x10]
80008a88:	21 0b       	sub	r11,16
80008a8a:	50 4b       	stdsp	sp[0x10],r11
80008a8c:	fa f9 06 90 	ld.w	r9,sp[1680]
80008a90:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a94:	fe ca b3 c8 	sub	r10,pc,-19512
80008a98:	40 4e       	lddsp	lr,sp[0x10]
80008a9a:	59 0e       	cp.w	lr,16
80008a9c:	fe 99 ff db 	brgt	80008a52 <_vfprintf_r+0x16b2>
80008aa0:	1c 09       	add	r9,lr
80008aa2:	2f f8       	sub	r8,-1
80008aa4:	87 0a       	st.w	r3[0x0],r10
80008aa6:	fb 49 06 90 	st.w	sp[1680],r9
80008aaa:	87 1e       	st.w	r3[0x4],lr
80008aac:	fb 48 06 8c 	st.w	sp[1676],r8
80008ab0:	58 78       	cp.w	r8,7
80008ab2:	e0 89 00 04 	brgt	80008aba <_vfprintf_r+0x171a>
80008ab6:	2f 83       	sub	r3,-8
80008ab8:	c0 b8       	rjmp	80008ace <_vfprintf_r+0x172e>
80008aba:	fa ca f9 78 	sub	r10,sp,-1672
80008abe:	02 9b       	mov	r11,r1
80008ac0:	08 9c       	mov	r12,r4
80008ac2:	fe b0 f4 61 	rcall	80007384 <__sprint_r>
80008ac6:	e0 81 03 ec 	brne	8000929e <_vfprintf_r+0x1efe>
80008aca:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ace:	30 09       	mov	r9,0
80008ad0:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008ad4:	f2 08 18 00 	cp.b	r8,r9
80008ad8:	c1 f0       	breq	80008b16 <_vfprintf_r+0x1776>
80008ada:	fa f8 06 90 	ld.w	r8,sp[1680]
80008ade:	fa c9 f9 45 	sub	r9,sp,-1723
80008ae2:	2f f8       	sub	r8,-1
80008ae4:	87 09       	st.w	r3[0x0],r9
80008ae6:	fb 48 06 90 	st.w	sp[1680],r8
80008aea:	30 19       	mov	r9,1
80008aec:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008af0:	87 19       	st.w	r3[0x4],r9
80008af2:	2f f8       	sub	r8,-1
80008af4:	fb 48 06 8c 	st.w	sp[1676],r8
80008af8:	58 78       	cp.w	r8,7
80008afa:	e0 89 00 04 	brgt	80008b02 <_vfprintf_r+0x1762>
80008afe:	2f 83       	sub	r3,-8
80008b00:	c0 b8       	rjmp	80008b16 <_vfprintf_r+0x1776>
80008b02:	fa ca f9 78 	sub	r10,sp,-1672
80008b06:	02 9b       	mov	r11,r1
80008b08:	08 9c       	mov	r12,r4
80008b0a:	fe b0 f4 3d 	rcall	80007384 <__sprint_r>
80008b0e:	e0 81 03 c8 	brne	8000929e <_vfprintf_r+0x1efe>
80008b12:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b16:	40 fc       	lddsp	r12,sp[0x3c]
80008b18:	58 0c       	cp.w	r12,0
80008b1a:	c1 f0       	breq	80008b58 <_vfprintf_r+0x17b8>
80008b1c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b20:	fa c9 f9 48 	sub	r9,sp,-1720
80008b24:	2f e8       	sub	r8,-2
80008b26:	87 09       	st.w	r3[0x0],r9
80008b28:	fb 48 06 90 	st.w	sp[1680],r8
80008b2c:	30 29       	mov	r9,2
80008b2e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b32:	87 19       	st.w	r3[0x4],r9
80008b34:	2f f8       	sub	r8,-1
80008b36:	fb 48 06 8c 	st.w	sp[1676],r8
80008b3a:	58 78       	cp.w	r8,7
80008b3c:	e0 89 00 04 	brgt	80008b44 <_vfprintf_r+0x17a4>
80008b40:	2f 83       	sub	r3,-8
80008b42:	c0 b8       	rjmp	80008b58 <_vfprintf_r+0x17b8>
80008b44:	fa ca f9 78 	sub	r10,sp,-1672
80008b48:	02 9b       	mov	r11,r1
80008b4a:	08 9c       	mov	r12,r4
80008b4c:	fe b0 f4 1c 	rcall	80007384 <__sprint_r>
80008b50:	e0 81 03 a7 	brne	8000929e <_vfprintf_r+0x1efe>
80008b54:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b58:	40 9b       	lddsp	r11,sp[0x24]
80008b5a:	e0 4b 00 80 	cp.w	r11,128
80008b5e:	c4 71       	brne	80008bec <_vfprintf_r+0x184c>
80008b60:	40 8a       	lddsp	r10,sp[0x20]
80008b62:	40 39       	lddsp	r9,sp[0xc]
80008b64:	12 1a       	sub	r10,r9
80008b66:	50 4a       	stdsp	sp[0x10],r10
80008b68:	58 0a       	cp.w	r10,0
80008b6a:	e0 89 00 20 	brgt	80008baa <_vfprintf_r+0x180a>
80008b6e:	c3 f8       	rjmp	80008bec <_vfprintf_r+0x184c>
80008b70:	2f 09       	sub	r9,-16
80008b72:	2f f8       	sub	r8,-1
80008b74:	fe ce b4 98 	sub	lr,pc,-19304
80008b78:	31 0c       	mov	r12,16
80008b7a:	fb 49 06 90 	st.w	sp[1680],r9
80008b7e:	87 0e       	st.w	r3[0x0],lr
80008b80:	87 1c       	st.w	r3[0x4],r12
80008b82:	fb 48 06 8c 	st.w	sp[1676],r8
80008b86:	58 78       	cp.w	r8,7
80008b88:	e0 89 00 04 	brgt	80008b90 <_vfprintf_r+0x17f0>
80008b8c:	2f 83       	sub	r3,-8
80008b8e:	c0 b8       	rjmp	80008ba4 <_vfprintf_r+0x1804>
80008b90:	fa ca f9 78 	sub	r10,sp,-1672
80008b94:	02 9b       	mov	r11,r1
80008b96:	08 9c       	mov	r12,r4
80008b98:	fe b0 f3 f6 	rcall	80007384 <__sprint_r>
80008b9c:	e0 81 03 81 	brne	8000929e <_vfprintf_r+0x1efe>
80008ba0:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ba4:	40 4b       	lddsp	r11,sp[0x10]
80008ba6:	21 0b       	sub	r11,16
80008ba8:	50 4b       	stdsp	sp[0x10],r11
80008baa:	fa f9 06 90 	ld.w	r9,sp[1680]
80008bae:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008bb2:	fe ca b4 d6 	sub	r10,pc,-19242
80008bb6:	40 4e       	lddsp	lr,sp[0x10]
80008bb8:	59 0e       	cp.w	lr,16
80008bba:	fe 99 ff db 	brgt	80008b70 <_vfprintf_r+0x17d0>
80008bbe:	1c 09       	add	r9,lr
80008bc0:	2f f8       	sub	r8,-1
80008bc2:	87 0a       	st.w	r3[0x0],r10
80008bc4:	fb 49 06 90 	st.w	sp[1680],r9
80008bc8:	87 1e       	st.w	r3[0x4],lr
80008bca:	fb 48 06 8c 	st.w	sp[1676],r8
80008bce:	58 78       	cp.w	r8,7
80008bd0:	e0 89 00 04 	brgt	80008bd8 <_vfprintf_r+0x1838>
80008bd4:	2f 83       	sub	r3,-8
80008bd6:	c0 b8       	rjmp	80008bec <_vfprintf_r+0x184c>
80008bd8:	fa ca f9 78 	sub	r10,sp,-1672
80008bdc:	02 9b       	mov	r11,r1
80008bde:	08 9c       	mov	r12,r4
80008be0:	fe b0 f3 d2 	rcall	80007384 <__sprint_r>
80008be4:	e0 81 03 5d 	brne	8000929e <_vfprintf_r+0x1efe>
80008be8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008bec:	40 2c       	lddsp	r12,sp[0x8]
80008bee:	04 1c       	sub	r12,r2
80008bf0:	50 2c       	stdsp	sp[0x8],r12
80008bf2:	58 0c       	cp.w	r12,0
80008bf4:	e0 89 00 20 	brgt	80008c34 <_vfprintf_r+0x1894>
80008bf8:	c3 f8       	rjmp	80008c76 <_vfprintf_r+0x18d6>
80008bfa:	2f 09       	sub	r9,-16
80008bfc:	2f f8       	sub	r8,-1
80008bfe:	fe cb b5 22 	sub	r11,pc,-19166
80008c02:	31 0a       	mov	r10,16
80008c04:	fb 49 06 90 	st.w	sp[1680],r9
80008c08:	87 0b       	st.w	r3[0x0],r11
80008c0a:	87 1a       	st.w	r3[0x4],r10
80008c0c:	fb 48 06 8c 	st.w	sp[1676],r8
80008c10:	58 78       	cp.w	r8,7
80008c12:	e0 89 00 04 	brgt	80008c1a <_vfprintf_r+0x187a>
80008c16:	2f 83       	sub	r3,-8
80008c18:	c0 b8       	rjmp	80008c2e <_vfprintf_r+0x188e>
80008c1a:	fa ca f9 78 	sub	r10,sp,-1672
80008c1e:	02 9b       	mov	r11,r1
80008c20:	08 9c       	mov	r12,r4
80008c22:	fe b0 f3 b1 	rcall	80007384 <__sprint_r>
80008c26:	e0 81 03 3c 	brne	8000929e <_vfprintf_r+0x1efe>
80008c2a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c2e:	40 29       	lddsp	r9,sp[0x8]
80008c30:	21 09       	sub	r9,16
80008c32:	50 29       	stdsp	sp[0x8],r9
80008c34:	fa f9 06 90 	ld.w	r9,sp[1680]
80008c38:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c3c:	fe ca b5 60 	sub	r10,pc,-19104
80008c40:	40 2e       	lddsp	lr,sp[0x8]
80008c42:	59 0e       	cp.w	lr,16
80008c44:	fe 99 ff db 	brgt	80008bfa <_vfprintf_r+0x185a>
80008c48:	1c 09       	add	r9,lr
80008c4a:	2f f8       	sub	r8,-1
80008c4c:	87 0a       	st.w	r3[0x0],r10
80008c4e:	fb 49 06 90 	st.w	sp[1680],r9
80008c52:	87 1e       	st.w	r3[0x4],lr
80008c54:	fb 48 06 8c 	st.w	sp[1676],r8
80008c58:	58 78       	cp.w	r8,7
80008c5a:	e0 89 00 04 	brgt	80008c62 <_vfprintf_r+0x18c2>
80008c5e:	2f 83       	sub	r3,-8
80008c60:	c0 b8       	rjmp	80008c76 <_vfprintf_r+0x18d6>
80008c62:	fa ca f9 78 	sub	r10,sp,-1672
80008c66:	02 9b       	mov	r11,r1
80008c68:	08 9c       	mov	r12,r4
80008c6a:	fe b0 f3 8d 	rcall	80007384 <__sprint_r>
80008c6e:	e0 81 03 18 	brne	8000929e <_vfprintf_r+0x1efe>
80008c72:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c76:	ed b5 00 08 	bld	r5,0x8
80008c7a:	c0 b0       	breq	80008c90 <_vfprintf_r+0x18f0>
80008c7c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c80:	87 12       	st.w	r3[0x4],r2
80008c82:	87 06       	st.w	r3[0x0],r6
80008c84:	f0 02 00 02 	add	r2,r8,r2
80008c88:	fb 42 06 90 	st.w	sp[1680],r2
80008c8c:	e0 8f 01 d4 	bral	80009034 <_vfprintf_r+0x1c94>
80008c90:	e0 40 00 65 	cp.w	r0,101
80008c94:	e0 8a 01 d6 	brle	80009040 <_vfprintf_r+0x1ca0>
80008c98:	30 08       	mov	r8,0
80008c9a:	30 09       	mov	r9,0
80008c9c:	40 5b       	lddsp	r11,sp[0x14]
80008c9e:	40 7a       	lddsp	r10,sp[0x1c]
80008ca0:	e0 a0 15 2f 	rcall	8000b6fe <__avr32_f64_cmp_eq>
80008ca4:	c7 90       	breq	80008d96 <_vfprintf_r+0x19f6>
80008ca6:	fa f8 06 90 	ld.w	r8,sp[1680]
80008caa:	fe c9 b5 e2 	sub	r9,pc,-18974
80008cae:	2f f8       	sub	r8,-1
80008cb0:	87 09       	st.w	r3[0x0],r9
80008cb2:	fb 48 06 90 	st.w	sp[1680],r8
80008cb6:	30 19       	mov	r9,1
80008cb8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008cbc:	87 19       	st.w	r3[0x4],r9
80008cbe:	2f f8       	sub	r8,-1
80008cc0:	fb 48 06 8c 	st.w	sp[1676],r8
80008cc4:	58 78       	cp.w	r8,7
80008cc6:	e0 89 00 05 	brgt	80008cd0 <_vfprintf_r+0x1930>
80008cca:	2f 83       	sub	r3,-8
80008ccc:	c0 c8       	rjmp	80008ce4 <_vfprintf_r+0x1944>
80008cce:	d7 03       	nop
80008cd0:	fa ca f9 78 	sub	r10,sp,-1672
80008cd4:	02 9b       	mov	r11,r1
80008cd6:	08 9c       	mov	r12,r4
80008cd8:	fe b0 f3 56 	rcall	80007384 <__sprint_r>
80008cdc:	e0 81 02 e1 	brne	8000929e <_vfprintf_r+0x1efe>
80008ce0:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ce4:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008ce8:	40 6c       	lddsp	r12,sp[0x18]
80008cea:	18 38       	cp.w	r8,r12
80008cec:	c0 55       	brlt	80008cf6 <_vfprintf_r+0x1956>
80008cee:	ed b5 00 00 	bld	r5,0x0
80008cf2:	e0 81 02 6b 	brne	800091c8 <_vfprintf_r+0x1e28>
80008cf6:	fa f8 06 90 	ld.w	r8,sp[1680]
80008cfa:	2f f8       	sub	r8,-1
80008cfc:	40 cb       	lddsp	r11,sp[0x30]
80008cfe:	fb 48 06 90 	st.w	sp[1680],r8
80008d02:	30 19       	mov	r9,1
80008d04:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d08:	87 0b       	st.w	r3[0x0],r11
80008d0a:	2f f8       	sub	r8,-1
80008d0c:	87 19       	st.w	r3[0x4],r9
80008d0e:	fb 48 06 8c 	st.w	sp[1676],r8
80008d12:	58 78       	cp.w	r8,7
80008d14:	e0 89 00 04 	brgt	80008d1c <_vfprintf_r+0x197c>
80008d18:	2f 83       	sub	r3,-8
80008d1a:	c0 b8       	rjmp	80008d30 <_vfprintf_r+0x1990>
80008d1c:	fa ca f9 78 	sub	r10,sp,-1672
80008d20:	02 9b       	mov	r11,r1
80008d22:	08 9c       	mov	r12,r4
80008d24:	fe b0 f3 30 	rcall	80007384 <__sprint_r>
80008d28:	e0 81 02 bb 	brne	8000929e <_vfprintf_r+0x1efe>
80008d2c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d30:	40 66       	lddsp	r6,sp[0x18]
80008d32:	20 16       	sub	r6,1
80008d34:	58 06       	cp.w	r6,0
80008d36:	e0 89 00 1d 	brgt	80008d70 <_vfprintf_r+0x19d0>
80008d3a:	e0 8f 02 47 	bral	800091c8 <_vfprintf_r+0x1e28>
80008d3e:	2f 09       	sub	r9,-16
80008d40:	2f f8       	sub	r8,-1
80008d42:	fb 49 06 90 	st.w	sp[1680],r9
80008d46:	87 02       	st.w	r3[0x0],r2
80008d48:	87 10       	st.w	r3[0x4],r0
80008d4a:	fb 48 06 8c 	st.w	sp[1676],r8
80008d4e:	58 78       	cp.w	r8,7
80008d50:	e0 89 00 04 	brgt	80008d58 <_vfprintf_r+0x19b8>
80008d54:	2f 83       	sub	r3,-8
80008d56:	c0 b8       	rjmp	80008d6c <_vfprintf_r+0x19cc>
80008d58:	fa ca f9 78 	sub	r10,sp,-1672
80008d5c:	02 9b       	mov	r11,r1
80008d5e:	08 9c       	mov	r12,r4
80008d60:	fe b0 f3 12 	rcall	80007384 <__sprint_r>
80008d64:	e0 81 02 9d 	brne	8000929e <_vfprintf_r+0x1efe>
80008d68:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d6c:	21 06       	sub	r6,16
80008d6e:	c0 48       	rjmp	80008d76 <_vfprintf_r+0x19d6>
80008d70:	fe c2 b6 94 	sub	r2,pc,-18796
80008d74:	31 00       	mov	r0,16
80008d76:	fa f9 06 90 	ld.w	r9,sp[1680]
80008d7a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d7e:	fe ca b6 a2 	sub	r10,pc,-18782
80008d82:	59 06       	cp.w	r6,16
80008d84:	fe 99 ff dd 	brgt	80008d3e <_vfprintf_r+0x199e>
80008d88:	0c 09       	add	r9,r6
80008d8a:	87 0a       	st.w	r3[0x0],r10
80008d8c:	fb 49 06 90 	st.w	sp[1680],r9
80008d90:	2f f8       	sub	r8,-1
80008d92:	87 16       	st.w	r3[0x4],r6
80008d94:	c5 39       	rjmp	8000903a <_vfprintf_r+0x1c9a>
80008d96:	fa fa 06 ac 	ld.w	r10,sp[1708]
80008d9a:	58 0a       	cp.w	r10,0
80008d9c:	e0 89 00 92 	brgt	80008ec0 <_vfprintf_r+0x1b20>
80008da0:	fa f8 06 90 	ld.w	r8,sp[1680]
80008da4:	fe c9 b6 dc 	sub	r9,pc,-18724
80008da8:	2f f8       	sub	r8,-1
80008daa:	87 09       	st.w	r3[0x0],r9
80008dac:	fb 48 06 90 	st.w	sp[1680],r8
80008db0:	30 19       	mov	r9,1
80008db2:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008db6:	87 19       	st.w	r3[0x4],r9
80008db8:	2f f8       	sub	r8,-1
80008dba:	fb 48 06 8c 	st.w	sp[1676],r8
80008dbe:	58 78       	cp.w	r8,7
80008dc0:	e0 89 00 04 	brgt	80008dc8 <_vfprintf_r+0x1a28>
80008dc4:	2f 83       	sub	r3,-8
80008dc6:	c0 b8       	rjmp	80008ddc <_vfprintf_r+0x1a3c>
80008dc8:	fa ca f9 78 	sub	r10,sp,-1672
80008dcc:	02 9b       	mov	r11,r1
80008dce:	08 9c       	mov	r12,r4
80008dd0:	fe b0 f2 da 	rcall	80007384 <__sprint_r>
80008dd4:	e0 81 02 65 	brne	8000929e <_vfprintf_r+0x1efe>
80008dd8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ddc:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008de0:	58 08       	cp.w	r8,0
80008de2:	c0 81       	brne	80008df2 <_vfprintf_r+0x1a52>
80008de4:	40 6a       	lddsp	r10,sp[0x18]
80008de6:	58 0a       	cp.w	r10,0
80008de8:	c0 51       	brne	80008df2 <_vfprintf_r+0x1a52>
80008dea:	ed b5 00 00 	bld	r5,0x0
80008dee:	e0 81 01 ed 	brne	800091c8 <_vfprintf_r+0x1e28>
80008df2:	40 c9       	lddsp	r9,sp[0x30]
80008df4:	fa f8 06 90 	ld.w	r8,sp[1680]
80008df8:	2f f8       	sub	r8,-1
80008dfa:	87 09       	st.w	r3[0x0],r9
80008dfc:	fb 48 06 90 	st.w	sp[1680],r8
80008e00:	30 19       	mov	r9,1
80008e02:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e06:	87 19       	st.w	r3[0x4],r9
80008e08:	2f f8       	sub	r8,-1
80008e0a:	fb 48 06 8c 	st.w	sp[1676],r8
80008e0e:	58 78       	cp.w	r8,7
80008e10:	e0 89 00 04 	brgt	80008e18 <_vfprintf_r+0x1a78>
80008e14:	2f 83       	sub	r3,-8
80008e16:	c0 b8       	rjmp	80008e2c <_vfprintf_r+0x1a8c>
80008e18:	fa ca f9 78 	sub	r10,sp,-1672
80008e1c:	02 9b       	mov	r11,r1
80008e1e:	08 9c       	mov	r12,r4
80008e20:	fe b0 f2 b2 	rcall	80007384 <__sprint_r>
80008e24:	e0 81 02 3d 	brne	8000929e <_vfprintf_r+0x1efe>
80008e28:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e2c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008e30:	5c 32       	neg	r2
80008e32:	58 02       	cp.w	r2,0
80008e34:	e0 89 00 1d 	brgt	80008e6e <_vfprintf_r+0x1ace>
80008e38:	c3 d8       	rjmp	80008eb2 <_vfprintf_r+0x1b12>
80008e3a:	2f 09       	sub	r9,-16
80008e3c:	2f f8       	sub	r8,-1
80008e3e:	31 0e       	mov	lr,16
80008e40:	fb 49 06 90 	st.w	sp[1680],r9
80008e44:	87 00       	st.w	r3[0x0],r0
80008e46:	87 1e       	st.w	r3[0x4],lr
80008e48:	fb 48 06 8c 	st.w	sp[1676],r8
80008e4c:	58 78       	cp.w	r8,7
80008e4e:	e0 89 00 04 	brgt	80008e56 <_vfprintf_r+0x1ab6>
80008e52:	2f 83       	sub	r3,-8
80008e54:	c0 b8       	rjmp	80008e6a <_vfprintf_r+0x1aca>
80008e56:	fa ca f9 78 	sub	r10,sp,-1672
80008e5a:	02 9b       	mov	r11,r1
80008e5c:	08 9c       	mov	r12,r4
80008e5e:	fe b0 f2 93 	rcall	80007384 <__sprint_r>
80008e62:	e0 81 02 1e 	brne	8000929e <_vfprintf_r+0x1efe>
80008e66:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e6a:	21 02       	sub	r2,16
80008e6c:	c0 38       	rjmp	80008e72 <_vfprintf_r+0x1ad2>
80008e6e:	fe c0 b7 92 	sub	r0,pc,-18542
80008e72:	fa f9 06 90 	ld.w	r9,sp[1680]
80008e76:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e7a:	fe ca b7 9e 	sub	r10,pc,-18530
80008e7e:	59 02       	cp.w	r2,16
80008e80:	fe 99 ff dd 	brgt	80008e3a <_vfprintf_r+0x1a9a>
80008e84:	04 09       	add	r9,r2
80008e86:	2f f8       	sub	r8,-1
80008e88:	87 0a       	st.w	r3[0x0],r10
80008e8a:	fb 49 06 90 	st.w	sp[1680],r9
80008e8e:	87 12       	st.w	r3[0x4],r2
80008e90:	fb 48 06 8c 	st.w	sp[1676],r8
80008e94:	58 78       	cp.w	r8,7
80008e96:	e0 89 00 04 	brgt	80008e9e <_vfprintf_r+0x1afe>
80008e9a:	2f 83       	sub	r3,-8
80008e9c:	c0 b8       	rjmp	80008eb2 <_vfprintf_r+0x1b12>
80008e9e:	fa ca f9 78 	sub	r10,sp,-1672
80008ea2:	02 9b       	mov	r11,r1
80008ea4:	08 9c       	mov	r12,r4
80008ea6:	fe b0 f2 6f 	rcall	80007384 <__sprint_r>
80008eaa:	e0 81 01 fa 	brne	8000929e <_vfprintf_r+0x1efe>
80008eae:	fa c3 f9 e0 	sub	r3,sp,-1568
80008eb2:	40 6c       	lddsp	r12,sp[0x18]
80008eb4:	fa f8 06 90 	ld.w	r8,sp[1680]
80008eb8:	87 06       	st.w	r3[0x0],r6
80008eba:	87 1c       	st.w	r3[0x4],r12
80008ebc:	18 08       	add	r8,r12
80008ebe:	cb 98       	rjmp	80009030 <_vfprintf_r+0x1c90>
80008ec0:	fa f9 06 90 	ld.w	r9,sp[1680]
80008ec4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ec8:	40 6b       	lddsp	r11,sp[0x18]
80008eca:	16 3a       	cp.w	r10,r11
80008ecc:	c6 f5       	brlt	80008faa <_vfprintf_r+0x1c0a>
80008ece:	16 09       	add	r9,r11
80008ed0:	2f f8       	sub	r8,-1
80008ed2:	87 06       	st.w	r3[0x0],r6
80008ed4:	fb 49 06 90 	st.w	sp[1680],r9
80008ed8:	87 1b       	st.w	r3[0x4],r11
80008eda:	fb 48 06 8c 	st.w	sp[1676],r8
80008ede:	58 78       	cp.w	r8,7
80008ee0:	e0 89 00 04 	brgt	80008ee8 <_vfprintf_r+0x1b48>
80008ee4:	2f 83       	sub	r3,-8
80008ee6:	c0 b8       	rjmp	80008efc <_vfprintf_r+0x1b5c>
80008ee8:	fa ca f9 78 	sub	r10,sp,-1672
80008eec:	02 9b       	mov	r11,r1
80008eee:	08 9c       	mov	r12,r4
80008ef0:	fe b0 f2 4a 	rcall	80007384 <__sprint_r>
80008ef4:	e0 81 01 d5 	brne	8000929e <_vfprintf_r+0x1efe>
80008ef8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008efc:	fa f6 06 ac 	ld.w	r6,sp[1708]
80008f00:	40 6a       	lddsp	r10,sp[0x18]
80008f02:	14 16       	sub	r6,r10
80008f04:	58 06       	cp.w	r6,0
80008f06:	e0 89 00 1c 	brgt	80008f3e <_vfprintf_r+0x1b9e>
80008f0a:	c3 d8       	rjmp	80008f84 <_vfprintf_r+0x1be4>
80008f0c:	2f 09       	sub	r9,-16
80008f0e:	2f f8       	sub	r8,-1
80008f10:	fb 49 06 90 	st.w	sp[1680],r9
80008f14:	87 02       	st.w	r3[0x0],r2
80008f16:	87 10       	st.w	r3[0x4],r0
80008f18:	fb 48 06 8c 	st.w	sp[1676],r8
80008f1c:	58 78       	cp.w	r8,7
80008f1e:	e0 89 00 04 	brgt	80008f26 <_vfprintf_r+0x1b86>
80008f22:	2f 83       	sub	r3,-8
80008f24:	c0 b8       	rjmp	80008f3a <_vfprintf_r+0x1b9a>
80008f26:	fa ca f9 78 	sub	r10,sp,-1672
80008f2a:	02 9b       	mov	r11,r1
80008f2c:	08 9c       	mov	r12,r4
80008f2e:	fe b0 f2 2b 	rcall	80007384 <__sprint_r>
80008f32:	e0 81 01 b6 	brne	8000929e <_vfprintf_r+0x1efe>
80008f36:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f3a:	21 06       	sub	r6,16
80008f3c:	c0 48       	rjmp	80008f44 <_vfprintf_r+0x1ba4>
80008f3e:	fe c2 b8 62 	sub	r2,pc,-18334
80008f42:	31 00       	mov	r0,16
80008f44:	fa f9 06 90 	ld.w	r9,sp[1680]
80008f48:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f4c:	fe ca b8 70 	sub	r10,pc,-18320
80008f50:	59 06       	cp.w	r6,16
80008f52:	fe 99 ff dd 	brgt	80008f0c <_vfprintf_r+0x1b6c>
80008f56:	0c 09       	add	r9,r6
80008f58:	2f f8       	sub	r8,-1
80008f5a:	87 0a       	st.w	r3[0x0],r10
80008f5c:	fb 49 06 90 	st.w	sp[1680],r9
80008f60:	87 16       	st.w	r3[0x4],r6
80008f62:	fb 48 06 8c 	st.w	sp[1676],r8
80008f66:	58 78       	cp.w	r8,7
80008f68:	e0 89 00 04 	brgt	80008f70 <_vfprintf_r+0x1bd0>
80008f6c:	2f 83       	sub	r3,-8
80008f6e:	c0 b8       	rjmp	80008f84 <_vfprintf_r+0x1be4>
80008f70:	fa ca f9 78 	sub	r10,sp,-1672
80008f74:	02 9b       	mov	r11,r1
80008f76:	08 9c       	mov	r12,r4
80008f78:	fe b0 f2 06 	rcall	80007384 <__sprint_r>
80008f7c:	e0 81 01 91 	brne	8000929e <_vfprintf_r+0x1efe>
80008f80:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f84:	ed b5 00 00 	bld	r5,0x0
80008f88:	e0 81 01 20 	brne	800091c8 <_vfprintf_r+0x1e28>
80008f8c:	40 c9       	lddsp	r9,sp[0x30]
80008f8e:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f92:	2f f8       	sub	r8,-1
80008f94:	87 09       	st.w	r3[0x0],r9
80008f96:	fb 48 06 90 	st.w	sp[1680],r8
80008f9a:	30 19       	mov	r9,1
80008f9c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fa0:	87 19       	st.w	r3[0x4],r9
80008fa2:	2f f8       	sub	r8,-1
80008fa4:	fb 48 06 8c 	st.w	sp[1676],r8
80008fa8:	c0 29       	rjmp	800091ac <_vfprintf_r+0x1e0c>
80008faa:	14 09       	add	r9,r10
80008fac:	2f f8       	sub	r8,-1
80008fae:	fb 49 06 90 	st.w	sp[1680],r9
80008fb2:	87 06       	st.w	r3[0x0],r6
80008fb4:	87 1a       	st.w	r3[0x4],r10
80008fb6:	fb 48 06 8c 	st.w	sp[1676],r8
80008fba:	58 78       	cp.w	r8,7
80008fbc:	e0 89 00 04 	brgt	80008fc4 <_vfprintf_r+0x1c24>
80008fc0:	2f 83       	sub	r3,-8
80008fc2:	c0 b8       	rjmp	80008fd8 <_vfprintf_r+0x1c38>
80008fc4:	fa ca f9 78 	sub	r10,sp,-1672
80008fc8:	02 9b       	mov	r11,r1
80008fca:	08 9c       	mov	r12,r4
80008fcc:	fe b0 f1 dc 	rcall	80007384 <__sprint_r>
80008fd0:	e0 81 01 67 	brne	8000929e <_vfprintf_r+0x1efe>
80008fd4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fd8:	40 c8       	lddsp	r8,sp[0x30]
80008fda:	87 08       	st.w	r3[0x0],r8
80008fdc:	fa f8 06 90 	ld.w	r8,sp[1680]
80008fe0:	2f f8       	sub	r8,-1
80008fe2:	30 19       	mov	r9,1
80008fe4:	fb 48 06 90 	st.w	sp[1680],r8
80008fe8:	87 19       	st.w	r3[0x4],r9
80008fea:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fee:	2f f8       	sub	r8,-1
80008ff0:	fb 48 06 8c 	st.w	sp[1676],r8
80008ff4:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008ff8:	58 78       	cp.w	r8,7
80008ffa:	e0 89 00 04 	brgt	80009002 <_vfprintf_r+0x1c62>
80008ffe:	2f 83       	sub	r3,-8
80009000:	c0 b8       	rjmp	80009016 <_vfprintf_r+0x1c76>
80009002:	fa ca f9 78 	sub	r10,sp,-1672
80009006:	02 9b       	mov	r11,r1
80009008:	08 9c       	mov	r12,r4
8000900a:	fe b0 f1 bd 	rcall	80007384 <__sprint_r>
8000900e:	e0 81 01 48 	brne	8000929e <_vfprintf_r+0x1efe>
80009012:	fa c3 f9 e0 	sub	r3,sp,-1568
80009016:	04 06       	add	r6,r2
80009018:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000901c:	87 06       	st.w	r3[0x0],r6
8000901e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009022:	40 66       	lddsp	r6,sp[0x18]
80009024:	40 6e       	lddsp	lr,sp[0x18]
80009026:	10 16       	sub	r6,r8
80009028:	f2 08 01 08 	sub	r8,r9,r8
8000902c:	87 16       	st.w	r3[0x4],r6
8000902e:	1c 08       	add	r8,lr
80009030:	fb 48 06 90 	st.w	sp[1680],r8
80009034:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009038:	2f f8       	sub	r8,-1
8000903a:	fb 48 06 8c 	st.w	sp[1676],r8
8000903e:	cb 78       	rjmp	800091ac <_vfprintf_r+0x1e0c>
80009040:	40 6c       	lddsp	r12,sp[0x18]
80009042:	58 1c       	cp.w	r12,1
80009044:	e0 89 00 06 	brgt	80009050 <_vfprintf_r+0x1cb0>
80009048:	ed b5 00 00 	bld	r5,0x0
8000904c:	e0 81 00 85 	brne	80009156 <_vfprintf_r+0x1db6>
80009050:	fa f8 06 90 	ld.w	r8,sp[1680]
80009054:	2f f8       	sub	r8,-1
80009056:	30 19       	mov	r9,1
80009058:	fb 48 06 90 	st.w	sp[1680],r8
8000905c:	87 06       	st.w	r3[0x0],r6
8000905e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009062:	87 19       	st.w	r3[0x4],r9
80009064:	2f f8       	sub	r8,-1
80009066:	fb 48 06 8c 	st.w	sp[1676],r8
8000906a:	58 78       	cp.w	r8,7
8000906c:	e0 89 00 04 	brgt	80009074 <_vfprintf_r+0x1cd4>
80009070:	2f 83       	sub	r3,-8
80009072:	c0 b8       	rjmp	80009088 <_vfprintf_r+0x1ce8>
80009074:	fa ca f9 78 	sub	r10,sp,-1672
80009078:	02 9b       	mov	r11,r1
8000907a:	08 9c       	mov	r12,r4
8000907c:	fe b0 f1 84 	rcall	80007384 <__sprint_r>
80009080:	e0 81 01 0f 	brne	8000929e <_vfprintf_r+0x1efe>
80009084:	fa c3 f9 e0 	sub	r3,sp,-1568
80009088:	fa f8 06 90 	ld.w	r8,sp[1680]
8000908c:	2f f8       	sub	r8,-1
8000908e:	40 cb       	lddsp	r11,sp[0x30]
80009090:	fb 48 06 90 	st.w	sp[1680],r8
80009094:	30 19       	mov	r9,1
80009096:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000909a:	87 0b       	st.w	r3[0x0],r11
8000909c:	2f f8       	sub	r8,-1
8000909e:	87 19       	st.w	r3[0x4],r9
800090a0:	fb 48 06 8c 	st.w	sp[1676],r8
800090a4:	58 78       	cp.w	r8,7
800090a6:	e0 89 00 05 	brgt	800090b0 <_vfprintf_r+0x1d10>
800090aa:	2f 83       	sub	r3,-8
800090ac:	c0 c8       	rjmp	800090c4 <_vfprintf_r+0x1d24>
800090ae:	d7 03       	nop
800090b0:	fa ca f9 78 	sub	r10,sp,-1672
800090b4:	02 9b       	mov	r11,r1
800090b6:	08 9c       	mov	r12,r4
800090b8:	fe b0 f1 66 	rcall	80007384 <__sprint_r>
800090bc:	e0 81 00 f1 	brne	8000929e <_vfprintf_r+0x1efe>
800090c0:	fa c3 f9 e0 	sub	r3,sp,-1568
800090c4:	30 08       	mov	r8,0
800090c6:	30 09       	mov	r9,0
800090c8:	40 5b       	lddsp	r11,sp[0x14]
800090ca:	40 7a       	lddsp	r10,sp[0x1c]
800090cc:	e0 a0 13 19 	rcall	8000b6fe <__avr32_f64_cmp_eq>
800090d0:	40 68       	lddsp	r8,sp[0x18]
800090d2:	20 18       	sub	r8,1
800090d4:	58 0c       	cp.w	r12,0
800090d6:	c0 d1       	brne	800090f0 <_vfprintf_r+0x1d50>
800090d8:	2f f6       	sub	r6,-1
800090da:	87 18       	st.w	r3[0x4],r8
800090dc:	87 06       	st.w	r3[0x0],r6
800090de:	fa f6 06 90 	ld.w	r6,sp[1680]
800090e2:	10 06       	add	r6,r8
800090e4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800090e8:	fb 46 06 90 	st.w	sp[1680],r6
800090ec:	2f f8       	sub	r8,-1
800090ee:	c3 18       	rjmp	80009150 <_vfprintf_r+0x1db0>
800090f0:	10 96       	mov	r6,r8
800090f2:	58 08       	cp.w	r8,0
800090f4:	e0 89 00 1c 	brgt	8000912c <_vfprintf_r+0x1d8c>
800090f8:	c4 b8       	rjmp	8000918e <_vfprintf_r+0x1dee>
800090fa:	2f 09       	sub	r9,-16
800090fc:	2f f8       	sub	r8,-1
800090fe:	fb 49 06 90 	st.w	sp[1680],r9
80009102:	87 02       	st.w	r3[0x0],r2
80009104:	87 10       	st.w	r3[0x4],r0
80009106:	fb 48 06 8c 	st.w	sp[1676],r8
8000910a:	58 78       	cp.w	r8,7
8000910c:	e0 89 00 04 	brgt	80009114 <_vfprintf_r+0x1d74>
80009110:	2f 83       	sub	r3,-8
80009112:	c0 b8       	rjmp	80009128 <_vfprintf_r+0x1d88>
80009114:	fa ca f9 78 	sub	r10,sp,-1672
80009118:	02 9b       	mov	r11,r1
8000911a:	08 9c       	mov	r12,r4
8000911c:	fe b0 f1 34 	rcall	80007384 <__sprint_r>
80009120:	e0 81 00 bf 	brne	8000929e <_vfprintf_r+0x1efe>
80009124:	fa c3 f9 e0 	sub	r3,sp,-1568
80009128:	21 06       	sub	r6,16
8000912a:	c0 48       	rjmp	80009132 <_vfprintf_r+0x1d92>
8000912c:	fe c2 ba 50 	sub	r2,pc,-17840
80009130:	31 00       	mov	r0,16
80009132:	fa f9 06 90 	ld.w	r9,sp[1680]
80009136:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000913a:	fe ca ba 5e 	sub	r10,pc,-17826
8000913e:	59 06       	cp.w	r6,16
80009140:	fe 99 ff dd 	brgt	800090fa <_vfprintf_r+0x1d5a>
80009144:	0c 09       	add	r9,r6
80009146:	87 0a       	st.w	r3[0x0],r10
80009148:	fb 49 06 90 	st.w	sp[1680],r9
8000914c:	2f f8       	sub	r8,-1
8000914e:	87 16       	st.w	r3[0x4],r6
80009150:	fb 48 06 8c 	st.w	sp[1676],r8
80009154:	c0 e8       	rjmp	80009170 <_vfprintf_r+0x1dd0>
80009156:	fa f8 06 90 	ld.w	r8,sp[1680]
8000915a:	2f f8       	sub	r8,-1
8000915c:	30 19       	mov	r9,1
8000915e:	fb 48 06 90 	st.w	sp[1680],r8
80009162:	87 06       	st.w	r3[0x0],r6
80009164:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009168:	87 19       	st.w	r3[0x4],r9
8000916a:	2f f8       	sub	r8,-1
8000916c:	fb 48 06 8c 	st.w	sp[1676],r8
80009170:	58 78       	cp.w	r8,7
80009172:	e0 89 00 04 	brgt	8000917a <_vfprintf_r+0x1dda>
80009176:	2f 83       	sub	r3,-8
80009178:	c0 b8       	rjmp	8000918e <_vfprintf_r+0x1dee>
8000917a:	fa ca f9 78 	sub	r10,sp,-1672
8000917e:	02 9b       	mov	r11,r1
80009180:	08 9c       	mov	r12,r4
80009182:	fe b0 f1 01 	rcall	80007384 <__sprint_r>
80009186:	e0 81 00 8c 	brne	8000929e <_vfprintf_r+0x1efe>
8000918a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000918e:	40 ea       	lddsp	r10,sp[0x38]
80009190:	fa f8 06 90 	ld.w	r8,sp[1680]
80009194:	14 08       	add	r8,r10
80009196:	fa c9 f9 64 	sub	r9,sp,-1692
8000919a:	fb 48 06 90 	st.w	sp[1680],r8
8000919e:	87 1a       	st.w	r3[0x4],r10
800091a0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800091a4:	87 09       	st.w	r3[0x0],r9
800091a6:	2f f8       	sub	r8,-1
800091a8:	fb 48 06 8c 	st.w	sp[1676],r8
800091ac:	58 78       	cp.w	r8,7
800091ae:	e0 89 00 04 	brgt	800091b6 <_vfprintf_r+0x1e16>
800091b2:	2f 83       	sub	r3,-8
800091b4:	c0 a8       	rjmp	800091c8 <_vfprintf_r+0x1e28>
800091b6:	fa ca f9 78 	sub	r10,sp,-1672
800091ba:	02 9b       	mov	r11,r1
800091bc:	08 9c       	mov	r12,r4
800091be:	fe b0 f0 e3 	rcall	80007384 <__sprint_r>
800091c2:	c6 e1       	brne	8000929e <_vfprintf_r+0x1efe>
800091c4:	fa c3 f9 e0 	sub	r3,sp,-1568
800091c8:	e2 15 00 04 	andl	r5,0x4,COH
800091cc:	c3 f0       	breq	8000924a <_vfprintf_r+0x1eaa>
800091ce:	40 86       	lddsp	r6,sp[0x20]
800091d0:	40 39       	lddsp	r9,sp[0xc]
800091d2:	12 16       	sub	r6,r9
800091d4:	58 06       	cp.w	r6,0
800091d6:	e0 89 00 1a 	brgt	8000920a <_vfprintf_r+0x1e6a>
800091da:	c3 88       	rjmp	8000924a <_vfprintf_r+0x1eaa>
800091dc:	2f 09       	sub	r9,-16
800091de:	2f f8       	sub	r8,-1
800091e0:	fb 49 06 90 	st.w	sp[1680],r9
800091e4:	87 05       	st.w	r3[0x0],r5
800091e6:	87 12       	st.w	r3[0x4],r2
800091e8:	fb 48 06 8c 	st.w	sp[1676],r8
800091ec:	58 78       	cp.w	r8,7
800091ee:	e0 89 00 04 	brgt	800091f6 <_vfprintf_r+0x1e56>
800091f2:	2f 83       	sub	r3,-8
800091f4:	c0 98       	rjmp	80009206 <_vfprintf_r+0x1e66>
800091f6:	00 9a       	mov	r10,r0
800091f8:	02 9b       	mov	r11,r1
800091fa:	08 9c       	mov	r12,r4
800091fc:	fe b0 f0 c4 	rcall	80007384 <__sprint_r>
80009200:	c4 f1       	brne	8000929e <_vfprintf_r+0x1efe>
80009202:	fa c3 f9 e0 	sub	r3,sp,-1568
80009206:	21 06       	sub	r6,16
80009208:	c0 68       	rjmp	80009214 <_vfprintf_r+0x1e74>
8000920a:	fe c5 bb 3e 	sub	r5,pc,-17602
8000920e:	31 02       	mov	r2,16
80009210:	fa c0 f9 78 	sub	r0,sp,-1672
80009214:	fa f9 06 90 	ld.w	r9,sp[1680]
80009218:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000921c:	fe ca bb 50 	sub	r10,pc,-17584
80009220:	59 06       	cp.w	r6,16
80009222:	fe 99 ff dd 	brgt	800091dc <_vfprintf_r+0x1e3c>
80009226:	0c 09       	add	r9,r6
80009228:	2f f8       	sub	r8,-1
8000922a:	87 0a       	st.w	r3[0x0],r10
8000922c:	87 16       	st.w	r3[0x4],r6
8000922e:	fb 49 06 90 	st.w	sp[1680],r9
80009232:	fb 48 06 8c 	st.w	sp[1676],r8
80009236:	58 78       	cp.w	r8,7
80009238:	e0 8a 00 09 	brle	8000924a <_vfprintf_r+0x1eaa>
8000923c:	fa ca f9 78 	sub	r10,sp,-1672
80009240:	02 9b       	mov	r11,r1
80009242:	08 9c       	mov	r12,r4
80009244:	fe b0 f0 a0 	rcall	80007384 <__sprint_r>
80009248:	c2 b1       	brne	8000929e <_vfprintf_r+0x1efe>
8000924a:	40 bc       	lddsp	r12,sp[0x2c]
8000924c:	40 36       	lddsp	r6,sp[0xc]
8000924e:	40 8e       	lddsp	lr,sp[0x20]
80009250:	ec 0e 0c 48 	max	r8,r6,lr
80009254:	10 0c       	add	r12,r8
80009256:	50 bc       	stdsp	sp[0x2c],r12
80009258:	fa f8 06 90 	ld.w	r8,sp[1680]
8000925c:	58 08       	cp.w	r8,0
8000925e:	c0 80       	breq	8000926e <_vfprintf_r+0x1ece>
80009260:	fa ca f9 78 	sub	r10,sp,-1672
80009264:	02 9b       	mov	r11,r1
80009266:	08 9c       	mov	r12,r4
80009268:	fe b0 f0 8e 	rcall	80007384 <__sprint_r>
8000926c:	c1 91       	brne	8000929e <_vfprintf_r+0x1efe>
8000926e:	30 0b       	mov	r11,0
80009270:	fa c3 f9 e0 	sub	r3,sp,-1568
80009274:	fb 4b 06 8c 	st.w	sp[1676],r11
80009278:	fe 9f f1 22 	bral	800074bc <_vfprintf_r+0x11c>
8000927c:	08 95       	mov	r5,r4
8000927e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009282:	58 08       	cp.w	r8,0
80009284:	c0 80       	breq	80009294 <_vfprintf_r+0x1ef4>
80009286:	08 9c       	mov	r12,r4
80009288:	fa ca f9 78 	sub	r10,sp,-1672
8000928c:	02 9b       	mov	r11,r1
8000928e:	fe b0 f0 7b 	rcall	80007384 <__sprint_r>
80009292:	c0 61       	brne	8000929e <_vfprintf_r+0x1efe>
80009294:	30 08       	mov	r8,0
80009296:	fb 48 06 8c 	st.w	sp[1676],r8
8000929a:	c0 28       	rjmp	8000929e <_vfprintf_r+0x1efe>
8000929c:	40 41       	lddsp	r1,sp[0x10]
8000929e:	82 68       	ld.sh	r8,r1[0xc]
800092a0:	ed b8 00 06 	bld	r8,0x6
800092a4:	c0 31       	brne	800092aa <_vfprintf_r+0x1f0a>
800092a6:	3f fa       	mov	r10,-1
800092a8:	50 ba       	stdsp	sp[0x2c],r10
800092aa:	40 bc       	lddsp	r12,sp[0x2c]
800092ac:	fe 3d f9 44 	sub	sp,-1724
800092b0:	d8 32       	popm	r0-r7,pc
800092b2:	d7 03       	nop

800092b4 <__swsetup_r>:
800092b4:	d4 21       	pushm	r4-r7,lr
800092b6:	e0 68 0a 30 	mov	r8,2608
800092ba:	18 96       	mov	r6,r12
800092bc:	16 97       	mov	r7,r11
800092be:	70 0c       	ld.w	r12,r8[0x0]
800092c0:	58 0c       	cp.w	r12,0
800092c2:	c0 60       	breq	800092ce <__swsetup_r+0x1a>
800092c4:	78 68       	ld.w	r8,r12[0x18]
800092c6:	58 08       	cp.w	r8,0
800092c8:	c0 31       	brne	800092ce <__swsetup_r+0x1a>
800092ca:	e0 a0 07 bf 	rcall	8000a248 <__sinit>
800092ce:	fe c8 ba d2 	sub	r8,pc,-17710
800092d2:	10 37       	cp.w	r7,r8
800092d4:	c0 61       	brne	800092e0 <__swsetup_r+0x2c>
800092d6:	e0 68 0a 30 	mov	r8,2608
800092da:	70 08       	ld.w	r8,r8[0x0]
800092dc:	70 07       	ld.w	r7,r8[0x0]
800092de:	c1 28       	rjmp	80009302 <__swsetup_r+0x4e>
800092e0:	fe c8 ba c4 	sub	r8,pc,-17724
800092e4:	10 37       	cp.w	r7,r8
800092e6:	c0 61       	brne	800092f2 <__swsetup_r+0x3e>
800092e8:	e0 68 0a 30 	mov	r8,2608
800092ec:	70 08       	ld.w	r8,r8[0x0]
800092ee:	70 17       	ld.w	r7,r8[0x4]
800092f0:	c0 98       	rjmp	80009302 <__swsetup_r+0x4e>
800092f2:	fe c8 ba b6 	sub	r8,pc,-17738
800092f6:	10 37       	cp.w	r7,r8
800092f8:	c0 51       	brne	80009302 <__swsetup_r+0x4e>
800092fa:	e0 68 0a 30 	mov	r8,2608
800092fe:	70 08       	ld.w	r8,r8[0x0]
80009300:	70 27       	ld.w	r7,r8[0x8]
80009302:	8e 68       	ld.sh	r8,r7[0xc]
80009304:	ed b8 00 03 	bld	r8,0x3
80009308:	c1 e0       	breq	80009344 <__swsetup_r+0x90>
8000930a:	ed b8 00 04 	bld	r8,0x4
8000930e:	c3 e1       	brne	8000938a <__swsetup_r+0xd6>
80009310:	ed b8 00 02 	bld	r8,0x2
80009314:	c1 51       	brne	8000933e <__swsetup_r+0x8a>
80009316:	6e db       	ld.w	r11,r7[0x34]
80009318:	58 0b       	cp.w	r11,0
8000931a:	c0 a0       	breq	8000932e <__swsetup_r+0x7a>
8000931c:	ee c8 ff bc 	sub	r8,r7,-68
80009320:	10 3b       	cp.w	r11,r8
80009322:	c0 40       	breq	8000932a <__swsetup_r+0x76>
80009324:	0c 9c       	mov	r12,r6
80009326:	e0 a0 08 2b 	rcall	8000a37c <_free_r>
8000932a:	30 08       	mov	r8,0
8000932c:	8f d8       	st.w	r7[0x34],r8
8000932e:	8e 68       	ld.sh	r8,r7[0xc]
80009330:	e0 18 ff db 	andl	r8,0xffdb
80009334:	ae 68       	st.h	r7[0xc],r8
80009336:	30 08       	mov	r8,0
80009338:	8f 18       	st.w	r7[0x4],r8
8000933a:	6e 48       	ld.w	r8,r7[0x10]
8000933c:	8f 08       	st.w	r7[0x0],r8
8000933e:	8e 68       	ld.sh	r8,r7[0xc]
80009340:	a3 b8       	sbr	r8,0x3
80009342:	ae 68       	st.h	r7[0xc],r8
80009344:	6e 48       	ld.w	r8,r7[0x10]
80009346:	58 08       	cp.w	r8,0
80009348:	c0 b1       	brne	8000935e <__swsetup_r+0xaa>
8000934a:	8e 68       	ld.sh	r8,r7[0xc]
8000934c:	e2 18 02 80 	andl	r8,0x280,COH
80009350:	e0 48 02 00 	cp.w	r8,512
80009354:	c0 50       	breq	8000935e <__swsetup_r+0xaa>
80009356:	0c 9c       	mov	r12,r6
80009358:	0e 9b       	mov	r11,r7
8000935a:	e0 a0 0a 4b 	rcall	8000a7f0 <__smakebuf_r>
8000935e:	8e 69       	ld.sh	r9,r7[0xc]
80009360:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009364:	c0 70       	breq	80009372 <__swsetup_r+0xbe>
80009366:	30 08       	mov	r8,0
80009368:	8f 28       	st.w	r7[0x8],r8
8000936a:	6e 58       	ld.w	r8,r7[0x14]
8000936c:	5c 38       	neg	r8
8000936e:	8f 68       	st.w	r7[0x18],r8
80009370:	c0 68       	rjmp	8000937c <__swsetup_r+0xc8>
80009372:	ed b9 00 01 	bld	r9,0x1
80009376:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000937a:	8f 28       	st.w	r7[0x8],r8
8000937c:	6e 48       	ld.w	r8,r7[0x10]
8000937e:	58 08       	cp.w	r8,0
80009380:	c0 61       	brne	8000938c <__swsetup_r+0xd8>
80009382:	8e 68       	ld.sh	r8,r7[0xc]
80009384:	ed b8 00 07 	bld	r8,0x7
80009388:	c0 21       	brne	8000938c <__swsetup_r+0xd8>
8000938a:	dc 2a       	popm	r4-r7,pc,r12=-1
8000938c:	d8 2a       	popm	r4-r7,pc,r12=0
8000938e:	d7 03       	nop

80009390 <quorem>:
80009390:	d4 31       	pushm	r0-r7,lr
80009392:	20 2d       	sub	sp,8
80009394:	18 97       	mov	r7,r12
80009396:	78 48       	ld.w	r8,r12[0x10]
80009398:	76 46       	ld.w	r6,r11[0x10]
8000939a:	0c 38       	cp.w	r8,r6
8000939c:	c0 34       	brge	800093a2 <quorem+0x12>
8000939e:	30 0c       	mov	r12,0
800093a0:	c8 58       	rjmp	800094aa <quorem+0x11a>
800093a2:	ec c2 ff fc 	sub	r2,r6,-4
800093a6:	f6 c3 ff ec 	sub	r3,r11,-20
800093aa:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
800093ae:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
800093b2:	2f f9       	sub	r9,-1
800093b4:	20 16       	sub	r6,1
800093b6:	f8 09 0d 08 	divu	r8,r12,r9
800093ba:	f6 02 00 22 	add	r2,r11,r2<<0x2
800093be:	ee c4 ff ec 	sub	r4,r7,-20
800093c2:	10 95       	mov	r5,r8
800093c4:	58 08       	cp.w	r8,0
800093c6:	c4 10       	breq	80009448 <quorem+0xb8>
800093c8:	30 09       	mov	r9,0
800093ca:	06 9a       	mov	r10,r3
800093cc:	08 98       	mov	r8,r4
800093ce:	12 91       	mov	r1,r9
800093d0:	50 0b       	stdsp	sp[0x0],r11
800093d2:	70 0e       	ld.w	lr,r8[0x0]
800093d4:	b1 8e       	lsr	lr,0x10
800093d6:	50 1e       	stdsp	sp[0x4],lr
800093d8:	15 0e       	ld.w	lr,r10++
800093da:	fc 00 16 10 	lsr	r0,lr,0x10
800093de:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
800093e2:	ea 0e 03 41 	mac	r1,r5,lr
800093e6:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
800093ea:	b1 81       	lsr	r1,0x10
800093ec:	40 1b       	lddsp	r11,sp[0x4]
800093ee:	ea 00 02 40 	mul	r0,r5,r0
800093f2:	e2 00 00 00 	add	r0,r1,r0
800093f6:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
800093fa:	02 1b       	sub	r11,r1
800093fc:	50 1b       	stdsp	sp[0x4],r11
800093fe:	70 0b       	ld.w	r11,r8[0x0]
80009400:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009404:	02 09       	add	r9,r1
80009406:	f2 0e 01 0e 	sub	lr,r9,lr
8000940a:	b0 1e       	st.h	r8[0x2],lr
8000940c:	fc 09 14 10 	asr	r9,lr,0x10
80009410:	40 1e       	lddsp	lr,sp[0x4]
80009412:	fc 09 00 09 	add	r9,lr,r9
80009416:	b0 09       	st.h	r8[0x0],r9
80009418:	e0 01 16 10 	lsr	r1,r0,0x10
8000941c:	2f c8       	sub	r8,-4
8000941e:	b1 49       	asr	r9,0x10
80009420:	04 3a       	cp.w	r10,r2
80009422:	fe 98 ff d8 	brls	800093d2 <quorem+0x42>
80009426:	40 0b       	lddsp	r11,sp[0x0]
80009428:	58 0c       	cp.w	r12,0
8000942a:	c0 f1       	brne	80009448 <quorem+0xb8>
8000942c:	ec c8 ff fb 	sub	r8,r6,-5
80009430:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009434:	c0 28       	rjmp	80009438 <quorem+0xa8>
80009436:	20 16       	sub	r6,1
80009438:	20 48       	sub	r8,4
8000943a:	08 38       	cp.w	r8,r4
8000943c:	e0 88 00 05 	brls	80009446 <quorem+0xb6>
80009440:	70 09       	ld.w	r9,r8[0x0]
80009442:	58 09       	cp.w	r9,0
80009444:	cf 90       	breq	80009436 <quorem+0xa6>
80009446:	8f 46       	st.w	r7[0x10],r6
80009448:	0e 9c       	mov	r12,r7
8000944a:	e0 a0 0a d2 	rcall	8000a9ee <__mcmp>
8000944e:	c2 d5       	brlt	800094a8 <quorem+0x118>
80009450:	2f f5       	sub	r5,-1
80009452:	08 98       	mov	r8,r4
80009454:	30 09       	mov	r9,0
80009456:	07 0b       	ld.w	r11,r3++
80009458:	f6 0a 16 10 	lsr	r10,r11,0x10
8000945c:	70 0c       	ld.w	r12,r8[0x0]
8000945e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009462:	f8 0e 16 10 	lsr	lr,r12,0x10
80009466:	14 1e       	sub	lr,r10
80009468:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000946c:	16 1a       	sub	r10,r11
8000946e:	12 0a       	add	r10,r9
80009470:	b0 1a       	st.h	r8[0x2],r10
80009472:	b1 4a       	asr	r10,0x10
80009474:	fc 0a 00 09 	add	r9,lr,r10
80009478:	b0 09       	st.h	r8[0x0],r9
8000947a:	2f c8       	sub	r8,-4
8000947c:	b1 49       	asr	r9,0x10
8000947e:	04 33       	cp.w	r3,r2
80009480:	fe 98 ff eb 	brls	80009456 <quorem+0xc6>
80009484:	ec c8 ff fb 	sub	r8,r6,-5
80009488:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000948c:	58 09       	cp.w	r9,0
8000948e:	c0 d1       	brne	800094a8 <quorem+0x118>
80009490:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009494:	c0 28       	rjmp	80009498 <quorem+0x108>
80009496:	20 16       	sub	r6,1
80009498:	20 48       	sub	r8,4
8000949a:	08 38       	cp.w	r8,r4
8000949c:	e0 88 00 05 	brls	800094a6 <quorem+0x116>
800094a0:	70 09       	ld.w	r9,r8[0x0]
800094a2:	58 09       	cp.w	r9,0
800094a4:	cf 90       	breq	80009496 <quorem+0x106>
800094a6:	8f 46       	st.w	r7[0x10],r6
800094a8:	0a 9c       	mov	r12,r5
800094aa:	2f ed       	sub	sp,-8
800094ac:	d8 32       	popm	r0-r7,pc
800094ae:	d7 03       	nop

800094b0 <_dtoa_r>:
800094b0:	d4 31       	pushm	r0-r7,lr
800094b2:	21 ad       	sub	sp,104
800094b4:	fa c4 ff 74 	sub	r4,sp,-140
800094b8:	18 97       	mov	r7,r12
800094ba:	16 95       	mov	r5,r11
800094bc:	68 2c       	ld.w	r12,r4[0x8]
800094be:	50 c9       	stdsp	sp[0x30],r9
800094c0:	68 16       	ld.w	r6,r4[0x4]
800094c2:	68 09       	ld.w	r9,r4[0x0]
800094c4:	50 e8       	stdsp	sp[0x38],r8
800094c6:	14 94       	mov	r4,r10
800094c8:	51 2c       	stdsp	sp[0x48],r12
800094ca:	fa e5 00 08 	st.d	sp[8],r4
800094ce:	51 59       	stdsp	sp[0x54],r9
800094d0:	6e 95       	ld.w	r5,r7[0x24]
800094d2:	58 05       	cp.w	r5,0
800094d4:	c0 91       	brne	800094e6 <_dtoa_r+0x36>
800094d6:	31 0c       	mov	r12,16
800094d8:	fe b0 e8 e8 	rcall	800066a8 <malloc>
800094dc:	99 35       	st.w	r12[0xc],r5
800094de:	8f 9c       	st.w	r7[0x24],r12
800094e0:	99 15       	st.w	r12[0x4],r5
800094e2:	99 25       	st.w	r12[0x8],r5
800094e4:	99 05       	st.w	r12[0x0],r5
800094e6:	6e 99       	ld.w	r9,r7[0x24]
800094e8:	72 08       	ld.w	r8,r9[0x0]
800094ea:	58 08       	cp.w	r8,0
800094ec:	c0 f0       	breq	8000950a <_dtoa_r+0x5a>
800094ee:	72 1a       	ld.w	r10,r9[0x4]
800094f0:	91 1a       	st.w	r8[0x4],r10
800094f2:	30 1a       	mov	r10,1
800094f4:	72 19       	ld.w	r9,r9[0x4]
800094f6:	f4 09 09 49 	lsl	r9,r10,r9
800094fa:	10 9b       	mov	r11,r8
800094fc:	91 29       	st.w	r8[0x8],r9
800094fe:	0e 9c       	mov	r12,r7
80009500:	e0 a0 0a 90 	rcall	8000aa20 <_Bfree>
80009504:	6e 98       	ld.w	r8,r7[0x24]
80009506:	30 09       	mov	r9,0
80009508:	91 09       	st.w	r8[0x0],r9
8000950a:	40 28       	lddsp	r8,sp[0x8]
8000950c:	10 94       	mov	r4,r8
8000950e:	58 08       	cp.w	r8,0
80009510:	c0 64       	brge	8000951c <_dtoa_r+0x6c>
80009512:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009516:	50 28       	stdsp	sp[0x8],r8
80009518:	30 18       	mov	r8,1
8000951a:	c0 28       	rjmp	8000951e <_dtoa_r+0x6e>
8000951c:	30 08       	mov	r8,0
8000951e:	8d 08       	st.w	r6[0x0],r8
80009520:	fc 1c 7f f0 	movh	r12,0x7ff0
80009524:	40 26       	lddsp	r6,sp[0x8]
80009526:	0c 98       	mov	r8,r6
80009528:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000952c:	18 38       	cp.w	r8,r12
8000952e:	c2 01       	brne	8000956e <_dtoa_r+0xbe>
80009530:	e0 68 27 0f 	mov	r8,9999
80009534:	41 5b       	lddsp	r11,sp[0x54]
80009536:	97 08       	st.w	r11[0x0],r8
80009538:	40 3a       	lddsp	r10,sp[0xc]
8000953a:	58 0a       	cp.w	r10,0
8000953c:	c0 71       	brne	8000954a <_dtoa_r+0x9a>
8000953e:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009542:	c0 41       	brne	8000954a <_dtoa_r+0x9a>
80009544:	fe cc bd 58 	sub	r12,pc,-17064
80009548:	c0 38       	rjmp	8000954e <_dtoa_r+0x9e>
8000954a:	fe cc bd 52 	sub	r12,pc,-17070
8000954e:	41 29       	lddsp	r9,sp[0x48]
80009550:	58 09       	cp.w	r9,0
80009552:	e0 80 05 9a 	breq	8000a086 <_dtoa_r+0xbd6>
80009556:	f8 c8 ff fd 	sub	r8,r12,-3
8000955a:	f8 c9 ff f8 	sub	r9,r12,-8
8000955e:	11 8b       	ld.ub	r11,r8[0x0]
80009560:	30 0a       	mov	r10,0
80009562:	41 25       	lddsp	r5,sp[0x48]
80009564:	f4 0b 18 00 	cp.b	r11,r10
80009568:	f2 08 17 10 	movne	r8,r9
8000956c:	c1 68       	rjmp	80009598 <_dtoa_r+0xe8>
8000956e:	fa ea 00 08 	ld.d	r10,sp[8]
80009572:	30 08       	mov	r8,0
80009574:	fa eb 00 3c 	st.d	sp[60],r10
80009578:	30 09       	mov	r9,0
8000957a:	e0 a0 10 c2 	rcall	8000b6fe <__avr32_f64_cmp_eq>
8000957e:	c1 00       	breq	8000959e <_dtoa_r+0xee>
80009580:	30 18       	mov	r8,1
80009582:	41 5a       	lddsp	r10,sp[0x54]
80009584:	95 08       	st.w	r10[0x0],r8
80009586:	fe cc be be 	sub	r12,pc,-16706
8000958a:	41 29       	lddsp	r9,sp[0x48]
8000958c:	f8 08 00 08 	add	r8,r12,r8
80009590:	58 09       	cp.w	r9,0
80009592:	e0 80 05 7a 	breq	8000a086 <_dtoa_r+0xbd6>
80009596:	12 95       	mov	r5,r9
80009598:	8b 08       	st.w	r5[0x0],r8
8000959a:	e0 8f 05 76 	bral	8000a086 <_dtoa_r+0xbd6>
8000959e:	fa c8 ff 9c 	sub	r8,sp,-100
800095a2:	fa c9 ff a0 	sub	r9,sp,-96
800095a6:	fa ea 00 3c 	ld.d	r10,sp[60]
800095aa:	0e 9c       	mov	r12,r7
800095ac:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
800095b0:	e0 a0 0a 8a 	rcall	8000aac4 <__d2b>
800095b4:	18 93       	mov	r3,r12
800095b6:	58 05       	cp.w	r5,0
800095b8:	c0 d0       	breq	800095d2 <_dtoa_r+0x122>
800095ba:	fa ea 00 3c 	ld.d	r10,sp[60]
800095be:	30 04       	mov	r4,0
800095c0:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
800095c4:	ea c5 03 ff 	sub	r5,r5,1023
800095c8:	10 9b       	mov	r11,r8
800095ca:	51 74       	stdsp	sp[0x5c],r4
800095cc:	ea 1b 3f f0 	orh	r11,0x3ff0
800095d0:	c2 58       	rjmp	8000961a <_dtoa_r+0x16a>
800095d2:	41 88       	lddsp	r8,sp[0x60]
800095d4:	41 9c       	lddsp	r12,sp[0x64]
800095d6:	10 0c       	add	r12,r8
800095d8:	f8 c5 fb ce 	sub	r5,r12,-1074
800095dc:	e0 45 00 20 	cp.w	r5,32
800095e0:	e0 8a 00 0e 	brle	800095fc <_dtoa_r+0x14c>
800095e4:	f8 cc fb ee 	sub	r12,r12,-1042
800095e8:	40 3b       	lddsp	r11,sp[0xc]
800095ea:	ea 08 11 40 	rsub	r8,r5,64
800095ee:	f6 0c 0a 4c 	lsr	r12,r11,r12
800095f2:	ec 08 09 46 	lsl	r6,r6,r8
800095f6:	0c 4c       	or	r12,r6
800095f8:	c0 78       	rjmp	80009606 <_dtoa_r+0x156>
800095fa:	d7 03       	nop
800095fc:	ea 0c 11 20 	rsub	r12,r5,32
80009600:	40 3a       	lddsp	r10,sp[0xc]
80009602:	f4 0c 09 4c 	lsl	r12,r10,r12
80009606:	e0 a0 10 08 	rcall	8000b616 <__avr32_u32_to_f64>
8000960a:	fc 18 fe 10 	movh	r8,0xfe10
8000960e:	30 19       	mov	r9,1
80009610:	ea c5 04 33 	sub	r5,r5,1075
80009614:	f0 0b 00 0b 	add	r11,r8,r11
80009618:	51 79       	stdsp	sp[0x5c],r9
8000961a:	30 08       	mov	r8,0
8000961c:	fc 19 3f f8 	movh	r9,0x3ff8
80009620:	e0 a0 0e 90 	rcall	8000b340 <__avr32_f64_sub>
80009624:	e0 68 43 61 	mov	r8,17249
80009628:	ea 18 63 6f 	orh	r8,0x636f
8000962c:	e0 69 87 a7 	mov	r9,34727
80009630:	ea 19 3f d2 	orh	r9,0x3fd2
80009634:	e0 a0 0d 9a 	rcall	8000b168 <__avr32_f64_mul>
80009638:	e0 68 c8 b3 	mov	r8,51379
8000963c:	ea 18 8b 60 	orh	r8,0x8b60
80009640:	e0 69 8a 28 	mov	r9,35368
80009644:	ea 19 3f c6 	orh	r9,0x3fc6
80009648:	e0 a0 0f 4a 	rcall	8000b4dc <__avr32_f64_add>
8000964c:	0a 9c       	mov	r12,r5
8000964e:	14 90       	mov	r0,r10
80009650:	16 91       	mov	r1,r11
80009652:	e0 a0 0f e6 	rcall	8000b61e <__avr32_s32_to_f64>
80009656:	e0 68 79 fb 	mov	r8,31227
8000965a:	ea 18 50 9f 	orh	r8,0x509f
8000965e:	e0 69 44 13 	mov	r9,17427
80009662:	ea 19 3f d3 	orh	r9,0x3fd3
80009666:	e0 a0 0d 81 	rcall	8000b168 <__avr32_f64_mul>
8000966a:	14 98       	mov	r8,r10
8000966c:	16 99       	mov	r9,r11
8000966e:	00 9a       	mov	r10,r0
80009670:	02 9b       	mov	r11,r1
80009672:	e0 a0 0f 35 	rcall	8000b4dc <__avr32_f64_add>
80009676:	14 90       	mov	r0,r10
80009678:	16 91       	mov	r1,r11
8000967a:	e0 a0 0f bb 	rcall	8000b5f0 <__avr32_f64_to_s32>
8000967e:	30 08       	mov	r8,0
80009680:	18 96       	mov	r6,r12
80009682:	30 09       	mov	r9,0
80009684:	00 9a       	mov	r10,r0
80009686:	02 9b       	mov	r11,r1
80009688:	e0 a0 10 82 	rcall	8000b78c <__avr32_f64_cmp_lt>
8000968c:	c0 c0       	breq	800096a4 <_dtoa_r+0x1f4>
8000968e:	0c 9c       	mov	r12,r6
80009690:	e0 a0 0f c7 	rcall	8000b61e <__avr32_s32_to_f64>
80009694:	14 98       	mov	r8,r10
80009696:	16 99       	mov	r9,r11
80009698:	00 9a       	mov	r10,r0
8000969a:	02 9b       	mov	r11,r1
8000969c:	e0 a0 10 31 	rcall	8000b6fe <__avr32_f64_cmp_eq>
800096a0:	f7 b6 00 01 	subeq	r6,1
800096a4:	59 66       	cp.w	r6,22
800096a6:	e0 88 00 05 	brls	800096b0 <_dtoa_r+0x200>
800096aa:	30 18       	mov	r8,1
800096ac:	51 48       	stdsp	sp[0x50],r8
800096ae:	c1 38       	rjmp	800096d4 <_dtoa_r+0x224>
800096b0:	fe c8 be 04 	sub	r8,pc,-16892
800096b4:	fa ea 00 3c 	ld.d	r10,sp[60]
800096b8:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
800096bc:	e0 a0 10 68 	rcall	8000b78c <__avr32_f64_cmp_lt>
800096c0:	f9 b4 00 00 	moveq	r4,0
800096c4:	fb f4 0a 14 	st.weq	sp[0x50],r4
800096c8:	f7 b6 01 01 	subne	r6,1
800096cc:	f9 bc 01 00 	movne	r12,0
800096d0:	fb fc 1a 14 	st.wne	sp[0x50],r12
800096d4:	41 90       	lddsp	r0,sp[0x64]
800096d6:	20 10       	sub	r0,1
800096d8:	0a 10       	sub	r0,r5
800096da:	c0 46       	brmi	800096e2 <_dtoa_r+0x232>
800096dc:	50 40       	stdsp	sp[0x10],r0
800096de:	30 00       	mov	r0,0
800096e0:	c0 48       	rjmp	800096e8 <_dtoa_r+0x238>
800096e2:	30 0b       	mov	r11,0
800096e4:	5c 30       	neg	r0
800096e6:	50 4b       	stdsp	sp[0x10],r11
800096e8:	ec 02 11 00 	rsub	r2,r6,0
800096ec:	58 06       	cp.w	r6,0
800096ee:	fb fa 40 04 	ld.wge	r10,sp[0x10]
800096f2:	f5 d6 e4 0a 	addge	r10,r10,r6
800096f6:	fb fa 4a 04 	st.wge	sp[0x10],r10
800096fa:	fb f6 4a 11 	st.wge	sp[0x44],r6
800096fe:	f9 b2 04 00 	movge	r2,0
80009702:	e1 d6 e5 10 	sublt	r0,r0,r6
80009706:	f9 b9 05 00 	movlt	r9,0
8000970a:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000970e:	40 c8       	lddsp	r8,sp[0x30]
80009710:	58 98       	cp.w	r8,9
80009712:	e0 8b 00 20 	brhi	80009752 <_dtoa_r+0x2a2>
80009716:	58 58       	cp.w	r8,5
80009718:	f9 b4 0a 01 	movle	r4,1
8000971c:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009720:	f7 b5 09 04 	subgt	r5,4
80009724:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009728:	f9 b4 09 00 	movgt	r4,0
8000972c:	40 cc       	lddsp	r12,sp[0x30]
8000972e:	58 3c       	cp.w	r12,3
80009730:	c2 d0       	breq	8000978a <_dtoa_r+0x2da>
80009732:	e0 89 00 05 	brgt	8000973c <_dtoa_r+0x28c>
80009736:	58 2c       	cp.w	r12,2
80009738:	c1 01       	brne	80009758 <_dtoa_r+0x2a8>
8000973a:	c1 88       	rjmp	8000976a <_dtoa_r+0x2ba>
8000973c:	40 cb       	lddsp	r11,sp[0x30]
8000973e:	58 4b       	cp.w	r11,4
80009740:	c0 60       	breq	8000974c <_dtoa_r+0x29c>
80009742:	58 5b       	cp.w	r11,5
80009744:	c0 a1       	brne	80009758 <_dtoa_r+0x2a8>
80009746:	30 1a       	mov	r10,1
80009748:	50 da       	stdsp	sp[0x34],r10
8000974a:	c2 28       	rjmp	8000978e <_dtoa_r+0x2de>
8000974c:	30 19       	mov	r9,1
8000974e:	50 d9       	stdsp	sp[0x34],r9
80009750:	c0 f8       	rjmp	8000976e <_dtoa_r+0x2be>
80009752:	30 08       	mov	r8,0
80009754:	30 14       	mov	r4,1
80009756:	50 c8       	stdsp	sp[0x30],r8
80009758:	3f f5       	mov	r5,-1
8000975a:	30 1c       	mov	r12,1
8000975c:	30 0b       	mov	r11,0
8000975e:	50 95       	stdsp	sp[0x24],r5
80009760:	50 dc       	stdsp	sp[0x34],r12
80009762:	0a 91       	mov	r1,r5
80009764:	31 28       	mov	r8,18
80009766:	50 eb       	stdsp	sp[0x38],r11
80009768:	c2 08       	rjmp	800097a8 <_dtoa_r+0x2f8>
8000976a:	30 0a       	mov	r10,0
8000976c:	50 da       	stdsp	sp[0x34],r10
8000976e:	40 e9       	lddsp	r9,sp[0x38]
80009770:	58 09       	cp.w	r9,0
80009772:	e0 89 00 07 	brgt	80009780 <_dtoa_r+0x2d0>
80009776:	30 18       	mov	r8,1
80009778:	50 98       	stdsp	sp[0x24],r8
8000977a:	10 91       	mov	r1,r8
8000977c:	50 e8       	stdsp	sp[0x38],r8
8000977e:	c1 58       	rjmp	800097a8 <_dtoa_r+0x2f8>
80009780:	40 e5       	lddsp	r5,sp[0x38]
80009782:	50 95       	stdsp	sp[0x24],r5
80009784:	0a 91       	mov	r1,r5
80009786:	0a 98       	mov	r8,r5
80009788:	c1 08       	rjmp	800097a8 <_dtoa_r+0x2f8>
8000978a:	30 0c       	mov	r12,0
8000978c:	50 dc       	stdsp	sp[0x34],r12
8000978e:	40 eb       	lddsp	r11,sp[0x38]
80009790:	ec 0b 00 0b 	add	r11,r6,r11
80009794:	50 9b       	stdsp	sp[0x24],r11
80009796:	16 98       	mov	r8,r11
80009798:	2f f8       	sub	r8,-1
8000979a:	58 08       	cp.w	r8,0
8000979c:	e0 89 00 05 	brgt	800097a6 <_dtoa_r+0x2f6>
800097a0:	10 91       	mov	r1,r8
800097a2:	30 18       	mov	r8,1
800097a4:	c0 28       	rjmp	800097a8 <_dtoa_r+0x2f8>
800097a6:	10 91       	mov	r1,r8
800097a8:	30 09       	mov	r9,0
800097aa:	6e 9a       	ld.w	r10,r7[0x24]
800097ac:	95 19       	st.w	r10[0x4],r9
800097ae:	30 49       	mov	r9,4
800097b0:	c0 68       	rjmp	800097bc <_dtoa_r+0x30c>
800097b2:	d7 03       	nop
800097b4:	6a 1a       	ld.w	r10,r5[0x4]
800097b6:	a1 79       	lsl	r9,0x1
800097b8:	2f fa       	sub	r10,-1
800097ba:	8b 1a       	st.w	r5[0x4],r10
800097bc:	6e 95       	ld.w	r5,r7[0x24]
800097be:	f2 ca ff ec 	sub	r10,r9,-20
800097c2:	10 3a       	cp.w	r10,r8
800097c4:	fe 98 ff f8 	brls	800097b4 <_dtoa_r+0x304>
800097c8:	6a 1b       	ld.w	r11,r5[0x4]
800097ca:	0e 9c       	mov	r12,r7
800097cc:	e0 a0 09 44 	rcall	8000aa54 <_Balloc>
800097d0:	58 e1       	cp.w	r1,14
800097d2:	5f 88       	srls	r8
800097d4:	8b 0c       	st.w	r5[0x0],r12
800097d6:	f1 e4 00 04 	and	r4,r8,r4
800097da:	6e 98       	ld.w	r8,r7[0x24]
800097dc:	70 08       	ld.w	r8,r8[0x0]
800097de:	50 88       	stdsp	sp[0x20],r8
800097e0:	e0 80 01 82 	breq	80009ae4 <_dtoa_r+0x634>
800097e4:	58 06       	cp.w	r6,0
800097e6:	e0 8a 00 43 	brle	8000986c <_dtoa_r+0x3bc>
800097ea:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
800097ee:	fe c8 bf 42 	sub	r8,pc,-16574
800097f2:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
800097f6:	fa e5 00 18 	st.d	sp[24],r4
800097fa:	ec 04 14 04 	asr	r4,r6,0x4
800097fe:	ed b4 00 04 	bld	r4,0x4
80009802:	c0 30       	breq	80009808 <_dtoa_r+0x358>
80009804:	30 25       	mov	r5,2
80009806:	c1 08       	rjmp	80009826 <_dtoa_r+0x376>
80009808:	fe c8 be 94 	sub	r8,pc,-16748
8000980c:	f0 e8 00 20 	ld.d	r8,r8[32]
80009810:	fa ea 00 3c 	ld.d	r10,sp[60]
80009814:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009818:	e0 a0 0f ee 	rcall	8000b7f4 <__avr32_f64_div>
8000981c:	30 35       	mov	r5,3
8000981e:	14 98       	mov	r8,r10
80009820:	16 99       	mov	r9,r11
80009822:	fa e9 00 08 	st.d	sp[8],r8
80009826:	fe cc be b2 	sub	r12,pc,-16718
8000982a:	50 a3       	stdsp	sp[0x28],r3
8000982c:	0c 93       	mov	r3,r6
8000982e:	18 96       	mov	r6,r12
80009830:	c0 f8       	rjmp	8000984e <_dtoa_r+0x39e>
80009832:	fa ea 00 18 	ld.d	r10,sp[24]
80009836:	ed b4 00 00 	bld	r4,0x0
8000983a:	c0 81       	brne	8000984a <_dtoa_r+0x39a>
8000983c:	ec e8 00 00 	ld.d	r8,r6[0]
80009840:	2f f5       	sub	r5,-1
80009842:	e0 a0 0c 93 	rcall	8000b168 <__avr32_f64_mul>
80009846:	fa eb 00 18 	st.d	sp[24],r10
8000984a:	a1 54       	asr	r4,0x1
8000984c:	2f 86       	sub	r6,-8
8000984e:	58 04       	cp.w	r4,0
80009850:	cf 11       	brne	80009832 <_dtoa_r+0x382>
80009852:	fa e8 00 18 	ld.d	r8,sp[24]
80009856:	fa ea 00 08 	ld.d	r10,sp[8]
8000985a:	06 96       	mov	r6,r3
8000985c:	e0 a0 0f cc 	rcall	8000b7f4 <__avr32_f64_div>
80009860:	40 a3       	lddsp	r3,sp[0x28]
80009862:	14 98       	mov	r8,r10
80009864:	16 99       	mov	r9,r11
80009866:	fa e9 00 08 	st.d	sp[8],r8
8000986a:	c2 f8       	rjmp	800098c8 <_dtoa_r+0x418>
8000986c:	ec 08 11 00 	rsub	r8,r6,0
80009870:	c0 31       	brne	80009876 <_dtoa_r+0x3c6>
80009872:	30 25       	mov	r5,2
80009874:	c2 a8       	rjmp	800098c8 <_dtoa_r+0x418>
80009876:	fe cc bf 02 	sub	r12,pc,-16638
8000987a:	f0 04 14 04 	asr	r4,r8,0x4
8000987e:	50 1c       	stdsp	sp[0x4],r12
80009880:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009884:	fe c9 bf d8 	sub	r9,pc,-16424
80009888:	fa ea 00 3c 	ld.d	r10,sp[60]
8000988c:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009890:	e0 a0 0c 6c 	rcall	8000b168 <__avr32_f64_mul>
80009894:	40 1c       	lddsp	r12,sp[0x4]
80009896:	50 63       	stdsp	sp[0x18],r3
80009898:	30 25       	mov	r5,2
8000989a:	0c 93       	mov	r3,r6
8000989c:	fa eb 00 08 	st.d	sp[8],r10
800098a0:	18 96       	mov	r6,r12
800098a2:	c0 f8       	rjmp	800098c0 <_dtoa_r+0x410>
800098a4:	fa ea 00 08 	ld.d	r10,sp[8]
800098a8:	ed b4 00 00 	bld	r4,0x0
800098ac:	c0 81       	brne	800098bc <_dtoa_r+0x40c>
800098ae:	ec e8 00 00 	ld.d	r8,r6[0]
800098b2:	2f f5       	sub	r5,-1
800098b4:	e0 a0 0c 5a 	rcall	8000b168 <__avr32_f64_mul>
800098b8:	fa eb 00 08 	st.d	sp[8],r10
800098bc:	a1 54       	asr	r4,0x1
800098be:	2f 86       	sub	r6,-8
800098c0:	58 04       	cp.w	r4,0
800098c2:	cf 11       	brne	800098a4 <_dtoa_r+0x3f4>
800098c4:	06 96       	mov	r6,r3
800098c6:	40 63       	lddsp	r3,sp[0x18]
800098c8:	41 4a       	lddsp	r10,sp[0x50]
800098ca:	58 0a       	cp.w	r10,0
800098cc:	c2 a0       	breq	80009920 <_dtoa_r+0x470>
800098ce:	fa e8 00 08 	ld.d	r8,sp[8]
800098d2:	58 01       	cp.w	r1,0
800098d4:	5f 94       	srgt	r4
800098d6:	fa e9 00 18 	st.d	sp[24],r8
800098da:	30 08       	mov	r8,0
800098dc:	fc 19 3f f0 	movh	r9,0x3ff0
800098e0:	fa ea 00 18 	ld.d	r10,sp[24]
800098e4:	e0 a0 0f 54 	rcall	8000b78c <__avr32_f64_cmp_lt>
800098e8:	f9 bc 00 00 	moveq	r12,0
800098ec:	f9 bc 01 01 	movne	r12,1
800098f0:	e9 ec 00 0c 	and	r12,r4,r12
800098f4:	c1 60       	breq	80009920 <_dtoa_r+0x470>
800098f6:	40 98       	lddsp	r8,sp[0x24]
800098f8:	58 08       	cp.w	r8,0
800098fa:	e0 8a 00 f1 	brle	80009adc <_dtoa_r+0x62c>
800098fe:	30 08       	mov	r8,0
80009900:	fc 19 40 24 	movh	r9,0x4024
80009904:	ec c4 00 01 	sub	r4,r6,1
80009908:	fa ea 00 18 	ld.d	r10,sp[24]
8000990c:	2f f5       	sub	r5,-1
8000990e:	50 64       	stdsp	sp[0x18],r4
80009910:	e0 a0 0c 2c 	rcall	8000b168 <__avr32_f64_mul>
80009914:	40 94       	lddsp	r4,sp[0x24]
80009916:	14 98       	mov	r8,r10
80009918:	16 99       	mov	r9,r11
8000991a:	fa e9 00 08 	st.d	sp[8],r8
8000991e:	c0 38       	rjmp	80009924 <_dtoa_r+0x474>
80009920:	50 66       	stdsp	sp[0x18],r6
80009922:	02 94       	mov	r4,r1
80009924:	0a 9c       	mov	r12,r5
80009926:	e0 a0 0e 7c 	rcall	8000b61e <__avr32_s32_to_f64>
8000992a:	fa e8 00 08 	ld.d	r8,sp[8]
8000992e:	e0 a0 0c 1d 	rcall	8000b168 <__avr32_f64_mul>
80009932:	30 08       	mov	r8,0
80009934:	fc 19 40 1c 	movh	r9,0x401c
80009938:	e0 a0 0d d2 	rcall	8000b4dc <__avr32_f64_add>
8000993c:	14 98       	mov	r8,r10
8000993e:	16 99       	mov	r9,r11
80009940:	fa e9 00 28 	st.d	sp[40],r8
80009944:	fc 18 fc c0 	movh	r8,0xfcc0
80009948:	40 a5       	lddsp	r5,sp[0x28]
8000994a:	10 05       	add	r5,r8
8000994c:	50 a5       	stdsp	sp[0x28],r5
8000994e:	58 04       	cp.w	r4,0
80009950:	c2 11       	brne	80009992 <_dtoa_r+0x4e2>
80009952:	fa ea 00 08 	ld.d	r10,sp[8]
80009956:	30 08       	mov	r8,0
80009958:	fc 19 40 14 	movh	r9,0x4014
8000995c:	e0 a0 0c f2 	rcall	8000b340 <__avr32_f64_sub>
80009960:	40 bc       	lddsp	r12,sp[0x2c]
80009962:	fa eb 00 08 	st.d	sp[8],r10
80009966:	14 98       	mov	r8,r10
80009968:	16 99       	mov	r9,r11
8000996a:	18 9a       	mov	r10,r12
8000996c:	0a 9b       	mov	r11,r5
8000996e:	e0 a0 0f 0f 	rcall	8000b78c <__avr32_f64_cmp_lt>
80009972:	e0 81 02 54 	brne	80009e1a <_dtoa_r+0x96a>
80009976:	0a 98       	mov	r8,r5
80009978:	40 b9       	lddsp	r9,sp[0x2c]
8000997a:	ee 18 80 00 	eorh	r8,0x8000
8000997e:	fa ea 00 08 	ld.d	r10,sp[8]
80009982:	10 95       	mov	r5,r8
80009984:	12 98       	mov	r8,r9
80009986:	0a 99       	mov	r9,r5
80009988:	e0 a0 0f 02 	rcall	8000b78c <__avr32_f64_cmp_lt>
8000998c:	e0 81 02 3e 	brne	80009e08 <_dtoa_r+0x958>
80009990:	ca 68       	rjmp	80009adc <_dtoa_r+0x62c>
80009992:	fe c9 c0 e6 	sub	r9,pc,-16154
80009996:	e8 c8 00 01 	sub	r8,r4,1
8000999a:	40 d5       	lddsp	r5,sp[0x34]
8000999c:	58 05       	cp.w	r5,0
8000999e:	c4 f0       	breq	80009a3c <_dtoa_r+0x58c>
800099a0:	30 0c       	mov	r12,0
800099a2:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
800099a6:	51 3c       	stdsp	sp[0x4c],r12
800099a8:	30 0a       	mov	r10,0
800099aa:	fc 1b 3f e0 	movh	r11,0x3fe0
800099ae:	e0 a0 0f 23 	rcall	8000b7f4 <__avr32_f64_div>
800099b2:	fa e8 00 28 	ld.d	r8,sp[40]
800099b6:	40 85       	lddsp	r5,sp[0x20]
800099b8:	e0 a0 0c c4 	rcall	8000b340 <__avr32_f64_sub>
800099bc:	fa eb 00 28 	st.d	sp[40],r10
800099c0:	fa ea 00 08 	ld.d	r10,sp[8]
800099c4:	e0 a0 0e 16 	rcall	8000b5f0 <__avr32_f64_to_s32>
800099c8:	51 6c       	stdsp	sp[0x58],r12
800099ca:	e0 a0 0e 2a 	rcall	8000b61e <__avr32_s32_to_f64>
800099ce:	14 98       	mov	r8,r10
800099d0:	16 99       	mov	r9,r11
800099d2:	fa ea 00 08 	ld.d	r10,sp[8]
800099d6:	e0 a0 0c b5 	rcall	8000b340 <__avr32_f64_sub>
800099da:	fa eb 00 08 	st.d	sp[8],r10
800099de:	41 68       	lddsp	r8,sp[0x58]
800099e0:	2d 08       	sub	r8,-48
800099e2:	0a c8       	st.b	r5++,r8
800099e4:	41 39       	lddsp	r9,sp[0x4c]
800099e6:	2f f9       	sub	r9,-1
800099e8:	51 39       	stdsp	sp[0x4c],r9
800099ea:	fa e8 00 28 	ld.d	r8,sp[40]
800099ee:	e0 a0 0e cf 	rcall	8000b78c <__avr32_f64_cmp_lt>
800099f2:	e0 81 03 39 	brne	8000a064 <_dtoa_r+0xbb4>
800099f6:	fa e8 00 08 	ld.d	r8,sp[8]
800099fa:	30 0a       	mov	r10,0
800099fc:	fc 1b 3f f0 	movh	r11,0x3ff0
80009a00:	e0 a0 0c a0 	rcall	8000b340 <__avr32_f64_sub>
80009a04:	fa e8 00 28 	ld.d	r8,sp[40]
80009a08:	e0 a0 0e c2 	rcall	8000b78c <__avr32_f64_cmp_lt>
80009a0c:	fa ea 00 28 	ld.d	r10,sp[40]
80009a10:	30 08       	mov	r8,0
80009a12:	fc 19 40 24 	movh	r9,0x4024
80009a16:	e0 81 00 da 	brne	80009bca <_dtoa_r+0x71a>
80009a1a:	41 3c       	lddsp	r12,sp[0x4c]
80009a1c:	08 3c       	cp.w	r12,r4
80009a1e:	c5 f4       	brge	80009adc <_dtoa_r+0x62c>
80009a20:	e0 a0 0b a4 	rcall	8000b168 <__avr32_f64_mul>
80009a24:	30 08       	mov	r8,0
80009a26:	fa eb 00 28 	st.d	sp[40],r10
80009a2a:	fc 19 40 24 	movh	r9,0x4024
80009a2e:	fa ea 00 08 	ld.d	r10,sp[8]
80009a32:	e0 a0 0b 9b 	rcall	8000b168 <__avr32_f64_mul>
80009a36:	fa eb 00 08 	st.d	sp[8],r10
80009a3a:	cc 3b       	rjmp	800099c0 <_dtoa_r+0x510>
80009a3c:	40 85       	lddsp	r5,sp[0x20]
80009a3e:	08 05       	add	r5,r4
80009a40:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009a44:	51 35       	stdsp	sp[0x4c],r5
80009a46:	fa e8 00 28 	ld.d	r8,sp[40]
80009a4a:	40 85       	lddsp	r5,sp[0x20]
80009a4c:	e0 a0 0b 8e 	rcall	8000b168 <__avr32_f64_mul>
80009a50:	fa eb 00 28 	st.d	sp[40],r10
80009a54:	fa ea 00 08 	ld.d	r10,sp[8]
80009a58:	e0 a0 0d cc 	rcall	8000b5f0 <__avr32_f64_to_s32>
80009a5c:	51 6c       	stdsp	sp[0x58],r12
80009a5e:	e0 a0 0d e0 	rcall	8000b61e <__avr32_s32_to_f64>
80009a62:	14 98       	mov	r8,r10
80009a64:	16 99       	mov	r9,r11
80009a66:	fa ea 00 08 	ld.d	r10,sp[8]
80009a6a:	e0 a0 0c 6b 	rcall	8000b340 <__avr32_f64_sub>
80009a6e:	fa eb 00 08 	st.d	sp[8],r10
80009a72:	41 68       	lddsp	r8,sp[0x58]
80009a74:	2d 08       	sub	r8,-48
80009a76:	0a c8       	st.b	r5++,r8
80009a78:	41 3c       	lddsp	r12,sp[0x4c]
80009a7a:	18 35       	cp.w	r5,r12
80009a7c:	c2 81       	brne	80009acc <_dtoa_r+0x61c>
80009a7e:	30 08       	mov	r8,0
80009a80:	fc 19 3f e0 	movh	r9,0x3fe0
80009a84:	fa ea 00 28 	ld.d	r10,sp[40]
80009a88:	e0 a0 0d 2a 	rcall	8000b4dc <__avr32_f64_add>
80009a8c:	40 85       	lddsp	r5,sp[0x20]
80009a8e:	fa e8 00 08 	ld.d	r8,sp[8]
80009a92:	08 05       	add	r5,r4
80009a94:	e0 a0 0e 7c 	rcall	8000b78c <__avr32_f64_cmp_lt>
80009a98:	e0 81 00 99 	brne	80009bca <_dtoa_r+0x71a>
80009a9c:	fa e8 00 28 	ld.d	r8,sp[40]
80009aa0:	30 0a       	mov	r10,0
80009aa2:	fc 1b 3f e0 	movh	r11,0x3fe0
80009aa6:	e0 a0 0c 4d 	rcall	8000b340 <__avr32_f64_sub>
80009aaa:	14 98       	mov	r8,r10
80009aac:	16 99       	mov	r9,r11
80009aae:	fa ea 00 08 	ld.d	r10,sp[8]
80009ab2:	e0 a0 0e 6d 	rcall	8000b78c <__avr32_f64_cmp_lt>
80009ab6:	c1 30       	breq	80009adc <_dtoa_r+0x62c>
80009ab8:	33 09       	mov	r9,48
80009aba:	0a 98       	mov	r8,r5
80009abc:	11 7a       	ld.ub	r10,--r8
80009abe:	f2 0a 18 00 	cp.b	r10,r9
80009ac2:	e0 81 02 d1 	brne	8000a064 <_dtoa_r+0xbb4>
80009ac6:	10 95       	mov	r5,r8
80009ac8:	cf 9b       	rjmp	80009aba <_dtoa_r+0x60a>
80009aca:	d7 03       	nop
80009acc:	30 08       	mov	r8,0
80009ace:	fc 19 40 24 	movh	r9,0x4024
80009ad2:	e0 a0 0b 4b 	rcall	8000b168 <__avr32_f64_mul>
80009ad6:	fa eb 00 08 	st.d	sp[8],r10
80009ada:	cb db       	rjmp	80009a54 <_dtoa_r+0x5a4>
80009adc:	fa ea 00 3c 	ld.d	r10,sp[60]
80009ae0:	fa eb 00 08 	st.d	sp[8],r10
80009ae4:	58 e6       	cp.w	r6,14
80009ae6:	5f ab       	srle	r11
80009ae8:	41 8a       	lddsp	r10,sp[0x60]
80009aea:	30 08       	mov	r8,0
80009aec:	f4 09 11 ff 	rsub	r9,r10,-1
80009af0:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80009af4:	f0 09 18 00 	cp.b	r9,r8
80009af8:	e0 80 00 82 	breq	80009bfc <_dtoa_r+0x74c>
80009afc:	40 ea       	lddsp	r10,sp[0x38]
80009afe:	58 01       	cp.w	r1,0
80009b00:	5f a9       	srle	r9
80009b02:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
80009b06:	fe ca c2 5a 	sub	r10,pc,-15782
80009b0a:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
80009b0e:	fa e5 00 10 	st.d	sp[16],r4
80009b12:	f0 09 18 00 	cp.b	r9,r8
80009b16:	c1 40       	breq	80009b3e <_dtoa_r+0x68e>
80009b18:	58 01       	cp.w	r1,0
80009b1a:	e0 81 01 77 	brne	80009e08 <_dtoa_r+0x958>
80009b1e:	30 08       	mov	r8,0
80009b20:	fc 19 40 14 	movh	r9,0x4014
80009b24:	08 9a       	mov	r10,r4
80009b26:	0a 9b       	mov	r11,r5
80009b28:	e0 a0 0b 20 	rcall	8000b168 <__avr32_f64_mul>
80009b2c:	fa e8 00 08 	ld.d	r8,sp[8]
80009b30:	e0 a0 0d fa 	rcall	8000b724 <__avr32_f64_cmp_ge>
80009b34:	e0 81 01 6a 	brne	80009e08 <_dtoa_r+0x958>
80009b38:	02 92       	mov	r2,r1
80009b3a:	e0 8f 01 72 	bral	80009e1e <_dtoa_r+0x96e>
80009b3e:	40 85       	lddsp	r5,sp[0x20]
80009b40:	30 14       	mov	r4,1
80009b42:	fa e8 00 10 	ld.d	r8,sp[16]
80009b46:	fa ea 00 08 	ld.d	r10,sp[8]
80009b4a:	e0 a0 0e 55 	rcall	8000b7f4 <__avr32_f64_div>
80009b4e:	e0 a0 0d 51 	rcall	8000b5f0 <__avr32_f64_to_s32>
80009b52:	18 92       	mov	r2,r12
80009b54:	e0 a0 0d 65 	rcall	8000b61e <__avr32_s32_to_f64>
80009b58:	fa e8 00 10 	ld.d	r8,sp[16]
80009b5c:	e0 a0 0b 06 	rcall	8000b168 <__avr32_f64_mul>
80009b60:	14 98       	mov	r8,r10
80009b62:	16 99       	mov	r9,r11
80009b64:	fa ea 00 08 	ld.d	r10,sp[8]
80009b68:	e0 a0 0b ec 	rcall	8000b340 <__avr32_f64_sub>
80009b6c:	fa eb 00 08 	st.d	sp[8],r10
80009b70:	e4 c8 ff d0 	sub	r8,r2,-48
80009b74:	0a c8       	st.b	r5++,r8
80009b76:	fc 19 40 24 	movh	r9,0x4024
80009b7a:	30 08       	mov	r8,0
80009b7c:	02 34       	cp.w	r4,r1
80009b7e:	c3 31       	brne	80009be4 <_dtoa_r+0x734>
80009b80:	fa e8 00 08 	ld.d	r8,sp[8]
80009b84:	e0 a0 0c ac 	rcall	8000b4dc <__avr32_f64_add>
80009b88:	16 91       	mov	r1,r11
80009b8a:	14 90       	mov	r0,r10
80009b8c:	14 98       	mov	r8,r10
80009b8e:	02 99       	mov	r9,r1
80009b90:	fa ea 00 10 	ld.d	r10,sp[16]
80009b94:	e0 a0 0d fc 	rcall	8000b78c <__avr32_f64_cmp_lt>
80009b98:	c1 a1       	brne	80009bcc <_dtoa_r+0x71c>
80009b9a:	fa e8 00 10 	ld.d	r8,sp[16]
80009b9e:	00 9a       	mov	r10,r0
80009ba0:	02 9b       	mov	r11,r1
80009ba2:	e0 a0 0d ae 	rcall	8000b6fe <__avr32_f64_cmp_eq>
80009ba6:	e0 80 02 5e 	breq	8000a062 <_dtoa_r+0xbb2>
80009baa:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80009bae:	c0 f1       	brne	80009bcc <_dtoa_r+0x71c>
80009bb0:	e0 8f 02 59 	bral	8000a062 <_dtoa_r+0xbb2>
80009bb4:	40 8a       	lddsp	r10,sp[0x20]
80009bb6:	14 38       	cp.w	r8,r10
80009bb8:	c0 30       	breq	80009bbe <_dtoa_r+0x70e>
80009bba:	10 95       	mov	r5,r8
80009bbc:	c0 98       	rjmp	80009bce <_dtoa_r+0x71e>
80009bbe:	33 08       	mov	r8,48
80009bc0:	40 89       	lddsp	r9,sp[0x20]
80009bc2:	2f f6       	sub	r6,-1
80009bc4:	b2 88       	st.b	r9[0x0],r8
80009bc6:	40 88       	lddsp	r8,sp[0x20]
80009bc8:	c0 88       	rjmp	80009bd8 <_dtoa_r+0x728>
80009bca:	40 66       	lddsp	r6,sp[0x18]
80009bcc:	33 99       	mov	r9,57
80009bce:	0a 98       	mov	r8,r5
80009bd0:	11 7a       	ld.ub	r10,--r8
80009bd2:	f2 0a 18 00 	cp.b	r10,r9
80009bd6:	ce f0       	breq	80009bb4 <_dtoa_r+0x704>
80009bd8:	50 66       	stdsp	sp[0x18],r6
80009bda:	11 89       	ld.ub	r9,r8[0x0]
80009bdc:	2f f9       	sub	r9,-1
80009bde:	b0 89       	st.b	r8[0x0],r9
80009be0:	e0 8f 02 42 	bral	8000a064 <_dtoa_r+0xbb4>
80009be4:	e0 a0 0a c2 	rcall	8000b168 <__avr32_f64_mul>
80009be8:	2f f4       	sub	r4,-1
80009bea:	fa eb 00 08 	st.d	sp[8],r10
80009bee:	30 08       	mov	r8,0
80009bf0:	30 09       	mov	r9,0
80009bf2:	e0 a0 0d 86 	rcall	8000b6fe <__avr32_f64_cmp_eq>
80009bf6:	ca 60       	breq	80009b42 <_dtoa_r+0x692>
80009bf8:	e0 8f 02 35 	bral	8000a062 <_dtoa_r+0xbb2>
80009bfc:	40 d8       	lddsp	r8,sp[0x34]
80009bfe:	58 08       	cp.w	r8,0
80009c00:	c0 51       	brne	80009c0a <_dtoa_r+0x75a>
80009c02:	04 98       	mov	r8,r2
80009c04:	00 95       	mov	r5,r0
80009c06:	40 d4       	lddsp	r4,sp[0x34]
80009c08:	c3 78       	rjmp	80009c76 <_dtoa_r+0x7c6>
80009c0a:	40 c5       	lddsp	r5,sp[0x30]
80009c0c:	58 15       	cp.w	r5,1
80009c0e:	e0 89 00 0f 	brgt	80009c2c <_dtoa_r+0x77c>
80009c12:	41 74       	lddsp	r4,sp[0x5c]
80009c14:	58 04       	cp.w	r4,0
80009c16:	c0 40       	breq	80009c1e <_dtoa_r+0x76e>
80009c18:	f4 c9 fb cd 	sub	r9,r10,-1075
80009c1c:	c0 48       	rjmp	80009c24 <_dtoa_r+0x774>
80009c1e:	41 99       	lddsp	r9,sp[0x64]
80009c20:	f2 09 11 36 	rsub	r9,r9,54
80009c24:	04 98       	mov	r8,r2
80009c26:	00 95       	mov	r5,r0
80009c28:	c1 c8       	rjmp	80009c60 <_dtoa_r+0x7b0>
80009c2a:	d7 03       	nop
80009c2c:	e2 c8 00 01 	sub	r8,r1,1
80009c30:	58 01       	cp.w	r1,0
80009c32:	e0 05 17 40 	movge	r5,r0
80009c36:	e2 09 17 40 	movge	r9,r1
80009c3a:	e1 d1 e5 15 	sublt	r5,r0,r1
80009c3e:	f9 b9 05 00 	movlt	r9,0
80009c42:	10 32       	cp.w	r2,r8
80009c44:	e5 d8 e4 18 	subge	r8,r2,r8
80009c48:	f1 d2 e5 18 	sublt	r8,r8,r2
80009c4c:	e5 d8 e5 02 	addlt	r2,r2,r8
80009c50:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80009c54:	f9 d8 e5 0c 	addlt	r12,r12,r8
80009c58:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80009c5c:	f9 b8 05 00 	movlt	r8,0
80009c60:	40 4b       	lddsp	r11,sp[0x10]
80009c62:	12 0b       	add	r11,r9
80009c64:	50 08       	stdsp	sp[0x0],r8
80009c66:	50 4b       	stdsp	sp[0x10],r11
80009c68:	12 00       	add	r0,r9
80009c6a:	30 1b       	mov	r11,1
80009c6c:	0e 9c       	mov	r12,r7
80009c6e:	e0 a0 08 a7 	rcall	8000adbc <__i2b>
80009c72:	40 08       	lddsp	r8,sp[0x0]
80009c74:	18 94       	mov	r4,r12
80009c76:	40 4a       	lddsp	r10,sp[0x10]
80009c78:	58 05       	cp.w	r5,0
80009c7a:	5f 99       	srgt	r9
80009c7c:	58 0a       	cp.w	r10,0
80009c7e:	5f 9a       	srgt	r10
80009c80:	f5 e9 00 09 	and	r9,r10,r9
80009c84:	c0 80       	breq	80009c94 <_dtoa_r+0x7e4>
80009c86:	40 4c       	lddsp	r12,sp[0x10]
80009c88:	f8 05 0d 49 	min	r9,r12,r5
80009c8c:	12 1c       	sub	r12,r9
80009c8e:	12 10       	sub	r0,r9
80009c90:	50 4c       	stdsp	sp[0x10],r12
80009c92:	12 15       	sub	r5,r9
80009c94:	58 02       	cp.w	r2,0
80009c96:	e0 8a 00 27 	brle	80009ce4 <_dtoa_r+0x834>
80009c9a:	40 db       	lddsp	r11,sp[0x34]
80009c9c:	58 0b       	cp.w	r11,0
80009c9e:	c1 d0       	breq	80009cd8 <_dtoa_r+0x828>
80009ca0:	58 08       	cp.w	r8,0
80009ca2:	e0 8a 00 17 	brle	80009cd0 <_dtoa_r+0x820>
80009ca6:	10 9a       	mov	r10,r8
80009ca8:	50 08       	stdsp	sp[0x0],r8
80009caa:	08 9b       	mov	r11,r4
80009cac:	0e 9c       	mov	r12,r7
80009cae:	e0 a0 08 cd 	rcall	8000ae48 <__pow5mult>
80009cb2:	06 9a       	mov	r10,r3
80009cb4:	18 9b       	mov	r11,r12
80009cb6:	18 94       	mov	r4,r12
80009cb8:	0e 9c       	mov	r12,r7
80009cba:	e0 a0 08 01 	rcall	8000acbc <__multiply>
80009cbe:	18 99       	mov	r9,r12
80009cc0:	06 9b       	mov	r11,r3
80009cc2:	50 19       	stdsp	sp[0x4],r9
80009cc4:	0e 9c       	mov	r12,r7
80009cc6:	e0 a0 06 ad 	rcall	8000aa20 <_Bfree>
80009cca:	40 19       	lddsp	r9,sp[0x4]
80009ccc:	40 08       	lddsp	r8,sp[0x0]
80009cce:	12 93       	mov	r3,r9
80009cd0:	e4 08 01 0a 	sub	r10,r2,r8
80009cd4:	c0 80       	breq	80009ce4 <_dtoa_r+0x834>
80009cd6:	c0 28       	rjmp	80009cda <_dtoa_r+0x82a>
80009cd8:	04 9a       	mov	r10,r2
80009cda:	06 9b       	mov	r11,r3
80009cdc:	0e 9c       	mov	r12,r7
80009cde:	e0 a0 08 b5 	rcall	8000ae48 <__pow5mult>
80009ce2:	18 93       	mov	r3,r12
80009ce4:	30 1b       	mov	r11,1
80009ce6:	0e 9c       	mov	r12,r7
80009ce8:	e0 a0 08 6a 	rcall	8000adbc <__i2b>
80009cec:	41 1a       	lddsp	r10,sp[0x44]
80009cee:	18 92       	mov	r2,r12
80009cf0:	58 0a       	cp.w	r10,0
80009cf2:	e0 8a 00 07 	brle	80009d00 <_dtoa_r+0x850>
80009cf6:	18 9b       	mov	r11,r12
80009cf8:	0e 9c       	mov	r12,r7
80009cfa:	e0 a0 08 a7 	rcall	8000ae48 <__pow5mult>
80009cfe:	18 92       	mov	r2,r12
80009d00:	40 c9       	lddsp	r9,sp[0x30]
80009d02:	58 19       	cp.w	r9,1
80009d04:	e0 89 00 14 	brgt	80009d2c <_dtoa_r+0x87c>
80009d08:	40 38       	lddsp	r8,sp[0xc]
80009d0a:	58 08       	cp.w	r8,0
80009d0c:	c1 01       	brne	80009d2c <_dtoa_r+0x87c>
80009d0e:	40 29       	lddsp	r9,sp[0x8]
80009d10:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80009d14:	c0 c1       	brne	80009d2c <_dtoa_r+0x87c>
80009d16:	12 98       	mov	r8,r9
80009d18:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009d1c:	c0 80       	breq	80009d2c <_dtoa_r+0x87c>
80009d1e:	40 4c       	lddsp	r12,sp[0x10]
80009d20:	30 1b       	mov	r11,1
80009d22:	2f fc       	sub	r12,-1
80009d24:	2f f0       	sub	r0,-1
80009d26:	50 4c       	stdsp	sp[0x10],r12
80009d28:	50 6b       	stdsp	sp[0x18],r11
80009d2a:	c0 38       	rjmp	80009d30 <_dtoa_r+0x880>
80009d2c:	30 0a       	mov	r10,0
80009d2e:	50 6a       	stdsp	sp[0x18],r10
80009d30:	41 19       	lddsp	r9,sp[0x44]
80009d32:	58 09       	cp.w	r9,0
80009d34:	c0 31       	brne	80009d3a <_dtoa_r+0x88a>
80009d36:	30 1c       	mov	r12,1
80009d38:	c0 98       	rjmp	80009d4a <_dtoa_r+0x89a>
80009d3a:	64 48       	ld.w	r8,r2[0x10]
80009d3c:	2f c8       	sub	r8,-4
80009d3e:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
80009d42:	e0 a0 05 df 	rcall	8000a900 <__hi0bits>
80009d46:	f8 0c 11 20 	rsub	r12,r12,32
80009d4a:	40 4b       	lddsp	r11,sp[0x10]
80009d4c:	f8 0b 00 08 	add	r8,r12,r11
80009d50:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80009d54:	c0 c0       	breq	80009d6c <_dtoa_r+0x8bc>
80009d56:	f0 08 11 20 	rsub	r8,r8,32
80009d5a:	58 48       	cp.w	r8,4
80009d5c:	e0 8a 00 06 	brle	80009d68 <_dtoa_r+0x8b8>
80009d60:	20 48       	sub	r8,4
80009d62:	10 0b       	add	r11,r8
80009d64:	50 4b       	stdsp	sp[0x10],r11
80009d66:	c0 78       	rjmp	80009d74 <_dtoa_r+0x8c4>
80009d68:	58 48       	cp.w	r8,4
80009d6a:	c0 70       	breq	80009d78 <_dtoa_r+0x8c8>
80009d6c:	40 4a       	lddsp	r10,sp[0x10]
80009d6e:	2e 48       	sub	r8,-28
80009d70:	10 0a       	add	r10,r8
80009d72:	50 4a       	stdsp	sp[0x10],r10
80009d74:	10 00       	add	r0,r8
80009d76:	10 05       	add	r5,r8
80009d78:	58 00       	cp.w	r0,0
80009d7a:	e0 8a 00 08 	brle	80009d8a <_dtoa_r+0x8da>
80009d7e:	06 9b       	mov	r11,r3
80009d80:	00 9a       	mov	r10,r0
80009d82:	0e 9c       	mov	r12,r7
80009d84:	e0 a0 07 58 	rcall	8000ac34 <__lshift>
80009d88:	18 93       	mov	r3,r12
80009d8a:	40 49       	lddsp	r9,sp[0x10]
80009d8c:	58 09       	cp.w	r9,0
80009d8e:	e0 8a 00 08 	brle	80009d9e <_dtoa_r+0x8ee>
80009d92:	04 9b       	mov	r11,r2
80009d94:	12 9a       	mov	r10,r9
80009d96:	0e 9c       	mov	r12,r7
80009d98:	e0 a0 07 4e 	rcall	8000ac34 <__lshift>
80009d9c:	18 92       	mov	r2,r12
80009d9e:	41 48       	lddsp	r8,sp[0x50]
80009da0:	58 08       	cp.w	r8,0
80009da2:	c1 b0       	breq	80009dd8 <_dtoa_r+0x928>
80009da4:	04 9b       	mov	r11,r2
80009da6:	06 9c       	mov	r12,r3
80009da8:	e0 a0 06 23 	rcall	8000a9ee <__mcmp>
80009dac:	c1 64       	brge	80009dd8 <_dtoa_r+0x928>
80009dae:	06 9b       	mov	r11,r3
80009db0:	30 09       	mov	r9,0
80009db2:	30 aa       	mov	r10,10
80009db4:	0e 9c       	mov	r12,r7
80009db6:	e0 a0 08 0b 	rcall	8000adcc <__multadd>
80009dba:	20 16       	sub	r6,1
80009dbc:	18 93       	mov	r3,r12
80009dbe:	40 dc       	lddsp	r12,sp[0x34]
80009dc0:	58 0c       	cp.w	r12,0
80009dc2:	c0 31       	brne	80009dc8 <_dtoa_r+0x918>
80009dc4:	40 91       	lddsp	r1,sp[0x24]
80009dc6:	c0 98       	rjmp	80009dd8 <_dtoa_r+0x928>
80009dc8:	08 9b       	mov	r11,r4
80009dca:	40 91       	lddsp	r1,sp[0x24]
80009dcc:	30 09       	mov	r9,0
80009dce:	30 aa       	mov	r10,10
80009dd0:	0e 9c       	mov	r12,r7
80009dd2:	e0 a0 07 fd 	rcall	8000adcc <__multadd>
80009dd6:	18 94       	mov	r4,r12
80009dd8:	58 01       	cp.w	r1,0
80009dda:	5f a9       	srle	r9
80009ddc:	40 cb       	lddsp	r11,sp[0x30]
80009dde:	58 2b       	cp.w	r11,2
80009de0:	5f 98       	srgt	r8
80009de2:	f3 e8 00 08 	and	r8,r9,r8
80009de6:	c2 50       	breq	80009e30 <_dtoa_r+0x980>
80009de8:	58 01       	cp.w	r1,0
80009dea:	c1 11       	brne	80009e0c <_dtoa_r+0x95c>
80009dec:	04 9b       	mov	r11,r2
80009dee:	02 99       	mov	r9,r1
80009df0:	30 5a       	mov	r10,5
80009df2:	0e 9c       	mov	r12,r7
80009df4:	e0 a0 07 ec 	rcall	8000adcc <__multadd>
80009df8:	18 92       	mov	r2,r12
80009dfa:	18 9b       	mov	r11,r12
80009dfc:	06 9c       	mov	r12,r3
80009dfe:	e0 a0 05 f8 	rcall	8000a9ee <__mcmp>
80009e02:	e0 89 00 0f 	brgt	80009e20 <_dtoa_r+0x970>
80009e06:	c0 38       	rjmp	80009e0c <_dtoa_r+0x95c>
80009e08:	30 02       	mov	r2,0
80009e0a:	04 94       	mov	r4,r2
80009e0c:	40 ea       	lddsp	r10,sp[0x38]
80009e0e:	30 09       	mov	r9,0
80009e10:	5c da       	com	r10
80009e12:	40 85       	lddsp	r5,sp[0x20]
80009e14:	50 6a       	stdsp	sp[0x18],r10
80009e16:	50 49       	stdsp	sp[0x10],r9
80009e18:	c0 f9       	rjmp	8000a036 <_dtoa_r+0xb86>
80009e1a:	08 92       	mov	r2,r4
80009e1c:	40 66       	lddsp	r6,sp[0x18]
80009e1e:	04 94       	mov	r4,r2
80009e20:	2f f6       	sub	r6,-1
80009e22:	50 66       	stdsp	sp[0x18],r6
80009e24:	33 18       	mov	r8,49
80009e26:	40 85       	lddsp	r5,sp[0x20]
80009e28:	0a c8       	st.b	r5++,r8
80009e2a:	30 08       	mov	r8,0
80009e2c:	50 48       	stdsp	sp[0x10],r8
80009e2e:	c0 49       	rjmp	8000a036 <_dtoa_r+0xb86>
80009e30:	40 dc       	lddsp	r12,sp[0x34]
80009e32:	58 0c       	cp.w	r12,0
80009e34:	e0 80 00 b5 	breq	80009f9e <_dtoa_r+0xaee>
80009e38:	58 05       	cp.w	r5,0
80009e3a:	e0 8a 00 08 	brle	80009e4a <_dtoa_r+0x99a>
80009e3e:	08 9b       	mov	r11,r4
80009e40:	0a 9a       	mov	r10,r5
80009e42:	0e 9c       	mov	r12,r7
80009e44:	e0 a0 06 f8 	rcall	8000ac34 <__lshift>
80009e48:	18 94       	mov	r4,r12
80009e4a:	40 6b       	lddsp	r11,sp[0x18]
80009e4c:	58 0b       	cp.w	r11,0
80009e4e:	c0 31       	brne	80009e54 <_dtoa_r+0x9a4>
80009e50:	08 9c       	mov	r12,r4
80009e52:	c1 38       	rjmp	80009e78 <_dtoa_r+0x9c8>
80009e54:	68 1b       	ld.w	r11,r4[0x4]
80009e56:	0e 9c       	mov	r12,r7
80009e58:	e0 a0 05 fe 	rcall	8000aa54 <_Balloc>
80009e5c:	68 4a       	ld.w	r10,r4[0x10]
80009e5e:	18 95       	mov	r5,r12
80009e60:	e8 cb ff f4 	sub	r11,r4,-12
80009e64:	2f ea       	sub	r10,-2
80009e66:	2f 4c       	sub	r12,-12
80009e68:	a3 6a       	lsl	r10,0x2
80009e6a:	fe b0 e6 43 	rcall	80006af0 <memcpy>
80009e6e:	0a 9b       	mov	r11,r5
80009e70:	30 1a       	mov	r10,1
80009e72:	0e 9c       	mov	r12,r7
80009e74:	e0 a0 06 e0 	rcall	8000ac34 <__lshift>
80009e78:	50 44       	stdsp	sp[0x10],r4
80009e7a:	40 3a       	lddsp	r10,sp[0xc]
80009e7c:	30 19       	mov	r9,1
80009e7e:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80009e82:	18 94       	mov	r4,r12
80009e84:	50 da       	stdsp	sp[0x34],r10
80009e86:	40 85       	lddsp	r5,sp[0x20]
80009e88:	50 99       	stdsp	sp[0x24],r9
80009e8a:	50 26       	stdsp	sp[0x8],r6
80009e8c:	50 e1       	stdsp	sp[0x38],r1
80009e8e:	04 9b       	mov	r11,r2
80009e90:	06 9c       	mov	r12,r3
80009e92:	fe b0 fa 7f 	rcall	80009390 <quorem>
80009e96:	40 4b       	lddsp	r11,sp[0x10]
80009e98:	f8 c0 ff d0 	sub	r0,r12,-48
80009e9c:	06 9c       	mov	r12,r3
80009e9e:	e0 a0 05 a8 	rcall	8000a9ee <__mcmp>
80009ea2:	08 9a       	mov	r10,r4
80009ea4:	50 6c       	stdsp	sp[0x18],r12
80009ea6:	04 9b       	mov	r11,r2
80009ea8:	0e 9c       	mov	r12,r7
80009eaa:	e0 a0 06 5d 	rcall	8000ab64 <__mdiff>
80009eae:	18 91       	mov	r1,r12
80009eb0:	78 38       	ld.w	r8,r12[0xc]
80009eb2:	58 08       	cp.w	r8,0
80009eb4:	c0 30       	breq	80009eba <_dtoa_r+0xa0a>
80009eb6:	30 16       	mov	r6,1
80009eb8:	c0 68       	rjmp	80009ec4 <_dtoa_r+0xa14>
80009eba:	18 9b       	mov	r11,r12
80009ebc:	06 9c       	mov	r12,r3
80009ebe:	e0 a0 05 98 	rcall	8000a9ee <__mcmp>
80009ec2:	18 96       	mov	r6,r12
80009ec4:	0e 9c       	mov	r12,r7
80009ec6:	02 9b       	mov	r11,r1
80009ec8:	e0 a0 05 ac 	rcall	8000aa20 <_Bfree>
80009ecc:	40 cc       	lddsp	r12,sp[0x30]
80009ece:	ed ec 10 08 	or	r8,r6,r12
80009ed2:	c0 d1       	brne	80009eec <_dtoa_r+0xa3c>
80009ed4:	40 db       	lddsp	r11,sp[0x34]
80009ed6:	58 0b       	cp.w	r11,0
80009ed8:	c0 a1       	brne	80009eec <_dtoa_r+0xa3c>
80009eda:	40 26       	lddsp	r6,sp[0x8]
80009edc:	e0 40 00 39 	cp.w	r0,57
80009ee0:	c3 00       	breq	80009f40 <_dtoa_r+0xa90>
80009ee2:	40 6a       	lddsp	r10,sp[0x18]
80009ee4:	58 0a       	cp.w	r10,0
80009ee6:	e0 89 00 24 	brgt	80009f2e <_dtoa_r+0xa7e>
80009eea:	c2 f8       	rjmp	80009f48 <_dtoa_r+0xa98>
80009eec:	40 69       	lddsp	r9,sp[0x18]
80009eee:	58 09       	cp.w	r9,0
80009ef0:	c0 85       	brlt	80009f00 <_dtoa_r+0xa50>
80009ef2:	12 98       	mov	r8,r9
80009ef4:	40 cc       	lddsp	r12,sp[0x30]
80009ef6:	18 48       	or	r8,r12
80009ef8:	c1 d1       	brne	80009f32 <_dtoa_r+0xa82>
80009efa:	40 db       	lddsp	r11,sp[0x34]
80009efc:	58 0b       	cp.w	r11,0
80009efe:	c1 a1       	brne	80009f32 <_dtoa_r+0xa82>
80009f00:	0c 99       	mov	r9,r6
80009f02:	40 26       	lddsp	r6,sp[0x8]
80009f04:	58 09       	cp.w	r9,0
80009f06:	e0 8a 00 21 	brle	80009f48 <_dtoa_r+0xa98>
80009f0a:	06 9b       	mov	r11,r3
80009f0c:	30 1a       	mov	r10,1
80009f0e:	0e 9c       	mov	r12,r7
80009f10:	e0 a0 06 92 	rcall	8000ac34 <__lshift>
80009f14:	04 9b       	mov	r11,r2
80009f16:	18 93       	mov	r3,r12
80009f18:	e0 a0 05 6b 	rcall	8000a9ee <__mcmp>
80009f1c:	e0 89 00 06 	brgt	80009f28 <_dtoa_r+0xa78>
80009f20:	c1 41       	brne	80009f48 <_dtoa_r+0xa98>
80009f22:	ed b0 00 00 	bld	r0,0x0
80009f26:	c1 11       	brne	80009f48 <_dtoa_r+0xa98>
80009f28:	e0 40 00 39 	cp.w	r0,57
80009f2c:	c0 a0       	breq	80009f40 <_dtoa_r+0xa90>
80009f2e:	2f f0       	sub	r0,-1
80009f30:	c0 c8       	rjmp	80009f48 <_dtoa_r+0xa98>
80009f32:	58 06       	cp.w	r6,0
80009f34:	e0 8a 00 0c 	brle	80009f4c <_dtoa_r+0xa9c>
80009f38:	40 26       	lddsp	r6,sp[0x8]
80009f3a:	e0 40 00 39 	cp.w	r0,57
80009f3e:	c0 41       	brne	80009f46 <_dtoa_r+0xa96>
80009f40:	33 98       	mov	r8,57
80009f42:	0a c8       	st.b	r5++,r8
80009f44:	c6 78       	rjmp	8000a012 <_dtoa_r+0xb62>
80009f46:	2f f0       	sub	r0,-1
80009f48:	0a c0       	st.b	r5++,r0
80009f4a:	c7 58       	rjmp	8000a034 <_dtoa_r+0xb84>
80009f4c:	0a c0       	st.b	r5++,r0
80009f4e:	40 9a       	lddsp	r10,sp[0x24]
80009f50:	40 e9       	lddsp	r9,sp[0x38]
80009f52:	12 3a       	cp.w	r10,r9
80009f54:	c4 30       	breq	80009fda <_dtoa_r+0xb2a>
80009f56:	06 9b       	mov	r11,r3
80009f58:	30 09       	mov	r9,0
80009f5a:	30 aa       	mov	r10,10
80009f5c:	0e 9c       	mov	r12,r7
80009f5e:	e0 a0 07 37 	rcall	8000adcc <__multadd>
80009f62:	40 48       	lddsp	r8,sp[0x10]
80009f64:	18 93       	mov	r3,r12
80009f66:	08 38       	cp.w	r8,r4
80009f68:	c0 91       	brne	80009f7a <_dtoa_r+0xaca>
80009f6a:	10 9b       	mov	r11,r8
80009f6c:	30 09       	mov	r9,0
80009f6e:	30 aa       	mov	r10,10
80009f70:	0e 9c       	mov	r12,r7
80009f72:	e0 a0 07 2d 	rcall	8000adcc <__multadd>
80009f76:	50 4c       	stdsp	sp[0x10],r12
80009f78:	c0 e8       	rjmp	80009f94 <_dtoa_r+0xae4>
80009f7a:	40 4b       	lddsp	r11,sp[0x10]
80009f7c:	30 09       	mov	r9,0
80009f7e:	30 aa       	mov	r10,10
80009f80:	0e 9c       	mov	r12,r7
80009f82:	e0 a0 07 25 	rcall	8000adcc <__multadd>
80009f86:	08 9b       	mov	r11,r4
80009f88:	50 4c       	stdsp	sp[0x10],r12
80009f8a:	30 09       	mov	r9,0
80009f8c:	30 aa       	mov	r10,10
80009f8e:	0e 9c       	mov	r12,r7
80009f90:	e0 a0 07 1e 	rcall	8000adcc <__multadd>
80009f94:	18 94       	mov	r4,r12
80009f96:	40 9c       	lddsp	r12,sp[0x24]
80009f98:	2f fc       	sub	r12,-1
80009f9a:	50 9c       	stdsp	sp[0x24],r12
80009f9c:	c7 9b       	rjmp	80009e8e <_dtoa_r+0x9de>
80009f9e:	30 18       	mov	r8,1
80009fa0:	06 90       	mov	r0,r3
80009fa2:	40 85       	lddsp	r5,sp[0x20]
80009fa4:	08 93       	mov	r3,r4
80009fa6:	0c 94       	mov	r4,r6
80009fa8:	10 96       	mov	r6,r8
80009faa:	04 9b       	mov	r11,r2
80009fac:	00 9c       	mov	r12,r0
80009fae:	fe b0 f9 f1 	rcall	80009390 <quorem>
80009fb2:	2d 0c       	sub	r12,-48
80009fb4:	0a cc       	st.b	r5++,r12
80009fb6:	02 36       	cp.w	r6,r1
80009fb8:	c0 a4       	brge	80009fcc <_dtoa_r+0xb1c>
80009fba:	00 9b       	mov	r11,r0
80009fbc:	30 09       	mov	r9,0
80009fbe:	30 aa       	mov	r10,10
80009fc0:	0e 9c       	mov	r12,r7
80009fc2:	2f f6       	sub	r6,-1
80009fc4:	e0 a0 07 04 	rcall	8000adcc <__multadd>
80009fc8:	18 90       	mov	r0,r12
80009fca:	cf 0b       	rjmp	80009faa <_dtoa_r+0xafa>
80009fcc:	08 96       	mov	r6,r4
80009fce:	30 0b       	mov	r11,0
80009fd0:	06 94       	mov	r4,r3
80009fd2:	50 4b       	stdsp	sp[0x10],r11
80009fd4:	00 93       	mov	r3,r0
80009fd6:	18 90       	mov	r0,r12
80009fd8:	c0 28       	rjmp	80009fdc <_dtoa_r+0xb2c>
80009fda:	40 26       	lddsp	r6,sp[0x8]
80009fdc:	06 9b       	mov	r11,r3
80009fde:	30 1a       	mov	r10,1
80009fe0:	0e 9c       	mov	r12,r7
80009fe2:	e0 a0 06 29 	rcall	8000ac34 <__lshift>
80009fe6:	04 9b       	mov	r11,r2
80009fe8:	18 93       	mov	r3,r12
80009fea:	e0 a0 05 02 	rcall	8000a9ee <__mcmp>
80009fee:	e0 89 00 12 	brgt	8000a012 <_dtoa_r+0xb62>
80009ff2:	c1 b1       	brne	8000a028 <_dtoa_r+0xb78>
80009ff4:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80009ff8:	c0 d1       	brne	8000a012 <_dtoa_r+0xb62>
80009ffa:	c1 78       	rjmp	8000a028 <_dtoa_r+0xb78>
80009ffc:	40 89       	lddsp	r9,sp[0x20]
80009ffe:	12 38       	cp.w	r8,r9
8000a000:	c0 30       	breq	8000a006 <_dtoa_r+0xb56>
8000a002:	10 95       	mov	r5,r8
8000a004:	c0 88       	rjmp	8000a014 <_dtoa_r+0xb64>
8000a006:	2f f6       	sub	r6,-1
8000a008:	50 66       	stdsp	sp[0x18],r6
8000a00a:	33 18       	mov	r8,49
8000a00c:	40 8c       	lddsp	r12,sp[0x20]
8000a00e:	b8 88       	st.b	r12[0x0],r8
8000a010:	c1 38       	rjmp	8000a036 <_dtoa_r+0xb86>
8000a012:	33 9a       	mov	r10,57
8000a014:	0a 98       	mov	r8,r5
8000a016:	11 79       	ld.ub	r9,--r8
8000a018:	f4 09 18 00 	cp.b	r9,r10
8000a01c:	cf 00       	breq	80009ffc <_dtoa_r+0xb4c>
8000a01e:	2f f9       	sub	r9,-1
8000a020:	b0 89       	st.b	r8[0x0],r9
8000a022:	c0 98       	rjmp	8000a034 <_dtoa_r+0xb84>
8000a024:	10 95       	mov	r5,r8
8000a026:	c0 28       	rjmp	8000a02a <_dtoa_r+0xb7a>
8000a028:	33 09       	mov	r9,48
8000a02a:	0a 98       	mov	r8,r5
8000a02c:	11 7a       	ld.ub	r10,--r8
8000a02e:	f2 0a 18 00 	cp.b	r10,r9
8000a032:	cf 90       	breq	8000a024 <_dtoa_r+0xb74>
8000a034:	50 66       	stdsp	sp[0x18],r6
8000a036:	04 9b       	mov	r11,r2
8000a038:	0e 9c       	mov	r12,r7
8000a03a:	e0 a0 04 f3 	rcall	8000aa20 <_Bfree>
8000a03e:	58 04       	cp.w	r4,0
8000a040:	c1 20       	breq	8000a064 <_dtoa_r+0xbb4>
8000a042:	40 4b       	lddsp	r11,sp[0x10]
8000a044:	08 3b       	cp.w	r11,r4
8000a046:	5f 19       	srne	r9
8000a048:	58 0b       	cp.w	r11,0
8000a04a:	5f 18       	srne	r8
8000a04c:	f3 e8 00 08 	and	r8,r9,r8
8000a050:	c0 40       	breq	8000a058 <_dtoa_r+0xba8>
8000a052:	0e 9c       	mov	r12,r7
8000a054:	e0 a0 04 e6 	rcall	8000aa20 <_Bfree>
8000a058:	08 9b       	mov	r11,r4
8000a05a:	0e 9c       	mov	r12,r7
8000a05c:	e0 a0 04 e2 	rcall	8000aa20 <_Bfree>
8000a060:	c0 28       	rjmp	8000a064 <_dtoa_r+0xbb4>
8000a062:	50 66       	stdsp	sp[0x18],r6
8000a064:	0e 9c       	mov	r12,r7
8000a066:	06 9b       	mov	r11,r3
8000a068:	e0 a0 04 dc 	rcall	8000aa20 <_Bfree>
8000a06c:	30 08       	mov	r8,0
8000a06e:	aa 88       	st.b	r5[0x0],r8
8000a070:	40 68       	lddsp	r8,sp[0x18]
8000a072:	41 5a       	lddsp	r10,sp[0x54]
8000a074:	2f f8       	sub	r8,-1
8000a076:	41 29       	lddsp	r9,sp[0x48]
8000a078:	95 08       	st.w	r10[0x0],r8
8000a07a:	40 8c       	lddsp	r12,sp[0x20]
8000a07c:	58 09       	cp.w	r9,0
8000a07e:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a082:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a086:	2e 6d       	sub	sp,-104
8000a088:	d8 32       	popm	r0-r7,pc
8000a08a:	d7 03       	nop

8000a08c <__errno>:
8000a08c:	e0 68 0a 30 	mov	r8,2608
8000a090:	70 0c       	ld.w	r12,r8[0x0]
8000a092:	2f 4c       	sub	r12,-12
8000a094:	5e fc       	retal	r12
8000a096:	d7 03       	nop

8000a098 <_fflush_r>:
8000a098:	d4 21       	pushm	r4-r7,lr
8000a09a:	16 97       	mov	r7,r11
8000a09c:	18 96       	mov	r6,r12
8000a09e:	76 48       	ld.w	r8,r11[0x10]
8000a0a0:	58 08       	cp.w	r8,0
8000a0a2:	c7 f0       	breq	8000a1a0 <_fflush_r+0x108>
8000a0a4:	58 0c       	cp.w	r12,0
8000a0a6:	c0 50       	breq	8000a0b0 <_fflush_r+0x18>
8000a0a8:	78 68       	ld.w	r8,r12[0x18]
8000a0aa:	58 08       	cp.w	r8,0
8000a0ac:	c0 21       	brne	8000a0b0 <_fflush_r+0x18>
8000a0ae:	cc dc       	rcall	8000a248 <__sinit>
8000a0b0:	fe c8 c8 b4 	sub	r8,pc,-14156
8000a0b4:	10 37       	cp.w	r7,r8
8000a0b6:	c0 31       	brne	8000a0bc <_fflush_r+0x24>
8000a0b8:	6c 07       	ld.w	r7,r6[0x0]
8000a0ba:	c0 c8       	rjmp	8000a0d2 <_fflush_r+0x3a>
8000a0bc:	fe c8 c8 a0 	sub	r8,pc,-14176
8000a0c0:	10 37       	cp.w	r7,r8
8000a0c2:	c0 31       	brne	8000a0c8 <_fflush_r+0x30>
8000a0c4:	6c 17       	ld.w	r7,r6[0x4]
8000a0c6:	c0 68       	rjmp	8000a0d2 <_fflush_r+0x3a>
8000a0c8:	fe c8 c8 8c 	sub	r8,pc,-14196
8000a0cc:	10 37       	cp.w	r7,r8
8000a0ce:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a0d2:	8e 6a       	ld.sh	r10,r7[0xc]
8000a0d4:	14 98       	mov	r8,r10
8000a0d6:	ed ba 00 03 	bld	r10,0x3
8000a0da:	c4 20       	breq	8000a15e <_fflush_r+0xc6>
8000a0dc:	ab ba       	sbr	r10,0xb
8000a0de:	ae 6a       	st.h	r7[0xc],r10
8000a0e0:	6e 18       	ld.w	r8,r7[0x4]
8000a0e2:	58 08       	cp.w	r8,0
8000a0e4:	e0 89 00 06 	brgt	8000a0f0 <_fflush_r+0x58>
8000a0e8:	6f 08       	ld.w	r8,r7[0x40]
8000a0ea:	58 08       	cp.w	r8,0
8000a0ec:	e0 8a 00 5a 	brle	8000a1a0 <_fflush_r+0x108>
8000a0f0:	6e b8       	ld.w	r8,r7[0x2c]
8000a0f2:	58 08       	cp.w	r8,0
8000a0f4:	c5 60       	breq	8000a1a0 <_fflush_r+0x108>
8000a0f6:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a0fa:	c0 30       	breq	8000a100 <_fflush_r+0x68>
8000a0fc:	6f 55       	ld.w	r5,r7[0x54]
8000a0fe:	c0 f8       	rjmp	8000a11c <_fflush_r+0x84>
8000a100:	30 19       	mov	r9,1
8000a102:	6e 8b       	ld.w	r11,r7[0x20]
8000a104:	0c 9c       	mov	r12,r6
8000a106:	5d 18       	icall	r8
8000a108:	18 95       	mov	r5,r12
8000a10a:	5b fc       	cp.w	r12,-1
8000a10c:	c0 81       	brne	8000a11c <_fflush_r+0x84>
8000a10e:	6c 38       	ld.w	r8,r6[0xc]
8000a110:	59 d8       	cp.w	r8,29
8000a112:	c4 70       	breq	8000a1a0 <_fflush_r+0x108>
8000a114:	8e 68       	ld.sh	r8,r7[0xc]
8000a116:	a7 a8       	sbr	r8,0x6
8000a118:	ae 68       	st.h	r7[0xc],r8
8000a11a:	d8 22       	popm	r4-r7,pc
8000a11c:	8e 68       	ld.sh	r8,r7[0xc]
8000a11e:	ed b8 00 02 	bld	r8,0x2
8000a122:	c0 91       	brne	8000a134 <_fflush_r+0x9c>
8000a124:	6e 18       	ld.w	r8,r7[0x4]
8000a126:	10 15       	sub	r5,r8
8000a128:	6e d8       	ld.w	r8,r7[0x34]
8000a12a:	58 08       	cp.w	r8,0
8000a12c:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a130:	eb d8 e1 15 	subne	r5,r5,r8
8000a134:	6e b8       	ld.w	r8,r7[0x2c]
8000a136:	0c 9c       	mov	r12,r6
8000a138:	30 09       	mov	r9,0
8000a13a:	0a 9a       	mov	r10,r5
8000a13c:	6e 8b       	ld.w	r11,r7[0x20]
8000a13e:	5d 18       	icall	r8
8000a140:	8e 68       	ld.sh	r8,r7[0xc]
8000a142:	0a 3c       	cp.w	r12,r5
8000a144:	c2 61       	brne	8000a190 <_fflush_r+0xf8>
8000a146:	ab d8       	cbr	r8,0xb
8000a148:	30 0c       	mov	r12,0
8000a14a:	6e 49       	ld.w	r9,r7[0x10]
8000a14c:	ae 68       	st.h	r7[0xc],r8
8000a14e:	8f 1c       	st.w	r7[0x4],r12
8000a150:	8f 09       	st.w	r7[0x0],r9
8000a152:	ed b8 00 0c 	bld	r8,0xc
8000a156:	c2 51       	brne	8000a1a0 <_fflush_r+0x108>
8000a158:	ef 45 00 54 	st.w	r7[84],r5
8000a15c:	d8 22       	popm	r4-r7,pc
8000a15e:	6e 45       	ld.w	r5,r7[0x10]
8000a160:	58 05       	cp.w	r5,0
8000a162:	c1 f0       	breq	8000a1a0 <_fflush_r+0x108>
8000a164:	6e 04       	ld.w	r4,r7[0x0]
8000a166:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a16a:	8f 05       	st.w	r7[0x0],r5
8000a16c:	f9 b8 01 00 	movne	r8,0
8000a170:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a174:	0a 14       	sub	r4,r5
8000a176:	8f 28       	st.w	r7[0x8],r8
8000a178:	c1 18       	rjmp	8000a19a <_fflush_r+0x102>
8000a17a:	08 99       	mov	r9,r4
8000a17c:	0a 9a       	mov	r10,r5
8000a17e:	6e a8       	ld.w	r8,r7[0x28]
8000a180:	6e 8b       	ld.w	r11,r7[0x20]
8000a182:	0c 9c       	mov	r12,r6
8000a184:	5d 18       	icall	r8
8000a186:	18 14       	sub	r4,r12
8000a188:	58 0c       	cp.w	r12,0
8000a18a:	e0 89 00 07 	brgt	8000a198 <_fflush_r+0x100>
8000a18e:	8e 68       	ld.sh	r8,r7[0xc]
8000a190:	a7 a8       	sbr	r8,0x6
8000a192:	3f fc       	mov	r12,-1
8000a194:	ae 68       	st.h	r7[0xc],r8
8000a196:	d8 22       	popm	r4-r7,pc
8000a198:	18 05       	add	r5,r12
8000a19a:	58 04       	cp.w	r4,0
8000a19c:	fe 99 ff ef 	brgt	8000a17a <_fflush_r+0xe2>
8000a1a0:	d8 2a       	popm	r4-r7,pc,r12=0
8000a1a2:	d7 03       	nop

8000a1a4 <__sfp_lock_acquire>:
8000a1a4:	5e fc       	retal	r12

8000a1a6 <__sfp_lock_release>:
8000a1a6:	5e fc       	retal	r12

8000a1a8 <_cleanup_r>:
8000a1a8:	d4 01       	pushm	lr
8000a1aa:	fe cb f0 c6 	sub	r11,pc,-3898
8000a1ae:	e0 a0 02 f7 	rcall	8000a79c <_fwalk>
8000a1b2:	d8 02       	popm	pc

8000a1b4 <__sfmoreglue>:
8000a1b4:	d4 21       	pushm	r4-r7,lr
8000a1b6:	16 95       	mov	r5,r11
8000a1b8:	f6 06 10 5c 	mul	r6,r11,92
8000a1bc:	ec cb ff f4 	sub	r11,r6,-12
8000a1c0:	fe b0 e2 7c 	rcall	800066b8 <_malloc_r>
8000a1c4:	18 97       	mov	r7,r12
8000a1c6:	c0 90       	breq	8000a1d8 <__sfmoreglue+0x24>
8000a1c8:	99 15       	st.w	r12[0x4],r5
8000a1ca:	30 0b       	mov	r11,0
8000a1cc:	2f 4c       	sub	r12,-12
8000a1ce:	0c 9a       	mov	r10,r6
8000a1d0:	8f 2c       	st.w	r7[0x8],r12
8000a1d2:	8f 0b       	st.w	r7[0x0],r11
8000a1d4:	fe b0 e5 32 	rcall	80006c38 <memset>
8000a1d8:	0e 9c       	mov	r12,r7
8000a1da:	d8 22       	popm	r4-r7,pc

8000a1dc <__sfp>:
8000a1dc:	d4 21       	pushm	r4-r7,lr
8000a1de:	fe c8 c9 7e 	sub	r8,pc,-13954
8000a1e2:	18 96       	mov	r6,r12
8000a1e4:	70 07       	ld.w	r7,r8[0x0]
8000a1e6:	6e 68       	ld.w	r8,r7[0x18]
8000a1e8:	58 08       	cp.w	r8,0
8000a1ea:	c0 31       	brne	8000a1f0 <__sfp+0x14>
8000a1ec:	0e 9c       	mov	r12,r7
8000a1ee:	c2 dc       	rcall	8000a248 <__sinit>
8000a1f0:	ee c7 ff 28 	sub	r7,r7,-216
8000a1f4:	30 05       	mov	r5,0
8000a1f6:	6e 2c       	ld.w	r12,r7[0x8]
8000a1f8:	6e 18       	ld.w	r8,r7[0x4]
8000a1fa:	c0 68       	rjmp	8000a206 <__sfp+0x2a>
8000a1fc:	98 69       	ld.sh	r9,r12[0xc]
8000a1fe:	ea 09 19 00 	cp.h	r9,r5
8000a202:	c1 10       	breq	8000a224 <__sfp+0x48>
8000a204:	2a 4c       	sub	r12,-92
8000a206:	20 18       	sub	r8,1
8000a208:	cf a7       	brpl	8000a1fc <__sfp+0x20>
8000a20a:	6e 08       	ld.w	r8,r7[0x0]
8000a20c:	58 08       	cp.w	r8,0
8000a20e:	c0 61       	brne	8000a21a <__sfp+0x3e>
8000a210:	30 4b       	mov	r11,4
8000a212:	0c 9c       	mov	r12,r6
8000a214:	cd 0f       	rcall	8000a1b4 <__sfmoreglue>
8000a216:	8f 0c       	st.w	r7[0x0],r12
8000a218:	c0 30       	breq	8000a21e <__sfp+0x42>
8000a21a:	6e 07       	ld.w	r7,r7[0x0]
8000a21c:	ce db       	rjmp	8000a1f6 <__sfp+0x1a>
8000a21e:	30 c8       	mov	r8,12
8000a220:	8d 38       	st.w	r6[0xc],r8
8000a222:	d8 22       	popm	r4-r7,pc
8000a224:	30 08       	mov	r8,0
8000a226:	f9 48 00 4c 	st.w	r12[76],r8
8000a22a:	99 08       	st.w	r12[0x0],r8
8000a22c:	99 28       	st.w	r12[0x8],r8
8000a22e:	99 18       	st.w	r12[0x4],r8
8000a230:	99 48       	st.w	r12[0x10],r8
8000a232:	99 58       	st.w	r12[0x14],r8
8000a234:	99 68       	st.w	r12[0x18],r8
8000a236:	99 d8       	st.w	r12[0x34],r8
8000a238:	99 e8       	st.w	r12[0x38],r8
8000a23a:	f9 48 00 48 	st.w	r12[72],r8
8000a23e:	3f f8       	mov	r8,-1
8000a240:	b8 78       	st.h	r12[0xe],r8
8000a242:	30 18       	mov	r8,1
8000a244:	b8 68       	st.h	r12[0xc],r8
8000a246:	d8 22       	popm	r4-r7,pc

8000a248 <__sinit>:
8000a248:	d4 21       	pushm	r4-r7,lr
8000a24a:	18 96       	mov	r6,r12
8000a24c:	78 67       	ld.w	r7,r12[0x18]
8000a24e:	58 07       	cp.w	r7,0
8000a250:	c4 91       	brne	8000a2e2 <__sinit+0x9a>
8000a252:	fe c8 00 aa 	sub	r8,pc,170
8000a256:	30 15       	mov	r5,1
8000a258:	99 a8       	st.w	r12[0x28],r8
8000a25a:	f9 47 00 d8 	st.w	r12[216],r7
8000a25e:	f9 47 00 dc 	st.w	r12[220],r7
8000a262:	f9 47 00 e0 	st.w	r12[224],r7
8000a266:	99 65       	st.w	r12[0x18],r5
8000a268:	cb af       	rcall	8000a1dc <__sfp>
8000a26a:	8d 0c       	st.w	r6[0x0],r12
8000a26c:	0c 9c       	mov	r12,r6
8000a26e:	cb 7f       	rcall	8000a1dc <__sfp>
8000a270:	8d 1c       	st.w	r6[0x4],r12
8000a272:	0c 9c       	mov	r12,r6
8000a274:	cb 4f       	rcall	8000a1dc <__sfp>
8000a276:	6c 09       	ld.w	r9,r6[0x0]
8000a278:	30 48       	mov	r8,4
8000a27a:	93 07       	st.w	r9[0x0],r7
8000a27c:	b2 68       	st.h	r9[0xc],r8
8000a27e:	93 17       	st.w	r9[0x4],r7
8000a280:	93 27       	st.w	r9[0x8],r7
8000a282:	6c 18       	ld.w	r8,r6[0x4]
8000a284:	b2 77       	st.h	r9[0xe],r7
8000a286:	93 47       	st.w	r9[0x10],r7
8000a288:	93 57       	st.w	r9[0x14],r7
8000a28a:	93 67       	st.w	r9[0x18],r7
8000a28c:	93 89       	st.w	r9[0x20],r9
8000a28e:	91 07       	st.w	r8[0x0],r7
8000a290:	91 17       	st.w	r8[0x4],r7
8000a292:	91 27       	st.w	r8[0x8],r7
8000a294:	fe ce f3 24 	sub	lr,pc,-3292
8000a298:	fe cb f3 54 	sub	r11,pc,-3244
8000a29c:	93 9e       	st.w	r9[0x24],lr
8000a29e:	93 ab       	st.w	r9[0x28],r11
8000a2a0:	fe ca f3 7c 	sub	r10,pc,-3204
8000a2a4:	fe c4 f3 88 	sub	r4,pc,-3192
8000a2a8:	93 ba       	st.w	r9[0x2c],r10
8000a2aa:	93 c4       	st.w	r9[0x30],r4
8000a2ac:	30 99       	mov	r9,9
8000a2ae:	b0 69       	st.h	r8[0xc],r9
8000a2b0:	b0 75       	st.h	r8[0xe],r5
8000a2b2:	91 c4       	st.w	r8[0x30],r4
8000a2b4:	91 47       	st.w	r8[0x10],r7
8000a2b6:	91 57       	st.w	r8[0x14],r7
8000a2b8:	91 67       	st.w	r8[0x18],r7
8000a2ba:	91 88       	st.w	r8[0x20],r8
8000a2bc:	91 9e       	st.w	r8[0x24],lr
8000a2be:	91 ab       	st.w	r8[0x28],r11
8000a2c0:	91 ba       	st.w	r8[0x2c],r10
8000a2c2:	8d 2c       	st.w	r6[0x8],r12
8000a2c4:	31 28       	mov	r8,18
8000a2c6:	99 07       	st.w	r12[0x0],r7
8000a2c8:	b8 68       	st.h	r12[0xc],r8
8000a2ca:	99 17       	st.w	r12[0x4],r7
8000a2cc:	99 27       	st.w	r12[0x8],r7
8000a2ce:	30 28       	mov	r8,2
8000a2d0:	b8 78       	st.h	r12[0xe],r8
8000a2d2:	99 c4       	st.w	r12[0x30],r4
8000a2d4:	99 67       	st.w	r12[0x18],r7
8000a2d6:	99 9e       	st.w	r12[0x24],lr
8000a2d8:	99 ab       	st.w	r12[0x28],r11
8000a2da:	99 ba       	st.w	r12[0x2c],r10
8000a2dc:	99 47       	st.w	r12[0x10],r7
8000a2de:	99 57       	st.w	r12[0x14],r7
8000a2e0:	99 8c       	st.w	r12[0x20],r12
8000a2e2:	d8 22       	popm	r4-r7,pc

8000a2e4 <_malloc_trim_r>:
8000a2e4:	d4 21       	pushm	r4-r7,lr
8000a2e6:	16 95       	mov	r5,r11
8000a2e8:	18 97       	mov	r7,r12
8000a2ea:	fe b0 d7 53 	rcall	80005190 <__malloc_lock>
8000a2ee:	e0 64 05 30 	mov	r4,1328
8000a2f2:	68 28       	ld.w	r8,r4[0x8]
8000a2f4:	70 16       	ld.w	r6,r8[0x4]
8000a2f6:	e0 16 ff fc 	andl	r6,0xfffc
8000a2fa:	ec c8 ff 91 	sub	r8,r6,-111
8000a2fe:	f0 05 01 05 	sub	r5,r8,r5
8000a302:	e0 15 ff 80 	andl	r5,0xff80
8000a306:	ea c5 00 80 	sub	r5,r5,128
8000a30a:	e0 45 00 7f 	cp.w	r5,127
8000a30e:	e0 8a 00 25 	brle	8000a358 <_malloc_trim_r+0x74>
8000a312:	30 0b       	mov	r11,0
8000a314:	0e 9c       	mov	r12,r7
8000a316:	fe b0 e5 f9 	rcall	80006f08 <_sbrk_r>
8000a31a:	68 28       	ld.w	r8,r4[0x8]
8000a31c:	0c 08       	add	r8,r6
8000a31e:	10 3c       	cp.w	r12,r8
8000a320:	c1 c1       	brne	8000a358 <_malloc_trim_r+0x74>
8000a322:	ea 0b 11 00 	rsub	r11,r5,0
8000a326:	0e 9c       	mov	r12,r7
8000a328:	fe b0 e5 f0 	rcall	80006f08 <_sbrk_r>
8000a32c:	5b fc       	cp.w	r12,-1
8000a32e:	c1 91       	brne	8000a360 <_malloc_trim_r+0x7c>
8000a330:	30 0b       	mov	r11,0
8000a332:	0e 9c       	mov	r12,r7
8000a334:	fe b0 e5 ea 	rcall	80006f08 <_sbrk_r>
8000a338:	68 28       	ld.w	r8,r4[0x8]
8000a33a:	f8 08 01 09 	sub	r9,r12,r8
8000a33e:	58 f9       	cp.w	r9,15
8000a340:	e0 8a 00 0c 	brle	8000a358 <_malloc_trim_r+0x74>
8000a344:	a1 a9       	sbr	r9,0x0
8000a346:	91 19       	st.w	r8[0x4],r9
8000a348:	e0 68 09 3c 	mov	r8,2364
8000a34c:	70 09       	ld.w	r9,r8[0x0]
8000a34e:	e0 68 0d 64 	mov	r8,3428
8000a352:	f8 09 01 09 	sub	r9,r12,r9
8000a356:	91 09       	st.w	r8[0x0],r9
8000a358:	0e 9c       	mov	r12,r7
8000a35a:	fe b0 d7 21 	rcall	8000519c <__malloc_unlock>
8000a35e:	d8 2a       	popm	r4-r7,pc,r12=0
8000a360:	68 28       	ld.w	r8,r4[0x8]
8000a362:	0a 16       	sub	r6,r5
8000a364:	a1 a6       	sbr	r6,0x0
8000a366:	91 16       	st.w	r8[0x4],r6
8000a368:	e0 68 0d 64 	mov	r8,3428
8000a36c:	70 09       	ld.w	r9,r8[0x0]
8000a36e:	0a 19       	sub	r9,r5
8000a370:	0e 9c       	mov	r12,r7
8000a372:	91 09       	st.w	r8[0x0],r9
8000a374:	fe b0 d7 14 	rcall	8000519c <__malloc_unlock>
8000a378:	da 2a       	popm	r4-r7,pc,r12=1
8000a37a:	d7 03       	nop

8000a37c <_free_r>:
8000a37c:	d4 21       	pushm	r4-r7,lr
8000a37e:	16 96       	mov	r6,r11
8000a380:	18 97       	mov	r7,r12
8000a382:	58 0b       	cp.w	r11,0
8000a384:	e0 80 00 c0 	breq	8000a504 <_free_r+0x188>
8000a388:	fe b0 d7 04 	rcall	80005190 <__malloc_lock>
8000a38c:	20 86       	sub	r6,8
8000a38e:	e0 6a 05 30 	mov	r10,1328
8000a392:	6c 18       	ld.w	r8,r6[0x4]
8000a394:	74 2e       	ld.w	lr,r10[0x8]
8000a396:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a39a:	a1 c8       	cbr	r8,0x0
8000a39c:	ec 08 00 09 	add	r9,r6,r8
8000a3a0:	72 1b       	ld.w	r11,r9[0x4]
8000a3a2:	e0 1b ff fc 	andl	r11,0xfffc
8000a3a6:	1c 39       	cp.w	r9,lr
8000a3a8:	c1 e1       	brne	8000a3e4 <_free_r+0x68>
8000a3aa:	f6 08 00 08 	add	r8,r11,r8
8000a3ae:	58 0c       	cp.w	r12,0
8000a3b0:	c0 81       	brne	8000a3c0 <_free_r+0x44>
8000a3b2:	6c 09       	ld.w	r9,r6[0x0]
8000a3b4:	12 16       	sub	r6,r9
8000a3b6:	12 08       	add	r8,r9
8000a3b8:	6c 3b       	ld.w	r11,r6[0xc]
8000a3ba:	6c 29       	ld.w	r9,r6[0x8]
8000a3bc:	97 29       	st.w	r11[0x8],r9
8000a3be:	93 3b       	st.w	r9[0xc],r11
8000a3c0:	10 99       	mov	r9,r8
8000a3c2:	95 26       	st.w	r10[0x8],r6
8000a3c4:	a1 a9       	sbr	r9,0x0
8000a3c6:	8d 19       	st.w	r6[0x4],r9
8000a3c8:	e0 69 09 38 	mov	r9,2360
8000a3cc:	72 09       	ld.w	r9,r9[0x0]
8000a3ce:	12 38       	cp.w	r8,r9
8000a3d0:	c0 63       	brcs	8000a3dc <_free_r+0x60>
8000a3d2:	e0 68 0d 60 	mov	r8,3424
8000a3d6:	0e 9c       	mov	r12,r7
8000a3d8:	70 0b       	ld.w	r11,r8[0x0]
8000a3da:	c8 5f       	rcall	8000a2e4 <_malloc_trim_r>
8000a3dc:	0e 9c       	mov	r12,r7
8000a3de:	fe b0 d6 df 	rcall	8000519c <__malloc_unlock>
8000a3e2:	d8 22       	popm	r4-r7,pc
8000a3e4:	93 1b       	st.w	r9[0x4],r11
8000a3e6:	58 0c       	cp.w	r12,0
8000a3e8:	c0 30       	breq	8000a3ee <_free_r+0x72>
8000a3ea:	30 0c       	mov	r12,0
8000a3ec:	c1 08       	rjmp	8000a40c <_free_r+0x90>
8000a3ee:	6c 0e       	ld.w	lr,r6[0x0]
8000a3f0:	f4 c5 ff f8 	sub	r5,r10,-8
8000a3f4:	1c 16       	sub	r6,lr
8000a3f6:	1c 08       	add	r8,lr
8000a3f8:	6c 2e       	ld.w	lr,r6[0x8]
8000a3fa:	0a 3e       	cp.w	lr,r5
8000a3fc:	f9 bc 00 01 	moveq	r12,1
8000a400:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a404:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a408:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a40c:	f2 0b 00 0e 	add	lr,r9,r11
8000a410:	7c 1e       	ld.w	lr,lr[0x4]
8000a412:	ed be 00 00 	bld	lr,0x0
8000a416:	c1 40       	breq	8000a43e <_free_r+0xc2>
8000a418:	16 08       	add	r8,r11
8000a41a:	58 0c       	cp.w	r12,0
8000a41c:	c0 d1       	brne	8000a436 <_free_r+0xba>
8000a41e:	e0 6e 05 30 	mov	lr,1328
8000a422:	72 2b       	ld.w	r11,r9[0x8]
8000a424:	2f 8e       	sub	lr,-8
8000a426:	1c 3b       	cp.w	r11,lr
8000a428:	c0 71       	brne	8000a436 <_free_r+0xba>
8000a42a:	97 36       	st.w	r11[0xc],r6
8000a42c:	97 26       	st.w	r11[0x8],r6
8000a42e:	8d 2b       	st.w	r6[0x8],r11
8000a430:	8d 3b       	st.w	r6[0xc],r11
8000a432:	30 1c       	mov	r12,1
8000a434:	c0 58       	rjmp	8000a43e <_free_r+0xc2>
8000a436:	72 2b       	ld.w	r11,r9[0x8]
8000a438:	72 39       	ld.w	r9,r9[0xc]
8000a43a:	93 2b       	st.w	r9[0x8],r11
8000a43c:	97 39       	st.w	r11[0xc],r9
8000a43e:	10 99       	mov	r9,r8
8000a440:	ec 08 09 08 	st.w	r6[r8],r8
8000a444:	a1 a9       	sbr	r9,0x0
8000a446:	8d 19       	st.w	r6[0x4],r9
8000a448:	58 0c       	cp.w	r12,0
8000a44a:	c5 a1       	brne	8000a4fe <_free_r+0x182>
8000a44c:	e0 48 01 ff 	cp.w	r8,511
8000a450:	e0 8b 00 13 	brhi	8000a476 <_free_r+0xfa>
8000a454:	a3 98       	lsr	r8,0x3
8000a456:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a45a:	72 2b       	ld.w	r11,r9[0x8]
8000a45c:	8d 39       	st.w	r6[0xc],r9
8000a45e:	8d 2b       	st.w	r6[0x8],r11
8000a460:	97 36       	st.w	r11[0xc],r6
8000a462:	93 26       	st.w	r9[0x8],r6
8000a464:	a3 48       	asr	r8,0x2
8000a466:	74 19       	ld.w	r9,r10[0x4]
8000a468:	30 1b       	mov	r11,1
8000a46a:	f6 08 09 48 	lsl	r8,r11,r8
8000a46e:	f3 e8 10 08 	or	r8,r9,r8
8000a472:	95 18       	st.w	r10[0x4],r8
8000a474:	c4 58       	rjmp	8000a4fe <_free_r+0x182>
8000a476:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a47a:	58 4b       	cp.w	r11,4
8000a47c:	e0 8b 00 06 	brhi	8000a488 <_free_r+0x10c>
8000a480:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a484:	2c 8b       	sub	r11,-56
8000a486:	c2 08       	rjmp	8000a4c6 <_free_r+0x14a>
8000a488:	59 4b       	cp.w	r11,20
8000a48a:	e0 8b 00 04 	brhi	8000a492 <_free_r+0x116>
8000a48e:	2a 5b       	sub	r11,-91
8000a490:	c1 b8       	rjmp	8000a4c6 <_free_r+0x14a>
8000a492:	e0 4b 00 54 	cp.w	r11,84
8000a496:	e0 8b 00 06 	brhi	8000a4a2 <_free_r+0x126>
8000a49a:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a49e:	29 2b       	sub	r11,-110
8000a4a0:	c1 38       	rjmp	8000a4c6 <_free_r+0x14a>
8000a4a2:	e0 4b 01 54 	cp.w	r11,340
8000a4a6:	e0 8b 00 06 	brhi	8000a4b2 <_free_r+0x136>
8000a4aa:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a4ae:	28 9b       	sub	r11,-119
8000a4b0:	c0 b8       	rjmp	8000a4c6 <_free_r+0x14a>
8000a4b2:	e0 4b 05 54 	cp.w	r11,1364
8000a4b6:	e0 88 00 05 	brls	8000a4c0 <_free_r+0x144>
8000a4ba:	37 eb       	mov	r11,126
8000a4bc:	c0 58       	rjmp	8000a4c6 <_free_r+0x14a>
8000a4be:	d7 03       	nop
8000a4c0:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a4c4:	28 4b       	sub	r11,-124
8000a4c6:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a4ca:	78 29       	ld.w	r9,r12[0x8]
8000a4cc:	18 39       	cp.w	r9,r12
8000a4ce:	c0 e1       	brne	8000a4ea <_free_r+0x16e>
8000a4d0:	74 18       	ld.w	r8,r10[0x4]
8000a4d2:	a3 4b       	asr	r11,0x2
8000a4d4:	30 1c       	mov	r12,1
8000a4d6:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a4da:	f1 eb 10 0b 	or	r11,r8,r11
8000a4de:	12 98       	mov	r8,r9
8000a4e0:	95 1b       	st.w	r10[0x4],r11
8000a4e2:	c0 a8       	rjmp	8000a4f6 <_free_r+0x17a>
8000a4e4:	72 29       	ld.w	r9,r9[0x8]
8000a4e6:	18 39       	cp.w	r9,r12
8000a4e8:	c0 60       	breq	8000a4f4 <_free_r+0x178>
8000a4ea:	72 1a       	ld.w	r10,r9[0x4]
8000a4ec:	e0 1a ff fc 	andl	r10,0xfffc
8000a4f0:	14 38       	cp.w	r8,r10
8000a4f2:	cf 93       	brcs	8000a4e4 <_free_r+0x168>
8000a4f4:	72 38       	ld.w	r8,r9[0xc]
8000a4f6:	8d 38       	st.w	r6[0xc],r8
8000a4f8:	8d 29       	st.w	r6[0x8],r9
8000a4fa:	93 36       	st.w	r9[0xc],r6
8000a4fc:	91 26       	st.w	r8[0x8],r6
8000a4fe:	0e 9c       	mov	r12,r7
8000a500:	fe b0 d6 4e 	rcall	8000519c <__malloc_unlock>
8000a504:	d8 22       	popm	r4-r7,pc
8000a506:	d7 03       	nop

8000a508 <__sfvwrite_r>:
8000a508:	d4 31       	pushm	r0-r7,lr
8000a50a:	20 3d       	sub	sp,12
8000a50c:	14 94       	mov	r4,r10
8000a50e:	18 95       	mov	r5,r12
8000a510:	16 97       	mov	r7,r11
8000a512:	74 28       	ld.w	r8,r10[0x8]
8000a514:	58 08       	cp.w	r8,0
8000a516:	e0 80 01 40 	breq	8000a796 <__sfvwrite_r+0x28e>
8000a51a:	96 68       	ld.sh	r8,r11[0xc]
8000a51c:	ed b8 00 03 	bld	r8,0x3
8000a520:	c0 41       	brne	8000a528 <__sfvwrite_r+0x20>
8000a522:	76 48       	ld.w	r8,r11[0x10]
8000a524:	58 08       	cp.w	r8,0
8000a526:	c0 c1       	brne	8000a53e <__sfvwrite_r+0x36>
8000a528:	0e 9b       	mov	r11,r7
8000a52a:	0a 9c       	mov	r12,r5
8000a52c:	fe b0 f6 c4 	rcall	800092b4 <__swsetup_r>
8000a530:	c0 70       	breq	8000a53e <__sfvwrite_r+0x36>
8000a532:	8e 68       	ld.sh	r8,r7[0xc]
8000a534:	a7 a8       	sbr	r8,0x6
8000a536:	ae 68       	st.h	r7[0xc],r8
8000a538:	30 98       	mov	r8,9
8000a53a:	8b 38       	st.w	r5[0xc],r8
8000a53c:	c2 b9       	rjmp	8000a792 <__sfvwrite_r+0x28a>
8000a53e:	8e 63       	ld.sh	r3,r7[0xc]
8000a540:	68 00       	ld.w	r0,r4[0x0]
8000a542:	06 96       	mov	r6,r3
8000a544:	e2 16 00 02 	andl	r6,0x2,COH
8000a548:	c2 10       	breq	8000a58a <__sfvwrite_r+0x82>
8000a54a:	30 03       	mov	r3,0
8000a54c:	e0 62 04 00 	mov	r2,1024
8000a550:	06 96       	mov	r6,r3
8000a552:	c0 48       	rjmp	8000a55a <__sfvwrite_r+0x52>
8000a554:	60 03       	ld.w	r3,r0[0x0]
8000a556:	60 16       	ld.w	r6,r0[0x4]
8000a558:	2f 80       	sub	r0,-8
8000a55a:	58 06       	cp.w	r6,0
8000a55c:	cf c0       	breq	8000a554 <__sfvwrite_r+0x4c>
8000a55e:	e0 46 04 00 	cp.w	r6,1024
8000a562:	ec 09 17 80 	movls	r9,r6
8000a566:	e4 09 17 b0 	movhi	r9,r2
8000a56a:	06 9a       	mov	r10,r3
8000a56c:	6e a8       	ld.w	r8,r7[0x28]
8000a56e:	6e 8b       	ld.w	r11,r7[0x20]
8000a570:	0a 9c       	mov	r12,r5
8000a572:	5d 18       	icall	r8
8000a574:	18 16       	sub	r6,r12
8000a576:	58 0c       	cp.w	r12,0
8000a578:	e0 8a 01 0a 	brle	8000a78c <__sfvwrite_r+0x284>
8000a57c:	68 28       	ld.w	r8,r4[0x8]
8000a57e:	18 18       	sub	r8,r12
8000a580:	89 28       	st.w	r4[0x8],r8
8000a582:	e0 80 01 0a 	breq	8000a796 <__sfvwrite_r+0x28e>
8000a586:	18 03       	add	r3,r12
8000a588:	ce 9b       	rjmp	8000a55a <__sfvwrite_r+0x52>
8000a58a:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000a58e:	c0 70       	breq	8000a59c <__sfvwrite_r+0x94>
8000a590:	50 06       	stdsp	sp[0x0],r6
8000a592:	0c 93       	mov	r3,r6
8000a594:	0c 91       	mov	r1,r6
8000a596:	50 15       	stdsp	sp[0x4],r5
8000a598:	08 92       	mov	r2,r4
8000a59a:	c9 c8       	rjmp	8000a6d2 <__sfvwrite_r+0x1ca>
8000a59c:	06 96       	mov	r6,r3
8000a59e:	08 91       	mov	r1,r4
8000a5a0:	c0 48       	rjmp	8000a5a8 <__sfvwrite_r+0xa0>
8000a5a2:	60 03       	ld.w	r3,r0[0x0]
8000a5a4:	60 16       	ld.w	r6,r0[0x4]
8000a5a6:	2f 80       	sub	r0,-8
8000a5a8:	58 06       	cp.w	r6,0
8000a5aa:	cf c0       	breq	8000a5a2 <__sfvwrite_r+0x9a>
8000a5ac:	8e 68       	ld.sh	r8,r7[0xc]
8000a5ae:	6e 24       	ld.w	r4,r7[0x8]
8000a5b0:	10 99       	mov	r9,r8
8000a5b2:	e2 19 02 00 	andl	r9,0x200,COH
8000a5b6:	c5 50       	breq	8000a660 <__sfvwrite_r+0x158>
8000a5b8:	08 36       	cp.w	r6,r4
8000a5ba:	c4 43       	brcs	8000a642 <__sfvwrite_r+0x13a>
8000a5bc:	10 99       	mov	r9,r8
8000a5be:	e2 19 04 80 	andl	r9,0x480,COH
8000a5c2:	c4 00       	breq	8000a642 <__sfvwrite_r+0x13a>
8000a5c4:	6e 4b       	ld.w	r11,r7[0x10]
8000a5c6:	6e 09       	ld.w	r9,r7[0x0]
8000a5c8:	16 19       	sub	r9,r11
8000a5ca:	50 09       	stdsp	sp[0x0],r9
8000a5cc:	6e 59       	ld.w	r9,r7[0x14]
8000a5ce:	10 9c       	mov	r12,r8
8000a5d0:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000a5d4:	30 28       	mov	r8,2
8000a5d6:	f4 08 0c 08 	divs	r8,r10,r8
8000a5da:	fa e9 00 04 	st.d	sp[4],r8
8000a5de:	10 94       	mov	r4,r8
8000a5e0:	40 09       	lddsp	r9,sp[0x0]
8000a5e2:	e2 1c 04 00 	andl	r12,0x400,COH
8000a5e6:	2f f9       	sub	r9,-1
8000a5e8:	0c 09       	add	r9,r6
8000a5ea:	12 38       	cp.w	r8,r9
8000a5ec:	f2 04 17 30 	movlo	r4,r9
8000a5f0:	58 0c       	cp.w	r12,0
8000a5f2:	c1 10       	breq	8000a614 <__sfvwrite_r+0x10c>
8000a5f4:	08 9b       	mov	r11,r4
8000a5f6:	0a 9c       	mov	r12,r5
8000a5f8:	fe b0 e0 60 	rcall	800066b8 <_malloc_r>
8000a5fc:	18 92       	mov	r2,r12
8000a5fe:	c1 40       	breq	8000a626 <__sfvwrite_r+0x11e>
8000a600:	40 0a       	lddsp	r10,sp[0x0]
8000a602:	6e 4b       	ld.w	r11,r7[0x10]
8000a604:	fe b0 e2 76 	rcall	80006af0 <memcpy>
8000a608:	8e 68       	ld.sh	r8,r7[0xc]
8000a60a:	e0 18 fb 7f 	andl	r8,0xfb7f
8000a60e:	a7 b8       	sbr	r8,0x7
8000a610:	ae 68       	st.h	r7[0xc],r8
8000a612:	c0 d8       	rjmp	8000a62c <__sfvwrite_r+0x124>
8000a614:	08 9a       	mov	r10,r4
8000a616:	0a 9c       	mov	r12,r5
8000a618:	fe b0 e3 18 	rcall	80006c48 <_realloc_r>
8000a61c:	18 92       	mov	r2,r12
8000a61e:	c0 71       	brne	8000a62c <__sfvwrite_r+0x124>
8000a620:	6e 4b       	ld.w	r11,r7[0x10]
8000a622:	0a 9c       	mov	r12,r5
8000a624:	ca ce       	rcall	8000a37c <_free_r>
8000a626:	30 c8       	mov	r8,12
8000a628:	8b 38       	st.w	r5[0xc],r8
8000a62a:	cb 18       	rjmp	8000a78c <__sfvwrite_r+0x284>
8000a62c:	40 0a       	lddsp	r10,sp[0x0]
8000a62e:	40 09       	lddsp	r9,sp[0x0]
8000a630:	e8 0a 01 0a 	sub	r10,r4,r10
8000a634:	e4 09 00 08 	add	r8,r2,r9
8000a638:	8f 54       	st.w	r7[0x14],r4
8000a63a:	8f 2a       	st.w	r7[0x8],r10
8000a63c:	8f 08       	st.w	r7[0x0],r8
8000a63e:	8f 42       	st.w	r7[0x10],r2
8000a640:	0c 94       	mov	r4,r6
8000a642:	08 36       	cp.w	r6,r4
8000a644:	ec 04 17 30 	movlo	r4,r6
8000a648:	06 9b       	mov	r11,r3
8000a64a:	08 9a       	mov	r10,r4
8000a64c:	6e 0c       	ld.w	r12,r7[0x0]
8000a64e:	c3 ad       	rcall	8000a8c2 <memmove>
8000a650:	6e 08       	ld.w	r8,r7[0x0]
8000a652:	08 08       	add	r8,r4
8000a654:	8f 08       	st.w	r7[0x0],r8
8000a656:	6e 28       	ld.w	r8,r7[0x8]
8000a658:	08 18       	sub	r8,r4
8000a65a:	0c 94       	mov	r4,r6
8000a65c:	8f 28       	st.w	r7[0x8],r8
8000a65e:	c2 e8       	rjmp	8000a6ba <__sfvwrite_r+0x1b2>
8000a660:	08 36       	cp.w	r6,r4
8000a662:	5f ba       	srhi	r10
8000a664:	6e 0c       	ld.w	r12,r7[0x0]
8000a666:	6e 48       	ld.w	r8,r7[0x10]
8000a668:	10 3c       	cp.w	r12,r8
8000a66a:	5f b8       	srhi	r8
8000a66c:	f5 e8 00 08 	and	r8,r10,r8
8000a670:	f2 08 18 00 	cp.b	r8,r9
8000a674:	c0 d0       	breq	8000a68e <__sfvwrite_r+0x186>
8000a676:	06 9b       	mov	r11,r3
8000a678:	08 9a       	mov	r10,r4
8000a67a:	c2 4d       	rcall	8000a8c2 <memmove>
8000a67c:	6e 08       	ld.w	r8,r7[0x0]
8000a67e:	08 08       	add	r8,r4
8000a680:	0e 9b       	mov	r11,r7
8000a682:	8f 08       	st.w	r7[0x0],r8
8000a684:	0a 9c       	mov	r12,r5
8000a686:	fe b0 fd 09 	rcall	8000a098 <_fflush_r>
8000a68a:	c1 80       	breq	8000a6ba <__sfvwrite_r+0x1b2>
8000a68c:	c8 08       	rjmp	8000a78c <__sfvwrite_r+0x284>
8000a68e:	6e 59       	ld.w	r9,r7[0x14]
8000a690:	12 36       	cp.w	r6,r9
8000a692:	c0 a3       	brcs	8000a6a6 <__sfvwrite_r+0x19e>
8000a694:	6e a8       	ld.w	r8,r7[0x28]
8000a696:	06 9a       	mov	r10,r3
8000a698:	6e 8b       	ld.w	r11,r7[0x20]
8000a69a:	0a 9c       	mov	r12,r5
8000a69c:	5d 18       	icall	r8
8000a69e:	18 94       	mov	r4,r12
8000a6a0:	e0 89 00 0d 	brgt	8000a6ba <__sfvwrite_r+0x1b2>
8000a6a4:	c7 48       	rjmp	8000a78c <__sfvwrite_r+0x284>
8000a6a6:	0c 9a       	mov	r10,r6
8000a6a8:	06 9b       	mov	r11,r3
8000a6aa:	c0 cd       	rcall	8000a8c2 <memmove>
8000a6ac:	6e 08       	ld.w	r8,r7[0x0]
8000a6ae:	0c 08       	add	r8,r6
8000a6b0:	0c 94       	mov	r4,r6
8000a6b2:	8f 08       	st.w	r7[0x0],r8
8000a6b4:	6e 28       	ld.w	r8,r7[0x8]
8000a6b6:	0c 18       	sub	r8,r6
8000a6b8:	8f 28       	st.w	r7[0x8],r8
8000a6ba:	62 28       	ld.w	r8,r1[0x8]
8000a6bc:	08 18       	sub	r8,r4
8000a6be:	83 28       	st.w	r1[0x8],r8
8000a6c0:	c6 b0       	breq	8000a796 <__sfvwrite_r+0x28e>
8000a6c2:	08 16       	sub	r6,r4
8000a6c4:	08 03       	add	r3,r4
8000a6c6:	c7 1b       	rjmp	8000a5a8 <__sfvwrite_r+0xa0>
8000a6c8:	60 03       	ld.w	r3,r0[0x0]
8000a6ca:	60 11       	ld.w	r1,r0[0x4]
8000a6cc:	30 08       	mov	r8,0
8000a6ce:	2f 80       	sub	r0,-8
8000a6d0:	50 08       	stdsp	sp[0x0],r8
8000a6d2:	58 01       	cp.w	r1,0
8000a6d4:	cf a0       	breq	8000a6c8 <__sfvwrite_r+0x1c0>
8000a6d6:	40 0a       	lddsp	r10,sp[0x0]
8000a6d8:	58 0a       	cp.w	r10,0
8000a6da:	c1 41       	brne	8000a702 <__sfvwrite_r+0x1fa>
8000a6dc:	e2 c6 ff ff 	sub	r6,r1,-1
8000a6e0:	02 9a       	mov	r10,r1
8000a6e2:	30 ab       	mov	r11,10
8000a6e4:	06 9c       	mov	r12,r3
8000a6e6:	ce 3c       	rcall	8000a8ac <memchr>
8000a6e8:	f8 c8 ff ff 	sub	r8,r12,-1
8000a6ec:	58 0c       	cp.w	r12,0
8000a6ee:	f1 d3 e1 16 	subne	r6,r8,r3
8000a6f2:	f9 b9 01 01 	movne	r9,1
8000a6f6:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a6fa:	f9 b8 00 01 	moveq	r8,1
8000a6fe:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000a702:	02 36       	cp.w	r6,r1
8000a704:	ec 04 17 80 	movls	r4,r6
8000a708:	e2 04 17 b0 	movhi	r4,r1
8000a70c:	6e 59       	ld.w	r9,r7[0x14]
8000a70e:	6e 25       	ld.w	r5,r7[0x8]
8000a710:	f2 05 00 05 	add	r5,r9,r5
8000a714:	0a 34       	cp.w	r4,r5
8000a716:	5f 9a       	srgt	r10
8000a718:	6e 0c       	ld.w	r12,r7[0x0]
8000a71a:	6e 48       	ld.w	r8,r7[0x10]
8000a71c:	10 3c       	cp.w	r12,r8
8000a71e:	5f b8       	srhi	r8
8000a720:	f5 e8 00 08 	and	r8,r10,r8
8000a724:	30 0a       	mov	r10,0
8000a726:	f4 08 18 00 	cp.b	r8,r10
8000a72a:	c0 d0       	breq	8000a744 <__sfvwrite_r+0x23c>
8000a72c:	06 9b       	mov	r11,r3
8000a72e:	0a 9a       	mov	r10,r5
8000a730:	cc 9c       	rcall	8000a8c2 <memmove>
8000a732:	6e 08       	ld.w	r8,r7[0x0]
8000a734:	0a 08       	add	r8,r5
8000a736:	0e 9b       	mov	r11,r7
8000a738:	8f 08       	st.w	r7[0x0],r8
8000a73a:	40 1c       	lddsp	r12,sp[0x4]
8000a73c:	fe b0 fc ae 	rcall	8000a098 <_fflush_r>
8000a740:	c1 70       	breq	8000a76e <__sfvwrite_r+0x266>
8000a742:	c2 58       	rjmp	8000a78c <__sfvwrite_r+0x284>
8000a744:	12 34       	cp.w	r4,r9
8000a746:	c0 a5       	brlt	8000a75a <__sfvwrite_r+0x252>
8000a748:	6e a8       	ld.w	r8,r7[0x28]
8000a74a:	06 9a       	mov	r10,r3
8000a74c:	6e 8b       	ld.w	r11,r7[0x20]
8000a74e:	40 1c       	lddsp	r12,sp[0x4]
8000a750:	5d 18       	icall	r8
8000a752:	18 95       	mov	r5,r12
8000a754:	e0 89 00 0d 	brgt	8000a76e <__sfvwrite_r+0x266>
8000a758:	c1 a8       	rjmp	8000a78c <__sfvwrite_r+0x284>
8000a75a:	08 9a       	mov	r10,r4
8000a75c:	06 9b       	mov	r11,r3
8000a75e:	cb 2c       	rcall	8000a8c2 <memmove>
8000a760:	6e 08       	ld.w	r8,r7[0x0]
8000a762:	08 08       	add	r8,r4
8000a764:	08 95       	mov	r5,r4
8000a766:	8f 08       	st.w	r7[0x0],r8
8000a768:	6e 28       	ld.w	r8,r7[0x8]
8000a76a:	08 18       	sub	r8,r4
8000a76c:	8f 28       	st.w	r7[0x8],r8
8000a76e:	0a 16       	sub	r6,r5
8000a770:	c0 71       	brne	8000a77e <__sfvwrite_r+0x276>
8000a772:	0e 9b       	mov	r11,r7
8000a774:	40 1c       	lddsp	r12,sp[0x4]
8000a776:	fe b0 fc 91 	rcall	8000a098 <_fflush_r>
8000a77a:	c0 91       	brne	8000a78c <__sfvwrite_r+0x284>
8000a77c:	50 06       	stdsp	sp[0x0],r6
8000a77e:	64 28       	ld.w	r8,r2[0x8]
8000a780:	0a 18       	sub	r8,r5
8000a782:	85 28       	st.w	r2[0x8],r8
8000a784:	c0 90       	breq	8000a796 <__sfvwrite_r+0x28e>
8000a786:	0a 11       	sub	r1,r5
8000a788:	0a 03       	add	r3,r5
8000a78a:	ca 4b       	rjmp	8000a6d2 <__sfvwrite_r+0x1ca>
8000a78c:	8e 68       	ld.sh	r8,r7[0xc]
8000a78e:	a7 a8       	sbr	r8,0x6
8000a790:	ae 68       	st.h	r7[0xc],r8
8000a792:	3f fc       	mov	r12,-1
8000a794:	c0 28       	rjmp	8000a798 <__sfvwrite_r+0x290>
8000a796:	30 0c       	mov	r12,0
8000a798:	2f dd       	sub	sp,-12
8000a79a:	d8 32       	popm	r0-r7,pc

8000a79c <_fwalk>:
8000a79c:	d4 31       	pushm	r0-r7,lr
8000a79e:	30 05       	mov	r5,0
8000a7a0:	16 91       	mov	r1,r11
8000a7a2:	f8 c7 ff 28 	sub	r7,r12,-216
8000a7a6:	0a 92       	mov	r2,r5
8000a7a8:	fe b0 fc fe 	rcall	8000a1a4 <__sfp_lock_acquire>
8000a7ac:	3f f3       	mov	r3,-1
8000a7ae:	c1 68       	rjmp	8000a7da <_fwalk+0x3e>
8000a7b0:	6e 26       	ld.w	r6,r7[0x8]
8000a7b2:	6e 14       	ld.w	r4,r7[0x4]
8000a7b4:	2f 46       	sub	r6,-12
8000a7b6:	c0 c8       	rjmp	8000a7ce <_fwalk+0x32>
8000a7b8:	8c 08       	ld.sh	r8,r6[0x0]
8000a7ba:	e4 08 19 00 	cp.h	r8,r2
8000a7be:	c0 70       	breq	8000a7cc <_fwalk+0x30>
8000a7c0:	8c 18       	ld.sh	r8,r6[0x2]
8000a7c2:	e6 08 19 00 	cp.h	r8,r3
8000a7c6:	c0 30       	breq	8000a7cc <_fwalk+0x30>
8000a7c8:	5d 11       	icall	r1
8000a7ca:	18 45       	or	r5,r12
8000a7cc:	2a 46       	sub	r6,-92
8000a7ce:	20 14       	sub	r4,1
8000a7d0:	ec cc 00 0c 	sub	r12,r6,12
8000a7d4:	58 04       	cp.w	r4,0
8000a7d6:	cf 14       	brge	8000a7b8 <_fwalk+0x1c>
8000a7d8:	6e 07       	ld.w	r7,r7[0x0]
8000a7da:	58 07       	cp.w	r7,0
8000a7dc:	ce a1       	brne	8000a7b0 <_fwalk+0x14>
8000a7de:	fe b0 fc e4 	rcall	8000a1a6 <__sfp_lock_release>
8000a7e2:	0a 9c       	mov	r12,r5
8000a7e4:	d8 32       	popm	r0-r7,pc
8000a7e6:	d7 03       	nop

8000a7e8 <_localeconv_r>:
8000a7e8:	fe cc cf 84 	sub	r12,pc,-12412
8000a7ec:	5e fc       	retal	r12
8000a7ee:	d7 03       	nop

8000a7f0 <__smakebuf_r>:
8000a7f0:	d4 21       	pushm	r4-r7,lr
8000a7f2:	20 fd       	sub	sp,60
8000a7f4:	96 68       	ld.sh	r8,r11[0xc]
8000a7f6:	16 97       	mov	r7,r11
8000a7f8:	18 96       	mov	r6,r12
8000a7fa:	e2 18 00 02 	andl	r8,0x2,COH
8000a7fe:	c3 d1       	brne	8000a878 <__smakebuf_r+0x88>
8000a800:	96 7b       	ld.sh	r11,r11[0xe]
8000a802:	f0 0b 19 00 	cp.h	r11,r8
8000a806:	c0 55       	brlt	8000a810 <__smakebuf_r+0x20>
8000a808:	1a 9a       	mov	r10,sp
8000a80a:	e0 a0 04 75 	rcall	8000b0f4 <_fstat_r>
8000a80e:	c0 f4       	brge	8000a82c <__smakebuf_r+0x3c>
8000a810:	8e 65       	ld.sh	r5,r7[0xc]
8000a812:	0a 98       	mov	r8,r5
8000a814:	ab b8       	sbr	r8,0xb
8000a816:	e2 15 00 80 	andl	r5,0x80,COH
8000a81a:	ae 68       	st.h	r7[0xc],r8
8000a81c:	30 04       	mov	r4,0
8000a81e:	e0 68 04 00 	mov	r8,1024
8000a822:	f9 b5 01 40 	movne	r5,64
8000a826:	f0 05 17 00 	moveq	r5,r8
8000a82a:	c1 c8       	rjmp	8000a862 <__smakebuf_r+0x72>
8000a82c:	40 18       	lddsp	r8,sp[0x4]
8000a82e:	e2 18 f0 00 	andl	r8,0xf000,COH
8000a832:	e0 48 20 00 	cp.w	r8,8192
8000a836:	5f 04       	sreq	r4
8000a838:	e0 48 80 00 	cp.w	r8,32768
8000a83c:	c0 e1       	brne	8000a858 <__smakebuf_r+0x68>
8000a83e:	6e b9       	ld.w	r9,r7[0x2c]
8000a840:	fe c8 f9 1c 	sub	r8,pc,-1764
8000a844:	10 39       	cp.w	r9,r8
8000a846:	c0 91       	brne	8000a858 <__smakebuf_r+0x68>
8000a848:	8e 68       	ld.sh	r8,r7[0xc]
8000a84a:	e0 65 04 00 	mov	r5,1024
8000a84e:	ab a8       	sbr	r8,0xa
8000a850:	ef 45 00 50 	st.w	r7[80],r5
8000a854:	ae 68       	st.h	r7[0xc],r8
8000a856:	c0 68       	rjmp	8000a862 <__smakebuf_r+0x72>
8000a858:	8e 68       	ld.sh	r8,r7[0xc]
8000a85a:	e0 65 04 00 	mov	r5,1024
8000a85e:	ab b8       	sbr	r8,0xb
8000a860:	ae 68       	st.h	r7[0xc],r8
8000a862:	0a 9b       	mov	r11,r5
8000a864:	0c 9c       	mov	r12,r6
8000a866:	fe b0 df 29 	rcall	800066b8 <_malloc_r>
8000a86a:	8e 68       	ld.sh	r8,r7[0xc]
8000a86c:	c0 d1       	brne	8000a886 <__smakebuf_r+0x96>
8000a86e:	ed b8 00 09 	bld	r8,0x9
8000a872:	c1 b0       	breq	8000a8a8 <__smakebuf_r+0xb8>
8000a874:	a1 b8       	sbr	r8,0x1
8000a876:	ae 68       	st.h	r7[0xc],r8
8000a878:	ee c8 ff b9 	sub	r8,r7,-71
8000a87c:	8f 48       	st.w	r7[0x10],r8
8000a87e:	8f 08       	st.w	r7[0x0],r8
8000a880:	30 18       	mov	r8,1
8000a882:	8f 58       	st.w	r7[0x14],r8
8000a884:	c1 28       	rjmp	8000a8a8 <__smakebuf_r+0xb8>
8000a886:	a7 b8       	sbr	r8,0x7
8000a888:	8f 4c       	st.w	r7[0x10],r12
8000a88a:	ae 68       	st.h	r7[0xc],r8
8000a88c:	8f 55       	st.w	r7[0x14],r5
8000a88e:	fe c8 06 e6 	sub	r8,pc,1766
8000a892:	8f 0c       	st.w	r7[0x0],r12
8000a894:	8d a8       	st.w	r6[0x28],r8
8000a896:	58 04       	cp.w	r4,0
8000a898:	c0 80       	breq	8000a8a8 <__smakebuf_r+0xb8>
8000a89a:	8e 7c       	ld.sh	r12,r7[0xe]
8000a89c:	fe b0 e3 94 	rcall	80006fc4 <isatty>
8000a8a0:	c0 40       	breq	8000a8a8 <__smakebuf_r+0xb8>
8000a8a2:	8e 68       	ld.sh	r8,r7[0xc]
8000a8a4:	a1 a8       	sbr	r8,0x0
8000a8a6:	ae 68       	st.h	r7[0xc],r8
8000a8a8:	2f 1d       	sub	sp,-60
8000a8aa:	d8 22       	popm	r4-r7,pc

8000a8ac <memchr>:
8000a8ac:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000a8b0:	c0 68       	rjmp	8000a8bc <memchr+0x10>
8000a8b2:	20 1a       	sub	r10,1
8000a8b4:	19 88       	ld.ub	r8,r12[0x0]
8000a8b6:	16 38       	cp.w	r8,r11
8000a8b8:	5e 0c       	reteq	r12
8000a8ba:	2f fc       	sub	r12,-1
8000a8bc:	58 0a       	cp.w	r10,0
8000a8be:	cf a1       	brne	8000a8b2 <memchr+0x6>
8000a8c0:	5e fa       	retal	r10

8000a8c2 <memmove>:
8000a8c2:	d4 01       	pushm	lr
8000a8c4:	18 3b       	cp.w	r11,r12
8000a8c6:	c1 92       	brcc	8000a8f8 <memmove+0x36>
8000a8c8:	f6 0a 00 09 	add	r9,r11,r10
8000a8cc:	12 3c       	cp.w	r12,r9
8000a8ce:	c1 52       	brcc	8000a8f8 <memmove+0x36>
8000a8d0:	f8 0a 00 0b 	add	r11,r12,r10
8000a8d4:	30 08       	mov	r8,0
8000a8d6:	c0 68       	rjmp	8000a8e2 <memmove+0x20>
8000a8d8:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000a8dc:	20 1a       	sub	r10,1
8000a8de:	f6 08 0b 0e 	st.b	r11[r8],lr
8000a8e2:	20 18       	sub	r8,1
8000a8e4:	58 0a       	cp.w	r10,0
8000a8e6:	cf 91       	brne	8000a8d8 <memmove+0x16>
8000a8e8:	d8 02       	popm	pc
8000a8ea:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a8ee:	20 1a       	sub	r10,1
8000a8f0:	f8 08 0b 09 	st.b	r12[r8],r9
8000a8f4:	2f f8       	sub	r8,-1
8000a8f6:	c0 28       	rjmp	8000a8fa <memmove+0x38>
8000a8f8:	30 08       	mov	r8,0
8000a8fa:	58 0a       	cp.w	r10,0
8000a8fc:	cf 71       	brne	8000a8ea <memmove+0x28>
8000a8fe:	d8 02       	popm	pc

8000a900 <__hi0bits>:
8000a900:	18 98       	mov	r8,r12
8000a902:	e0 1c 00 00 	andl	r12,0x0
8000a906:	f0 09 15 10 	lsl	r9,r8,0x10
8000a90a:	58 0c       	cp.w	r12,0
8000a90c:	f2 08 17 00 	moveq	r8,r9
8000a910:	f9 bc 00 10 	moveq	r12,16
8000a914:	f9 bc 01 00 	movne	r12,0
8000a918:	10 9a       	mov	r10,r8
8000a91a:	f0 09 15 08 	lsl	r9,r8,0x8
8000a91e:	e6 1a ff 00 	andh	r10,0xff00,COH
8000a922:	f7 bc 00 f8 	subeq	r12,-8
8000a926:	f2 08 17 00 	moveq	r8,r9
8000a92a:	10 9a       	mov	r10,r8
8000a92c:	f0 09 15 04 	lsl	r9,r8,0x4
8000a930:	e6 1a f0 00 	andh	r10,0xf000,COH
8000a934:	f7 bc 00 fc 	subeq	r12,-4
8000a938:	f2 08 17 00 	moveq	r8,r9
8000a93c:	10 9a       	mov	r10,r8
8000a93e:	f0 09 15 02 	lsl	r9,r8,0x2
8000a942:	e6 1a c0 00 	andh	r10,0xc000,COH
8000a946:	f7 bc 00 fe 	subeq	r12,-2
8000a94a:	f2 08 17 00 	moveq	r8,r9
8000a94e:	58 08       	cp.w	r8,0
8000a950:	5e 5c       	retlt	r12
8000a952:	ed b8 00 1e 	bld	r8,0x1e
8000a956:	f9 bc 01 20 	movne	r12,32
8000a95a:	f7 bc 00 ff 	subeq	r12,-1
8000a95e:	5e fc       	retal	r12

8000a960 <__lo0bits>:
8000a960:	18 99       	mov	r9,r12
8000a962:	78 08       	ld.w	r8,r12[0x0]
8000a964:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000a968:	c1 50       	breq	8000a992 <__lo0bits+0x32>
8000a96a:	ed b8 00 00 	bld	r8,0x0
8000a96e:	c0 21       	brne	8000a972 <__lo0bits+0x12>
8000a970:	5e fd       	retal	0
8000a972:	10 9b       	mov	r11,r8
8000a974:	f0 0a 16 01 	lsr	r10,r8,0x1
8000a978:	e2 1b 00 02 	andl	r11,0x2,COH
8000a97c:	a3 88       	lsr	r8,0x2
8000a97e:	58 0b       	cp.w	r11,0
8000a980:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000a984:	f9 bc 01 01 	movne	r12,1
8000a988:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000a98c:	f9 bc 00 02 	moveq	r12,2
8000a990:	5e fc       	retal	r12
8000a992:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000a996:	f0 0b 16 10 	lsr	r11,r8,0x10
8000a99a:	58 0a       	cp.w	r10,0
8000a99c:	f6 08 17 00 	moveq	r8,r11
8000a9a0:	f9 bc 00 10 	moveq	r12,16
8000a9a4:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000a9a8:	f0 0a 16 08 	lsr	r10,r8,0x8
8000a9ac:	58 0b       	cp.w	r11,0
8000a9ae:	f7 bc 00 f8 	subeq	r12,-8
8000a9b2:	f4 08 17 00 	moveq	r8,r10
8000a9b6:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000a9ba:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a9be:	58 0b       	cp.w	r11,0
8000a9c0:	f7 bc 00 fc 	subeq	r12,-4
8000a9c4:	f4 08 17 00 	moveq	r8,r10
8000a9c8:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000a9cc:	f0 0a 16 02 	lsr	r10,r8,0x2
8000a9d0:	58 0b       	cp.w	r11,0
8000a9d2:	f7 bc 00 fe 	subeq	r12,-2
8000a9d6:	f4 08 17 00 	moveq	r8,r10
8000a9da:	ed b8 00 00 	bld	r8,0x0
8000a9de:	c0 60       	breq	8000a9ea <__lo0bits+0x8a>
8000a9e0:	a1 98       	lsr	r8,0x1
8000a9e2:	c0 31       	brne	8000a9e8 <__lo0bits+0x88>
8000a9e4:	32 0c       	mov	r12,32
8000a9e6:	5e fc       	retal	r12
8000a9e8:	2f fc       	sub	r12,-1
8000a9ea:	93 08       	st.w	r9[0x0],r8
8000a9ec:	5e fc       	retal	r12

8000a9ee <__mcmp>:
8000a9ee:	d4 01       	pushm	lr
8000a9f0:	18 98       	mov	r8,r12
8000a9f2:	76 49       	ld.w	r9,r11[0x10]
8000a9f4:	78 4c       	ld.w	r12,r12[0x10]
8000a9f6:	12 1c       	sub	r12,r9
8000a9f8:	c1 31       	brne	8000aa1e <__mcmp+0x30>
8000a9fa:	2f b9       	sub	r9,-5
8000a9fc:	a3 69       	lsl	r9,0x2
8000a9fe:	12 0b       	add	r11,r9
8000aa00:	f0 09 00 09 	add	r9,r8,r9
8000aa04:	2e c8       	sub	r8,-20
8000aa06:	13 4e       	ld.w	lr,--r9
8000aa08:	17 4a       	ld.w	r10,--r11
8000aa0a:	14 3e       	cp.w	lr,r10
8000aa0c:	c0 60       	breq	8000aa18 <__mcmp+0x2a>
8000aa0e:	f9 bc 03 ff 	movlo	r12,-1
8000aa12:	f9 bc 02 01 	movhs	r12,1
8000aa16:	d8 02       	popm	pc
8000aa18:	10 39       	cp.w	r9,r8
8000aa1a:	fe 9b ff f6 	brhi	8000aa06 <__mcmp+0x18>
8000aa1e:	d8 02       	popm	pc

8000aa20 <_Bfree>:
8000aa20:	d4 21       	pushm	r4-r7,lr
8000aa22:	18 97       	mov	r7,r12
8000aa24:	16 95       	mov	r5,r11
8000aa26:	78 96       	ld.w	r6,r12[0x24]
8000aa28:	58 06       	cp.w	r6,0
8000aa2a:	c0 91       	brne	8000aa3c <_Bfree+0x1c>
8000aa2c:	31 0c       	mov	r12,16
8000aa2e:	fe b0 de 3d 	rcall	800066a8 <malloc>
8000aa32:	99 36       	st.w	r12[0xc],r6
8000aa34:	8f 9c       	st.w	r7[0x24],r12
8000aa36:	99 16       	st.w	r12[0x4],r6
8000aa38:	99 26       	st.w	r12[0x8],r6
8000aa3a:	99 06       	st.w	r12[0x0],r6
8000aa3c:	58 05       	cp.w	r5,0
8000aa3e:	c0 90       	breq	8000aa50 <_Bfree+0x30>
8000aa40:	6a 19       	ld.w	r9,r5[0x4]
8000aa42:	6e 98       	ld.w	r8,r7[0x24]
8000aa44:	70 38       	ld.w	r8,r8[0xc]
8000aa46:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000aa4a:	8b 0a       	st.w	r5[0x0],r10
8000aa4c:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000aa50:	d8 22       	popm	r4-r7,pc
8000aa52:	d7 03       	nop

8000aa54 <_Balloc>:
8000aa54:	d4 21       	pushm	r4-r7,lr
8000aa56:	18 97       	mov	r7,r12
8000aa58:	16 96       	mov	r6,r11
8000aa5a:	78 95       	ld.w	r5,r12[0x24]
8000aa5c:	58 05       	cp.w	r5,0
8000aa5e:	c0 91       	brne	8000aa70 <_Balloc+0x1c>
8000aa60:	31 0c       	mov	r12,16
8000aa62:	fe b0 de 23 	rcall	800066a8 <malloc>
8000aa66:	99 35       	st.w	r12[0xc],r5
8000aa68:	8f 9c       	st.w	r7[0x24],r12
8000aa6a:	99 15       	st.w	r12[0x4],r5
8000aa6c:	99 25       	st.w	r12[0x8],r5
8000aa6e:	99 05       	st.w	r12[0x0],r5
8000aa70:	6e 95       	ld.w	r5,r7[0x24]
8000aa72:	6a 38       	ld.w	r8,r5[0xc]
8000aa74:	58 08       	cp.w	r8,0
8000aa76:	c0 b1       	brne	8000aa8c <_Balloc+0x38>
8000aa78:	31 0a       	mov	r10,16
8000aa7a:	30 4b       	mov	r11,4
8000aa7c:	0e 9c       	mov	r12,r7
8000aa7e:	e0 a0 02 9b 	rcall	8000afb4 <_calloc_r>
8000aa82:	8b 3c       	st.w	r5[0xc],r12
8000aa84:	6e 98       	ld.w	r8,r7[0x24]
8000aa86:	70 3c       	ld.w	r12,r8[0xc]
8000aa88:	58 0c       	cp.w	r12,0
8000aa8a:	c1 b0       	breq	8000aac0 <_Balloc+0x6c>
8000aa8c:	6e 98       	ld.w	r8,r7[0x24]
8000aa8e:	70 38       	ld.w	r8,r8[0xc]
8000aa90:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000aa94:	70 0c       	ld.w	r12,r8[0x0]
8000aa96:	58 0c       	cp.w	r12,0
8000aa98:	c0 40       	breq	8000aaa0 <_Balloc+0x4c>
8000aa9a:	78 09       	ld.w	r9,r12[0x0]
8000aa9c:	91 09       	st.w	r8[0x0],r9
8000aa9e:	c0 e8       	rjmp	8000aaba <_Balloc+0x66>
8000aaa0:	0e 9c       	mov	r12,r7
8000aaa2:	30 17       	mov	r7,1
8000aaa4:	0e 9b       	mov	r11,r7
8000aaa6:	ee 06 09 47 	lsl	r7,r7,r6
8000aaaa:	ee ca ff fb 	sub	r10,r7,-5
8000aaae:	a3 6a       	lsl	r10,0x2
8000aab0:	e0 a0 02 82 	rcall	8000afb4 <_calloc_r>
8000aab4:	c0 60       	breq	8000aac0 <_Balloc+0x6c>
8000aab6:	99 16       	st.w	r12[0x4],r6
8000aab8:	99 27       	st.w	r12[0x8],r7
8000aaba:	30 08       	mov	r8,0
8000aabc:	99 38       	st.w	r12[0xc],r8
8000aabe:	99 48       	st.w	r12[0x10],r8
8000aac0:	d8 22       	popm	r4-r7,pc
8000aac2:	d7 03       	nop

8000aac4 <__d2b>:
8000aac4:	d4 31       	pushm	r0-r7,lr
8000aac6:	20 2d       	sub	sp,8
8000aac8:	16 93       	mov	r3,r11
8000aaca:	12 96       	mov	r6,r9
8000aacc:	10 95       	mov	r5,r8
8000aace:	14 92       	mov	r2,r10
8000aad0:	30 1b       	mov	r11,1
8000aad2:	cc 1f       	rcall	8000aa54 <_Balloc>
8000aad4:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000aad8:	50 09       	stdsp	sp[0x0],r9
8000aada:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000aade:	b5 a9       	sbr	r9,0x14
8000aae0:	f0 01 16 14 	lsr	r1,r8,0x14
8000aae4:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000aae8:	18 94       	mov	r4,r12
8000aaea:	58 02       	cp.w	r2,0
8000aaec:	c1 d0       	breq	8000ab26 <__d2b+0x62>
8000aaee:	fa cc ff f8 	sub	r12,sp,-8
8000aaf2:	18 d2       	st.w	--r12,r2
8000aaf4:	c3 6f       	rcall	8000a960 <__lo0bits>
8000aaf6:	40 18       	lddsp	r8,sp[0x4]
8000aaf8:	c0 d0       	breq	8000ab12 <__d2b+0x4e>
8000aafa:	40 09       	lddsp	r9,sp[0x0]
8000aafc:	f8 0a 11 20 	rsub	r10,r12,32
8000ab00:	f2 0a 09 4a 	lsl	r10,r9,r10
8000ab04:	f5 e8 10 08 	or	r8,r10,r8
8000ab08:	89 58       	st.w	r4[0x14],r8
8000ab0a:	f2 0c 0a 49 	lsr	r9,r9,r12
8000ab0e:	50 09       	stdsp	sp[0x0],r9
8000ab10:	c0 28       	rjmp	8000ab14 <__d2b+0x50>
8000ab12:	89 58       	st.w	r4[0x14],r8
8000ab14:	40 08       	lddsp	r8,sp[0x0]
8000ab16:	58 08       	cp.w	r8,0
8000ab18:	f9 b3 01 02 	movne	r3,2
8000ab1c:	f9 b3 00 01 	moveq	r3,1
8000ab20:	89 68       	st.w	r4[0x18],r8
8000ab22:	89 43       	st.w	r4[0x10],r3
8000ab24:	c0 88       	rjmp	8000ab34 <__d2b+0x70>
8000ab26:	1a 9c       	mov	r12,sp
8000ab28:	c1 cf       	rcall	8000a960 <__lo0bits>
8000ab2a:	30 13       	mov	r3,1
8000ab2c:	40 08       	lddsp	r8,sp[0x0]
8000ab2e:	2e 0c       	sub	r12,-32
8000ab30:	89 43       	st.w	r4[0x10],r3
8000ab32:	89 58       	st.w	r4[0x14],r8
8000ab34:	58 01       	cp.w	r1,0
8000ab36:	c0 90       	breq	8000ab48 <__d2b+0x84>
8000ab38:	e2 c1 04 33 	sub	r1,r1,1075
8000ab3c:	18 01       	add	r1,r12
8000ab3e:	8d 01       	st.w	r6[0x0],r1
8000ab40:	f8 0c 11 35 	rsub	r12,r12,53
8000ab44:	8b 0c       	st.w	r5[0x0],r12
8000ab46:	c0 c8       	rjmp	8000ab5e <__d2b+0x9a>
8000ab48:	e6 c8 ff fc 	sub	r8,r3,-4
8000ab4c:	f8 cc 04 32 	sub	r12,r12,1074
8000ab50:	a5 73       	lsl	r3,0x5
8000ab52:	8d 0c       	st.w	r6[0x0],r12
8000ab54:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000ab58:	cd 4e       	rcall	8000a900 <__hi0bits>
8000ab5a:	18 13       	sub	r3,r12
8000ab5c:	8b 03       	st.w	r5[0x0],r3
8000ab5e:	08 9c       	mov	r12,r4
8000ab60:	2f ed       	sub	sp,-8
8000ab62:	d8 32       	popm	r0-r7,pc

8000ab64 <__mdiff>:
8000ab64:	d4 31       	pushm	r0-r7,lr
8000ab66:	74 48       	ld.w	r8,r10[0x10]
8000ab68:	76 45       	ld.w	r5,r11[0x10]
8000ab6a:	16 97       	mov	r7,r11
8000ab6c:	14 96       	mov	r6,r10
8000ab6e:	10 15       	sub	r5,r8
8000ab70:	c1 31       	brne	8000ab96 <__mdiff+0x32>
8000ab72:	2f b8       	sub	r8,-5
8000ab74:	ee ce ff ec 	sub	lr,r7,-20
8000ab78:	a3 68       	lsl	r8,0x2
8000ab7a:	f4 08 00 0b 	add	r11,r10,r8
8000ab7e:	ee 08 00 08 	add	r8,r7,r8
8000ab82:	11 4a       	ld.w	r10,--r8
8000ab84:	17 49       	ld.w	r9,--r11
8000ab86:	12 3a       	cp.w	r10,r9
8000ab88:	c0 30       	breq	8000ab8e <__mdiff+0x2a>
8000ab8a:	c0 e2       	brcc	8000aba6 <__mdiff+0x42>
8000ab8c:	c0 78       	rjmp	8000ab9a <__mdiff+0x36>
8000ab8e:	1c 38       	cp.w	r8,lr
8000ab90:	fe 9b ff f9 	brhi	8000ab82 <__mdiff+0x1e>
8000ab94:	c4 98       	rjmp	8000ac26 <__mdiff+0xc2>
8000ab96:	58 05       	cp.w	r5,0
8000ab98:	c0 64       	brge	8000aba4 <__mdiff+0x40>
8000ab9a:	0e 98       	mov	r8,r7
8000ab9c:	30 15       	mov	r5,1
8000ab9e:	0c 97       	mov	r7,r6
8000aba0:	10 96       	mov	r6,r8
8000aba2:	c0 28       	rjmp	8000aba6 <__mdiff+0x42>
8000aba4:	30 05       	mov	r5,0
8000aba6:	6e 1b       	ld.w	r11,r7[0x4]
8000aba8:	c5 6f       	rcall	8000aa54 <_Balloc>
8000abaa:	6e 49       	ld.w	r9,r7[0x10]
8000abac:	6c 44       	ld.w	r4,r6[0x10]
8000abae:	99 35       	st.w	r12[0xc],r5
8000abb0:	2f b4       	sub	r4,-5
8000abb2:	f2 c5 ff fb 	sub	r5,r9,-5
8000abb6:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000abba:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000abbe:	2e c6       	sub	r6,-20
8000abc0:	2e c7       	sub	r7,-20
8000abc2:	f8 c8 ff ec 	sub	r8,r12,-20
8000abc6:	30 0a       	mov	r10,0
8000abc8:	0f 0e       	ld.w	lr,r7++
8000abca:	0d 0b       	ld.w	r11,r6++
8000abcc:	fc 02 16 10 	lsr	r2,lr,0x10
8000abd0:	f6 03 16 10 	lsr	r3,r11,0x10
8000abd4:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000abd8:	e4 03 01 03 	sub	r3,r2,r3
8000abdc:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000abe0:	fc 0b 01 0b 	sub	r11,lr,r11
8000abe4:	f6 0a 00 0a 	add	r10,r11,r10
8000abe8:	b0 1a       	st.h	r8[0x2],r10
8000abea:	b1 4a       	asr	r10,0x10
8000abec:	e6 0a 00 0a 	add	r10,r3,r10
8000abf0:	b0 0a       	st.h	r8[0x0],r10
8000abf2:	2f c8       	sub	r8,-4
8000abf4:	b1 4a       	asr	r10,0x10
8000abf6:	08 36       	cp.w	r6,r4
8000abf8:	ce 83       	brcs	8000abc8 <__mdiff+0x64>
8000abfa:	c0 d8       	rjmp	8000ac14 <__mdiff+0xb0>
8000abfc:	0f 0b       	ld.w	r11,r7++
8000abfe:	f6 0e 16 10 	lsr	lr,r11,0x10
8000ac02:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ac06:	16 0a       	add	r10,r11
8000ac08:	b0 1a       	st.h	r8[0x2],r10
8000ac0a:	b1 4a       	asr	r10,0x10
8000ac0c:	1c 0a       	add	r10,lr
8000ac0e:	b0 0a       	st.h	r8[0x0],r10
8000ac10:	2f c8       	sub	r8,-4
8000ac12:	b1 4a       	asr	r10,0x10
8000ac14:	0a 37       	cp.w	r7,r5
8000ac16:	cf 33       	brcs	8000abfc <__mdiff+0x98>
8000ac18:	c0 28       	rjmp	8000ac1c <__mdiff+0xb8>
8000ac1a:	20 19       	sub	r9,1
8000ac1c:	11 4a       	ld.w	r10,--r8
8000ac1e:	58 0a       	cp.w	r10,0
8000ac20:	cf d0       	breq	8000ac1a <__mdiff+0xb6>
8000ac22:	99 49       	st.w	r12[0x10],r9
8000ac24:	d8 32       	popm	r0-r7,pc
8000ac26:	30 0b       	mov	r11,0
8000ac28:	c1 6f       	rcall	8000aa54 <_Balloc>
8000ac2a:	30 18       	mov	r8,1
8000ac2c:	99 48       	st.w	r12[0x10],r8
8000ac2e:	30 08       	mov	r8,0
8000ac30:	99 58       	st.w	r12[0x14],r8
8000ac32:	d8 32       	popm	r0-r7,pc

8000ac34 <__lshift>:
8000ac34:	d4 31       	pushm	r0-r7,lr
8000ac36:	16 97       	mov	r7,r11
8000ac38:	76 46       	ld.w	r6,r11[0x10]
8000ac3a:	f4 02 14 05 	asr	r2,r10,0x5
8000ac3e:	2f f6       	sub	r6,-1
8000ac40:	14 93       	mov	r3,r10
8000ac42:	18 94       	mov	r4,r12
8000ac44:	04 06       	add	r6,r2
8000ac46:	76 1b       	ld.w	r11,r11[0x4]
8000ac48:	6e 28       	ld.w	r8,r7[0x8]
8000ac4a:	c0 38       	rjmp	8000ac50 <__lshift+0x1c>
8000ac4c:	2f fb       	sub	r11,-1
8000ac4e:	a1 78       	lsl	r8,0x1
8000ac50:	10 36       	cp.w	r6,r8
8000ac52:	fe 99 ff fd 	brgt	8000ac4c <__lshift+0x18>
8000ac56:	08 9c       	mov	r12,r4
8000ac58:	cf ee       	rcall	8000aa54 <_Balloc>
8000ac5a:	30 09       	mov	r9,0
8000ac5c:	18 95       	mov	r5,r12
8000ac5e:	f8 c8 ff ec 	sub	r8,r12,-20
8000ac62:	12 9a       	mov	r10,r9
8000ac64:	c0 38       	rjmp	8000ac6a <__lshift+0x36>
8000ac66:	10 aa       	st.w	r8++,r10
8000ac68:	2f f9       	sub	r9,-1
8000ac6a:	04 39       	cp.w	r9,r2
8000ac6c:	cf d5       	brlt	8000ac66 <__lshift+0x32>
8000ac6e:	6e 4b       	ld.w	r11,r7[0x10]
8000ac70:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000ac74:	2f bb       	sub	r11,-5
8000ac76:	ee c9 ff ec 	sub	r9,r7,-20
8000ac7a:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000ac7e:	58 03       	cp.w	r3,0
8000ac80:	c1 30       	breq	8000aca6 <__lshift+0x72>
8000ac82:	e6 0c 11 20 	rsub	r12,r3,32
8000ac86:	30 0a       	mov	r10,0
8000ac88:	72 02       	ld.w	r2,r9[0x0]
8000ac8a:	e4 03 09 42 	lsl	r2,r2,r3
8000ac8e:	04 4a       	or	r10,r2
8000ac90:	10 aa       	st.w	r8++,r10
8000ac92:	13 0a       	ld.w	r10,r9++
8000ac94:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ac98:	16 39       	cp.w	r9,r11
8000ac9a:	cf 73       	brcs	8000ac88 <__lshift+0x54>
8000ac9c:	91 0a       	st.w	r8[0x0],r10
8000ac9e:	58 0a       	cp.w	r10,0
8000aca0:	c0 70       	breq	8000acae <__lshift+0x7a>
8000aca2:	2f f6       	sub	r6,-1
8000aca4:	c0 58       	rjmp	8000acae <__lshift+0x7a>
8000aca6:	13 0a       	ld.w	r10,r9++
8000aca8:	10 aa       	st.w	r8++,r10
8000acaa:	16 39       	cp.w	r9,r11
8000acac:	cf d3       	brcs	8000aca6 <__lshift+0x72>
8000acae:	08 9c       	mov	r12,r4
8000acb0:	20 16       	sub	r6,1
8000acb2:	0e 9b       	mov	r11,r7
8000acb4:	8b 46       	st.w	r5[0x10],r6
8000acb6:	cb 5e       	rcall	8000aa20 <_Bfree>
8000acb8:	0a 9c       	mov	r12,r5
8000acba:	d8 32       	popm	r0-r7,pc

8000acbc <__multiply>:
8000acbc:	d4 31       	pushm	r0-r7,lr
8000acbe:	20 2d       	sub	sp,8
8000acc0:	76 49       	ld.w	r9,r11[0x10]
8000acc2:	74 48       	ld.w	r8,r10[0x10]
8000acc4:	16 96       	mov	r6,r11
8000acc6:	14 95       	mov	r5,r10
8000acc8:	10 39       	cp.w	r9,r8
8000acca:	ec 08 17 50 	movlt	r8,r6
8000acce:	ea 06 17 50 	movlt	r6,r5
8000acd2:	f0 05 17 50 	movlt	r5,r8
8000acd6:	6c 28       	ld.w	r8,r6[0x8]
8000acd8:	76 43       	ld.w	r3,r11[0x10]
8000acda:	74 42       	ld.w	r2,r10[0x10]
8000acdc:	76 1b       	ld.w	r11,r11[0x4]
8000acde:	e4 03 00 07 	add	r7,r2,r3
8000ace2:	10 37       	cp.w	r7,r8
8000ace4:	f7 bb 09 ff 	subgt	r11,-1
8000ace8:	cb 6e       	rcall	8000aa54 <_Balloc>
8000acea:	ee c4 ff fb 	sub	r4,r7,-5
8000acee:	f8 c9 ff ec 	sub	r9,r12,-20
8000acf2:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000acf6:	30 0a       	mov	r10,0
8000acf8:	12 98       	mov	r8,r9
8000acfa:	c0 28       	rjmp	8000acfe <__multiply+0x42>
8000acfc:	10 aa       	st.w	r8++,r10
8000acfe:	08 38       	cp.w	r8,r4
8000ad00:	cf e3       	brcs	8000acfc <__multiply+0x40>
8000ad02:	2f b3       	sub	r3,-5
8000ad04:	2f b2       	sub	r2,-5
8000ad06:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000ad0a:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000ad0e:	ec cb ff ec 	sub	r11,r6,-20
8000ad12:	50 12       	stdsp	sp[0x4],r2
8000ad14:	ea ca ff ec 	sub	r10,r5,-20
8000ad18:	c4 48       	rjmp	8000ada0 <__multiply+0xe4>
8000ad1a:	94 95       	ld.uh	r5,r10[0x2]
8000ad1c:	58 05       	cp.w	r5,0
8000ad1e:	c2 00       	breq	8000ad5e <__multiply+0xa2>
8000ad20:	12 98       	mov	r8,r9
8000ad22:	16 96       	mov	r6,r11
8000ad24:	30 0e       	mov	lr,0
8000ad26:	50 09       	stdsp	sp[0x0],r9
8000ad28:	0d 02       	ld.w	r2,r6++
8000ad2a:	e4 00 16 10 	lsr	r0,r2,0x10
8000ad2e:	70 01       	ld.w	r1,r8[0x0]
8000ad30:	70 09       	ld.w	r9,r8[0x0]
8000ad32:	b1 81       	lsr	r1,0x10
8000ad34:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000ad38:	e0 05 03 41 	mac	r1,r0,r5
8000ad3c:	ab 32       	mul	r2,r5
8000ad3e:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000ad42:	00 02       	add	r2,r0
8000ad44:	e4 0e 00 0e 	add	lr,r2,lr
8000ad48:	b0 1e       	st.h	r8[0x2],lr
8000ad4a:	b1 8e       	lsr	lr,0x10
8000ad4c:	1c 01       	add	r1,lr
8000ad4e:	b0 01       	st.h	r8[0x0],r1
8000ad50:	e2 0e 16 10 	lsr	lr,r1,0x10
8000ad54:	2f c8       	sub	r8,-4
8000ad56:	06 36       	cp.w	r6,r3
8000ad58:	ce 83       	brcs	8000ad28 <__multiply+0x6c>
8000ad5a:	40 09       	lddsp	r9,sp[0x0]
8000ad5c:	91 0e       	st.w	r8[0x0],lr
8000ad5e:	94 86       	ld.uh	r6,r10[0x0]
8000ad60:	58 06       	cp.w	r6,0
8000ad62:	c1 d0       	breq	8000ad9c <__multiply+0xe0>
8000ad64:	72 02       	ld.w	r2,r9[0x0]
8000ad66:	12 98       	mov	r8,r9
8000ad68:	16 9e       	mov	lr,r11
8000ad6a:	30 05       	mov	r5,0
8000ad6c:	b0 12       	st.h	r8[0x2],r2
8000ad6e:	1d 01       	ld.w	r1,lr++
8000ad70:	90 82       	ld.uh	r2,r8[0x0]
8000ad72:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000ad76:	ad 30       	mul	r0,r6
8000ad78:	e0 02 00 02 	add	r2,r0,r2
8000ad7c:	e4 05 00 05 	add	r5,r2,r5
8000ad80:	b0 05       	st.h	r8[0x0],r5
8000ad82:	b1 85       	lsr	r5,0x10
8000ad84:	b1 81       	lsr	r1,0x10
8000ad86:	2f c8       	sub	r8,-4
8000ad88:	ad 31       	mul	r1,r6
8000ad8a:	90 92       	ld.uh	r2,r8[0x2]
8000ad8c:	e2 02 00 02 	add	r2,r1,r2
8000ad90:	0a 02       	add	r2,r5
8000ad92:	e4 05 16 10 	lsr	r5,r2,0x10
8000ad96:	06 3e       	cp.w	lr,r3
8000ad98:	ce a3       	brcs	8000ad6c <__multiply+0xb0>
8000ad9a:	91 02       	st.w	r8[0x0],r2
8000ad9c:	2f ca       	sub	r10,-4
8000ad9e:	2f c9       	sub	r9,-4
8000ada0:	40 18       	lddsp	r8,sp[0x4]
8000ada2:	10 3a       	cp.w	r10,r8
8000ada4:	cb b3       	brcs	8000ad1a <__multiply+0x5e>
8000ada6:	c0 28       	rjmp	8000adaa <__multiply+0xee>
8000ada8:	20 17       	sub	r7,1
8000adaa:	58 07       	cp.w	r7,0
8000adac:	e0 8a 00 05 	brle	8000adb6 <__multiply+0xfa>
8000adb0:	09 48       	ld.w	r8,--r4
8000adb2:	58 08       	cp.w	r8,0
8000adb4:	cf a0       	breq	8000ada8 <__multiply+0xec>
8000adb6:	99 47       	st.w	r12[0x10],r7
8000adb8:	2f ed       	sub	sp,-8
8000adba:	d8 32       	popm	r0-r7,pc

8000adbc <__i2b>:
8000adbc:	d4 21       	pushm	r4-r7,lr
8000adbe:	16 97       	mov	r7,r11
8000adc0:	30 1b       	mov	r11,1
8000adc2:	c4 9e       	rcall	8000aa54 <_Balloc>
8000adc4:	30 19       	mov	r9,1
8000adc6:	99 57       	st.w	r12[0x14],r7
8000adc8:	99 49       	st.w	r12[0x10],r9
8000adca:	d8 22       	popm	r4-r7,pc

8000adcc <__multadd>:
8000adcc:	d4 31       	pushm	r0-r7,lr
8000adce:	30 08       	mov	r8,0
8000add0:	12 95       	mov	r5,r9
8000add2:	16 97       	mov	r7,r11
8000add4:	18 96       	mov	r6,r12
8000add6:	76 44       	ld.w	r4,r11[0x10]
8000add8:	f6 c9 ff ec 	sub	r9,r11,-20
8000addc:	72 0b       	ld.w	r11,r9[0x0]
8000adde:	f6 0c 16 10 	lsr	r12,r11,0x10
8000ade2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ade6:	f4 0c 02 4c 	mul	r12,r10,r12
8000adea:	f4 0b 03 45 	mac	r5,r10,r11
8000adee:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000adf2:	b1 85       	lsr	r5,0x10
8000adf4:	18 05       	add	r5,r12
8000adf6:	ea 0c 15 10 	lsl	r12,r5,0x10
8000adfa:	f8 0b 00 0b 	add	r11,r12,r11
8000adfe:	12 ab       	st.w	r9++,r11
8000ae00:	2f f8       	sub	r8,-1
8000ae02:	b1 85       	lsr	r5,0x10
8000ae04:	08 38       	cp.w	r8,r4
8000ae06:	ce b5       	brlt	8000addc <__multadd+0x10>
8000ae08:	58 05       	cp.w	r5,0
8000ae0a:	c1 c0       	breq	8000ae42 <__multadd+0x76>
8000ae0c:	6e 28       	ld.w	r8,r7[0x8]
8000ae0e:	10 34       	cp.w	r4,r8
8000ae10:	c1 35       	brlt	8000ae36 <__multadd+0x6a>
8000ae12:	6e 1b       	ld.w	r11,r7[0x4]
8000ae14:	0c 9c       	mov	r12,r6
8000ae16:	2f fb       	sub	r11,-1
8000ae18:	c1 ee       	rcall	8000aa54 <_Balloc>
8000ae1a:	6e 4a       	ld.w	r10,r7[0x10]
8000ae1c:	ee cb ff f4 	sub	r11,r7,-12
8000ae20:	18 93       	mov	r3,r12
8000ae22:	2f ea       	sub	r10,-2
8000ae24:	2f 4c       	sub	r12,-12
8000ae26:	a3 6a       	lsl	r10,0x2
8000ae28:	fe b0 de 64 	rcall	80006af0 <memcpy>
8000ae2c:	0e 9b       	mov	r11,r7
8000ae2e:	0c 9c       	mov	r12,r6
8000ae30:	fe b0 fd f8 	rcall	8000aa20 <_Bfree>
8000ae34:	06 97       	mov	r7,r3
8000ae36:	e8 c8 ff ff 	sub	r8,r4,-1
8000ae3a:	2f b4       	sub	r4,-5
8000ae3c:	8f 48       	st.w	r7[0x10],r8
8000ae3e:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000ae42:	0e 9c       	mov	r12,r7
8000ae44:	d8 32       	popm	r0-r7,pc
8000ae46:	d7 03       	nop

8000ae48 <__pow5mult>:
8000ae48:	d4 31       	pushm	r0-r7,lr
8000ae4a:	14 96       	mov	r6,r10
8000ae4c:	18 97       	mov	r7,r12
8000ae4e:	16 94       	mov	r4,r11
8000ae50:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000ae54:	c0 90       	breq	8000ae66 <__pow5mult+0x1e>
8000ae56:	20 18       	sub	r8,1
8000ae58:	fe c9 d5 b8 	sub	r9,pc,-10824
8000ae5c:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000ae60:	30 09       	mov	r9,0
8000ae62:	cb 5f       	rcall	8000adcc <__multadd>
8000ae64:	18 94       	mov	r4,r12
8000ae66:	a3 46       	asr	r6,0x2
8000ae68:	c3 40       	breq	8000aed0 <__pow5mult+0x88>
8000ae6a:	6e 95       	ld.w	r5,r7[0x24]
8000ae6c:	58 05       	cp.w	r5,0
8000ae6e:	c0 91       	brne	8000ae80 <__pow5mult+0x38>
8000ae70:	31 0c       	mov	r12,16
8000ae72:	fe b0 dc 1b 	rcall	800066a8 <malloc>
8000ae76:	99 35       	st.w	r12[0xc],r5
8000ae78:	8f 9c       	st.w	r7[0x24],r12
8000ae7a:	99 15       	st.w	r12[0x4],r5
8000ae7c:	99 25       	st.w	r12[0x8],r5
8000ae7e:	99 05       	st.w	r12[0x0],r5
8000ae80:	6e 93       	ld.w	r3,r7[0x24]
8000ae82:	66 25       	ld.w	r5,r3[0x8]
8000ae84:	58 05       	cp.w	r5,0
8000ae86:	c0 c1       	brne	8000ae9e <__pow5mult+0x56>
8000ae88:	e0 6b 02 71 	mov	r11,625
8000ae8c:	0e 9c       	mov	r12,r7
8000ae8e:	c9 7f       	rcall	8000adbc <__i2b>
8000ae90:	87 2c       	st.w	r3[0x8],r12
8000ae92:	30 08       	mov	r8,0
8000ae94:	18 95       	mov	r5,r12
8000ae96:	99 08       	st.w	r12[0x0],r8
8000ae98:	c0 38       	rjmp	8000ae9e <__pow5mult+0x56>
8000ae9a:	06 9c       	mov	r12,r3
8000ae9c:	18 95       	mov	r5,r12
8000ae9e:	ed b6 00 00 	bld	r6,0x0
8000aea2:	c0 b1       	brne	8000aeb8 <__pow5mult+0x70>
8000aea4:	08 9b       	mov	r11,r4
8000aea6:	0a 9a       	mov	r10,r5
8000aea8:	0e 9c       	mov	r12,r7
8000aeaa:	c0 9f       	rcall	8000acbc <__multiply>
8000aeac:	08 9b       	mov	r11,r4
8000aeae:	18 93       	mov	r3,r12
8000aeb0:	0e 9c       	mov	r12,r7
8000aeb2:	06 94       	mov	r4,r3
8000aeb4:	fe b0 fd b6 	rcall	8000aa20 <_Bfree>
8000aeb8:	a1 56       	asr	r6,0x1
8000aeba:	c0 b0       	breq	8000aed0 <__pow5mult+0x88>
8000aebc:	6a 03       	ld.w	r3,r5[0x0]
8000aebe:	58 03       	cp.w	r3,0
8000aec0:	ce d1       	brne	8000ae9a <__pow5mult+0x52>
8000aec2:	0a 9a       	mov	r10,r5
8000aec4:	0a 9b       	mov	r11,r5
8000aec6:	0e 9c       	mov	r12,r7
8000aec8:	cf ae       	rcall	8000acbc <__multiply>
8000aeca:	8b 0c       	st.w	r5[0x0],r12
8000aecc:	99 03       	st.w	r12[0x0],r3
8000aece:	ce 7b       	rjmp	8000ae9c <__pow5mult+0x54>
8000aed0:	08 9c       	mov	r12,r4
8000aed2:	d8 32       	popm	r0-r7,pc

8000aed4 <__isinfd>:
8000aed4:	14 98       	mov	r8,r10
8000aed6:	fc 19 7f f0 	movh	r9,0x7ff0
8000aeda:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000aede:	f0 0b 11 00 	rsub	r11,r8,0
8000aee2:	f7 e8 10 08 	or	r8,r11,r8
8000aee6:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000aeea:	f2 08 01 08 	sub	r8,r9,r8
8000aeee:	f0 0c 11 00 	rsub	r12,r8,0
8000aef2:	f9 e8 10 08 	or	r8,r12,r8
8000aef6:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000aefa:	2f fc       	sub	r12,-1
8000aefc:	5e fc       	retal	r12

8000aefe <__isnand>:
8000aefe:	14 98       	mov	r8,r10
8000af00:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000af04:	f0 0c 11 00 	rsub	r12,r8,0
8000af08:	10 4c       	or	r12,r8
8000af0a:	fc 18 7f f0 	movh	r8,0x7ff0
8000af0e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000af12:	f0 0c 01 0c 	sub	r12,r8,r12
8000af16:	bf 9c       	lsr	r12,0x1f
8000af18:	5e fc       	retal	r12
8000af1a:	d7 03       	nop

8000af1c <__sclose>:
8000af1c:	d4 01       	pushm	lr
8000af1e:	96 7b       	ld.sh	r11,r11[0xe]
8000af20:	c7 6c       	rcall	8000b00c <_close_r>
8000af22:	d8 02       	popm	pc

8000af24 <__sseek>:
8000af24:	d4 21       	pushm	r4-r7,lr
8000af26:	16 97       	mov	r7,r11
8000af28:	96 7b       	ld.sh	r11,r11[0xe]
8000af2a:	cf 7c       	rcall	8000b118 <_lseek_r>
8000af2c:	8e 68       	ld.sh	r8,r7[0xc]
8000af2e:	10 99       	mov	r9,r8
8000af30:	ad c8       	cbr	r8,0xc
8000af32:	ad a9       	sbr	r9,0xc
8000af34:	5b fc       	cp.w	r12,-1
8000af36:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000af3a:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000af3e:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000af42:	d8 22       	popm	r4-r7,pc

8000af44 <__swrite>:
8000af44:	d4 21       	pushm	r4-r7,lr
8000af46:	96 68       	ld.sh	r8,r11[0xc]
8000af48:	16 97       	mov	r7,r11
8000af4a:	14 95       	mov	r5,r10
8000af4c:	12 94       	mov	r4,r9
8000af4e:	e2 18 01 00 	andl	r8,0x100,COH
8000af52:	18 96       	mov	r6,r12
8000af54:	c0 50       	breq	8000af5e <__swrite+0x1a>
8000af56:	30 29       	mov	r9,2
8000af58:	30 0a       	mov	r10,0
8000af5a:	96 7b       	ld.sh	r11,r11[0xe]
8000af5c:	cd ec       	rcall	8000b118 <_lseek_r>
8000af5e:	8e 68       	ld.sh	r8,r7[0xc]
8000af60:	ad c8       	cbr	r8,0xc
8000af62:	08 99       	mov	r9,r4
8000af64:	0a 9a       	mov	r10,r5
8000af66:	8e 7b       	ld.sh	r11,r7[0xe]
8000af68:	0c 9c       	mov	r12,r6
8000af6a:	ae 68       	st.h	r7[0xc],r8
8000af6c:	c1 0c       	rcall	8000af8c <_write_r>
8000af6e:	d8 22       	popm	r4-r7,pc

8000af70 <__sread>:
8000af70:	d4 21       	pushm	r4-r7,lr
8000af72:	16 97       	mov	r7,r11
8000af74:	96 7b       	ld.sh	r11,r11[0xe]
8000af76:	ce 5c       	rcall	8000b140 <_read_r>
8000af78:	c0 65       	brlt	8000af84 <__sread+0x14>
8000af7a:	6f 58       	ld.w	r8,r7[0x54]
8000af7c:	18 08       	add	r8,r12
8000af7e:	ef 48 00 54 	st.w	r7[84],r8
8000af82:	d8 22       	popm	r4-r7,pc
8000af84:	8e 68       	ld.sh	r8,r7[0xc]
8000af86:	ad c8       	cbr	r8,0xc
8000af88:	ae 68       	st.h	r7[0xc],r8
8000af8a:	d8 22       	popm	r4-r7,pc

8000af8c <_write_r>:
8000af8c:	d4 21       	pushm	r4-r7,lr
8000af8e:	16 98       	mov	r8,r11
8000af90:	18 97       	mov	r7,r12
8000af92:	10 9c       	mov	r12,r8
8000af94:	30 08       	mov	r8,0
8000af96:	14 9b       	mov	r11,r10
8000af98:	e0 66 40 fc 	mov	r6,16636
8000af9c:	12 9a       	mov	r10,r9
8000af9e:	8d 08       	st.w	r6[0x0],r8
8000afa0:	fe b0 d1 24 	rcall	800051e8 <_write>
8000afa4:	5b fc       	cp.w	r12,-1
8000afa6:	c0 51       	brne	8000afb0 <_write_r+0x24>
8000afa8:	6c 08       	ld.w	r8,r6[0x0]
8000afaa:	58 08       	cp.w	r8,0
8000afac:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000afb0:	d8 22       	popm	r4-r7,pc
8000afb2:	d7 03       	nop

8000afb4 <_calloc_r>:
8000afb4:	d4 21       	pushm	r4-r7,lr
8000afb6:	f4 0b 02 4b 	mul	r11,r10,r11
8000afba:	fe b0 db 7f 	rcall	800066b8 <_malloc_r>
8000afbe:	18 97       	mov	r7,r12
8000afc0:	c2 30       	breq	8000b006 <_calloc_r+0x52>
8000afc2:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000afc6:	e0 1a ff fc 	andl	r10,0xfffc
8000afca:	20 4a       	sub	r10,4
8000afcc:	e0 4a 00 24 	cp.w	r10,36
8000afd0:	e0 8b 00 18 	brhi	8000b000 <_calloc_r+0x4c>
8000afd4:	18 98       	mov	r8,r12
8000afd6:	59 3a       	cp.w	r10,19
8000afd8:	e0 88 00 0f 	brls	8000aff6 <_calloc_r+0x42>
8000afdc:	30 09       	mov	r9,0
8000afde:	10 a9       	st.w	r8++,r9
8000afe0:	10 a9       	st.w	r8++,r9
8000afe2:	59 ba       	cp.w	r10,27
8000afe4:	e0 88 00 09 	brls	8000aff6 <_calloc_r+0x42>
8000afe8:	10 a9       	st.w	r8++,r9
8000afea:	10 a9       	st.w	r8++,r9
8000afec:	e0 4a 00 24 	cp.w	r10,36
8000aff0:	c0 31       	brne	8000aff6 <_calloc_r+0x42>
8000aff2:	10 a9       	st.w	r8++,r9
8000aff4:	10 a9       	st.w	r8++,r9
8000aff6:	30 09       	mov	r9,0
8000aff8:	10 a9       	st.w	r8++,r9
8000affa:	91 19       	st.w	r8[0x4],r9
8000affc:	91 09       	st.w	r8[0x0],r9
8000affe:	c0 48       	rjmp	8000b006 <_calloc_r+0x52>
8000b000:	30 0b       	mov	r11,0
8000b002:	fe b0 de 1b 	rcall	80006c38 <memset>
8000b006:	0e 9c       	mov	r12,r7
8000b008:	d8 22       	popm	r4-r7,pc
8000b00a:	d7 03       	nop

8000b00c <_close_r>:
8000b00c:	d4 21       	pushm	r4-r7,lr
8000b00e:	30 08       	mov	r8,0
8000b010:	18 97       	mov	r7,r12
8000b012:	e0 66 40 fc 	mov	r6,16636
8000b016:	16 9c       	mov	r12,r11
8000b018:	8d 08       	st.w	r6[0x0],r8
8000b01a:	fe b0 df c1 	rcall	80006f9c <_close>
8000b01e:	5b fc       	cp.w	r12,-1
8000b020:	c0 51       	brne	8000b02a <_close_r+0x1e>
8000b022:	6c 08       	ld.w	r8,r6[0x0]
8000b024:	58 08       	cp.w	r8,0
8000b026:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b02a:	d8 22       	popm	r4-r7,pc

8000b02c <_fclose_r>:
8000b02c:	d4 21       	pushm	r4-r7,lr
8000b02e:	18 96       	mov	r6,r12
8000b030:	16 97       	mov	r7,r11
8000b032:	58 0b       	cp.w	r11,0
8000b034:	c0 31       	brne	8000b03a <_fclose_r+0xe>
8000b036:	16 95       	mov	r5,r11
8000b038:	c5 38       	rjmp	8000b0de <_fclose_r+0xb2>
8000b03a:	fe b0 f8 b5 	rcall	8000a1a4 <__sfp_lock_acquire>
8000b03e:	58 06       	cp.w	r6,0
8000b040:	c0 70       	breq	8000b04e <_fclose_r+0x22>
8000b042:	6c 68       	ld.w	r8,r6[0x18]
8000b044:	58 08       	cp.w	r8,0
8000b046:	c0 41       	brne	8000b04e <_fclose_r+0x22>
8000b048:	0c 9c       	mov	r12,r6
8000b04a:	fe b0 f8 ff 	rcall	8000a248 <__sinit>
8000b04e:	fe c8 d8 52 	sub	r8,pc,-10158
8000b052:	10 37       	cp.w	r7,r8
8000b054:	c0 31       	brne	8000b05a <_fclose_r+0x2e>
8000b056:	6c 07       	ld.w	r7,r6[0x0]
8000b058:	c0 c8       	rjmp	8000b070 <_fclose_r+0x44>
8000b05a:	fe c8 d8 3e 	sub	r8,pc,-10178
8000b05e:	10 37       	cp.w	r7,r8
8000b060:	c0 31       	brne	8000b066 <_fclose_r+0x3a>
8000b062:	6c 17       	ld.w	r7,r6[0x4]
8000b064:	c0 68       	rjmp	8000b070 <_fclose_r+0x44>
8000b066:	fe c8 d8 2a 	sub	r8,pc,-10198
8000b06a:	10 37       	cp.w	r7,r8
8000b06c:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b070:	8e 69       	ld.sh	r9,r7[0xc]
8000b072:	30 08       	mov	r8,0
8000b074:	f0 09 19 00 	cp.h	r9,r8
8000b078:	c0 51       	brne	8000b082 <_fclose_r+0x56>
8000b07a:	fe b0 f8 96 	rcall	8000a1a6 <__sfp_lock_release>
8000b07e:	30 05       	mov	r5,0
8000b080:	c2 f8       	rjmp	8000b0de <_fclose_r+0xb2>
8000b082:	0e 9b       	mov	r11,r7
8000b084:	0c 9c       	mov	r12,r6
8000b086:	fe b0 f8 09 	rcall	8000a098 <_fflush_r>
8000b08a:	6e c8       	ld.w	r8,r7[0x30]
8000b08c:	18 95       	mov	r5,r12
8000b08e:	58 08       	cp.w	r8,0
8000b090:	c0 60       	breq	8000b09c <_fclose_r+0x70>
8000b092:	6e 8b       	ld.w	r11,r7[0x20]
8000b094:	0c 9c       	mov	r12,r6
8000b096:	5d 18       	icall	r8
8000b098:	f9 b5 05 ff 	movlt	r5,-1
8000b09c:	8e 68       	ld.sh	r8,r7[0xc]
8000b09e:	ed b8 00 07 	bld	r8,0x7
8000b0a2:	c0 51       	brne	8000b0ac <_fclose_r+0x80>
8000b0a4:	6e 4b       	ld.w	r11,r7[0x10]
8000b0a6:	0c 9c       	mov	r12,r6
8000b0a8:	fe b0 f9 6a 	rcall	8000a37c <_free_r>
8000b0ac:	6e db       	ld.w	r11,r7[0x34]
8000b0ae:	58 0b       	cp.w	r11,0
8000b0b0:	c0 a0       	breq	8000b0c4 <_fclose_r+0x98>
8000b0b2:	ee c8 ff bc 	sub	r8,r7,-68
8000b0b6:	10 3b       	cp.w	r11,r8
8000b0b8:	c0 40       	breq	8000b0c0 <_fclose_r+0x94>
8000b0ba:	0c 9c       	mov	r12,r6
8000b0bc:	fe b0 f9 60 	rcall	8000a37c <_free_r>
8000b0c0:	30 08       	mov	r8,0
8000b0c2:	8f d8       	st.w	r7[0x34],r8
8000b0c4:	6f 2b       	ld.w	r11,r7[0x48]
8000b0c6:	58 0b       	cp.w	r11,0
8000b0c8:	c0 70       	breq	8000b0d6 <_fclose_r+0xaa>
8000b0ca:	0c 9c       	mov	r12,r6
8000b0cc:	fe b0 f9 58 	rcall	8000a37c <_free_r>
8000b0d0:	30 08       	mov	r8,0
8000b0d2:	ef 48 00 48 	st.w	r7[72],r8
8000b0d6:	30 08       	mov	r8,0
8000b0d8:	ae 68       	st.h	r7[0xc],r8
8000b0da:	fe b0 f8 66 	rcall	8000a1a6 <__sfp_lock_release>
8000b0de:	0a 9c       	mov	r12,r5
8000b0e0:	d8 22       	popm	r4-r7,pc
8000b0e2:	d7 03       	nop

8000b0e4 <fclose>:
8000b0e4:	d4 01       	pushm	lr
8000b0e6:	e0 68 0a 30 	mov	r8,2608
8000b0ea:	18 9b       	mov	r11,r12
8000b0ec:	70 0c       	ld.w	r12,r8[0x0]
8000b0ee:	c9 ff       	rcall	8000b02c <_fclose_r>
8000b0f0:	d8 02       	popm	pc
8000b0f2:	d7 03       	nop

8000b0f4 <_fstat_r>:
8000b0f4:	d4 21       	pushm	r4-r7,lr
8000b0f6:	16 98       	mov	r8,r11
8000b0f8:	18 97       	mov	r7,r12
8000b0fa:	10 9c       	mov	r12,r8
8000b0fc:	30 08       	mov	r8,0
8000b0fe:	e0 66 40 fc 	mov	r6,16636
8000b102:	14 9b       	mov	r11,r10
8000b104:	8d 08       	st.w	r6[0x0],r8
8000b106:	fe b0 df 73 	rcall	80006fec <_fstat>
8000b10a:	5b fc       	cp.w	r12,-1
8000b10c:	c0 51       	brne	8000b116 <_fstat_r+0x22>
8000b10e:	6c 08       	ld.w	r8,r6[0x0]
8000b110:	58 08       	cp.w	r8,0
8000b112:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b116:	d8 22       	popm	r4-r7,pc

8000b118 <_lseek_r>:
8000b118:	d4 21       	pushm	r4-r7,lr
8000b11a:	16 98       	mov	r8,r11
8000b11c:	18 97       	mov	r7,r12
8000b11e:	10 9c       	mov	r12,r8
8000b120:	30 08       	mov	r8,0
8000b122:	14 9b       	mov	r11,r10
8000b124:	e0 66 40 fc 	mov	r6,16636
8000b128:	12 9a       	mov	r10,r9
8000b12a:	8d 08       	st.w	r6[0x0],r8
8000b12c:	fe b0 df 42 	rcall	80006fb0 <_lseek>
8000b130:	5b fc       	cp.w	r12,-1
8000b132:	c0 51       	brne	8000b13c <_lseek_r+0x24>
8000b134:	6c 08       	ld.w	r8,r6[0x0]
8000b136:	58 08       	cp.w	r8,0
8000b138:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b13c:	d8 22       	popm	r4-r7,pc
8000b13e:	d7 03       	nop

8000b140 <_read_r>:
8000b140:	d4 21       	pushm	r4-r7,lr
8000b142:	16 98       	mov	r8,r11
8000b144:	18 97       	mov	r7,r12
8000b146:	10 9c       	mov	r12,r8
8000b148:	30 08       	mov	r8,0
8000b14a:	14 9b       	mov	r11,r10
8000b14c:	e0 66 40 fc 	mov	r6,16636
8000b150:	12 9a       	mov	r10,r9
8000b152:	8d 08       	st.w	r6[0x0],r8
8000b154:	fe b0 d0 2a 	rcall	800051a8 <_read>
8000b158:	5b fc       	cp.w	r12,-1
8000b15a:	c0 51       	brne	8000b164 <_read_r+0x24>
8000b15c:	6c 08       	ld.w	r8,r6[0x0]
8000b15e:	58 08       	cp.w	r8,0
8000b160:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b164:	d8 22       	popm	r4-r7,pc
8000b166:	d7 03       	nop

8000b168 <__avr32_f64_mul>:
8000b168:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b16c:	e0 80 00 dc 	breq	8000b324 <__avr32_f64_mul_op1_zero>
8000b170:	d4 21       	pushm	r4-r7,lr
8000b172:	f7 e9 20 0e 	eor	lr,r11,r9
8000b176:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b17a:	30 15       	mov	r5,1
8000b17c:	c4 30       	breq	8000b202 <__avr32_f64_mul_op1_subnormal>
8000b17e:	ab 6b       	lsl	r11,0xa
8000b180:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b184:	ab 6a       	lsl	r10,0xa
8000b186:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b18a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b18e:	c5 c0       	breq	8000b246 <__avr32_f64_mul_op2_subnormal>
8000b190:	a1 78       	lsl	r8,0x1
8000b192:	5c f9       	rol	r9
8000b194:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b198:	e0 47 07 ff 	cp.w	r7,2047
8000b19c:	c7 70       	breq	8000b28a <__avr32_f64_mul_op_nan_or_inf>
8000b19e:	e0 46 07 ff 	cp.w	r6,2047
8000b1a2:	c7 40       	breq	8000b28a <__avr32_f64_mul_op_nan_or_inf>
8000b1a4:	ee 06 00 0c 	add	r12,r7,r6
8000b1a8:	e0 2c 03 fe 	sub	r12,1022
8000b1ac:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b1b0:	f4 09 07 44 	macu.d	r4,r10,r9
8000b1b4:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b1b8:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b1bc:	08 07       	add	r7,r4
8000b1be:	f4 05 00 4a 	adc	r10,r10,r5
8000b1c2:	5c 0b       	acr	r11
8000b1c4:	ed bb 00 14 	bld	r11,0x14
8000b1c8:	c0 50       	breq	8000b1d2 <__avr32_f64_mul+0x6a>
8000b1ca:	a1 77       	lsl	r7,0x1
8000b1cc:	5c fa       	rol	r10
8000b1ce:	5c fb       	rol	r11
8000b1d0:	20 1c       	sub	r12,1
8000b1d2:	58 0c       	cp.w	r12,0
8000b1d4:	e0 8a 00 6f 	brle	8000b2b2 <__avr32_f64_mul_res_subnormal>
8000b1d8:	e0 4c 07 ff 	cp.w	r12,2047
8000b1dc:	e0 84 00 9c 	brge	8000b314 <__avr32_f64_mul_res_inf>
8000b1e0:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b1e4:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b1e8:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b1ec:	ee 17 80 00 	eorh	r7,0x8000
8000b1f0:	f1 b7 04 20 	satu	r7,0x1
8000b1f4:	0e 0a       	add	r10,r7
8000b1f6:	5c 0b       	acr	r11
8000b1f8:	ed be 00 1f 	bld	lr,0x1f
8000b1fc:	ef bb 00 1f 	bst	r11,0x1f
8000b200:	d8 22       	popm	r4-r7,pc

8000b202 <__avr32_f64_mul_op1_subnormal>:
8000b202:	e4 1b 00 0f 	andh	r11,0xf
8000b206:	f4 0c 12 00 	clz	r12,r10
8000b20a:	f6 06 12 00 	clz	r6,r11
8000b20e:	f7 bc 03 e1 	sublo	r12,-31
8000b212:	f8 06 17 30 	movlo	r6,r12
8000b216:	f7 b6 02 01 	subhs	r6,1
8000b21a:	e0 46 00 20 	cp.w	r6,32
8000b21e:	c0 d4       	brge	8000b238 <__avr32_f64_mul_op1_subnormal+0x36>
8000b220:	ec 0c 11 20 	rsub	r12,r6,32
8000b224:	f6 06 09 4b 	lsl	r11,r11,r6
8000b228:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b22c:	18 4b       	or	r11,r12
8000b22e:	f4 06 09 4a 	lsl	r10,r10,r6
8000b232:	20 b6       	sub	r6,11
8000b234:	0c 17       	sub	r7,r6
8000b236:	ca ab       	rjmp	8000b18a <__avr32_f64_mul+0x22>
8000b238:	f4 06 09 4b 	lsl	r11,r10,r6
8000b23c:	c6 40       	breq	8000b304 <__avr32_f64_mul_res_zero>
8000b23e:	30 0a       	mov	r10,0
8000b240:	20 b6       	sub	r6,11
8000b242:	0c 17       	sub	r7,r6
8000b244:	ca 3b       	rjmp	8000b18a <__avr32_f64_mul+0x22>

8000b246 <__avr32_f64_mul_op2_subnormal>:
8000b246:	e4 19 00 0f 	andh	r9,0xf
8000b24a:	f0 0c 12 00 	clz	r12,r8
8000b24e:	f2 05 12 00 	clz	r5,r9
8000b252:	f7 bc 03 ea 	sublo	r12,-22
8000b256:	f8 05 17 30 	movlo	r5,r12
8000b25a:	f7 b5 02 0a 	subhs	r5,10
8000b25e:	e0 45 00 20 	cp.w	r5,32
8000b262:	c0 d4       	brge	8000b27c <__avr32_f64_mul_op2_subnormal+0x36>
8000b264:	ea 0c 11 20 	rsub	r12,r5,32
8000b268:	f2 05 09 49 	lsl	r9,r9,r5
8000b26c:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b270:	18 49       	or	r9,r12
8000b272:	f0 05 09 48 	lsl	r8,r8,r5
8000b276:	20 25       	sub	r5,2
8000b278:	0a 16       	sub	r6,r5
8000b27a:	c8 fb       	rjmp	8000b198 <__avr32_f64_mul+0x30>
8000b27c:	f0 05 09 49 	lsl	r9,r8,r5
8000b280:	c4 20       	breq	8000b304 <__avr32_f64_mul_res_zero>
8000b282:	30 08       	mov	r8,0
8000b284:	20 25       	sub	r5,2
8000b286:	0a 16       	sub	r6,r5
8000b288:	c8 8b       	rjmp	8000b198 <__avr32_f64_mul+0x30>

8000b28a <__avr32_f64_mul_op_nan_or_inf>:
8000b28a:	e4 19 00 0f 	andh	r9,0xf
8000b28e:	e4 1b 00 0f 	andh	r11,0xf
8000b292:	14 4b       	or	r11,r10
8000b294:	10 49       	or	r9,r8
8000b296:	e0 47 07 ff 	cp.w	r7,2047
8000b29a:	c0 91       	brne	8000b2ac <__avr32_f64_mul_op1_not_naninf>
8000b29c:	58 0b       	cp.w	r11,0
8000b29e:	c3 81       	brne	8000b30e <__avr32_f64_mul_res_nan>
8000b2a0:	e0 46 07 ff 	cp.w	r6,2047
8000b2a4:	c3 81       	brne	8000b314 <__avr32_f64_mul_res_inf>
8000b2a6:	58 09       	cp.w	r9,0
8000b2a8:	c3 60       	breq	8000b314 <__avr32_f64_mul_res_inf>
8000b2aa:	c3 28       	rjmp	8000b30e <__avr32_f64_mul_res_nan>

8000b2ac <__avr32_f64_mul_op1_not_naninf>:
8000b2ac:	58 09       	cp.w	r9,0
8000b2ae:	c3 30       	breq	8000b314 <__avr32_f64_mul_res_inf>
8000b2b0:	c2 f8       	rjmp	8000b30e <__avr32_f64_mul_res_nan>

8000b2b2 <__avr32_f64_mul_res_subnormal>:
8000b2b2:	5c 3c       	neg	r12
8000b2b4:	2f fc       	sub	r12,-1
8000b2b6:	f1 bc 04 c0 	satu	r12,0x6
8000b2ba:	e0 4c 00 20 	cp.w	r12,32
8000b2be:	c1 14       	brge	8000b2e0 <__avr32_f64_mul_res_subnormal+0x2e>
8000b2c0:	f8 08 11 20 	rsub	r8,r12,32
8000b2c4:	0e 46       	or	r6,r7
8000b2c6:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b2ca:	f4 08 09 49 	lsl	r9,r10,r8
8000b2ce:	12 47       	or	r7,r9
8000b2d0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b2d4:	f6 08 09 49 	lsl	r9,r11,r8
8000b2d8:	12 4a       	or	r10,r9
8000b2da:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b2de:	c8 3b       	rjmp	8000b1e4 <__avr32_f64_mul+0x7c>
8000b2e0:	f8 08 11 20 	rsub	r8,r12,32
8000b2e4:	f9 b9 00 00 	moveq	r9,0
8000b2e8:	c0 30       	breq	8000b2ee <__avr32_f64_mul_res_subnormal+0x3c>
8000b2ea:	f6 08 09 49 	lsl	r9,r11,r8
8000b2ee:	0e 46       	or	r6,r7
8000b2f0:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b2f4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b2f8:	f3 ea 10 07 	or	r7,r9,r10
8000b2fc:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b300:	30 0b       	mov	r11,0
8000b302:	c7 1b       	rjmp	8000b1e4 <__avr32_f64_mul+0x7c>

8000b304 <__avr32_f64_mul_res_zero>:
8000b304:	1c 9b       	mov	r11,lr
8000b306:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b30a:	30 0a       	mov	r10,0
8000b30c:	d8 22       	popm	r4-r7,pc

8000b30e <__avr32_f64_mul_res_nan>:
8000b30e:	3f fb       	mov	r11,-1
8000b310:	3f fa       	mov	r10,-1
8000b312:	d8 22       	popm	r4-r7,pc

8000b314 <__avr32_f64_mul_res_inf>:
8000b314:	f0 6b 00 00 	mov	r11,-1048576
8000b318:	ed be 00 1f 	bld	lr,0x1f
8000b31c:	ef bb 00 1f 	bst	r11,0x1f
8000b320:	30 0a       	mov	r10,0
8000b322:	d8 22       	popm	r4-r7,pc

8000b324 <__avr32_f64_mul_op1_zero>:
8000b324:	f7 e9 20 0b 	eor	r11,r11,r9
8000b328:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b32c:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b330:	e0 4c 07 ff 	cp.w	r12,2047
8000b334:	5e 1c       	retne	r12
8000b336:	3f fa       	mov	r10,-1
8000b338:	3f fb       	mov	r11,-1
8000b33a:	5e fc       	retal	r12

8000b33c <__avr32_f64_sub_from_add>:
8000b33c:	ee 19 80 00 	eorh	r9,0x8000

8000b340 <__avr32_f64_sub>:
8000b340:	f7 e9 20 0c 	eor	r12,r11,r9
8000b344:	e0 86 00 ca 	brmi	8000b4d8 <__avr32_f64_add_from_sub>
8000b348:	eb cd 40 e0 	pushm	r5-r7,lr
8000b34c:	16 9c       	mov	r12,r11
8000b34e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b352:	bf db       	cbr	r11,0x1f
8000b354:	bf d9       	cbr	r9,0x1f
8000b356:	10 3a       	cp.w	r10,r8
8000b358:	f2 0b 13 00 	cpc	r11,r9
8000b35c:	c0 92       	brcc	8000b36e <__avr32_f64_sub+0x2e>
8000b35e:	16 97       	mov	r7,r11
8000b360:	12 9b       	mov	r11,r9
8000b362:	0e 99       	mov	r9,r7
8000b364:	14 97       	mov	r7,r10
8000b366:	10 9a       	mov	r10,r8
8000b368:	0e 98       	mov	r8,r7
8000b36a:	ee 1c 80 00 	eorh	r12,0x8000
8000b36e:	f6 07 16 14 	lsr	r7,r11,0x14
8000b372:	ab 7b       	lsl	r11,0xb
8000b374:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b378:	ab 7a       	lsl	r10,0xb
8000b37a:	bf bb       	sbr	r11,0x1f
8000b37c:	f2 06 16 14 	lsr	r6,r9,0x14
8000b380:	c4 40       	breq	8000b408 <__avr32_f64_sub_opL_subnormal>
8000b382:	ab 79       	lsl	r9,0xb
8000b384:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b388:	ab 78       	lsl	r8,0xb
8000b38a:	bf b9       	sbr	r9,0x1f

8000b38c <__avr32_f64_sub_opL_subnormal_done>:
8000b38c:	e0 47 07 ff 	cp.w	r7,2047
8000b390:	c4 f0       	breq	8000b42e <__avr32_f64_sub_opH_nan_or_inf>
8000b392:	0e 26       	rsub	r6,r7
8000b394:	c1 20       	breq	8000b3b8 <__avr32_f64_sub_shift_done>
8000b396:	ec 05 11 20 	rsub	r5,r6,32
8000b39a:	e0 46 00 20 	cp.w	r6,32
8000b39e:	c7 c2       	brcc	8000b496 <__avr32_f64_sub_longshift>
8000b3a0:	f0 05 09 4e 	lsl	lr,r8,r5
8000b3a4:	f2 05 09 45 	lsl	r5,r9,r5
8000b3a8:	f0 06 0a 48 	lsr	r8,r8,r6
8000b3ac:	f2 06 0a 49 	lsr	r9,r9,r6
8000b3b0:	0a 48       	or	r8,r5
8000b3b2:	58 0e       	cp.w	lr,0
8000b3b4:	5f 1e       	srne	lr
8000b3b6:	1c 48       	or	r8,lr

8000b3b8 <__avr32_f64_sub_shift_done>:
8000b3b8:	10 1a       	sub	r10,r8
8000b3ba:	f6 09 01 4b 	sbc	r11,r11,r9
8000b3be:	f6 06 12 00 	clz	r6,r11
8000b3c2:	c0 e0       	breq	8000b3de <__avr32_f64_sub_longnormalize_done>
8000b3c4:	c7 83       	brcs	8000b4b4 <__avr32_f64_sub_longnormalize>
8000b3c6:	ec 0e 11 20 	rsub	lr,r6,32
8000b3ca:	f6 06 09 4b 	lsl	r11,r11,r6
8000b3ce:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b3d2:	1c 4b       	or	r11,lr
8000b3d4:	f4 06 09 4a 	lsl	r10,r10,r6
8000b3d8:	0c 17       	sub	r7,r6
8000b3da:	e0 8a 00 39 	brle	8000b44c <__avr32_f64_sub_subnormal_result>

8000b3de <__avr32_f64_sub_longnormalize_done>:
8000b3de:	f4 09 15 15 	lsl	r9,r10,0x15
8000b3e2:	ab 9a       	lsr	r10,0xb
8000b3e4:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b3e8:	ab 9b       	lsr	r11,0xb
8000b3ea:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b3ee:	18 4b       	or	r11,r12

8000b3f0 <__avr32_f64_sub_round>:
8000b3f0:	fc 17 80 00 	movh	r7,0x8000
8000b3f4:	ed ba 00 00 	bld	r10,0x0
8000b3f8:	f7 b7 01 ff 	subne	r7,-1
8000b3fc:	0e 39       	cp.w	r9,r7
8000b3fe:	5f 29       	srhs	r9
8000b400:	12 0a       	add	r10,r9
8000b402:	5c 0b       	acr	r11
8000b404:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b408 <__avr32_f64_sub_opL_subnormal>:
8000b408:	ab 79       	lsl	r9,0xb
8000b40a:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b40e:	ab 78       	lsl	r8,0xb
8000b410:	f3 e8 10 0e 	or	lr,r9,r8
8000b414:	f9 b6 01 01 	movne	r6,1
8000b418:	ee 0e 11 00 	rsub	lr,r7,0
8000b41c:	f9 b7 00 01 	moveq	r7,1
8000b420:	ef bb 00 1f 	bst	r11,0x1f
8000b424:	f7 ea 10 0e 	or	lr,r11,r10
8000b428:	f9 b7 00 00 	moveq	r7,0
8000b42c:	cb 0b       	rjmp	8000b38c <__avr32_f64_sub_opL_subnormal_done>

8000b42e <__avr32_f64_sub_opH_nan_or_inf>:
8000b42e:	bf db       	cbr	r11,0x1f
8000b430:	f7 ea 10 0e 	or	lr,r11,r10
8000b434:	c0 81       	brne	8000b444 <__avr32_f64_sub_return_nan>
8000b436:	e0 46 07 ff 	cp.w	r6,2047
8000b43a:	c0 50       	breq	8000b444 <__avr32_f64_sub_return_nan>
8000b43c:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b440:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b444 <__avr32_f64_sub_return_nan>:
8000b444:	3f fa       	mov	r10,-1
8000b446:	3f fb       	mov	r11,-1
8000b448:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b44c <__avr32_f64_sub_subnormal_result>:
8000b44c:	5c 37       	neg	r7
8000b44e:	2f f7       	sub	r7,-1
8000b450:	f1 b7 04 c0 	satu	r7,0x6
8000b454:	e0 47 00 20 	cp.w	r7,32
8000b458:	c1 14       	brge	8000b47a <__avr32_f64_sub_subnormal_result+0x2e>
8000b45a:	ee 08 11 20 	rsub	r8,r7,32
8000b45e:	f4 08 09 49 	lsl	r9,r10,r8
8000b462:	5f 16       	srne	r6
8000b464:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b468:	0c 4a       	or	r10,r6
8000b46a:	f6 08 09 49 	lsl	r9,r11,r8
8000b46e:	f5 e9 10 0a 	or	r10,r10,r9
8000b472:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b476:	30 07       	mov	r7,0
8000b478:	cb 3b       	rjmp	8000b3de <__avr32_f64_sub_longnormalize_done>
8000b47a:	ee 08 11 40 	rsub	r8,r7,64
8000b47e:	f6 08 09 49 	lsl	r9,r11,r8
8000b482:	14 49       	or	r9,r10
8000b484:	5f 16       	srne	r6
8000b486:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b48a:	0c 4a       	or	r10,r6
8000b48c:	30 0b       	mov	r11,0
8000b48e:	30 07       	mov	r7,0
8000b490:	ca 7b       	rjmp	8000b3de <__avr32_f64_sub_longnormalize_done>
8000b492:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b496 <__avr32_f64_sub_longshift>:
8000b496:	f1 b6 04 c0 	satu	r6,0x6
8000b49a:	f0 0e 17 00 	moveq	lr,r8
8000b49e:	c0 40       	breq	8000b4a6 <__avr32_f64_sub_longshift+0x10>
8000b4a0:	f2 05 09 4e 	lsl	lr,r9,r5
8000b4a4:	10 4e       	or	lr,r8
8000b4a6:	f2 06 0a 48 	lsr	r8,r9,r6
8000b4aa:	30 09       	mov	r9,0
8000b4ac:	58 0e       	cp.w	lr,0
8000b4ae:	5f 1e       	srne	lr
8000b4b0:	1c 48       	or	r8,lr
8000b4b2:	c8 3b       	rjmp	8000b3b8 <__avr32_f64_sub_shift_done>

8000b4b4 <__avr32_f64_sub_longnormalize>:
8000b4b4:	f4 06 12 00 	clz	r6,r10
8000b4b8:	f9 b7 03 00 	movlo	r7,0
8000b4bc:	f9 b6 03 00 	movlo	r6,0
8000b4c0:	f9 bc 03 00 	movlo	r12,0
8000b4c4:	f7 b6 02 e0 	subhs	r6,-32
8000b4c8:	f4 06 09 4b 	lsl	r11,r10,r6
8000b4cc:	30 0a       	mov	r10,0
8000b4ce:	0c 17       	sub	r7,r6
8000b4d0:	fe 9a ff be 	brle	8000b44c <__avr32_f64_sub_subnormal_result>
8000b4d4:	c8 5b       	rjmp	8000b3de <__avr32_f64_sub_longnormalize_done>
8000b4d6:	d7 03       	nop

8000b4d8 <__avr32_f64_add_from_sub>:
8000b4d8:	ee 19 80 00 	eorh	r9,0x8000

8000b4dc <__avr32_f64_add>:
8000b4dc:	f7 e9 20 0c 	eor	r12,r11,r9
8000b4e0:	fe 96 ff 2e 	brmi	8000b33c <__avr32_f64_sub_from_add>
8000b4e4:	eb cd 40 e0 	pushm	r5-r7,lr
8000b4e8:	16 9c       	mov	r12,r11
8000b4ea:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b4ee:	bf db       	cbr	r11,0x1f
8000b4f0:	bf d9       	cbr	r9,0x1f
8000b4f2:	12 3b       	cp.w	r11,r9
8000b4f4:	c0 72       	brcc	8000b502 <__avr32_f64_add+0x26>
8000b4f6:	16 97       	mov	r7,r11
8000b4f8:	12 9b       	mov	r11,r9
8000b4fa:	0e 99       	mov	r9,r7
8000b4fc:	14 97       	mov	r7,r10
8000b4fe:	10 9a       	mov	r10,r8
8000b500:	0e 98       	mov	r8,r7
8000b502:	30 0e       	mov	lr,0
8000b504:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b508:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000b50c:	b5 ab       	sbr	r11,0x14
8000b50e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b512:	c6 20       	breq	8000b5d6 <__avr32_f64_add_op2_subnormal>
8000b514:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b518:	b5 a9       	sbr	r9,0x14
8000b51a:	e0 47 07 ff 	cp.w	r7,2047
8000b51e:	c2 80       	breq	8000b56e <__avr32_f64_add_opH_nan_or_inf>
8000b520:	0e 26       	rsub	r6,r7
8000b522:	c1 20       	breq	8000b546 <__avr32_f64_add_shift_done>
8000b524:	e0 46 00 36 	cp.w	r6,54
8000b528:	c1 52       	brcc	8000b552 <__avr32_f64_add_res_of_done>
8000b52a:	ec 05 11 20 	rsub	r5,r6,32
8000b52e:	e0 46 00 20 	cp.w	r6,32
8000b532:	c3 52       	brcc	8000b59c <__avr32_f64_add_longshift>
8000b534:	f0 05 09 4e 	lsl	lr,r8,r5
8000b538:	f2 05 09 45 	lsl	r5,r9,r5
8000b53c:	f0 06 0a 48 	lsr	r8,r8,r6
8000b540:	f2 06 0a 49 	lsr	r9,r9,r6
8000b544:	0a 48       	or	r8,r5

8000b546 <__avr32_f64_add_shift_done>:
8000b546:	10 0a       	add	r10,r8
8000b548:	f6 09 00 4b 	adc	r11,r11,r9
8000b54c:	ed bb 00 15 	bld	r11,0x15
8000b550:	c3 40       	breq	8000b5b8 <__avr32_f64_add_res_of>

8000b552 <__avr32_f64_add_res_of_done>:
8000b552:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b556:	18 4b       	or	r11,r12

8000b558 <__avr32_f64_add_round>:
8000b558:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000b55c:	18 4e       	or	lr,r12
8000b55e:	ee 1e 80 00 	eorh	lr,0x8000
8000b562:	f1 be 04 20 	satu	lr,0x1
8000b566:	1c 0a       	add	r10,lr
8000b568:	5c 0b       	acr	r11
8000b56a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b56e <__avr32_f64_add_opH_nan_or_inf>:
8000b56e:	b5 cb       	cbr	r11,0x14
8000b570:	f7 ea 10 0e 	or	lr,r11,r10
8000b574:	c1 01       	brne	8000b594 <__avr32_f64_add_return_nan>
8000b576:	e0 46 07 ff 	cp.w	r6,2047
8000b57a:	c0 30       	breq	8000b580 <__avr32_f64_add_opL_nan_or_inf>
8000b57c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b580 <__avr32_f64_add_opL_nan_or_inf>:
8000b580:	b5 c9       	cbr	r9,0x14
8000b582:	f3 e8 10 0e 	or	lr,r9,r8
8000b586:	c0 71       	brne	8000b594 <__avr32_f64_add_return_nan>
8000b588:	30 0a       	mov	r10,0
8000b58a:	fc 1b 7f f0 	movh	r11,0x7ff0
8000b58e:	18 4b       	or	r11,r12
8000b590:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b594 <__avr32_f64_add_return_nan>:
8000b594:	3f fa       	mov	r10,-1
8000b596:	3f fb       	mov	r11,-1
8000b598:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b59c <__avr32_f64_add_longshift>:
8000b59c:	f1 b6 04 c0 	satu	r6,0x6
8000b5a0:	f0 0e 17 00 	moveq	lr,r8
8000b5a4:	c0 60       	breq	8000b5b0 <__avr32_f64_add_longshift+0x14>
8000b5a6:	f2 05 09 4e 	lsl	lr,r9,r5
8000b5aa:	58 08       	cp.w	r8,0
8000b5ac:	5f 18       	srne	r8
8000b5ae:	10 4e       	or	lr,r8
8000b5b0:	f2 06 0a 48 	lsr	r8,r9,r6
8000b5b4:	30 09       	mov	r9,0
8000b5b6:	cc 8b       	rjmp	8000b546 <__avr32_f64_add_shift_done>

8000b5b8 <__avr32_f64_add_res_of>:
8000b5b8:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000b5bc:	a1 9b       	lsr	r11,0x1
8000b5be:	5d 0a       	ror	r10
8000b5c0:	5d 0e       	ror	lr
8000b5c2:	2f f7       	sub	r7,-1
8000b5c4:	e0 47 07 ff 	cp.w	r7,2047
8000b5c8:	f9 ba 00 00 	moveq	r10,0
8000b5cc:	f9 bb 00 00 	moveq	r11,0
8000b5d0:	f9 be 00 00 	moveq	lr,0
8000b5d4:	cb fb       	rjmp	8000b552 <__avr32_f64_add_res_of_done>

8000b5d6 <__avr32_f64_add_op2_subnormal>:
8000b5d6:	30 16       	mov	r6,1
8000b5d8:	58 07       	cp.w	r7,0
8000b5da:	ca 01       	brne	8000b51a <__avr32_f64_add+0x3e>
8000b5dc:	b5 cb       	cbr	r11,0x14
8000b5de:	10 0a       	add	r10,r8
8000b5e0:	f6 09 00 4b 	adc	r11,r11,r9
8000b5e4:	18 4b       	or	r11,r12
8000b5e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b5ea:	d7 03       	nop

8000b5ec <__avr32_f64_to_u32>:
8000b5ec:	58 0b       	cp.w	r11,0
8000b5ee:	5e 6d       	retmi	0

8000b5f0 <__avr32_f64_to_s32>:
8000b5f0:	f6 0c 15 01 	lsl	r12,r11,0x1
8000b5f4:	b5 9c       	lsr	r12,0x15
8000b5f6:	e0 2c 03 ff 	sub	r12,1023
8000b5fa:	5e 3d       	retlo	0
8000b5fc:	f8 0c 11 1f 	rsub	r12,r12,31
8000b600:	16 99       	mov	r9,r11
8000b602:	ab 7b       	lsl	r11,0xb
8000b604:	bf bb       	sbr	r11,0x1f
8000b606:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b60a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b60e:	a1 79       	lsl	r9,0x1
8000b610:	5e 2b       	reths	r11
8000b612:	5c 3b       	neg	r11
8000b614:	5e fb       	retal	r11

8000b616 <__avr32_u32_to_f64>:
8000b616:	f8 cb 00 00 	sub	r11,r12,0
8000b61a:	30 0c       	mov	r12,0
8000b61c:	c0 38       	rjmp	8000b622 <__avr32_s32_to_f64+0x4>

8000b61e <__avr32_s32_to_f64>:
8000b61e:	18 9b       	mov	r11,r12
8000b620:	5c 4b       	abs	r11
8000b622:	30 0a       	mov	r10,0
8000b624:	5e 0b       	reteq	r11
8000b626:	d4 01       	pushm	lr
8000b628:	e0 69 04 1e 	mov	r9,1054
8000b62c:	f6 08 12 00 	clz	r8,r11
8000b630:	c1 70       	breq	8000b65e <__avr32_s32_to_f64+0x40>
8000b632:	c0 c3       	brcs	8000b64a <__avr32_s32_to_f64+0x2c>
8000b634:	f0 0e 11 20 	rsub	lr,r8,32
8000b638:	f6 08 09 4b 	lsl	r11,r11,r8
8000b63c:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b640:	1c 4b       	or	r11,lr
8000b642:	f4 08 09 4a 	lsl	r10,r10,r8
8000b646:	10 19       	sub	r9,r8
8000b648:	c0 b8       	rjmp	8000b65e <__avr32_s32_to_f64+0x40>
8000b64a:	f4 08 12 00 	clz	r8,r10
8000b64e:	f9 b8 03 00 	movlo	r8,0
8000b652:	f7 b8 02 e0 	subhs	r8,-32
8000b656:	f4 08 09 4b 	lsl	r11,r10,r8
8000b65a:	30 0a       	mov	r10,0
8000b65c:	10 19       	sub	r9,r8
8000b65e:	58 09       	cp.w	r9,0
8000b660:	e0 89 00 30 	brgt	8000b6c0 <__avr32_s32_to_f64+0xa2>
8000b664:	5c 39       	neg	r9
8000b666:	2f f9       	sub	r9,-1
8000b668:	e0 49 00 36 	cp.w	r9,54
8000b66c:	c0 43       	brcs	8000b674 <__avr32_s32_to_f64+0x56>
8000b66e:	30 0b       	mov	r11,0
8000b670:	30 0a       	mov	r10,0
8000b672:	c2 68       	rjmp	8000b6be <__avr32_s32_to_f64+0xa0>
8000b674:	2f 69       	sub	r9,-10
8000b676:	f2 08 11 20 	rsub	r8,r9,32
8000b67a:	e0 49 00 20 	cp.w	r9,32
8000b67e:	c0 b2       	brcc	8000b694 <__avr32_s32_to_f64+0x76>
8000b680:	f4 08 09 4e 	lsl	lr,r10,r8
8000b684:	f6 08 09 48 	lsl	r8,r11,r8
8000b688:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b68c:	f6 09 0a 4b 	lsr	r11,r11,r9
8000b690:	10 4b       	or	r11,r8
8000b692:	c0 88       	rjmp	8000b6a2 <__avr32_s32_to_f64+0x84>
8000b694:	f6 08 09 4e 	lsl	lr,r11,r8
8000b698:	14 4e       	or	lr,r10
8000b69a:	16 9a       	mov	r10,r11
8000b69c:	30 0b       	mov	r11,0
8000b69e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b6a2:	ed ba 00 00 	bld	r10,0x0
8000b6a6:	c0 92       	brcc	8000b6b8 <__avr32_s32_to_f64+0x9a>
8000b6a8:	1c 7e       	tst	lr,lr
8000b6aa:	c0 41       	brne	8000b6b2 <__avr32_s32_to_f64+0x94>
8000b6ac:	ed ba 00 01 	bld	r10,0x1
8000b6b0:	c0 42       	brcc	8000b6b8 <__avr32_s32_to_f64+0x9a>
8000b6b2:	2f fa       	sub	r10,-1
8000b6b4:	f7 bb 02 ff 	subhs	r11,-1
8000b6b8:	5c fc       	rol	r12
8000b6ba:	5d 0b       	ror	r11
8000b6bc:	5d 0a       	ror	r10
8000b6be:	d8 02       	popm	pc
8000b6c0:	e0 68 03 ff 	mov	r8,1023
8000b6c4:	ed ba 00 0b 	bld	r10,0xb
8000b6c8:	f7 b8 00 ff 	subeq	r8,-1
8000b6cc:	10 0a       	add	r10,r8
8000b6ce:	5c 0b       	acr	r11
8000b6d0:	f7 b9 03 fe 	sublo	r9,-2
8000b6d4:	e0 49 07 ff 	cp.w	r9,2047
8000b6d8:	c0 55       	brlt	8000b6e2 <__avr32_s32_to_f64+0xc4>
8000b6da:	30 0a       	mov	r10,0
8000b6dc:	fc 1b ff e0 	movh	r11,0xffe0
8000b6e0:	c0 c8       	rjmp	8000b6f8 <__floatsidf_return_op1>
8000b6e2:	ed bb 00 1f 	bld	r11,0x1f
8000b6e6:	f7 b9 01 01 	subne	r9,1
8000b6ea:	ab 9a       	lsr	r10,0xb
8000b6ec:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b6f0:	a1 7b       	lsl	r11,0x1
8000b6f2:	ab 9b       	lsr	r11,0xb
8000b6f4:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000b6f8 <__floatsidf_return_op1>:
8000b6f8:	a1 7c       	lsl	r12,0x1
8000b6fa:	5d 0b       	ror	r11
8000b6fc:	d8 02       	popm	pc

8000b6fe <__avr32_f64_cmp_eq>:
8000b6fe:	10 3a       	cp.w	r10,r8
8000b700:	f2 0b 13 00 	cpc	r11,r9
8000b704:	c0 80       	breq	8000b714 <__avr32_f64_cmp_eq+0x16>
8000b706:	a1 7b       	lsl	r11,0x1
8000b708:	a1 79       	lsl	r9,0x1
8000b70a:	14 4b       	or	r11,r10
8000b70c:	12 4b       	or	r11,r9
8000b70e:	10 4b       	or	r11,r8
8000b710:	5e 0f       	reteq	1
8000b712:	5e fd       	retal	0
8000b714:	a1 7b       	lsl	r11,0x1
8000b716:	fc 1c ff e0 	movh	r12,0xffe0
8000b71a:	58 0a       	cp.w	r10,0
8000b71c:	f8 0b 13 00 	cpc	r11,r12
8000b720:	5e 8f       	retls	1
8000b722:	5e fd       	retal	0

8000b724 <__avr32_f64_cmp_ge>:
8000b724:	1a de       	st.w	--sp,lr
8000b726:	1a d7       	st.w	--sp,r7
8000b728:	a1 7b       	lsl	r11,0x1
8000b72a:	5f 3c       	srlo	r12
8000b72c:	a1 79       	lsl	r9,0x1
8000b72e:	5f 37       	srlo	r7
8000b730:	5c fc       	rol	r12
8000b732:	fc 1e ff e0 	movh	lr,0xffe0
8000b736:	58 0a       	cp.w	r10,0
8000b738:	fc 0b 13 00 	cpc	r11,lr
8000b73c:	e0 8b 00 1d 	brhi	8000b776 <__avr32_f64_cmp_ge+0x52>
8000b740:	58 08       	cp.w	r8,0
8000b742:	fc 09 13 00 	cpc	r9,lr
8000b746:	e0 8b 00 18 	brhi	8000b776 <__avr32_f64_cmp_ge+0x52>
8000b74a:	58 0b       	cp.w	r11,0
8000b74c:	f5 ba 00 00 	subfeq	r10,0
8000b750:	c1 50       	breq	8000b77a <__avr32_f64_cmp_ge+0x56>
8000b752:	1b 07       	ld.w	r7,sp++
8000b754:	1b 0e       	ld.w	lr,sp++
8000b756:	58 3c       	cp.w	r12,3
8000b758:	c0 a0       	breq	8000b76c <__avr32_f64_cmp_ge+0x48>
8000b75a:	58 1c       	cp.w	r12,1
8000b75c:	c0 33       	brcs	8000b762 <__avr32_f64_cmp_ge+0x3e>
8000b75e:	5e 0f       	reteq	1
8000b760:	5e 1d       	retne	0
8000b762:	10 3a       	cp.w	r10,r8
8000b764:	f2 0b 13 00 	cpc	r11,r9
8000b768:	5e 2f       	reths	1
8000b76a:	5e 3d       	retlo	0
8000b76c:	14 38       	cp.w	r8,r10
8000b76e:	f6 09 13 00 	cpc	r9,r11
8000b772:	5e 2f       	reths	1
8000b774:	5e 3d       	retlo	0
8000b776:	1b 07       	ld.w	r7,sp++
8000b778:	d8 0a       	popm	pc,r12=0
8000b77a:	58 17       	cp.w	r7,1
8000b77c:	5f 0c       	sreq	r12
8000b77e:	58 09       	cp.w	r9,0
8000b780:	f5 b8 00 00 	subfeq	r8,0
8000b784:	1b 07       	ld.w	r7,sp++
8000b786:	1b 0e       	ld.w	lr,sp++
8000b788:	5e 0f       	reteq	1
8000b78a:	5e fc       	retal	r12

8000b78c <__avr32_f64_cmp_lt>:
8000b78c:	1a de       	st.w	--sp,lr
8000b78e:	1a d7       	st.w	--sp,r7
8000b790:	a1 7b       	lsl	r11,0x1
8000b792:	5f 3c       	srlo	r12
8000b794:	a1 79       	lsl	r9,0x1
8000b796:	5f 37       	srlo	r7
8000b798:	5c fc       	rol	r12
8000b79a:	fc 1e ff e0 	movh	lr,0xffe0
8000b79e:	58 0a       	cp.w	r10,0
8000b7a0:	fc 0b 13 00 	cpc	r11,lr
8000b7a4:	e0 8b 00 1d 	brhi	8000b7de <__avr32_f64_cmp_lt+0x52>
8000b7a8:	58 08       	cp.w	r8,0
8000b7aa:	fc 09 13 00 	cpc	r9,lr
8000b7ae:	e0 8b 00 18 	brhi	8000b7de <__avr32_f64_cmp_lt+0x52>
8000b7b2:	58 0b       	cp.w	r11,0
8000b7b4:	f5 ba 00 00 	subfeq	r10,0
8000b7b8:	c1 50       	breq	8000b7e2 <__avr32_f64_cmp_lt+0x56>
8000b7ba:	1b 07       	ld.w	r7,sp++
8000b7bc:	1b 0e       	ld.w	lr,sp++
8000b7be:	58 3c       	cp.w	r12,3
8000b7c0:	c0 a0       	breq	8000b7d4 <__avr32_f64_cmp_lt+0x48>
8000b7c2:	58 1c       	cp.w	r12,1
8000b7c4:	c0 33       	brcs	8000b7ca <__avr32_f64_cmp_lt+0x3e>
8000b7c6:	5e 0d       	reteq	0
8000b7c8:	5e 1f       	retne	1
8000b7ca:	10 3a       	cp.w	r10,r8
8000b7cc:	f2 0b 13 00 	cpc	r11,r9
8000b7d0:	5e 2d       	reths	0
8000b7d2:	5e 3f       	retlo	1
8000b7d4:	14 38       	cp.w	r8,r10
8000b7d6:	f6 09 13 00 	cpc	r9,r11
8000b7da:	5e 2d       	reths	0
8000b7dc:	5e 3f       	retlo	1
8000b7de:	1b 07       	ld.w	r7,sp++
8000b7e0:	d8 0a       	popm	pc,r12=0
8000b7e2:	58 17       	cp.w	r7,1
8000b7e4:	5f 1c       	srne	r12
8000b7e6:	58 09       	cp.w	r9,0
8000b7e8:	f5 b8 00 00 	subfeq	r8,0
8000b7ec:	1b 07       	ld.w	r7,sp++
8000b7ee:	1b 0e       	ld.w	lr,sp++
8000b7f0:	5e 0d       	reteq	0
8000b7f2:	5e fc       	retal	r12

8000b7f4 <__avr32_f64_div>:
8000b7f4:	eb cd 40 ff 	pushm	r0-r7,lr
8000b7f8:	f7 e9 20 0e 	eor	lr,r11,r9
8000b7fc:	f6 07 16 14 	lsr	r7,r11,0x14
8000b800:	a9 7b       	lsl	r11,0x9
8000b802:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000b806:	a9 7a       	lsl	r10,0x9
8000b808:	bd bb       	sbr	r11,0x1d
8000b80a:	e4 1b 3f ff 	andh	r11,0x3fff
8000b80e:	ab d7       	cbr	r7,0xb
8000b810:	e0 80 00 cc 	breq	8000b9a8 <__avr32_f64_div_round_subnormal+0x54>
8000b814:	e0 47 07 ff 	cp.w	r7,2047
8000b818:	e0 84 00 b5 	brge	8000b982 <__avr32_f64_div_round_subnormal+0x2e>
8000b81c:	f2 06 16 14 	lsr	r6,r9,0x14
8000b820:	a9 79       	lsl	r9,0x9
8000b822:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000b826:	a9 78       	lsl	r8,0x9
8000b828:	bd b9       	sbr	r9,0x1d
8000b82a:	e4 19 3f ff 	andh	r9,0x3fff
8000b82e:	ab d6       	cbr	r6,0xb
8000b830:	e0 80 00 e2 	breq	8000b9f4 <__avr32_f64_div_round_subnormal+0xa0>
8000b834:	e0 46 07 ff 	cp.w	r6,2047
8000b838:	e0 84 00 b2 	brge	8000b99c <__avr32_f64_div_round_subnormal+0x48>
8000b83c:	0c 17       	sub	r7,r6
8000b83e:	fe 37 fc 01 	sub	r7,-1023
8000b842:	fc 1c 80 00 	movh	r12,0x8000
8000b846:	f8 03 16 01 	lsr	r3,r12,0x1
8000b84a:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000b84e:	5c d4       	com	r4
8000b850:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000b854:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b858:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b85c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b860:	ea 03 15 02 	lsl	r3,r5,0x2
8000b864:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b868:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b86c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b870:	ea 03 15 02 	lsl	r3,r5,0x2
8000b874:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b878:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b87c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b880:	ea 03 15 02 	lsl	r3,r5,0x2
8000b884:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b888:	e4 09 07 40 	macu.d	r0,r2,r9
8000b88c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b890:	02 04       	add	r4,r1
8000b892:	5c 05       	acr	r5
8000b894:	a3 65       	lsl	r5,0x2
8000b896:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b89a:	a3 64       	lsl	r4,0x2
8000b89c:	5c 34       	neg	r4
8000b89e:	f8 05 01 45 	sbc	r5,r12,r5
8000b8a2:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b8a6:	e4 05 07 40 	macu.d	r0,r2,r5
8000b8aa:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b8ae:	02 04       	add	r4,r1
8000b8b0:	5c 05       	acr	r5
8000b8b2:	ea 03 15 02 	lsl	r3,r5,0x2
8000b8b6:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b8ba:	e8 02 15 02 	lsl	r2,r4,0x2
8000b8be:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b8c2:	e4 09 07 40 	macu.d	r0,r2,r9
8000b8c6:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b8ca:	02 04       	add	r4,r1
8000b8cc:	5c 05       	acr	r5
8000b8ce:	a3 65       	lsl	r5,0x2
8000b8d0:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b8d4:	a3 64       	lsl	r4,0x2
8000b8d6:	5c 34       	neg	r4
8000b8d8:	f8 05 01 45 	sbc	r5,r12,r5
8000b8dc:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b8e0:	e4 05 07 40 	macu.d	r0,r2,r5
8000b8e4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b8e8:	02 04       	add	r4,r1
8000b8ea:	5c 05       	acr	r5
8000b8ec:	ea 03 15 02 	lsl	r3,r5,0x2
8000b8f0:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b8f4:	e8 02 15 02 	lsl	r2,r4,0x2
8000b8f8:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000b8fc:	e4 0b 07 40 	macu.d	r0,r2,r11
8000b900:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000b904:	02 02       	add	r2,r1
8000b906:	5c 03       	acr	r3
8000b908:	ed b3 00 1c 	bld	r3,0x1c
8000b90c:	c0 90       	breq	8000b91e <__avr32_f64_div+0x12a>
8000b90e:	a1 72       	lsl	r2,0x1
8000b910:	5c f3       	rol	r3
8000b912:	20 17       	sub	r7,1
8000b914:	a3 9a       	lsr	r10,0x3
8000b916:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000b91a:	a3 9b       	lsr	r11,0x3
8000b91c:	c0 58       	rjmp	8000b926 <__avr32_f64_div+0x132>
8000b91e:	a5 8a       	lsr	r10,0x4
8000b920:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000b924:	a5 8b       	lsr	r11,0x4
8000b926:	58 07       	cp.w	r7,0
8000b928:	e0 8a 00 8b 	brle	8000ba3e <__avr32_f64_div_res_subnormal>
8000b92c:	e0 12 ff 00 	andl	r2,0xff00
8000b930:	e8 12 00 80 	orl	r2,0x80
8000b934:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b938:	e4 09 07 40 	macu.d	r0,r2,r9
8000b93c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b940:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b944:	00 05       	add	r5,r0
8000b946:	f0 01 00 48 	adc	r8,r8,r1
8000b94a:	5c 09       	acr	r9
8000b94c:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b950:	58 04       	cp.w	r4,0
8000b952:	5c 25       	cpc	r5

8000b954 <__avr32_f64_div_round_subnormal>:
8000b954:	f4 08 13 00 	cpc	r8,r10
8000b958:	f6 09 13 00 	cpc	r9,r11
8000b95c:	5f 36       	srlo	r6
8000b95e:	f8 06 17 00 	moveq	r6,r12
8000b962:	e4 0a 16 08 	lsr	r10,r2,0x8
8000b966:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000b96a:	e6 0b 16 08 	lsr	r11,r3,0x8
8000b96e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b972:	ed be 00 1f 	bld	lr,0x1f
8000b976:	ef bb 00 1f 	bst	r11,0x1f
8000b97a:	0c 0a       	add	r10,r6
8000b97c:	5c 0b       	acr	r11
8000b97e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b982:	e4 1b 00 0f 	andh	r11,0xf
8000b986:	14 4b       	or	r11,r10
8000b988:	e0 81 00 a7 	brne	8000bad6 <__avr32_f64_div_res_subnormal+0x98>
8000b98c:	f2 06 16 14 	lsr	r6,r9,0x14
8000b990:	ab d6       	cbr	r6,0xb
8000b992:	e0 46 07 ff 	cp.w	r6,2047
8000b996:	e0 81 00 a4 	brne	8000bade <__avr32_f64_div_res_subnormal+0xa0>
8000b99a:	c9 e8       	rjmp	8000bad6 <__avr32_f64_div_res_subnormal+0x98>
8000b99c:	e4 19 00 0f 	andh	r9,0xf
8000b9a0:	10 49       	or	r9,r8
8000b9a2:	e0 81 00 9a 	brne	8000bad6 <__avr32_f64_div_res_subnormal+0x98>
8000b9a6:	c9 28       	rjmp	8000baca <__avr32_f64_div_res_subnormal+0x8c>
8000b9a8:	a3 7b       	lsl	r11,0x3
8000b9aa:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000b9ae:	a3 7a       	lsl	r10,0x3
8000b9b0:	f5 eb 10 04 	or	r4,r10,r11
8000b9b4:	e0 80 00 a0 	breq	8000baf4 <__avr32_f64_div_op1_zero>
8000b9b8:	f6 04 12 00 	clz	r4,r11
8000b9bc:	c1 70       	breq	8000b9ea <__avr32_f64_div_round_subnormal+0x96>
8000b9be:	c0 c3       	brcs	8000b9d6 <__avr32_f64_div_round_subnormal+0x82>
8000b9c0:	e8 05 11 20 	rsub	r5,r4,32
8000b9c4:	f6 04 09 4b 	lsl	r11,r11,r4
8000b9c8:	f4 05 0a 45 	lsr	r5,r10,r5
8000b9cc:	0a 4b       	or	r11,r5
8000b9ce:	f4 04 09 4a 	lsl	r10,r10,r4
8000b9d2:	08 17       	sub	r7,r4
8000b9d4:	c0 b8       	rjmp	8000b9ea <__avr32_f64_div_round_subnormal+0x96>
8000b9d6:	f4 04 12 00 	clz	r4,r10
8000b9da:	f9 b4 03 00 	movlo	r4,0
8000b9de:	f7 b4 02 e0 	subhs	r4,-32
8000b9e2:	f4 04 09 4b 	lsl	r11,r10,r4
8000b9e6:	30 0a       	mov	r10,0
8000b9e8:	08 17       	sub	r7,r4
8000b9ea:	a3 8a       	lsr	r10,0x2
8000b9ec:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000b9f0:	a3 8b       	lsr	r11,0x2
8000b9f2:	c1 1b       	rjmp	8000b814 <__avr32_f64_div+0x20>
8000b9f4:	a3 79       	lsl	r9,0x3
8000b9f6:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000b9fa:	a3 78       	lsl	r8,0x3
8000b9fc:	f3 e8 10 04 	or	r4,r9,r8
8000ba00:	c6 f0       	breq	8000bade <__avr32_f64_div_res_subnormal+0xa0>
8000ba02:	f2 04 12 00 	clz	r4,r9
8000ba06:	c1 70       	breq	8000ba34 <__avr32_f64_div_round_subnormal+0xe0>
8000ba08:	c0 c3       	brcs	8000ba20 <__avr32_f64_div_round_subnormal+0xcc>
8000ba0a:	e8 05 11 20 	rsub	r5,r4,32
8000ba0e:	f2 04 09 49 	lsl	r9,r9,r4
8000ba12:	f0 05 0a 45 	lsr	r5,r8,r5
8000ba16:	0a 49       	or	r9,r5
8000ba18:	f0 04 09 48 	lsl	r8,r8,r4
8000ba1c:	08 16       	sub	r6,r4
8000ba1e:	c0 b8       	rjmp	8000ba34 <__avr32_f64_div_round_subnormal+0xe0>
8000ba20:	f0 04 12 00 	clz	r4,r8
8000ba24:	f9 b4 03 00 	movlo	r4,0
8000ba28:	f7 b4 02 e0 	subhs	r4,-32
8000ba2c:	f0 04 09 49 	lsl	r9,r8,r4
8000ba30:	30 08       	mov	r8,0
8000ba32:	08 16       	sub	r6,r4
8000ba34:	a3 88       	lsr	r8,0x2
8000ba36:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000ba3a:	a3 89       	lsr	r9,0x2
8000ba3c:	cf ca       	rjmp	8000b834 <__avr32_f64_div+0x40>

8000ba3e <__avr32_f64_div_res_subnormal>:
8000ba3e:	5c 37       	neg	r7
8000ba40:	2f f7       	sub	r7,-1
8000ba42:	f1 b7 04 c0 	satu	r7,0x6
8000ba46:	e0 47 00 20 	cp.w	r7,32
8000ba4a:	c1 54       	brge	8000ba74 <__avr32_f64_div_res_subnormal+0x36>
8000ba4c:	ee 06 11 20 	rsub	r6,r7,32
8000ba50:	e4 07 0a 42 	lsr	r2,r2,r7
8000ba54:	e6 06 09 4c 	lsl	r12,r3,r6
8000ba58:	18 42       	or	r2,r12
8000ba5a:	e6 07 0a 43 	lsr	r3,r3,r7
8000ba5e:	f4 06 09 41 	lsl	r1,r10,r6
8000ba62:	f4 07 0a 4a 	lsr	r10,r10,r7
8000ba66:	f6 06 09 4c 	lsl	r12,r11,r6
8000ba6a:	18 4a       	or	r10,r12
8000ba6c:	f6 07 0a 4b 	lsr	r11,r11,r7
8000ba70:	30 00       	mov	r0,0
8000ba72:	c1 58       	rjmp	8000ba9c <__avr32_f64_div_res_subnormal+0x5e>
8000ba74:	ee 06 11 20 	rsub	r6,r7,32
8000ba78:	f9 b0 00 00 	moveq	r0,0
8000ba7c:	f9 bc 00 00 	moveq	r12,0
8000ba80:	c0 50       	breq	8000ba8a <__avr32_f64_div_res_subnormal+0x4c>
8000ba82:	f4 06 09 40 	lsl	r0,r10,r6
8000ba86:	f6 06 09 4c 	lsl	r12,r11,r6
8000ba8a:	e6 07 0a 42 	lsr	r2,r3,r7
8000ba8e:	30 03       	mov	r3,0
8000ba90:	f4 07 0a 41 	lsr	r1,r10,r7
8000ba94:	18 41       	or	r1,r12
8000ba96:	f6 07 0a 4a 	lsr	r10,r11,r7
8000ba9a:	30 0b       	mov	r11,0
8000ba9c:	e0 12 ff 00 	andl	r2,0xff00
8000baa0:	e8 12 00 80 	orl	r2,0x80
8000baa4:	e6 08 06 46 	mulu.d	r6,r3,r8
8000baa8:	e4 09 07 46 	macu.d	r6,r2,r9
8000baac:	e4 08 06 44 	mulu.d	r4,r2,r8
8000bab0:	e6 09 06 48 	mulu.d	r8,r3,r9
8000bab4:	0c 05       	add	r5,r6
8000bab6:	f0 07 00 48 	adc	r8,r8,r7
8000baba:	5c 09       	acr	r9
8000babc:	30 07       	mov	r7,0
8000babe:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000bac2:	00 34       	cp.w	r4,r0
8000bac4:	e2 05 13 00 	cpc	r5,r1
8000bac8:	c4 6b       	rjmp	8000b954 <__avr32_f64_div_round_subnormal>
8000baca:	1c 9b       	mov	r11,lr
8000bacc:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bad0:	30 0a       	mov	r10,0
8000bad2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bad6:	3f fb       	mov	r11,-1
8000bad8:	30 0a       	mov	r10,0
8000bada:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bade:	f5 eb 10 04 	or	r4,r10,r11
8000bae2:	c0 90       	breq	8000baf4 <__avr32_f64_div_op1_zero>
8000bae4:	1c 9b       	mov	r11,lr
8000bae6:	e6 1b 80 00 	andh	r11,0x8000,COH
8000baea:	ea 1b 7f f0 	orh	r11,0x7ff0
8000baee:	30 0a       	mov	r10,0
8000baf0:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000baf4 <__avr32_f64_div_op1_zero>:
8000baf4:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000baf8:	ce f0       	breq	8000bad6 <__avr32_f64_div_res_subnormal+0x98>
8000bafa:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000bafe:	e0 44 07 ff 	cp.w	r4,2047
8000bb02:	ce 41       	brne	8000baca <__avr32_f64_div_res_subnormal+0x8c>
8000bb04:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000bb08:	ce 10       	breq	8000baca <__avr32_f64_div_res_subnormal+0x8c>
8000bb0a:	ce 6b       	rjmp	8000bad6 <__avr32_f64_div_res_subnormal+0x98>

8000bb0c <__avr32_udiv64>:
8000bb0c:	d4 31       	pushm	r0-r7,lr
8000bb0e:	1a 97       	mov	r7,sp
8000bb10:	20 3d       	sub	sp,12
8000bb12:	10 9c       	mov	r12,r8
8000bb14:	12 9e       	mov	lr,r9
8000bb16:	14 93       	mov	r3,r10
8000bb18:	58 09       	cp.w	r9,0
8000bb1a:	e0 81 00 bd 	brne	8000bc94 <__avr32_udiv64+0x188>
8000bb1e:	16 38       	cp.w	r8,r11
8000bb20:	e0 88 00 40 	brls	8000bba0 <__avr32_udiv64+0x94>
8000bb24:	f0 08 12 00 	clz	r8,r8
8000bb28:	c0 d0       	breq	8000bb42 <__avr32_udiv64+0x36>
8000bb2a:	f6 08 09 4b 	lsl	r11,r11,r8
8000bb2e:	f0 09 11 20 	rsub	r9,r8,32
8000bb32:	f8 08 09 4c 	lsl	r12,r12,r8
8000bb36:	f4 09 0a 49 	lsr	r9,r10,r9
8000bb3a:	f4 08 09 43 	lsl	r3,r10,r8
8000bb3e:	f3 eb 10 0b 	or	r11,r9,r11
8000bb42:	f8 0e 16 10 	lsr	lr,r12,0x10
8000bb46:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000bb4a:	f6 0e 0d 00 	divu	r0,r11,lr
8000bb4e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000bb52:	00 99       	mov	r9,r0
8000bb54:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bb58:	e0 0a 02 48 	mul	r8,r0,r10
8000bb5c:	10 3b       	cp.w	r11,r8
8000bb5e:	c0 a2       	brcc	8000bb72 <__avr32_udiv64+0x66>
8000bb60:	20 19       	sub	r9,1
8000bb62:	18 0b       	add	r11,r12
8000bb64:	18 3b       	cp.w	r11,r12
8000bb66:	c0 63       	brcs	8000bb72 <__avr32_udiv64+0x66>
8000bb68:	10 3b       	cp.w	r11,r8
8000bb6a:	f7 b9 03 01 	sublo	r9,1
8000bb6e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bb72:	f6 08 01 01 	sub	r1,r11,r8
8000bb76:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000bb7a:	e2 0e 0d 00 	divu	r0,r1,lr
8000bb7e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000bb82:	00 98       	mov	r8,r0
8000bb84:	e0 0a 02 4a 	mul	r10,r0,r10
8000bb88:	14 33       	cp.w	r3,r10
8000bb8a:	c0 82       	brcc	8000bb9a <__avr32_udiv64+0x8e>
8000bb8c:	20 18       	sub	r8,1
8000bb8e:	18 03       	add	r3,r12
8000bb90:	18 33       	cp.w	r3,r12
8000bb92:	c0 43       	brcs	8000bb9a <__avr32_udiv64+0x8e>
8000bb94:	14 33       	cp.w	r3,r10
8000bb96:	f7 b8 03 01 	sublo	r8,1
8000bb9a:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000bb9e:	cd f8       	rjmp	8000bd5c <__avr32_udiv64+0x250>
8000bba0:	58 08       	cp.w	r8,0
8000bba2:	c0 51       	brne	8000bbac <__avr32_udiv64+0xa0>
8000bba4:	30 19       	mov	r9,1
8000bba6:	f2 08 0d 08 	divu	r8,r9,r8
8000bbaa:	10 9c       	mov	r12,r8
8000bbac:	f8 06 12 00 	clz	r6,r12
8000bbb0:	c0 41       	brne	8000bbb8 <__avr32_udiv64+0xac>
8000bbb2:	18 1b       	sub	r11,r12
8000bbb4:	30 19       	mov	r9,1
8000bbb6:	c4 08       	rjmp	8000bc36 <__avr32_udiv64+0x12a>
8000bbb8:	ec 01 11 20 	rsub	r1,r6,32
8000bbbc:	f4 01 0a 49 	lsr	r9,r10,r1
8000bbc0:	f8 06 09 4c 	lsl	r12,r12,r6
8000bbc4:	f6 06 09 48 	lsl	r8,r11,r6
8000bbc8:	f6 01 0a 41 	lsr	r1,r11,r1
8000bbcc:	f3 e8 10 08 	or	r8,r9,r8
8000bbd0:	f8 03 16 10 	lsr	r3,r12,0x10
8000bbd4:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000bbd8:	e2 03 0d 00 	divu	r0,r1,r3
8000bbdc:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bbe0:	00 9e       	mov	lr,r0
8000bbe2:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bbe6:	e0 05 02 49 	mul	r9,r0,r5
8000bbea:	12 3b       	cp.w	r11,r9
8000bbec:	c0 a2       	brcc	8000bc00 <__avr32_udiv64+0xf4>
8000bbee:	20 1e       	sub	lr,1
8000bbf0:	18 0b       	add	r11,r12
8000bbf2:	18 3b       	cp.w	r11,r12
8000bbf4:	c0 63       	brcs	8000bc00 <__avr32_udiv64+0xf4>
8000bbf6:	12 3b       	cp.w	r11,r9
8000bbf8:	f7 be 03 01 	sublo	lr,1
8000bbfc:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bc00:	12 1b       	sub	r11,r9
8000bc02:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000bc06:	f6 03 0d 02 	divu	r2,r11,r3
8000bc0a:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000bc0e:	04 99       	mov	r9,r2
8000bc10:	e4 05 02 4b 	mul	r11,r2,r5
8000bc14:	16 38       	cp.w	r8,r11
8000bc16:	c0 a2       	brcc	8000bc2a <__avr32_udiv64+0x11e>
8000bc18:	20 19       	sub	r9,1
8000bc1a:	18 08       	add	r8,r12
8000bc1c:	18 38       	cp.w	r8,r12
8000bc1e:	c0 63       	brcs	8000bc2a <__avr32_udiv64+0x11e>
8000bc20:	16 38       	cp.w	r8,r11
8000bc22:	f7 b9 03 01 	sublo	r9,1
8000bc26:	f1 dc e3 08 	addcs	r8,r8,r12
8000bc2a:	f4 06 09 43 	lsl	r3,r10,r6
8000bc2e:	f0 0b 01 0b 	sub	r11,r8,r11
8000bc32:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000bc36:	f8 06 16 10 	lsr	r6,r12,0x10
8000bc3a:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000bc3e:	f6 06 0d 00 	divu	r0,r11,r6
8000bc42:	e6 0b 16 10 	lsr	r11,r3,0x10
8000bc46:	00 9a       	mov	r10,r0
8000bc48:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bc4c:	e0 0e 02 48 	mul	r8,r0,lr
8000bc50:	10 3b       	cp.w	r11,r8
8000bc52:	c0 a2       	brcc	8000bc66 <__avr32_udiv64+0x15a>
8000bc54:	20 1a       	sub	r10,1
8000bc56:	18 0b       	add	r11,r12
8000bc58:	18 3b       	cp.w	r11,r12
8000bc5a:	c0 63       	brcs	8000bc66 <__avr32_udiv64+0x15a>
8000bc5c:	10 3b       	cp.w	r11,r8
8000bc5e:	f7 ba 03 01 	sublo	r10,1
8000bc62:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bc66:	f6 08 01 01 	sub	r1,r11,r8
8000bc6a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000bc6e:	e2 06 0d 00 	divu	r0,r1,r6
8000bc72:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000bc76:	00 98       	mov	r8,r0
8000bc78:	e0 0e 02 4b 	mul	r11,r0,lr
8000bc7c:	16 33       	cp.w	r3,r11
8000bc7e:	c0 82       	brcc	8000bc8e <__avr32_udiv64+0x182>
8000bc80:	20 18       	sub	r8,1
8000bc82:	18 03       	add	r3,r12
8000bc84:	18 33       	cp.w	r3,r12
8000bc86:	c0 43       	brcs	8000bc8e <__avr32_udiv64+0x182>
8000bc88:	16 33       	cp.w	r3,r11
8000bc8a:	f7 b8 03 01 	sublo	r8,1
8000bc8e:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000bc92:	c6 98       	rjmp	8000bd64 <__avr32_udiv64+0x258>
8000bc94:	16 39       	cp.w	r9,r11
8000bc96:	e0 8b 00 65 	brhi	8000bd60 <__avr32_udiv64+0x254>
8000bc9a:	f2 09 12 00 	clz	r9,r9
8000bc9e:	c0 b1       	brne	8000bcb4 <__avr32_udiv64+0x1a8>
8000bca0:	10 3a       	cp.w	r10,r8
8000bca2:	5f 2a       	srhs	r10
8000bca4:	1c 3b       	cp.w	r11,lr
8000bca6:	5f b8       	srhi	r8
8000bca8:	10 4a       	or	r10,r8
8000bcaa:	f2 0a 18 00 	cp.b	r10,r9
8000bcae:	c5 90       	breq	8000bd60 <__avr32_udiv64+0x254>
8000bcb0:	30 18       	mov	r8,1
8000bcb2:	c5 98       	rjmp	8000bd64 <__avr32_udiv64+0x258>
8000bcb4:	f0 09 09 46 	lsl	r6,r8,r9
8000bcb8:	f2 03 11 20 	rsub	r3,r9,32
8000bcbc:	fc 09 09 4e 	lsl	lr,lr,r9
8000bcc0:	f0 03 0a 48 	lsr	r8,r8,r3
8000bcc4:	f6 09 09 4c 	lsl	r12,r11,r9
8000bcc8:	f4 03 0a 42 	lsr	r2,r10,r3
8000bccc:	ef 46 ff f4 	st.w	r7[-12],r6
8000bcd0:	f6 03 0a 43 	lsr	r3,r11,r3
8000bcd4:	18 42       	or	r2,r12
8000bcd6:	f1 ee 10 0c 	or	r12,r8,lr
8000bcda:	f8 01 16 10 	lsr	r1,r12,0x10
8000bcde:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bce2:	e6 01 0d 04 	divu	r4,r3,r1
8000bce6:	e4 03 16 10 	lsr	r3,r2,0x10
8000bcea:	08 9e       	mov	lr,r4
8000bcec:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000bcf0:	e8 06 02 48 	mul	r8,r4,r6
8000bcf4:	10 33       	cp.w	r3,r8
8000bcf6:	c0 a2       	brcc	8000bd0a <__avr32_udiv64+0x1fe>
8000bcf8:	20 1e       	sub	lr,1
8000bcfa:	18 03       	add	r3,r12
8000bcfc:	18 33       	cp.w	r3,r12
8000bcfe:	c0 63       	brcs	8000bd0a <__avr32_udiv64+0x1fe>
8000bd00:	10 33       	cp.w	r3,r8
8000bd02:	f7 be 03 01 	sublo	lr,1
8000bd06:	e7 dc e3 03 	addcs	r3,r3,r12
8000bd0a:	10 13       	sub	r3,r8
8000bd0c:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000bd10:	e6 01 0d 00 	divu	r0,r3,r1
8000bd14:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bd18:	00 98       	mov	r8,r0
8000bd1a:	e0 06 02 46 	mul	r6,r0,r6
8000bd1e:	0c 3b       	cp.w	r11,r6
8000bd20:	c0 a2       	brcc	8000bd34 <__avr32_udiv64+0x228>
8000bd22:	20 18       	sub	r8,1
8000bd24:	18 0b       	add	r11,r12
8000bd26:	18 3b       	cp.w	r11,r12
8000bd28:	c0 63       	brcs	8000bd34 <__avr32_udiv64+0x228>
8000bd2a:	0c 3b       	cp.w	r11,r6
8000bd2c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bd30:	f7 b8 03 01 	sublo	r8,1
8000bd34:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000bd38:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000bd3c:	0c 1b       	sub	r11,r6
8000bd3e:	f0 04 06 42 	mulu.d	r2,r8,r4
8000bd42:	06 95       	mov	r5,r3
8000bd44:	16 35       	cp.w	r5,r11
8000bd46:	e0 8b 00 0a 	brhi	8000bd5a <__avr32_udiv64+0x24e>
8000bd4a:	5f 0b       	sreq	r11
8000bd4c:	f4 09 09 49 	lsl	r9,r10,r9
8000bd50:	12 32       	cp.w	r2,r9
8000bd52:	5f b9       	srhi	r9
8000bd54:	f7 e9 00 09 	and	r9,r11,r9
8000bd58:	c0 60       	breq	8000bd64 <__avr32_udiv64+0x258>
8000bd5a:	20 18       	sub	r8,1
8000bd5c:	30 09       	mov	r9,0
8000bd5e:	c0 38       	rjmp	8000bd64 <__avr32_udiv64+0x258>
8000bd60:	30 09       	mov	r9,0
8000bd62:	12 98       	mov	r8,r9
8000bd64:	10 9a       	mov	r10,r8
8000bd66:	12 93       	mov	r3,r9
8000bd68:	10 92       	mov	r2,r8
8000bd6a:	12 9b       	mov	r11,r9
8000bd6c:	2f dd       	sub	sp,-12
8000bd6e:	d8 32       	popm	r0-r7,pc

8000bd70 <__avr32_umod64>:
8000bd70:	d4 31       	pushm	r0-r7,lr
8000bd72:	1a 97       	mov	r7,sp
8000bd74:	20 3d       	sub	sp,12
8000bd76:	10 9c       	mov	r12,r8
8000bd78:	12 95       	mov	r5,r9
8000bd7a:	14 9e       	mov	lr,r10
8000bd7c:	16 91       	mov	r1,r11
8000bd7e:	16 96       	mov	r6,r11
8000bd80:	58 09       	cp.w	r9,0
8000bd82:	e0 81 00 81 	brne	8000be84 <__avr32_umod64+0x114>
8000bd86:	16 38       	cp.w	r8,r11
8000bd88:	e0 88 00 12 	brls	8000bdac <__avr32_umod64+0x3c>
8000bd8c:	f0 08 12 00 	clz	r8,r8
8000bd90:	c4 e0       	breq	8000be2c <__avr32_umod64+0xbc>
8000bd92:	f6 08 09 46 	lsl	r6,r11,r8
8000bd96:	f8 08 09 4c 	lsl	r12,r12,r8
8000bd9a:	f0 0b 11 20 	rsub	r11,r8,32
8000bd9e:	f4 08 09 4e 	lsl	lr,r10,r8
8000bda2:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000bda6:	f7 e6 10 06 	or	r6,r11,r6
8000bdaa:	c4 18       	rjmp	8000be2c <__avr32_umod64+0xbc>
8000bdac:	58 08       	cp.w	r8,0
8000bdae:	c0 51       	brne	8000bdb8 <__avr32_umod64+0x48>
8000bdb0:	30 19       	mov	r9,1
8000bdb2:	f2 08 0d 08 	divu	r8,r9,r8
8000bdb6:	10 9c       	mov	r12,r8
8000bdb8:	f8 08 12 00 	clz	r8,r12
8000bdbc:	c0 31       	brne	8000bdc2 <__avr32_umod64+0x52>
8000bdbe:	18 16       	sub	r6,r12
8000bdc0:	c3 68       	rjmp	8000be2c <__avr32_umod64+0xbc>
8000bdc2:	f0 03 11 20 	rsub	r3,r8,32
8000bdc6:	f4 03 0a 4b 	lsr	r11,r10,r3
8000bdca:	f8 08 09 4c 	lsl	r12,r12,r8
8000bdce:	ec 08 09 49 	lsl	r9,r6,r8
8000bdd2:	ec 03 0a 43 	lsr	r3,r6,r3
8000bdd6:	f7 e9 10 09 	or	r9,r11,r9
8000bdda:	f8 05 16 10 	lsr	r5,r12,0x10
8000bdde:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bde2:	e6 05 0d 02 	divu	r2,r3,r5
8000bde6:	f2 0e 16 10 	lsr	lr,r9,0x10
8000bdea:	ec 02 02 4b 	mul	r11,r6,r2
8000bdee:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000bdf2:	16 3e       	cp.w	lr,r11
8000bdf4:	c0 72       	brcc	8000be02 <__avr32_umod64+0x92>
8000bdf6:	18 0e       	add	lr,r12
8000bdf8:	18 3e       	cp.w	lr,r12
8000bdfa:	c0 43       	brcs	8000be02 <__avr32_umod64+0x92>
8000bdfc:	16 3e       	cp.w	lr,r11
8000bdfe:	fd dc e3 0e 	addcs	lr,lr,r12
8000be02:	fc 0b 01 03 	sub	r3,lr,r11
8000be06:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000be0a:	e6 05 0d 02 	divu	r2,r3,r5
8000be0e:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000be12:	a5 36       	mul	r6,r2
8000be14:	0c 39       	cp.w	r9,r6
8000be16:	c0 72       	brcc	8000be24 <__avr32_umod64+0xb4>
8000be18:	18 09       	add	r9,r12
8000be1a:	18 39       	cp.w	r9,r12
8000be1c:	c0 43       	brcs	8000be24 <__avr32_umod64+0xb4>
8000be1e:	0c 39       	cp.w	r9,r6
8000be20:	f3 dc e3 09 	addcs	r9,r9,r12
8000be24:	f2 06 01 06 	sub	r6,r9,r6
8000be28:	f4 08 09 4e 	lsl	lr,r10,r8
8000be2c:	f8 0a 16 10 	lsr	r10,r12,0x10
8000be30:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000be34:	ec 0a 0d 02 	divu	r2,r6,r10
8000be38:	fc 09 16 10 	lsr	r9,lr,0x10
8000be3c:	ea 02 02 4b 	mul	r11,r5,r2
8000be40:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000be44:	16 39       	cp.w	r9,r11
8000be46:	c0 72       	brcc	8000be54 <__avr32_umod64+0xe4>
8000be48:	18 09       	add	r9,r12
8000be4a:	18 39       	cp.w	r9,r12
8000be4c:	c0 43       	brcs	8000be54 <__avr32_umod64+0xe4>
8000be4e:	16 39       	cp.w	r9,r11
8000be50:	f3 dc e3 09 	addcs	r9,r9,r12
8000be54:	f2 0b 01 0b 	sub	r11,r9,r11
8000be58:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000be5c:	f6 0a 0d 0a 	divu	r10,r11,r10
8000be60:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000be64:	ea 0a 02 4a 	mul	r10,r5,r10
8000be68:	14 3e       	cp.w	lr,r10
8000be6a:	c0 72       	brcc	8000be78 <__avr32_umod64+0x108>
8000be6c:	18 0e       	add	lr,r12
8000be6e:	18 3e       	cp.w	lr,r12
8000be70:	c0 43       	brcs	8000be78 <__avr32_umod64+0x108>
8000be72:	14 3e       	cp.w	lr,r10
8000be74:	fd dc e3 0e 	addcs	lr,lr,r12
8000be78:	fc 0a 01 0a 	sub	r10,lr,r10
8000be7c:	30 0b       	mov	r11,0
8000be7e:	f4 08 0a 4a 	lsr	r10,r10,r8
8000be82:	c7 b8       	rjmp	8000bf78 <__avr32_umod64+0x208>
8000be84:	16 39       	cp.w	r9,r11
8000be86:	e0 8b 00 79 	brhi	8000bf78 <__avr32_umod64+0x208>
8000be8a:	f2 09 12 00 	clz	r9,r9
8000be8e:	c1 21       	brne	8000beb2 <__avr32_umod64+0x142>
8000be90:	10 3a       	cp.w	r10,r8
8000be92:	5f 2b       	srhs	r11
8000be94:	0a 31       	cp.w	r1,r5
8000be96:	5f ba       	srhi	r10
8000be98:	f7 ea 10 0a 	or	r10,r11,r10
8000be9c:	f2 0a 18 00 	cp.b	r10,r9
8000bea0:	c0 60       	breq	8000beac <__avr32_umod64+0x13c>
8000bea2:	fc 08 01 0c 	sub	r12,lr,r8
8000bea6:	e2 05 01 46 	sbc	r6,r1,r5
8000beaa:	18 9e       	mov	lr,r12
8000beac:	0c 9b       	mov	r11,r6
8000beae:	1c 9a       	mov	r10,lr
8000beb0:	c6 48       	rjmp	8000bf78 <__avr32_umod64+0x208>
8000beb2:	ea 09 09 4c 	lsl	r12,r5,r9
8000beb6:	f2 06 11 20 	rsub	r6,r9,32
8000beba:	f6 09 09 4b 	lsl	r11,r11,r9
8000bebe:	f0 09 09 42 	lsl	r2,r8,r9
8000bec2:	ef 46 ff f4 	st.w	r7[-12],r6
8000bec6:	f0 06 0a 48 	lsr	r8,r8,r6
8000beca:	18 48       	or	r8,r12
8000becc:	e2 06 0a 4c 	lsr	r12,r1,r6
8000bed0:	f4 09 09 43 	lsl	r3,r10,r9
8000bed4:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000bed8:	f4 06 0a 4a 	lsr	r10,r10,r6
8000bedc:	16 4a       	or	r10,r11
8000bede:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bee2:	f8 0b 0d 04 	divu	r4,r12,r11
8000bee6:	f4 0c 16 10 	lsr	r12,r10,0x10
8000beea:	08 91       	mov	r1,r4
8000beec:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000bef0:	e8 0e 02 46 	mul	r6,r4,lr
8000bef4:	0c 3c       	cp.w	r12,r6
8000bef6:	c0 a2       	brcc	8000bf0a <__avr32_umod64+0x19a>
8000bef8:	20 11       	sub	r1,1
8000befa:	10 0c       	add	r12,r8
8000befc:	10 3c       	cp.w	r12,r8
8000befe:	c0 63       	brcs	8000bf0a <__avr32_umod64+0x19a>
8000bf00:	0c 3c       	cp.w	r12,r6
8000bf02:	f7 b1 03 01 	sublo	r1,1
8000bf06:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000bf0a:	0c 1c       	sub	r12,r6
8000bf0c:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000bf10:	f8 0b 0d 04 	divu	r4,r12,r11
8000bf14:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000bf18:	08 96       	mov	r6,r4
8000bf1a:	e8 0e 02 4e 	mul	lr,r4,lr
8000bf1e:	1c 3b       	cp.w	r11,lr
8000bf20:	c0 a2       	brcc	8000bf34 <__avr32_umod64+0x1c4>
8000bf22:	20 16       	sub	r6,1
8000bf24:	10 0b       	add	r11,r8
8000bf26:	10 3b       	cp.w	r11,r8
8000bf28:	c0 63       	brcs	8000bf34 <__avr32_umod64+0x1c4>
8000bf2a:	1c 3b       	cp.w	r11,lr
8000bf2c:	f7 b6 03 01 	sublo	r6,1
8000bf30:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000bf34:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000bf38:	1c 1b       	sub	r11,lr
8000bf3a:	e2 02 06 40 	mulu.d	r0,r1,r2
8000bf3e:	00 9e       	mov	lr,r0
8000bf40:	02 9c       	mov	r12,r1
8000bf42:	16 3c       	cp.w	r12,r11
8000bf44:	e0 8b 00 08 	brhi	8000bf54 <__avr32_umod64+0x1e4>
8000bf48:	5f 06       	sreq	r6
8000bf4a:	06 30       	cp.w	r0,r3
8000bf4c:	5f ba       	srhi	r10
8000bf4e:	ed ea 00 0a 	and	r10,r6,r10
8000bf52:	c0 60       	breq	8000bf5e <__avr32_umod64+0x1ee>
8000bf54:	fc 02 01 04 	sub	r4,lr,r2
8000bf58:	f8 08 01 4c 	sbc	r12,r12,r8
8000bf5c:	08 9e       	mov	lr,r4
8000bf5e:	e6 0e 01 0a 	sub	r10,r3,lr
8000bf62:	f6 0c 01 4c 	sbc	r12,r11,r12
8000bf66:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000bf6a:	f8 09 0a 4b 	lsr	r11,r12,r9
8000bf6e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bf72:	f8 01 09 4c 	lsl	r12,r12,r1
8000bf76:	18 4a       	or	r10,r12
8000bf78:	2f dd       	sub	sp,-12
8000bf7a:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c000 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c000:	c0 08       	rjmp	8000c000 <_evba>
	...

8000c004 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c004:	c0 08       	rjmp	8000c004 <_handle_TLB_Multiple_Hit>
	...

8000c008 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c008:	c0 08       	rjmp	8000c008 <_handle_Bus_Error_Data_Fetch>
	...

8000c00c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c00c:	c0 08       	rjmp	8000c00c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c010 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c010:	c0 08       	rjmp	8000c010 <_handle_NMI>
	...

8000c014 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c014:	c0 08       	rjmp	8000c014 <_handle_Instruction_Address>
	...

8000c018 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c018:	c0 08       	rjmp	8000c018 <_handle_ITLB_Protection>
	...

8000c01c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c01c:	c0 08       	rjmp	8000c01c <_handle_Breakpoint>
	...

8000c020 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c020:	c0 08       	rjmp	8000c020 <_handle_Illegal_Opcode>
	...

8000c024 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c024:	c0 08       	rjmp	8000c024 <_handle_Unimplemented_Instruction>
	...

8000c028 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c028:	c0 08       	rjmp	8000c028 <_handle_Privilege_Violation>
	...

8000c02c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c02c:	c0 08       	rjmp	8000c02c <_handle_Floating_Point>
	...

8000c030 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c030:	c0 08       	rjmp	8000c030 <_handle_Coprocessor_Absent>
	...

8000c034 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c034:	c0 08       	rjmp	8000c034 <_handle_Data_Address_Read>
	...

8000c038 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c038:	c0 08       	rjmp	8000c038 <_handle_Data_Address_Write>
	...

8000c03c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c03c:	c0 08       	rjmp	8000c03c <_handle_DTLB_Protection_Read>
	...

8000c040 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c040:	c0 08       	rjmp	8000c040 <_handle_DTLB_Protection_Write>
	...

8000c044 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c044:	c0 08       	rjmp	8000c044 <_handle_DTLB_Modified>
	...

8000c050 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c050:	c0 08       	rjmp	8000c050 <_handle_ITLB_Miss>
	...

8000c060 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c060:	c0 08       	rjmp	8000c060 <_handle_DTLB_Miss_Read>
	...

8000c070 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c070:	c0 08       	rjmp	8000c070 <_handle_DTLB_Miss_Write>
	...

8000c100 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c100:	fe cf 70 b8 	sub	pc,pc,28856

8000c104 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c104:	30 0c       	mov	r12,0
8000c106:	fe b0 c4 15 	rcall	80004930 <_get_interrupt_handler>
8000c10a:	58 0c       	cp.w	r12,0
8000c10c:	f8 0f 17 10 	movne	pc,r12
8000c110:	d6 03       	rete

8000c112 <_int1>:
8000c112:	30 1c       	mov	r12,1
8000c114:	fe b0 c4 0e 	rcall	80004930 <_get_interrupt_handler>
8000c118:	58 0c       	cp.w	r12,0
8000c11a:	f8 0f 17 10 	movne	pc,r12
8000c11e:	d6 03       	rete

8000c120 <_int2>:
8000c120:	30 2c       	mov	r12,2
8000c122:	fe b0 c4 07 	rcall	80004930 <_get_interrupt_handler>
8000c126:	58 0c       	cp.w	r12,0
8000c128:	f8 0f 17 10 	movne	pc,r12
8000c12c:	d6 03       	rete

8000c12e <_int3>:
8000c12e:	30 3c       	mov	r12,3
8000c130:	fe b0 c4 00 	rcall	80004930 <_get_interrupt_handler>
8000c134:	58 0c       	cp.w	r12,0
8000c136:	f8 0f 17 10 	movne	pc,r12
8000c13a:	d6 03       	rete

8000c13c <ipr_val>:
8000c13c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c14c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c15c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c16c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c17c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c18c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c19c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1fc:	d7 03 d7 03                                         ....
